pub fn sub_830D55B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D55B0 size=240
    let mut pc: u32 = 0x830D55B0;
    'dispatch: loop {
        match pc {
            0x830D55B0 => {
    //   block [0x830D55B0..0x830D560C)
	// 830D55B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D55B4: 4BBD3E59  bl 0x82ca940c
	ctx.lr = 0x830D55B8;
	sub_82CA93D0(ctx, base);
	// 830D55B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D55BC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830D55C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830D55C4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830D55C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D55CC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830D55D0: 4BC809C9  bl 0x82d55f98
	ctx.lr = 0x830D55D4;
	sub_82D55F98(ctx, base);
	// 830D55D4: 897F0048  lbz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 830D55D8: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 830D55DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D55E0: 419A002C  beq cr6, 0x830d560c
	if ctx.cr[6].eq {
	pc = 0x830D560C; continue 'dispatch;
	}
	// 830D55E4: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 830D55E8: 89610057  lbz r11, 0x57(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 830D55EC: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 830D55F0: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830D55F4: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 830D55F8: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 830D55FC: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 830D5600: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 830D5604: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 830D5608: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x830D560C; continue 'dispatch;
            }
            0x830D560C => {
    //   block [0x830D560C..0x830D56A0)
	// 830D560C: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	// 830D5610: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D5614: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 830D5618: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 830D561C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830D5620: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830D5624: 9941005C  stb r10, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u8 ) };
	// 830D5628: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D562C: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D5630: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D5634: 4E800421  bctrl
	ctx.lr = 0x830D5638;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D5638: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D563C: 4BC80115  bl 0x82d55750
	ctx.lr = 0x830D5640;
	sub_82D55750(ctx, base);
	// 830D5640: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D5644: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830D5648: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830D564C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5650: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D5654: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D5658: 4E800421  bctrl
	ctx.lr = 0x830D565C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D565C: 7CBD1850  subf r5, r29, r3
	ctx.r[5].s64 = ctx.r[3].s64 - ctx.r[29].s64;
	// 830D5660: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D5664: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 830D5668: 4BC893F1  bl 0x82d5ea58
	ctx.lr = 0x830D566C;
	sub_82D5EA58(ctx, base);
	// 830D566C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D5670: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D5674: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5678: 4BC835B1  bl 0x82d58c28
	ctx.lr = 0x830D567C;
	sub_82D58C28(ctx, base);
	// 830D567C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830D5680: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D5684: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D5688: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D568C: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 830D5690: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 830D5694: 4E800421  bctrl
	ctx.lr = 0x830D5698;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D5698: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830D569C: 4BBD3DC0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D56A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D56A0 size=276
    let mut pc: u32 = 0x830D56A0;
    'dispatch: loop {
        match pc {
            0x830D56A0 => {
    //   block [0x830D56A0..0x830D573C)
	// 830D56A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D56A4: 4BBD3D61  bl 0x82ca9404
	ctx.lr = 0x830D56A8;
	sub_82CA93D0(ctx, base);
	// 830D56A8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D56AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830D56B0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830D56B4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830D56B8: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 830D56BC: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 830D56C0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830D56C4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830D56C8: 4BC83679  bl 0x82d58d40
	ctx.lr = 0x830D56CC;
	sub_82D58D40(ctx, base);
	// 830D56CC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D56D0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830D56D4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830D56D8: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 830D56DC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830D56E0: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 830D56E4: 3D6057E0  lis r11, 0x57e0
	ctx.r[11].s64 = 1474297856;
	// 830D56E8: 9BE100B8  stb r31, 0xb8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[31].u8 ) };
	// 830D56EC: 616BE057  ori r11, r11, 0xe057
	ctx.r[11].u64 = ctx.r[11].u64 | 57431;
	// 830D56F0: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 830D56F4: 3D6010C0  lis r11, 0x10c0
	ctx.r[11].s64 = 281018368;
	// 830D56F8: 616BC010  ori r11, r11, 0xc010
	ctx.r[11].u64 = ctx.r[11].u64 | 49168;
	// 830D56FC: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 830D5700: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 830D5704: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 830D5708: 4BC83629  bl 0x82d58d30
	ctx.lr = 0x830D570C;
	sub_82D58D30(ctx, base);
	// 830D570C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 830D5710: 938100A4  stw r28, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[28].u32 ) };
	// 830D5714: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 830D5718: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 830D571C: 4BC83625  bl 0x82d58d40
	ctx.lr = 0x830D5720;
	sub_82D58D40(ctx, base);
	// 830D5720: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D5724: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 830D5728: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830D572C: 409A0010  bne cr6, 0x830d573c
	if !ctx.cr[6].eq {
	pc = 0x830D573C; continue 'dispatch;
	}
	// 830D5730: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 830D5734: 4800344D  bl 0x830d8b80
	ctx.lr = 0x830D5738;
	sub_830D8B80(ctx, base);
	// 830D5738: 4800000C  b 0x830d5744
	pc = 0x830D5744; continue 'dispatch;
            }
            0x830D573C => {
    //   block [0x830D573C..0x830D5744)
	// 830D573C: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830D5740: 4BC834D9  bl 0x82d58c18
	ctx.lr = 0x830D5744;
	sub_82D58C18(ctx, base);
	pc = 0x830D5744; continue 'dispatch;
            }
            0x830D5744 => {
    //   block [0x830D5744..0x830D57B4)
	// 830D5744: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 830D5748: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D574C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 830D5750: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 830D5754: 38CBB324  addi r6, r11, -0x4cdc
	ctx.r[6].s64 = ctx.r[11].s64 + -19676;
	// 830D5758: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830D575C: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 830D5760: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 830D5764: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 830D5768: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 830D576C: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D5770: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830D5774: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 830D5778: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D577C: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 830D5780: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830D5784: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 830D5788: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 830D578C: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 830D5790: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 830D5794: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830D5798: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 830D579C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 830D57A0: 4E800421  bctrl
	ctx.lr = 0x830D57A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D57A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D57A8: 4BC9FE81  bl 0x82d75628
	ctx.lr = 0x830D57AC;
	sub_82D75628(ctx, base);
	// 830D57AC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 830D57B0: 4BBD3CA4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D57B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D57B8 size=248
    let mut pc: u32 = 0x830D57B8;
    'dispatch: loop {
        match pc {
            0x830D57B8 => {
    //   block [0x830D57B8..0x830D581C)
	// 830D57B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D57BC: 4BBD3C51  bl 0x82ca940c
	ctx.lr = 0x830D57C0;
	sub_82CA93D0(ctx, base);
	// 830D57C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D57C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830D57C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830D57CC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D57D0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D57D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D57D8: 4E800421  bctrl
	ctx.lr = 0x830D57DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D57DC: 3961005C  addi r11, r1, 0x5c
	ctx.r[11].s64 = ctx.r[1].s64 + 92;
	// 830D57E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830D57E4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830D57E8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830D57EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830D57F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830D57F4: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 830D57F8: 616B0020  ori r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 | 32;
	// 830D57FC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830D5800: 4099004C  ble cr6, 0x830d584c
	if !ctx.cr[6].gt {
	pc = 0x830D584C; continue 'dispatch;
	}
	// 830D5804: 2F1F0020  cmpwi cr6, r31, 0x20
	ctx.cr[6].compare_i32(ctx.r[31].s32, 32, &mut ctx.xer);
	// 830D5808: 40990020  ble cr6, 0x830d5828
	if !ctx.cr[6].gt {
	pc = 0x830D5828; continue 'dispatch;
	}
	// 830D580C: 2F1F0040  cmpwi cr6, r31, 0x40
	ctx.cr[6].compare_i32(ctx.r[31].s32, 64, &mut ctx.xer);
	// 830D5810: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 830D5814: 41980008  blt cr6, 0x830d581c
	if ctx.cr[6].lt {
	pc = 0x830D581C; continue 'dispatch;
	}
	// 830D5818: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
            }
            0x830D581C => {
    //   block [0x830D581C..0x830D5828)
	// 830D581C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830D5820: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D5824: 4BC816ED  bl 0x82d56f10
	ctx.lr = 0x830D5828;
	sub_82D56F10(ctx, base);
	pc = 0x830D5828; continue 'dispatch;
            }
            0x830D5828 => {
    //   block [0x830D5828..0x830D5838)
	// 830D5828: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830D582C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830D5830: 4099001C  ble cr6, 0x830d584c
	if !ctx.cr[6].gt {
	pc = 0x830D584C; continue 'dispatch;
	}
	// 830D5834: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	pc = 0x830D5838; continue 'dispatch;
            }
            0x830D5838 => {
    //   block [0x830D5838..0x830D584C)
	// 830D5838: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D583C: 7D4959AE  stbx r10, r9, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u8) };
	// 830D5840: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D5844: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830D5848: 4198FFF0  blt cr6, 0x830d5838
	if ctx.cr[6].lt {
	pc = 0x830D5838; continue 'dispatch;
	}
	pc = 0x830D584C; continue 'dispatch;
            }
            0x830D584C => {
    //   block [0x830D584C..0x830D587C)
	// 830D584C: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 830D5850: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830D5854: 7D6BE838  and r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[29].u64;
	// 830D5858: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D585C: 419A0020  beq cr6, 0x830d587c
	if ctx.cr[6].eq {
	pc = 0x830D587C; continue 'dispatch;
	}
	// 830D5860: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5864: 7CABF850  subf r5, r11, r31
	ctx.r[5].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 830D5868: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D586C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D5870: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D5874: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D5878: 4E800421  bctrl
	ctx.lr = 0x830D587C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830D587C => {
    //   block [0x830D587C..0x830D58A8)
	// 830D587C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D5880: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D5884: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D5888: 409A0020  bne cr6, 0x830d58a8
	if !ctx.cr[6].eq {
	pc = 0x830D58A8; continue 'dispatch;
	}
	// 830D588C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5890: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D5894: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D5898: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D589C: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D58A0: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D58A4: 4BC7FA25  bl 0x82d552c8
	ctx.lr = 0x830D58A8;
	sub_82D552C8(ctx, base);
	pc = 0x830D58A8; continue 'dispatch;
            }
            0x830D58A8 => {
    //   block [0x830D58A8..0x830D58B0)
	// 830D58A8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830D58AC: 4BBD3BB0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D58B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D58B0 size=180
    let mut pc: u32 = 0x830D58B0;
    'dispatch: loop {
        match pc {
            0x830D58B0 => {
    //   block [0x830D58B0..0x830D58E8)
	// 830D58B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D58B4: 4BBD3B51  bl 0x82ca9404
	ctx.lr = 0x830D58B8;
	sub_82CA93D0(ctx, base);
	// 830D58B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D58BC: 3B640004  addi r27, r4, 4
	ctx.r[27].s64 = ctx.r[4].s64 + 4;
	// 830D58C0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830D58C4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D58C8: 83FC0060  lwz r31, 0x60(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D58CC: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D58D0: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830D58D4: 40980024  bge cr6, 0x830d58f8
	if !ctx.cr[6].lt {
	pc = 0x830D58F8; continue 'dispatch;
	}
	// 830D58D8: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D58DC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D58E0: 41980008  blt cr6, 0x830d58e8
	if ctx.cr[6].lt {
	pc = 0x830D58E8; continue 'dispatch;
	}
	// 830D58E4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x830D58E8; continue 'dispatch;
            }
            0x830D58E8 => {
    //   block [0x830D58E8..0x830D58F8)
	// 830D58E8: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 830D58EC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830D58F0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830D58F4: 4BC8161D  bl 0x82d56f10
	ctx.lr = 0x830D58F8;
	sub_82D56F10(ctx, base);
	pc = 0x830D58F8; continue 'dispatch;
            }
            0x830D58F8 => {
    //   block [0x830D58F8..0x830D592C)
	// 830D58F8: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D58FC: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5900: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 830D5904: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 830D5908: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830D590C: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830D5910: 4BC83431  bl 0x82d58d40
	ctx.lr = 0x830D5914;
	sub_82D58D40(ctx, base);
	// 830D5914: 817C0060  lwz r11, 0x60(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D5918: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830D591C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D5920: 4099003C  ble cr6, 0x830d595c
	if !ctx.cr[6].gt {
	pc = 0x830D595C; continue 'dispatch;
	}
	// 830D5924: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830D5928: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x830D592C; continue 'dispatch;
            }
            0x830D592C => {
    //   block [0x830D592C..0x830D595C)
	// 830D592C: 815C005C  lwz r10, 0x5c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(92 as u32) ) } as u64;
	// 830D5930: 38A00013  li r5, 0x13
	ctx.r[5].s64 = 19;
	// 830D5934: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5938: 7C6BEA14  add r3, r11, r29
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830D593C: 7C8AF02E  lwzx r4, r10, r30
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830D5940: 4BC832D9  bl 0x82d58c18
	ctx.lr = 0x830D5944;
	sub_82D58C18(ctx, base);
	// 830D5944: 817C0060  lwz r11, 0x60(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D5948: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830D594C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830D5950: 3BBD0030  addi r29, r29, 0x30
	ctx.r[29].s64 = ctx.r[29].s64 + 48;
	// 830D5954: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D5958: 4198FFD4  blt cr6, 0x830d592c
	if ctx.cr[6].lt {
	pc = 0x830D592C; continue 'dispatch;
	}
	pc = 0x830D595C; continue 'dispatch;
            }
            0x830D595C => {
    //   block [0x830D595C..0x830D5964)
	// 830D595C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830D5960: 4BBD3AF4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D5968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D5968 size=1196
    let mut pc: u32 = 0x830D5968;
    'dispatch: loop {
        match pc {
            0x830D5968 => {
    //   block [0x830D5968..0x830D59B8)
	// 830D5968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D596C: 4BBD3A6D  bl 0x82ca93d8
	ctx.lr = 0x830D5970;
	sub_82CA93D0(ctx, base);
	// 830D5970: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D5974: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830D5978: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 830D597C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830D5980: 7CB02B78  mr r16, r5
	ctx.r[16].u64 = ctx.r[5].u64;
	// 830D5984: 88BE0048  lbz r5, 0x48(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 830D5988: 809E001C  lwz r4, 0x1c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D598C: 4BC88585  bl 0x82d5df10
	ctx.lr = 0x830D5990;
	sub_82D5DF10(ctx, base);
	// 830D5990: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D5994: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830D5998: 3EE08000  lis r23, -0x8000
	ctx.r[23].s64 = -2147483648;
	// 830D599C: 7F51D378  mr r17, r26
	ctx.r[17].u64 = ctx.r[26].u64;
	// 830D59A0: 3A80FFFF  li r20, -1
	ctx.r[20].s64 = -1;
	// 830D59A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D59A8: 409902C8  ble cr6, 0x830d5c70
	if !ctx.cr[6].gt {
	pc = 0x830D5C70; continue 'dispatch;
	}
	// 830D59AC: 7F55D378  mr r21, r26
	ctx.r[21].u64 = ctx.r[26].u64;
	// 830D59B0: 7F56D378  mr r22, r26
	ctx.r[22].u64 = ctx.r[26].u64;
	// 830D59B4: 3A40FFFD  li r18, -3
	ctx.r[18].s64 = -3;
	pc = 0x830D59B8; continue 'dispatch;
            }
            0x830D59B8 => {
    //   block [0x830D59B8..0x830D5A04)
	// 830D59B8: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 830D59BC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D59C0: 7D6BAA14  add r11, r11, r21
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[21].u64;
	// 830D59C4: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 830D59C8: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 830D59CC: 7F6AB214  add r27, r10, r22
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[22].u64;
	// 830D59D0: 3BAB000C  addi r29, r11, 0xc
	ctx.r[29].s64 = ctx.r[11].s64 + 12;
	// 830D59D4: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 830D59D8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D59DC: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830D59E0: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D59E4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830D59E8: 40990034  ble cr6, 0x830d5a1c
	if !ctx.cr[6].gt {
	pc = 0x830D5A1C; continue 'dispatch;
	}
	// 830D59EC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830D59F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D59F4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830D59F8: 4BC81519  bl 0x82d56f10
	ctx.lr = 0x830D59FC;
	sub_82D56F10(ctx, base);
	// 830D59FC: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 830D5A00: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x830D5A04; continue 'dispatch;
            }
            0x830D5A04 => {
    //   block [0x830D5A04..0x830D5A1C)
	// 830D5A04: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D5A08: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830D5A0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D5A10: 7E8A492E  stwx r20, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[20].u32) };
	// 830D5A14: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830D5A18: 409AFFEC  bne cr6, 0x830d5a04
	if !ctx.cr[6].eq {
	pc = 0x830D5A04; continue 'dispatch;
	}
	pc = 0x830D5A1C; continue 'dispatch;
            }
            0x830D5A1C => {
    //   block [0x830D5A1C..0x830D5A3C)
	// 830D5A1C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 830D5A20: 7F58D378  mr r24, r26
	ctx.r[24].u64 = ctx.r[26].u64;
	// 830D5A24: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D5A28: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D5A2C: 409900A0  ble cr6, 0x830d5acc
	if !ctx.cr[6].gt {
	pc = 0x830D5ACC; continue 'dispatch;
	}
	// 830D5A30: 3B330014  addi r25, r19, 0x14
	ctx.r[25].s64 = ctx.r[19].s64 + 20;
	// 830D5A34: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 830D5A38: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	pc = 0x830D5A3C; continue 'dispatch;
            }
            0x830D5A3C => {
    //   block [0x830D5A3C..0x830D5AB8)
	// 830D5A3C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5A40: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 830D5A44: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830D5A48: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 830D5A4C: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D5A50: 4BC8AC39  bl 0x82d60688
	ctx.lr = 0x830D5A54;
	sub_82D60688(ctx, base);
	// 830D5A54: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D5A58: 41980060  blt cr6, 0x830d5ab8
	if ctx.cr[6].lt {
	pc = 0x830D5AB8; continue 'dispatch;
	}
	// 830D5A5C: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D5A60: 546B1838  slwi r11, r3, 3
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D5A64: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D5A68: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D5A6C: 4198004C  blt cr6, 0x830d5ab8
	if ctx.cr[6].lt {
	pc = 0x830D5AB8; continue 'dispatch;
	}
	// 830D5A70: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5A74: 813B0014  lwz r9, 0x14(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D5A78: 7D5C502E  lwzx r10, r28, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D5A7C: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 830D5A80: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D5A84: 7D5F492E  stwx r10, r31, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 830D5A88: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D5A8C: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D5A90: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 830D5A94: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830D5A98: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830D5A9C: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D5AA0: 7D3F5214  add r9, r31, r10
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 830D5AA4: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D5AA8: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 830D5AAC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D5AB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D5AB4: 91690008  stw r11, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x830D5AB8; continue 'dispatch;
            }
            0x830D5AB8 => {
    //   block [0x830D5AB8..0x830D5ACC)
	// 830D5AB8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D5ABC: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 830D5AC0: 3B9C000C  addi r28, r28, 0xc
	ctx.r[28].s64 = ctx.r[28].s64 + 12;
	// 830D5AC4: 7F185800  cmpw cr6, r24, r11
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D5AC8: 4198FF74  blt cr6, 0x830d5a3c
	if ctx.cr[6].lt {
	pc = 0x830D5A3C; continue 'dispatch;
	}
	pc = 0x830D5ACC; continue 'dispatch;
            }
            0x830D5ACC => {
    //   block [0x830D5ACC..0x830D5B2C)
	// 830D5ACC: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D5AD0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D5AD4: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D5AD8: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D5ADC: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D5AE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5AE4: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D5AE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D5AEC: 4E800421  bctrl
	ctx.lr = 0x830D5AF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D5AF0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830D5AF4: 80A1005C  lwz r5, 0x5c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830D5AF8: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D5AFC: 4BC8894D  bl 0x82d5e448
	ctx.lr = 0x830D5B00;
	sub_82D5E448(ctx, base);
	// 830D5B00: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D5B04: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D5B08: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D5B0C: 409A0020  bne cr6, 0x830d5b2c
	if !ctx.cr[6].eq {
	pc = 0x830D5B2C; continue 'dispatch;
	}
	// 830D5B10: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5B14: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D5B18: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D5B1C: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D5B20: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830D5B24: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D5B28: 4BC7F7A1  bl 0x82d552c8
	ctx.lr = 0x830D5B2C;
	sub_82D552C8(ctx, base);
            }
            0x830D5B2C => {
    //   block [0x830D5B2C..0x830D5B6C)
	// 830D5B2C: 817E003C  lwz r11, 0x3c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(60 as u32) ) } as u64;
	// 830D5B30: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D5B34: 7D6BAA14  add r11, r11, r21
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[21].u64;
	// 830D5B38: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 830D5B3C: 9341006C  stw r26, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[26].u32 ) };
	// 830D5B40: 7F2AB214  add r25, r10, r22
	ctx.r[25].u64 = ctx.r[10].u64 + ctx.r[22].u64;
	// 830D5B44: 3B8B0018  addi r28, r11, 0x18
	ctx.r[28].s64 = ctx.r[11].s64 + 24;
	// 830D5B48: 92E10070  stw r23, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[23].u32 ) };
	// 830D5B4C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D5B50: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830D5B54: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D5B58: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830D5B5C: 4099001C  ble cr6, 0x830d5b78
	if !ctx.cr[6].gt {
	pc = 0x830D5B78; continue 'dispatch;
	}
	// 830D5B60: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830D5B64: 41980008  blt cr6, 0x830d5b6c
	if ctx.cr[6].lt {
	pc = 0x830D5B6C; continue 'dispatch;
	}
	// 830D5B68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	pc = 0x830D5B6C; continue 'dispatch;
            }
            0x830D5B6C => {
    //   block [0x830D5B6C..0x830D5B78)
	// 830D5B6C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830D5B70: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 830D5B74: 4BC8139D  bl 0x82d56f10
	ctx.lr = 0x830D5B78;
	sub_82D56F10(ctx, base);
	pc = 0x830D5B78; continue 'dispatch;
            }
            0x830D5B78 => {
    //   block [0x830D5B78..0x830D5B98)
	// 830D5B78: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 830D5B7C: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	// 830D5B80: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D5B84: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D5B88: 40990070  ble cr6, 0x830d5bf8
	if !ctx.cr[6].gt {
	pc = 0x830D5BF8; continue 'dispatch;
	}
	// 830D5B8C: 3B1E0030  addi r24, r30, 0x30
	ctx.r[24].s64 = ctx.r[30].s64 + 48;
	// 830D5B90: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 830D5B94: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	pc = 0x830D5B98; continue 'dispatch;
            }
            0x830D5B98 => {
    //   block [0x830D5B98..0x830D5BF8)
	// 830D5B98: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5B9C: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 830D5BA0: 81590014  lwz r10, 0x14(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D5BA4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 830D5BA8: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830D5BAC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 830D5BB0: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830D5BB4: 7D7F512E  stwx r11, r31, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 830D5BB8: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830D5BBC: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830D5BC0: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 830D5BC4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5BC8: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 830D5BCC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D5BD0: 4BC89129  bl 0x82d5ecf8
	ctx.lr = 0x830D5BD4;
	sub_82D5ECF8(ctx, base);
	// 830D5BD4: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830D5BD8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 830D5BDC: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 830D5BE0: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830D5BE4: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 830D5BE8: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 830D5BEC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D5BF0: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D5BF4: 4198FFA4  blt cr6, 0x830d5b98
	if ctx.cr[6].lt {
	pc = 0x830D5B98; continue 'dispatch;
	}
	pc = 0x830D5BF8; continue 'dispatch;
            }
            0x830D5BF8 => {
    //   block [0x830D5BF8..0x830D5C58)
	// 830D5BF8: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D5BFC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D5C00: 81790020  lwz r11, 0x20(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D5C04: 81590014  lwz r10, 0x14(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D5C08: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D5C0C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5C10: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D5C14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D5C18: 4E800421  bctrl
	ctx.lr = 0x830D5C1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D5C1C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830D5C20: 80A1006C  lwz r5, 0x6c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830D5C24: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830D5C28: 4BC88821  bl 0x82d5e448
	ctx.lr = 0x830D5C2C;
	sub_82D5E448(ctx, base);
	// 830D5C2C: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830D5C30: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D5C34: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D5C38: 409A0020  bne cr6, 0x830d5c58
	if !ctx.cr[6].eq {
	pc = 0x830D5C58; continue 'dispatch;
	}
	// 830D5C3C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5C40: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D5C44: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D5C48: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830D5C4C: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830D5C50: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D5C54: 4BC7F675  bl 0x82d552c8
	ctx.lr = 0x830D5C58;
	sub_82D552C8(ctx, base);
            }
            0x830D5C58 => {
    //   block [0x830D5C58..0x830D5C70)
	// 830D5C58: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D5C5C: 3A310001  addi r17, r17, 1
	ctx.r[17].s64 = ctx.r[17].s64 + 1;
	// 830D5C60: 3AD60030  addi r22, r22, 0x30
	ctx.r[22].s64 = ctx.r[22].s64 + 48;
	// 830D5C64: 3AB50034  addi r21, r21, 0x34
	ctx.r[21].s64 = ctx.r[21].s64 + 52;
	// 830D5C68: 7F115800  cmpw cr6, r17, r11
	ctx.cr[6].compare_i32(ctx.r[17].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D5C6C: 4198FD4C  blt cr6, 0x830d59b8
	if ctx.cr[6].lt {
	pc = 0x830D59B8; continue 'dispatch;
	}
	pc = 0x830D5C70; continue 'dispatch;
            }
            0x830D5C70 => {
    //   block [0x830D5C70..0x830D5CAC)
	// 830D5C70: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D5C74: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D5C78: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 830D5C7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5C80: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D5C84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D5C88: 4E800421  bctrl
	ctx.lr = 0x830D5C8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D5C8C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D5C90: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 830D5C94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D5C98: 4099008C  ble cr6, 0x830d5d24
	if !ctx.cr[6].gt {
	pc = 0x830D5D24; continue 'dispatch;
	}
	// 830D5C9C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 830D5CA0: 3B9E0020  addi r28, r30, 0x20
	ctx.r[28].s64 = ctx.r[30].s64 + 32;
	// 830D5CA4: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 830D5CA8: 3B6BB354  addi r27, r11, -0x4cac
	ctx.r[27].s64 = ctx.r[11].s64 + -19628;
            }
            0x830D5CAC => {
    //   block [0x830D5CAC..0x830D5D24)
	// 830D5CAC: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5CB0: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 830D5CB4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D5CB8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 830D5CBC: 809E001C  lwz r4, 0x1c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D5CC0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D5CC4: 934100A0  stw r26, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[26].u32 ) };
	// 830D5CC8: 7CABFA14  add r5, r11, r31
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830D5CCC: 934100A4  stw r26, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[26].u32 ) };
	// 830D5CD0: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D5CD4: 92E100A8  stw r23, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[23].u32 ) };
	// 830D5CD8: 934100AC  stw r26, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[26].u32 ) };
	// 830D5CDC: 934100B0  stw r26, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[26].u32 ) };
	// 830D5CE0: 92E100B4  stw r23, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[23].u32 ) };
	// 830D5CE4: 934100B8  stw r26, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[26].u32 ) };
	// 830D5CE8: 934100BC  stw r26, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[26].u32 ) };
	// 830D5CEC: 92E100C0  stw r23, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[23].u32 ) };
	// 830D5CF0: 934100C4  stw r26, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[26].u32 ) };
	// 830D5CF4: 934100C8  stw r26, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[26].u32 ) };
	// 830D5CF8: 92E100CC  stw r23, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[23].u32 ) };
	// 830D5CFC: 934100D0  stw r26, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[26].u32 ) };
	// 830D5D00: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 830D5D04: 4E800421  bctrl
	ctx.lr = 0x830D5D08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D5D08: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830D5D0C: 4BC9F91D  bl 0x82d75628
	ctx.lr = 0x830D5D10;
	sub_82D75628(ctx, base);
	// 830D5D10: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D5D14: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830D5D18: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 830D5D1C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D5D20: 4198FF8C  blt cr6, 0x830d5cac
	if ctx.cr[6].lt {
	pc = 0x830D5CAC; continue 'dispatch;
	}
            }
            0x830D5D24 => {
    //   block [0x830D5D24..0x830D5E14)
	// 830D5D24: 807E001C  lwz r3, 0x1c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D5D28: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D5D2C: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 830D5D30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5D34: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D5D38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D5D3C: 4E800421  bctrl
	ctx.lr = 0x830D5D40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D5D40: 387E0020  addi r3, r30, 0x20
	ctx.r[3].s64 = ctx.r[30].s64 + 32;
	// 830D5D44: 4BFFE735  bl 0x830d4478
	ctx.lr = 0x830D5D48;
	sub_830D4478(ctx, base);
	// 830D5D48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830D5D4C: 3D40832F  lis r10, -0x7cd1
	ctx.r[10].s64 = -2094071808;
	// 830D5D50: 809E001C  lwz r4, 0x1c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D5D54: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830D5D58: 394A7D58  addi r10, r10, 0x7d58
	ctx.r[10].s64 = ctx.r[10].s64 + 32088;
	// 830D5D5C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5D60: 894A0001  lbz r10, 1(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 830D5D64: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830D5D68: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 830D5D6C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830D5D70: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830D5D74: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830D5D78: 69650001  xori r5, r11, 1
	ctx.r[5].u64 = ctx.r[11].u64 ^ 1;
	// 830D5D7C: 4BC88195  bl 0x82d5df10
	ctx.lr = 0x830D5D80;
	sub_82D5DF10(ctx, base);
	// 830D5D80: 81730080  lwz r11, 0x80(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(128 as u32) ) } as u64;
	// 830D5D84: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D5D88: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830D5D8C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D5D90: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D5D94: 4BC88405  bl 0x82d5e198
	ctx.lr = 0x830D5D98;
	sub_82D5E198(ctx, base);
	// 830D5D98: 81730080  lwz r11, 0x80(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(128 as u32) ) } as u64;
	// 830D5D9C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830D5DA0: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D5DA4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D5DA8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D5DAC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D5DB0: 4BC883E9  bl 0x82d5e198
	ctx.lr = 0x830D5DB4;
	sub_82D5E198(ctx, base);
	// 830D5DB4: 81730084  lwz r11, 0x84(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(132 as u32) ) } as u64;
	// 830D5DB8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830D5DBC: 81330008  lwz r9, 8(r19)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D5DC0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830D5DC4: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830D5DC8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D5DCC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D5DD0: 7FEB482E  lwzx r31, r11, r9
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830D5DD4: 4BC883C5  bl 0x82d5e198
	ctx.lr = 0x830D5DD8;
	sub_82D5E198(ctx, base);
	// 830D5DD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D5DDC: 4BC7F975  bl 0x82d55750
	ctx.lr = 0x830D5DE0;
	sub_82D55750(ctx, base);
	// 830D5DE0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830D5DE4: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 830D5DE8: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 830D5DEC: 4BC88F0D  bl 0x82d5ecf8
	ctx.lr = 0x830D5DF0;
	sub_82D5ECF8(ctx, base);
	// 830D5DF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830D5DF4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830D5DF8: 4BC883A1  bl 0x82d5e198
	ctx.lr = 0x830D5DFC;
	sub_82D5E198(ctx, base);
	// 830D5DFC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830D5E00: 4BC882B9  bl 0x82d5e0b8
	ctx.lr = 0x830D5E04;
	sub_82D5E0B8(ctx, base);
	// 830D5E04: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830D5E08: 4BC882B1  bl 0x82d5e0b8
	ctx.lr = 0x830D5E0C;
	sub_82D5E0B8(ctx, base);
	// 830D5E0C: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 830D5E10: 4BBD3618  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D5E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D5E18 size=3740
    let mut pc: u32 = 0x830D5E18;
    'dispatch: loop {
        match pc {
            0x830D5E18 => {
    //   block [0x830D5E18..0x830D5E80)
	// 830D5E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D5E1C: 4BBD35B5  bl 0x82ca93d0
	ctx.lr = 0x830D5E20;
	sub_82CA93D0(ctx, base);
	// 830D5E20: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D5E24: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 830D5E28: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 830D5E2C: 8078001C  lwz r3, 0x1c(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D5E30: 83F80004  lwz r31, 4(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D5E34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5E38: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D5E3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D5E40: 4E800421  bctrl
	ctx.lr = 0x830D5E44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D5E44: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830D5E48: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 830D5E4C: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 830D5E50: 3D208333  lis r9, -0x7ccd
	ctx.r[9].s64 = -2093809664;
	// 830D5E54: 3D008333  lis r8, -0x7ccd
	ctx.r[8].s64 = -2093809664;
	// 830D5E58: 396B7634  addi r11, r11, 0x7634
	ctx.r[11].s64 = ctx.r[11].s64 + 30260;
	// 830D5E5C: 394A76C4  addi r10, r10, 0x76c4
	ctx.r[10].s64 = ctx.r[10].s64 + 30404;
	// 830D5E60: 39297694  addi r9, r9, 0x7694
	ctx.r[9].s64 = ctx.r[9].s64 + 30356;
	// 830D5E64: 39087664  addi r8, r8, 0x7664
	ctx.r[8].s64 = ctx.r[8].s64 + 30308;
	// 830D5E68: 3BA100A0  addi r29, r1, 0xa0
	ctx.r[29].s64 = ctx.r[1].s64 + 160;
	// 830D5E6C: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 830D5E70: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 830D5E74: 914100A4  stw r10, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	// 830D5E78: 912100A8  stw r9, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[9].u32 ) };
	// 830D5E7C: 910100AC  stw r8, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[8].u32 ) };
            }
            0x830D5E80 => {
    //   block [0x830D5E80..0x830D5ED0)
	// 830D5E80: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 830D5E84: 80DF0014  lwz r6, 0x14(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D5E88: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 830D5E8C: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5E90: 4BFFF721  bl 0x830d55b0
	ctx.lr = 0x830D5E94;
	sub_830D55B0(ctx, base);
	// 830D5E94: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 830D5E98: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 830D5E9C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830D5EA0: 409AFFE0  bne cr6, 0x830d5e80
	if !ctx.cr[6].eq {
	pc = 0x830D5E80; continue 'dispatch;
	}
	// 830D5EA4: 3BB50038  addi r29, r21, 0x38
	ctx.r[29].s64 = ctx.r[21].s64 + 56;
	// 830D5EA8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D5EAC: 4BC88AB5  bl 0x82d5e960
	ctx.lr = 0x830D5EB0;
	sub_82D5E960(ctx, base);
	// 830D5EB0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830D5EB4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830D5EB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D5EBC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830D5EC0: 4BC88B79  bl 0x82d5ea38
	ctx.lr = 0x830D5EC4;
	sub_82D5EA38(ctx, base);
	// 830D5EC4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D5EC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D5ECC: 419A0050  beq cr6, 0x830d5f1c
	if ctx.cr[6].eq {
	pc = 0x830D5F1C; continue 'dispatch;
	}
	pc = 0x830D5ED0; continue 'dispatch;
            }
            0x830D5ED0 => {
    //   block [0x830D5ED0..0x830D5F1C)
	// 830D5ED0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D5ED4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D5ED8: 4BC88AE1  bl 0x82d5e9b8
	ctx.lr = 0x830D5EDC;
	sub_82D5E9B8(ctx, base);
	// 830D5EDC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830D5EE0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 830D5EE4: 80DF0014  lwz r6, 0x14(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D5EE8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 830D5EEC: 4BFFF6C5  bl 0x830d55b0
	ctx.lr = 0x830D5EF0;
	sub_830D55B0(ctx, base);
	// 830D5EF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D5EF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D5EF8: 4BC88B01  bl 0x82d5e9f8
	ctx.lr = 0x830D5EFC;
	sub_82D5E9F8(ctx, base);
	// 830D5EFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830D5F00: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830D5F04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D5F08: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830D5F0C: 4BC88B2D  bl 0x82d5ea38
	ctx.lr = 0x830D5F10;
	sub_82D5EA38(ctx, base);
	// 830D5F10: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D5F14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D5F18: 409AFFB8  bne cr6, 0x830d5ed0
	if !ctx.cr[6].eq {
	pc = 0x830D5ED0; continue 'dispatch;
	}
	pc = 0x830D5F1C; continue 'dispatch;
            }
            0x830D5F1C => {
    //   block [0x830D5F1C..0x830D5F54)
	// 830D5F1C: 83D8001C  lwz r30, 0x1c(r24)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D5F20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D5F24: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5F28: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D5F2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D5F30: 4E800421  bctrl
	ctx.lr = 0x830D5F34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D5F34: 396101DC  addi r11, r1, 0x1dc
	ctx.r[11].s64 = ctx.r[1].s64 + 476;
	// 830D5F38: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 830D5F3C: 3A00FFFF  li r16, -1
	ctx.r[16].s64 = -1;
	// 830D5F40: 916101D0  stw r11, 0x1d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(464 as u32), ctx.r[11].u32 ) };
	// 830D5F44: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 830D5F48: 61760020  ori r22, r11, 0x20
	ctx.r[22].u64 = ctx.r[11].u64 | 32;
	// 830D5F4C: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 830D5F50: 92C101D8  stw r22, 0x1d8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(472 as u32), ctx.r[22].u32 ) };
            }
            0x830D5F54 => {
    //   block [0x830D5F54..0x830D5F98)
	// 830D5F54: 814101D0  lwz r10, 0x1d0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(464 as u32) ) } as u64;
	// 830D5F58: 7E0A59AE  stbx r16, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[16].u8) };
	// 830D5F5C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D5F60: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 830D5F64: 4198FFF0  blt cr6, 0x830d5f54
	if ctx.cr[6].lt {
	pc = 0x830D5F54; continue 'dispatch;
	}
	// 830D5F68: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 830D5F6C: 546B073E  clrlwi r11, r3, 0x1c
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 830D5F70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D5F74: 914101D4  stw r10, 0x1d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(468 as u32), ctx.r[10].u32 ) };
	// 830D5F78: 419A0020  beq cr6, 0x830d5f98
	if ctx.cr[6].eq {
	pc = 0x830D5F98; continue 'dispatch;
	}
	// 830D5F7C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5F80: 20AB0010  subfic r5, r11, 0x10
	ctx.xer.ca = ctx.r[11].u32 <= 16 as u32;
	ctx.r[5].s64 = (16 as i64) - ctx.r[11].s64;
	// 830D5F84: 808101D0  lwz r4, 0x1d0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(464 as u32) ) } as u64;
	// 830D5F88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D5F8C: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D5F90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D5F94: 4E800421  bctrl
	ctx.lr = 0x830D5F98;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830D5F98 => {
    //   block [0x830D5F98..0x830D5FC4)
	// 830D5F98: 816101D8  lwz r11, 0x1d8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(472 as u32) ) } as u64;
	// 830D5F9C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D5FA0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D5FA4: 409A0020  bne cr6, 0x830d5fc4
	if !ctx.cr[6].eq {
	pc = 0x830D5FC4; continue 'dispatch;
	}
	// 830D5FA8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5FAC: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D5FB0: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D5FB4: 808101D0  lwz r4, 0x1d0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(464 as u32) ) } as u64;
	// 830D5FB8: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D5FBC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D5FC0: 4BC7F309  bl 0x82d552c8
	ctx.lr = 0x830D5FC4;
	sub_82D552C8(ctx, base);
	pc = 0x830D5FC4; continue 'dispatch;
            }
            0x830D5FC4 => {
    //   block [0x830D5FC4..0x830D6020)
	// 830D5FC4: 8078001C  lwz r3, 0x1c(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D5FC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D5FCC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D5FD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D5FD4: 4E800421  bctrl
	ctx.lr = 0x830D5FD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D5FD8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D5FDC: 3A580010  addi r18, r24, 0x10
	ctx.r[18].s64 = ctx.r[24].s64 + 16;
	// 830D5FE0: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 830D5FE4: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 830D5FE8: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 830D5FEC: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830D5FF0: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 830D5FF4: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 830D5FF8: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 830D5FFC: 81720008  lwz r11, 8(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D6000: 83F5000C  lwz r31, 0xc(r21)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D6004: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D6008: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830D600C: 40980024  bge cr6, 0x830d6030
	if !ctx.cr[6].lt {
	pc = 0x830D6030; continue 'dispatch;
	}
	// 830D6010: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D6014: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D6018: 41980008  blt cr6, 0x830d6020
	if ctx.cr[6].lt {
	pc = 0x830D6020; continue 'dispatch;
	}
	// 830D601C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
            }
            0x830D6020 => {
    //   block [0x830D6020..0x830D6030)
	// 830D6020: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 830D6024: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830D6028: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 830D602C: 4BC80EE5  bl 0x82d56f10
	ctx.lr = 0x830D6030;
	sub_82D56F10(ctx, base);
	pc = 0x830D6030; continue 'dispatch;
            }
            0x830D6030 => {
    //   block [0x830D6030..0x830D6054)
	// 830D6030: 3A38003C  addi r17, r24, 0x3c
	ctx.r[17].s64 = ctx.r[24].s64 + 60;
	// 830D6034: 93F20004  stw r31, 4(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 830D6038: 83980008  lwz r28, 8(r24)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D603C: 3DE08000  lis r15, -0x8000
	ctx.r[15].s64 = -2147483648;
	// 830D6040: 83B10004  lwz r29, 4(r17)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D6044: 7F1CE800  cmpw cr6, r28, r29
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830D6048: 4098002C  bge cr6, 0x830d6074
	if !ctx.cr[6].lt {
	pc = 0x830D6074; continue 'dispatch;
	}
	// 830D604C: 1FDC0034  mulli r30, r28, 0x34
	ctx.r[30].s32 = ((ctx.r[28].s32 as i64 * 52 as i64) as i32);
	ctx.r[30].s64 = ctx.r[30].s32 as i64;
	// 830D6050: 7FFCE850  subf r31, r28, r29
	ctx.r[31].s64 = ctx.r[29].s64 - ctx.r[28].s64;
	pc = 0x830D6054; continue 'dispatch;
            }
            0x830D6054 => {
    //   block [0x830D6054..0x830D6074)
	// 830D6054: 81710000  lwz r11, 0(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6058: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830D605C: 4BC9F5CD  bl 0x82d75628
	ctx.lr = 0x830D6060;
	sub_82D75628(ctx, base);
	// 830D6060: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 830D6064: 3BDE0034  addi r30, r30, 0x34
	ctx.r[30].s64 = ctx.r[30].s64 + 52;
	// 830D6068: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830D606C: 409AFFE8  bne cr6, 0x830d6054
	if !ctx.cr[6].eq {
	pc = 0x830D6054; continue 'dispatch;
	}
	// 830D6070: 48000170  b 0x830d61e0
	pc = 0x830D61E0; continue 'dispatch;
            }
            0x830D6074 => {
    //   block [0x830D6074..0x830D6094)
	// 830D6074: 83510008  lwz r26, 8(r17)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D6078: 574B00BE  clrlwi r11, r26, 2
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x3FFFFFFFu64;
	// 830D607C: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D6080: 409900F8  ble cr6, 0x830d6178
	if !ctx.cr[6].gt {
	pc = 0x830D6178; continue 'dispatch;
	}
	// 830D6084: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D6088: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D608C: 41980008  blt cr6, 0x830d6094
	if ctx.cr[6].lt {
	pc = 0x830D6094; continue 'dispatch;
	}
	// 830D6090: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x830D6094; continue 'dispatch;
            }
            0x830D6094 => {
    //   block [0x830D6094..0x830D60B4)
	// 830D6094: 83710000  lwz r27, 0(r17)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6098: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D609C: 92910000  stw r20, 0(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(0 as u32), ctx.r[20].u32 ) };
	// 830D60A0: 92910004  stw r20, 4(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(4 as u32), ctx.r[20].u32 ) };
	// 830D60A4: 91F10008  stw r15, 8(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(8 as u32), ctx.r[15].u32 ) };
	// 830D60A8: 4099001C  ble cr6, 0x830d60c4
	if !ctx.cr[6].gt {
	pc = 0x830D60C4; continue 'dispatch;
	}
	// 830D60AC: 40980008  bge cr6, 0x830d60b4
	if !ctx.cr[6].lt {
	pc = 0x830D60B4; continue 'dispatch;
	}
	// 830D60B0: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	pc = 0x830D60B4; continue 'dispatch;
            }
            0x830D60B4 => {
    //   block [0x830D60B4..0x830D60C4)
	// 830D60B4: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 830D60B8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830D60BC: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 830D60C0: 4BC80E51  bl 0x82d56f10
	ctx.lr = 0x830D60C4;
	sub_82D56F10(ctx, base);
	pc = 0x830D60C4; continue 'dispatch;
            }
            0x830D60C4 => {
    //   block [0x830D60C4..0x830D60D8)
	// 830D60C4: 81710000  lwz r11, 0(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D60C8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830D60CC: 40990054  ble cr6, 0x830d6120
	if !ctx.cr[6].gt {
	pc = 0x830D6120; continue 'dispatch;
	}
	// 830D60D0: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 830D60D4: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x830D60D8; continue 'dispatch;
            }
            0x830D60D8 => {
    //   block [0x830D60D8..0x830D6110)
	// 830D60D8: 352BFFEC  addic. r9, r11, -0x14
	ctx.xer.ca = (ctx.r[11].u32 > (!(-20 as u32)));
	ctx.r[9].s64 = ctx.r[11].s64 + -20;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830D60DC: 41820034  beq 0x830d6110
	if ctx.cr[0].eq {
	pc = 0x830D6110; continue 'dispatch;
	}
	// 830D60E0: 928BFFEC  stw r20, -0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-20 as u32), ctx.r[20].u32 ) };
	// 830D60E4: 928BFFF0  stw r20, -0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16 as u32), ctx.r[20].u32 ) };
	// 830D60E8: 91EBFFF4  stw r15, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[15].u32 ) };
	// 830D60EC: 928BFFF8  stw r20, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[20].u32 ) };
	// 830D60F0: 928BFFFC  stw r20, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[20].u32 ) };
	// 830D60F4: 91EB0000  stw r15, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[15].u32 ) };
	// 830D60F8: 928B0004  stw r20, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[20].u32 ) };
	// 830D60FC: 928B0008  stw r20, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 830D6100: 91EB000C  stw r15, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[15].u32 ) };
	// 830D6104: 928B0010  stw r20, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[20].u32 ) };
	// 830D6108: 928B0014  stw r20, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u32 ) };
	// 830D610C: 91EB0018  stw r15, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[15].u32 ) };
	pc = 0x830D6110; continue 'dispatch;
            }
            0x830D6110 => {
    //   block [0x830D6110..0x830D6120)
	// 830D6110: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830D6114: 396B0034  addi r11, r11, 0x34
	ctx.r[11].s64 = ctx.r[11].s64 + 52;
	// 830D6118: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830D611C: 409AFFBC  bne cr6, 0x830d60d8
	if !ctx.cr[6].eq {
	pc = 0x830D60D8; continue 'dispatch;
	}
	pc = 0x830D6120; continue 'dispatch;
            }
            0x830D6120 => {
    //   block [0x830D6120..0x830D6134)
	// 830D6120: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830D6124: 93B10004  stw r29, 4(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830D6128: 40990024  ble cr6, 0x830d614c
	if !ctx.cr[6].gt {
	pc = 0x830D614C; continue 'dispatch;
	}
	// 830D612C: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 830D6130: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	pc = 0x830D6134; continue 'dispatch;
            }
            0x830D6134 => {
    //   block [0x830D6134..0x830D614C)
	// 830D6134: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D6138: 4BC9F4F1  bl 0x82d75628
	ctx.lr = 0x830D613C;
	sub_82D75628(ctx, base);
	// 830D613C: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 830D6140: 3BDE0034  addi r30, r30, 0x34
	ctx.r[30].s64 = ctx.r[30].s64 + 52;
	// 830D6144: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830D6148: 409AFFEC  bne cr6, 0x830d6134
	if !ctx.cr[6].eq {
	pc = 0x830D6134; continue 'dispatch;
	}
	pc = 0x830D614C; continue 'dispatch;
            }
            0x830D614C => {
    //   block [0x830D614C..0x830D6178)
	// 830D614C: 574B0000  rlwinm r11, r26, 0, 0, 0
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 830D6150: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D6154: 409A0024  bne cr6, 0x830d6178
	if !ctx.cr[6].eq {
	pc = 0x830D6178; continue 'dispatch;
	}
	// 830D6158: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D615C: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830D6160: 574900BE  clrlwi r9, r26, 2
	ctx.r[9].u64 = ctx.r[26].u32 as u64 & 0x3FFFFFFFu64;
	// 830D6164: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D6168: 1CA90034  mulli r5, r9, 0x34
	ctx.r[5].s32 = ((ctx.r[9].s32 as i64 * 52 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 830D616C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830D6170: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830D6174: 4BC7F155  bl 0x82d552c8
	ctx.lr = 0x830D6178;
	sub_82D552C8(ctx, base);
	pc = 0x830D6178; continue 'dispatch;
            }
            0x830D6178 => {
    //   block [0x830D6178..0x830D6194)
	// 830D6178: 81510000  lwz r10, 0(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D617C: 7F1DE000  cmpw cr6, r29, r28
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[28].s32, &mut ctx.xer);
	// 830D6180: 40980060  bge cr6, 0x830d61e0
	if !ctx.cr[6].lt {
	pc = 0x830D61E0; continue 'dispatch;
	}
	// 830D6184: 1D7D0034  mulli r11, r29, 0x34
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * 52 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 830D6188: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D618C: 7D5DE050  subf r10, r29, r28
	ctx.r[10].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 830D6190: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	pc = 0x830D6194; continue 'dispatch;
            }
            0x830D6194 => {
    //   block [0x830D6194..0x830D61D0)
	// 830D6194: 352BFFEC  addic. r9, r11, -0x14
	ctx.xer.ca = (ctx.r[11].u32 > (!(-20 as u32)));
	ctx.r[9].s64 = ctx.r[11].s64 + -20;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830D6198: 41820038  beq 0x830d61d0
	if ctx.cr[0].eq {
	pc = 0x830D61D0; continue 'dispatch;
	}
	// 830D619C: 928BFFEC  stw r20, -0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-20 as u32), ctx.r[20].u32 ) };
	// 830D61A0: 928BFFF0  stw r20, -0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16 as u32), ctx.r[20].u32 ) };
	// 830D61A4: 91EBFFF4  stw r15, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[15].u32 ) };
	// 830D61A8: 928BFFF8  stw r20, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[20].u32 ) };
	// 830D61AC: 928BFFFC  stw r20, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[20].u32 ) };
	// 830D61B0: 91EB0000  stw r15, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[15].u32 ) };
	// 830D61B4: 928B0004  stw r20, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[20].u32 ) };
	// 830D61B8: 928B0008  stw r20, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[20].u32 ) };
	// 830D61BC: 91EB000C  stw r15, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[15].u32 ) };
	// 830D61C0: 928B0010  stw r20, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[20].u32 ) };
	// 830D61C4: 928B0014  stw r20, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u32 ) };
	// 830D61C8: 91EB0018  stw r15, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[15].u32 ) };
	// 830D61CC: 928B001C  stw r20, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[20].u32 ) };
	pc = 0x830D61D0; continue 'dispatch;
            }
            0x830D61D0 => {
    //   block [0x830D61D0..0x830D61E0)
	// 830D61D0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830D61D4: 396B0034  addi r11, r11, 0x34
	ctx.r[11].s64 = ctx.r[11].s64 + 52;
	// 830D61D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830D61DC: 409AFFB8  bne cr6, 0x830d6194
	if !ctx.cr[6].eq {
	pc = 0x830D6194; continue 'dispatch;
	}
	pc = 0x830D61E0; continue 'dispatch;
            }
            0x830D61E0 => {
    //   block [0x830D61E0..0x830D6208)
	// 830D61E0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830D61E4: 93910004  stw r28, 4(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830D61E8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 830D61EC: 808B1E0C  lwz r4, 0x1e0c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7692 as u32) ) } as u64;
	// 830D61F0: 48002E61  bl 0x830d9050
	ctx.lr = 0x830D61F4;
	sub_830D9050(ctx, base);
	// 830D61F4: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D61F8: 7C6E1B78  mr r14, r3
	ctx.r[14].u64 = ctx.r[3].u64;
	// 830D61FC: 3A600001  li r19, 1
	ctx.r[19].s64 = 1;
	// 830D6200: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830D6204: 40990AA8  ble cr6, 0x830d6cac
	if !ctx.cr[6].gt {
	pc = 0x830D6CAC; continue 'dispatch;
	}
	pc = 0x830D6208; continue 'dispatch;
            }
            0x830D6208 => {
    //   block [0x830D6208..0x830D6298)
	// 830D6208: 8078001C  lwz r3, 0x1c(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D620C: 566B083C  slwi r11, r19, 1
	ctx.r[11].u32 = ctx.r[19].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D6210: 81580004  lwz r10, 4(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D6214: 7D735A14  add r11, r19, r11
	ctx.r[11].u64 = ctx.r[19].u64 + ctx.r[11].u64;
	// 830D6218: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D621C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6220: 7EEB5214  add r23, r11, r10
	ctx.r[23].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D6224: 81290020  lwz r9, 0x20(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D6228: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 830D622C: 4E800421  bctrl
	ctx.lr = 0x830D6230;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6230: 90770014  stw r3, 0x14(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 830D6234: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6238: 92810060  stw r20, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[20].u32 ) };
	// 830D623C: 92810064  stw r20, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[20].u32 ) };
	// 830D6240: 91E10068  stw r15, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[15].u32 ) };
	// 830D6244: 9281006C  stw r20, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[20].u32 ) };
	// 830D6248: 92810070  stw r20, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[20].u32 ) };
	// 830D624C: 91E10074  stw r15, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[15].u32 ) };
	// 830D6250: 92810078  stw r20, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[20].u32 ) };
	// 830D6254: 9281007C  stw r20, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[20].u32 ) };
	// 830D6258: 91E10080  stw r15, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[15].u32 ) };
	// 830D625C: 92810084  stw r20, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[20].u32 ) };
	// 830D6260: 92810088  stw r20, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[20].u32 ) };
	// 830D6264: 91E1008C  stw r15, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[15].u32 ) };
	// 830D6268: 92810090  stw r20, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[20].u32 ) };
	// 830D626C: 896B0008  lbz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D6270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D6274: 409A0068  bne cr6, 0x830d62dc
	if !ctx.cr[6].eq {
	pc = 0x830D62DC; continue 'dispatch;
	}
	// 830D6278: 7F137000  cmpw cr6, r19, r14
	ctx.cr[6].compare_i32(ctx.r[19].s32, ctx.r[14].s32, &mut ctx.xer);
	// 830D627C: 409A0060  bne cr6, 0x830d62dc
	if !ctx.cr[6].eq {
	pc = 0x830D62DC; continue 'dispatch;
	}
	// 830D6280: 8175000C  lwz r11, 0xc(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D6284: 7E88A378  mr r8, r20
	ctx.r[8].u64 = ctx.r[20].u64;
	// 830D6288: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D628C: 40990118  ble cr6, 0x830d63a4
	if !ctx.cr[6].gt {
	pc = 0x830D63A4; continue 'dispatch;
	}
	// 830D6290: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 830D6294: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
            }
            0x830D6298 => {
    //   block [0x830D6298..0x830D62C0)
	// 830D6298: 81350008  lwz r9, 8(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D629C: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 830D62A0: 81290010  lwz r9, 0x10(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D62A4: 7F097000  cmpw cr6, r9, r14
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[14].s32, &mut ctx.xer);
	// 830D62A8: 409A0018  bne cr6, 0x830d62c0
	if !ctx.cr[6].eq {
	pc = 0x830D62C0; continue 'dispatch;
	}
	// 830D62AC: 81320000  lwz r9, 0(r18)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D62B0: 7E09592E  stwx r16, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[16].u32) };
	// 830D62B4: 81320000  lwz r9, 0(r18)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D62B8: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 830D62BC: 92090004  stw r16, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[16].u32 ) };
	pc = 0x830D62C0; continue 'dispatch;
            }
            0x830D62C0 => {
    //   block [0x830D62C0..0x830D62DC)
	// 830D62C0: 8135000C  lwz r9, 0xc(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D62C4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 830D62C8: 394A0018  addi r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 + 24;
	// 830D62CC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 830D62D0: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830D62D4: 4198FFC4  blt cr6, 0x830d6298
	if ctx.cr[6].lt {
	pc = 0x830D6298; continue 'dispatch;
	}
	// 830D62D8: 480000CC  b 0x830d63a4
	pc = 0x830D63A4; continue 'dispatch;
            }
            0x830D62DC => {
    //   block [0x830D62DC..0x830D62F4)
	// 830D62DC: 8175000C  lwz r11, 0xc(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D62E0: 7E99A378  mr r25, r20
	ctx.r[25].u64 = ctx.r[20].u64;
	// 830D62E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D62E8: 409900BC  ble cr6, 0x830d63a4
	if !ctx.cr[6].gt {
	pc = 0x830D63A4; continue 'dispatch;
	}
	// 830D62EC: 7E9CA378  mr r28, r20
	ctx.r[28].u64 = ctx.r[20].u64;
	// 830D62F0: 7E9AA378  mr r26, r20
	ctx.r[26].u64 = ctx.r[20].u64;
	pc = 0x830D62F4; continue 'dispatch;
            }
            0x830D62F4 => {
    //   block [0x830D62F4..0x830D6370)
	// 830D62F4: 81750008  lwz r11, 8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D62F8: 7FEBD214  add r31, r11, r26
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 830D62FC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D6300: 7F0B9800  cmpw cr6, r11, r19
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[19].s32, &mut ctx.xer);
	// 830D6304: 409A0088  bne cr6, 0x830d638c
	if !ctx.cr[6].eq {
	pc = 0x830D638C; continue 'dispatch;
	}
	// 830D6308: 81720000  lwz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D630C: 837F0000  lwz r27, 0(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6310: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D6314: 7E6BE12E  stwx r19, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[19].u32) };
	// 830D6318: 8078001C  lwz r3, 0x1c(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D631C: 81720000  lwz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6320: 7FABE214  add r29, r11, r28
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830D6324: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6328: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D632C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6330: 4E800421  bctrl
	ctx.lr = 0x830D6334;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6334: 81770014  lwz r11, 0x14(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D6338: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830D633C: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 830D6340: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830D6344: 419A002C  beq cr6, 0x830d6370
	if ctx.cr[6].eq {
	pc = 0x830D6370; continue 'dispatch;
	}
	// 830D6348: 81780020  lwz r11, 0x20(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D634C: 38780020  addi r3, r24, 0x20
	ctx.r[3].s64 = ctx.r[24].s64 + 32;
	// 830D6350: 8098001C  lwz r4, 0x1c(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D6354: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 830D6358: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830D635C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830D6360: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D6364: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6368: 4E800421  bctrl
	ctx.lr = 0x830D636C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D636C: 48000020  b 0x830d638c
	pc = 0x830D638C; continue 'dispatch;
            }
            0x830D6370 => {
    //   block [0x830D6370..0x830D638C)
	// 830D6370: 8078001C  lwz r3, 0x1c(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D6374: 80BF0014  lwz r5, 0x14(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D6378: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D637C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6380: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D6384: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6388: 4E800421  bctrl
	ctx.lr = 0x830D638C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830D638C => {
    //   block [0x830D638C..0x830D63A4)
	// 830D638C: 8175000C  lwz r11, 0xc(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D6390: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 830D6394: 3B5A0018  addi r26, r26, 0x18
	ctx.r[26].s64 = ctx.r[26].s64 + 24;
	// 830D6398: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 830D639C: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D63A0: 4198FF54  blt cr6, 0x830d62f4
	if ctx.cr[6].lt {
	pc = 0x830D62F4; continue 'dispatch;
	}
	pc = 0x830D63A4; continue 'dispatch;
            }
            0x830D63A4 => {
    //   block [0x830D63A4..0x830D63B8)
	// 830D63A4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830D63A8: 7E89A378  mr r9, r20
	ctx.r[9].u64 = ctx.r[20].u64;
	// 830D63AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D63B0: 40990048  ble cr6, 0x830d63f8
	if !ctx.cr[6].gt {
	pc = 0x830D63F8; continue 'dispatch;
	}
	// 830D63B4: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	pc = 0x830D63B8; continue 'dispatch;
            }
            0x830D63B8 => {
    //   block [0x830D63B8..0x830D63F8)
	// 830D63B8: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D63BC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830D63C0: 80F70014  lwz r7, 0x14(r23)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D63C4: 7D0A582E  lwzx r8, r10, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830D63C8: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 830D63CC: 7D0A592E  stwx r8, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u32) };
	// 830D63D0: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D63D4: 81170014  lwz r8, 0x14(r23)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D63D8: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830D63DC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 830D63E0: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D63E4: 7D083850  subf r8, r8, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 830D63E8: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 830D63EC: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830D63F0: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830D63F4: 4198FFC4  blt cr6, 0x830d63b8
	if ctx.cr[6].lt {
	pc = 0x830D63B8; continue 'dispatch;
	}
	pc = 0x830D63F8; continue 'dispatch;
            }
            0x830D63F8 => {
    //   block [0x830D63F8..0x830D6418)
	// 830D63F8: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830D63FC: 3B8BFFFF  addi r28, r11, -1
	ctx.r[28].s64 = ctx.r[11].s64 + -1;
	// 830D6400: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830D6404: 419800D4  blt cr6, 0x830d64d8
	if ctx.cr[6].lt {
	pc = 0x830D64D8; continue 'dispatch;
	}
	// 830D6408: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D640C: 3B750020  addi r27, r21, 0x20
	ctx.r[27].s64 = ctx.r[21].s64 + 32;
	// 830D6410: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 830D6414: 557F103A  slwi r31, r11, 2
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	pc = 0x830D6418; continue 'dispatch;
            }
            0x830D6418 => {
    //   block [0x830D6418..0x830D6464)
	// 830D6418: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830D641C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D6420: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830D6424: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830D6428: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D642C: 4BC8A25D  bl 0x82d60688
	ctx.lr = 0x830D6430;
	sub_82D60688(ctx, base);
	// 830D6430: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830D6434: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830D6438: 419A0090  beq cr6, 0x830d64c8
	if ctx.cr[6].eq {
	pc = 0x830D64C8; continue 'dispatch;
	}
	// 830D643C: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 830D6440: 83A1006C  lwz r29, 0x6c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830D6444: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D6448: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830D644C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830D6450: 409A0014  bne cr6, 0x830d6464
	if !ctx.cr[6].eq {
	pc = 0x830D6464; continue 'dispatch;
	}
	// 830D6454: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 830D6458: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 830D645C: 4BC80B3D  bl 0x82d56f98
	ctx.lr = 0x830D6460;
	sub_82D56F98(ctx, base);
	// 830D6460: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	pc = 0x830D6464; continue 'dispatch;
            }
            0x830D6464 => {
    //   block [0x830D6464..0x830D64C8)
	// 830D6464: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830D6468: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D646C: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 830D6470: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 830D6474: 7D3DF82E  lwzx r9, r29, r31
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830D6478: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830D647C: 81570014  lwz r10, 0x14(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D6480: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 830D6484: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830D6488: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830D648C: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830D6490: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830D6494: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830D6498: 7D0AFA14  add r8, r10, r31
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 830D649C: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830D64A0: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 830D64A4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830D64A8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D64AC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D64B0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D64B4: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830D64B8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D64BC: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830D64C0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D64C4: 91680008  stw r11, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x830D64C8; continue 'dispatch;
            }
            0x830D64C8 => {
    //   block [0x830D64C8..0x830D64D8)
	// 830D64C8: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 830D64CC: 3BFFFFF4  addi r31, r31, -0xc
	ctx.r[31].s64 = ctx.r[31].s64 + -12;
	// 830D64D0: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830D64D4: 4098FF44  bge cr6, 0x830d6418
	if !ctx.cr[6].lt {
	pc = 0x830D6418; continue 'dispatch;
	}
	pc = 0x830D64D8; continue 'dispatch;
            }
            0x830D64D8 => {
    //   block [0x830D64D8..0x830D6548)
	// 830D64D8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830D64DC: 88B80048  lbz r5, 0x48(r24)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(72 as u32) ) } as u64;
	// 830D64E0: 8098001C  lwz r4, 0x1c(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D64E4: 4BC87A2D  bl 0x82d5df10
	ctx.lr = 0x830D64E8;
	sub_82D5DF10(ctx, base);
	// 830D64E8: 8078001C  lwz r3, 0x1c(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D64EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D64F0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D64F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D64F8: 4E800421  bctrl
	ctx.lr = 0x830D64FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D64FC: 81770014  lwz r11, 0x14(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D6500: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830D6504: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 830D6508: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830D650C: 91770018  stw r11, 0x18(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 830D6510: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830D6514: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D6518: 5566083C  slwi r6, r11, 1
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 830D651C: 4BC87725  bl 0x82d5dc40
	ctx.lr = 0x830D6520;
	sub_82D5DC40(ctx, base);
	// 830D6520: 83F8001C  lwz r31, 0x1c(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D6524: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D6528: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D652C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D6530: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6534: 4E800421  bctrl
	ctx.lr = 0x830D6538;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6538: 3961020C  addi r11, r1, 0x20c
	ctx.r[11].s64 = ctx.r[1].s64 + 524;
	// 830D653C: 92C10208  stw r22, 0x208(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(520 as u32), ctx.r[22].u32 ) };
	// 830D6540: 91610200  stw r11, 0x200(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(512 as u32), ctx.r[11].u32 ) };
	// 830D6544: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
            }
            0x830D6548 => {
    //   block [0x830D6548..0x830D658C)
	// 830D6548: 81410200  lwz r10, 0x200(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(512 as u32) ) } as u64;
	// 830D654C: 7E0A59AE  stbx r16, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[16].u8) };
	// 830D6550: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D6554: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 830D6558: 4198FFF0  blt cr6, 0x830d6548
	if ctx.cr[6].lt {
	pc = 0x830D6548; continue 'dispatch;
	}
	// 830D655C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 830D6560: 546B073E  clrlwi r11, r3, 0x1c
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 830D6564: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D6568: 91410204  stw r10, 0x204(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(516 as u32), ctx.r[10].u32 ) };
	// 830D656C: 419A0020  beq cr6, 0x830d658c
	if ctx.cr[6].eq {
	pc = 0x830D658C; continue 'dispatch;
	}
	// 830D6570: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6574: 20AB0010  subfic r5, r11, 0x10
	ctx.xer.ca = ctx.r[11].u32 <= 16 as u32;
	ctx.r[5].s64 = (16 as i64) - ctx.r[11].s64;
	// 830D6578: 80810200  lwz r4, 0x200(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(512 as u32) ) } as u64;
	// 830D657C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D6580: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D6584: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6588: 4E800421  bctrl
	ctx.lr = 0x830D658C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830D658C => {
    //   block [0x830D658C..0x830D65B8)
	// 830D658C: 81610208  lwz r11, 0x208(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(520 as u32) ) } as u64;
	// 830D6590: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D6594: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D6598: 409A0020  bne cr6, 0x830d65b8
	if !ctx.cr[6].eq {
	pc = 0x830D65B8; continue 'dispatch;
	}
	// 830D659C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D65A0: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D65A4: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D65A8: 80810200  lwz r4, 0x200(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(512 as u32) ) } as u64;
	// 830D65AC: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D65B0: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D65B4: 4BC7ED15  bl 0x82d552c8
	ctx.lr = 0x830D65B8;
	sub_82D552C8(ctx, base);
	pc = 0x830D65B8; continue 'dispatch;
            }
            0x830D65B8 => {
    //   block [0x830D65B8..0x830D6664)
	// 830D65B8: 8078001C  lwz r3, 0x1c(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D65BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D65C0: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D65C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D65C8: 4E800421  bctrl
	ctx.lr = 0x830D65CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D65CC: 81770014  lwz r11, 0x14(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D65D0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830D65D4: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 830D65D8: 9177001C  stw r11, 0x1c(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 830D65DC: 8078001C  lwz r3, 0x1c(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D65E0: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830D65E4: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830D65E8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D65EC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D65F0: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830D65F4: 8169001C  lwz r11, 0x1c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D65F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D65FC: 4E800421  bctrl
	ctx.lr = 0x830D6600;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6600: 81710000  lwz r11, 0(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6604: 1F930034  mulli r28, r19, 0x34
	ctx.r[28].s32 = ((ctx.r[19].s32 as i64 * 52 as i64) as i32);
	ctx.r[28].s64 = ctx.r[28].s32 as i64;
	// 830D6608: 8121006C  lwz r9, 0x6c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830D660C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830D6610: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D6614: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 830D6618: 81210070  lwz r9, 0x70(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830D661C: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 830D6620: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D6624: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 830D6628: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 830D662C: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 830D6630: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D6634: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 830D6638: 83F8001C  lwz r31, 0x1c(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D663C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D6640: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 830D6644: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6648: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D664C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6650: 4E800421  bctrl
	ctx.lr = 0x830D6654;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6654: 3961011C  addi r11, r1, 0x11c
	ctx.r[11].s64 = ctx.r[1].s64 + 284;
	// 830D6658: 92C10118  stw r22, 0x118(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[22].u32 ) };
	// 830D665C: 91610110  stw r11, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 830D6660: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
            }
            0x830D6664 => {
    //   block [0x830D6664..0x830D66A8)
	// 830D6664: 81410110  lwz r10, 0x110(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) } as u64;
	// 830D6668: 7E0A59AE  stbx r16, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[16].u8) };
	// 830D666C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D6670: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 830D6674: 4198FFF0  blt cr6, 0x830d6664
	if ctx.cr[6].lt {
	pc = 0x830D6664; continue 'dispatch;
	}
	// 830D6678: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 830D667C: 546B073E  clrlwi r11, r3, 0x1c
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 830D6680: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D6684: 91410114  stw r10, 0x114(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), ctx.r[10].u32 ) };
	// 830D6688: 419A0020  beq cr6, 0x830d66a8
	if ctx.cr[6].eq {
	pc = 0x830D66A8; continue 'dispatch;
	}
	// 830D668C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6690: 20AB0010  subfic r5, r11, 0x10
	ctx.xer.ca = ctx.r[11].u32 <= 16 as u32;
	ctx.r[5].s64 = (16 as i64) - ctx.r[11].s64;
	// 830D6694: 80810110  lwz r4, 0x110(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) } as u64;
	// 830D6698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D669C: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D66A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D66A4: 4E800421  bctrl
	ctx.lr = 0x830D66A8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830D66A8 => {
    //   block [0x830D66A8..0x830D66D4)
	// 830D66A8: 81610118  lwz r11, 0x118(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(280 as u32) ) } as u64;
	// 830D66AC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D66B0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D66B4: 409A0020  bne cr6, 0x830d66d4
	if !ctx.cr[6].eq {
	pc = 0x830D66D4; continue 'dispatch;
	}
	// 830D66B8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D66BC: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D66C0: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D66C4: 80810110  lwz r4, 0x110(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) } as u64;
	// 830D66C8: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D66CC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D66D0: 4BC7EBF9  bl 0x82d552c8
	ctx.lr = 0x830D66D4;
	sub_82D552C8(ctx, base);
	pc = 0x830D66D4; continue 'dispatch;
            }
            0x830D66D4 => {
    //   block [0x830D66D4..0x830D677C)
	// 830D66D4: 8078001C  lwz r3, 0x1c(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D66D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D66DC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D66E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D66E4: 4E800421  bctrl
	ctx.lr = 0x830D66E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D66E8: 81770014  lwz r11, 0x14(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D66EC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830D66F0: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 830D66F4: 91770020  stw r11, 0x20(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830D66F8: 8078001C  lwz r3, 0x1c(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D66FC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 830D6700: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830D6704: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6708: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D670C: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830D6710: 8169001C  lwz r11, 0x1c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D6714: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6718: 4E800421  bctrl
	ctx.lr = 0x830D671C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D671C: 81710000  lwz r11, 0(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6720: 81210078  lwz r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830D6724: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830D6728: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D672C: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 830D6730: 8121007C  lwz r9, 0x7c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 830D6734: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 830D6738: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D673C: 912B001C  stw r9, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 830D6740: 81210080  lwz r9, 0x80(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 830D6744: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 830D6748: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D674C: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 830D6750: 83F8001C  lwz r31, 0x1c(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D6754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D6758: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 830D675C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6760: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D6764: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6768: 4E800421  bctrl
	ctx.lr = 0x830D676C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D676C: 396100BC  addi r11, r1, 0xbc
	ctx.r[11].s64 = ctx.r[1].s64 + 188;
	// 830D6770: 92C100B8  stw r22, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[22].u32 ) };
	// 830D6774: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 830D6778: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
            }
            0x830D677C => {
    //   block [0x830D677C..0x830D67C0)
	// 830D677C: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 830D6780: 7E0A59AE  stbx r16, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[16].u8) };
	// 830D6784: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D6788: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 830D678C: 4198FFF0  blt cr6, 0x830d677c
	if ctx.cr[6].lt {
	pc = 0x830D677C; continue 'dispatch;
	}
	// 830D6790: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 830D6794: 546B073E  clrlwi r11, r3, 0x1c
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 830D6798: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D679C: 914100B4  stw r10, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[10].u32 ) };
	// 830D67A0: 419A0020  beq cr6, 0x830d67c0
	if ctx.cr[6].eq {
	pc = 0x830D67C0; continue 'dispatch;
	}
	// 830D67A4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D67A8: 20AB0010  subfic r5, r11, 0x10
	ctx.xer.ca = ctx.r[11].u32 <= 16 as u32;
	ctx.r[5].s64 = (16 as i64) - ctx.r[11].s64;
	// 830D67AC: 808100B0  lwz r4, 0xb0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 830D67B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D67B4: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D67B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D67BC: 4E800421  bctrl
	ctx.lr = 0x830D67C0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830D67C0 => {
    //   block [0x830D67C0..0x830D67EC)
	// 830D67C0: 816100B8  lwz r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 830D67C4: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D67C8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D67CC: 409A0020  bne cr6, 0x830d67ec
	if !ctx.cr[6].eq {
	pc = 0x830D67EC; continue 'dispatch;
	}
	// 830D67D0: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D67D4: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D67D8: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D67DC: 808100B0  lwz r4, 0xb0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 830D67E0: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D67E4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D67E8: 4BC7EAE1  bl 0x82d552c8
	ctx.lr = 0x830D67EC;
	sub_82D552C8(ctx, base);
	pc = 0x830D67EC; continue 'dispatch;
            }
            0x830D67EC => {
    //   block [0x830D67EC..0x830D6820)
	// 830D67EC: 8078001C  lwz r3, 0x1c(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D67F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D67F4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D67F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D67FC: 4E800421  bctrl
	ctx.lr = 0x830D6800;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6800: 81570014  lwz r10, 0x14(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D6804: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 830D6808: 7D4A1850  subf r10, r10, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[10].s64;
	// 830D680C: 91570024  stw r10, 0x24(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 830D6810: 81350034  lwz r9, 0x34(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(52 as u32) ) } as u64;
	// 830D6814: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830D6818: 41980024  blt cr6, 0x830d683c
	if ctx.cr[6].lt {
	pc = 0x830D683C; continue 'dispatch;
	}
	// 830D681C: 8155002C  lwz r10, 0x2c(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(44 as u32) ) } as u64;
            }
            0x830D6820 => {
    //   block [0x830D6820..0x830D683C)
	// 830D6820: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6824: 2F08FFFF  cmpwi cr6, r8, -1
	ctx.cr[6].compare_i32(ctx.r[8].s32, -1, &mut ctx.xer);
	// 830D6828: 409A0014  bne cr6, 0x830d683c
	if !ctx.cr[6].eq {
	pc = 0x830D683C; continue 'dispatch;
	}
	// 830D682C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D6830: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830D6834: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830D6838: 4099FFE8  ble cr6, 0x830d6820
	if !ctx.cr[6].gt {
	pc = 0x830D6820; continue 'dispatch;
	}
	pc = 0x830D683C; continue 'dispatch;
            }
            0x830D683C => {
    //   block [0x830D683C..0x830D6840)
	// 830D683C: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	pc = 0x830D6840; continue 'dispatch;
            }
            0x830D6840 => {
    //   block [0x830D6840..0x830D6858)
	// 830D6840: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 830D6844: 81750034  lwz r11, 0x34(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(52 as u32) ) } as u64;
	// 830D6848: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D684C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830D6850: 40990008  ble cr6, 0x830d6858
	if !ctx.cr[6].gt {
	pc = 0x830D6858; continue 'dispatch;
	}
	// 830D6854: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	pc = 0x830D6858; continue 'dispatch;
            }
            0x830D6858 => {
    //   block [0x830D6858..0x830D6918)
	// 830D6858: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830D685C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D6860: 419A0164  beq cr6, 0x830d69c4
	if ctx.cr[6].eq {
	pc = 0x830D69C4; continue 'dispatch;
	}
	// 830D6864: 8175002C  lwz r11, 0x2c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(44 as u32) ) } as u64;
	// 830D6868: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830D686C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 830D6870: 38750014  addi r3, r21, 0x14
	ctx.r[3].s64 = ctx.r[21].s64 + 20;
	// 830D6874: 7C8A582E  lwzx r4, r10, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830D6878: 4BC89E11  bl 0x82d60688
	ctx.lr = 0x830D687C;
	sub_82D60688(ctx, base);
	// 830D687C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D6880: 41980108  blt cr6, 0x830d6988
	if ctx.cr[6].lt {
	pc = 0x830D6988; continue 'dispatch;
	}
	// 830D6884: 546B083C  slwi r11, r3, 1
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D6888: 81550008  lwz r10, 8(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D688C: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 830D6890: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D6894: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D6898: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D689C: 7F0B9800  cmpw cr6, r11, r19
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[19].s32, &mut ctx.xer);
	// 830D68A0: 409A00E8  bne cr6, 0x830d6988
	if !ctx.cr[6].eq {
	pc = 0x830D6988; continue 'dispatch;
	}
	// 830D68A4: 81520000  lwz r10, 0(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D68A8: 546B1838  slwi r11, r3, 3
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D68AC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830D68B0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D68B4: 8155002C  lwz r10, 0x2c(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(44 as u32) ) } as u64;
	// 830D68B8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 830D68BC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D68C0: 81750034  lwz r11, 0x34(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(52 as u32) ) } as u64;
	// 830D68C4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830D68C8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D68CC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D68D0: 7FEB502E  lwzx r31, r11, r10
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D68D4: 4BC878C5  bl 0x82d5e198
	ctx.lr = 0x830D68D8;
	sub_82D5E198(ctx, base);
	// 830D68D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D68DC: 4BC8234D  bl 0x82d58c28
	ctx.lr = 0x830D68E0;
	sub_82D58C28(ctx, base);
	// 830D68E0: 38A30001  addi r5, r3, 1
	ctx.r[5].s64 = ctx.r[3].s64 + 1;
	// 830D68E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D68E8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830D68EC: 4BC8751D  bl 0x82d5de08
	ctx.lr = 0x830D68F0;
	sub_82D5DE08(ctx, base);
	// 830D68F0: 83F8001C  lwz r31, 0x1c(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D68F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D68F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D68FC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D6900: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6904: 4E800421  bctrl
	ctx.lr = 0x830D6908;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6908: 3961017C  addi r11, r1, 0x17c
	ctx.r[11].s64 = ctx.r[1].s64 + 380;
	// 830D690C: 92C10178  stw r22, 0x178(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[22].u32 ) };
	// 830D6910: 91610170  stw r11, 0x170(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[11].u32 ) };
	// 830D6914: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
            }
            0x830D6918 => {
    //   block [0x830D6918..0x830D695C)
	// 830D6918: 81410170  lwz r10, 0x170(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) } as u64;
	// 830D691C: 7E0A59AE  stbx r16, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[16].u8) };
	// 830D6920: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D6924: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830D6928: 4198FFF0  blt cr6, 0x830d6918
	if ctx.cr[6].lt {
	pc = 0x830D6918; continue 'dispatch;
	}
	// 830D692C: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830D6930: 546B07BE  clrlwi r11, r3, 0x1e
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000003u64;
	// 830D6934: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D6938: 91410174  stw r10, 0x174(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), ctx.r[10].u32 ) };
	// 830D693C: 419A0020  beq cr6, 0x830d695c
	if ctx.cr[6].eq {
	pc = 0x830D695C; continue 'dispatch;
	}
	// 830D6940: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6944: 20AB0004  subfic r5, r11, 4
	ctx.xer.ca = ctx.r[11].u32 <= 4 as u32;
	ctx.r[5].s64 = (4 as i64) - ctx.r[11].s64;
	// 830D6948: 80810170  lwz r4, 0x170(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) } as u64;
	// 830D694C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D6950: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D6954: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6958: 4E800421  bctrl
	ctx.lr = 0x830D695C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830D695C => {
    //   block [0x830D695C..0x830D6988)
	// 830D695C: 81610178  lwz r11, 0x178(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) } as u64;
	// 830D6960: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D6964: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D6968: 409A0020  bne cr6, 0x830d6988
	if !ctx.cr[6].eq {
	pc = 0x830D6988; continue 'dispatch;
	}
	// 830D696C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6970: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D6974: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D6978: 80810170  lwz r4, 0x170(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) } as u64;
	// 830D697C: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D6980: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D6984: 4BC7E945  bl 0x82d552c8
	ctx.lr = 0x830D6988;
	sub_82D552C8(ctx, base);
	pc = 0x830D6988; continue 'dispatch;
            }
            0x830D6988 => {
    //   block [0x830D6988..0x830D69A4)
	// 830D6988: 81150034  lwz r8, 0x34(r21)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(52 as u32) ) } as u64;
	// 830D698C: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 830D6990: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830D6994: 4199FEAC  bgt cr6, 0x830d6840
	if ctx.cr[6].gt {
	pc = 0x830D6840; continue 'dispatch;
	}
	// 830D6998: 8135002C  lwz r9, 0x2c(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(44 as u32) ) } as u64;
	// 830D699C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830D69A0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	pc = 0x830D69A4; continue 'dispatch;
            }
            0x830D69A4 => {
    //   block [0x830D69A4..0x830D69C4)
	// 830D69A4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D69A8: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 830D69AC: 409AFE94  bne cr6, 0x830d6840
	if !ctx.cr[6].eq {
	pc = 0x830D6840; continue 'dispatch;
	}
	// 830D69B0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D69B4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830D69B8: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830D69BC: 4099FFE8  ble cr6, 0x830d69a4
	if !ctx.cr[6].gt {
	pc = 0x830D69A4; continue 'dispatch;
	}
	// 830D69C0: 4BFFFE80  b 0x830d6840
	pc = 0x830D6840; continue 'dispatch;
            }
            0x830D69C4 => {
    //   block [0x830D69C4..0x830D6A04)
	// 830D69C4: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 830D69C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D69CC: 419A00A8  beq cr6, 0x830d6a74
	if ctx.cr[6].eq {
	pc = 0x830D6A74; continue 'dispatch;
	}
	// 830D69D0: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 830D69D4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830D69D8: 4BC877C1  bl 0x82d5e198
	ctx.lr = 0x830D69DC;
	sub_82D5E198(ctx, base);
	// 830D69DC: 83F8001C  lwz r31, 0x1c(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D69E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D69E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D69E8: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D69EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D69F0: 4E800421  bctrl
	ctx.lr = 0x830D69F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D69F4: 396100EC  addi r11, r1, 0xec
	ctx.r[11].s64 = ctx.r[1].s64 + 236;
	// 830D69F8: 92C100E8  stw r22, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[22].u32 ) };
	// 830D69FC: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 830D6A00: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
            }
            0x830D6A04 => {
    //   block [0x830D6A04..0x830D6A48)
	// 830D6A04: 814100E0  lwz r10, 0xe0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) } as u64;
	// 830D6A08: 7E0A59AE  stbx r16, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[16].u8) };
	// 830D6A0C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D6A10: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 830D6A14: 4198FFF0  blt cr6, 0x830d6a04
	if ctx.cr[6].lt {
	pc = 0x830D6A04; continue 'dispatch;
	}
	// 830D6A18: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 830D6A1C: 546B073E  clrlwi r11, r3, 0x1c
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 830D6A20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D6A24: 914100E4  stw r10, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[10].u32 ) };
	// 830D6A28: 419A0020  beq cr6, 0x830d6a48
	if ctx.cr[6].eq {
	pc = 0x830D6A48; continue 'dispatch;
	}
	// 830D6A2C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6A30: 20AB0010  subfic r5, r11, 0x10
	ctx.xer.ca = ctx.r[11].u32 <= 16 as u32;
	ctx.r[5].s64 = (16 as i64) - ctx.r[11].s64;
	// 830D6A34: 808100E0  lwz r4, 0xe0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) } as u64;
	// 830D6A38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D6A3C: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D6A40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6A44: 4E800421  bctrl
	ctx.lr = 0x830D6A48;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830D6A48 => {
    //   block [0x830D6A48..0x830D6A74)
	// 830D6A48: 816100E8  lwz r11, 0xe8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) } as u64;
	// 830D6A4C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D6A50: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D6A54: 409A0020  bne cr6, 0x830d6a74
	if !ctx.cr[6].eq {
	pc = 0x830D6A74; continue 'dispatch;
	}
	// 830D6A58: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6A5C: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D6A60: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D6A64: 808100E0  lwz r4, 0xe0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) } as u64;
	// 830D6A68: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D6A6C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D6A70: 4BC7E859  bl 0x82d552c8
	ctx.lr = 0x830D6A74;
	sub_82D552C8(ctx, base);
	pc = 0x830D6A74; continue 'dispatch;
            }
            0x830D6A74 => {
    //   block [0x830D6A74..0x830D6AA8)
	// 830D6A74: 8078001C  lwz r3, 0x1c(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D6A78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6A7C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D6A80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6A84: 4E800421  bctrl
	ctx.lr = 0x830D6A88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6A88: 81770014  lwz r11, 0x14(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D6A8C: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	// 830D6A90: 7D6B1850  subf r11, r11, r3
	ctx.r[11].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 830D6A94: 91770028  stw r11, 0x28(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 830D6A98: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830D6A9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D6AA0: 409900E8  ble cr6, 0x830d6b88
	if !ctx.cr[6].gt {
	pc = 0x830D6B88; continue 'dispatch;
	}
	// 830D6AA4: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
            }
            0x830D6AA8 => {
    //   block [0x830D6AA8..0x830D6B00)
	// 830D6AA8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 830D6AAC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830D6AB0: 7FEBF214  add r31, r11, r30
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830D6AB4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6AB8: 4BC876E1  bl 0x82d5e198
	ctx.lr = 0x830D6ABC;
	sub_82D5E198(ctx, base);
	// 830D6ABC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D6AC0: 4BC82169  bl 0x82d58c28
	ctx.lr = 0x830D6AC4;
	sub_82D58C28(ctx, base);
	// 830D6AC4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830D6AC8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D6ACC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830D6AD0: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 830D6AD4: 4BC87335  bl 0x82d5de08
	ctx.lr = 0x830D6AD8;
	sub_82D5DE08(ctx, base);
	// 830D6AD8: 83F8001C  lwz r31, 0x1c(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D6ADC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D6AE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6AE4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D6AE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6AEC: 4E800421  bctrl
	ctx.lr = 0x830D6AF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6AF0: 3961014C  addi r11, r1, 0x14c
	ctx.r[11].s64 = ctx.r[1].s64 + 332;
	// 830D6AF4: 92C10148  stw r22, 0x148(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), ctx.r[22].u32 ) };
	// 830D6AF8: 91610140  stw r11, 0x140(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 830D6AFC: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
            }
            0x830D6B00 => {
    //   block [0x830D6B00..0x830D6B44)
	// 830D6B00: 81410140  lwz r10, 0x140(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(320 as u32) ) } as u64;
	// 830D6B04: 7E0A59AE  stbx r16, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[16].u8) };
	// 830D6B08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D6B0C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830D6B10: 4198FFF0  blt cr6, 0x830d6b00
	if ctx.cr[6].lt {
	pc = 0x830D6B00; continue 'dispatch;
	}
	// 830D6B14: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830D6B18: 546B07BE  clrlwi r11, r3, 0x1e
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000003u64;
	// 830D6B1C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D6B20: 91410144  stw r10, 0x144(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), ctx.r[10].u32 ) };
	// 830D6B24: 419A0020  beq cr6, 0x830d6b44
	if ctx.cr[6].eq {
	pc = 0x830D6B44; continue 'dispatch;
	}
	// 830D6B28: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6B2C: 20AB0004  subfic r5, r11, 4
	ctx.xer.ca = ctx.r[11].u32 <= 4 as u32;
	ctx.r[5].s64 = (4 as i64) - ctx.r[11].s64;
	// 830D6B30: 80810140  lwz r4, 0x140(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(320 as u32) ) } as u64;
	// 830D6B34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D6B38: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D6B3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6B40: 4E800421  bctrl
	ctx.lr = 0x830D6B44;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830D6B44 => {
    //   block [0x830D6B44..0x830D6B70)
	// 830D6B44: 81610148  lwz r11, 0x148(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(328 as u32) ) } as u64;
	// 830D6B48: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D6B4C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D6B50: 409A0020  bne cr6, 0x830d6b70
	if !ctx.cr[6].eq {
	pc = 0x830D6B70; continue 'dispatch;
	}
	// 830D6B54: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6B58: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D6B5C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D6B60: 80810140  lwz r4, 0x140(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(320 as u32) ) } as u64;
	// 830D6B64: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D6B68: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D6B6C: 4BC7E75D  bl 0x82d552c8
	ctx.lr = 0x830D6B70;
	sub_82D552C8(ctx, base);
	pc = 0x830D6B70; continue 'dispatch;
            }
            0x830D6B70 => {
    //   block [0x830D6B70..0x830D6B88)
	// 830D6B70: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830D6B74: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830D6B78: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 830D6B7C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D6B80: 4198FF28  blt cr6, 0x830d6aa8
	if ctx.cr[6].lt {
	pc = 0x830D6AA8; continue 'dispatch;
	}
	// 830D6B84: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	pc = 0x830D6B88; continue 'dispatch;
            }
            0x830D6B88 => {
    //   block [0x830D6B88..0x830D6BF8)
	// 830D6B88: 419A00E0  beq cr6, 0x830d6c68
	if ctx.cr[6].eq {
	pc = 0x830D6C68; continue 'dispatch;
	}
	// 830D6B8C: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 830D6B90: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830D6B94: 4BC87605  bl 0x82d5e198
	ctx.lr = 0x830D6B98;
	sub_82D5E198(ctx, base);
	// 830D6B98: 81710000  lwz r11, 0(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6B9C: 81210084  lwz r9, 0x84(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 830D6BA0: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830D6BA4: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 830D6BA8: 912B0024  stw r9, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 830D6BAC: 81210088  lwz r9, 0x88(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830D6BB0: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 830D6BB4: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 830D6BB8: 912B0028  stw r9, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 830D6BBC: 8121008C  lwz r9, 0x8c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 830D6BC0: 91410088  stw r10, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 830D6BC4: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 830D6BC8: 912B002C  stw r9, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 830D6BCC: 83F8001C  lwz r31, 0x1c(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D6BD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D6BD4: 9141008C  stw r10, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 830D6BD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6BDC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D6BE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6BE4: 4E800421  bctrl
	ctx.lr = 0x830D6BE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6BE8: 396101AC  addi r11, r1, 0x1ac
	ctx.r[11].s64 = ctx.r[1].s64 + 428;
	// 830D6BEC: 92C101A8  stw r22, 0x1a8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(424 as u32), ctx.r[22].u32 ) };
	// 830D6BF0: 916101A0  stw r11, 0x1a0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), ctx.r[11].u32 ) };
	// 830D6BF4: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
            }
            0x830D6BF8 => {
    //   block [0x830D6BF8..0x830D6C3C)
	// 830D6BF8: 814101A0  lwz r10, 0x1a0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(416 as u32) ) } as u64;
	// 830D6BFC: 7E0A59AE  stbx r16, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[16].u8) };
	// 830D6C00: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D6C04: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 830D6C08: 4198FFF0  blt cr6, 0x830d6bf8
	if ctx.cr[6].lt {
	pc = 0x830D6BF8; continue 'dispatch;
	}
	// 830D6C0C: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 830D6C10: 546B073E  clrlwi r11, r3, 0x1c
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 830D6C14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D6C18: 914101A4  stw r10, 0x1a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(420 as u32), ctx.r[10].u32 ) };
	// 830D6C1C: 419A0020  beq cr6, 0x830d6c3c
	if ctx.cr[6].eq {
	pc = 0x830D6C3C; continue 'dispatch;
	}
	// 830D6C20: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6C24: 20AB0010  subfic r5, r11, 0x10
	ctx.xer.ca = ctx.r[11].u32 <= 16 as u32;
	ctx.r[5].s64 = (16 as i64) - ctx.r[11].s64;
	// 830D6C28: 808101A0  lwz r4, 0x1a0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(416 as u32) ) } as u64;
	// 830D6C2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D6C30: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D6C34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6C38: 4E800421  bctrl
	ctx.lr = 0x830D6C3C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830D6C3C => {
    //   block [0x830D6C3C..0x830D6C68)
	// 830D6C3C: 816101A8  lwz r11, 0x1a8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(424 as u32) ) } as u64;
	// 830D6C40: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D6C44: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D6C48: 409A0020  bne cr6, 0x830d6c68
	if !ctx.cr[6].eq {
	pc = 0x830D6C68; continue 'dispatch;
	}
	// 830D6C4C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6C50: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D6C54: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D6C58: 808101A0  lwz r4, 0x1a0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(416 as u32) ) } as u64;
	// 830D6C5C: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D6C60: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D6C64: 4BC7E665  bl 0x82d552c8
	ctx.lr = 0x830D6C68;
	sub_82D552C8(ctx, base);
	pc = 0x830D6C68; continue 'dispatch;
            }
            0x830D6C68 => {
    //   block [0x830D6C68..0x830D6CAC)
	// 830D6C68: 8078001C  lwz r3, 0x1c(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D6C6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6C70: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D6C74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6C78: 4E800421  bctrl
	ctx.lr = 0x830D6C7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6C7C: 81770014  lwz r11, 0x14(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D6C80: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 830D6C84: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830D6C88: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830D6C8C: 9177002C  stw r11, 0x2c(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 830D6C90: 4BC87429  bl 0x82d5e0b8
	ctx.lr = 0x830D6C94;
	sub_82D5E0B8(ctx, base);
	// 830D6C94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830D6C98: 4BC9E991  bl 0x82d75628
	ctx.lr = 0x830D6C9C;
	sub_82D75628(ctx, base);
	// 830D6C9C: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D6CA0: 3A730001  addi r19, r19, 1
	ctx.r[19].s64 = ctx.r[19].s64 + 1;
	// 830D6CA4: 7F135800  cmpw cr6, r19, r11
	ctx.cr[6].compare_i32(ctx.r[19].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D6CA8: 4198F560  blt cr6, 0x830d6208
	if ctx.cr[6].lt {
	pc = 0x830D6208; continue 'dispatch;
	}
            }
            0x830D6CAC => {
    //   block [0x830D6CAC..0x830D6CB4)
	// 830D6CAC: 382102D0  addi r1, r1, 0x2d0
	ctx.r[1].s64 = ctx.r[1].s64 + 720;
	// 830D6CB0: 4BBD2770  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D6CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D6CB8 size=300
    let mut pc: u32 = 0x830D6CB8;
    'dispatch: loop {
        match pc {
            0x830D6CB8 => {
    //   block [0x830D6CB8..0x830D6DE4)
	// 830D6CB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D6CBC: 4BBD2751  bl 0x82ca940c
	ctx.lr = 0x830D6CC0;
	sub_82CA93D0(ctx, base);
	// 830D6CC0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D6CC4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830D6CC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D6CCC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830D6CD0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830D6CD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830D6CD8: 480002A1  bl 0x830d6f78
	ctx.lr = 0x830D6CDC;
	sub_830D6F78(ctx, base);
	// 830D6CDC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D6CE0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830D6CE4: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 830D6CE8: 396B9BB4  addi r11, r11, -0x644c
	ctx.r[11].s64 = ctx.r[11].s64 + -25676;
	// 830D6CEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D6CF0: B1410056  sth r10, 0x56(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[10].u16 ) };
	// 830D6CF4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830D6CF8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6CFC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D6D00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6D04: 4E800421  bctrl
	ctx.lr = 0x830D6D08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6D08: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830D6D0C: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 830D6D10: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830D6D14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D6D18: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830D6D1C: 4BFFEB95  bl 0x830d58b0
	ctx.lr = 0x830D6D20;
	sub_830D58B0(ctx, base);
	// 830D6D20: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830D6D24: 80C10068  lwz r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830D6D28: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830D6D2C: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 830D6D30: 4BFFE971  bl 0x830d56a0
	ctx.lr = 0x830D6D34;
	sub_830D56A0(ctx, base);
	// 830D6D34: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D6D38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D6D3C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D6D40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6D44: 4E800421  bctrl
	ctx.lr = 0x830D6D48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6D48: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D6D4C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830D6D50: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830D6D54: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830D6D58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D6D5C: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D6D60: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830D6D64: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D6D68: 55642036  slwi r4, r11, 4
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830D6D6C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 830D6D70: 4E800421  bctrl
	ctx.lr = 0x830D6D74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6D74: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830D6D78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D6D7C: 4BFFF09D  bl 0x830d5e18
	ctx.lr = 0x830D6D80;
	sub_830D5E18(ctx, base);
	// 830D6D80: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D6D84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D6D88: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D6D8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6D90: 4E800421  bctrl
	ctx.lr = 0x830D6D94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6D94: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830D6D98: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830D6D9C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830D6DA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D6DA4: 4BFFEBC5  bl 0x830d5968
	ctx.lr = 0x830D6DA8;
	sub_830D5968(ctx, base);
	// 830D6DA8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D6DAC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D6DB0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830D6DB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D6DB8: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D6DBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6DC0: 4E800421  bctrl
	ctx.lr = 0x830D6DC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6DC4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D6DC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830D6DCC: 396B39E0  addi r11, r11, 0x39e0
	ctx.r[11].s64 = ctx.r[11].s64 + 14816;
	// 830D6DD0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830D6DD4: 4800022D  bl 0x830d7000
	ctx.lr = 0x830D6DD8;
	sub_830D7000(ctx, base);
	// 830D6DD8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830D6DDC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 830D6DE0: 4BBD267C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D6DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D6DE8 size=64
    let mut pc: u32 = 0x830D6DE8;
    'dispatch: loop {
        match pc {
            0x830D6DE8 => {
    //   block [0x830D6DE8..0x830D6E28)
	// 830D6DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D6DEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830D6DF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830D6DF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D6DF8: 80840008  lwz r4, 8(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D6DFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D6E00: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6E04: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D6E08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6E0C: 4E800421  bctrl
	ctx.lr = 0x830D6E10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6E10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D6E14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830D6E18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830D6E1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830D6E20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830D6E24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D6E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830D6E28 size=20
    let mut pc: u32 = 0x830D6E28;
    'dispatch: loop {
        match pc {
            0x830D6E28 => {
    //   block [0x830D6E28..0x830D6E3C)
	// 830D6E28: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D6E2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6E30: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D6E34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6E38: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D6E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830D6E40 size=20
    let mut pc: u32 = 0x830D6E40;
    'dispatch: loop {
        match pc {
            0x830D6E40 => {
    //   block [0x830D6E40..0x830D6E54)
	// 830D6E40: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D6E44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6E48: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D6E4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6E50: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D6E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D6E58 size=64
    let mut pc: u32 = 0x830D6E58;
    'dispatch: loop {
        match pc {
            0x830D6E58 => {
    //   block [0x830D6E58..0x830D6E98)
	// 830D6E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D6E5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830D6E60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830D6E64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D6E68: 80840008  lwz r4, 8(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D6E6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D6E70: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6E74: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D6E78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6E7C: 4E800421  bctrl
	ctx.lr = 0x830D6E80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6E80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D6E84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830D6E88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830D6E8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830D6E90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830D6E94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D6E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830D6E98 size=36
    let mut pc: u32 = 0x830D6E98;
    'dispatch: loop {
        match pc {
            0x830D6E98 => {
    //   block [0x830D6E98..0x830D6EA8)
	// 830D6E98: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830D6E9C: 409A000C  bne cr6, 0x830d6ea8
	if !ctx.cr[6].eq {
	pc = 0x830D6EA8; continue 'dispatch;
	}
	// 830D6EA0: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D6EA4: 7C8B2214  add r4, r11, r4
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	pc = 0x830D6EA8; continue 'dispatch;
            }
            0x830D6EA8 => {
    //   block [0x830D6EA8..0x830D6EBC)
	// 830D6EA8: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D6EAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6EB0: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D6EB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6EB8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D6EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D6EC0 size=68
    let mut pc: u32 = 0x830D6EC0;
    'dispatch: loop {
        match pc {
            0x830D6EC0 => {
    //   block [0x830D6EC0..0x830D6F04)
	// 830D6EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D6EC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830D6EC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830D6ECC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D6ED0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D6ED4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D6ED8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6EDC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D6EE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D6EE4: 4E800421  bctrl
	ctx.lr = 0x830D6EE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D6EE8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D6EEC: 7C6B1850  subf r3, r11, r3
	ctx.r[3].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 830D6EF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830D6EF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830D6EF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830D6EFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830D6F00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D6F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D6F08 size=112
    let mut pc: u32 = 0x830D6F08;
    'dispatch: loop {
        match pc {
            0x830D6F08 => {
    //   block [0x830D6F08..0x830D6F5C)
	// 830D6F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D6F0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830D6F10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830D6F14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830D6F18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D6F1C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D6F20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D6F24: 396B9B84  addi r11, r11, -0x647c
	ctx.r[11].s64 = ctx.r[11].s64 + -25724;
	// 830D6F28: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830D6F2C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830D6F30: 48001FD9  bl 0x830d8f08
	ctx.lr = 0x830D6F34;
	sub_830D8F08(ctx, base);
	// 830D6F34: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 830D6F38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D6F3C: 419A0020  beq cr6, 0x830d6f5c
	if ctx.cr[6].eq {
	pc = 0x830D6F5C; continue 'dispatch;
	}
	// 830D6F40: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D6F44: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830D6F48: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 830D6F4C: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D6F50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D6F54: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830D6F58: 4BC7E371  bl 0x82d552c8
	ctx.lr = 0x830D6F5C;
	sub_82D552C8(ctx, base);
	pc = 0x830D6F5C; continue 'dispatch;
            }
            0x830D6F5C => {
    //   block [0x830D6F5C..0x830D6F78)
	// 830D6F5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D6F60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830D6F64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830D6F68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830D6F6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830D6F70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830D6F74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D6F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D6F78 size=136
    let mut pc: u32 = 0x830D6F78;
    'dispatch: loop {
        match pc {
            0x830D6F78 => {
    //   block [0x830D6F78..0x830D7000)
	// 830D6F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D6F7C: 4BBD248D  bl 0x82ca9408
	ctx.lr = 0x830D6F80;
	sub_82CA93D0(ctx, base);
	// 830D6F80: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D6F84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D6F88: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830D6F8C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830D6F90: 3F808000  lis r28, -0x8000
	ctx.r[28].s64 = -2147483648;
	// 830D6F94: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 830D6F98: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 830D6F9C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830D6FA0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830D6FA4: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830D6FA8: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 830D6FAC: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 830D6FB0: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 830D6FB4: 939F0018  stw r28, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[28].u32 ) };
	// 830D6FB8: 4BFFD4D1  bl 0x830d4488
	ctx.lr = 0x830D6FBC;
	sub_830D4488(ctx, base);
	// 830D6FBC: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 830D6FC0: 4BC88069  bl 0x82d5f028
	ctx.lr = 0x830D6FC4;
	sub_82D5F028(ctx, base);
	// 830D6FC4: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 830D6FC8: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 830D6FCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D6FD0: 396B7D58  addi r11, r11, 0x7d58
	ctx.r[11].s64 = ctx.r[11].s64 + 32088;
	// 830D6FD4: 93DF0040  stw r30, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	// 830D6FD8: 939F0044  stw r28, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[28].u32 ) };
	// 830D6FDC: 895D0005  lbz r10, 5(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(5 as u32) ) } as u64;
	// 830D6FE0: 896B0001  lbz r11, 1(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 830D6FE4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830D6FE8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830D6FEC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830D6FF0: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 830D6FF4: 997F0048  stb r11, 0x48(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u8 ) };
	// 830D6FF8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830D6FFC: 4BBD245C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D7000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D7000 size=232
    let mut pc: u32 = 0x830D7000;
    'dispatch: loop {
        match pc {
            0x830D7000 => {
    //   block [0x830D7000..0x830D7020)
	// 830D7000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D7004: 4BBD2409  bl 0x82ca940c
	ctx.lr = 0x830D7008;
	sub_82CA93D0(ctx, base);
	// 830D7008: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D700C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830D7010: 83FD0040  lwz r31, 0x40(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 830D7014: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830D7018: 40990024  ble cr6, 0x830d703c
	if !ctx.cr[6].gt {
	pc = 0x830D703C; continue 'dispatch;
	}
	// 830D701C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x830D7020; continue 'dispatch;
            }
            0x830D7020 => {
    //   block [0x830D7020..0x830D703C)
	// 830D7020: 817D003C  lwz r11, 0x3c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 830D7024: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830D7028: 4BC9E601  bl 0x82d75628
	ctx.lr = 0x830D702C;
	sub_82D75628(ctx, base);
	// 830D702C: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 830D7030: 3BDE0034  addi r30, r30, 0x34
	ctx.r[30].s64 = ctx.r[30].s64 + 52;
	// 830D7034: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830D7038: 409AFFE8  bne cr6, 0x830d7020
	if !ctx.cr[6].eq {
	pc = 0x830D7020; continue 'dispatch;
	}
	pc = 0x830D703C; continue 'dispatch;
            }
            0x830D703C => {
    //   block [0x830D703C..0x830D706C)
	// 830D703C: 817D0044  lwz r11, 0x44(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(68 as u32) ) } as u64;
	// 830D7040: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D7044: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D7048: 409A0024  bne cr6, 0x830d706c
	if !ctx.cr[6].eq {
	pc = 0x830D706C; continue 'dispatch;
	}
	// 830D704C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7050: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D7054: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D7058: 809D003C  lwz r4, 0x3c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 830D705C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D7060: 1CAB0034  mulli r5, r11, 0x34
	ctx.r[5].s32 = ((ctx.r[11].s32 as i64 * 52 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 830D7064: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D7068: 4BC7E261  bl 0x82d552c8
	ctx.lr = 0x830D706C;
	sub_82D552C8(ctx, base);
	pc = 0x830D706C; continue 'dispatch;
            }
            0x830D706C => {
    //   block [0x830D706C..0x830D70A8)
	// 830D706C: 387D0030  addi r3, r29, 0x30
	ctx.r[3].s64 = ctx.r[29].s64 + 48;
	// 830D7070: 4BC88021  bl 0x82d5f090
	ctx.lr = 0x830D7074;
	sub_82D5F090(ctx, base);
	// 830D7074: 387D0020  addi r3, r29, 0x20
	ctx.r[3].s64 = ctx.r[29].s64 + 32;
	// 830D7078: 4BFFD571  bl 0x830d45e8
	ctx.lr = 0x830D707C;
	sub_830D45E8(ctx, base);
	// 830D707C: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D7080: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D7084: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D7088: 409A0020  bne cr6, 0x830d70a8
	if !ctx.cr[6].eq {
	pc = 0x830D70A8; continue 'dispatch;
	}
	// 830D708C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7090: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D7094: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D7098: 809D0010  lwz r4, 0x10(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D709C: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830D70A0: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D70A4: 4BC7E225  bl 0x82d552c8
	ctx.lr = 0x830D70A8;
	sub_82D552C8(ctx, base);
	pc = 0x830D70A8; continue 'dispatch;
            }
            0x830D70A8 => {
    //   block [0x830D70A8..0x830D70E0)
	// 830D70A8: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D70AC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D70B0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D70B4: 409A002C  bne cr6, 0x830d70e0
	if !ctx.cr[6].eq {
	pc = 0x830D70E0; continue 'dispatch;
	}
	// 830D70B8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D70BC: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D70C0: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D70C4: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D70C8: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D70CC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D70D0: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830D70D4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D70D8: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830D70DC: 4BC7E1ED  bl 0x82d552c8
	ctx.lr = 0x830D70E0;
	sub_82D552C8(ctx, base);
	pc = 0x830D70E0; continue 'dispatch;
            }
            0x830D70E0 => {
    //   block [0x830D70E0..0x830D70E8)
	// 830D70E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830D70E4: 4BBD2378  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D70E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D70E8 size=1472
    let mut pc: u32 = 0x830D70E8;
    'dispatch: loop {
        match pc {
            0x830D70E8 => {
    //   block [0x830D70E8..0x830D71FC)
	// 830D70E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D70EC: 4BBD2301  bl 0x82ca93ec
	ctx.lr = 0x830D70F0;
	sub_82CA93D0(ctx, base);
	// 830D70F0: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D70F4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 830D70F8: 3FE08000  lis r31, -0x8000
	ctx.r[31].s64 = -2147483648;
	// 830D70FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830D7100: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830D7104: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830D7108: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 830D710C: 93010070  stw r24, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[24].u32 ) };
	// 830D7110: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 830D7114: 93010074  stw r24, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[24].u32 ) };
	// 830D7118: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 830D711C: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 830D7120: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 830D7124: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 830D7128: 4BC81289  bl 0x82d583b0
	ctx.lr = 0x830D712C;
	sub_82D583B0(ctx, base);
	// 830D712C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 830D7130: 930100A0  stw r24, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[24].u32 ) };
	// 830D7134: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D7138: 930100A4  stw r24, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[24].u32 ) };
	// 830D713C: 93E100A8  stw r31, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[31].u32 ) };
	// 830D7140: 930100AC  stw r24, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[24].u32 ) };
	// 830D7144: 930100B0  stw r24, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[24].u32 ) };
	// 830D7148: 93E100B4  stw r31, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[31].u32 ) };
	// 830D714C: 930100B8  stw r24, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[24].u32 ) };
	// 830D7150: 930100BC  stw r24, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[24].u32 ) };
	// 830D7154: 93E100C0  stw r31, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[31].u32 ) };
	// 830D7158: 930100C4  stw r24, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[24].u32 ) };
	// 830D715C: 930100C8  stw r24, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[24].u32 ) };
	// 830D7160: 93E100CC  stw r31, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[31].u32 ) };
	// 830D7164: 930100D0  stw r24, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[24].u32 ) };
	// 830D7168: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 830D716C: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 830D7170: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 830D7174: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 830D7178: 93A10084  stw r29, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	// 830D717C: 4BC7FE1D  bl 0x82d56f98
	ctx.lr = 0x830D7180;
	sub_82D56F98(ctx, base);
	// 830D7180: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830D7184: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830D7188: E9410080  ld r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 830D718C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D7190: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D7194: 7D4B492A  stdx r10, r11, r9
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u64) };
	// 830D7198: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830D719C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D71A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830D71A4: 4B18FD9D  bl 0x82266f40
	ctx.lr = 0x830D71A8;
	sub_82266F40(ctx, base);
	// 830D71A8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 830D71AC: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 830D71B0: 386100D4  addi r3, r1, 0xd4
	ctx.r[3].s64 = ctx.r[1].s64 + 212;
	// 830D71B4: 93010064  stw r24, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[24].u32 ) };
	// 830D71B8: 3BCB7D58  addi r30, r11, 0x7d58
	ctx.r[30].s64 = ctx.r[11].s64 + 32088;
	// 830D71BC: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 830D71C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D71C4: 4BC9A4A5  bl 0x82d71668
	ctx.lr = 0x830D71C8;
	sub_82D71668(ctx, base);
	// 830D71C8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830D71CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D71D0: 4BC9A499  bl 0x82d71668
	ctx.lr = 0x830D71D4;
	sub_82D71668(ctx, base);
	// 830D71D4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830D71D8: 38A100D4  addi r5, r1, 0xd4
	ctx.r[5].s64 = ctx.r[1].s64 + 212;
	// 830D71DC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830D71E0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 830D71E4: 4BC9E675  bl 0x82d75858
	ctx.lr = 0x830D71E8;
	sub_82D75858(ctx, base);
	// 830D71E8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830D71EC: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	// 830D71F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D71F4: 409901E0  ble cr6, 0x830d73d4
	if !ctx.cr[6].gt {
	pc = 0x830D73D4; continue 'dispatch;
	}
	// 830D71F8: 7F1AC378  mr r26, r24
	ctx.r[26].u64 = ctx.r[24].u64;
	pc = 0x830D71FC; continue 'dispatch;
            }
            0x830D71FC => {
    //   block [0x830D71FC..0x830D7254)
	// 830D71FC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D7200: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830D7204: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 830D7208: 7FDA582E  lwzx r30, r26, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830D720C: 7D7A5A14  add r11, r26, r11
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 830D7210: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D7214: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D7218: 4B18E9E9  bl 0x82265c00
	ctx.lr = 0x830D721C;
	sub_82265C00(ctx, base);
	// 830D721C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D7220: 83A100B0  lwz r29, 0xb0(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 830D7224: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 830D7228: 4BC7E8C9  bl 0x82d55af0
	ctx.lr = 0x830D722C;
	sub_82D55AF0(ctx, base);
	// 830D722C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7230: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D7234: 419A0020  beq cr6, 0x830d7254
	if ctx.cr[6].eq {
	pc = 0x830D7254; continue 'dispatch;
	}
	// 830D7238: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D723C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D7240: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 830D7244: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D7248: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D724C: 4E800421  bctrl
	ctx.lr = 0x830D7250;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D7250: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            0x830D7254 => {
    //   block [0x830D7254..0x830D7288)
	// 830D7254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D7258: 83810074  lwz r28, 0x74(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 830D725C: 4BC7E4F5  bl 0x82d55750
	ctx.lr = 0x830D7260;
	sub_82D55750(ctx, base);
	// 830D7260: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830D7264: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830D7268: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D726C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830D7270: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830D7274: 409A0014  bne cr6, 0x830d7288
	if !ctx.cr[6].eq {
	pc = 0x830D7288; continue 'dispatch;
	}
	// 830D7278: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 830D727C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830D7280: 4BC7FD19  bl 0x82d56f98
	ctx.lr = 0x830D7284;
	sub_82D56F98(ctx, base);
	// 830D7284: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	pc = 0x830D7288; continue 'dispatch;
            }
            0x830D7288 => {
    //   block [0x830D7288..0x830D72E8)
	// 830D7288: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830D728C: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 830D7290: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D7294: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D7298: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 830D729C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D72A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830D72A4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D72A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D72AC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 830D72B0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830D72B4: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830D72B8: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 830D72BC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830D72C0: 80C100E0  lwz r6, 0xe0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) } as u64;
	// 830D72C4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D72C8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 830D72CC: 4BC9FF35  bl 0x82d77200
	ctx.lr = 0x830D72D0;
	sub_82D77200(ctx, base);
	// 830D72D0: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 830D72D4: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D72D8: 409800E8  bge cr6, 0x830d73c0
	if !ctx.cr[6].lt {
	pc = 0x830D73C0; continue 'dispatch;
	}
	// 830D72DC: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D72E0: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 830D72E4: 557E103A  slwi r30, r11, 2
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	pc = 0x830D72E8; continue 'dispatch;
            }
            0x830D72E8 => {
    //   block [0x830D72E8..0x830D7340)
	// 830D72E8: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 830D72EC: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830D72F0: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D72F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830D72F8: 419A00B4  beq cr6, 0x830d73ac
	if ctx.cr[6].eq {
	pc = 0x830D73AC; continue 'dispatch;
	}
	// 830D72FC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D7300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D7304: 419A00A8  beq cr6, 0x830d73ac
	if ctx.cr[6].eq {
	pc = 0x830D73AC; continue 'dispatch;
	}
	// 830D7308: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 830D730C: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 830D7310: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 830D7314: 419A002C  beq cr6, 0x830d7340
	if ctx.cr[6].eq {
	pc = 0x830D7340; continue 'dispatch;
	}
	// 830D7318: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D731C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D7320: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830D7324: 4BC89365  bl 0x82d60688
	ctx.lr = 0x830D7328;
	sub_82D60688(ctx, base);
	// 830D7328: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830D732C: 419A0014  beq cr6, 0x830d7340
	if ctx.cr[6].eq {
	pc = 0x830D7340; continue 'dispatch;
	}
	// 830D7330: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 830D7334: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830D7338: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 830D733C: 48000070  b 0x830d73ac
	pc = 0x830D73AC; continue 'dispatch;
            }
            0x830D7340 => {
    //   block [0x830D7340..0x830D7360)
	// 830D7340: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D7344: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830D7348: 4BC892E9  bl 0x82d60630
	ctx.lr = 0x830D734C;
	sub_82D60630(ctx, base);
	// 830D734C: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 830D7350: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D7354: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830D7358: 40990008  ble cr6, 0x830d7360
	if !ctx.cr[6].gt {
	pc = 0x830D7360; continue 'dispatch;
	}
	// 830D735C: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x830D7360; continue 'dispatch;
            }
            0x830D7360 => {
    //   block [0x830D7360..0x830D738C)
	// 830D7360: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830D7364: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D7368: 409A0044  bne cr6, 0x830d73ac
	if !ctx.cr[6].eq {
	pc = 0x830D73AC; continue 'dispatch;
	}
	// 830D736C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D7370: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830D7374: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D7378: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D737C: 409A0010  bne cr6, 0x830d738c
	if !ctx.cr[6].eq {
	pc = 0x830D738C; continue 'dispatch;
	}
	// 830D7380: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 830D7384: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D7388: 4BC7FC11  bl 0x82d56f98
	ctx.lr = 0x830D738C;
	sub_82D56F98(ctx, base);
	pc = 0x830D738C; continue 'dispatch;
            }
            0x830D738C => {
    //   block [0x830D738C..0x830D73AC)
	// 830D738C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830D7390: E9410080  ld r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 830D7394: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D7398: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D739C: 7D4B492A  stdx r10, r11, r9
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u64) };
	// 830D73A0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830D73A4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D73A8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x830D73AC; continue 'dispatch;
            }
            0x830D73AC => {
    //   block [0x830D73AC..0x830D73C0)
	// 830D73AC: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 830D73B0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830D73B4: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 830D73B8: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D73BC: 4198FF2C  blt cr6, 0x830d72e8
	if ctx.cr[6].lt {
	pc = 0x830D72E8; continue 'dispatch;
	}
	pc = 0x830D73C0; continue 'dispatch;
            }
            0x830D73C0 => {
    //   block [0x830D73C0..0x830D73D4)
	// 830D73C0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830D73C4: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 830D73C8: 3B5A0008  addi r26, r26, 8
	ctx.r[26].s64 = ctx.r[26].s64 + 8;
	// 830D73CC: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D73D0: 4198FE2C  blt cr6, 0x830d71fc
	if ctx.cr[6].lt {
	pc = 0x830D71FC; continue 'dispatch;
	}
	pc = 0x830D73D4; continue 'dispatch;
            }
            0x830D73D4 => {
    //   block [0x830D73D4..0x830D7418)
	// 830D73D4: 80810074  lwz r4, 0x74(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 830D73D8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830D73DC: 419A0210  beq cr6, 0x830d75ec
	if ctx.cr[6].eq {
	pc = 0x830D75EC; continue 'dispatch;
	}
	// 830D73E0: 832D0000  lwz r25, 0(r13)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D73E4: 3B400004  li r26, 4
	ctx.r[26].s64 = 4;
	// 830D73E8: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 830D73EC: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 830D73F0: 4BC7E089  bl 0x82d55478
	ctx.lr = 0x830D73F4;
	sub_82D55478(ctx, base);
	// 830D73F4: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 830D73F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830D73FC: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830D7400: 4BC81931  bl 0x82d58d30
	ctx.lr = 0x830D7404;
	sub_82D58D30(ctx, base);
	// 830D7404: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 830D7408: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 830D740C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D7410: 40990034  ble cr6, 0x830d7444
	if !ctx.cr[6].gt {
	pc = 0x830D7444; continue 'dispatch;
	}
	// 830D7414: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x830D7418; continue 'dispatch;
            }
            0x830D7418 => {
    //   block [0x830D7418..0x830D7444)
	// 830D7418: 812100A0  lwz r9, 0xa0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 830D741C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830D7420: 7D0B4A14  add r8, r11, r9
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830D7424: 7CEB482E  lwzx r7, r11, r9
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830D7428: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 830D742C: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D7430: 7D29EA14  add r9, r9, r29
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 830D7434: 7D27E92E  stwx r9, r7, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[29].u32), ctx.r[9].u32) };
	// 830D7438: 812100A4  lwz r9, 0xa4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 830D743C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830D7440: 4198FFD8  blt cr6, 0x830d7418
	if ctx.cr[6].lt {
	pc = 0x830D7418; continue 'dispatch;
	}
	pc = 0x830D7444; continue 'dispatch;
            }
            0x830D7444 => {
    //   block [0x830D7444..0x830D745C)
	// 830D7444: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 830D7448: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 830D744C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D7450: 40990054  ble cr6, 0x830d74a4
	if !ctx.cr[6].gt {
	pc = 0x830D74A4; continue 'dispatch;
	}
	// 830D7454: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 830D7458: 3B60FFFF  li r27, -1
	ctx.r[27].s64 = -1;
	pc = 0x830D745C; continue 'dispatch;
            }
            0x830D745C => {
    //   block [0x830D745C..0x830D7484)
	// 830D745C: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 830D7460: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830D7464: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830D7468: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830D746C: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D7470: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830D7474: 4BC89215  bl 0x82d60688
	ctx.lr = 0x830D7478;
	sub_82D60688(ctx, base);
	// 830D7478: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 830D747C: 419A0008  beq cr6, 0x830d7484
	if ctx.cr[6].eq {
	pc = 0x830D7484; continue 'dispatch;
	}
	// 830D7480: 7FC3EA14  add r30, r3, r29
	ctx.r[30].u64 = ctx.r[3].u64 + ctx.r[29].u64;
	pc = 0x830D7484; continue 'dispatch;
            }
            0x830D7484 => {
    //   block [0x830D7484..0x830D74A4)
	// 830D7484: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 830D7488: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830D748C: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830D7490: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 830D7494: 7FCBE92E  stwx r30, r11, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), ctx.r[30].u32) };
	// 830D7498: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 830D749C: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D74A0: 4198FFBC  blt cr6, 0x830d745c
	if ctx.cr[6].lt {
	pc = 0x830D745C; continue 'dispatch;
	}
	pc = 0x830D74A4; continue 'dispatch;
            }
            0x830D74A4 => {
    //   block [0x830D74A4..0x830D74C0)
	// 830D74A4: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 830D74A8: 419A0048  beq cr6, 0x830d74f0
	if ctx.cr[6].eq {
	pc = 0x830D74F0; continue 'dispatch;
	}
	// 830D74AC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830D74B0: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 830D74B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D74B8: 40990038  ble cr6, 0x830d74f0
	if !ctx.cr[6].gt {
	pc = 0x830D74F0; continue 'dispatch;
	}
	// 830D74BC: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	pc = 0x830D74C0; continue 'dispatch;
            }
            0x830D74C0 => {
    //   block [0x830D74C0..0x830D74F0)
	// 830D74C0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D74C4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830D74C8: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830D74CC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D74D0: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D74D4: 7CAAEA14  add r5, r10, r29
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 830D74D8: 4B18E729  bl 0x82265c00
	ctx.lr = 0x830D74DC;
	sub_82265C00(ctx, base);
	// 830D74DC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830D74E0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830D74E4: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 830D74E8: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D74EC: 4198FFD4  blt cr6, 0x830d74c0
	if ctx.cr[6].lt {
	pc = 0x830D74C0; continue 'dispatch;
	}
	pc = 0x830D74F0; continue 'dispatch;
            }
            0x830D74F0 => {
    //   block [0x830D74F0..0x830D750C)
	// 830D74F0: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 830D74F4: 419A0054  beq cr6, 0x830d7548
	if ctx.cr[6].eq {
	pc = 0x830D7548; continue 'dispatch;
	}
	// 830D74F8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830D74FC: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 830D7500: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D7504: 40990044  ble cr6, 0x830d7548
	if !ctx.cr[6].gt {
	pc = 0x830D7548; continue 'dispatch;
	}
	// 830D7508: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	pc = 0x830D750C; continue 'dispatch;
            }
            0x830D750C => {
    //   block [0x830D750C..0x830D7548)
	// 830D750C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D7510: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 830D7514: 81550000  lwz r10, 0(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7518: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830D751C: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D7520: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7524: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D7528: 7C8AEA14  add r4, r10, r29
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 830D752C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 830D7530: 4E800421  bctrl
	ctx.lr = 0x830D7534;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D7534: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830D7538: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830D753C: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 830D7540: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D7544: 4198FFC8  blt cr6, 0x830d750c
	if ctx.cr[6].lt {
	pc = 0x830D750C; continue 'dispatch;
	}
            }
            0x830D7548 => {
    //   block [0x830D7548..0x830D7580)
	// 830D7548: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 830D754C: 4BC9E395  bl 0x82d758e0
	ctx.lr = 0x830D7550;
	sub_82D758E0(ctx, base);
	// 830D7550: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830D7554: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D7558: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D755C: 409A0024  bne cr6, 0x830d7580
	if !ctx.cr[6].eq {
	pc = 0x830D7580; continue 'dispatch;
	}
	// 830D7560: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D7564: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 830D7568: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D756C: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D7570: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830D7574: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D7578: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830D757C: 4BC7DD4D  bl 0x82d552c8
	ctx.lr = 0x830D7580;
	sub_82D552C8(ctx, base);
	pc = 0x830D7580; continue 'dispatch;
            }
            0x830D7580 => {
    //   block [0x830D7580..0x830D75AC)
	// 830D7580: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830D7584: 4B18F985  bl 0x82266f08
	ctx.lr = 0x830D7588;
	sub_82266F08(ctx, base);
	// 830D7588: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D758C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D7590: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D7594: 409A0018  bne cr6, 0x830d75ac
	if !ctx.cr[6].eq {
	pc = 0x830D75AC; continue 'dispatch;
	}
	// 830D7598: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D759C: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 830D75A0: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830D75A4: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D75A8: 4BC7DD21  bl 0x82d552c8
	ctx.lr = 0x830D75AC;
	sub_82D552C8(ctx, base);
	pc = 0x830D75AC; continue 'dispatch;
            }
            0x830D75AC => {
    //   block [0x830D75AC..0x830D75E0)
	// 830D75AC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830D75B0: 4BC9E079  bl 0x82d75628
	ctx.lr = 0x830D75B4;
	sub_82D75628(ctx, base);
	// 830D75B4: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 830D75B8: 4BC80E79  bl 0x82d58430
	ctx.lr = 0x830D75BC;
	sub_82D58430(ctx, base);
	// 830D75BC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830D75C0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D75C4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D75C8: 409A0018  bne cr6, 0x830d75e0
	if !ctx.cr[6].eq {
	pc = 0x830D75E0; continue 'dispatch;
	}
	// 830D75CC: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D75D0: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 830D75D4: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D75D8: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830D75DC: 4BC7DCED  bl 0x82d552c8
	ctx.lr = 0x830D75E0;
	sub_82D552C8(ctx, base);
	pc = 0x830D75E0; continue 'dispatch;
            }
            0x830D75E0 => {
    //   block [0x830D75E0..0x830D75EC)
	// 830D75E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D75E4: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830D75E8: 4BBD1E54  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D75EC => {
    //   block [0x830D75EC..0x830D762C)
	// 830D75EC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 830D75F0: 4BC9E2F1  bl 0x82d758e0
	ctx.lr = 0x830D75F4;
	sub_82D758E0(ctx, base);
	// 830D75F4: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830D75F8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D75FC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D7600: 409A002C  bne cr6, 0x830d762c
	if !ctx.cr[6].eq {
	pc = 0x830D762C; continue 'dispatch;
	}
	// 830D7604: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7608: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D760C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D7610: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D7614: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D7618: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D761C: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830D7620: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D7624: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830D7628: 4BC7DCA1  bl 0x82d552c8
	ctx.lr = 0x830D762C;
	sub_82D552C8(ctx, base);
	pc = 0x830D762C; continue 'dispatch;
            }
            0x830D762C => {
    //   block [0x830D762C..0x830D7660)
	// 830D762C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 830D7630: 4B18F8D9  bl 0x82266f08
	ctx.lr = 0x830D7634;
	sub_82266F08(ctx, base);
	// 830D7634: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D7638: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D763C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D7640: 409A0020  bne cr6, 0x830d7660
	if !ctx.cr[6].eq {
	pc = 0x830D7660; continue 'dispatch;
	}
	// 830D7644: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7648: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D764C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D7650: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D7654: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830D7658: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D765C: 4BC7DC6D  bl 0x82d552c8
	ctx.lr = 0x830D7660;
	sub_82D552C8(ctx, base);
	pc = 0x830D7660; continue 'dispatch;
            }
            0x830D7660 => {
    //   block [0x830D7660..0x830D769C)
	// 830D7660: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830D7664: 4BC9DFC5  bl 0x82d75628
	ctx.lr = 0x830D7668;
	sub_82D75628(ctx, base);
	// 830D7668: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 830D766C: 4BC80DC5  bl 0x82d58430
	ctx.lr = 0x830D7670;
	sub_82D58430(ctx, base);
	// 830D7670: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830D7674: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D7678: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D767C: 409A0020  bne cr6, 0x830d769c
	if !ctx.cr[6].eq {
	pc = 0x830D769C; continue 'dispatch;
	}
	// 830D7680: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7684: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D7688: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D768C: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830D7690: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D7694: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D7698: 4BC7DC31  bl 0x82d552c8
	ctx.lr = 0x830D769C;
	sub_82D552C8(ctx, base);
	pc = 0x830D769C; continue 'dispatch;
            }
            0x830D769C => {
    //   block [0x830D769C..0x830D76A8)
	// 830D769C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830D76A0: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830D76A4: 4BBD1D98  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D76A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D76A8 size=148
    let mut pc: u32 = 0x830D76A8;
    'dispatch: loop {
        match pc {
            0x830D76A8 => {
    //   block [0x830D76A8..0x830D7720)
	// 830D76A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D76AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830D76B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830D76B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D76B8: 4BC7E099  bl 0x82d55750
	ctx.lr = 0x830D76BC;
	sub_82D55750(ctx, base);
	// 830D76BC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D76C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D76C4: 388B3CD8  addi r4, r11, 0x3cd8
	ctx.r[4].s64 = ctx.r[11].s64 + 15576;
	// 830D76C8: 4BC81311  bl 0x82d589d8
	ctx.lr = 0x830D76CC;
	sub_82D589D8(ctx, base);
	// 830D76CC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D76D0: 419A0050  beq cr6, 0x830d7720
	if ctx.cr[6].eq {
	pc = 0x830D7720; continue 'dispatch;
	}
	// 830D76D4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D76D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D76DC: 388B41B4  addi r4, r11, 0x41b4
	ctx.r[4].s64 = ctx.r[11].s64 + 16820;
	// 830D76E0: 4BC812F9  bl 0x82d589d8
	ctx.lr = 0x830D76E4;
	sub_82D589D8(ctx, base);
	// 830D76E4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D76E8: 419A0038  beq cr6, 0x830d7720
	if ctx.cr[6].eq {
	pc = 0x830D7720; continue 'dispatch;
	}
	// 830D76EC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D76F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D76F4: 388B3D58  addi r4, r11, 0x3d58
	ctx.r[4].s64 = ctx.r[11].s64 + 15704;
	// 830D76F8: 4BC812E1  bl 0x82d589d8
	ctx.lr = 0x830D76FC;
	sub_82D589D8(ctx, base);
	// 830D76FC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D7700: 419A0020  beq cr6, 0x830d7720
	if ctx.cr[6].eq {
	pc = 0x830D7720; continue 'dispatch;
	}
	// 830D7704: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D7708: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D770C: 388B3D48  addi r4, r11, 0x3d48
	ctx.r[4].s64 = ctx.r[11].s64 + 15688;
	// 830D7710: 4BC812C9  bl 0x82d589d8
	ctx.lr = 0x830D7714;
	sub_82D589D8(ctx, base);
	// 830D7714: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D7718: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830D771C: 409A0008  bne cr6, 0x830d7724
	if !ctx.cr[6].eq {
	pc = 0x830D7724; continue 'dispatch;
	}
	pc = 0x830D7720; continue 'dispatch;
            }
            0x830D7720 => {
    //   block [0x830D7720..0x830D7724)
	// 830D7720: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830D7724; continue 'dispatch;
            }
            0x830D7724 => {
    //   block [0x830D7724..0x830D773C)
	// 830D7724: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830D7728: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830D772C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830D7730: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830D7734: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830D7738: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D7740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830D7740 size=8
    let mut pc: u32 = 0x830D7740;
    'dispatch: loop {
        match pc {
            0x830D7740 => {
    //   block [0x830D7740..0x830D7748)
	// 830D7740: 80630018  lwz r3, 0x18(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D7744: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D7748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830D7748 size=8
    let mut pc: u32 = 0x830D7748;
    'dispatch: loop {
        match pc {
            0x830D7748 => {
    //   block [0x830D7748..0x830D7750)
	// 830D7748: 38630034  addi r3, r3, 0x34
	ctx.r[3].s64 = ctx.r[3].s64 + 52;
	// 830D774C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D7750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830D7750 size=8
    let mut pc: u32 = 0x830D7750;
    'dispatch: loop {
        match pc {
            0x830D7750 => {
    //   block [0x830D7750..0x830D7758)
	// 830D7750: 80630040  lwz r3, 0x40(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 830D7754: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D7758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D7758 size=172
    let mut pc: u32 = 0x830D7758;
    'dispatch: loop {
        match pc {
            0x830D7758 => {
    //   block [0x830D7758..0x830D77DC)
	// 830D7758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D775C: 4BBD1CB1  bl 0x82ca940c
	ctx.lr = 0x830D7760;
	sub_82CA93D0(ctx, base);
	// 830D7760: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D7764: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D7768: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830D776C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830D7770: 388B9BE8  addi r4, r11, -0x6418
	ctx.r[4].s64 = ctx.r[11].s64 + -25624;
	// 830D7774: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D7778: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D777C: 48004415  bl 0x830dbb90
	ctx.lr = 0x830D7780;
	sub_830DBB90(ctx, base);
	// 830D7780: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830D7784: 419A0064  beq cr6, 0x830d77e8
	if ctx.cr[6].eq {
	pc = 0x830D77E8; continue 'dispatch;
	}
	// 830D7788: 4BC814C9  bl 0x82d58c50
	ctx.lr = 0x830D778C;
	sub_82D58C50(ctx, base);
	// 830D778C: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830D7790: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 830D7794: 419A0054  beq cr6, 0x830d77e8
	if ctx.cr[6].eq {
	pc = 0x830D77E8; continue 'dispatch;
	}
	// 830D7798: 3963FFFE  addi r11, r3, -2
	ctx.r[11].s64 = ctx.r[3].s64 + -2;
	// 830D779C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 830D77A0: 4199003C  bgt cr6, 0x830d77dc
	if ctx.cr[6].gt {
	pc = 0x830D77DC; continue 'dispatch;
	}
	// 830D77A4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D77A8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D77AC: 388B9BD8  addi r4, r11, -0x6428
	ctx.r[4].s64 = ctx.r[11].s64 + -25640;
	// 830D77B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D77B4: 480043DD  bl 0x830dbb90
	ctx.lr = 0x830D77B8;
	sub_830DBB90(ctx, base);
	// 830D77B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830D77BC: 409A0034  bne cr6, 0x830d77f0
	if !ctx.cr[6].eq {
	pc = 0x830D77F0; continue 'dispatch;
	}
	// 830D77C0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D77C4: 386B68B4  addi r3, r11, 0x68b4
	ctx.r[3].s64 = ctx.r[11].s64 + 26804;
	// 830D77C8: 4BC815C1  bl 0x82d58d88
	ctx.lr = 0x830D77CC;
	sub_82D58D88(ctx, base);
	// 830D77CC: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830D77D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830D77D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830D77D8: 4BBD1C84  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D77DC => {
    //   block [0x830D77DC..0x830D77E8)
	// 830D77DC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830D77E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830D77E4: 4BBD1C78  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D77E8 => {
    //   block [0x830D77E8..0x830D77F0)
	// 830D77E8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D77EC: 386B68C0  addi r3, r11, 0x68c0
	ctx.r[3].s64 = ctx.r[11].s64 + 26816;
	pc = 0x830D77F0; continue 'dispatch;
            }
            0x830D77F0 => {
    //   block [0x830D77F0..0x830D7804)
	// 830D77F0: 4BC81599  bl 0x82d58d88
	ctx.lr = 0x830D77F4;
	sub_82D58D88(ctx, base);
	// 830D77F4: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830D77F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830D77FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830D7800: 4BBD1C5C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D7808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830D7808 size=20
    let mut pc: u32 = 0x830D7808;
    'dispatch: loop {
        match pc {
            0x830D7808 => {
    //   block [0x830D7808..0x830D781C)
	// 830D7808: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D780C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D7810: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 830D7814: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D7818: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D7820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D7820 size=224
    let mut pc: u32 = 0x830D7820;
    'dispatch: loop {
        match pc {
            0x830D7820 => {
    //   block [0x830D7820..0x830D78E0)
	// 830D7820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D7824: 4BBD1BD5  bl 0x82ca93f8
	ctx.lr = 0x830D7828;
	sub_82CA93D0(ctx, base);
	// 830D7828: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D782C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 830D7830: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830D7834: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D7838: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830D783C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830D7840: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 830D7844: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 830D7848: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 830D784C: 4BC8734D  bl 0x82d5eb98
	ctx.lr = 0x830D7850;
	sub_82D5EB98(ctx, base);
	// 830D7850: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830D7854: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D7858: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D785C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830D7860: 4BC871D9  bl 0x82d5ea38
	ctx.lr = 0x830D7864;
	sub_82D5EA38(ctx, base);
	// 830D7864: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D7868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D786C: 419A0074  beq cr6, 0x830d78e0
	if ctx.cr[6].eq {
	pc = 0x830D78E0; continue 'dispatch;
	}
	// 830D7870: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830D7874: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D7878: 4BC87141  bl 0x82d5e9b8
	ctx.lr = 0x830D787C;
	sub_82D5E9B8(ctx, base);
	// 830D787C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D7880: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830D7884: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D7888: 4BC874A1  bl 0x82d5ed28
	ctx.lr = 0x830D788C;
	sub_82D5ED28(ctx, base);
	// 830D788C: 38DB0008  addi r6, r27, 8
	ctx.r[6].s64 = ctx.r[27].s64 + 8;
	// 830D7890: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 830D7894: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830D7898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D789C: 4BC9B975  bl 0x82d73210
	ctx.lr = 0x830D78A0;
	sub_82D73210(ctx, base);
	// 830D78A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830D78A4: 4BC99DB5  bl 0x82d71658
	ctx.lr = 0x830D78A8;
	sub_82D71658(ctx, base);
	// 830D78A8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830D78AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D78B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830D78B4: 4BC9A415  bl 0x82d71cc8
	ctx.lr = 0x830D78B8;
	sub_82D71CC8(ctx, base);
	// 830D78B8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D78BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D78C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D78C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D78C8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D78CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D78D0: 4E800421  bctrl
	ctx.lr = 0x830D78D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D78D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D78D8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830D78DC: 4BBD1B6C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D78E0 => {
    //   block [0x830D78E0..0x830D7900)
	// 830D78E0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D78E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D78E8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D78EC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D78F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D78F4: 4E800421  bctrl
	ctx.lr = 0x830D78F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D78F8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830D78FC: 4BBD1B4C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D7900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D7900 size=240
    let mut pc: u32 = 0x830D7900;
    'dispatch: loop {
        match pc {
            0x830D7900 => {
    //   block [0x830D7900..0x830D7938)
	// 830D7900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D7904: 4BBD1AFD  bl 0x82ca9400
	ctx.lr = 0x830D7908;
	sub_82CA93D0(ctx, base);
	// 830D7908: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D790C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830D7910: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830D7914: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830D7918: 4BC9BC59  bl 0x82d73570
	ctx.lr = 0x830D791C;
	sub_82D73570(ctx, base);
	// 830D791C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830D7920: 419A0084  beq cr6, 0x830d79a4
	if ctx.cr[6].eq {
	pc = 0x830D79A4; continue 'dispatch;
	}
	// 830D7924: 817D0038  lwz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 830D7928: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830D792C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D7930: 40990074  ble cr6, 0x830d79a4
	if !ctx.cr[6].gt {
	pc = 0x830D79A4; continue 'dispatch;
	}
	// 830D7934: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x830D7938; continue 'dispatch;
            }
            0x830D7938 => {
    //   block [0x830D7938..0x830D7990)
	// 830D7938: 83DD0034  lwz r30, 0x34(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 830D793C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D7940: 817D0040  lwz r11, 0x40(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 830D7944: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 830D7948: 7C9EF82E  lwzx r4, r30, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830D794C: 4BC88D3D  bl 0x82d60688
	ctx.lr = 0x830D7950;
	sub_82D60688(ctx, base);
	// 830D7950: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830D7954: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 830D7958: 419A0038  beq cr6, 0x830d7990
	if ctx.cr[6].eq {
	pc = 0x830D7990; continue 'dispatch;
	}
	// 830D795C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7960: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D7964: 7C9EF82E  lwzx r4, r30, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830D7968: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D796C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D7970: 4E800421  bctrl
	ctx.lr = 0x830D7974;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D7974: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830D7978: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 830D797C: 419A0014  beq cr6, 0x830d7990
	if ctx.cr[6].eq {
	pc = 0x830D7990; continue 'dispatch;
	}
	// 830D7980: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D7984: 7C9EF82E  lwzx r4, r30, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830D7988: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 830D798C: 4B18E275  bl 0x82265c00
	ctx.lr = 0x830D7990;
	sub_82265C00(ctx, base);
            }
            0x830D7990 => {
    //   block [0x830D7990..0x830D79A4)
	// 830D7990: 817D0038  lwz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 830D7994: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 830D7998: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 830D799C: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D79A0: 4198FF98  blt cr6, 0x830d7938
	if ctx.cr[6].lt {
	pc = 0x830D7938; continue 'dispatch;
	}
	pc = 0x830D79A4; continue 'dispatch;
            }
            0x830D79A4 => {
    //   block [0x830D79A4..0x830D79E0)
	// 830D79A4: 817D0040  lwz r11, 0x40(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 830D79A8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D79AC: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 830D79B0: 808B0034  lwz r4, 0x34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 830D79B4: 4BC88CD5  bl 0x82d60688
	ctx.lr = 0x830D79B8;
	sub_82D60688(ctx, base);
	// 830D79B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830D79BC: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 830D79C0: 419A0020  beq cr6, 0x830d79e0
	if ctx.cr[6].eq {
	pc = 0x830D79E0; continue 'dispatch;
	}
	// 830D79C4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830D79C8: 4BC81011  bl 0x82d589d8
	ctx.lr = 0x830D79CC;
	sub_82D589D8(ctx, base);
	// 830D79CC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D79D0: 419A0010  beq cr6, 0x830d79e0
	if ctx.cr[6].eq {
	pc = 0x830D79E0; continue 'dispatch;
	}
	// 830D79D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830D79D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830D79DC: 4BBD1A74  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D79E0 => {
    //   block [0x830D79E0..0x830D79F0)
	// 830D79E0: 817D0040  lwz r11, 0x40(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 830D79E4: 806B0034  lwz r3, 0x34(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 830D79E8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830D79EC: 4BBD1A64  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D79F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830D79F0 size=20
    let mut pc: u32 = 0x830D79F0;
    'dispatch: loop {
        match pc {
            0x830D79F0 => {
    //   block [0x830D79F0..0x830D7A04)
	// 830D79F0: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 830D79F4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D79F8: 386B0028  addi r3, r11, 0x28
	ctx.r[3].s64 = ctx.r[11].s64 + 40;
	// 830D79FC: 808B0034  lwz r4, 0x34(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 830D7A00: 4BC88C88  b 0x82d60688
	sub_82D60688(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D7A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D7A08 size=248
    let mut pc: u32 = 0x830D7A08;
    'dispatch: loop {
        match pc {
            0x830D7A08 => {
    //   block [0x830D7A08..0x830D7A48)
	// 830D7A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D7A0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830D7A10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830D7A14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D7A18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D7A1C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D7A20: 396B9C0C  addi r11, r11, -0x63f4
	ctx.r[11].s64 = ctx.r[11].s64 + -25588;
	// 830D7A24: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 830D7A28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830D7A2C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830D7A30: 419A0018  beq cr6, 0x830d7a48
	if ctx.cr[6].eq {
	pc = 0x830D7A48; continue 'dispatch;
	}
	// 830D7A34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7A38: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830D7A3C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7A40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D7A44: 4E800421  bctrl
	ctx.lr = 0x830D7A48;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830D7A48 => {
    //   block [0x830D7A48..0x830D7A84)
	// 830D7A48: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D7A4C: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D7A50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D7A54: 419A0030  beq cr6, 0x830d7a84
	if ctx.cr[6].eq {
	pc = 0x830D7A84; continue 'dispatch;
	}
	// 830D7A58: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 830D7A5C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830D7A60: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 830D7A64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D7A68: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 830D7A6C: 409A0018  bne cr6, 0x830d7a84
	if !ctx.cr[6].eq {
	pc = 0x830D7A84; continue 'dispatch;
	}
	// 830D7A70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7A74: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830D7A78: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7A7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D7A80: 4E800421  bctrl
	ctx.lr = 0x830D7A84;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830D7A84 => {
    //   block [0x830D7A84..0x830D7AB0)
	// 830D7A84: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 830D7A88: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D7A8C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D7A90: 409A0020  bne cr6, 0x830d7ab0
	if !ctx.cr[6].eq {
	pc = 0x830D7AB0; continue 'dispatch;
	}
	// 830D7A94: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7A98: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D7A9C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D7AA0: 809F0034  lwz r4, 0x34(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 830D7AA4: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830D7AA8: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D7AAC: 4BC7D81D  bl 0x82d552c8
	ctx.lr = 0x830D7AB0;
	sub_82D552C8(ctx, base);
	pc = 0x830D7AB0; continue 'dispatch;
            }
            0x830D7AB0 => {
    //   block [0x830D7AB0..0x830D7AE4)
	// 830D7AB0: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 830D7AB4: 4BC875DD  bl 0x82d5f090
	ctx.lr = 0x830D7AB8;
	sub_82D5F090(ctx, base);
	// 830D7AB8: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 830D7ABC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D7AC0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D7AC4: 409A0020  bne cr6, 0x830d7ae4
	if !ctx.cr[6].eq {
	pc = 0x830D7AE4; continue 'dispatch;
	}
	// 830D7AC8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7ACC: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D7AD0: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D7AD4: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D7AD8: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830D7ADC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D7AE0: 4BC7D7E9  bl 0x82d552c8
	ctx.lr = 0x830D7AE4;
	sub_82D552C8(ctx, base);
	pc = 0x830D7AE4; continue 'dispatch;
            }
            0x830D7AE4 => {
    //   block [0x830D7AE4..0x830D7B00)
	// 830D7AE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D7AE8: 4BC9B7C9  bl 0x82d732b0
	ctx.lr = 0x830D7AEC;
	sub_82D732B0(ctx, base);
	// 830D7AEC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830D7AF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830D7AF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830D7AF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830D7AFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D7B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D7B00 size=488
    let mut pc: u32 = 0x830D7B00;
    'dispatch: loop {
        match pc {
            0x830D7B00 => {
    //   block [0x830D7B00..0x830D7B6C)
	// 830D7B00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D7B04: 4BBD18E1  bl 0x82ca93e4
	ctx.lr = 0x830D7B08;
	sub_82CA93D0(ctx, base);
	// 830D7B08: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D7B0C: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 830D7B10: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 830D7B14: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830D7B18: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 830D7B1C: 7CD53378  mr r21, r6
	ctx.r[21].u64 = ctx.r[6].u64;
	// 830D7B20: 7CF33B78  mr r19, r7
	ctx.r[19].u64 = ctx.r[7].u64;
	// 830D7B24: 4BC87075  bl 0x82d5eb98
	ctx.lr = 0x830D7B28;
	sub_82D5EB98(ctx, base);
	// 830D7B28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D7B2C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830D7B30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D7B34: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830D7B38: 4BC86F01  bl 0x82d5ea38
	ctx.lr = 0x830D7B3C;
	sub_82D5EA38(ctx, base);
	// 830D7B3C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D7B40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D7B44: 419A0060  beq cr6, 0x830d7ba4
	if ctx.cr[6].eq {
	pc = 0x830D7BA4; continue 'dispatch;
	}
	// 830D7B48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D7B4C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830D7B50: 4BC86E69  bl 0x82d5e9b8
	ctx.lr = 0x830D7B54;
	sub_82D5E9B8(ctx, base);
	// 830D7B54: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830D7B58: 81380040  lwz r9, 0x40(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(64 as u32) ) } as u64;
	// 830D7B5C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 830D7B60: 2F05FFFF  cmpwi cr6, r5, -1
	ctx.cr[6].compare_i32(ctx.r[5].s32, -1, &mut ctx.xer);
	// 830D7B64: 419A0028  beq cr6, 0x830d7b8c
	if ctx.cr[6].eq {
	pc = 0x830D7B8C; continue 'dispatch;
	}
	// 830D7B68: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x830D7B6C; continue 'dispatch;
            }
            0x830D7B6C => {
    //   block [0x830D7B6C..0x830D7B8C)
	// 830D7B6C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D7B70: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D7B74: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 830D7B78: 8149000C  lwz r10, 0xc(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D7B7C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D7B80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D7B84: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830D7B88: 409AFFE4  bne cr6, 0x830d7b6c
	if !ctx.cr[6].eq {
	pc = 0x830D7B6C; continue 'dispatch;
	}
	pc = 0x830D7B8C; continue 'dispatch;
            }
            0x830D7B8C => {
    //   block [0x830D7B8C..0x830D7BA4)
	// 830D7B8C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830D7B90: 38690018  addi r3, r9, 0x18
	ctx.r[3].s64 = ctx.r[9].s64 + 24;
	// 830D7B94: 4B18E06D  bl 0x82265c00
	ctx.lr = 0x830D7B98;
	sub_82265C00(ctx, base);
	// 830D7B98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D7B9C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830D7BA0: 4BC87189  bl 0x82d5ed28
	ctx.lr = 0x830D7BA4;
	sub_82D5ED28(ctx, base);
	pc = 0x830D7BA4; continue 'dispatch;
            }
            0x830D7BA4 => {
    //   block [0x830D7BA4..0x830D7BD4)
	// 830D7BA4: 8175001C  lwz r11, 0x1c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D7BA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D7BAC: 419A0028  beq cr6, 0x830d7bd4
	if ctx.cr[6].eq {
	pc = 0x830D7BD4; continue 'dispatch;
	}
	// 830D7BB0: 80780040  lwz r3, 0x40(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(64 as u32) ) } as u64;
	// 830D7BB4: 81750018  lwz r11, 0x18(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D7BB8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7BBC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7BC0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D7BC4: 7C8ACA14  add r4, r10, r25
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[25].u64;
	// 830D7BC8: 8169001C  lwz r11, 0x1c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 830D7BCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D7BD0: 4E800421  bctrl
	ctx.lr = 0x830D7BD4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830D7BD4 => {
    //   block [0x830D7BD4..0x830D7BEC)
	// 830D7BD4: 81750028  lwz r11, 0x28(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(40 as u32) ) } as u64;
	// 830D7BD8: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 830D7BDC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D7BE0: 40990100  ble cr6, 0x830d7ce0
	if !ctx.cr[6].gt {
	pc = 0x830D7CE0; continue 'dispatch;
	}
	// 830D7BE4: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 830D7BE8: 3AE0FFFF  li r23, -1
	ctx.r[23].s64 = -1;
	pc = 0x830D7BEC; continue 'dispatch;
            }
            0x830D7BEC => {
    //   block [0x830D7BEC..0x830D7C30)
	// 830D7BEC: 81750024  lwz r11, 0x24(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(36 as u32) ) } as u64;
	// 830D7BF0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830D7BF4: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 830D7BF8: 7FD65A14  add r30, r22, r11
	ctx.r[30].u64 = ctx.r[22].u64 + ctx.r[11].u64;
	// 830D7BFC: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D7C00: 4BC87071  bl 0x82d5ec70
	ctx.lr = 0x830D7C04;
	sub_82D5EC70(ctx, base);
	// 830D7C04: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D7C08: 409A0028  bne cr6, 0x830d7c30
	if !ctx.cr[6].eq {
	pc = 0x830D7C30; continue 'dispatch;
	}
	// 830D7C0C: 80780040  lwz r3, 0x40(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(64 as u32) ) } as u64;
	// 830D7C10: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7C14: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830D7C18: 7CABCA14  add r5, r11, r25
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 830D7C1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7C20: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D7C24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D7C28: 4E800421  bctrl
	ctx.lr = 0x830D7C2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D7C2C: 480000A0  b 0x830d7ccc
	pc = 0x830D7CCC; continue 'dispatch;
            }
            0x830D7C30 => {
    //   block [0x830D7C30..0x830D7C7C)
	// 830D7C30: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 830D7C34: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D7C38: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830D7C3C: 4BC870BD  bl 0x82d5ecf8
	ctx.lr = 0x830D7C40;
	sub_82D5ECF8(ctx, base);
	// 830D7C40: 81780040  lwz r11, 0x40(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(64 as u32) ) } as u64;
	// 830D7C44: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7C48: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830D7C4C: 3BEB000C  addi r31, r11, 0xc
	ctx.r[31].s64 = ctx.r[11].s64 + 12;
	// 830D7C50: 7F6ACA14  add r27, r10, r25
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[25].u64;
	// 830D7C54: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D7C58: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830D7C5C: 419A0020  beq cr6, 0x830d7c7c
	if ctx.cr[6].eq {
	pc = 0x830D7C7C; continue 'dispatch;
	}
	// 830D7C60: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7C64: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830D7C68: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 830D7C6C: 7D6A4A14  add r11, r10, r9
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830D7C70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D7C74: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 830D7C78: 48000030  b 0x830d7ca8
	pc = 0x830D7CA8; continue 'dispatch;
            }
            0x830D7C7C => {
    //   block [0x830D7C7C..0x830D7C9C)
	// 830D7C7C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D7C80: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D7C84: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D7C88: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D7C8C: 409A0010  bne cr6, 0x830d7c9c
	if !ctx.cr[6].eq {
	pc = 0x830D7C9C; continue 'dispatch;
	}
	// 830D7C90: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 830D7C94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D7C98: 4BC7F301  bl 0x82d56f98
	ctx.lr = 0x830D7C9C;
	sub_82D56F98(ctx, base);
	pc = 0x830D7C9C; continue 'dispatch;
            }
            0x830D7C9C => {
    //   block [0x830D7C9C..0x830D7CA8)
	// 830D7C9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D7CA0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D7CA4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x830D7CA8; continue 'dispatch;
            }
            0x830D7CA8 => {
    //   block [0x830D7CA8..0x830D7CCC)
	// 830D7CA8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7CAC: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D7CB0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830D7CB4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D7CB8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830D7CBC: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 830D7CC0: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830D7CC4: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D7CC8: 4BC86D91  bl 0x82d5ea58
	ctx.lr = 0x830D7CCC;
	sub_82D5EA58(ctx, base);
	pc = 0x830D7CCC; continue 'dispatch;
            }
            0x830D7CCC => {
    //   block [0x830D7CCC..0x830D7CE0)
	// 830D7CCC: 81750028  lwz r11, 0x28(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(40 as u32) ) } as u64;
	// 830D7CD0: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 830D7CD4: 3AD60008  addi r22, r22, 8
	ctx.r[22].s64 = ctx.r[22].s64 + 8;
	// 830D7CD8: 7F145800  cmpw cr6, r20, r11
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D7CDC: 4198FF10  blt cr6, 0x830d7bec
	if ctx.cr[6].lt {
	pc = 0x830D7BEC; continue 'dispatch;
	}
	pc = 0x830D7CE0; continue 'dispatch;
            }
            0x830D7CE0 => {
    //   block [0x830D7CE0..0x830D7CE8)
	// 830D7CE0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 830D7CE4: 4BBD1750  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D7CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D7CE8 size=2848
    let mut pc: u32 = 0x830D7CE8;
    'dispatch: loop {
        match pc {
            0x830D7CE8 => {
    //   block [0x830D7CE8..0x830D7D48)
	// 830D7CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D7CEC: 4BBD16E5  bl 0x82ca93d0
	ctx.lr = 0x830D7CF0;
	sub_82CA93D0(ctx, base);
	// 830D7CF0: 9421FBB0  stwu r1, -0x450(r1)
	ea = ctx.r[1].u32.wrapping_add(-1104 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D7CF4: 82ED0000  lwz r23, 0(r13)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7CF8: 3B600004  li r27, 4
	ctx.r[27].s64 = 4;
	// 830D7CFC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 830D7D00: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830D7D04: 3FE08000  lis r31, -0x8000
	ctx.r[31].s64 = -2147483648;
	// 830D7D08: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830D7D0C: 7C7BB82E  lwzx r3, r27, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 830D7D10: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830D7D14: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 830D7D18: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 830D7D1C: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 830D7D20: 93410474  stw r26, 0x474(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1140 as u32), ctx.r[26].u32 ) };
	// 830D7D24: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D7D28: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 830D7D2C: 394B4010  addi r10, r11, 0x4010
	ctx.r[10].s64 = ctx.r[11].s64 + 16400;
	// 830D7D30: 92E1005C  stw r23, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[23].u32 ) };
	// 830D7D34: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 830D7D38: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830D7D3C: 4199000C  bgt cr6, 0x830d7d48
	if ctx.cr[6].gt {
	pc = 0x830D7D48; continue 'dispatch;
	}
	// 830D7D40: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830D7D44: 4800001C  b 0x830d7d60
	pc = 0x830D7D60; continue 'dispatch;
            }
            0x830D7D48 => {
    //   block [0x830D7D48..0x830D7D60)
	// 830D7D48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7D4C: 38804010  li r4, 0x4010
	ctx.r[4].s64 = 16400;
	// 830D7D50: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D7D54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D7D58: 4E800421  bctrl
	ctx.lr = 0x830D7D5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D7D5C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
            }
            0x830D7D60 => {
    //   block [0x830D7D60..0x830D7F04)
	// 830D7D60: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 830D7D64: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830D7D68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D7D6C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 830D7D70: 614A4000  ori r10, r10, 0x4000
	ctx.r[10].u64 = ctx.r[10].u64 | 16384;
	// 830D7D74: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 830D7D78: 7F38CB78  mr r24, r25
	ctx.r[24].u64 = ctx.r[25].u64;
	// 830D7D7C: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 830D7D80: 4813FD31  bl 0x83217ab0
	ctx.lr = 0x830D7D84;
	sub_83217AB0(ctx, base);
	// 830D7D84: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 830D7D88: 48004281  bl 0x830dc008
	ctx.lr = 0x830D7D8C;
	sub_830DC008(ctx, base);
	// 830D7D8C: 38810180  addi r4, r1, 0x180
	ctx.r[4].s64 = ctx.r[1].s64 + 384;
	// 830D7D90: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 830D7D94: 48006105  bl 0x830dde98
	ctx.lr = 0x830D7D98;
	sub_830DDE98(ctx, base);
	// 830D7D98: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D7D9C: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	// 830D7DA0: 93210100  stw r25, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[25].u32 ) };
	// 830D7DA4: 396B9BFC  addi r11, r11, -0x6404
	ctx.r[11].s64 = ctx.r[11].s64 + -25604;
	// 830D7DA8: 93210104  stw r25, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[25].u32 ) };
	// 830D7DAC: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 830D7DB0: 93E10108  stw r31, 0x108(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[31].u32 ) };
	// 830D7DB4: 9321010C  stw r25, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[25].u32 ) };
	// 830D7DB8: 93210110  stw r25, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[25].u32 ) };
	// 830D7DBC: 93E10114  stw r31, 0x114(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), ctx.r[31].u32 ) };
	// 830D7DC0: 93210118  stw r25, 0x118(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[25].u32 ) };
	// 830D7DC4: 9321011C  stw r25, 0x11c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), ctx.r[25].u32 ) };
	// 830D7DC8: 93E10120  stw r31, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[31].u32 ) };
	// 830D7DCC: 93210124  stw r25, 0x124(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[25].u32 ) };
	// 830D7DD0: 93210128  stw r25, 0x128(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[25].u32 ) };
	// 830D7DD4: 93E1012C  stw r31, 0x12c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), ctx.r[31].u32 ) };
	// 830D7DD8: 93210130  stw r25, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[25].u32 ) };
	// 830D7DDC: B2A10146  sth r21, 0x146(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(326 as u32), ctx.r[21].u16 ) };
	// 830D7DE0: 91610140  stw r11, 0x140(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 830D7DE4: 4BC87245  bl 0x82d5f028
	ctx.lr = 0x830D7DE8;
	sub_82D5F028(ctx, base);
	// 830D7DE8: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 830D7DEC: 4B18F155  bl 0x82266f40
	ctx.lr = 0x830D7DF0;
	sub_82266F40(ctx, base);
	// 830D7DF0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 830D7DF4: 4BC87235  bl 0x82d5f028
	ctx.lr = 0x830D7DF8;
	sub_82D5F028(ctx, base);
	// 830D7DF8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830D7DFC: 4BC8722D  bl 0x82d5f028
	ctx.lr = 0x830D7E00;
	sub_82D5F028(ctx, base);
	// 830D7E00: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 830D7E04: 4BC87225  bl 0x82d5f028
	ctx.lr = 0x830D7E08;
	sub_82D5F028(ctx, base);
	// 830D7E08: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830D7E0C: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 830D7E10: 4BC9BA49  bl 0x82d73858
	ctx.lr = 0x830D7E14;
	sub_82D73858(ctx, base);
	// 830D7E14: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 830D7E18: 3BEBAFAC  addi r31, r11, -0x5054
	ctx.r[31].s64 = ctx.r[11].s64 + -20564;
	// 830D7E1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D7E20: 4BC7D931  bl 0x82d55750
	ctx.lr = 0x830D7E24;
	sub_82D55750(ctx, base);
	// 830D7E24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830D7E28: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 830D7E2C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830D7E30: 4BC86C29  bl 0x82d5ea58
	ctx.lr = 0x830D7E34;
	sub_82D5EA58(ctx, base);
	// 830D7E34: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 830D7E38: 3BEBB06C  addi r31, r11, -0x4f94
	ctx.r[31].s64 = ctx.r[11].s64 + -20372;
	// 830D7E3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D7E40: 4BC7D911  bl 0x82d55750
	ctx.lr = 0x830D7E44;
	sub_82D55750(ctx, base);
	// 830D7E44: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830D7E48: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 830D7E4C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830D7E50: 4BC86C09  bl 0x82d5ea58
	ctx.lr = 0x830D7E54;
	sub_82D5EA58(ctx, base);
	// 830D7E54: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 830D7E58: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D7E5C: 388B0D8C  addi r4, r11, 0xd8c
	ctx.r[4].s64 = ctx.r[11].s64 + 3468;
	// 830D7E60: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 830D7E64: 4BC86BF5  bl 0x82d5ea58
	ctx.lr = 0x830D7E68;
	sub_82D5EA58(ctx, base);
	// 830D7E68: 38A10160  addi r5, r1, 0x160
	ctx.r[5].s64 = ctx.r[1].s64 + 352;
	// 830D7E6C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830D7E70: 92A10080  stw r21, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[21].u32 ) };
	// 830D7E74: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 830D7E78: 48004881  bl 0x830dc6f8
	ctx.lr = 0x830D7E7C;
	sub_830DC6F8(ctx, base);
	// 830D7E7C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D7E80: 409A06A8  bne cr6, 0x830d8528
	if !ctx.cr[6].eq {
	pc = 0x830D8528; continue 'dispatch;
	}
	// 830D7E84: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D7E88: 3DE08333  lis r15, -0x7ccd
	ctx.r[15].s64 = -2093809664;
	// 830D7E8C: 3A8B9C7C  addi r20, r11, -0x6384
	ctx.r[20].s64 = ctx.r[11].s64 + -25476;
	// 830D7E90: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D7E94: 3A6B9C64  addi r19, r11, -0x639c
	ctx.r[19].s64 = ctx.r[11].s64 + -25500;
	// 830D7E98: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 830D7E9C: 3B6BAFDC  addi r27, r11, -0x5024
	ctx.r[27].s64 = ctx.r[11].s64 + -20516;
	// 830D7EA0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830D7EA4: 3A4B7694  addi r18, r11, 0x7694
	ctx.r[18].s64 = ctx.r[11].s64 + 30356;
	// 830D7EA8: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830D7EAC: 936100B4  stw r27, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[27].u32 ) };
	// 830D7EB0: 3A2B7634  addi r17, r11, 0x7634
	ctx.r[17].s64 = ctx.r[11].s64 + 30260;
	// 830D7EB4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D7EB8: 396B9C58  addi r11, r11, -0x63a8
	ctx.r[11].s64 = ctx.r[11].s64 + -25512;
	// 830D7EBC: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 830D7EC0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D7EC4: 3A0B68CC  addi r16, r11, 0x68cc
	ctx.r[16].s64 = ctx.r[11].s64 + 26828;
	// 830D7EC8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D7ECC: 396B9C4C  addi r11, r11, -0x63b4
	ctx.r[11].s64 = ctx.r[11].s64 + -25524;
	// 830D7ED0: 916100F0  stw r11, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 830D7ED4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D7ED8: 39CB3CD8  addi r14, r11, 0x3cd8
	ctx.r[14].s64 = ctx.r[11].s64 + 15576;
	// 830D7EDC: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 830D7EE0: 396BFFAC  addi r11, r11, -0x54
	ctx.r[11].s64 = ctx.r[11].s64 + -84;
	// 830D7EE4: 916100EC  stw r11, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 830D7EE8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 830D7EEC: 3AEB86B4  addi r23, r11, -0x794c
	ctx.r[23].s64 = ctx.r[11].s64 + -31052;
	// 830D7EF0: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D7EF4: 3ACB3D6C  addi r22, r11, 0x3d6c
	ctx.r[22].s64 = ctx.r[11].s64 + 15724;
	// 830D7EF8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D7EFC: 396B9C40  addi r11, r11, -0x63c0
	ctx.r[11].s64 = ctx.r[11].s64 + -25536;
	// 830D7F00: 916100C8  stw r11, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	pc = 0x830D7F04; continue 'dispatch;
            }
            0x830D7F04 => {
    //   block [0x830D7F04..0x830D7FB4)
	// 830D7F04: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830D7F08: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D7F0C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830D7F10: 409A04B0  bne cr6, 0x830d83c0
	if !ctx.cr[6].eq {
	pc = 0x830D83C0; continue 'dispatch;
	}
	// 830D7F14: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D7F18: 3BC3000C  addi r30, r3, 0xc
	ctx.r[30].s64 = ctx.r[3].s64 + 12;
	// 830D7F1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D7F20: 808100C8  lwz r4, 0xc8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 830D7F24: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830D7F28: 4BC80AB1  bl 0x82d589d8
	ctx.lr = 0x830D7F2C;
	sub_82D589D8(ctx, base);
	// 830D7F2C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D7F30: 409A02D8  bne cr6, 0x830d8208
	if !ctx.cr[6].eq {
	pc = 0x830D8208; continue 'dispatch;
	}
	// 830D7F34: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D7F38: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 830D7F3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D7F40: 48003C51  bl 0x830dbb90
	ctx.lr = 0x830D7F44;
	sub_830DBB90(ctx, base);
	// 830D7F44: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D7F48: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830D7F4C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D7F50: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 830D7F54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D7F58: 4E800421  bctrl
	ctx.lr = 0x830D7F5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D7F5C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830D7F60: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 830D7F64: 38E100B8  addi r7, r1, 0xb8
	ctx.r[7].s64 = ctx.r[1].s64 + 184;
	// 830D7F68: 38C10098  addi r6, r1, 0x98
	ctx.r[6].s64 = ctx.r[1].s64 + 152;
	// 830D7F6C: 38A100D0  addi r5, r1, 0xd0
	ctx.r[5].s64 = ctx.r[1].s64 + 208;
	// 830D7F70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D7F74: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D7F78: 4BFFF8A9  bl 0x830d7820
	ctx.lr = 0x830D7F7C;
	sub_830D7820(ctx, base);
	// 830D7F7C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830D7F80: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D7F84: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 830D7F88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D7F8C: 48003C05  bl 0x830dbb90
	ctx.lr = 0x830D7F90;
	sub_830DBB90(ctx, base);
	// 830D7F90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830D7F94: 38A100C4  addi r5, r1, 0xc4
	ctx.r[5].s64 = ctx.r[1].s64 + 196;
	// 830D7F98: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 830D7F9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D7FA0: 4BC86CD1  bl 0x82d5ec70
	ctx.lr = 0x830D7FA4;
	sub_82D5EC70(ctx, base);
	// 830D7FA4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D7FA8: 409A000C  bne cr6, 0x830d7fb4
	if !ctx.cr[6].eq {
	pc = 0x830D7FB4; continue 'dispatch;
	}
	// 830D7FAC: 834100C4  lwz r26, 0xc4(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 830D7FB0: 48000024  b 0x830d7fd4
	pc = 0x830D7FD4; continue 'dispatch;
            }
            0x830D7FB4 => {
    //   block [0x830D7FB4..0x830D7FD4)
	// 830D7FB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D7FB8: 4BC80DD1  bl 0x82d58d88
	ctx.lr = 0x830D7FBC;
	sub_82D58D88(ctx, base);
	// 830D7FBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830D7FC0: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 830D7FC4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830D7FC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D7FCC: 4BC86A8D  bl 0x82d5ea58
	ctx.lr = 0x830D7FD0;
	sub_82D5EA58(ctx, base);
	// 830D7FD0: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	pc = 0x830D7FD4; continue 'dispatch;
            }
            0x830D7FD4 => {
    //   block [0x830D7FD4..0x830D8024)
	// 830D7FD4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D7FD8: 808100EC  lwz r4, 0xec(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 830D7FDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D7FE0: 48003BB1  bl 0x830dbb90
	ctx.lr = 0x830D7FE4;
	sub_830DBB90(ctx, base);
	// 830D7FE4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830D7FE8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830D7FEC: 419A0054  beq cr6, 0x830d8040
	if ctx.cr[6].eq {
	pc = 0x830D8040; continue 'dispatch;
	}
	// 830D7FF0: 4BC80D99  bl 0x82d58d88
	ctx.lr = 0x830D7FF4;
	sub_82D58D88(ctx, base);
	// 830D7FF4: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D7FF8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830D7FFC: 3BEB0018  addi r31, r11, 0x18
	ctx.r[31].s64 = ctx.r[11].s64 + 24;
	// 830D8000: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 830D8004: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D8008: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D800C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D8010: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D8014: 409A0010  bne cr6, 0x830d8024
	if !ctx.cr[6].eq {
	pc = 0x830D8024; continue 'dispatch;
	}
	// 830D8018: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 830D801C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D8020: 4BC7EF79  bl 0x82d56f98
	ctx.lr = 0x830D8024;
	sub_82D56F98(ctx, base);
	pc = 0x830D8024; continue 'dispatch;
            }
            0x830D8024 => {
    //   block [0x830D8024..0x830D8040)
	// 830D8024: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D8028: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D802C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D8030: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 830D8034: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D8038: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D803C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x830D8040; continue 'dispatch;
            }
            0x830D8040 => {
    //   block [0x830D8040..0x830D80D0)
	// 830D8040: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 830D8044: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830D8048: 48003D79  bl 0x830dbdc0
	ctx.lr = 0x830D804C;
	sub_830DBDC0(ctx, base);
	// 830D804C: 38E10100  addi r7, r1, 0x100
	ctx.r[7].s64 = ctx.r[1].s64 + 256;
	// 830D8050: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 830D8054: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 830D8058: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830D805C: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 830D8060: 38810160  addi r4, r1, 0x160
	ctx.r[4].s64 = ctx.r[1].s64 + 352;
	// 830D8064: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 830D8068: 48007E11  bl 0x830dfe78
	ctx.lr = 0x830D806C;
	sub_830DFE78(ctx, base);
	// 830D806C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D8070: 409A0638  bne cr6, 0x830d86a8
	if !ctx.cr[6].eq {
	pc = 0x830D86A8; continue 'dispatch;
	}
	// 830D8074: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D8078: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 830D807C: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830D8080: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830D8084: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D8088: 4BC7D3F1  bl 0x82d55478
	ctx.lr = 0x830D808C;
	sub_82D55478(ctx, base);
	// 830D808C: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830D8090: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D8094: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D8098: 4BC80C99  bl 0x82d58d30
	ctx.lr = 0x830D809C;
	sub_82D58D30(ctx, base);
	// 830D809C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D80A0: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830D80A4: 4BC9D505  bl 0x82d755a8
	ctx.lr = 0x830D80A8;
	sub_82D755A8(ctx, base);
	// 830D80A8: 817C0018  lwz r11, 0x18(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D80AC: 3BCB0018  addi r30, r11, 0x18
	ctx.r[30].s64 = ctx.r[11].s64 + 24;
	// 830D80B0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D80B4: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D80B8: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D80BC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D80C0: 409A0010  bne cr6, 0x830d80d0
	if !ctx.cr[6].eq {
	pc = 0x830D80D0; continue 'dispatch;
	}
	// 830D80C4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 830D80C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D80CC: 4BC7EECD  bl 0x82d56f98
	ctx.lr = 0x830D80D0;
	sub_82D56F98(ctx, base);
	pc = 0x830D80D0; continue 'dispatch;
            }
            0x830D80D0 => {
    //   block [0x830D80D0..0x830D8104)
	// 830D80D0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D80D4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830D80D8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D80DC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D80E0: 7FEB512E  stwx r31, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
	// 830D80E4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D80E8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D80EC: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830D80F0: 419A0014  beq cr6, 0x830d8104
	if ctx.cr[6].eq {
	pc = 0x830D8104; continue 'dispatch;
	}
	// 830D80F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830D80F8: 807C0018  lwz r3, 0x18(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D80FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830D8100: 4BC9A3F9  bl 0x82d724f8
	ctx.lr = 0x830D8104;
	sub_82D724F8(ctx, base);
	pc = 0x830D8104; continue 'dispatch;
            }
            0x830D8104 => {
    //   block [0x830D8104..0x830D8164)
	// 830D8104: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830D8108: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830D810C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 830D8110: 4BC86949  bl 0x82d5ea58
	ctx.lr = 0x830D8114;
	sub_82D5EA58(ctx, base);
	// 830D8114: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 830D8118: 38E10088  addi r7, r1, 0x88
	ctx.r[7].s64 = ctx.r[1].s64 + 136;
	// 830D811C: 38C10100  addi r6, r1, 0x100
	ctx.r[6].s64 = ctx.r[1].s64 + 256;
	// 830D8120: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830D8124: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830D8128: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D812C: 4BFFF9D5  bl 0x830d7b00
	ctx.lr = 0x830D8130;
	sub_830D7B00(ctx, base);
	// 830D8130: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830D8134: 4BC7D61D  bl 0x82d55750
	ctx.lr = 0x830D8138;
	sub_82D55750(ctx, base);
	// 830D8138: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 830D813C: 4BC8089D  bl 0x82d589d8
	ctx.lr = 0x830D8140;
	sub_82D589D8(ctx, base);
	// 830D8140: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D8144: 409A0020  bne cr6, 0x830d8164
	if !ctx.cr[6].eq {
	pc = 0x830D8164; continue 'dispatch;
	}
	// 830D8148: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D814C: 4BC7D605  bl 0x82d55750
	ctx.lr = 0x830D8150;
	sub_82D55750(ctx, base);
	// 830D8150: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830D8154: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830D8158: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 830D815C: 4BC868FD  bl 0x82d5ea58
	ctx.lr = 0x830D8160;
	sub_82D5EA58(ctx, base);
	// 830D8160: 4800008C  b 0x830d81ec
	pc = 0x830D81EC; continue 'dispatch;
            }
            0x830D8164 => {
    //   block [0x830D8164..0x830D819C)
	// 830D8164: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830D8168: 4BFFF541  bl 0x830d76a8
	ctx.lr = 0x830D816C;
	sub_830D76A8(ctx, base);
	// 830D816C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830D8170: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D8174: 419A0078  beq cr6, 0x830d81ec
	if ctx.cr[6].eq {
	pc = 0x830D81EC; continue 'dispatch;
	}
	// 830D8178: 3BDC0034  addi r30, r28, 0x34
	ctx.r[30].s64 = ctx.r[28].s64 + 52;
	// 830D817C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D8180: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D8184: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D8188: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D818C: 409A0010  bne cr6, 0x830d819c
	if !ctx.cr[6].eq {
	pc = 0x830D819C; continue 'dispatch;
	}
	// 830D8190: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 830D8194: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D8198: 4BC7EE01  bl 0x82d56f98
	ctx.lr = 0x830D819C;
	sub_82D56F98(ctx, base);
	pc = 0x830D819C; continue 'dispatch;
            }
            0x830D819C => {
    //   block [0x830D819C..0x830D81EC)
	// 830D819C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D81A0: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 830D81A4: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D81A8: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830D81AC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D81B0: 7FAA4A14  add r29, r10, r9
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830D81B4: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830D81B8: 937D0004  stw r27, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830D81BC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 830D81C0: 409A002C  bne cr6, 0x830d81ec
	if !ctx.cr[6].eq {
	pc = 0x830D81EC; continue 'dispatch;
	}
	// 830D81C4: 817C0040  lwz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 830D81C8: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 830D81CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D81D0: 409A001C  bne cr6, 0x830d81ec
	if !ctx.cr[6].eq {
	pc = 0x830D81EC; continue 'dispatch;
	}
	// 830D81D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830D81D8: 4BC7D579  bl 0x82d55750
	ctx.lr = 0x830D81DC;
	sub_82D55750(ctx, base);
	// 830D81DC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830D81E0: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D81E4: 807C0040  lwz r3, 0x40(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 830D81E8: 4BC986F9  bl 0x82d708e0
	ctx.lr = 0x830D81EC;
	sub_82D708E0(ctx, base);
	pc = 0x830D81EC; continue 'dispatch;
            }
            0x830D81EC => {
    //   block [0x830D81EC..0x830D8208)
	// 830D81EC: 83410474  lwz r26, 0x474(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1140 as u32) ) } as u64;
	// 830D81F0: 836100B4  lwz r27, 0xb4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 830D81F4: 93210104  stw r25, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[25].u32 ) };
	// 830D81F8: 93210110  stw r25, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[25].u32 ) };
	// 830D81FC: 9321011C  stw r25, 0x11c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), ctx.r[25].u32 ) };
	// 830D8200: 93210128  stw r25, 0x128(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[25].u32 ) };
	// 830D8204: 480002E4  b 0x830d84e8
	pc = 0x830D84E8; continue 'dispatch;
            }
            0x830D8208 => {
    //   block [0x830D8208..0x830D8254)
	// 830D8208: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D820C: 808100F0  lwz r4, 0xf0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) } as u64;
	// 830D8210: 4BC807C9  bl 0x82d589d8
	ctx.lr = 0x830D8214;
	sub_82D589D8(ctx, base);
	// 830D8214: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D8218: 409A00BC  bne cr6, 0x830d82d4
	if !ctx.cr[6].eq {
	pc = 0x830D82D4; continue 'dispatch;
	}
	// 830D821C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830D8220: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 830D8224: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D8228: 48003969  bl 0x830dbb90
	ctx.lr = 0x830D822C;
	sub_830DBB90(ctx, base);
	// 830D822C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D8230: 3BBC0028  addi r29, r28, 0x28
	ctx.r[29].s64 = ctx.r[28].s64 + 40;
	// 830D8234: 38A100E8  addi r5, r1, 0xe8
	ctx.r[5].s64 = ctx.r[1].s64 + 232;
	// 830D8238: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D823C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D8240: 4BC86A31  bl 0x82d5ec70
	ctx.lr = 0x830D8244;
	sub_82D5EC70(ctx, base);
	// 830D8244: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D8248: 409A000C  bne cr6, 0x830d8254
	if !ctx.cr[6].eq {
	pc = 0x830D8254; continue 'dispatch;
	}
	// 830D824C: 830100E8  lwz r24, 0xe8(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) } as u64;
	// 830D8250: 48000298  b 0x830d84e8
	pc = 0x830D84E8; continue 'dispatch;
            }
            0x830D8254 => {
    //   block [0x830D8254..0x830D8294)
	// 830D8254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D8258: 831C0020  lwz r24, 0x20(r28)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 830D825C: 4BC80B2D  bl 0x82d58d88
	ctx.lr = 0x830D8260;
	sub_82D58D88(ctx, base);
	// 830D8260: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830D8264: 807C0018  lwz r3, 0x18(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D8268: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D826C: 4BC9877D  bl 0x82d709e8
	ctx.lr = 0x830D8270;
	sub_82D709E8(ctx, base);
	// 830D8270: 3BFC001C  addi r31, r28, 0x1c
	ctx.r[31].s64 = ctx.r[28].s64 + 28;
	// 830D8274: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D8278: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D827C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D8280: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D8284: 409A0010  bne cr6, 0x830d8294
	if !ctx.cr[6].eq {
	pc = 0x830D8294; continue 'dispatch;
	}
	// 830D8288: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 830D828C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D8290: 4BC7ED09  bl 0x82d56f98
	ctx.lr = 0x830D8294;
	sub_82D56F98(ctx, base);
	pc = 0x830D8294; continue 'dispatch;
            }
            0x830D8294 => {
    //   block [0x830D8294..0x830D82D4)
	// 830D8294: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D8298: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 830D829C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D82A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D82A4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D82A8: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 830D82AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D82B0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D82B4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830D82B8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D82BC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D82C0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D82C4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D82C8: 808BFFFC  lwz r4, -4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830D82CC: 4BC8678D  bl 0x82d5ea58
	ctx.lr = 0x830D82D0;
	sub_82D5EA58(ctx, base);
	// 830D82D0: 48000218  b 0x830d84e8
	pc = 0x830D84E8; continue 'dispatch;
            }
            0x830D82D4 => {
    //   block [0x830D82D4..0x830D8360)
	// 830D82D4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D82D8: 808100A4  lwz r4, 0xa4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 830D82DC: 4BC806FD  bl 0x82d589d8
	ctx.lr = 0x830D82E0;
	sub_82D589D8(ctx, base);
	// 830D82E0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D82E4: 409A0474  bne cr6, 0x830d8758
	if !ctx.cr[6].eq {
	pc = 0x830D8758; continue 'dispatch;
	}
	// 830D82E8: 38A1007C  addi r5, r1, 0x7c
	ctx.r[5].s64 = ctx.r[1].s64 + 124;
	// 830D82EC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 830D82F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D82F4: 4BFFF465  bl 0x830d7758
	ctx.lr = 0x830D82F8;
	sub_830D7758(ctx, base);
	// 830D82F8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D82FC: 83E1007C  lwz r31, 0x7c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 830D8300: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D8304: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D8308: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 830D830C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D8310: 4E800421  bctrl
	ctx.lr = 0x830D8314;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D8314: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D8318: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830D831C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D8320: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D8324: 4BC7D1AD  bl 0x82d554d0
	ctx.lr = 0x830D8328;
	sub_82D554D0(ctx, base);
	// 830D8328: 82A10080  lwz r21, 0x80(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 830D832C: 9321007C  stw r25, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[25].u32 ) };
	// 830D8330: 2F150005  cmpwi cr6, r21, 5
	ctx.cr[6].compare_i32(ctx.r[21].s32, 5, &mut ctx.xer);
	// 830D8334: 4198002C  blt cr6, 0x830d8360
	if ctx.cr[6].lt {
	pc = 0x830D8360; continue 'dispatch;
	}
	// 830D8338: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 830D833C: 4BC7D415  bl 0x82d55750
	ctx.lr = 0x830D8340;
	sub_82D55750(ctx, base);
	// 830D8340: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830D8344: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 830D8348: 7E258B78  mr r5, r17
	ctx.r[5].u64 = ctx.r[17].u64;
	// 830D834C: 4BC8670D  bl 0x82d5ea58
	ctx.lr = 0x830D8350;
	sub_82D5EA58(ctx, base);
	// 830D8350: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 830D8354: 4BC7D3FD  bl 0x82d55750
	ctx.lr = 0x830D8358;
	sub_82D55750(ctx, base);
	// 830D8358: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 830D835C: 48000018  b 0x830d8374
	pc = 0x830D8374; continue 'dispatch;
            }
            0x830D8360 => {
    //   block [0x830D8360..0x830D8374)
	// 830D8360: 2F150002  cmpwi cr6, r21, 2
	ctx.cr[6].compare_i32(ctx.r[21].s32, 2, &mut ctx.xer);
	// 830D8364: 4198001C  blt cr6, 0x830d8380
	if ctx.cr[6].lt {
	pc = 0x830D8380; continue 'dispatch;
	}
	// 830D8368: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830D836C: 4BC7D3E5  bl 0x82d55750
	ctx.lr = 0x830D8370;
	sub_82D55750(ctx, base);
	// 830D8370: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	pc = 0x830D8374; continue 'dispatch;
            }
            0x830D8374 => {
    //   block [0x830D8374..0x830D8380)
	// 830D8374: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830D8378: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 830D837C: 4BC866DD  bl 0x82d5ea58
	ctx.lr = 0x830D8380;
	sub_82D5EA58(ctx, base);
	pc = 0x830D8380; continue 'dispatch;
            }
            0x830D8380 => {
    //   block [0x830D8380..0x830D83C0)
	// 830D8380: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 830D8384: 409A0164  bne cr6, 0x830d84e8
	if !ctx.cr[6].eq {
	pc = 0x830D84E8; continue 'dispatch;
	}
	// 830D8388: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830D838C: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D8390: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D8394: 83EB7BF8  lwz r31, 0x7bf8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31736 as u32) ) } as u64;
	// 830D8398: 816A0024  lwz r11, 0x24(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 830D839C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D83A0: 4E800421  bctrl
	ctx.lr = 0x830D83A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D83A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830D83A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D83AC: 4BC9AA55  bl 0x82d72e00
	ctx.lr = 0x830D83B0;
	sub_82D72E00(ctx, base);
	// 830D83B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830D83B4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 830D83B8: 4BC9B389  bl 0x82d73740
	ctx.lr = 0x830D83BC;
	sub_82D73740(ctx, base);
	// 830D83BC: 4800012C  b 0x830d84e8
	pc = 0x830D84E8; continue 'dispatch;
            }
            0x830D83C0 => {
    //   block [0x830D83C0..0x830D8468)
	// 830D83C0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830D83C4: 419A0128  beq cr6, 0x830d84ec
	if ctx.cr[6].eq {
	pc = 0x830D84EC; continue 'dispatch;
	}
	// 830D83C8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830D83CC: 409A00CC  bne cr6, 0x830d8498
	if !ctx.cr[6].eq {
	pc = 0x830D8498; continue 'dispatch;
	}
	// 830D83D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830D83D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D83D8: 48003A61  bl 0x830dbe38
	ctx.lr = 0x830D83DC;
	sub_830DBE38(ctx, base);
	// 830D83DC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D83E0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D83E4: 40810104  ble 0x830d84e8
	if !ctx.cr[0].gt {
	pc = 0x830D84E8; continue 'dispatch;
	}
	// 830D83E8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 830D83EC: 4BC9B2C5  bl 0x82d736b0
	ctx.lr = 0x830D83F0;
	sub_82D736B0(ctx, base);
	// 830D83F0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 830D83F4: 4BC86C9D  bl 0x82d5f090
	ctx.lr = 0x830D83F8;
	sub_82D5F090(ctx, base);
	// 830D83F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830D83FC: 4BC86C95  bl 0x82d5f090
	ctx.lr = 0x830D8400;
	sub_82D5F090(ctx, base);
	// 830D8400: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 830D8404: 4BC86C8D  bl 0x82d5f090
	ctx.lr = 0x830D8408;
	sub_82D5F090(ctx, base);
	// 830D8408: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 830D840C: 4B18EAFD  bl 0x82266f08
	ctx.lr = 0x830D8410;
	sub_82266F08(ctx, base);
	// 830D8410: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 830D8414: 48000515  bl 0x830d8928
	ctx.lr = 0x830D8418;
	sub_830D8928(ctx, base);
	// 830D8418: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830D841C: 4BC9D20D  bl 0x82d75628
	ctx.lr = 0x830D8420;
	sub_82D75628(ctx, base);
	// 830D8420: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 830D8424: 48005585  bl 0x830dd9a8
	ctx.lr = 0x830D8428;
	sub_830DD9A8(ctx, base);
	// 830D8428: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 830D842C: 48003C4D  bl 0x830dc078
	ctx.lr = 0x830D8430;
	sub_830DC078(ctx, base);
	// 830D8430: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 830D8434: 4813F6BD  bl 0x83217af0
	ctx.lr = 0x830D8438;
	sub_83217AF0(ctx, base);
	// 830D8438: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D843C: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830D8440: 8081006C  lwz r4, 0x6c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830D8444: 7C7EF82E  lwzx r3, r30, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830D8448: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830D844C: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 830D8450: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830D8454: 409A0014  bne cr6, 0x830d8468
	if !ctx.cr[6].eq {
	pc = 0x830D8468; continue 'dispatch;
	}
	// 830D8458: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D845C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D8460: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D8464: 4E800421  bctrl
	ctx.lr = 0x830D8468;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830D8468 => {
    //   block [0x830D8468..0x830D8498)
	// 830D8468: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830D846C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D8470: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D8474: 409A02D8  bne cr6, 0x830d874c
	if !ctx.cr[6].eq {
	pc = 0x830D874C; continue 'dispatch;
	}
	// 830D8478: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D847C: 7C7EF82E  lwzx r3, r30, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830D8480: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D8484: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D8488: 4BC7CE41  bl 0x82d552c8
	ctx.lr = 0x830D848C;
	sub_82D552C8(ctx, base);
	// 830D848C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830D8490: 38210450  addi r1, r1, 0x450
	ctx.r[1].s64 = ctx.r[1].s64 + 1104;
	// 830D8494: 4BBD0F8C  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D8498 => {
    //   block [0x830D8498..0x830D84E8)
	// 830D8498: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 830D849C: 388101B0  addi r4, r1, 0x1b0
	ctx.r[4].s64 = ctx.r[1].s64 + 432;
	// 830D84A0: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 830D84A4: 4BC7F545  bl 0x82d579e8
	ctx.lr = 0x830D84A8;
	sub_82D579E8(ctx, base);
	// 830D84A8: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 830D84AC: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 830D84B0: 4BC7F941  bl 0x82d57df0
	ctx.lr = 0x830D84B4;
	sub_82D57DF0(ctx, base);
	// 830D84B4: 806F7630  lwz r3, 0x7630(r15)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(30256 as u32) ) } as u64;
	// 830D84B8: 3CA05EF4  lis r5, 0x5ef4
	ctx.r[5].s64 = 1593049088;
	// 830D84BC: 390001D5  li r8, 0x1d5
	ctx.r[8].s64 = 469;
	// 830D84C0: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 830D84C4: 38C101B0  addi r6, r1, 0x1b0
	ctx.r[6].s64 = ctx.r[1].s64 + 432;
	// 830D84C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D84CC: 60A5E5A3  ori r5, r5, 0xe5a3
	ctx.r[5].u64 = ctx.r[5].u64 | 58787;
	// 830D84D0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 830D84D4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D84D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D84DC: 4E800421  bctrl
	ctx.lr = 0x830D84E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D84E0: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 830D84E4: 4BC7FF4D  bl 0x82d58430
	ctx.lr = 0x830D84E8;
	sub_82D58430(ctx, base);
            }
            0x830D84E8 => {
    //   block [0x830D84E8..0x830D84EC)
	// 830D84E8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x830D84EC; continue 'dispatch;
            }
            0x830D84EC => {
    //   block [0x830D84EC..0x830D8508)
	// 830D84EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830D84F0: 419A0018  beq cr6, 0x830d8508
	if ctx.cr[6].eq {
	pc = 0x830D8508; continue 'dispatch;
	}
	// 830D84F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D84F8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830D84FC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D8500: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D8504: 4E800421  bctrl
	ctx.lr = 0x830D8508;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830D8508 => {
    //   block [0x830D8508..0x830D8528)
	// 830D8508: 38A10160  addi r5, r1, 0x160
	ctx.r[5].s64 = ctx.r[1].s64 + 352;
	// 830D850C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830D8510: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 830D8514: 480041E5  bl 0x830dc6f8
	ctx.lr = 0x830D8518;
	sub_830DC6F8(ctx, base);
	// 830D8518: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D851C: 419AF9E8  beq cr6, 0x830d7f04
	if ctx.cr[6].eq {
	pc = 0x830D7F04; continue 'dispatch;
	}
	// 830D8520: 82E1005C  lwz r23, 0x5c(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830D8524: 83610058  lwz r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x830D8528; continue 'dispatch;
            }
            0x830D8528 => {
    //   block [0x830D8528..0x830D8550)
	// 830D8528: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830D852C: 4BC86435  bl 0x82d5e960
	ctx.lr = 0x830D8530;
	sub_82D5E960(ctx, base);
	// 830D8530: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830D8534: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830D8538: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D853C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830D8540: 4BC864F9  bl 0x82d5ea38
	ctx.lr = 0x830D8544;
	sub_82D5EA38(ctx, base);
	// 830D8544: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D8548: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D854C: 419A00B4  beq cr6, 0x830d8600
	if ctx.cr[6].eq {
	pc = 0x830D8600; continue 'dispatch;
	}
	pc = 0x830D8550; continue 'dispatch;
            }
            0x830D8550 => {
    //   block [0x830D8550..0x830D85A8)
	// 830D8550: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830D8554: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830D8558: 4BC86441  bl 0x82d5e998
	ctx.lr = 0x830D855C;
	sub_82D5E998(ctx, base);
	// 830D855C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D8560: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830D8564: 2F0B0023  cmpwi cr6, r11, 0x23
	ctx.cr[6].compare_i32(ctx.r[11].s32, 35, &mut ctx.xer);
	// 830D8568: 419A006C  beq cr6, 0x830d85d4
	if ctx.cr[6].eq {
	pc = 0x830D85D4; continue 'dispatch;
	}
	// 830D856C: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 830D8570: 409A0064  bne cr6, 0x830d85d4
	if !ctx.cr[6].eq {
	pc = 0x830D85D4; continue 'dispatch;
	}
	// 830D8574: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 830D8578: 4BC80811  bl 0x82d58d88
	ctx.lr = 0x830D857C;
	sub_82D58D88(ctx, base);
	// 830D857C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830D8580: 807C0018  lwz r3, 0x18(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D8584: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D8588: 4BC98461  bl 0x82d709e8
	ctx.lr = 0x830D858C;
	sub_82D709E8(ctx, base);
	// 830D858C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830D8590: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830D8594: 4BC86425  bl 0x82d5e9b8
	ctx.lr = 0x830D8598;
	sub_82D5E9B8(ctx, base);
	// 830D8598: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 830D859C: 419A0038  beq cr6, 0x830d85d4
	if ctx.cr[6].eq {
	pc = 0x830D85D4; continue 'dispatch;
	}
	// 830D85A0: 817C0040  lwz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 830D85A4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x830D85A8; continue 'dispatch;
            }
            0x830D85A8 => {
    //   block [0x830D85A8..0x830D85D4)
	// 830D85A8: 547F1838  slwi r31, r3, 3
	ctx.r[31].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 830D85AC: 807C0018  lwz r3, 0x18(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D85B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D85B4: 7CBF582E  lwzx r5, r31, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830D85B8: 4BC99FA1  bl 0x82d72558
	ctx.lr = 0x830D85BC;
	sub_82D72558(ctx, base);
	// 830D85BC: 817C0040  lwz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 830D85C0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D85C4: 7D5F5A14  add r10, r31, r11
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830D85C8: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D85CC: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 830D85D0: 409AFFD8  bne cr6, 0x830d85a8
	if !ctx.cr[6].eq {
	pc = 0x830D85A8; continue 'dispatch;
	}
	pc = 0x830D85D4; continue 'dispatch;
            }
            0x830D85D4 => {
    //   block [0x830D85D4..0x830D8600)
	// 830D85D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830D85D8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830D85DC: 4BC8641D  bl 0x82d5e9f8
	ctx.lr = 0x830D85E0;
	sub_82D5E9F8(ctx, base);
	// 830D85E0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830D85E4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830D85E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D85EC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830D85F0: 4BC86449  bl 0x82d5ea38
	ctx.lr = 0x830D85F4;
	sub_82D5EA38(ctx, base);
	// 830D85F4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D85F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D85FC: 409AFF54  bne cr6, 0x830d8550
	if !ctx.cr[6].eq {
	pc = 0x830D8550; continue 'dispatch;
	}
	pc = 0x830D8600; continue 'dispatch;
            }
            0x830D8600 => {
    //   block [0x830D8600..0x830D8678)
	// 830D8600: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 830D8604: 4BC9B0AD  bl 0x82d736b0
	ctx.lr = 0x830D8608;
	sub_82D736B0(ctx, base);
	// 830D8608: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 830D860C: 4BC86A85  bl 0x82d5f090
	ctx.lr = 0x830D8610;
	sub_82D5F090(ctx, base);
	// 830D8610: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830D8614: 4BC86A7D  bl 0x82d5f090
	ctx.lr = 0x830D8618;
	sub_82D5F090(ctx, base);
	// 830D8618: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 830D861C: 4BC86A75  bl 0x82d5f090
	ctx.lr = 0x830D8620;
	sub_82D5F090(ctx, base);
	// 830D8620: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 830D8624: 4B18E8E5  bl 0x82266f08
	ctx.lr = 0x830D8628;
	sub_82266F08(ctx, base);
	// 830D8628: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 830D862C: 480002FD  bl 0x830d8928
	ctx.lr = 0x830D8630;
	sub_830D8928(ctx, base);
	// 830D8630: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830D8634: 4BC9CFF5  bl 0x82d75628
	ctx.lr = 0x830D8638;
	sub_82D75628(ctx, base);
	// 830D8638: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 830D863C: 4800536D  bl 0x830dd9a8
	ctx.lr = 0x830D8640;
	sub_830DD9A8(ctx, base);
	// 830D8640: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 830D8644: 48003A35  bl 0x830dc078
	ctx.lr = 0x830D8648;
	sub_830DC078(ctx, base);
	// 830D8648: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 830D864C: 4813F4A5  bl 0x83217af0
	ctx.lr = 0x830D8650;
	sub_83217AF0(ctx, base);
	// 830D8650: 7C7BB82E  lwzx r3, r27, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 830D8654: 8081006C  lwz r4, 0x6c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830D8658: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830D865C: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 830D8660: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830D8664: 409A0014  bne cr6, 0x830d8678
	if !ctx.cr[6].eq {
	pc = 0x830D8678; continue 'dispatch;
	}
	// 830D8668: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D866C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D8670: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D8674: 4E800421  bctrl
	ctx.lr = 0x830D8678;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830D8678 => {
    //   block [0x830D8678..0x830D869C)
	// 830D8678: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830D867C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D8680: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D8684: 409A0018  bne cr6, 0x830d869c
	if !ctx.cr[6].eq {
	pc = 0x830D869C; continue 'dispatch;
	}
	// 830D8688: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D868C: 7C7BB82E  lwzx r3, r27, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 830D8690: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D8694: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D8698: 4BC7CC31  bl 0x82d552c8
	ctx.lr = 0x830D869C;
	sub_82D552C8(ctx, base);
	pc = 0x830D869C; continue 'dispatch;
            }
            0x830D869C => {
    //   block [0x830D869C..0x830D86A8)
	// 830D869C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830D86A0: 38210450  addi r1, r1, 0x450
	ctx.r[1].s64 = ctx.r[1].s64 + 1104;
	// 830D86A4: 4BBD0D7C  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D86A8 => {
    //   block [0x830D86A8..0x830D8728)
	// 830D86A8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 830D86AC: 4BC9B005  bl 0x82d736b0
	ctx.lr = 0x830D86B0;
	sub_82D736B0(ctx, base);
	// 830D86B0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 830D86B4: 4BC869DD  bl 0x82d5f090
	ctx.lr = 0x830D86B8;
	sub_82D5F090(ctx, base);
	// 830D86B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830D86BC: 4BC869D5  bl 0x82d5f090
	ctx.lr = 0x830D86C0;
	sub_82D5F090(ctx, base);
	// 830D86C0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 830D86C4: 4BC869CD  bl 0x82d5f090
	ctx.lr = 0x830D86C8;
	sub_82D5F090(ctx, base);
	// 830D86C8: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 830D86CC: 4B18E83D  bl 0x82266f08
	ctx.lr = 0x830D86D0;
	sub_82266F08(ctx, base);
	// 830D86D0: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 830D86D4: 48000255  bl 0x830d8928
	ctx.lr = 0x830D86D8;
	sub_830D8928(ctx, base);
	// 830D86D8: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830D86DC: 4BC9CF4D  bl 0x82d75628
	ctx.lr = 0x830D86E0;
	sub_82D75628(ctx, base);
	// 830D86E0: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 830D86E4: 480052C5  bl 0x830dd9a8
	ctx.lr = 0x830D86E8;
	sub_830DD9A8(ctx, base);
	// 830D86E8: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 830D86EC: 4800398D  bl 0x830dc078
	ctx.lr = 0x830D86F0;
	sub_830DC078(ctx, base);
	// 830D86F0: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 830D86F4: 4813F3FD  bl 0x83217af0
	ctx.lr = 0x830D86F8;
	sub_83217AF0(ctx, base);
	// 830D86F8: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D86FC: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830D8700: 8081006C  lwz r4, 0x6c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830D8704: 7C7EF82E  lwzx r3, r30, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830D8708: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830D870C: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 830D8710: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830D8714: 409A0014  bne cr6, 0x830d8728
	if !ctx.cr[6].eq {
	pc = 0x830D8728; continue 'dispatch;
	}
	// 830D8718: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D871C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D8720: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D8724: 4E800421  bctrl
	ctx.lr = 0x830D8728;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830D8728 => {
    //   block [0x830D8728..0x830D874C)
	// 830D8728: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830D872C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D8730: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D8734: 409A0018  bne cr6, 0x830d874c
	if !ctx.cr[6].eq {
	pc = 0x830D874C; continue 'dispatch;
	}
	// 830D8738: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D873C: 7C7EF82E  lwzx r3, r30, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830D8740: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D8744: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D8748: 4BC7CB81  bl 0x82d552c8
	ctx.lr = 0x830D874C;
	sub_82D552C8(ctx, base);
	pc = 0x830D874C; continue 'dispatch;
            }
            0x830D874C => {
    //   block [0x830D874C..0x830D8758)
	// 830D874C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830D8750: 38210450  addi r1, r1, 0x450
	ctx.r[1].s64 = ctx.r[1].s64 + 1104;
	// 830D8754: 4BBD0CCC  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D8758 => {
    //   block [0x830D8758..0x830D87D8)
	// 830D8758: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 830D875C: 4BC9AF55  bl 0x82d736b0
	ctx.lr = 0x830D8760;
	sub_82D736B0(ctx, base);
	// 830D8760: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 830D8764: 4BC8692D  bl 0x82d5f090
	ctx.lr = 0x830D8768;
	sub_82D5F090(ctx, base);
	// 830D8768: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830D876C: 4BC86925  bl 0x82d5f090
	ctx.lr = 0x830D8770;
	sub_82D5F090(ctx, base);
	// 830D8770: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 830D8774: 4BC8691D  bl 0x82d5f090
	ctx.lr = 0x830D8778;
	sub_82D5F090(ctx, base);
	// 830D8778: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 830D877C: 4B18E78D  bl 0x82266f08
	ctx.lr = 0x830D8780;
	sub_82266F08(ctx, base);
	// 830D8780: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 830D8784: 480001A5  bl 0x830d8928
	ctx.lr = 0x830D8788;
	sub_830D8928(ctx, base);
	// 830D8788: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 830D878C: 4BC9CE9D  bl 0x82d75628
	ctx.lr = 0x830D8790;
	sub_82D75628(ctx, base);
	// 830D8790: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 830D8794: 48005215  bl 0x830dd9a8
	ctx.lr = 0x830D8798;
	sub_830DD9A8(ctx, base);
	// 830D8798: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 830D879C: 480038DD  bl 0x830dc078
	ctx.lr = 0x830D87A0;
	sub_830DC078(ctx, base);
	// 830D87A0: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 830D87A4: 4813F34D  bl 0x83217af0
	ctx.lr = 0x830D87A8;
	sub_83217AF0(ctx, base);
	// 830D87A8: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D87AC: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830D87B0: 8081006C  lwz r4, 0x6c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830D87B4: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830D87B8: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830D87BC: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 830D87C0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830D87C4: 409A0014  bne cr6, 0x830d87d8
	if !ctx.cr[6].eq {
	pc = 0x830D87D8; continue 'dispatch;
	}
	// 830D87C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D87CC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D87D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D87D4: 4E800421  bctrl
	ctx.lr = 0x830D87D8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830D87D8 => {
    //   block [0x830D87D8..0x830D87FC)
	// 830D87D8: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830D87DC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D87E0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D87E4: 409A0018  bne cr6, 0x830d87fc
	if !ctx.cr[6].eq {
	pc = 0x830D87FC; continue 'dispatch;
	}
	// 830D87E8: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D87EC: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830D87F0: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D87F4: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D87F8: 4BC7CAD1  bl 0x82d552c8
	ctx.lr = 0x830D87FC;
	sub_82D552C8(ctx, base);
	pc = 0x830D87FC; continue 'dispatch;
            }
            0x830D87FC => {
    //   block [0x830D87FC..0x830D8808)
	// 830D87FC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830D8800: 38210450  addi r1, r1, 0x450
	ctx.r[1].s64 = ctx.r[1].s64 + 1104;
	// 830D8804: 4BBD0C1C  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D8808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D8808 size=284
    let mut pc: u32 = 0x830D8808;
    'dispatch: loop {
        match pc {
            0x830D8808 => {
    //   block [0x830D8808..0x830D8878)
	// 830D8808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D880C: 4BBD0BF9  bl 0x82ca9404
	ctx.lr = 0x830D8810;
	sub_82CA93D0(ctx, base);
	// 830D8810: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D8814: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830D8818: 4BC9AA49  bl 0x82d73260
	ctx.lr = 0x830D881C;
	sub_82D73260(ctx, base);
	// 830D881C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D8820: 3BFE001C  addi r31, r30, 0x1c
	ctx.r[31].s64 = ctx.r[30].s64 + 28;
	// 830D8824: 396B9C0C  addi r11, r11, -0x63f4
	ctx.r[11].s64 = ctx.r[11].s64 + -25588;
	// 830D8828: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830D882C: 3F608000  lis r27, -0x8000
	ctx.r[27].s64 = -2147483648;
	// 830D8830: 3BBE0028  addi r29, r30, 0x28
	ctx.r[29].s64 = ctx.r[30].s64 + 40;
	// 830D8834: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D8838: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830D883C: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830D8840: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830D8844: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 830D8848: 4BC867E1  bl 0x82d5f028
	ctx.lr = 0x830D884C;
	sub_82D5F028(ctx, base);
	// 830D884C: 939E0034  stw r28, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[28].u32 ) };
	// 830D8850: 939E0038  stw r28, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[28].u32 ) };
	// 830D8854: 937E003C  stw r27, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[27].u32 ) };
	// 830D8858: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D885C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D8860: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D8864: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D8868: 409A0010  bne cr6, 0x830d8878
	if !ctx.cr[6].eq {
	pc = 0x830D8878; continue 'dispatch;
	}
	// 830D886C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 830D8870: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D8874: 4BC7E725  bl 0x82d56f98
	ctx.lr = 0x830D8878;
	sub_82D56F98(ctx, base);
	pc = 0x830D8878; continue 'dispatch;
            }
            0x830D8878 => {
    //   block [0x830D8878..0x830D8924)
	// 830D8878: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D887C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D8880: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D8884: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D8888: 396B68CC  addi r11, r11, 0x68cc
	ctx.r[11].s64 = ctx.r[11].s64 + 26828;
	// 830D888C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830D8890: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D8894: 7D6A492E  stwx r11, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[11].u32) };
	// 830D8898: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D889C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D88A0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830D88A4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D88A8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D88AC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D88B0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D88B4: 808BFFFC  lwz r4, -4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830D88B8: 4BC861A1  bl 0x82d5ea58
	ctx.lr = 0x830D88BC;
	sub_82D5EA58(ctx, base);
	// 830D88BC: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D88C0: 3BE00004  li r31, 4
	ctx.r[31].s64 = 4;
	// 830D88C4: 38A00014  li r5, 0x14
	ctx.r[5].s64 = 20;
	// 830D88C8: 38800048  li r4, 0x48
	ctx.r[4].s64 = 72;
	// 830D88CC: 7C7FE82E  lwzx r3, r31, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830D88D0: 4BC7C979  bl 0x82d55248
	ctx.lr = 0x830D88D4;
	sub_82D55248(ctx, base);
	// 830D88D4: 39600048  li r11, 0x48
	ctx.r[11].s64 = 72;
	// 830D88D8: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 830D88DC: 4BC997A5  bl 0x82d72080
	ctx.lr = 0x830D88E0;
	sub_82D72080(ctx, base);
	// 830D88E0: 38A00014  li r5, 0x14
	ctx.r[5].s64 = 20;
	// 830D88E4: 907E0018  stw r3, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 830D88E8: 38800038  li r4, 0x38
	ctx.r[4].s64 = 56;
	// 830D88EC: 7C7FE82E  lwzx r3, r31, r29
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830D88F0: 4BC7C959  bl 0x82d55248
	ctx.lr = 0x830D88F4;
	sub_82D55248(ctx, base);
	// 830D88F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D88F8: 39600038  li r11, 0x38
	ctx.r[11].s64 = 56;
	// 830D88FC: B17F0004  sth r11, 4(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 830D8900: 809E0018  lwz r4, 0x18(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830D8904: 4BC98285  bl 0x82d70b88
	ctx.lr = 0x830D8908;
	sub_82D70B88(ctx, base);
	// 830D8908: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D890C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D8910: 396B9CA8  addi r11, r11, -0x6358
	ctx.r[11].s64 = ctx.r[11].s64 + -25432;
	// 830D8914: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830D8918: 93FE0040  stw r31, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[31].u32 ) };
	// 830D891C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830D8920: 4BBD0B34  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D8928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D8928 size=176
    let mut pc: u32 = 0x830D8928;
    'dispatch: loop {
        match pc {
            0x830D8928 => {
    //   block [0x830D8928..0x830D8978)
	// 830D8928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D892C: 4BBD0AD9  bl 0x82ca9404
	ctx.lr = 0x830D8930;
	sub_82CA93D0(ctx, base);
	// 830D8930: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D8934: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D8938: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830D893C: 396B9BFC  addi r11, r11, -0x6404
	ctx.r[11].s64 = ctx.r[11].s64 + -25604;
	// 830D8940: 3BDB0008  addi r30, r27, 8
	ctx.r[30].s64 = ctx.r[27].s64 + 8;
	// 830D8944: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D8948: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830D894C: 4BC86015  bl 0x82d5e960
	ctx.lr = 0x830D8950;
	sub_82D5E960(ctx, base);
	// 830D8950: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D8954: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D8958: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D895C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830D8960: 4BC860D9  bl 0x82d5ea38
	ctx.lr = 0x830D8964;
	sub_82D5EA38(ctx, base);
	// 830D8964: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D8968: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D896C: 419A0050  beq cr6, 0x830d89bc
	if ctx.cr[6].eq {
	pc = 0x830D89BC; continue 'dispatch;
	}
	// 830D8970: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D8974: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	pc = 0x830D8978; continue 'dispatch;
            }
            0x830D8978 => {
    //   block [0x830D8978..0x830D89BC)
	// 830D8978: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D897C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D8980: 4BC86019  bl 0x82d5e998
	ctx.lr = 0x830D8984;
	sub_82D5E998(ctx, base);
	// 830D8984: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830D8988: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830D898C: 4BC7CB45  bl 0x82d554d0
	ctx.lr = 0x830D8990;
	sub_82D554D0(ctx, base);
	// 830D8990: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D8994: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D8998: 4BC86061  bl 0x82d5e9f8
	ctx.lr = 0x830D899C;
	sub_82D5E9F8(ctx, base);
	// 830D899C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D89A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D89A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D89A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830D89AC: 4BC8608D  bl 0x82d5ea38
	ctx.lr = 0x830D89B0;
	sub_82D5EA38(ctx, base);
	// 830D89B0: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D89B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D89B8: 409AFFC0  bne cr6, 0x830d8978
	if !ctx.cr[6].eq {
	pc = 0x830D8978; continue 'dispatch;
	}
	pc = 0x830D89BC; continue 'dispatch;
            }
            0x830D89BC => {
    //   block [0x830D89BC..0x830D89D8)
	// 830D89BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D89C0: 4BC866D1  bl 0x82d5f090
	ctx.lr = 0x830D89C4;
	sub_82D5F090(ctx, base);
	// 830D89C4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D89C8: 396B39E0  addi r11, r11, 0x39e0
	ctx.r[11].s64 = ctx.r[11].s64 + 14816;
	// 830D89CC: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830D89D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830D89D4: 4BBD0A80  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D89D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D89D8 size=100
    let mut pc: u32 = 0x830D89D8;
    'dispatch: loop {
        match pc {
            0x830D89D8 => {
    //   block [0x830D89D8..0x830D8A20)
	// 830D89D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D89DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830D89E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830D89E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830D89E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D89EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D89F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830D89F4: 4BFFFF35  bl 0x830d8928
	ctx.lr = 0x830D89F8;
	sub_830D8928(ctx, base);
	// 830D89F8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 830D89FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D8A00: 419A0020  beq cr6, 0x830d8a20
	if ctx.cr[6].eq {
	pc = 0x830D8A20; continue 'dispatch;
	}
	// 830D8A04: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D8A08: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830D8A0C: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 830D8A10: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D8A14: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D8A18: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830D8A1C: 4BC7C8AD  bl 0x82d552c8
	ctx.lr = 0x830D8A20;
	sub_82D552C8(ctx, base);
	pc = 0x830D8A20; continue 'dispatch;
            }
            0x830D8A20 => {
    //   block [0x830D8A20..0x830D8A3C)
	// 830D8A20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D8A24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830D8A28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830D8A2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830D8A30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830D8A34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830D8A38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D8A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D8A40 size=100
    let mut pc: u32 = 0x830D8A40;
    'dispatch: loop {
        match pc {
            0x830D8A40 => {
    //   block [0x830D8A40..0x830D8A88)
	// 830D8A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D8A44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830D8A48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830D8A4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830D8A50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D8A54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D8A58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830D8A5C: 4BFFEFAD  bl 0x830d7a08
	ctx.lr = 0x830D8A60;
	sub_830D7A08(ctx, base);
	// 830D8A60: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 830D8A64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D8A68: 419A0020  beq cr6, 0x830d8a88
	if ctx.cr[6].eq {
	pc = 0x830D8A88; continue 'dispatch;
	}
	// 830D8A6C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D8A70: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830D8A74: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 830D8A78: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D8A7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D8A80: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830D8A84: 4BC7C845  bl 0x82d552c8
	ctx.lr = 0x830D8A88;
	sub_82D552C8(ctx, base);
	pc = 0x830D8A88; continue 'dispatch;
            }
            0x830D8A88 => {
    //   block [0x830D8A88..0x830D8AA4)
	// 830D8A88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D8A8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830D8A90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830D8A94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830D8A98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830D8A9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830D8AA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D8AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D8AA8 size=100
    let mut pc: u32 = 0x830D8AA8;
    'dispatch: loop {
        match pc {
            0x830D8AA8 => {
    //   block [0x830D8AA8..0x830D8AF0)
	// 830D8AA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D8AAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830D8AB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830D8AB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830D8AB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D8ABC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D8AC0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830D8AC4: 4BC985B5  bl 0x82d71078
	ctx.lr = 0x830D8AC8;
	sub_82D71078(ctx, base);
	// 830D8AC8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 830D8ACC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D8AD0: 419A0020  beq cr6, 0x830d8af0
	if ctx.cr[6].eq {
	pc = 0x830D8AF0; continue 'dispatch;
	}
	// 830D8AD4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D8AD8: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830D8ADC: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 830D8AE0: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D8AE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D8AE8: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830D8AEC: 4BC7C7DD  bl 0x82d552c8
	ctx.lr = 0x830D8AF0;
	sub_82D552C8(ctx, base);
	pc = 0x830D8AF0; continue 'dispatch;
            }
            0x830D8AF0 => {
    //   block [0x830D8AF0..0x830D8B0C)
	// 830D8AF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D8AF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830D8AF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830D8AFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830D8B00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830D8B04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830D8B08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D8B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D8B10 size=108
    let mut pc: u32 = 0x830D8B10;
    'dispatch: loop {
        match pc {
            0x830D8B10 => {
    //   block [0x830D8B10..0x830D8B64)
	// 830D8B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D8B14: 4BBD08F9  bl 0x82ca940c
	ctx.lr = 0x830D8B18;
	sub_82CA93D0(ctx, base);
	// 830D8B18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D8B1C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830D8B20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D8B24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830D8B28: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830D8B2C: 4BC7CFC5  bl 0x82d55af0
	ctx.lr = 0x830D8B30;
	sub_82D55AF0(ctx, base);
	// 830D8B30: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D8B34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D8B38: 419A0038  beq cr6, 0x830d8b70
	if ctx.cr[6].eq {
	pc = 0x830D8B70; continue 'dispatch;
	}
	// 830D8B3C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830D8B40: 419A0024  beq cr6, 0x830d8b64
	if ctx.cr[6].eq {
	pc = 0x830D8B64; continue 'dispatch;
	}
	// 830D8B44: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D8B48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830D8B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D8B50: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D8B54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D8B58: 4E800421  bctrl
	ctx.lr = 0x830D8B5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D8B5C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830D8B60: 4BBD08FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D8B64 => {
    //   block [0x830D8B64..0x830D8B70)
	// 830D8B64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830D8B68: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830D8B6C: 4BBD08F0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D8B70 => {
    //   block [0x830D8B70..0x830D8B7C)
	// 830D8B70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D8B74: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830D8B78: 4BBD08E4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D8B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830D8B80 size=32
    let mut pc: u32 = 0x830D8B80;
    'dispatch: loop {
        match pc {
            0x830D8B80 => {
    //   block [0x830D8B80..0x830D8BA0)
	// 830D8B80: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D8B84: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830D8B88: 392B9CE0  addi r9, r11, -0x6320
	ctx.r[9].s64 = ctx.r[11].s64 + -25376;
	// 830D8B8C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D8B90: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830D8B94: 38AB9CCC  addi r5, r11, -0x6334
	ctx.r[5].s64 = ctx.r[11].s64 + -25396;
	// 830D8B98: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 830D8B9C: 4BC7FDAC  b 0x82d58948
	sub_82D58948(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D8BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D8BA0 size=96
    let mut pc: u32 = 0x830D8BA0;
    'dispatch: loop {
        match pc {
            0x830D8BA0 => {
    //   block [0x830D8BA0..0x830D8C00)
	// 830D8BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D8BA4: 4BBD0861  bl 0x82ca9404
	ctx.lr = 0x830D8BA8;
	sub_82CA93D0(ctx, base);
	// 830D8BA8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D8BAC: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830D8BB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D8BB4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830D8BB8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830D8BBC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830D8BC0: 806B7BF4  lwz r3, 0x7bf4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31732 as u32) ) } as u64;
	// 830D8BC4: 837F0000  lwz r27, 0(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D8BC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D8BCC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830D8BD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D8BD4: 4E800421  bctrl
	ctx.lr = 0x830D8BD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D8BD8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 830D8BDC: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D8BE0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830D8BE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D8BE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D8BEC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 830D8BF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D8BF4: 4E800421  bctrl
	ctx.lr = 0x830D8BF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D8BF8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830D8BFC: 4BBD0858  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D8C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D8C00 size=116
    let mut pc: u32 = 0x830D8C00;
    'dispatch: loop {
        match pc {
            0x830D8C00 => {
    //   block [0x830D8C00..0x830D8C4C)
	// 830D8C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D8C04: 4BBD0805  bl 0x82ca9408
	ctx.lr = 0x830D8C08;
	sub_82CA93D0(ctx, base);
	// 830D8C08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D8C0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D8C10: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830D8C14: 3BBF0014  addi r29, r31, 0x14
	ctx.r[29].s64 = ctx.r[31].s64 + 20;
	// 830D8C18: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 830D8C1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D8C20: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830D8C24: 4BC87A65  bl 0x82d60688
	ctx.lr = 0x830D8C28;
	sub_82D60688(ctx, base);
	// 830D8C28: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D8C2C: 41980020  blt cr6, 0x830d8c4c
	if ctx.cr[6].lt {
	pc = 0x830D8C4C; continue 'dispatch;
	}
	// 830D8C30: 546B083C  slwi r11, r3, 1
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D8C34: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D8C38: 3920FFFE  li r9, -2
	ctx.r[9].s64 = -2;
	// 830D8C3C: 7D635A14  add r11, r3, r11
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 830D8C40: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D8C44: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D8C48: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x830D8C4C; continue 'dispatch;
            }
            0x830D8C4C => {
    //   block [0x830D8C4C..0x830D8C74)
	// 830D8C4C: 38A0FFFE  li r5, -2
	ctx.r[5].s64 = -2;
	// 830D8C50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D8C54: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D8C58: 4B18CFA9  bl 0x82265c00
	ctx.lr = 0x830D8C5C;
	sub_82265C00(ctx, base);
	// 830D8C5C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830D8C60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D8C64: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 830D8C68: 4B18CF99  bl 0x82265c00
	ctx.lr = 0x830D8C6C;
	sub_82265C00(ctx, base);
	// 830D8C6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830D8C70: 4BBD07E8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D8C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830D8C78 size=8
    let mut pc: u32 = 0x830D8C78;
    'dispatch: loop {
        match pc {
            0x830D8C78 => {
    //   block [0x830D8C78..0x830D8C80)
	// 830D8C78: 3863002C  addi r3, r3, 0x2c
	ctx.r[3].s64 = ctx.r[3].s64 + 44;
	// 830D8C7C: 4B18CF84  b 0x82265c00
	sub_82265C00(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D8C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D8C80 size=392
    let mut pc: u32 = 0x830D8C80;
    'dispatch: loop {
        match pc {
            0x830D8C80 => {
    //   block [0x830D8C80..0x830D8D5C)
	// 830D8C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D8C84: 4BBD0785  bl 0x82ca9408
	ctx.lr = 0x830D8C88;
	sub_82CA93D0(ctx, base);
	// 830D8C88: 9421FD70  stwu r1, -0x290(r1)
	ea = ctx.r[1].u32.wrapping_add(-656 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D8C8C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830D8C90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830D8C94: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D8C98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D8C9C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830D8CA0: 3B8B3CD8  addi r28, r11, 0x3cd8
	ctx.r[28].s64 = ctx.r[11].s64 + 15576;
	// 830D8CA4: 4BC7CAAD  bl 0x82d55750
	ctx.lr = 0x830D8CA8;
	sub_82D55750(ctx, base);
	// 830D8CA8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830D8CAC: 4BC7FD2D  bl 0x82d589d8
	ctx.lr = 0x830D8CB0;
	sub_82D589D8(ctx, base);
	// 830D8CB0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D8CB4: 409A00F8  bne cr6, 0x830d8dac
	if !ctx.cr[6].eq {
	pc = 0x830D8DAC; continue 'dispatch;
	}
	// 830D8CB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D8CBC: 4BC7CA95  bl 0x82d55750
	ctx.lr = 0x830D8CC0;
	sub_82D55750(ctx, base);
	// 830D8CC0: 3B9E0038  addi r28, r30, 0x38
	ctx.r[28].s64 = ctx.r[30].s64 + 56;
	// 830D8CC4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830D8CC8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D8CCC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D8CD0: 4BC86029  bl 0x82d5ecf8
	ctx.lr = 0x830D8CD4;
	sub_82D5ECF8(ctx, base);
	// 830D8CD4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830D8CD8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830D8CDC: 419A00C0  beq cr6, 0x830d8d9c
	if ctx.cr[6].eq {
	pc = 0x830D8D9C; continue 'dispatch;
	}
	// 830D8CE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830D8CE4: 4BC7D2B5  bl 0x82d55f98
	ctx.lr = 0x830D8CE8;
	sub_82D55F98(ctx, base);
	// 830D8CE8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830D8CEC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830D8CF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D8CF4: 4BC7D2A5  bl 0x82d55f98
	ctx.lr = 0x830D8CF8;
	sub_82D55F98(ctx, base);
	// 830D8CF8: 7F03E040  cmplw cr6, r3, r28
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830D8CFC: 419A0060  beq cr6, 0x830d8d5c
	if ctx.cr[6].eq {
	pc = 0x830D8D5C; continue 'dispatch;
	}
	// 830D8D00: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 830D8D04: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830D8D08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D8D0C: 4BC7ECDD  bl 0x82d579e8
	ctx.lr = 0x830D8D10;
	sub_82D579E8(ctx, base);
	// 830D8D10: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D8D14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D8D18: 388B9D08  addi r4, r11, -0x62f8
	ctx.r[4].s64 = ctx.r[11].s64 + -25336;
	// 830D8D1C: 4BC7F0D5  bl 0x82d57df0
	ctx.lr = 0x830D8D20;
	sub_82D57DF0(ctx, base);
	// 830D8D20: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830D8D24: 3CA02518  lis r5, 0x2518
	ctx.r[5].s64 = 622329856;
	// 830D8D28: 390000B5  li r8, 0xb5
	ctx.r[8].s64 = 181;
	// 830D8D2C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830D8D30: 60A5721C  ori r5, r5, 0x721c
	ctx.r[5].u64 = ctx.r[5].u64 | 29212;
	// 830D8D34: 806B7630  lwz r3, 0x7630(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30256 as u32) ) } as u64;
	// 830D8D38: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D8D3C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 830D8D40: 38EB9CE4  addi r7, r11, -0x631c
	ctx.r[7].s64 = ctx.r[11].s64 + -25372;
	// 830D8D44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D8D48: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D8D4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D8D50: 4E800421  bctrl
	ctx.lr = 0x830D8D54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D8D54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D8D58: 4BC7F6D9  bl 0x82d58430
	ctx.lr = 0x830D8D5C;
	sub_82D58430(ctx, base);
            }
            0x830D8D5C => {
    //   block [0x830D8D5C..0x830D8D9C)
	// 830D8D5C: 3B9E0014  addi r28, r30, 0x14
	ctx.r[28].s64 = ctx.r[30].s64 + 20;
	// 830D8D60: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 830D8D64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830D8D68: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D8D6C: 4BC8791D  bl 0x82d60688
	ctx.lr = 0x830D8D70;
	sub_82D60688(ctx, base);
	// 830D8D70: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830D8D74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D8D78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D8D7C: 4B18CE85  bl 0x82265c00
	ctx.lr = 0x830D8D80;
	sub_82265C00(ctx, base);
	// 830D8D80: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830D8D84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D8D88: 387E0050  addi r3, r30, 0x50
	ctx.r[3].s64 = ctx.r[30].s64 + 80;
	// 830D8D8C: 4B18CE75  bl 0x82265c00
	ctx.lr = 0x830D8D90;
	sub_82265C00(ctx, base);
	// 830D8D90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830D8D94: 38210290  addi r1, r1, 0x290
	ctx.r[1].s64 = ctx.r[1].s64 + 656;
	// 830D8D98: 4BBD06C0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D8D9C => {
    //   block [0x830D8D9C..0x830D8DAC)
	// 830D8D9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D8DA0: 4BC7C9B1  bl 0x82d55750
	ctx.lr = 0x830D8DA4;
	sub_82D55750(ctx, base);
	// 830D8DA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830D8DA8: 48000048  b 0x830d8df0
	pc = 0x830D8DF0; continue 'dispatch;
            }
            0x830D8DAC => {
    //   block [0x830D8DAC..0x830D8DF0)
	// 830D8DAC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D8DB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D8DB4: 3B8B3D58  addi r28, r11, 0x3d58
	ctx.r[28].s64 = ctx.r[11].s64 + 15704;
	// 830D8DB8: 4BC7C999  bl 0x82d55750
	ctx.lr = 0x830D8DBC;
	sub_82D55750(ctx, base);
	// 830D8DBC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830D8DC0: 4BC7FC19  bl 0x82d589d8
	ctx.lr = 0x830D8DC4;
	sub_82D589D8(ctx, base);
	// 830D8DC4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D8DC8: 409A0034  bne cr6, 0x830d8dfc
	if !ctx.cr[6].eq {
	pc = 0x830D8DFC; continue 'dispatch;
	}
	// 830D8DCC: 3B9E0044  addi r28, r30, 0x44
	ctx.r[28].s64 = ctx.r[30].s64 + 68;
	// 830D8DD0: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D8DD4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830D8DD8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D8DDC: 4BC85F1D  bl 0x82d5ecf8
	ctx.lr = 0x830D8DE0;
	sub_82D5ECF8(ctx, base);
	// 830D8DE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830D8DE4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830D8DE8: 409AFF74  bne cr6, 0x830d8d5c
	if !ctx.cr[6].eq {
	pc = 0x830D8D5C; continue 'dispatch;
	}
	// 830D8DEC: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x830D8DF0; continue 'dispatch;
            }
            0x830D8DF0 => {
    //   block [0x830D8DF0..0x830D8DFC)
	// 830D8DF0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830D8DF4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D8DF8: 4BC85C61  bl 0x82d5ea58
	ctx.lr = 0x830D8DFC;
	sub_82D5EA58(ctx, base);
	pc = 0x830D8DFC; continue 'dispatch;
            }
            0x830D8DFC => {
    //   block [0x830D8DFC..0x830D8E08)
	// 830D8DFC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830D8E00: 38210290  addi r1, r1, 0x290
	ctx.r[1].s64 = ctx.r[1].s64 + 656;
	// 830D8E04: 4BBD0654  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D8E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D8E08 size=252
    let mut pc: u32 = 0x830D8E08;
    'dispatch: loop {
        match pc {
            0x830D8E08 => {
    //   block [0x830D8E08..0x830D8F04)
	// 830D8E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D8E0C: 4BBD05FD  bl 0x82ca9408
	ctx.lr = 0x830D8E10;
	sub_82CA93D0(ctx, base);
	// 830D8E10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D8E14: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D8E18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D8E1C: 396B9D88  addi r11, r11, -0x6278
	ctx.r[11].s64 = ctx.r[11].s64 + -25208;
	// 830D8E20: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830D8E24: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830D8E28: 3F808000  lis r28, -0x8000
	ctx.r[28].s64 = -2147483648;
	// 830D8E2C: 3BBF0014  addi r29, r31, 0x14
	ctx.r[29].s64 = ctx.r[31].s64 + 20;
	// 830D8E30: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830D8E34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D8E38: B15F0006  sth r10, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 830D8E3C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830D8E40: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 830D8E44: 939F0010  stw r28, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[28].u32 ) };
	// 830D8E48: 4B18E0F9  bl 0x82266f40
	ctx.lr = 0x830D8E4C;
	sub_82266F40(ctx, base);
	// 830D8E4C: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 830D8E50: 4B18E0F1  bl 0x82266f40
	ctx.lr = 0x830D8E54;
	sub_82266F40(ctx, base);
	// 830D8E54: 387F002C  addi r3, r31, 0x2c
	ctx.r[3].s64 = ctx.r[31].s64 + 44;
	// 830D8E58: 4B18E0E9  bl 0x82266f40
	ctx.lr = 0x830D8E5C;
	sub_82266F40(ctx, base);
	// 830D8E5C: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 830D8E60: 4BC861C9  bl 0x82d5f028
	ctx.lr = 0x830D8E64;
	sub_82D5F028(ctx, base);
	// 830D8E64: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 830D8E68: 4BC861C1  bl 0x82d5f028
	ctx.lr = 0x830D8E6C;
	sub_82D5F028(ctx, base);
	// 830D8E6C: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 830D8E70: 4B18E0D1  bl 0x82266f40
	ctx.lr = 0x830D8E74;
	sub_82266F40(ctx, base);
	// 830D8E74: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 830D8E78: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 830D8E7C: 93DF0060  stw r30, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 830D8E80: 939F0064  stw r28, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 830D8E84: 4BC861A5  bl 0x82d5f028
	ctx.lr = 0x830D8E88;
	sub_82D5F028(ctx, base);
	// 830D8E88: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830D8E8C: 93DF0074  stw r30, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 830D8E90: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 830D8E94: 93DF0078  stw r30, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 830D8E98: 939F007C  stw r28, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[28].u32 ) };
	// 830D8E9C: 93DF0088  stw r30, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 830D8EA0: 93DF008C  stw r30, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 830D8EA4: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 830D8EA8: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 830D8EAC: 4B18E095  bl 0x82266f40
	ctx.lr = 0x830D8EB0;
	sub_82266F40(ctx, base);
	// 830D8EB0: 387F009C  addi r3, r31, 0x9c
	ctx.r[3].s64 = ctx.r[31].s64 + 156;
	// 830D8EB4: 4BC86175  bl 0x82d5f028
	ctx.lr = 0x830D8EB8;
	sub_82D5F028(ctx, base);
	// 830D8EB8: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830D8EBC: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 830D8EC0: 388B7694  addi r4, r11, 0x7694
	ctx.r[4].s64 = ctx.r[11].s64 + 30356;
	// 830D8EC4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830D8EC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D8ECC: 4B18CD35  bl 0x82265c00
	ctx.lr = 0x830D8ED0;
	sub_82265C00(ctx, base);
	// 830D8ED0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830D8ED4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830D8ED8: 388B76C4  addi r4, r11, 0x76c4
	ctx.r[4].s64 = ctx.r[11].s64 + 30404;
	// 830D8EDC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D8EE0: 4B18CD21  bl 0x82265c00
	ctx.lr = 0x830D8EE4;
	sub_82265C00(ctx, base);
	// 830D8EE4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830D8EE8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830D8EEC: 388B7634  addi r4, r11, 0x7634
	ctx.r[4].s64 = ctx.r[11].s64 + 30260;
	// 830D8EF0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D8EF4: 4B18CD0D  bl 0x82265c00
	ctx.lr = 0x830D8EF8;
	sub_82265C00(ctx, base);
	// 830D8EF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D8EFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830D8F00: 4BBD0558  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D8F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D8F08 size=328
    let mut pc: u32 = 0x830D8F08;
    'dispatch: loop {
        match pc {
            0x830D8F08 => {
    //   block [0x830D8F08..0x830D8F40)
	// 830D8F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D8F0C: 4BBD04F9  bl 0x82ca9404
	ctx.lr = 0x830D8F10;
	sub_82CA93D0(ctx, base);
	// 830D8F10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D8F14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D8F18: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D8F1C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830D8F20: 396B9D88  addi r11, r11, -0x6278
	ctx.r[11].s64 = ctx.r[11].s64 + -25208;
	// 830D8F24: 815F0060  lwz r10, 0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D8F28: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D8F2C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830D8F30: 40990034  ble cr6, 0x830d8f64
	if !ctx.cr[6].gt {
	pc = 0x830D8F64; continue 'dispatch;
	}
	// 830D8F34: 836D0000  lwz r27, 0(r13)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D8F38: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 830D8F3C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x830D8F40; continue 'dispatch;
            }
            0x830D8F40 => {
    //   block [0x830D8F40..0x830D8F64)
	// 830D8F40: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830D8F44: 7C7CD82E  lwzx r3, r28, r27
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 830D8F48: 7C9E582E  lwzx r4, r30, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830D8F4C: 4BC7C585  bl 0x82d554d0
	ctx.lr = 0x830D8F50;
	sub_82D554D0(ctx, base);
	// 830D8F50: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D8F54: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830D8F58: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830D8F5C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D8F60: 4198FFE0  blt cr6, 0x830d8f40
	if ctx.cr[6].lt {
	pc = 0x830D8F40; continue 'dispatch;
	}
	pc = 0x830D8F64; continue 'dispatch;
            }
            0x830D8F64 => {
    //   block [0x830D8F64..0x830D8FA0)
	// 830D8F64: 387F009C  addi r3, r31, 0x9c
	ctx.r[3].s64 = ctx.r[31].s64 + 156;
	// 830D8F68: 4BC86129  bl 0x82d5f090
	ctx.lr = 0x830D8F6C;
	sub_82D5F090(ctx, base);
	// 830D8F6C: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 830D8F70: 4B18DF99  bl 0x82266f08
	ctx.lr = 0x830D8F74;
	sub_82266F08(ctx, base);
	// 830D8F74: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 830D8F78: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D8F7C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D8F80: 409A0020  bne cr6, 0x830d8fa0
	if !ctx.cr[6].eq {
	pc = 0x830D8FA0; continue 'dispatch;
	}
	// 830D8F84: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D8F88: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D8F8C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D8F90: 809F0074  lwz r4, 0x74(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 830D8F94: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830D8F98: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D8F9C: 4BC7C32D  bl 0x82d552c8
	ctx.lr = 0x830D8FA0;
	sub_82D552C8(ctx, base);
	pc = 0x830D8FA0; continue 'dispatch;
            }
            0x830D8FA0 => {
    //   block [0x830D8FA0..0x830D8FD4)
	// 830D8FA0: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 830D8FA4: 4BC860ED  bl 0x82d5f090
	ctx.lr = 0x830D8FA8;
	sub_82D5F090(ctx, base);
	// 830D8FA8: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 830D8FAC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D8FB0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D8FB4: 409A0020  bne cr6, 0x830d8fd4
	if !ctx.cr[6].eq {
	pc = 0x830D8FD4; continue 'dispatch;
	}
	// 830D8FB8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D8FBC: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D8FC0: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D8FC4: 809F005C  lwz r4, 0x5c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 830D8FC8: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830D8FCC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D8FD0: 4BC7C2F9  bl 0x82d552c8
	ctx.lr = 0x830D8FD4;
	sub_82D552C8(ctx, base);
	pc = 0x830D8FD4; continue 'dispatch;
            }
            0x830D8FD4 => {
    //   block [0x830D8FD4..0x830D903C)
	// 830D8FD4: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 830D8FD8: 4B18DF31  bl 0x82266f08
	ctx.lr = 0x830D8FDC;
	sub_82266F08(ctx, base);
	// 830D8FDC: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 830D8FE0: 4BC860B1  bl 0x82d5f090
	ctx.lr = 0x830D8FE4;
	sub_82D5F090(ctx, base);
	// 830D8FE4: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 830D8FE8: 4BC860A9  bl 0x82d5f090
	ctx.lr = 0x830D8FEC;
	sub_82D5F090(ctx, base);
	// 830D8FEC: 387F002C  addi r3, r31, 0x2c
	ctx.r[3].s64 = ctx.r[31].s64 + 44;
	// 830D8FF0: 4B18DF19  bl 0x82266f08
	ctx.lr = 0x830D8FF4;
	sub_82266F08(ctx, base);
	// 830D8FF4: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 830D8FF8: 4B18DF11  bl 0x82266f08
	ctx.lr = 0x830D8FFC;
	sub_82266F08(ctx, base);
	// 830D8FFC: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 830D9000: 4B18DF09  bl 0x82266f08
	ctx.lr = 0x830D9004;
	sub_82266F08(ctx, base);
	// 830D9004: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830D9008: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830D900C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830D9010: 409A002C  bne cr6, 0x830d903c
	if !ctx.cr[6].eq {
	pc = 0x830D903C; continue 'dispatch;
	}
	// 830D9014: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D9018: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830D901C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D9020: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D9024: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830D9028: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D902C: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830D9030: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D9034: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830D9038: 4BC7C291  bl 0x82d552c8
	ctx.lr = 0x830D903C;
	sub_82D552C8(ctx, base);
	pc = 0x830D903C; continue 'dispatch;
            }
            0x830D903C => {
    //   block [0x830D903C..0x830D9050)
	// 830D903C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D9040: 396B39E0  addi r11, r11, 0x39e0
	ctx.r[11].s64 = ctx.r[11].s64 + 14816;
	// 830D9044: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830D9048: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830D904C: 4BBD0408  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D9050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D9050 size=164
    let mut pc: u32 = 0x830D9050;
    'dispatch: loop {
        match pc {
            0x830D9050 => {
    //   block [0x830D9050..0x830D9088)
	// 830D9050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D9054: 4BBD03B5  bl 0x82ca9408
	ctx.lr = 0x830D9058;
	sub_82CA93D0(ctx, base);
	// 830D9058: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D905C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D9060: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830D9064: 3B9F0068  addi r28, r31, 0x68
	ctx.r[28].s64 = ctx.r[31].s64 + 104;
	// 830D9068: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830D906C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D9070: 4BC85C01  bl 0x82d5ec70
	ctx.lr = 0x830D9074;
	sub_82D5EC70(ctx, base);
	// 830D9074: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D9078: 409A0010  bne cr6, 0x830d9088
	if !ctx.cr[6].eq {
	pc = 0x830D9088; continue 'dispatch;
	}
	// 830D907C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D9080: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830D9084: 4BBD03D4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9088 => {
    //   block [0x830D9088..0x830D90CC)
	// 830D9088: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D908C: 4BC7FCFD  bl 0x82d58d88
	ctx.lr = 0x830D9090;
	sub_82D58D88(ctx, base);
	// 830D9090: 83DF0060  lwz r30, 0x60(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 830D9094: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830D9098: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D909C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830D90A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830D90A4: 4BC859B5  bl 0x82d5ea58
	ctx.lr = 0x830D90A8;
	sub_82D5EA58(ctx, base);
	// 830D90A8: 3BFF005C  addi r31, r31, 0x5c
	ctx.r[31].s64 = ctx.r[31].s64 + 92;
	// 830D90AC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D90B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D90B4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D90B8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D90BC: 409A0010  bne cr6, 0x830d90cc
	if !ctx.cr[6].eq {
	pc = 0x830D90CC; continue 'dispatch;
	}
	// 830D90C0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 830D90C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D90C8: 4BC7DED1  bl 0x82d56f98
	ctx.lr = 0x830D90CC;
	sub_82D56F98(ctx, base);
	pc = 0x830D90CC; continue 'dispatch;
            }
            0x830D90CC => {
    //   block [0x830D90CC..0x830D90F4)
	// 830D90CC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D90D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D90D4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D90D8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D90DC: 7FAB512E  stwx r29, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u32) };
	// 830D90E0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D90E4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D90E8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830D90EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830D90F0: 4BBD0368  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D90F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D90F8 size=328
    let mut pc: u32 = 0x830D90F8;
    'dispatch: loop {
        match pc {
            0x830D90F8 => {
    //   block [0x830D90F8..0x830D9150)
	// 830D90F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D90FC: 4BBD0305  bl 0x82ca9400
	ctx.lr = 0x830D9100;
	sub_82CA93D0(ctx, base);
	// 830D9100: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D9104: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830D9108: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 830D910C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830D9110: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830D9114: 387B0090  addi r3, r27, 0x90
	ctx.r[3].s64 = ctx.r[27].s64 + 144;
	// 830D9118: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 830D911C: 4BC8756D  bl 0x82d60688
	ctx.lr = 0x830D9120;
	sub_82D60688(ctx, base);
	// 830D9120: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 830D9124: 409A0114  bne cr6, 0x830d9238
	if !ctx.cr[6].eq {
	pc = 0x830D9238; continue 'dispatch;
	}
	// 830D9128: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D912C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 830D9130: 4BC7C621  bl 0x82d55750
	ctx.lr = 0x830D9134;
	sub_82D55750(ctx, base);
	// 830D9134: 3BDB009C  addi r30, r27, 0x9c
	ctx.r[30].s64 = ctx.r[27].s64 + 156;
	// 830D9138: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830D913C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830D9140: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9144: 4BC85BB5  bl 0x82d5ecf8
	ctx.lr = 0x830D9148;
	sub_82D5ECF8(ctx, base);
	// 830D9148: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 830D914C: 409A00EC  bne cr6, 0x830d9238
	if !ctx.cr[6].eq {
	pc = 0x830D9238; continue 'dispatch;
	}
	pc = 0x830D9150; continue 'dispatch;
            }
            0x830D9150 => {
    //   block [0x830D9150..0x830D9188)
	// 830D9150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D9154: 4BC7C605  bl 0x82d55758
	ctx.lr = 0x830D9158;
	sub_82D55758(ctx, base);
	// 830D9158: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D915C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830D9160: 419A0028  beq cr6, 0x830d9188
	if ctx.cr[6].eq {
	pc = 0x830D9188; continue 'dispatch;
	}
	// 830D9164: 4BC7C5ED  bl 0x82d55750
	ctx.lr = 0x830D9168;
	sub_82D55750(ctx, base);
	// 830D9168: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830D916C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830D9170: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9174: 4BC85B85  bl 0x82d5ecf8
	ctx.lr = 0x830D9178;
	sub_82D5ECF8(ctx, base);
	// 830D9178: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 830D917C: 419AFFD4  beq cr6, 0x830d9150
	if ctx.cr[6].eq {
	pc = 0x830D9150; continue 'dispatch;
	}
	// 830D9180: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830D9184: 4BBD02CC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9188 => {
    //   block [0x830D9188..0x830D91C0)
	// 830D9188: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830D918C: 386B7634  addi r3, r11, 0x7634
	ctx.r[3].s64 = ctx.r[11].s64 + 30260;
	// 830D9190: 4BC7C5C1  bl 0x82d55750
	ctx.lr = 0x830D9194;
	sub_82D55750(ctx, base);
	// 830D9194: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D9198: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D919C: 4BC7C5B5  bl 0x82d55750
	ctx.lr = 0x830D91A0;
	sub_82D55750(ctx, base);
	// 830D91A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830D91A4: 4BC7F835  bl 0x82d589d8
	ctx.lr = 0x830D91A8;
	sub_82D589D8(ctx, base);
	// 830D91A8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D91AC: 3FE08330  lis r31, -0x7cd0
	ctx.r[31].s64 = -2094006272;
	// 830D91B0: 409A0010  bne cr6, 0x830d91c0
	if !ctx.cr[6].eq {
	pc = 0x830D91C0; continue 'dispatch;
	}
	// 830D91B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830D91B8: 809F1E0C  lwz r4, 0x1e0c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7692 as u32) ) } as u64;
	// 830D91BC: 4BFFFE95  bl 0x830d9050
	ctx.lr = 0x830D91C0;
	sub_830D9050(ctx, base);
	pc = 0x830D91C0; continue 'dispatch;
            }
            0x830D91C0 => {
    //   block [0x830D91C0..0x830D91F4)
	// 830D91C0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830D91C4: 386B7694  addi r3, r11, 0x7694
	ctx.r[3].s64 = ctx.r[11].s64 + 30356;
	// 830D91C8: 4BC7C589  bl 0x82d55750
	ctx.lr = 0x830D91CC;
	sub_82D55750(ctx, base);
	// 830D91CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830D91D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D91D4: 4BC7C57D  bl 0x82d55750
	ctx.lr = 0x830D91D8;
	sub_82D55750(ctx, base);
	// 830D91D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D91DC: 4BC7F7FD  bl 0x82d589d8
	ctx.lr = 0x830D91E0;
	sub_82D589D8(ctx, base);
	// 830D91E0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D91E4: 409A0010  bne cr6, 0x830d91f4
	if !ctx.cr[6].eq {
	pc = 0x830D91F4; continue 'dispatch;
	}
	// 830D91E8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830D91EC: 809F1E0C  lwz r4, 0x1e0c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7692 as u32) ) } as u64;
	// 830D91F0: 4BFFFE61  bl 0x830d9050
	ctx.lr = 0x830D91F4;
	sub_830D9050(ctx, base);
	pc = 0x830D91F4; continue 'dispatch;
            }
            0x830D91F4 => {
    //   block [0x830D91F4..0x830D9230)
	// 830D91F4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830D91F8: 386B76C4  addi r3, r11, 0x76c4
	ctx.r[3].s64 = ctx.r[11].s64 + 30404;
	// 830D91FC: 4BC7C555  bl 0x82d55750
	ctx.lr = 0x830D9200;
	sub_82D55750(ctx, base);
	// 830D9200: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830D9204: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D9208: 4BC7C549  bl 0x82d55750
	ctx.lr = 0x830D920C;
	sub_82D55750(ctx, base);
	// 830D920C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D9210: 4BC7F7C9  bl 0x82d589d8
	ctx.lr = 0x830D9214;
	sub_82D589D8(ctx, base);
	// 830D9214: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D9218: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830D921C: 409A0014  bne cr6, 0x830d9230
	if !ctx.cr[6].eq {
	pc = 0x830D9230; continue 'dispatch;
	}
	// 830D9220: 809F1E0C  lwz r4, 0x1e0c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(7692 as u32) ) } as u64;
	// 830D9224: 4BFFFE2D  bl 0x830d9050
	ctx.lr = 0x830D9228;
	sub_830D9050(ctx, base);
	// 830D9228: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830D922C: 4BBD0224  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9230 => {
    //   block [0x830D9230..0x830D9238)
	// 830D9230: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830D9234: 4BFFFE1D  bl 0x830d9050
	ctx.lr = 0x830D9238;
	sub_830D9050(ctx, base);
	pc = 0x830D9238; continue 'dispatch;
            }
            0x830D9238 => {
    //   block [0x830D9238..0x830D9240)
	// 830D9238: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830D923C: 4BBD0214  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D9240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D9240 size=240
    let mut pc: u32 = 0x830D9240;
    'dispatch: loop {
        match pc {
            0x830D9240 => {
    //   block [0x830D9240..0x830D92A8)
	// 830D9240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D9244: 4BBD01C9  bl 0x82ca940c
	ctx.lr = 0x830D9248;
	sub_82CA93D0(ctx, base);
	// 830D9248: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D924C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 830D9250: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 830D9254: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830D9258: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 830D925C: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	// 830D9260: 7CE53B78  mr r5, r7
	ctx.r[5].u64 = ctx.r[7].u64;
	// 830D9264: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830D9268: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830D926C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 830D9270: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 830D9274: 4BFFFE85  bl 0x830d90f8
	ctx.lr = 0x830D9278;
	sub_830D90F8(ctx, base);
	// 830D9278: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830D927C: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 830D9280: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 830D9284: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 830D9288: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D928C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D9290: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D9294: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D9298: 409A0010  bne cr6, 0x830d92a8
	if !ctx.cr[6].eq {
	pc = 0x830D92A8; continue 'dispatch;
	}
	// 830D929C: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 830D92A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D92A4: 4BC7DCF5  bl 0x82d56f98
	ctx.lr = 0x830D92A8;
	sub_82D56F98(ctx, base);
	pc = 0x830D92A8; continue 'dispatch;
            }
            0x830D92A8 => {
    //   block [0x830D92A8..0x830D92CC)
	// 830D92A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D92AC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830D92B0: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D92B4: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 830D92B8: 5567083C  slwi r7, r11, 1
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 830D92BC: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 830D92C0: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D92C4: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830D92C8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x830D92CC; continue 'dispatch;
            }
            0x830D92CC => {
    //   block [0x830D92CC..0x830D9330)
	// 830D92CC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D92D0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830D92D4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830D92D8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830D92DC: 4200FFF0  bdnz 0x830d92cc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x830D92CC; continue 'dispatch;
	}
	// 830D92E0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830D92E4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D92E8: 396B7634  addi r11, r11, 0x7634
	ctx.r[11].s64 = ctx.r[11].s64 + 30260;
	// 830D92EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830D92F0: 7D3D5850  subf r9, r29, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 830D92F4: 7D7D5850  subf r11, r29, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 830D92F8: 7D290034  cntlzw r9, r9
	ctx.r[9].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 830D92FC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830D9300: 5527DFFE  rlwinm r7, r9, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 830D9304: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830D9308: 5569DFFE  rlwinm r9, r11, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830D930C: 811E008C  lwz r8, 0x8c(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 830D9310: 815E0088  lwz r10, 0x88(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 830D9314: 68EB0001  xori r11, r7, 1
	ctx.r[11].u64 = ctx.r[7].u64 ^ 1;
	// 830D9318: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 830D931C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830D9320: 913E008C  stw r9, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[9].u32 ) };
	// 830D9324: 917E0088  stw r11, 0x88(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 830D9328: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830D932C: 4BBD0130  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D9330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D9330 size=104
    let mut pc: u32 = 0x830D9330;
    'dispatch: loop {
        match pc {
            0x830D9330 => {
    //   block [0x830D9330..0x830D9398)
	// 830D9330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D9334: 4BBD00D9  bl 0x82ca940c
	ctx.lr = 0x830D9338;
	sub_82CA93D0(ctx, base);
	// 830D9338: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D933C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D9340: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D9344: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830D9348: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830D934C: 4BC9830D  bl 0x82d71658
	ctx.lr = 0x830D9350;
	sub_82D71658(ctx, base);
	// 830D9350: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830D9354: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830D9358: 4BFFB131  bl 0x830d4488
	ctx.lr = 0x830D935C;
	sub_830D4488(ctx, base);
	// 830D935C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830D9360: 4813D6C9  bl 0x83216a28
	ctx.lr = 0x830D9364;
	sub_83216A28(ctx, base);
	// 830D9364: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830D9368: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830D936C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830D9370: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830D9374: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830D9378: 4BFFB301  bl 0x830d4678
	ctx.lr = 0x830D937C;
	sub_830D4678(ctx, base);
	// 830D937C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D9380: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830D9384: 396B39E0  addi r11, r11, 0x39e0
	ctx.r[11].s64 = ctx.r[11].s64 + 14816;
	// 830D9388: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 830D938C: 4BFFB25D  bl 0x830d45e8
	ctx.lr = 0x830D9390;
	sub_830D45E8(ctx, base);
	// 830D9390: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830D9394: 4BBD00C8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D9398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830D9398 size=4
    let mut pc: u32 = 0x830D9398;
    'dispatch: loop {
        match pc {
            0x830D9398 => {
    //   block [0x830D9398..0x830D939C)
	// 830D9398: 4BFFFCB8  b 0x830d9050
	sub_830D9050(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D93A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D93A0 size=76
    let mut pc: u32 = 0x830D93A0;
    'dispatch: loop {
        match pc {
            0x830D93A0 => {
    //   block [0x830D93A0..0x830D93EC)
	// 830D93A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D93A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830D93A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830D93AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830D93B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D93B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830D93B8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 830D93BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D93C0: 4BFFFC91  bl 0x830d9050
	ctx.lr = 0x830D93C4;
	sub_830D9050(ctx, base);
	// 830D93C4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830D93C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D93CC: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 830D93D0: 4B18C831  bl 0x82265c00
	ctx.lr = 0x830D93D4;
	sub_82265C00(ctx, base);
	// 830D93D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830D93D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830D93DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830D93E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830D93E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830D93E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D93F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D93F0 size=64
    let mut pc: u32 = 0x830D93F0;
    'dispatch: loop {
        match pc {
            0x830D93F0 => {
    //   block [0x830D93F0..0x830D9430)
	// 830D93F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D93F4: 4BBD0019  bl 0x82ca940c
	ctx.lr = 0x830D93F8;
	sub_82CA93D0(ctx, base);
	// 830D93F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D93FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830D9400: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 830D9404: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D9408: 4BFFFC49  bl 0x830d9050
	ctx.lr = 0x830D940C;
	sub_830D9050(ctx, base);
	// 830D940C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830D9410: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9414: 4BC7C33D  bl 0x82d55750
	ctx.lr = 0x830D9418;
	sub_82D55750(ctx, base);
	// 830D9418: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830D941C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830D9420: 387F009C  addi r3, r31, 0x9c
	ctx.r[3].s64 = ctx.r[31].s64 + 156;
	// 830D9424: 4BC85635  bl 0x82d5ea58
	ctx.lr = 0x830D9428;
	sub_82D5EA58(ctx, base);
	// 830D9428: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830D942C: 4BBD0030  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D9430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D9430 size=656
    let mut pc: u32 = 0x830D9430;
    'dispatch: loop {
        match pc {
            0x830D9430 => {
    //   block [0x830D9430..0x830D9478)
	// 830D9430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D9434: 4BBCFFC5  bl 0x82ca93f8
	ctx.lr = 0x830D9438;
	sub_82CA93D0(ctx, base);
	// 830D9438: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D943C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830D9440: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830D9444: 3B9D0014  addi r28, r29, 0x14
	ctx.r[28].s64 = ctx.r[29].s64 + 20;
	// 830D9448: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830D944C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D9450: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 830D9454: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 830D9458: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 830D945C: 4BC871D5  bl 0x82d60630
	ctx.lr = 0x830D9460;
	sub_82D60630(ctx, base);
	// 830D9460: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D9464: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830D9468: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D946C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830D9470: 40990008  ble cr6, 0x830d9478
	if !ctx.cr[6].gt {
	pc = 0x830D9478; continue 'dispatch;
	}
	// 830D9474: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x830D9478; continue 'dispatch;
            }
            0x830D9478 => {
    //   block [0x830D9478..0x830D94D0)
	// 830D9478: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830D947C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D9480: 409A0238  bne cr6, 0x830d96b8
	if !ctx.cr[6].eq {
	pc = 0x830D96B8; continue 'dispatch;
	}
	// 830D9484: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 830D9488: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830D948C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9490: 4BFFF681  bl 0x830d8b10
	ctx.lr = 0x830D9494;
	sub_830D8B10(ctx, base);
	// 830D9494: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830D9498: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D949C: 419A01C4  beq cr6, 0x830d9660
	if ctx.cr[6].eq {
	pc = 0x830D9660; continue 'dispatch;
	}
	// 830D94A0: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 830D94A4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 830D94A8: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 830D94AC: 419A0024  beq cr6, 0x830d94d0
	if ctx.cr[6].eq {
	pc = 0x830D94D0; continue 'dispatch;
	}
	// 830D94B0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D94B4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830D94B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830D94BC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830D94C0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D94C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D94C8: 4E800421  bctrl
	ctx.lr = 0x830D94CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D94CC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
            }
            0x830D94D0 => {
    //   block [0x830D94D0..0x830D9514)
	// 830D94D0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830D94D4: 419A0174  beq cr6, 0x830d9648
	if ctx.cr[6].eq {
	pc = 0x830D9648; continue 'dispatch;
	}
	// 830D94D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D94DC: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D94E0: 4BFFF7A1  bl 0x830d8c80
	ctx.lr = 0x830D94E4;
	sub_830D8C80(ctx, base);
	// 830D94E4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D94E8: 419A01D0  beq cr6, 0x830d96b8
	if ctx.cr[6].eq {
	pc = 0x830D96B8; continue 'dispatch;
	}
	// 830D94EC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D94F0: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830D94F4: 419A002C  beq cr6, 0x830d9520
	if ctx.cr[6].eq {
	pc = 0x830D9520; continue 'dispatch;
	}
	// 830D94F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D94FC: 4BC87135  bl 0x82d60630
	ctx.lr = 0x830D9500;
	sub_82D60630(ctx, base);
	// 830D9500: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D9504: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D9508: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830D950C: 40990008  ble cr6, 0x830d9514
	if !ctx.cr[6].gt {
	pc = 0x830D9514; continue 'dispatch;
	}
	// 830D9510: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x830D9514; continue 'dispatch;
            }
            0x830D9514 => {
    //   block [0x830D9514..0x830D9520)
	// 830D9514: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830D9518: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D951C: 409A019C  bne cr6, 0x830d96b8
	if !ctx.cr[6].eq {
	pc = 0x830D96B8; continue 'dispatch;
	}
	pc = 0x830D9520; continue 'dispatch;
            }
            0x830D9520 => {
    //   block [0x830D9520..0x830D955C)
	// 830D9520: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D9524: 80BD000C  lwz r5, 0xc(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D9528: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D952C: 4B18C6D5  bl 0x82265c00
	ctx.lr = 0x830D9530;
	sub_82265C00(ctx, base);
	// 830D9530: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D9534: 7F04F040  cmplw cr6, r4, r30
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830D9538: 419A0024  beq cr6, 0x830d955c
	if ctx.cr[6].eq {
	pc = 0x830D955C; continue 'dispatch;
	}
	// 830D953C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D9540: 80BD000C  lwz r5, 0xc(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D9544: 4B18C6BD  bl 0x82265c00
	ctx.lr = 0x830D9548;
	sub_82265C00(ctx, base);
	// 830D9548: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830D954C: 387D0050  addi r3, r29, 0x50
	ctx.r[3].s64 = ctx.r[29].s64 + 80;
	// 830D9550: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D9554: 4B18C6AD  bl 0x82265c00
	ctx.lr = 0x830D9558;
	sub_82265C00(ctx, base);
	// 830D9558: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x830D955C; continue 'dispatch;
            }
            0x830D955C => {
    //   block [0x830D955C..0x830D95CC)
	// 830D955C: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 830D9560: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D9564: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 830D9568: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830D956C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D9570: 4BFFFCD1  bl 0x830d9240
	ctx.lr = 0x830D9574;
	sub_830D9240(ctx, base);
	// 830D9574: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 830D9578: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830D957C: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D9580: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830D9584: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 830D9588: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 830D958C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 830D9590: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 830D9594: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 830D9598: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830D959C: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 830D95A0: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 830D95A4: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 830D95A8: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 830D95AC: 93E10088  stw r31, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	// 830D95B0: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 830D95B4: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 830D95B8: 4BFFFD79  bl 0x830d9330
	ctx.lr = 0x830D95BC;
	sub_830D9330(ctx, base);
	// 830D95BC: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830D95C0: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 830D95C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830D95C8: 4099004C  ble cr6, 0x830d9614
	if !ctx.cr[6].gt {
	pc = 0x830D9614; continue 'dispatch;
	}
	pc = 0x830D95CC; continue 'dispatch;
            }
            0x830D95CC => {
    //   block [0x830D95CC..0x830D9600)
	// 830D95CC: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830D95D0: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830D95D4: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D95D8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D95DC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 830D95E0: 419A0020  beq cr6, 0x830d9600
	if ctx.cr[6].eq {
	pc = 0x830D9600; continue 'dispatch;
	}
	// 830D95E4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830D95E8: 419A0018  beq cr6, 0x830d9600
	if ctx.cr[6].eq {
	pc = 0x830D9600; continue 'dispatch;
	}
	// 830D95EC: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 830D95F0: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 830D95F4: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 830D95F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D95FC: 4BFFFE35  bl 0x830d9430
	ctx.lr = 0x830D9600;
	sub_830D9430(ctx, base);
	pc = 0x830D9600; continue 'dispatch;
            }
            0x830D9600 => {
    //   block [0x830D9600..0x830D9614)
	// 830D9600: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830D9604: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830D9608: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 830D960C: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D9610: 4198FFBC  blt cr6, 0x830d95cc
	if ctx.cr[6].lt {
	pc = 0x830D95CC; continue 'dispatch;
	}
	pc = 0x830D9614; continue 'dispatch;
            }
            0x830D9614 => {
    //   block [0x830D9614..0x830D9648)
	// 830D9614: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830D9618: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830D961C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 830D9620: 38AB7634  addi r5, r11, 0x7634
	ctx.r[5].s64 = ctx.r[11].s64 + 30260;
	// 830D9624: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830D9628: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 830D962C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D9630: 810B1E0C  lwz r8, 0x1e0c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7692 as u32) ) } as u64;
	// 830D9634: 4BFFFDFD  bl 0x830d9430
	ctx.lr = 0x830D9638;
	sub_830D9430(ctx, base);
	// 830D9638: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830D963C: 4BC9BFED  bl 0x82d75628
	ctx.lr = 0x830D9640;
	sub_82D75628(ctx, base);
	// 830D9640: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830D9644: 4BBCFE04  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9648 => {
    //   block [0x830D9648..0x830D9660)
	// 830D9648: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 830D964C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D9650: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D9654: 4B18C5AD  bl 0x82265c00
	ctx.lr = 0x830D9658;
	sub_82265C00(ctx, base);
	// 830D9658: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830D965C: 4BBCFDEC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9660 => {
    //   block [0x830D9660..0x830D9698)
	// 830D9660: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 830D9664: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D9668: 4B18C599  bl 0x82265c00
	ctx.lr = 0x830D966C;
	sub_82265C00(ctx, base);
	// 830D966C: 3BFD0074  addi r31, r29, 0x74
	ctx.r[31].s64 = ctx.r[29].s64 + 116;
	// 830D9670: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 830D9674: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 830D9678: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830D967C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D9680: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830D9684: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830D9688: 409A0010  bne cr6, 0x830d9698
	if !ctx.cr[6].eq {
	pc = 0x830D9698; continue 'dispatch;
	}
	// 830D968C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 830D9690: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830D9694: 4BC7D905  bl 0x82d56f98
	ctx.lr = 0x830D9698;
	sub_82D56F98(ctx, base);
	pc = 0x830D9698; continue 'dispatch;
            }
            0x830D9698 => {
    //   block [0x830D9698..0x830D96B8)
	// 830D9698: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D969C: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830D96A0: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D96A4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D96A8: 7D4B492A  stdx r10, r11, r9
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u64) };
	// 830D96AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830D96B0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D96B4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x830D96B8; continue 'dispatch;
            }
            0x830D96B8 => {
    //   block [0x830D96B8..0x830D96C0)
	// 830D96B8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830D96BC: 4BBCFD8C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D96C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D96C0 size=96
    let mut pc: u32 = 0x830D96C0;
    'dispatch: loop {
        match pc {
            0x830D96C0 => {
    //   block [0x830D96C0..0x830D9720)
	// 830D96C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D96C4: 4BBCFD41  bl 0x82ca9404
	ctx.lr = 0x830D96C8;
	sub_82CA93D0(ctx, base);
	// 830D96C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D96CC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830D96D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830D96D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830D96D8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830D96DC: 810B1E08  lwz r8, 0x1e08(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7688 as u32) ) } as u64;
	// 830D96E0: 4BFFFD51  bl 0x830d9430
	ctx.lr = 0x830D96E4;
	sub_830D9430(ctx, base);
	// 830D96E4: 3B9F0014  addi r28, r31, 0x14
	ctx.r[28].s64 = ctx.r[31].s64 + 20;
	// 830D96E8: 3B60FFFF  li r27, -1
	ctx.r[27].s64 = -1;
	// 830D96EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D96F0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830D96F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D96F8: 4BC86F91  bl 0x82d60688
	ctx.lr = 0x830D96FC;
	sub_82D60688(ctx, base);
	// 830D96FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830D9700: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830D9704: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830D9708: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D970C: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 830D9710: 4BC86F79  bl 0x82d60688
	ctx.lr = 0x830D9714;
	sub_82D60688(ctx, base);
	// 830D9714: 907F0084  stw r3, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 830D9718: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830D971C: 4BBCFD38  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D9720(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D9720 size=44
    let mut pc: u32 = 0x830D9720;
    'dispatch: loop {
        match pc {
            0x830D9720 => {
    //   block [0x830D9720..0x830D973C)
	// 830D9720: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D9724: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830D9728: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D972C: 4BC83645  bl 0x82d5cd70
	ctx.lr = 0x830D9730;
	sub_82D5CD70(ctx, base);
	// 830D9730: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830D9734: 409A0008  bne cr6, 0x830d973c
	if !ctx.cr[6].eq {
	pc = 0x830D973C; continue 'dispatch;
	}
	// 830D9738: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x830D973C; continue 'dispatch;
            }
            0x830D973C => {
    //   block [0x830D973C..0x830D974C)
	// 830D973C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830D9740: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830D9744: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830D9748: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D9750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D9750 size=948
    let mut pc: u32 = 0x830D9750;
    'dispatch: loop {
        match pc {
            0x830D9750 => {
    //   block [0x830D9750..0x830D999C)
	// 830D9750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D9754: 4BBCFCA5  bl 0x82ca93f8
	ctx.lr = 0x830D9758;
	sub_82CA93D0(ctx, base);
	// 830D9758: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D975C: 39600041  li r11, 0x41
	ctx.r[11].s64 = 65;
	// 830D9760: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830D9764: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830D9768: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830D976C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830D9770: 99610070  stb r11, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u8 ) };
	// 830D9774: 39600042  li r11, 0x42
	ctx.r[11].s64 = 66;
	// 830D9778: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830D977C: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 830D9780: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830D9784: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830D9788: 99610071  stb r11, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[11].u8 ) };
	// 830D978C: 39600043  li r11, 0x43
	ctx.r[11].s64 = 67;
	// 830D9790: 99610072  stb r11, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[11].u8 ) };
	// 830D9794: 39600044  li r11, 0x44
	ctx.r[11].s64 = 68;
	// 830D9798: 99610073  stb r11, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[11].u8 ) };
	// 830D979C: 39600045  li r11, 0x45
	ctx.r[11].s64 = 69;
	// 830D97A0: 99610074  stb r11, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	// 830D97A4: 39600046  li r11, 0x46
	ctx.r[11].s64 = 70;
	// 830D97A8: 99610075  stb r11, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[11].u8 ) };
	// 830D97AC: 39600047  li r11, 0x47
	ctx.r[11].s64 = 71;
	// 830D97B0: 99610076  stb r11, 0x76(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(118 as u32), ctx.r[11].u8 ) };
	// 830D97B4: 39600048  li r11, 0x48
	ctx.r[11].s64 = 72;
	// 830D97B8: 99610077  stb r11, 0x77(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(119 as u32), ctx.r[11].u8 ) };
	// 830D97BC: 39600049  li r11, 0x49
	ctx.r[11].s64 = 73;
	// 830D97C0: 99610078  stb r11, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u8 ) };
	// 830D97C4: 3960004A  li r11, 0x4a
	ctx.r[11].s64 = 74;
	// 830D97C8: 99610079  stb r11, 0x79(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(121 as u32), ctx.r[11].u8 ) };
	// 830D97CC: 3960004B  li r11, 0x4b
	ctx.r[11].s64 = 75;
	// 830D97D0: 9961007A  stb r11, 0x7a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(122 as u32), ctx.r[11].u8 ) };
	// 830D97D4: 3960004C  li r11, 0x4c
	ctx.r[11].s64 = 76;
	// 830D97D8: 9961007B  stb r11, 0x7b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(123 as u32), ctx.r[11].u8 ) };
	// 830D97DC: 3960004D  li r11, 0x4d
	ctx.r[11].s64 = 77;
	// 830D97E0: 9961007C  stb r11, 0x7c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u8 ) };
	// 830D97E4: 3960004E  li r11, 0x4e
	ctx.r[11].s64 = 78;
	// 830D97E8: 9961007D  stb r11, 0x7d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(125 as u32), ctx.r[11].u8 ) };
	// 830D97EC: 3960004F  li r11, 0x4f
	ctx.r[11].s64 = 79;
	// 830D97F0: 9961007E  stb r11, 0x7e(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(126 as u32), ctx.r[11].u8 ) };
	// 830D97F4: 39600050  li r11, 0x50
	ctx.r[11].s64 = 80;
	// 830D97F8: 9961007F  stb r11, 0x7f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(127 as u32), ctx.r[11].u8 ) };
	// 830D97FC: 39600051  li r11, 0x51
	ctx.r[11].s64 = 81;
	// 830D9800: 99610080  stb r11, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u8 ) };
	// 830D9804: 39600052  li r11, 0x52
	ctx.r[11].s64 = 82;
	// 830D9808: 99610081  stb r11, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[11].u8 ) };
	// 830D980C: 39600053  li r11, 0x53
	ctx.r[11].s64 = 83;
	// 830D9810: 99610082  stb r11, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[11].u8 ) };
	// 830D9814: 39600054  li r11, 0x54
	ctx.r[11].s64 = 84;
	// 830D9818: 99610083  stb r11, 0x83(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(131 as u32), ctx.r[11].u8 ) };
	// 830D981C: 39600055  li r11, 0x55
	ctx.r[11].s64 = 85;
	// 830D9820: 99610084  stb r11, 0x84(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u8 ) };
	// 830D9824: 39600056  li r11, 0x56
	ctx.r[11].s64 = 86;
	// 830D9828: 99610085  stb r11, 0x85(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(133 as u32), ctx.r[11].u8 ) };
	// 830D982C: 39600057  li r11, 0x57
	ctx.r[11].s64 = 87;
	// 830D9830: 99610086  stb r11, 0x86(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(134 as u32), ctx.r[11].u8 ) };
	// 830D9834: 39600058  li r11, 0x58
	ctx.r[11].s64 = 88;
	// 830D9838: 99610087  stb r11, 0x87(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(135 as u32), ctx.r[11].u8 ) };
	// 830D983C: 39600059  li r11, 0x59
	ctx.r[11].s64 = 89;
	// 830D9840: 99610088  stb r11, 0x88(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u8 ) };
	// 830D9844: 3960005A  li r11, 0x5a
	ctx.r[11].s64 = 90;
	// 830D9848: 99610089  stb r11, 0x89(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(137 as u32), ctx.r[11].u8 ) };
	// 830D984C: 39600061  li r11, 0x61
	ctx.r[11].s64 = 97;
	// 830D9850: 9961008A  stb r11, 0x8a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(138 as u32), ctx.r[11].u8 ) };
	// 830D9854: 39600062  li r11, 0x62
	ctx.r[11].s64 = 98;
	// 830D9858: 9961008B  stb r11, 0x8b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(139 as u32), ctx.r[11].u8 ) };
	// 830D985C: 39600063  li r11, 0x63
	ctx.r[11].s64 = 99;
	// 830D9860: 9961008C  stb r11, 0x8c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u8 ) };
	// 830D9864: 39600064  li r11, 0x64
	ctx.r[11].s64 = 100;
	// 830D9868: 9961008D  stb r11, 0x8d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(141 as u32), ctx.r[11].u8 ) };
	// 830D986C: 39600065  li r11, 0x65
	ctx.r[11].s64 = 101;
	// 830D9870: 9961008E  stb r11, 0x8e(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(142 as u32), ctx.r[11].u8 ) };
	// 830D9874: 39600066  li r11, 0x66
	ctx.r[11].s64 = 102;
	// 830D9878: 9961008F  stb r11, 0x8f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(143 as u32), ctx.r[11].u8 ) };
	// 830D987C: 39600067  li r11, 0x67
	ctx.r[11].s64 = 103;
	// 830D9880: 99610090  stb r11, 0x90(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u8 ) };
	// 830D9884: 39600068  li r11, 0x68
	ctx.r[11].s64 = 104;
	// 830D9888: 99610091  stb r11, 0x91(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(145 as u32), ctx.r[11].u8 ) };
	// 830D988C: 39600069  li r11, 0x69
	ctx.r[11].s64 = 105;
	// 830D9890: 99610092  stb r11, 0x92(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(146 as u32), ctx.r[11].u8 ) };
	// 830D9894: 3960006A  li r11, 0x6a
	ctx.r[11].s64 = 106;
	// 830D9898: 99610093  stb r11, 0x93(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(147 as u32), ctx.r[11].u8 ) };
	// 830D989C: 3960006B  li r11, 0x6b
	ctx.r[11].s64 = 107;
	// 830D98A0: 99610094  stb r11, 0x94(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u8 ) };
	// 830D98A4: 3960006C  li r11, 0x6c
	ctx.r[11].s64 = 108;
	// 830D98A8: 88AA0000  lbz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D98AC: 99610095  stb r11, 0x95(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(149 as u32), ctx.r[11].u8 ) };
	// 830D98B0: 3960006D  li r11, 0x6d
	ctx.r[11].s64 = 109;
	// 830D98B4: 99610096  stb r11, 0x96(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(150 as u32), ctx.r[11].u8 ) };
	// 830D98B8: 3960006E  li r11, 0x6e
	ctx.r[11].s64 = 110;
	// 830D98BC: 99610097  stb r11, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[11].u8 ) };
	// 830D98C0: 3960006F  li r11, 0x6f
	ctx.r[11].s64 = 111;
	// 830D98C4: 99610098  stb r11, 0x98(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u8 ) };
	// 830D98C8: 39600070  li r11, 0x70
	ctx.r[11].s64 = 112;
	// 830D98CC: 99610099  stb r11, 0x99(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(153 as u32), ctx.r[11].u8 ) };
	// 830D98D0: 39600071  li r11, 0x71
	ctx.r[11].s64 = 113;
	// 830D98D4: 9961009A  stb r11, 0x9a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(154 as u32), ctx.r[11].u8 ) };
	// 830D98D8: 39600072  li r11, 0x72
	ctx.r[11].s64 = 114;
	// 830D98DC: 9961009B  stb r11, 0x9b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(155 as u32), ctx.r[11].u8 ) };
	// 830D98E0: 39600073  li r11, 0x73
	ctx.r[11].s64 = 115;
	// 830D98E4: 9961009C  stb r11, 0x9c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u8 ) };
	// 830D98E8: 39600074  li r11, 0x74
	ctx.r[11].s64 = 116;
	// 830D98EC: 9961009D  stb r11, 0x9d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(157 as u32), ctx.r[11].u8 ) };
	// 830D98F0: 39600075  li r11, 0x75
	ctx.r[11].s64 = 117;
	// 830D98F4: 9961009E  stb r11, 0x9e(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(158 as u32), ctx.r[11].u8 ) };
	// 830D98F8: 39600076  li r11, 0x76
	ctx.r[11].s64 = 118;
	// 830D98FC: 9961009F  stb r11, 0x9f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(159 as u32), ctx.r[11].u8 ) };
	// 830D9900: 39600077  li r11, 0x77
	ctx.r[11].s64 = 119;
	// 830D9904: 996100A0  stb r11, 0xa0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u8 ) };
	// 830D9908: 39600078  li r11, 0x78
	ctx.r[11].s64 = 120;
	// 830D990C: 996100A1  stb r11, 0xa1(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(161 as u32), ctx.r[11].u8 ) };
	// 830D9910: 39600079  li r11, 0x79
	ctx.r[11].s64 = 121;
	// 830D9914: 996100A2  stb r11, 0xa2(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(162 as u32), ctx.r[11].u8 ) };
	// 830D9918: 3960007A  li r11, 0x7a
	ctx.r[11].s64 = 122;
	// 830D991C: 996100A3  stb r11, 0xa3(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(163 as u32), ctx.r[11].u8 ) };
	// 830D9920: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	// 830D9924: 996100A4  stb r11, 0xa4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u8 ) };
	// 830D9928: 39600031  li r11, 0x31
	ctx.r[11].s64 = 49;
	// 830D992C: 996100A5  stb r11, 0xa5(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(165 as u32), ctx.r[11].u8 ) };
	// 830D9930: 39600032  li r11, 0x32
	ctx.r[11].s64 = 50;
	// 830D9934: 996100A6  stb r11, 0xa6(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(166 as u32), ctx.r[11].u8 ) };
	// 830D9938: 39600033  li r11, 0x33
	ctx.r[11].s64 = 51;
	// 830D993C: 996100A7  stb r11, 0xa7(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(167 as u32), ctx.r[11].u8 ) };
	// 830D9940: 39600034  li r11, 0x34
	ctx.r[11].s64 = 52;
	// 830D9944: 996100A8  stb r11, 0xa8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[11].u8 ) };
	// 830D9948: 39600035  li r11, 0x35
	ctx.r[11].s64 = 53;
	// 830D994C: 996100A9  stb r11, 0xa9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(169 as u32), ctx.r[11].u8 ) };
	// 830D9950: 39600036  li r11, 0x36
	ctx.r[11].s64 = 54;
	// 830D9954: 996100AA  stb r11, 0xaa(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(170 as u32), ctx.r[11].u8 ) };
	// 830D9958: 39600037  li r11, 0x37
	ctx.r[11].s64 = 55;
	// 830D995C: 996100AB  stb r11, 0xab(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(171 as u32), ctx.r[11].u8 ) };
	// 830D9960: 39600038  li r11, 0x38
	ctx.r[11].s64 = 56;
	// 830D9964: 996100AC  stb r11, 0xac(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[11].u8 ) };
	// 830D9968: 39600039  li r11, 0x39
	ctx.r[11].s64 = 57;
	// 830D996C: 996100AD  stb r11, 0xad(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(173 as u32), ctx.r[11].u8 ) };
	// 830D9970: 3960002B  li r11, 0x2b
	ctx.r[11].s64 = 43;
	// 830D9974: 996100AE  stb r11, 0xae(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(174 as u32), ctx.r[11].u8 ) };
	// 830D9978: 3960002F  li r11, 0x2f
	ctx.r[11].s64 = 47;
	// 830D997C: 996100AF  stb r11, 0xaf(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(175 as u32), ctx.r[11].u8 ) };
	// 830D9980: 4BC84591  bl 0x82d5df10
	ctx.lr = 0x830D9984;
	sub_82D5DF10(ctx, base);
	// 830D9984: 3B600013  li r27, 0x13
	ctx.r[27].s64 = 19;
	// 830D9988: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830D998C: 40990164  ble cr6, 0x830d9af0
	if !ctx.cr[6].gt {
	pc = 0x830D9AF0; continue 'dispatch;
	}
	// 830D9990: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830D9994: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830D9998: 3B2B0C88  addi r25, r11, 0xc88
	ctx.r[25].s64 = ctx.r[11].s64 + 3208;
	pc = 0x830D999C; continue 'dispatch;
            }
            0x830D999C => {
    //   block [0x830D999C..0x830D99BC)
	// 830D999C: 39610053  addi r11, r1, 0x53
	ctx.r[11].s64 = ctx.r[1].s64 + 83;
	// 830D99A0: 9B810052  stb r28, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[28].u8 ) };
	// 830D99A4: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 830D99A8: 3BE00003  li r31, 3
	ctx.r[31].s64 = 3;
	// 830D99AC: 9B8B0000  stb r28, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u8 ) };
	// 830D99B0: 9B8B0001  stb r28, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[28].u8 ) };
	// 830D99B4: 40980008  bge cr6, 0x830d99bc
	if !ctx.cr[6].lt {
	pc = 0x830D99BC; continue 'dispatch;
	}
	// 830D99B8: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	pc = 0x830D99BC; continue 'dispatch;
            }
            0x830D99BC => {
    //   block [0x830D99BC..0x830D9A68)
	// 830D99BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830D99C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830D99C4: 38610052  addi r3, r1, 0x52
	ctx.r[3].s64 = ctx.r[1].s64 + 82;
	// 830D99C8: 4BC7F369  bl 0x82d58d30
	ctx.lr = 0x830D99CC;
	sub_82D58D30(ctx, base);
	// 830D99CC: 89610052  lbz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 830D99D0: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 830D99D4: 89410053  lbz r10, 0x53(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(83 as u32) ) } as u64;
	// 830D99D8: 556426B6  rlwinm r4, r11, 4, 0x1a, 0x1b
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 830D99DC: 89210054  lbz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830D99E0: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D99E4: 5543E13E  srwi r3, r10, 4
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shr(4);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 830D99E8: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 830D99EC: 7C642378  or r4, r3, r4
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[4].u64;
	// 830D99F0: 5538D1BE  srwi r24, r9, 6
	ctx.r[24].u32 = ctx.r[9].u32.wrapping_shr(6);
	ctx.r[24].u64 = ctx.r[24].u32 as u64;
	// 830D99F4: 7D6B40AE  lbzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830D99F8: 554A16BA  rlwinm r10, r10, 2, 0x1a, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 830D99FC: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 830D9A00: 7F0A5378  or r10, r24, r10
	ctx.r[10].u64 = ctx.r[24].u64 | ctx.r[10].u64;
	// 830D9A04: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 830D9A08: 552906BE  clrlwi r9, r9, 0x1a
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000003Fu64;
	// 830D9A0C: 99610058  stb r11, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u8 ) };
	// 830D9A10: 7FBFEA14  add r29, r31, r29
	ctx.r[29].u64 = ctx.r[31].u64 + ctx.r[29].u64;
	// 830D9A14: 7D6438AE  lbzx r11, r4, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 830D9A18: 7FDFF050  subf r30, r31, r30
	ctx.r[30].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 830D9A1C: 2F1F0003  cmpwi cr6, r31, 3
	ctx.cr[6].compare_i32(ctx.r[31].s32, 3, &mut ctx.xer);
	// 830D9A20: 99610059  stb r11, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[11].u8 ) };
	// 830D9A24: 7D6A30AE  lbzx r11, r10, r6
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 830D9A28: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	// 830D9A2C: 7D6928AE  lbzx r11, r9, r5
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 830D9A30: 9961005B  stb r11, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[11].u8 ) };
	// 830D9A34: 41980088  blt cr6, 0x830d9abc
	if ctx.cr[6].lt {
	pc = 0x830D9ABC; continue 'dispatch;
	}
	// 830D9A38: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830D9A3C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830D9A40: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830D9A44: 4BC843C5  bl 0x82d5de08
	ctx.lr = 0x830D9A48;
	sub_82D5DE08(ctx, base);
	// 830D9A48: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 830D9A4C: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830D9A50: 409A0018  bne cr6, 0x830d9a68
	if !ctx.cr[6].eq {
	pc = 0x830D9A68; continue 'dispatch;
	}
	// 830D9A54: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830D9A58: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830D9A5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830D9A60: 4BC843A9  bl 0x82d5de08
	ctx.lr = 0x830D9A64;
	sub_82D5DE08(ctx, base);
	// 830D9A64: 3B600013  li r27, 0x13
	ctx.r[27].s64 = 19;
	pc = 0x830D9A68; continue 'dispatch;
            }
            0x830D9A68 => {
    //   block [0x830D9A68..0x830D9AA8)
	// 830D9A68: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D9A6C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830D9A70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830D9A74: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830D9A78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830D9A7C: 4E800421  bctrl
	ctx.lr = 0x830D9A80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830D9A80: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D9A84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D9A88: 419A0020  beq cr6, 0x830d9aa8
	if ctx.cr[6].eq {
	pc = 0x830D9AA8; continue 'dispatch;
	}
	// 830D9A8C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830D9A90: 4199FF0C  bgt cr6, 0x830d999c
	if ctx.cr[6].gt {
	pc = 0x830D999C; continue 'dispatch;
	}
	// 830D9A94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830D9A98: 4BC84621  bl 0x82d5e0b8
	ctx.lr = 0x830D9A9C;
	sub_82D5E0B8(ctx, base);
	// 830D9A9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830D9AA0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 830D9AA4: 4BBCF9A4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9AA8 => {
    //   block [0x830D9AA8..0x830D9ABC)
	// 830D9AA8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830D9AAC: 4BC8460D  bl 0x82d5e0b8
	ctx.lr = 0x830D9AB0;
	sub_82D5E0B8(ctx, base);
	// 830D9AB0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830D9AB4: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 830D9AB8: 4BBCF990  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9ABC => {
    //   block [0x830D9ABC..0x830D9AD4)
	// 830D9ABC: 2F1F0001  cmpwi cr6, r31, 1
	ctx.cr[6].compare_i32(ctx.r[31].s32, 1, &mut ctx.xer);
	// 830D9AC0: 419A0014  beq cr6, 0x830d9ad4
	if ctx.cr[6].eq {
	pc = 0x830D9AD4; continue 'dispatch;
	}
	// 830D9AC4: 2F1F0002  cmpwi cr6, r31, 2
	ctx.cr[6].compare_i32(ctx.r[31].s32, 2, &mut ctx.xer);
	// 830D9AC8: 409A0028  bne cr6, 0x830d9af0
	if !ctx.cr[6].eq {
	pc = 0x830D9AF0; continue 'dispatch;
	}
	// 830D9ACC: 3960003D  li r11, 0x3d
	ctx.r[11].s64 = 61;
	// 830D9AD0: 4800000C  b 0x830d9adc
	pc = 0x830D9ADC; continue 'dispatch;
            }
            0x830D9AD4 => {
    //   block [0x830D9AD4..0x830D9ADC)
	// 830D9AD4: 3960003D  li r11, 0x3d
	ctx.r[11].s64 = 61;
	// 830D9AD8: 9961005A  stb r11, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u8 ) };
	pc = 0x830D9ADC; continue 'dispatch;
            }
            0x830D9ADC => {
    //   block [0x830D9ADC..0x830D9AF0)
	// 830D9ADC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830D9AE0: 9961005B  stb r11, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[11].u8 ) };
	// 830D9AE4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830D9AE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830D9AEC: 4BC8431D  bl 0x82d5de08
	ctx.lr = 0x830D9AF0;
	sub_82D5DE08(ctx, base);
	pc = 0x830D9AF0; continue 'dispatch;
            }
            0x830D9AF0 => {
    //   block [0x830D9AF0..0x830D9B04)
	// 830D9AF0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830D9AF4: 4BC845C5  bl 0x82d5e0b8
	ctx.lr = 0x830D9AF8;
	sub_82D5E0B8(ctx, base);
	// 830D9AF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830D9AFC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 830D9B00: 4BBCF948  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D9B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830D9B08 size=552
    let mut pc: u32 = 0x830D9B08;
    'dispatch: loop {
        match pc {
            0x830D9B08 => {
    //   block [0x830D9B08..0x830D9B64)
	// 830D9B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D9B0C: 4BBCF8D5  bl 0x82ca93e0
	ctx.lr = 0x830D9B10;
	sub_82CA93D0(ctx, base);
	// 830D9B10: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D9B14: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830D9B18: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830D9B1C: 40990208  ble cr6, 0x830d9d24
	if !ctx.cr[6].gt {
	pc = 0x830D9D24; continue 'dispatch;
	}
	// 830D9B20: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D9B24: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 830D9B28: 3A8B9DE4  addi r20, r11, -0x621c
	ctx.r[20].s64 = ctx.r[11].s64 + -25116;
	// 830D9B2C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D9B30: 7C922378  mr r18, r4
	ctx.r[18].u64 = ctx.r[4].u64;
	// 830D9B34: 3B4B9DDC  addi r26, r11, -0x6224
	ctx.r[26].s64 = ctx.r[11].s64 + -25124;
	// 830D9B38: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D9B3C: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 830D9B40: 3B2B9DD4  addi r25, r11, -0x622c
	ctx.r[25].s64 = ctx.r[11].s64 + -25132;
	// 830D9B44: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D9B48: 3B0B9DCC  addi r24, r11, -0x6234
	ctx.r[24].s64 = ctx.r[11].s64 + -25140;
	// 830D9B4C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D9B50: 3AEB9DC4  addi r23, r11, -0x623c
	ctx.r[23].s64 = ctx.r[11].s64 + -25148;
	// 830D9B54: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D9B58: 3B6B9DBC  addi r27, r11, -0x6244
	ctx.r[27].s64 = ctx.r[11].s64 + -25156;
	// 830D9B5C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D9B60: 3AAB9DB4  addi r21, r11, -0x624c
	ctx.r[21].s64 = ctx.r[11].s64 + -25164;
	pc = 0x830D9B64; continue 'dispatch;
            }
            0x830D9B64 => {
    //   block [0x830D9B64..0x830D9B80)
	// 830D9B64: 83D30000  lwz r30, 0(r19)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D9B68: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830D9B6C: 419A019C  beq cr6, 0x830d9d08
	if ctx.cr[6].eq {
	pc = 0x830D9D08; continue 'dispatch;
	}
	// 830D9B70: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D9B74: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 830D9B78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D9B7C: 419A0178  beq cr6, 0x830d9cf4
	if ctx.cr[6].eq {
	pc = 0x830D9CF4; continue 'dispatch;
	}
	pc = 0x830D9B80; continue 'dispatch;
            }
            0x830D9B80 => {
    //   block [0x830D9B80..0x830D9C30)
	// 830D9B80: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D9B84: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830D9B88: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 830D9B8C: 40990134  ble cr6, 0x830d9cc0
	if !ctx.cr[6].gt {
	pc = 0x830D9CC0; continue 'dispatch;
	}
	// 830D9B90: 2F0B007F  cmpwi cr6, r11, 0x7f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 127, &mut ctx.xer);
	// 830D9B94: 4098012C  bge cr6, 0x830d9cc0
	if !ctx.cr[6].lt {
	pc = 0x830D9CC0; continue 'dispatch;
	}
	// 830D9B98: 396BFFDE  addi r11, r11, -0x22
	ctx.r[11].s64 = ctx.r[11].s64 + -34;
	// 830D9B9C: 2B0B001C  cmplwi cr6, r11, 0x1c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 28 as u32, &mut ctx.xer);
	// 830D9BA0: 41990144  bgt cr6, 0x830d9ce4
	if ctx.cr[6].gt {
	pc = 0x830D9CE4; continue 'dispatch;
	}
	// 830D9BA4: 3D80830E  lis r12, -0x7cf2
	ctx.r[12].s64 = -2096234496;
	// 830D9BA8: 398C9BBC  addi r12, r12, -0x6444
	ctx.r[12].s64 = ctx.r[12].s64 + -25668;
	// 830D9BAC: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 830D9BB0: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 830D9BB4: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 830D9BB8: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x830D9C30; continue 'dispatch;
		},
		1 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		2 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		3 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		4 => {
	pc = 0x830D9C30; continue 'dispatch;
		},
		5 => {
	pc = 0x830D9C30; continue 'dispatch;
		},
		6 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		7 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		8 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		9 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		10 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		11 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		12 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		13 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		14 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		15 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		16 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		17 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		18 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		19 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		20 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		21 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		22 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		23 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		24 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		25 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		26 => {
	pc = 0x830D9C30; continue 'dispatch;
		},
		27 => {
	pc = 0x830D9CE4; continue 'dispatch;
		},
		28 => {
	pc = 0x830D9C30; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 830D9BBC: 830D9C30  lwz r24, -0x63d0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25552 as u32) ) } as u64;
	// 830D9BC0: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9BC4: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9BC8: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9BCC: 830D9C30  lwz r24, -0x63d0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25552 as u32) ) } as u64;
	// 830D9BD0: 830D9C30  lwz r24, -0x63d0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25552 as u32) ) } as u64;
	// 830D9BD4: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9BD8: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9BDC: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9BE0: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9BE4: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9BE8: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9BEC: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9BF0: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9BF4: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9BF8: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9BFC: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9C00: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9C04: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9C08: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9C0C: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9C10: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9C14: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9C18: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9C1C: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9C20: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9C24: 830D9C30  lwz r24, -0x63d0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25552 as u32) ) } as u64;
	// 830D9C28: 830D9CE4  lwz r24, -0x631c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25372 as u32) ) } as u64;
	// 830D9C2C: 830D9C30  lwz r24, -0x63d0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25552 as u32) ) } as u64;
            }
            0x830D9C30 => {
    //   block [0x830D9C30..0x830D9C6C)
	// 830D9C30: 7CBEF850  subf r5, r30, r31
	ctx.r[5].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 830D9C34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D9C38: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D9C3C: 4BC7E5A5  bl 0x82d581e0
	ctx.lr = 0x830D9C40;
	sub_82D581E0(ctx, base);
	// 830D9C40: 893F0000  lbz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D9C44: 3BDF0001  addi r30, r31, 1
	ctx.r[30].s64 = ctx.r[31].s64 + 1;
	// 830D9C48: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 830D9C4C: 92E10054  stw r23, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u32 ) };
	// 830D9C50: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 830D9C54: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 830D9C58: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 830D9C5C: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 830D9C60: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 830D9C64: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 830D9C68: 92C10064  stw r22, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[22].u32 ) };
	pc = 0x830D9C6C; continue 'dispatch;
            }
            0x830D9C6C => {
    //   block [0x830D9C6C..0x830D9C98)
	// 830D9C6C: 894A0000  lbz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D9C70: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 830D9C74: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830D9C78: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830D9C7C: 419A001C  beq cr6, 0x830d9c98
	if ctx.cr[6].eq {
	pc = 0x830D9C98; continue 'dispatch;
	}
	// 830D9C80: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830D9C84: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 830D9C88: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D9C8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830D9C90: 409AFFDC  bne cr6, 0x830d9c6c
	if !ctx.cr[6].eq {
	pc = 0x830D9C6C; continue 'dispatch;
	}
	// 830D9C94: 48000050  b 0x830d9ce4
	pc = 0x830D9CE4; continue 'dispatch;
            }
            0x830D9C98 => {
    //   block [0x830D9C98..0x830D9CC0)
	// 830D9C98: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830D9C9C: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830D9CA0: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 830D9CA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830D9CA8: 4BC7EF81  bl 0x82d58c28
	ctx.lr = 0x830D9CAC;
	sub_82D58C28(ctx, base);
	// 830D9CAC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830D9CB0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830D9CB4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D9CB8: 4BC7E529  bl 0x82d581e0
	ctx.lr = 0x830D9CBC;
	sub_82D581E0(ctx, base);
	// 830D9CBC: 48000028  b 0x830d9ce4
	pc = 0x830D9CE4; continue 'dispatch;
            }
            0x830D9CC0 => {
    //   block [0x830D9CC0..0x830D9CE4)
	// 830D9CC0: 7CBEF850  subf r5, r30, r31
	ctx.r[5].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 830D9CC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D9CC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D9CCC: 4BC7E515  bl 0x82d581e0
	ctx.lr = 0x830D9CD0;
	sub_82D581E0(ctx, base);
	// 830D9CD0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D9CD4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 830D9CD8: 88BF0000  lbz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D9CDC: 4BC7E455  bl 0x82d58130
	ctx.lr = 0x830D9CE0;
	sub_82D58130(ctx, base);
	// 830D9CE0: 3BDF0001  addi r30, r31, 1
	ctx.r[30].s64 = ctx.r[31].s64 + 1;
	pc = 0x830D9CE4; continue 'dispatch;
            }
            0x830D9CE4 => {
    //   block [0x830D9CE4..0x830D9CF4)
	// 830D9CE4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830D9CE8: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D9CEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D9CF0: 409AFE90  bne cr6, 0x830d9b80
	if !ctx.cr[6].eq {
	pc = 0x830D9B80; continue 'dispatch;
	}
	pc = 0x830D9CF4; continue 'dispatch;
            }
            0x830D9CF4 => {
    //   block [0x830D9CF4..0x830D9D08)
	// 830D9CF4: 7CBEF850  subf r5, r30, r31
	ctx.r[5].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 830D9CF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830D9CFC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D9D00: 4BC7E4E1  bl 0x82d581e0
	ctx.lr = 0x830D9D04;
	sub_82D581E0(ctx, base);
	// 830D9D04: 48000010  b 0x830d9d14
	pc = 0x830D9D14; continue 'dispatch;
            }
            0x830D9D08 => {
    //   block [0x830D9D08..0x830D9D14)
	// 830D9D08: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830D9D0C: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 830D9D10: 4BC7E0E1  bl 0x82d57df0
	ctx.lr = 0x830D9D14;
	sub_82D57DF0(ctx, base);
	pc = 0x830D9D14; continue 'dispatch;
            }
            0x830D9D14 => {
    //   block [0x830D9D14..0x830D9D24)
	// 830D9D14: 3A52FFFF  addi r18, r18, -1
	ctx.r[18].s64 = ctx.r[18].s64 + -1;
	// 830D9D18: 3A730004  addi r19, r19, 4
	ctx.r[19].s64 = ctx.r[19].s64 + 4;
	// 830D9D1C: 2B120000  cmplwi cr6, r18, 0
	ctx.cr[6].compare_u32(ctx.r[18].u32, 0 as u32, &mut ctx.xer);
	// 830D9D20: 409AFE44  bne cr6, 0x830d9b64
	if !ctx.cr[6].eq {
	pc = 0x830D9B64; continue 'dispatch;
	}
	pc = 0x830D9D24; continue 'dispatch;
            }
            0x830D9D24 => {
    //   block [0x830D9D24..0x830D9D30)
	// 830D9D24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830D9D28: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830D9D2C: 4BBCF704  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830D9D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830D9D30 size=1520
    let mut pc: u32 = 0x830D9D30;
    'dispatch: loop {
        match pc {
            0x830D9D30 => {
    //   block [0x830D9D30..0x830D9DE0)
	// 830D9D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830D9D34: 4BBCF6D9  bl 0x82ca940c
	ctx.lr = 0x830D9D38;
	sub_82CA93D0(ctx, base);
	// 830D9D38: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830D9D3C: 3963FFFF  addi r11, r3, -1
	ctx.r[11].s64 = ctx.r[3].s64 + -1;
	// 830D9D40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830D9D44: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830D9D48: 2B0B001D  cmplwi cr6, r11, 0x1d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 29 as u32, &mut ctx.xer);
	// 830D9D4C: 419905CC  bgt cr6, 0x830da318
	if ctx.cr[6].gt {
	pc = 0x830DA318; continue 'dispatch;
	}
	// 830D9D50: 3D80830E  lis r12, -0x7cf2
	ctx.r[12].s64 = -2096234496;
	// 830D9D54: 398C9D68  addi r12, r12, -0x6298
	ctx.r[12].s64 = ctx.r[12].s64 + -25240;
	// 830D9D58: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 830D9D5C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 830D9D60: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 830D9D64: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x830D9DE0; continue 'dispatch;
		},
		1 => {
	pc = 0x830D9E1C; continue 'dispatch;
		},
		2 => {
	pc = 0x830D9E3C; continue 'dispatch;
		},
		3 => {
	pc = 0x830D9E5C; continue 'dispatch;
		},
		4 => {
	pc = 0x830D9E78; continue 'dispatch;
		},
		5 => {
	pc = 0x830D9E98; continue 'dispatch;
		},
		6 => {
	pc = 0x830D9EB4; continue 'dispatch;
		},
		7 => {
	pc = 0x830D9ED0; continue 'dispatch;
		},
		8 => {
	pc = 0x830D9EEC; continue 'dispatch;
		},
		9 => {
	pc = 0x830D9F08; continue 'dispatch;
		},
		10 => {
	pc = 0x830D9F24; continue 'dispatch;
		},
		11 => {
	pc = 0x830D9F48; continue 'dispatch;
		},
		12 => {
	pc = 0x830D9F48; continue 'dispatch;
		},
		13 => {
	pc = 0x830D9F90; continue 'dispatch;
		},
		14 => {
	pc = 0x830D9F90; continue 'dispatch;
		},
		15 => {
	pc = 0x830DA030; continue 'dispatch;
		},
		16 => {
	pc = 0x830DA0E0; continue 'dispatch;
		},
		17 => {
	pc = 0x830DA1E0; continue 'dispatch;
		},
		18 => {
	pc = 0x830DA318; continue 'dispatch;
		},
		19 => {
	pc = 0x830DA2B0; continue 'dispatch;
		},
		20 => {
	pc = 0x830DA318; continue 'dispatch;
		},
		21 => {
	pc = 0x830DA318; continue 'dispatch;
		},
		22 => {
	pc = 0x830DA318; continue 'dispatch;
		},
		23 => {
	pc = 0x830DA318; continue 'dispatch;
		},
		24 => {
	pc = 0x830DA318; continue 'dispatch;
		},
		25 => {
	pc = 0x830DA318; continue 'dispatch;
		},
		26 => {
	pc = 0x830DA318; continue 'dispatch;
		},
		27 => {
	pc = 0x830DA318; continue 'dispatch;
		},
		28 => {
	pc = 0x830DA2E8; continue 'dispatch;
		},
		29 => {
	pc = 0x830D9ED0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 830D9D68: 830D9DE0  lwz r24, -0x6220(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25120 as u32) ) } as u64;
	// 830D9D6C: 830D9E1C  lwz r24, -0x61e4(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25060 as u32) ) } as u64;
	// 830D9D70: 830D9E3C  lwz r24, -0x61c4(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-25028 as u32) ) } as u64;
	// 830D9D74: 830D9E5C  lwz r24, -0x61a4(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-24996 as u32) ) } as u64;
	// 830D9D78: 830D9E78  lwz r24, -0x6188(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-24968 as u32) ) } as u64;
	// 830D9D7C: 830D9E98  lwz r24, -0x6168(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-24936 as u32) ) } as u64;
	// 830D9D80: 830D9EB4  lwz r24, -0x614c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-24908 as u32) ) } as u64;
	// 830D9D84: 830D9ED0  lwz r24, -0x6130(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-24880 as u32) ) } as u64;
	// 830D9D88: 830D9EEC  lwz r24, -0x6114(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-24852 as u32) ) } as u64;
	// 830D9D8C: 830D9F08  lwz r24, -0x60f8(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-24824 as u32) ) } as u64;
	// 830D9D90: 830D9F24  lwz r24, -0x60dc(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-24796 as u32) ) } as u64;
	// 830D9D94: 830D9F48  lwz r24, -0x60b8(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-24760 as u32) ) } as u64;
	// 830D9D98: 830D9F48  lwz r24, -0x60b8(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-24760 as u32) ) } as u64;
	// 830D9D9C: 830D9F90  lwz r24, -0x6070(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-24688 as u32) ) } as u64;
	// 830D9DA0: 830D9F90  lwz r24, -0x6070(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-24688 as u32) ) } as u64;
	// 830D9DA4: 830DA030  lwz r24, -0x5fd0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-24528 as u32) ) } as u64;
	// 830D9DA8: 830DA0E0  lwz r24, -0x5f20(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-24352 as u32) ) } as u64;
	// 830D9DAC: 830DA1E0  lwz r24, -0x5e20(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-24096 as u32) ) } as u64;
	// 830D9DB0: 830DA318  lwz r24, -0x5ce8(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-23784 as u32) ) } as u64;
	// 830D9DB4: 830DA2B0  lwz r24, -0x5d50(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-23888 as u32) ) } as u64;
	// 830D9DB8: 830DA318  lwz r24, -0x5ce8(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-23784 as u32) ) } as u64;
	// 830D9DBC: 830DA318  lwz r24, -0x5ce8(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-23784 as u32) ) } as u64;
	// 830D9DC0: 830DA318  lwz r24, -0x5ce8(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-23784 as u32) ) } as u64;
	// 830D9DC4: 830DA318  lwz r24, -0x5ce8(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-23784 as u32) ) } as u64;
	// 830D9DC8: 830DA318  lwz r24, -0x5ce8(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-23784 as u32) ) } as u64;
	// 830D9DCC: 830DA318  lwz r24, -0x5ce8(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-23784 as u32) ) } as u64;
	// 830D9DD0: 830DA318  lwz r24, -0x5ce8(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-23784 as u32) ) } as u64;
	// 830D9DD4: 830DA318  lwz r24, -0x5ce8(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-23784 as u32) ) } as u64;
	// 830D9DD8: 830DA2E8  lwz r24, -0x5d18(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-23832 as u32) ) } as u64;
	// 830D9DDC: 830D9ED0  lwz r24, -0x6130(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-24880 as u32) ) } as u64;
            }
            0x830D9DE0 => {
    //   block [0x830D9DE0..0x830D9E04)
	// 830D9DE0: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D9DE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830D9DE8: 419A001C  beq cr6, 0x830d9e04
	if ctx.cr[6].eq {
	pc = 0x830D9E04; continue 'dispatch;
	}
	// 830D9DEC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830D9DF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9DF4: 388B0F40  addi r4, r11, 0xf40
	ctx.r[4].s64 = ctx.r[11].s64 + 3904;
	// 830D9DF8: 4BC7DFF9  bl 0x82d57df0
	ctx.lr = 0x830D9DFC;
	sub_82D57DF0(ctx, base);
	// 830D9DFC: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830D9E00: 4BBCF65C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9E04 => {
    //   block [0x830D9E04..0x830D9E1C)
	// 830D9E04: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 830D9E08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9E0C: 388B1700  addi r4, r11, 0x1700
	ctx.r[4].s64 = ctx.r[11].s64 + 5888;
	// 830D9E10: 4BC7DFE1  bl 0x82d57df0
	ctx.lr = 0x830D9E14;
	sub_82D57DF0(ctx, base);
	// 830D9E14: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830D9E18: 4BBCF644  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9E1C => {
    //   block [0x830D9E1C..0x830D9E3C)
	// 830D9E1C: 895F0000  lbz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D9E20: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 830D9E24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9E28: 388B3F10  addi r4, r11, 0x3f10
	ctx.r[4].s64 = ctx.r[11].s64 + 16144;
	// 830D9E2C: 7D450774  extsb r5, r10
	ctx.r[5].s64 = ctx.r[10].s8 as i64;
	// 830D9E30: 4BC7E301  bl 0x82d58130
	ctx.lr = 0x830D9E34;
	sub_82D58130(ctx, base);
	// 830D9E34: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830D9E38: 4BBCF624  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9E3C => {
    //   block [0x830D9E3C..0x830D9E5C)
	// 830D9E3C: 895F0000  lbz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D9E40: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D9E44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9E48: 388B3B98  addi r4, r11, 0x3b98
	ctx.r[4].s64 = ctx.r[11].s64 + 15256;
	// 830D9E4C: 7D450774  extsb r5, r10
	ctx.r[5].s64 = ctx.r[10].s8 as i64;
	// 830D9E50: 4BC7E2E1  bl 0x82d58130
	ctx.lr = 0x830D9E54;
	sub_82D58130(ctx, base);
	// 830D9E54: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830D9E58: 4BBCF604  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9E5C => {
    //   block [0x830D9E5C..0x830D9E78)
	// 830D9E5C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 830D9E60: 88BF0000  lbz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D9E64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9E68: 388B8864  addi r4, r11, -0x779c
	ctx.r[4].s64 = ctx.r[11].s64 + -30620;
	// 830D9E6C: 4BC7E2C5  bl 0x82d58130
	ctx.lr = 0x830D9E70;
	sub_82D58130(ctx, base);
	// 830D9E70: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830D9E74: 4BBCF5E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9E78 => {
    //   block [0x830D9E78..0x830D9E98)
	// 830D9E78: A15F0000  lhz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D9E7C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D9E80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9E84: 388B3B98  addi r4, r11, 0x3b98
	ctx.r[4].s64 = ctx.r[11].s64 + 15256;
	// 830D9E88: 7D450734  extsh r5, r10
	ctx.r[5].s64 = ctx.r[10].s16 as i64;
	// 830D9E8C: 4BC7E2A5  bl 0x82d58130
	ctx.lr = 0x830D9E90;
	sub_82D58130(ctx, base);
	// 830D9E90: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830D9E94: 4BBCF5C8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9E98 => {
    //   block [0x830D9E98..0x830D9EB4)
	// 830D9E98: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 830D9E9C: A0BF0000  lhz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D9EA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9EA4: 388B8864  addi r4, r11, -0x779c
	ctx.r[4].s64 = ctx.r[11].s64 + -30620;
	// 830D9EA8: 4BC7E289  bl 0x82d58130
	ctx.lr = 0x830D9EAC;
	sub_82D58130(ctx, base);
	// 830D9EAC: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830D9EB0: 4BBCF5AC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9EB4 => {
    //   block [0x830D9EB4..0x830D9ED0)
	// 830D9EB4: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D9EB8: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D9EBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9EC0: 388B3B98  addi r4, r11, 0x3b98
	ctx.r[4].s64 = ctx.r[11].s64 + 15256;
	// 830D9EC4: 4BC7E26D  bl 0x82d58130
	ctx.lr = 0x830D9EC8;
	sub_82D58130(ctx, base);
	// 830D9EC8: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830D9ECC: 4BBCF590  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9ED0 => {
    //   block [0x830D9ED0..0x830D9EEC)
	// 830D9ED0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 830D9ED4: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830D9ED8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9EDC: 388B8864  addi r4, r11, -0x779c
	ctx.r[4].s64 = ctx.r[11].s64 + -30620;
	// 830D9EE0: 4BC7E251  bl 0x82d58130
	ctx.lr = 0x830D9EE4;
	sub_82D58130(ctx, base);
	// 830D9EE4: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830D9EE8: 4BBCF574  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9EEC => {
    //   block [0x830D9EEC..0x830D9F08)
	// 830D9EEC: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830D9EF0: E8BF0000  ld r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 830D9EF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9EF8: 388B3B9C  addi r4, r11, 0x3b9c
	ctx.r[4].s64 = ctx.r[11].s64 + 15260;
	// 830D9EFC: 4BC7E235  bl 0x82d58130
	ctx.lr = 0x830D9F00;
	sub_82D58130(ctx, base);
	// 830D9F00: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830D9F04: 4BBCF558  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9F08 => {
    //   block [0x830D9F08..0x830D9F24)
	// 830D9F08: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 830D9F0C: E8BF0000  ld r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	// 830D9F10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9F14: 388B681C  addi r4, r11, 0x681c
	ctx.r[4].s64 = ctx.r[11].s64 + 26652;
	// 830D9F18: 4BC7E219  bl 0x82d58130
	ctx.lr = 0x830D9F1C;
	sub_82D58130(ctx, base);
	// 830D9F1C: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830D9F20: 4BBCF53C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9F24 => {
    //   block [0x830D9F24..0x830D9F48)
	// 830D9F24: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 830D9F28: C03F0000  lfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830D9F2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9F30: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 830D9F34: 388BFB84  addi r4, r11, -0x47c
	ctx.r[4].s64 = ctx.r[11].s64 + -1148;
	// 830D9F38: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 830D9F3C: 4BC7E1F5  bl 0x82d58130
	ctx.lr = 0x830D9F40;
	sub_82D58130(ctx, base);
	// 830D9F40: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830D9F44: 4BBCF518  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9F48 => {
    //   block [0x830D9F48..0x830D9F90)
	// 830D9F48: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D9F4C: C09F000C  lfs f4, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 830D9F50: C07F0008  lfs f3, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830D9F54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9F58: C05F0004  lfs f2, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830D9F5C: 388B9E14  addi r4, r11, -0x61ec
	ctx.r[4].s64 = ctx.r[11].s64 + -25068;
	// 830D9F60: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830D9F64: D8810038  stfd f4, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.f[4].u64 ) };
	// 830D9F68: E9010038  ld r8, 0x38(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(56 as u32) ) };
	// 830D9F6C: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 830D9F70: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 830D9F74: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 830D9F78: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 830D9F7C: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 830D9F80: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 830D9F84: 4BC7E1AD  bl 0x82d58130
	ctx.lr = 0x830D9F88;
	sub_82D58130(ctx, base);
	// 830D9F88: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830D9F8C: 4BBCF4D0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830D9F90 => {
    //   block [0x830D9F90..0x830DA030)
	// 830D9F90: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830D9F94: C07F0008  lfs f3, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830D9F98: C05F0004  lfs f2, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830D9F9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9FA0: 3BAB9E08  addi r29, r11, -0x61f8
	ctx.r[29].s64 = ctx.r[11].s64 + -25080;
	// 830D9FA4: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830D9FA8: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 830D9FAC: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 830D9FB0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830D9FB4: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 830D9FB8: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 830D9FBC: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 830D9FC0: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 830D9FC4: 4BC7E16D  bl 0x82d58130
	ctx.lr = 0x830D9FC8;
	sub_82D58130(ctx, base);
	// 830D9FC8: C07F0018  lfs f3, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830D9FCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830D9FD0: C05F0014  lfs f2, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830D9FD4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830D9FD8: C03F0010  lfs f1, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830D9FDC: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 830D9FE0: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 830D9FE4: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 830D9FE8: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 830D9FEC: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 830D9FF0: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 830D9FF4: 4BC7E13D  bl 0x82d58130
	ctx.lr = 0x830D9FF8;
	sub_82D58130(ctx, base);
	// 830D9FF8: C07F0028  lfs f3, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830D9FFC: C05F0024  lfs f2, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830DA000: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA004: C03F0020  lfs f1, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830DA008: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DA00C: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 830DA010: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 830DA014: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 830DA018: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 830DA01C: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 830DA020: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 830DA024: 4BC7E10D  bl 0x82d58130
	ctx.lr = 0x830DA028;
	sub_82D58130(ctx, base);
	// 830DA028: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830DA02C: 4BBCF430  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DA030 => {
    //   block [0x830DA030..0x830DA0E0)
	// 830DA030: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DA034: C07F0008  lfs f3, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830DA038: C05F0004  lfs f2, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830DA03C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA040: 3BAB9E08  addi r29, r11, -0x61f8
	ctx.r[29].s64 = ctx.r[11].s64 + -25080;
	// 830DA044: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830DA048: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 830DA04C: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 830DA050: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DA054: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 830DA058: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 830DA05C: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 830DA060: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 830DA064: 4BC7E0CD  bl 0x82d58130
	ctx.lr = 0x830DA068;
	sub_82D58130(ctx, base);
	// 830DA068: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DA06C: C09F001C  lfs f4, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 830DA070: C07F0018  lfs f3, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830DA074: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA078: C05F0014  lfs f2, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830DA07C: 388B9E14  addi r4, r11, -0x61ec
	ctx.r[4].s64 = ctx.r[11].s64 + -25068;
	// 830DA080: C03F0010  lfs f1, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830DA084: D8810038  stfd f4, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.f[4].u64 ) };
	// 830DA088: E9010038  ld r8, 0x38(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(56 as u32) ) };
	// 830DA08C: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 830DA090: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 830DA094: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 830DA098: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 830DA09C: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 830DA0A0: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 830DA0A4: 4BC7E08D  bl 0x82d58130
	ctx.lr = 0x830DA0A8;
	sub_82D58130(ctx, base);
	// 830DA0A8: C07F0028  lfs f3, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830DA0AC: C05F0024  lfs f2, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830DA0B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA0B4: C03F0020  lfs f1, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830DA0B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DA0BC: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 830DA0C0: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 830DA0C4: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 830DA0C8: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 830DA0CC: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 830DA0D0: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 830DA0D4: 4BC7E05D  bl 0x82d58130
	ctx.lr = 0x830DA0D8;
	sub_82D58130(ctx, base);
	// 830DA0D8: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830DA0DC: 4BBCF380  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DA0E0 => {
    //   block [0x830DA0E0..0x830DA1E0)
	// 830DA0E0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DA0E4: C09F000C  lfs f4, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 830DA0E8: C07F0008  lfs f3, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830DA0EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA0F0: 3BAB9E14  addi r29, r11, -0x61ec
	ctx.r[29].s64 = ctx.r[11].s64 + -25068;
	// 830DA0F4: C05F0004  lfs f2, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830DA0F8: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830DA0FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DA100: D8810038  stfd f4, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.f[4].u64 ) };
	// 830DA104: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 830DA108: E9010038  ld r8, 0x38(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(56 as u32) ) };
	// 830DA10C: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 830DA110: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 830DA114: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 830DA118: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 830DA11C: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 830DA120: 4BC7E011  bl 0x82d58130
	ctx.lr = 0x830DA124;
	sub_82D58130(ctx, base);
	// 830DA124: C09F001C  lfs f4, 0x1c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 830DA128: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA12C: C07F0018  lfs f3, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830DA130: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DA134: C05F0014  lfs f2, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830DA138: C03F0010  lfs f1, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830DA13C: D8810038  stfd f4, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.f[4].u64 ) };
	// 830DA140: E9010038  ld r8, 0x38(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(56 as u32) ) };
	// 830DA144: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 830DA148: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 830DA14C: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 830DA150: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 830DA154: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 830DA158: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 830DA15C: 4BC7DFD5  bl 0x82d58130
	ctx.lr = 0x830DA160;
	sub_82D58130(ctx, base);
	// 830DA160: C09F002C  lfs f4, 0x2c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 830DA164: C07F0028  lfs f3, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830DA168: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA16C: C05F0024  lfs f2, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830DA170: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DA174: C03F0020  lfs f1, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830DA178: D8810038  stfd f4, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.f[4].u64 ) };
	// 830DA17C: E9010038  ld r8, 0x38(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(56 as u32) ) };
	// 830DA180: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 830DA184: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 830DA188: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 830DA18C: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 830DA190: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 830DA194: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 830DA198: 4BC7DF99  bl 0x82d58130
	ctx.lr = 0x830DA19C;
	sub_82D58130(ctx, base);
	// 830DA19C: C09F003C  lfs f4, 0x3c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 830DA1A0: C07F0038  lfs f3, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830DA1A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA1A8: C05F0034  lfs f2, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830DA1AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DA1B0: C03F0030  lfs f1, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830DA1B4: D8810038  stfd f4, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.f[4].u64 ) };
	// 830DA1B8: E9010038  ld r8, 0x38(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(56 as u32) ) };
	// 830DA1BC: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 830DA1C0: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 830DA1C4: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 830DA1C8: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 830DA1CC: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 830DA1D0: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 830DA1D4: 4BC7DF5D  bl 0x82d58130
	ctx.lr = 0x830DA1D8;
	sub_82D58130(ctx, base);
	// 830DA1D8: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830DA1DC: 4BBCF280  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DA1E0 => {
    //   block [0x830DA1E0..0x830DA2B0)
	// 830DA1E0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DA1E4: C07F0008  lfs f3, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830DA1E8: C05F0004  lfs f2, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830DA1EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA1F0: 3BAB9E08  addi r29, r11, -0x61f8
	ctx.r[29].s64 = ctx.r[11].s64 + -25080;
	// 830DA1F4: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830DA1F8: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 830DA1FC: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 830DA200: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DA204: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 830DA208: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 830DA20C: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 830DA210: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 830DA214: 4BC7DF1D  bl 0x82d58130
	ctx.lr = 0x830DA218;
	sub_82D58130(ctx, base);
	// 830DA218: C07F0018  lfs f3, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830DA21C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA220: C05F0014  lfs f2, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830DA224: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DA228: C03F0010  lfs f1, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830DA22C: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 830DA230: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 830DA234: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 830DA238: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 830DA23C: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 830DA240: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 830DA244: 4BC7DEED  bl 0x82d58130
	ctx.lr = 0x830DA248;
	sub_82D58130(ctx, base);
	// 830DA248: C07F0028  lfs f3, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830DA24C: C05F0024  lfs f2, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830DA250: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA254: C03F0020  lfs f1, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830DA258: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DA25C: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 830DA260: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 830DA264: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 830DA268: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 830DA26C: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 830DA270: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 830DA274: 4BC7DEBD  bl 0x82d58130
	ctx.lr = 0x830DA278;
	sub_82D58130(ctx, base);
	// 830DA278: C07F0038  lfs f3, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830DA27C: C05F0034  lfs f2, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830DA280: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA284: C03F0030  lfs f1, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830DA288: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DA28C: D8610030  stfd f3, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.f[3].u64 ) };
	// 830DA290: E8E10030  ld r7, 0x30(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(48 as u32) ) };
	// 830DA294: D8410028  stfd f2, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.f[2].u64 ) };
	// 830DA298: E8C10028  ld r6, 0x28(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(40 as u32) ) };
	// 830DA29C: D8210020  stfd f1, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.f[1].u64 ) };
	// 830DA2A0: E8A10020  ld r5, 0x20(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(32 as u32) ) };
	// 830DA2A4: 4BC7DE8D  bl 0x82d58130
	ctx.lr = 0x830DA2A8;
	sub_82D58130(ctx, base);
	// 830DA2A8: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830DA2AC: 4BBCF1B0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DA2B0 => {
    //   block [0x830DA2B0..0x830DA2E8)
	// 830DA2B0: 80660024  lwz r3, 0x24(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 830DA2B4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830DA2B8: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA2BC: 38C00100  li r6, 0x100
	ctx.r[6].s64 = 256;
	// 830DA2C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA2C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DA2C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DA2CC: 4E800421  bctrl
	ctx.lr = 0x830DA2D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DA2D0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830DA2D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830DA2D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA2DC: 4BC7DF05  bl 0x82d581e0
	ctx.lr = 0x830DA2E0;
	sub_82D581E0(ctx, base);
	// 830DA2E0: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830DA2E4: 4BBCF178  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DA2E8 => {
    //   block [0x830DA2E8..0x830DA318)
	// 830DA2E8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DA2EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA2F0: 388B9DFC  addi r4, r11, -0x6204
	ctx.r[4].s64 = ctx.r[11].s64 + -25092;
	// 830DA2F4: 4BC7DE3D  bl 0x82d58130
	ctx.lr = 0x830DA2F8;
	sub_82D58130(ctx, base);
	// 830DA2F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830DA2FC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DA300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DA304: 4BFFF805  bl 0x830d9b08
	ctx.lr = 0x830DA308;
	sub_830D9B08(ctx, base);
	// 830DA308: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DA30C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA310: 388B9DEC  addi r4, r11, -0x6214
	ctx.r[4].s64 = ctx.r[11].s64 + -25108;
	// 830DA314: 4BC7DE1D  bl 0x82d58130
	ctx.lr = 0x830DA318;
	sub_82D58130(ctx, base);
	pc = 0x830DA318; continue 'dispatch;
            }
            0x830DA318 => {
    //   block [0x830DA318..0x830DA320)
	// 830DA318: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 830DA31C: 4BBCF140  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DA320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DA320 size=116
    let mut pc: u32 = 0x830DA320;
    'dispatch: loop {
        match pc {
            0x830DA320 => {
    //   block [0x830DA320..0x830DA394)
	// 830DA320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DA324: 4BBCF0E5  bl 0x82ca9408
	ctx.lr = 0x830DA328;
	sub_82CA93D0(ctx, base);
	// 830DA328: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DA32C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830DA330: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830DA334: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830DA338: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830DA33C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 830DA340: 4BC7DF59  bl 0x82d58298
	ctx.lr = 0x830DA344;
	sub_82D58298(ctx, base);
	// 830DA344: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DA348: 80BD0008  lwz r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DA34C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830DA350: 388B9E38  addi r4, r11, -0x61c8
	ctx.r[4].s64 = ctx.r[11].s64 + -25032;
	// 830DA354: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830DA358: 4BC7DDD9  bl 0x82d58130
	ctx.lr = 0x830DA35C;
	sub_82D58130(ctx, base);
	// 830DA35C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830DA360: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DA364: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DA368: 4BFFF3E9  bl 0x830d9750
	ctx.lr = 0x830DA36C;
	sub_830D9750(ctx, base);
	// 830DA36C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DA370: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DA374: 388B9E24  addi r4, r11, -0x61dc
	ctx.r[4].s64 = ctx.r[11].s64 + -25052;
	// 830DA378: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830DA37C: 4BC7DDB5  bl 0x82d58130
	ctx.lr = 0x830DA380;
	sub_82D58130(ctx, base);
	// 830DA380: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830DA384: 4BC7E0AD  bl 0x82d58430
	ctx.lr = 0x830DA388;
	sub_82D58430(ctx, base);
	// 830DA388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DA38C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830DA390: 4BBCF0C8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DA398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DA398 size=112
    let mut pc: u32 = 0x830DA398;
    'dispatch: loop {
        match pc {
            0x830DA398 => {
    //   block [0x830DA398..0x830DA3E8)
	// 830DA398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DA39C: 4BBCF065  bl 0x82ca9400
	ctx.lr = 0x830DA3A0;
	sub_82CA93D0(ctx, base);
	// 830DA3A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DA3A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DA3A8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830DA3AC: 3B9E0004  addi r28, r30, 4
	ctx.r[28].s64 = ctx.r[30].s64 + 4;
	// 830DA3B0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830DA3B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DA3B8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830DA3BC: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 830DA3C0: 4BC862C9  bl 0x82d60688
	ctx.lr = 0x830DA3C4;
	sub_82D60688(ctx, base);
	// 830DA3C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DA3C8: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830DA3CC: 409A001C  bne cr6, 0x830da3e8
	if !ctx.cr[6].eq {
	pc = 0x830DA3E8; continue 'dispatch;
	}
	// 830DA3D0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DA3D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DA3D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DA3DC: 557F007E  clrlwi r31, r11, 1
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 830DA3E0: 38BF0001  addi r5, r31, 1
	ctx.r[5].s64 = ctx.r[31].s64 + 1;
	// 830DA3E4: 4B18B81D  bl 0x82265c00
	ctx.lr = 0x830DA3E8;
	sub_82265C00(ctx, base);
	pc = 0x830DA3E8; continue 'dispatch;
            }
            0x830DA3E8 => {
    //   block [0x830DA3E8..0x830DA408)
	// 830DA3E8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DA3EC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 830DA3F0: 38AB9A94  addi r5, r11, -0x656c
	ctx.r[5].s64 = ctx.r[11].s64 + -25964;
	// 830DA3F4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830DA3F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830DA3FC: 4BC7E54D  bl 0x82d58948
	ctx.lr = 0x830DA400;
	sub_82D58948(ctx, base);
	// 830DA400: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830DA404: 4BBCF04C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DA408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DA408 size=160
    let mut pc: u32 = 0x830DA408;
    'dispatch: loop {
        match pc {
            0x830DA408 => {
    //   block [0x830DA408..0x830DA44C)
	// 830DA408: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DA40C: 4BBCF001  bl 0x82ca940c
	ctx.lr = 0x830DA410;
	sub_82CA93D0(ctx, base);
	// 830DA410: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DA414: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DA418: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DA41C: 7D7D2214  add r11, r29, r4
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[4].u64;
	// 830DA420: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 830DA424: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830DA428: 40990058  ble cr6, 0x830da480
	if !ctx.cr[6].gt {
	pc = 0x830DA480; continue 'dispatch;
	}
	// 830DA42C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DA430: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DA434: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830DA438: 40980024  bge cr6, 0x830da45c
	if !ctx.cr[6].lt {
	pc = 0x830DA45C; continue 'dispatch;
	}
	// 830DA43C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DA440: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DA444: 41980008  blt cr6, 0x830da44c
	if ctx.cr[6].lt {
	pc = 0x830DA44C; continue 'dispatch;
	}
	// 830DA448: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x830DA44C; continue 'dispatch;
            }
            0x830DA44C => {
    //   block [0x830DA44C..0x830DA45C)
	// 830DA44C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DA450: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830DA454: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA458: 4BC7CAB9  bl 0x82d56f10
	ctx.lr = 0x830DA45C;
	sub_82D56F10(ctx, base);
	pc = 0x830DA45C; continue 'dispatch;
            }
            0x830DA45C => {
    //   block [0x830DA45C..0x830DA46C)
	// 830DA45C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 830DA460: 7F1DF800  cmpw cr6, r29, r31
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830DA464: 4098001C  bge cr6, 0x830da480
	if !ctx.cr[6].lt {
	pc = 0x830DA480; continue 'dispatch;
	}
	// 830DA468: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	pc = 0x830DA46C; continue 'dispatch;
            }
            0x830DA46C => {
    //   block [0x830DA46C..0x830DA480)
	// 830DA46C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA470: 7D4959AE  stbx r10, r9, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u8) };
	// 830DA474: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830DA478: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830DA47C: 4198FFF0  blt cr6, 0x830da46c
	if ctx.cr[6].lt {
	pc = 0x830DA46C; continue 'dispatch;
	}
	pc = 0x830DA480; continue 'dispatch;
            }
            0x830DA480 => {
    //   block [0x830DA480..0x830DA4A8)
	// 830DA480: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA484: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830DA488: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 830DA48C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830DA490: 994BFFFF  stb r10, -1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-1 as u32), ctx.r[10].u8 ) };
	// 830DA494: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DA498: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830DA49C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830DA4A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830DA4A4: 4BBCEFB8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DA4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DA4B8 size=184
    let mut pc: u32 = 0x830DA4B8;
    'dispatch: loop {
        match pc {
            0x830DA4B8 => {
    //   block [0x830DA4B8..0x830DA50C)
	// 830DA4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DA4BC: 4BBCEF45  bl 0x82ca9400
	ctx.lr = 0x830DA4C0;
	sub_82CA93D0(ctx, base);
	// 830DA4C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DA4C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DA4C8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830DA4CC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DA4D0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830DA4D4: 388B9E6C  addi r4, r11, -0x6194
	ctx.r[4].s64 = ctx.r[11].s64 + -24980;
	// 830DA4D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DA4DC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830DA4E0: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA4E4: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 830DA4E8: 4BC7DC49  bl 0x82d58130
	ctx.lr = 0x830DA4EC;
	sub_82D58130(ctx, base);
	// 830DA4EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DA4F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA4F4: 4BFFFF15  bl 0x830da408
	ctx.lr = 0x830DA4F8;
	sub_830DA408(ctx, base);
	// 830DA4F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DA4FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830DA500: 4BC7B461  bl 0x82d55960
	ctx.lr = 0x830DA504;
	sub_82D55960(ctx, base);
	// 830DA504: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DA508: 4099003C  ble cr6, 0x830da544
	if !ctx.cr[6].gt {
	pc = 0x830DA544; continue 'dispatch;
	}
	pc = 0x830DA50C; continue 'dispatch;
            }
            0x830DA50C => {
    //   block [0x830DA50C..0x830DA544)
	// 830DA50C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DA510: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DA514: 4BC7B475  bl 0x82d55988
	ctx.lr = 0x830DA518;
	sub_82D55988(ctx, base);
	// 830DA518: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830DA51C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA520: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830DA524: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830DA528: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 830DA52C: 48000585  bl 0x830daab0
	ctx.lr = 0x830DA530;
	sub_830DAAB0(ctx, base);
	// 830DA530: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DA534: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830DA538: 4BC7B429  bl 0x82d55960
	ctx.lr = 0x830DA53C;
	sub_82D55960(ctx, base);
	// 830DA53C: 7F1F1800  cmpw cr6, r31, r3
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[3].s32, &mut ctx.xer);
	// 830DA540: 4198FFCC  blt cr6, 0x830da50c
	if ctx.cr[6].lt {
	pc = 0x830DA50C; continue 'dispatch;
	}
	pc = 0x830DA544; continue 'dispatch;
            }
            0x830DA544 => {
    //   block [0x830DA544..0x830DA570)
	// 830DA544: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 830DA548: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA54C: 4BFFFEBD  bl 0x830da408
	ctx.lr = 0x830DA550;
	sub_830DA408(ctx, base);
	// 830DA550: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DA554: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DA558: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA55C: 388B9E5C  addi r4, r11, -0x61a4
	ctx.r[4].s64 = ctx.r[11].s64 + -24996;
	// 830DA560: 4BC7DBD1  bl 0x82d58130
	ctx.lr = 0x830DA564;
	sub_82D58130(ctx, base);
	// 830DA564: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830DA568: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830DA56C: 4BBCEEE4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DA570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830DA570 size=8
    let mut pc: u32 = 0x830DA570;
    'dispatch: loop {
        match pc {
            0x830DA570 => {
    //   block [0x830DA570..0x830DA578)
	// 830DA570: 38630008  addi r3, r3, 8
	ctx.r[3].s64 = ctx.r[3].s64 + 8;
	// 830DA574: 4BFFFE94  b 0x830da408
	sub_830DA408(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DA578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DA578 size=152
    let mut pc: u32 = 0x830DA578;
    'dispatch: loop {
        match pc {
            0x830DA578 => {
    //   block [0x830DA578..0x830DA5E0)
	// 830DA578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DA57C: 4BBCEE91  bl 0x82ca940c
	ctx.lr = 0x830DA580;
	sub_82CA93D0(ctx, base);
	// 830DA580: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DA584: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DA588: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DA58C: 396B9E80  addi r11, r11, -0x6180
	ctx.r[11].s64 = ctx.r[11].s64 + -24960;
	// 830DA590: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 830DA594: 3D208000  lis r9, -0x8000
	ctx.r[9].s64 = -2147483648;
	// 830DA598: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830DA59C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830DA5A0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830DA5A4: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 830DA5A8: 61290010  ori r9, r9, 0x10
	ctx.r[9].u64 = ctx.r[9].u64 | 16;
	// 830DA5AC: B15E0006  sth r10, 6(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 830DA5B0: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830DA5B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830DA5B8: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830DA5BC: 909E0024  stw r4, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[4].u32 ) };
	// 830DA5C0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DA5C4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DA5C8: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DA5CC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DA5D0: 409A0010  bne cr6, 0x830da5e0
	if !ctx.cr[6].eq {
	pc = 0x830DA5E0; continue 'dispatch;
	}
	// 830DA5D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DA5D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DA5DC: 4BC7C9BD  bl 0x82d56f98
	ctx.lr = 0x830DA5E0;
	sub_82D56F98(ctx, base);
	pc = 0x830DA5E0; continue 'dispatch;
            }
            0x830DA5E0 => {
    //   block [0x830DA5E0..0x830DA610)
	// 830DA5E0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DA5E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DA5E8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA5EC: 7FAA59AE  stbx r29, r10, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[29].u8) };
	// 830DA5F0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DA5F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830DA5F8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830DA5FC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DA600: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830DA604: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830DA608: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830DA60C: 4BBCEE50  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DA610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DA610 size=252
    let mut pc: u32 = 0x830DA610;
    'dispatch: loop {
        match pc {
            0x830DA610 => {
    //   block [0x830DA610..0x830DA674)
	// 830DA610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DA614: 4BBCEDF5  bl 0x82ca9408
	ctx.lr = 0x830DA618;
	sub_82CA93D0(ctx, base);
	// 830DA618: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DA61C: 7CEB0774  extsb r11, r7
	ctx.r[11].s64 = ctx.r[7].s8 as i64;
	// 830DA620: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830DA624: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830DA628: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830DA62C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 830DA630: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DA634: 419A0040  beq cr6, 0x830da674
	if ctx.cr[6].eq {
	pc = 0x830DA674; continue 'dispatch;
	}
	// 830DA638: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA63C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830DA640: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DA644: 388B0C88  addi r4, r11, 0xc88
	ctx.r[4].s64 = ctx.r[11].s64 + 3208;
	// 830DA648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DA64C: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DA650: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DA654: 4E800421  bctrl
	ctx.lr = 0x830DA658;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DA658: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA65C: 80BC000C  lwz r5, 0xc(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DA660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DA664: 809C0008  lwz r4, 8(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DA668: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DA66C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DA670: 4E800421  bctrl
	ctx.lr = 0x830DA674;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DA674 => {
    //   block [0x830DA674..0x830DA6B8)
	// 830DA674: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DA678: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830DA67C: 4BC7DC1D  bl 0x82d58298
	ctx.lr = 0x830DA680;
	sub_82D58298(ctx, base);
	// 830DA680: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830DA684: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830DA688: 388BEAF4  addi r4, r11, -0x150c
	ctx.r[4].s64 = ctx.r[11].s64 + -5388;
	// 830DA68C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830DA690: 4BC7DAA1  bl 0x82d58130
	ctx.lr = 0x830DA694;
	sub_82D58130(ctx, base);
	// 830DA694: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830DA698: 419A0048  beq cr6, 0x830da6e0
	if ctx.cr[6].eq {
	pc = 0x830DA6E0; continue 'dispatch;
	}
	// 830DA69C: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA6A0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830DA6A4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 830DA6A8: 419A0038  beq cr6, 0x830da6e0
	if ctx.cr[6].eq {
	pc = 0x830DA6E0; continue 'dispatch;
	}
	// 830DA6AC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 830DA6B0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 830DA6B4: 3BAAEAF8  addi r29, r10, -0x1508
	ctx.r[29].s64 = ctx.r[10].s64 + -5384;
	pc = 0x830DA6B8; continue 'dispatch;
            }
            0x830DA6B8 => {
    //   block [0x830DA6B8..0x830DA6E0)
	// 830DA6B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DA6BC: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DA6C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830DA6C4: 4BC7DA6D  bl 0x82d58130
	ctx.lr = 0x830DA6C8;
	sub_82D58130(ctx, base);
	// 830DA6C8: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 830DA6CC: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DA6D0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830DA6D4: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA6D8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 830DA6DC: 409AFFDC  bne cr6, 0x830da6b8
	if !ctx.cr[6].eq {
	pc = 0x830DA6B8; continue 'dispatch;
	}
	pc = 0x830DA6E0; continue 'dispatch;
            }
            0x830DA6E0 => {
    //   block [0x830DA6E0..0x830DA70C)
	// 830DA6E0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 830DA6E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830DA6E8: 388BF608  addi r4, r11, -0x9f8
	ctx.r[4].s64 = ctx.r[11].s64 + -2552;
	// 830DA6EC: 4BC7DA45  bl 0x82d58130
	ctx.lr = 0x830DA6F0;
	sub_82D58130(ctx, base);
	// 830DA6F0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DA6F4: 387C0008  addi r3, r28, 8
	ctx.r[3].s64 = ctx.r[28].s64 + 8;
	// 830DA6F8: 4BFFFD11  bl 0x830da408
	ctx.lr = 0x830DA6FC;
	sub_830DA408(ctx, base);
	// 830DA6FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830DA700: 4BC7DD31  bl 0x82d58430
	ctx.lr = 0x830DA704;
	sub_82D58430(ctx, base);
	// 830DA704: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830DA708: 4BBCED50  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DA710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DA710 size=224
    let mut pc: u32 = 0x830DA710;
    'dispatch: loop {
        match pc {
            0x830DA710 => {
    //   block [0x830DA710..0x830DA784)
	// 830DA710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DA714: 4BBCECF1  bl 0x82ca9404
	ctx.lr = 0x830DA718;
	sub_82CA93D0(ctx, base);
	// 830DA718: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DA71C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DA720: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830DA724: 3BBE0008  addi r29, r30, 8
	ctx.r[29].s64 = ctx.r[30].s64 + 8;
	// 830DA728: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 830DA72C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DA730: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830DA734: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830DA738: 4BFFFCD1  bl 0x830da408
	ctx.lr = 0x830DA73C;
	sub_830DA408(ctx, base);
	// 830DA73C: 7F6B0774  extsb r11, r27
	ctx.r[11].s64 = ctx.r[27].s8 as i64;
	// 830DA740: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DA744: 419A0040  beq cr6, 0x830da784
	if ctx.cr[6].eq {
	pc = 0x830DA784; continue 'dispatch;
	}
	// 830DA748: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA74C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830DA750: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DA754: 388B0C88  addi r4, r11, 0xc88
	ctx.r[4].s64 = ctx.r[11].s64 + 3208;
	// 830DA758: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DA75C: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DA760: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DA764: 4E800421  bctrl
	ctx.lr = 0x830DA768;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DA768: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA76C: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DA770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DA774: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA778: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DA77C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DA780: 4E800421  bctrl
	ctx.lr = 0x830DA784;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DA784 => {
    //   block [0x830DA784..0x830DA7F0)
	// 830DA784: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA788: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 830DA78C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 830DA790: 388BA704  addi r4, r11, -0x58fc
	ctx.r[4].s64 = ctx.r[11].s64 + -22780;
	// 830DA794: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DA798: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DA79C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DA7A0: 4E800421  bctrl
	ctx.lr = 0x830DA7A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DA7A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DA7A8: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA7AC: 4BC7E47D  bl 0x82d58c28
	ctx.lr = 0x830DA7B0;
	sub_82D58C28(ctx, base);
	// 830DA7B0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830DA7B4: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DA7B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DA7BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DA7C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DA7C4: 4E800421  bctrl
	ctx.lr = 0x830DA7C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DA7C8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA7CC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 830DA7D0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DA7D4: 388BF608  addi r4, r11, -0x9f8
	ctx.r[4].s64 = ctx.r[11].s64 + -2552;
	// 830DA7D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DA7DC: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DA7E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DA7E4: 4E800421  bctrl
	ctx.lr = 0x830DA7E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DA7E8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830DA7EC: 4BBCEC68  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DA7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830DA7F0 size=700
    let mut pc: u32 = 0x830DA7F0;
    'dispatch: loop {
        match pc {
            0x830DA7F0 => {
    //   block [0x830DA7F0..0x830DA8E8)
	// 830DA7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DA7F4: 4BBCEBF9  bl 0x82ca93ec
	ctx.lr = 0x830DA7F8;
	sub_82CA93D0(ctx, base);
	// 830DA7F8: 9421FD50  stwu r1, -0x2b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-688 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DA7FC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830DA800: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 830DA804: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DA808: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830DA80C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 830DA810: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 830DA814: 4BC8280D  bl 0x82d5d020
	ctx.lr = 0x830DA818;
	sub_82D5D020(ctx, base);
	// 830DA818: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 830DA81C: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA820: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DA824: 4BC827F5  bl 0x82d5d018
	ctx.lr = 0x830DA828;
	sub_82D5D018(ctx, base);
	// 830DA828: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DA82C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830DA830: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DA834: 419A0270  beq cr6, 0x830daaa4
	if ctx.cr[6].eq {
	pc = 0x830DAAA4; continue 'dispatch;
	}
	// 830DA838: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DA83C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830DA840: 4BFFFBC9  bl 0x830da408
	ctx.lr = 0x830DA844;
	sub_830DA408(ctx, base);
	// 830DA844: 397BFFFF  addi r11, r27, -1
	ctx.r[11].s64 = ctx.r[27].s64 + -1;
	// 830DA848: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830DA84C: 2B0B001D  cmplwi cr6, r11, 0x1d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 29 as u32, &mut ctx.xer);
	// 830DA850: 3AAA9EBC  addi r21, r10, -0x6144
	ctx.r[21].s64 = ctx.r[10].s64 + -24900;
	// 830DA854: 41990234  bgt cr6, 0x830daa88
	if ctx.cr[6].gt {
	pc = 0x830DAA88; continue 'dispatch;
	}
	// 830DA858: 3D80830E  lis r12, -0x7cf2
	ctx.r[12].s64 = -2096234496;
	// 830DA85C: 398CA870  addi r12, r12, -0x5790
	ctx.r[12].s64 = ctx.r[12].s64 + -22416;
	// 830DA860: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 830DA864: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 830DA868: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 830DA86C: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		1 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		2 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		3 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		4 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		5 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		6 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		7 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		8 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		9 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		10 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		11 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		12 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		13 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		14 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		15 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		16 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		17 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		18 => {
	pc = 0x830DA984; continue 'dispatch;
		},
		19 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		20 => {
	pc = 0x830DAA88; continue 'dispatch;
		},
		21 => {
	pc = 0x830DAA88; continue 'dispatch;
		},
		22 => {
	pc = 0x830DAA88; continue 'dispatch;
		},
		23 => {
	pc = 0x830DAA88; continue 'dispatch;
		},
		24 => {
	pc = 0x830DA99C; continue 'dispatch;
		},
		25 => {
	pc = 0x830DAA88; continue 'dispatch;
		},
		26 => {
	pc = 0x830DAA88; continue 'dispatch;
		},
		27 => {
	pc = 0x830DA9E4; continue 'dispatch;
		},
		28 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		29 => {
	pc = 0x830DA8E8; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 830DA870: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA874: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA878: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA87C: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA880: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA884: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA888: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA88C: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA890: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA894: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA898: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA89C: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA8A0: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA8A4: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA8A8: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA8AC: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA8B0: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA8B4: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA8B8: 830DA984  lwz r24, -0x567c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22140 as u32) ) } as u64;
	// 830DA8BC: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA8C0: 830DAA88  lwz r24, -0x5578(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21880 as u32) ) } as u64;
	// 830DA8C4: 830DAA88  lwz r24, -0x5578(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21880 as u32) ) } as u64;
	// 830DA8C8: 830DAA88  lwz r24, -0x5578(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21880 as u32) ) } as u64;
	// 830DA8CC: 830DAA88  lwz r24, -0x5578(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21880 as u32) ) } as u64;
	// 830DA8D0: 830DA99C  lwz r24, -0x5664(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22116 as u32) ) } as u64;
	// 830DA8D4: 830DAA88  lwz r24, -0x5578(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21880 as u32) ) } as u64;
	// 830DA8D8: 830DAA88  lwz r24, -0x5578(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21880 as u32) ) } as u64;
	// 830DA8DC: 830DA9E4  lwz r24, -0x561c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22044 as u32) ) } as u64;
	// 830DA8E0: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
	// 830DA8E4: 830DA8E8  lwz r24, -0x5718(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-22296 as u32) ) } as u64;
            }
            0x830DA8E8 => {
    //   block [0x830DA8E8..0x830DA90C)
	// 830DA8E8: 397BFFF4  addi r11, r27, -0xc
	ctx.r[11].s64 = ctx.r[27].s64 + -12;
	// 830DA8EC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DA8F0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830DA8F4: 216B0006  subfic r11, r11, 6
	ctx.xer.ca = ctx.r[11].u32 <= 6 as u32;
	ctx.r[11].s64 = (6 as i64) - ctx.r[11].s64;
	// 830DA8F8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DA8FC: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 830DA900: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 830DA904: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	// 830DA908: 40990180  ble cr6, 0x830daa88
	if !ctx.cr[6].gt {
	pc = 0x830DAA88; continue 'dispatch;
	}
	pc = 0x830DA90C; continue 'dispatch;
            }
            0x830DA90C => {
    //   block [0x830DA90C..0x830DA948)
	// 830DA90C: 57AB083E  rotlwi r11, r29, 1
	ctx.r[11].u64 = ((ctx.r[29].u32).rotate_left(1)) as u64;
	// 830DA910: 7D5DE3D6  divw r10, r29, r28
	ctx.r[10].s32 = ctx.r[29].s32 / ctx.r[28].s32;
	// 830DA914: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830DA918: 7D4AE1D6  mullw r10, r10, r28
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[28].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 830DA91C: 7F8B5878  andc r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 & !ctx.r[11].u64;
	// 830DA920: 0CDC0000  twi 6, r28, 0
	// 830DA924: 7D4AE851  subf. r10, r10, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DA928: 0CABFFFF  twi 5, r11, -1
	// 830DA92C: 4182001C  beq 0x830da948
	if ctx.cr[0].eq {
	pc = 0x830DA948; continue 'dispatch;
	}
	// 830DA930: 2F1B001D  cmpwi cr6, r27, 0x1d
	ctx.cr[6].compare_i32(ctx.r[27].s32, 29, &mut ctx.xer);
	// 830DA934: 419A0014  beq cr6, 0x830da948
	if ctx.cr[6].eq {
	pc = 0x830DA948; continue 'dispatch;
	}
	// 830DA938: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 830DA93C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830DA940: 4BC7D461  bl 0x82d57da0
	ctx.lr = 0x830DA944;
	sub_82D57DA0(ctx, base);
	// 830DA944: 48000014  b 0x830da958
	pc = 0x830DA958; continue 'dispatch;
            }
            0x830DA948 => {
    //   block [0x830DA948..0x830DA958)
	// 830DA948: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830DA94C: 80B60000  lwz r5, 0(r22)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA950: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 830DA954: 4BC7D7DD  bl 0x82d58130
	ctx.lr = 0x830DA958;
	sub_82D58130(ctx, base);
	pc = 0x830DA958; continue 'dispatch;
            }
            0x830DA958 => {
    //   block [0x830DA958..0x830DA984)
	// 830DA958: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 830DA95C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830DA960: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DA964: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830DA968: 4BFFF3C9  bl 0x830d9d30
	ctx.lr = 0x830DA96C;
	sub_830D9D30(ctx, base);
	// 830DA96C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DA970: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830DA974: 7FFFC214  add r31, r31, r24
	ctx.r[31].u64 = ctx.r[31].u64 + ctx.r[24].u64;
	// 830DA978: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DA97C: 4198FF90  blt cr6, 0x830da90c
	if ctx.cr[6].lt {
	pc = 0x830DA90C; continue 'dispatch;
	}
	// 830DA980: 48000108  b 0x830daa88
	pc = 0x830DAA88; continue 'dispatch;
            }
            0x830DA984 => {
    //   block [0x830DA984..0x830DA99C)
	// 830DA984: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DA988: 80BC0000  lwz r5, 0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DA98C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830DA990: 388B9EA4  addi r4, r11, -0x615c
	ctx.r[4].s64 = ctx.r[11].s64 + -24924;
	// 830DA994: 4BC7D79D  bl 0x82d58130
	ctx.lr = 0x830DA998;
	sub_82D58130(ctx, base);
	// 830DA998: 480000F0  b 0x830daa88
	pc = 0x830DAA88; continue 'dispatch;
            }
            0x830DA99C => {
    //   block [0x830DA99C..0x830DA9AC)
	// 830DA99C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DA9A0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830DA9A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DA9A8: 409900E0  ble cr6, 0x830daa88
	if !ctx.cr[6].gt {
	pc = 0x830DAA88; continue 'dispatch;
	}
	pc = 0x830DA9AC; continue 'dispatch;
            }
            0x830DA9AC => {
    //   block [0x830DA9AC..0x830DA9E4)
	// 830DA9AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DA9B0: 4BC823A9  bl 0x82d5cd58
	ctx.lr = 0x830DA9B4;
	sub_82D5CD58(ctx, base);
	// 830DA9B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830DA9B8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830DA9BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830DA9C0: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 830DA9C4: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 830DA9C8: 4BFFFAF1  bl 0x830da4b8
	ctx.lr = 0x830DA9CC;
	sub_830DA4B8(ctx, base);
	// 830DA9CC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DA9D0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830DA9D4: 7FFFC214  add r31, r31, r24
	ctx.r[31].u64 = ctx.r[31].u64 + ctx.r[24].u64;
	// 830DA9D8: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DA9DC: 4198FFD0  blt cr6, 0x830da9ac
	if ctx.cr[6].lt {
	pc = 0x830DA9AC; continue 'dispatch;
	}
	// 830DA9E0: 480000A8  b 0x830daa88
	pc = 0x830DAA88; continue 'dispatch;
            }
            0x830DA9E4 => {
    //   block [0x830DA9E4..0x830DAA0C)
	// 830DA9E4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DA9E8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830DA9EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DA9F0: 40990098  ble cr6, 0x830daa88
	if !ctx.cr[6].gt {
	pc = 0x830DAA88; continue 'dispatch;
	}
	// 830DA9F4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DA9F8: 3B8B9E98  addi r28, r11, -0x6168
	ctx.r[28].s64 = ctx.r[11].s64 + -24936;
	// 830DA9FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830DAA00: 3B6B0CA0  addi r27, r11, 0xca0
	ctx.r[27].s64 = ctx.r[11].s64 + 3232;
	// 830DAA04: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 830DAA08: 3AEB4A00  addi r23, r11, 0x4a00
	ctx.r[23].s64 = ctx.r[11].s64 + 18944;
	pc = 0x830DAA0C; continue 'dispatch;
            }
            0x830DAA0C => {
    //   block [0x830DAA0C..0x830DAA64)
	// 830DAA0C: 80790024  lwz r3, 0x24(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 830DAA10: 38C00100  li r6, 0x100
	ctx.r[6].s64 = 256;
	// 830DAA14: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DAA18: 38A10150  addi r5, r1, 0x150
	ctx.r[5].s64 = ctx.r[1].s64 + 336;
	// 830DAA1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DAA20: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DAA24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DAA28: 4E800421  bctrl
	ctx.lr = 0x830DAA2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DAA2C: 80790024  lwz r3, 0x24(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 830DAA30: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DAA34: 38C00100  li r6, 0x100
	ctx.r[6].s64 = 256;
	// 830DAA38: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830DAA3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DAA40: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DAA44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DAA48: 4E800421  bctrl
	ctx.lr = 0x830DAA4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DAA4C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DAA50: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830DAA54: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 830DAA58: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DAA5C: 41980008  blt cr6, 0x830daa64
	if ctx.cr[6].lt {
	pc = 0x830DAA64; continue 'dispatch;
	}
	// 830DAA60: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
            }
            0x830DAA64 => {
    //   block [0x830DAA64..0x830DAA88)
	// 830DAA64: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830DAA68: 38A10150  addi r5, r1, 0x150
	ctx.r[5].s64 = ctx.r[1].s64 + 336;
	// 830DAA6C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DAA70: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830DAA74: 4BC7D6BD  bl 0x82d58130
	ctx.lr = 0x830DAA78;
	sub_82D58130(ctx, base);
	// 830DAA78: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DAA7C: 7FFFC214  add r31, r31, r24
	ctx.r[31].u64 = ctx.r[31].u64 + ctx.r[24].u64;
	// 830DAA80: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DAA84: 4198FF88  blt cr6, 0x830daa0c
	if ctx.cr[6].lt {
	pc = 0x830DAA0C; continue 'dispatch;
	}
	pc = 0x830DAA88; continue 'dispatch;
            }
            0x830DAA88 => {
    //   block [0x830DAA88..0x830DAAA4)
	// 830DAA88: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 830DAA8C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830DAA90: 4BFFF979  bl 0x830da408
	ctx.lr = 0x830DAA94;
	sub_830DA408(ctx, base);
	// 830DAA94: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830DAA98: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 830DAA9C: 80B60000  lwz r5, 0(r22)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DAAA0: 4BC7D691  bl 0x82d58130
	ctx.lr = 0x830DAAA4;
	sub_82D58130(ctx, base);
	pc = 0x830DAAA4; continue 'dispatch;
            }
            0x830DAAA4 => {
    //   block [0x830DAAA4..0x830DAAAC)
	// 830DAAA4: 382102B0  addi r1, r1, 0x2b0
	ctx.r[1].s64 = ctx.r[1].s64 + 688;
	// 830DAAA8: 4BBCE994  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DAAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DAAB0 size=2256
    let mut pc: u32 = 0x830DAAB0;
    'dispatch: loop {
        match pc {
            0x830DAAB0 => {
    //   block [0x830DAAB0..0x830DAB04)
	// 830DAAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DAAB4: 4BBCE939  bl 0x82ca93ec
	ctx.lr = 0x830DAAB8;
	sub_82CA93D0(ctx, base);
	// 830DAAB8: 9421FA00  stwu r1, -0x600(r1)
	ea = ctx.r[1].u32.wrapping_add(-1536 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DAABC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830DAAC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DAAC4: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 830DAAC8: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 830DAACC: A15E0010  lhz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DAAD0: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 830DAAD4: 554A056A  rlwinm r10, r10, 0, 0x15, 0x15
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830DAAD8: 7F0B2A14  add r24, r11, r5
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 830DAADC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830DAAE0: 419A0024  beq cr6, 0x830dab04
	if ctx.cr[6].eq {
	pc = 0x830DAB04; continue 'dispatch;
	}
	// 830DAAE4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DAAE8: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DAAEC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DAAF0: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DAAF4: 388B9FF4  addi r4, r11, -0x600c
	ctx.r[4].s64 = ctx.r[11].s64 + -24588;
	// 830DAAF8: 4BC7D639  bl 0x82d58130
	ctx.lr = 0x830DAAFC;
	sub_82D58130(ctx, base);
	// 830DAAFC: 38210600  addi r1, r1, 0x600
	ctx.r[1].s64 = ctx.r[1].s64 + 1536;
	// 830DAB00: 4BBCE93C  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DAB04 => {
    //   block [0x830DAB04..0x830DAB48)
	// 830DAB04: 897E000C  lbz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DAB08: 2B0B0014  cmplwi cr6, r11, 0x14
	ctx.cr[6].compare_u32(ctx.r[11].u32, 20 as u32, &mut ctx.xer);
	// 830DAB0C: 409A003C  bne cr6, 0x830dab48
	if !ctx.cr[6].eq {
	pc = 0x830DAB48; continue 'dispatch;
	}
	// 830DAB10: 897E000D  lbz r11, 0xd(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(13 as u32) ) } as u64;
	// 830DAB14: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830DAB18: 409A0030  bne cr6, 0x830dab48
	if !ctx.cr[6].eq {
	pc = 0x830DAB48; continue 'dispatch;
	}
	// 830DAB1C: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DAB20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DAB24: 409A0024  bne cr6, 0x830dab48
	if !ctx.cr[6].eq {
	pc = 0x830DAB48; continue 'dispatch;
	}
	// 830DAB28: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DAB2C: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DAB30: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DAB34: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DAB38: 388B9FC4  addi r4, r11, -0x603c
	ctx.r[4].s64 = ctx.r[11].s64 + -24636;
	// 830DAB3C: 4BC7D5F5  bl 0x82d58130
	ctx.lr = 0x830DAB40;
	sub_82D58130(ctx, base);
	// 830DAB40: 38210600  addi r1, r1, 0x600
	ctx.r[1].s64 = ctx.r[1].s64 + 1536;
	// 830DAB44: 4BBCE8F8  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DAB48 => {
    //   block [0x830DAB48..0x830DABA0)
	// 830DAB48: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DAB4C: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DAB50: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DAB54: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DAB58: 388B9FAC  addi r4, r11, -0x6054
	ctx.r[4].s64 = ctx.r[11].s64 + -24660;
	// 830DAB5C: 4BC7D5D5  bl 0x82d58130
	ctx.lr = 0x830DAB60;
	sub_82D58130(ctx, base);
	// 830DAB60: 897E000C  lbz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DAB64: 396BFFEA  addi r11, r11, -0x16
	ctx.r[11].s64 = ctx.r[11].s64 + -22;
	// 830DAB68: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 830DAB6C: 41990050  bgt cr6, 0x830dabbc
	if ctx.cr[6].gt {
	pc = 0x830DABBC; continue 'dispatch;
	}
	// 830DAB70: 3D80830E  lis r12, -0x7cf2
	ctx.r[12].s64 = -2096234496;
	// 830DAB74: 398CAB88  addi r12, r12, -0x5478
	ctx.r[12].s64 = ctx.r[12].s64 + -21624;
	// 830DAB78: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 830DAB7C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 830DAB80: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 830DAB84: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x830DABA0; continue 'dispatch;
		},
		1 => {
	pc = 0x830DABA0; continue 'dispatch;
		},
		2 => {
	pc = 0x830DABBC; continue 'dispatch;
		},
		3 => {
	pc = 0x830DABBC; continue 'dispatch;
		},
		4 => {
	pc = 0x830DABA0; continue 'dispatch;
		},
		5 => {
	pc = 0x830DABA8; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 830DAB88: 830DABA0  lwz r24, -0x5460(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21600 as u32) ) } as u64;
	// 830DAB8C: 830DABA0  lwz r24, -0x5460(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21600 as u32) ) } as u64;
	// 830DAB90: 830DABBC  lwz r24, -0x5444(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21572 as u32) ) } as u64;
	// 830DAB94: 830DABBC  lwz r24, -0x5444(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21572 as u32) ) } as u64;
	// 830DAB98: 830DABA0  lwz r24, -0x5460(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21600 as u32) ) } as u64;
	// 830DAB9C: 830DABA8  lwz r24, -0x5458(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21592 as u32) ) } as u64;
            }
            0x830DABA0 => {
    //   block [0x830DABA0..0x830DABA8)
	// 830DABA0: 80B80004  lwz r5, 4(r24)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DABA4: 48000008  b 0x830dabac
	pc = 0x830DABAC; continue 'dispatch;
            }
            0x830DABA8 => {
    //   block [0x830DABA8..0x830DABAC)
	// 830DABA8: 80B80008  lwz r5, 8(r24)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x830DABAC; continue 'dispatch;
            }
            0x830DABAC => {
    //   block [0x830DABAC..0x830DABBC)
	// 830DABAC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DABB0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DABB4: 388B9F98  addi r4, r11, -0x6068
	ctx.r[4].s64 = ctx.r[11].s64 + -24680;
	// 830DABB8: 4BC7D579  bl 0x82d58130
	ctx.lr = 0x830DABBC;
	sub_82D58130(ctx, base);
	pc = 0x830DABBC; continue 'dispatch;
            }
            0x830DABBC => {
    //   block [0x830DABBC..0x830DAC70)
	// 830DABBC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 830DABC0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DABC4: 388BF608  addi r4, r11, -0x9f8
	ctx.r[4].s64 = ctx.r[11].s64 + -2552;
	// 830DABC8: 4BC7D569  bl 0x82d58130
	ctx.lr = 0x830DABCC;
	sub_82D58130(ctx, base);
	// 830DABCC: 897E000C  lbz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DABD0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830DABD4: 2B0B001E  cmplwi cr6, r11, 0x1e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 30 as u32, &mut ctx.xer);
	// 830DABD8: 41990734  bgt cr6, 0x830db30c
	if ctx.cr[6].gt {
	pc = 0x830DB30C; continue 'dispatch;
	}
	// 830DABDC: 3D80830E  lis r12, -0x7cf2
	ctx.r[12].s64 = -2096234496;
	// 830DABE0: 398CABF4  addi r12, r12, -0x540c
	ctx.r[12].s64 = ctx.r[12].s64 + -21516;
	// 830DABE4: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 830DABE8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 830DABEC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 830DABF0: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		1 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		2 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		3 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		4 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		5 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		6 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		7 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		8 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		9 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		10 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		11 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		12 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		13 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		14 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		15 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		16 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		17 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		18 => {
	pc = 0x830DAD4C; continue 'dispatch;
		},
		19 => {
	pc = 0x830DAD8C; continue 'dispatch;
		},
		20 => {
	pc = 0x830DAE5C; continue 'dispatch;
		},
		21 => {
	pc = 0x830DAEA0; continue 'dispatch;
		},
		22 => {
	pc = 0x830DAEA0; continue 'dispatch;
		},
		23 => {
	pc = 0x830DAEBC; continue 'dispatch;
		},
		24 => {
	pc = 0x830DAF1C; continue 'dispatch;
		},
		25 => {
	pc = 0x830DAEA0; continue 'dispatch;
		},
		26 => {
	pc = 0x830DAFB4; continue 'dispatch;
		},
		27 => {
	pc = 0x830DB12C; continue 'dispatch;
		},
		28 => {
	pc = 0x830DAD64; continue 'dispatch;
		},
		29 => {
	pc = 0x830DAC70; continue 'dispatch;
		},
		30 => {
	pc = 0x830DB1F8; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 830DABF4: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DABF8: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DABFC: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DAC00: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DAC04: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DAC08: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DAC0C: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DAC10: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DAC14: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DAC18: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DAC1C: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DAC20: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DAC24: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DAC28: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DAC2C: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DAC30: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DAC34: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DAC38: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DAC3C: 830DAD4C  lwz r24, -0x52b4(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21172 as u32) ) } as u64;
	// 830DAC40: 830DAD8C  lwz r24, -0x5274(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21108 as u32) ) } as u64;
	// 830DAC44: 830DAE5C  lwz r24, -0x51a4(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-20900 as u32) ) } as u64;
	// 830DAC48: 830DAEA0  lwz r24, -0x5160(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-20832 as u32) ) } as u64;
	// 830DAC4C: 830DAEA0  lwz r24, -0x5160(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-20832 as u32) ) } as u64;
	// 830DAC50: 830DAEBC  lwz r24, -0x5144(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-20804 as u32) ) } as u64;
	// 830DAC54: 830DAF1C  lwz r24, -0x50e4(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-20708 as u32) ) } as u64;
	// 830DAC58: 830DAEA0  lwz r24, -0x5160(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-20832 as u32) ) } as u64;
	// 830DAC5C: 830DAFB4  lwz r24, -0x504c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-20556 as u32) ) } as u64;
	// 830DAC60: 830DB12C  lwz r24, -0x4ed4(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-20180 as u32) ) } as u64;
	// 830DAC64: 830DAD64  lwz r24, -0x529c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21148 as u32) ) } as u64;
	// 830DAC68: 830DAC70  lwz r24, -0x5390(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-21392 as u32) ) } as u64;
	// 830DAC6C: 830DB1F8  lwz r24, -0x4e08(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-19976 as u32) ) } as u64;
            }
            0x830DAC70 => {
    //   block [0x830DAC70..0x830DAC88)
	// 830DAC70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DAC74: 4BC820FD  bl 0x82d5cd70
	ctx.lr = 0x830DAC78;
	sub_82D5CD70(ctx, base);
	// 830DAC78: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DAC7C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830DAC80: 409A0008  bne cr6, 0x830dac88
	if !ctx.cr[6].eq {
	pc = 0x830DAC88; continue 'dispatch;
	}
	// 830DAC84: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	pc = 0x830DAC88; continue 'dispatch;
            }
            0x830DAC88 => {
    //   block [0x830DAC88..0x830DACD4)
	// 830DAC88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DAC8C: 4BC82115  bl 0x82d5cda0
	ctx.lr = 0x830DAC90;
	sub_82D5CDA0(ctx, base);
	// 830DAC90: 546B083E  rotlwi r11, r3, 1
	ctx.r[11].u64 = ((ctx.r[3].u32).rotate_left(1)) as u64;
	// 830DAC94: 7F63EBD6  divw r27, r3, r29
	ctx.r[27].s32 = ctx.r[3].s32 / ctx.r[29].s32;
	// 830DAC98: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830DAC9C: 0CDD0000  twi 6, r29, 0
	// 830DACA0: 7FAB5878  andc r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 & !ctx.r[11].u64;
	// 830DACA4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830DACA8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830DACAC: 0CABFFFF  twi 5, r11, -1
	// 830DACB0: 409906B8  ble cr6, 0x830db368
	if !ctx.cr[6].gt {
	pc = 0x830DB368; continue 'dispatch;
	}
	// 830DACB4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 830DACB8: 3B4B4A00  addi r26, r11, 0x4a00
	ctx.r[26].s64 = ctx.r[11].s64 + 18944;
	// 830DACBC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830DACC0: 3AEB0C88  addi r23, r11, 0xc88
	ctx.r[23].s64 = ctx.r[11].s64 + 3208;
	// 830DACC4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 830DACC8: 3B8B3F10  addi r28, r11, 0x3f10
	ctx.r[28].s64 = ctx.r[11].s64 + 16144;
	// 830DACCC: 3D6051EB  lis r11, 0x51eb
	ctx.r[11].s64 = 1374355456;
	// 830DACD0: 6176851F  ori r22, r11, 0x851f
	ctx.r[22].u64 = ctx.r[11].u64 | 34079;
	pc = 0x830DACD4; continue 'dispatch;
            }
            0x830DACD4 => {
    //   block [0x830DACD4..0x830DACF8)
	// 830DACD4: 897E000C  lbz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DACD8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830DACDC: 409A001C  bne cr6, 0x830dacf8
	if !ctx.cr[6].eq {
	pc = 0x830DACF8; continue 'dispatch;
	}
	// 830DACE0: 89780000  lbz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DACE4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DACE8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DACEC: 7D650774  extsb r5, r11
	ctx.r[5].s64 = ctx.r[11].s8 as i64;
	// 830DACF0: 4BC7D441  bl 0x82d58130
	ctx.lr = 0x830DACF4;
	sub_82D58130(ctx, base);
	// 830DACF4: 48000044  b 0x830dad38
	pc = 0x830DAD38; continue 'dispatch;
            }
            0x830DACF8 => {
    //   block [0x830DACF8..0x830DAD1C)
	// 830DACF8: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830DACFC: 419A0028  beq cr6, 0x830dad24
	if ctx.cr[6].eq {
	pc = 0x830DAD24; continue 'dispatch;
	}
	// 830DAD00: 7D7FB016  mulhwu r11, r31, r22
	ctx.r[11].u64 = ((ctx.r[31].u32 as u64 * ctx.r[22].u32 as u64) >> 32);
	// 830DAD04: 556BE13E  srwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DAD08: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 830DAD0C: 1D6B0032  mulli r11, r11, 0x32
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 50 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 830DAD10: 7D6BF851  subf. r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DAD14: 41820008  beq 0x830dad1c
	if ctx.cr[0].eq {
	pc = 0x830DAD1C; continue 'dispatch;
	}
	// 830DAD18: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	pc = 0x830DAD1C; continue 'dispatch;
            }
            0x830DAD1C => {
    //   block [0x830DAD1C..0x830DAD24)
	// 830DAD1C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DAD20: 4BC7D411  bl 0x82d58130
	ctx.lr = 0x830DAD24;
	sub_82D58130(ctx, base);
	pc = 0x830DAD24; continue 'dispatch;
            }
            0x830DAD24 => {
    //   block [0x830DAD24..0x830DAD38)
	// 830DAD24: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 830DAD28: 887E000C  lbz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DAD2C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 830DAD30: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 830DAD34: 4BFFEFFD  bl 0x830d9d30
	ctx.lr = 0x830DAD38;
	sub_830D9D30(ctx, base);
	pc = 0x830DAD38; continue 'dispatch;
            }
            0x830DAD38 => {
    //   block [0x830DAD38..0x830DAD4C)
	// 830DAD38: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830DAD3C: 7F18DA14  add r24, r24, r27
	ctx.r[24].u64 = ctx.r[24].u64 + ctx.r[27].u64;
	// 830DAD40: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830DAD44: 4198FF90  blt cr6, 0x830dacd4
	if ctx.cr[6].lt {
	pc = 0x830DACD4; continue 'dispatch;
	}
	// 830DAD48: 48000620  b 0x830db368
	pc = 0x830DB368; continue 'dispatch;
            }
            0x830DAD4C => {
    //   block [0x830DAD4C..0x830DAD64)
	// 830DAD4C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DAD50: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DAD54: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DAD58: 388B9F84  addi r4, r11, -0x607c
	ctx.r[4].s64 = ctx.r[11].s64 + -24700;
	// 830DAD5C: 4BC7D3D5  bl 0x82d58130
	ctx.lr = 0x830DAD60;
	sub_82D58130(ctx, base);
	// 830DAD60: 48000608  b 0x830db368
	pc = 0x830DB368; continue 'dispatch;
            }
            0x830DAD64 => {
    //   block [0x830DAD64..0x830DAD7C)
	// 830DAD64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DAD68: 4BC82009  bl 0x82d5cd70
	ctx.lr = 0x830DAD6C;
	sub_82D5CD70(ctx, base);
	// 830DAD6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830DAD70: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830DAD74: 409A0008  bne cr6, 0x830dad7c
	if !ctx.cr[6].eq {
	pc = 0x830DAD7C; continue 'dispatch;
	}
	// 830DAD78: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	pc = 0x830DAD7C; continue 'dispatch;
            }
            0x830DAD7C => {
    //   block [0x830DAD7C..0x830DAD8C)
	// 830DAD7C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 830DAD80: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 830DAD84: 4BFFED85  bl 0x830d9b08
	ctx.lr = 0x830DAD88;
	sub_830D9B08(ctx, base);
	// 830DAD88: 480005E0  b 0x830db368
	pc = 0x830DB368; continue 'dispatch;
            }
            0x830DAD8C => {
    //   block [0x830DAD8C..0x830DADA4)
	// 830DAD8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DAD90: 4BC81FE1  bl 0x82d5cd70
	ctx.lr = 0x830DAD94;
	sub_82D5CD70(ctx, base);
	// 830DAD94: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DAD98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830DAD9C: 409A0008  bne cr6, 0x830dada4
	if !ctx.cr[6].eq {
	pc = 0x830DADA4; continue 'dispatch;
	}
	// 830DADA0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	pc = 0x830DADA4; continue 'dispatch;
            }
            0x830DADA4 => {
    //   block [0x830DADA4..0x830DADC4)
	// 830DADA4: 897E000D  lbz r11, 0xd(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(13 as u32) ) } as u64;
	// 830DADA8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830DADAC: 409A0018  bne cr6, 0x830dadc4
	if !ctx.cr[6].eq {
	pc = 0x830DADC4; continue 'dispatch;
	}
	// 830DADB0: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 830DADB4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DADB8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 830DADBC: 4BFFED4D  bl 0x830d9b08
	ctx.lr = 0x830DADC0;
	sub_830D9B08(ctx, base);
	// 830DADC0: 480005A8  b 0x830db368
	pc = 0x830DB368; continue 'dispatch;
            }
            0x830DADC4 => {
    //   block [0x830DADC4..0x830DADEC)
	// 830DADC4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830DADC8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830DADCC: 4099059C  ble cr6, 0x830db368
	if !ctx.cr[6].gt {
	pc = 0x830DB368; continue 'dispatch;
	}
	// 830DADD0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 830DADD4: 3B5DFFFF  addi r26, r29, -1
	ctx.r[26].s64 = ctx.r[29].s64 + -1;
	// 830DADD8: 3B8B0D8C  addi r28, r11, 0xd8c
	ctx.r[28].s64 = ctx.r[11].s64 + 3468;
	// 830DADDC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 830DADE0: 3BEB231C  addi r31, r11, 0x231c
	ctx.r[31].s64 = ctx.r[11].s64 + 8988;
	// 830DADE4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 830DADE8: 3B6B4A00  addi r27, r11, 0x4a00
	ctx.r[27].s64 = ctx.r[11].s64 + 18944;
	pc = 0x830DADEC; continue 'dispatch;
            }
            0x830DADEC => {
    //   block [0x830DADEC..0x830DAE28)
	// 830DADEC: 80980000  lwz r4, 0(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DADF0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830DADF4: 419A0034  beq cr6, 0x830dae28
	if ctx.cr[6].eq {
	pc = 0x830DAE28; continue 'dispatch;
	}
	// 830DADF8: 80750024  lwz r3, 0x24(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(36 as u32) ) } as u64;
	// 830DADFC: 38C00100  li r6, 0x100
	ctx.r[6].s64 = 256;
	// 830DAE00: 38A102A0  addi r5, r1, 0x2a0
	ctx.r[5].s64 = ctx.r[1].s64 + 672;
	// 830DAE04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DAE08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DAE0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DAE10: 4E800421  bctrl
	ctx.lr = 0x830DAE14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DAE14: 38A102A0  addi r5, r1, 0x2a0
	ctx.r[5].s64 = ctx.r[1].s64 + 672;
	// 830DAE18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DAE1C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DAE20: 4BC7D311  bl 0x82d58130
	ctx.lr = 0x830DAE24;
	sub_82D58130(ctx, base);
	// 830DAE24: 48000010  b 0x830dae34
	pc = 0x830DAE34; continue 'dispatch;
            }
            0x830DAE28 => {
    //   block [0x830DAE28..0x830DAE34)
	// 830DAE28: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DAE2C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DAE30: 4BC7CFC1  bl 0x82d57df0
	ctx.lr = 0x830DAE34;
	sub_82D57DF0(ctx, base);
	pc = 0x830DAE34; continue 'dispatch;
            }
            0x830DAE34 => {
    //   block [0x830DAE34..0x830DAE48)
	// 830DAE34: 7F1ED000  cmpw cr6, r30, r26
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[26].s32, &mut ctx.xer);
	// 830DAE38: 40980010  bge cr6, 0x830dae48
	if !ctx.cr[6].lt {
	pc = 0x830DAE48; continue 'dispatch;
	}
	// 830DAE3C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DAE40: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830DAE44: 4BC7CFAD  bl 0x82d57df0
	ctx.lr = 0x830DAE48;
	sub_82D57DF0(ctx, base);
	pc = 0x830DAE48; continue 'dispatch;
            }
            0x830DAE48 => {
    //   block [0x830DAE48..0x830DAE5C)
	// 830DAE48: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830DAE4C: 3B180004  addi r24, r24, 4
	ctx.r[24].s64 = ctx.r[24].s64 + 4;
	// 830DAE50: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830DAE54: 4198FF98  blt cr6, 0x830dadec
	if ctx.cr[6].lt {
	pc = 0x830DADEC; continue 'dispatch;
	}
	// 830DAE58: 48000510  b 0x830db368
	pc = 0x830DB368; continue 'dispatch;
            }
            0x830DAE5C => {
    //   block [0x830DAE5C..0x830DAE74)
	// 830DAE5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DAE60: 4BC81F11  bl 0x82d5cd70
	ctx.lr = 0x830DAE64;
	sub_82D5CD70(ctx, base);
	// 830DAE64: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DAE68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DAE6C: 409A0008  bne cr6, 0x830dae74
	if !ctx.cr[6].eq {
	pc = 0x830DAE74; continue 'dispatch;
	}
	// 830DAE70: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	pc = 0x830DAE74; continue 'dispatch;
            }
            0x830DAE74 => {
    //   block [0x830DAE74..0x830DAE84)
	// 830DAE74: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830DAE78: 409904F0  ble cr6, 0x830db368
	if !ctx.cr[6].gt {
	pc = 0x830DB368; continue 'dispatch;
	}
	// 830DAE7C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 830DAE80: 3BCB0D8C  addi r30, r11, 0xd8c
	ctx.r[30].s64 = ctx.r[11].s64 + 3468;
	pc = 0x830DAE84; continue 'dispatch;
            }
            0x830DAE84 => {
    //   block [0x830DAE84..0x830DAEA0)
	// 830DAE84: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DAE88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830DAE8C: 4BC7CF65  bl 0x82d57df0
	ctx.lr = 0x830DAE90;
	sub_82D57DF0(ctx, base);
	// 830DAE90: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 830DAE94: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830DAE98: 409AFFEC  bne cr6, 0x830dae84
	if !ctx.cr[6].eq {
	pc = 0x830DAE84; continue 'dispatch;
	}
	// 830DAE9C: 480004CC  b 0x830db368
	pc = 0x830DB368; continue 'dispatch;
            }
            0x830DAEA0 => {
    //   block [0x830DAEA0..0x830DAEBC)
	// 830DAEA0: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 830DAEA4: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 830DAEA8: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 830DAEAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830DAEB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DAEB4: 4BFFF93D  bl 0x830da7f0
	ctx.lr = 0x830DAEB8;
	sub_830DA7F0(ctx, base);
	// 830DAEB8: 480004B0  b 0x830db368
	pc = 0x830DB368; continue 'dispatch;
            }
            0x830DAEBC => {
    //   block [0x830DAEBC..0x830DAF08)
	// 830DAEBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DAEC0: 4BC81EC1  bl 0x82d5cd80
	ctx.lr = 0x830DAEC4;
	sub_82D5CD80(ctx, base);
	// 830DAEC4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830DAEC8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 830DAECC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DAED0: 4BC821A1  bl 0x82d5d070
	ctx.lr = 0x830DAED4;
	sub_82D5D070(ctx, base);
	// 830DAED4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830DAED8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DAEDC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830DAEE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DAEE4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DAEE8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830DAEEC: 4BC83615  bl 0x82d5e500
	ctx.lr = 0x830DAEF0;
	sub_82D5E500(ctx, base);
	// 830DAEF0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DAEF4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DAEF8: 409A0010  bne cr6, 0x830daf08
	if !ctx.cr[6].eq {
	pc = 0x830DAF08; continue 'dispatch;
	}
	// 830DAEFC: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830DAF00: 4BC7D231  bl 0x82d58130
	ctx.lr = 0x830DAF04;
	sub_82D58130(ctx, base);
	// 830DAF04: 48000464  b 0x830db368
	pc = 0x830DB368; continue 'dispatch;
            }
            0x830DAF08 => {
    //   block [0x830DAF08..0x830DAF1C)
	// 830DAF08: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DAF0C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830DAF10: 388B9F70  addi r4, r11, -0x6090
	ctx.r[4].s64 = ctx.r[11].s64 + -24720;
	// 830DAF14: 4BC7D21D  bl 0x82d58130
	ctx.lr = 0x830DAF18;
	sub_82D58130(ctx, base);
	// 830DAF18: 48000450  b 0x830db368
	pc = 0x830DB368; continue 'dispatch;
            }
            0x830DAF1C => {
    //   block [0x830DAF1C..0x830DAF4C)
	// 830DAF1C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DAF20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DAF24: 4BFFF4E5  bl 0x830da408
	ctx.lr = 0x830DAF28;
	sub_830DA408(ctx, base);
	// 830DAF28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DAF2C: 4BC81E2D  bl 0x82d5cd58
	ctx.lr = 0x830DAF30;
	sub_82D5CD58(ctx, base);
	// 830DAF30: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830DAF34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DAF38: 4BC81E39  bl 0x82d5cd70
	ctx.lr = 0x830DAF3C;
	sub_82D5CD70(ctx, base);
	// 830DAF3C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DAF40: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830DAF44: 409A0008  bne cr6, 0x830daf4c
	if !ctx.cr[6].eq {
	pc = 0x830DAF4C; continue 'dispatch;
	}
	// 830DAF48: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	pc = 0x830DAF4C; continue 'dispatch;
            }
            0x830DAF4C => {
    //   block [0x830DAF4C..0x830DAF64)
	// 830DAF4C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DAF50: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 830DAF54: 4BC7AB8D  bl 0x82d55ae0
	ctx.lr = 0x830DAF58;
	sub_82D55AE0(ctx, base);
	// 830DAF58: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830DAF5C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830DAF60: 4099002C  ble cr6, 0x830daf8c
	if !ctx.cr[6].gt {
	pc = 0x830DAF8C; continue 'dispatch;
	}
	pc = 0x830DAF64; continue 'dispatch;
            }
            0x830DAF64 => {
    //   block [0x830DAF64..0x830DAF8C)
	// 830DAF64: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 830DAF68: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 830DAF6C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830DAF70: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DAF74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DAF78: 4BFFF541  bl 0x830da4b8
	ctx.lr = 0x830DAF7C;
	sub_830DA4B8(ctx, base);
	// 830DAF7C: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 830DAF80: 7FDBF214  add r30, r27, r30
	ctx.r[30].u64 = ctx.r[27].u64 + ctx.r[30].u64;
	// 830DAF84: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830DAF88: 409AFFDC  bne cr6, 0x830daf64
	if !ctx.cr[6].eq {
	pc = 0x830DAF64; continue 'dispatch;
	}
	pc = 0x830DAF8C; continue 'dispatch;
            }
            0x830DAF8C => {
    //   block [0x830DAF8C..0x830DAFB4)
	// 830DAF8C: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 830DAF90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DAF94: 4BFFF475  bl 0x830da408
	ctx.lr = 0x830DAF98;
	sub_830DA408(ctx, base);
	// 830DAF98: 3880000A  li r4, 0xa
	ctx.r[4].s64 = 10;
	// 830DAF9C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DAFA0: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DAFA4: 4BC7CDFD  bl 0x82d57da0
	ctx.lr = 0x830DAFA8;
	sub_82D57DA0(ctx, base);
	// 830DAFA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DAFAC: 4BC7CE45  bl 0x82d57df0
	ctx.lr = 0x830DAFB0;
	sub_82D57DF0(ctx, base);
	// 830DAFB0: 480003B8  b 0x830db368
	pc = 0x830DB368; continue 'dispatch;
            }
            0x830DAFB4 => {
    //   block [0x830DAFB4..0x830DB068)
	// 830DAFB4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DAFB8: 83980000  lwz r28, 0(r24)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DAFBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DAFC0: 4BFFF449  bl 0x830da408
	ctx.lr = 0x830DAFC4;
	sub_830DA408(ctx, base);
	// 830DAFC4: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DAFC8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DAFCC: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DAFD0: 388B9F50  addi r4, r11, -0x60b0
	ctx.r[4].s64 = ctx.r[11].s64 + -24752;
	// 830DAFD4: 4BC7D15D  bl 0x82d58130
	ctx.lr = 0x830DAFD8;
	sub_82D58130(ctx, base);
	// 830DAFD8: 39610074  addi r11, r1, 0x74
	ctx.r[11].s64 = ctx.r[1].s64 + 116;
	// 830DAFDC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830DAFE0: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 830DAFE4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DAFE8: 394A86B4  addi r10, r10, -0x794c
	ctx.r[10].s64 = ctx.r[10].s64 + -31052;
	// 830DAFEC: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830DAFF0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830DAFF4: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830DAFF8: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 830DAFFC: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 830DB000: 4BC7A751  bl 0x82d55750
	ctx.lr = 0x830DB004;
	sub_82D55750(ctx, base);
	// 830DB004: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830DB008: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 830DB00C: 3BAB7634  addi r29, r11, 0x7634
	ctx.r[29].s64 = ctx.r[11].s64 + 30260;
	// 830DB010: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830DB014: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DB018: 396B3D6C  addi r11, r11, 0x3d6c
	ctx.r[11].s64 = ctx.r[11].s64 + 15724;
	// 830DB01C: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 830DB020: 4BC7A731  bl 0x82d55750
	ctx.lr = 0x830DB024;
	sub_82D55750(ctx, base);
	// 830DB024: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830DB028: 9061007C  stw r3, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 830DB02C: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 830DB030: 80990008  lwz r4, 8(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DB034: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830DB038: 3B4A9C40  addi r26, r10, -0x63c0
	ctx.r[26].s64 = ctx.r[10].s64 + -25536;
	// 830DB03C: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 830DB040: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830DB044: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 830DB048: 9AE10050  stb r23, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u8 ) };
	// 830DB04C: 88EB0000  lbz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB050: 4BFFF5C1  bl 0x830da610
	ctx.lr = 0x830DB054;
	sub_830DA610(ctx, base);
	// 830DB054: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DB058: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 830DB05C: 4BC7A905  bl 0x82d55960
	ctx.lr = 0x830DB060;
	sub_82D55960(ctx, base);
	// 830DB060: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DB064: 4099003C  ble cr6, 0x830db0a0
	if !ctx.cr[6].gt {
	pc = 0x830DB0A0; continue 'dispatch;
	}
	pc = 0x830DB068; continue 'dispatch;
            }
            0x830DB068 => {
    //   block [0x830DB068..0x830DB0A0)
	// 830DB068: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830DB06C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DB070: 4BC7A919  bl 0x82d55988
	ctx.lr = 0x830DB074;
	sub_82D55988(ctx, base);
	// 830DB074: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830DB078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DB07C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830DB080: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 830DB084: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 830DB088: 4BFFFA29  bl 0x830daab0
	ctx.lr = 0x830DB08C;
	sub_830DAAB0(ctx, base);
	// 830DB08C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DB090: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 830DB094: 4BC7A8CD  bl 0x82d55960
	ctx.lr = 0x830DB098;
	sub_82D55960(ctx, base);
	// 830DB098: 7F1B1800  cmpw cr6, r27, r3
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[3].s32, &mut ctx.xer);
	// 830DB09C: 4198FFCC  blt cr6, 0x830db068
	if ctx.cr[6].lt {
	pc = 0x830DB068; continue 'dispatch;
	}
	pc = 0x830DB0A0; continue 'dispatch;
            }
            0x830DB0A0 => {
    //   block [0x830DB0A0..0x830DB0F0)
	// 830DB0A0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830DB0A4: 9AE10050  stb r23, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u8 ) };
	// 830DB0A8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 830DB0AC: 80990008  lwz r4, 8(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DB0B0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830DB0B4: 88CB0000  lbz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB0B8: 4BFFF659  bl 0x830da710
	ctx.lr = 0x830DB0BC;
	sub_830DA710(ctx, base);
	// 830DB0BC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DB0C0: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB0C4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DB0C8: 388B9F30  addi r4, r11, -0x60d0
	ctx.r[4].s64 = ctx.r[11].s64 + -24784;
	// 830DB0CC: 4BC7D065  bl 0x82d58130
	ctx.lr = 0x830DB0D0;
	sub_82D58130(ctx, base);
	// 830DB0D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DB0D4: 3B780004  addi r27, r24, 4
	ctx.r[27].s64 = ctx.r[24].s64 + 4;
	// 830DB0D8: 4BC7AA09  bl 0x82d55ae0
	ctx.lr = 0x830DB0DC;
	sub_82D55AE0(ctx, base);
	// 830DB0DC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DB0E0: 83BB0000  lwz r29, 0(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB0E4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830DB0E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DB0EC: 40990030  ble cr6, 0x830db11c
	if !ctx.cr[6].gt {
	pc = 0x830DB11C; continue 'dispatch;
	}
	pc = 0x830DB0F0; continue 'dispatch;
            }
            0x830DB0F0 => {
    //   block [0x830DB0F0..0x830DB11C)
	// 830DB0F0: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 830DB0F4: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 830DB0F8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830DB0FC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DB100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DB104: 4BFFF3B5  bl 0x830da4b8
	ctx.lr = 0x830DB108;
	sub_830DA4B8(ctx, base);
	// 830DB108: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DB10C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830DB110: 7FBDD214  add r29, r29, r26
	ctx.r[29].u64 = ctx.r[29].u64 + ctx.r[26].u64;
	// 830DB114: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DB118: 4198FFD8  blt cr6, 0x830db0f0
	if ctx.cr[6].lt {
	pc = 0x830DB0F0; continue 'dispatch;
	}
	pc = 0x830DB11C; continue 'dispatch;
            }
            0x830DB11C => {
    //   block [0x830DB11C..0x830DB12C)
	// 830DB11C: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 830DB120: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DB124: 4BFFF2E5  bl 0x830da408
	ctx.lr = 0x830DB128;
	sub_830DA408(ctx, base);
	// 830DB128: 48000240  b 0x830db368
	pc = 0x830DB368; continue 'dispatch;
            }
            0x830DB12C => {
    //   block [0x830DB12C..0x830DB144)
	// 830DB12C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DB130: 4BC81C41  bl 0x82d5cd70
	ctx.lr = 0x830DB134;
	sub_82D5CD70(ctx, base);
	// 830DB134: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DB138: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DB13C: 409A0008  bne cr6, 0x830db144
	if !ctx.cr[6].eq {
	pc = 0x830DB144; continue 'dispatch;
	}
	// 830DB140: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x830DB144; continue 'dispatch;
            }
            0x830DB144 => {
    //   block [0x830DB144..0x830DB168)
	// 830DB144: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830DB148: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830DB14C: 4099021C  ble cr6, 0x830db368
	if !ctx.cr[6].gt {
	pc = 0x830DB368; continue 'dispatch;
	}
	// 830DB150: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DB154: 3BAB9E98  addi r29, r11, -0x6168
	ctx.r[29].s64 = ctx.r[11].s64 + -24936;
	// 830DB158: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830DB15C: 3B8B0CA0  addi r28, r11, 0xca0
	ctx.r[28].s64 = ctx.r[11].s64 + 3232;
	// 830DB160: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 830DB164: 3B6B4A00  addi r27, r11, 0x4a00
	ctx.r[27].s64 = ctx.r[11].s64 + 18944;
	pc = 0x830DB168; continue 'dispatch;
            }
            0x830DB168 => {
    //   block [0x830DB168..0x830DB1D0)
	// 830DB168: 80980000  lwz r4, 0(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB16C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830DB170: 419A0074  beq cr6, 0x830db1e4
	if ctx.cr[6].eq {
	pc = 0x830DB1E4; continue 'dispatch;
	}
	// 830DB174: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DB178: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DB17C: 419A0068  beq cr6, 0x830db1e4
	if ctx.cr[6].eq {
	pc = 0x830DB1E4; continue 'dispatch;
	}
	// 830DB180: 80750024  lwz r3, 0x24(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(36 as u32) ) } as u64;
	// 830DB184: 38C00100  li r6, 0x100
	ctx.r[6].s64 = 256;
	// 830DB188: 38A101A0  addi r5, r1, 0x1a0
	ctx.r[5].s64 = ctx.r[1].s64 + 416;
	// 830DB18C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB190: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DB194: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DB198: 4E800421  bctrl
	ctx.lr = 0x830DB19C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DB19C: 80750024  lwz r3, 0x24(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(36 as u32) ) } as u64;
	// 830DB1A0: 80980004  lwz r4, 4(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DB1A4: 38C00100  li r6, 0x100
	ctx.r[6].s64 = 256;
	// 830DB1A8: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 830DB1AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB1B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DB1B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DB1B8: 4E800421  bctrl
	ctx.lr = 0x830DB1BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DB1BC: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 830DB1C0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 830DB1C4: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830DB1C8: 41980008  blt cr6, 0x830db1d0
	if ctx.cr[6].lt {
	pc = 0x830DB1D0; continue 'dispatch;
	}
	// 830DB1CC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
            }
            0x830DB1D0 => {
    //   block [0x830DB1D0..0x830DB1E4)
	// 830DB1D0: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 830DB1D4: 38A101A0  addi r5, r1, 0x1a0
	ctx.r[5].s64 = ctx.r[1].s64 + 416;
	// 830DB1D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DB1DC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DB1E0: 4BC7CF51  bl 0x82d58130
	ctx.lr = 0x830DB1E4;
	sub_82D58130(ctx, base);
	pc = 0x830DB1E4; continue 'dispatch;
            }
            0x830DB1E4 => {
    //   block [0x830DB1E4..0x830DB1F8)
	// 830DB1E4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830DB1E8: 3B180008  addi r24, r24, 8
	ctx.r[24].s64 = ctx.r[24].s64 + 8;
	// 830DB1EC: 7F1FF000  cmpw cr6, r31, r30
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830DB1F0: 4198FF78  blt cr6, 0x830db168
	if ctx.cr[6].lt {
	pc = 0x830DB168; continue 'dispatch;
	}
	// 830DB1F4: 48000174  b 0x830db368
	pc = 0x830DB368; continue 'dispatch;
            }
            0x830DB1F8 => {
    //   block [0x830DB1F8..0x830DB25C)
	// 830DB1F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DB1FC: 4BC81B85  bl 0x82d5cd80
	ctx.lr = 0x830DB200;
	sub_82D5CD80(ctx, base);
	// 830DB200: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DB204: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 830DB208: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DB20C: 4BC81E65  bl 0x82d5d070
	ctx.lr = 0x830DB210;
	sub_82D5D070(ctx, base);
	// 830DB210: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830DB214: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 830DB218: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830DB21C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 830DB220: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830DB224: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DB228: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 830DB22C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 830DB230: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830DB234: 4BC8347D  bl 0x82d5e6b0
	ctx.lr = 0x830DB238;
	sub_82D5E6B0(ctx, base);
	// 830DB238: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 830DB23C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830DB240: 3BAA0940  addi r29, r10, 0x940
	ctx.r[29].s64 = ctx.r[10].s64 + 2368;
	// 830DB244: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830DB248: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DB24C: 3B8A0CA0  addi r28, r10, 0xca0
	ctx.r[28].s64 = ctx.r[10].s64 + 3232;
	// 830DB250: 40990044  ble cr6, 0x830db294
	if !ctx.cr[6].gt {
	pc = 0x830DB294; continue 'dispatch;
	}
	// 830DB254: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 830DB258: 3BEB3590  addi r31, r11, 0x3590
	ctx.r[31].s64 = ctx.r[11].s64 + 13712;
	pc = 0x830DB25C; continue 'dispatch;
            }
            0x830DB25C => {
    //   block [0x830DB25C..0x830DB26C)
	// 830DB25C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830DB260: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830DB264: 419A0008  beq cr6, 0x830db26c
	if ctx.cr[6].eq {
	pc = 0x830DB26C; continue 'dispatch;
	}
	// 830DB268: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	pc = 0x830DB26C; continue 'dispatch;
            }
            0x830DB26C => {
    //   block [0x830DB26C..0x830DB294)
	// 830DB26C: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DB270: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DB274: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DB278: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DB27C: 7CCB502E  lwzx r6, r11, r10
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DB280: 4BC7CEB1  bl 0x82d58130
	ctx.lr = 0x830DB284;
	sub_82D58130(ctx, base);
	// 830DB284: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830DB288: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830DB28C: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DB290: 4198FFCC  blt cr6, 0x830db25c
	if ctx.cr[6].lt {
	pc = 0x830DB25C; continue 'dispatch;
	}
	pc = 0x830DB294; continue 'dispatch;
            }
            0x830DB294 => {
    //   block [0x830DB294..0x830DB2B0)
	// 830DB294: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830DB298: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 830DB29C: 419A0028  beq cr6, 0x830db2c4
	if ctx.cr[6].eq {
	pc = 0x830DB2C4; continue 'dispatch;
	}
	// 830DB2A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DB2A4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830DB2A8: 419A0008  beq cr6, 0x830db2b0
	if ctx.cr[6].eq {
	pc = 0x830DB2B0; continue 'dispatch;
	}
	// 830DB2AC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	pc = 0x830DB2B0; continue 'dispatch;
            }
            0x830DB2B0 => {
    //   block [0x830DB2B0..0x830DB2C4)
	// 830DB2B0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DB2B4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DB2B8: 388B9F14  addi r4, r11, -0x60ec
	ctx.r[4].s64 = ctx.r[11].s64 + -24812;
	// 830DB2BC: 4BC7CE75  bl 0x82d58130
	ctx.lr = 0x830DB2C0;
	sub_82D58130(ctx, base);
	// 830DB2C0: 4800001C  b 0x830db2dc
	pc = 0x830DB2DC; continue 'dispatch;
            }
            0x830DB2C4 => {
    //   block [0x830DB2C4..0x830DB2DC)
	// 830DB2C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DB2C8: 409A0014  bne cr6, 0x830db2dc
	if !ctx.cr[6].eq {
	pc = 0x830DB2DC; continue 'dispatch;
	}
	// 830DB2CC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 830DB2D0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DB2D4: 388B7088  addi r4, r11, 0x7088
	ctx.r[4].s64 = ctx.r[11].s64 + 28808;
	// 830DB2D8: 4BC7CE59  bl 0x82d58130
	ctx.lr = 0x830DB2DC;
	sub_82D58130(ctx, base);
	pc = 0x830DB2DC; continue 'dispatch;
            }
            0x830DB2DC => {
    //   block [0x830DB2DC..0x830DB30C)
	// 830DB2DC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DB2E0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DB2E4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DB2E8: 409A0080  bne cr6, 0x830db368
	if !ctx.cr[6].eq {
	pc = 0x830DB368; continue 'dispatch;
	}
	// 830DB2EC: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB2F0: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DB2F4: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DB2F8: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DB2FC: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830DB300: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DB304: 4BC79FC5  bl 0x82d552c8
	ctx.lr = 0x830DB308;
	sub_82D552C8(ctx, base);
	// 830DB308: 48000060  b 0x830db368
	pc = 0x830DB368; continue 'dispatch;
            }
            0x830DB30C => {
    //   block [0x830DB30C..0x830DB368)
	// 830DB30C: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 830DB310: 388103A0  addi r4, r1, 0x3a0
	ctx.r[4].s64 = ctx.r[1].s64 + 928;
	// 830DB314: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 830DB318: 4BC7C6D1  bl 0x82d579e8
	ctx.lr = 0x830DB31C;
	sub_82D579E8(ctx, base);
	// 830DB31C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DB320: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 830DB324: 388B9EF4  addi r4, r11, -0x610c
	ctx.r[4].s64 = ctx.r[11].s64 + -24844;
	// 830DB328: 4BC7CAC9  bl 0x82d57df0
	ctx.lr = 0x830DB32C;
	sub_82D57DF0(ctx, base);
	// 830DB32C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830DB330: 3CA040A1  lis r5, 0x40a1
	ctx.r[5].s64 = 1084293120;
	// 830DB334: 39000309  li r8, 0x309
	ctx.r[8].s64 = 777;
	// 830DB338: 38C103A0  addi r6, r1, 0x3a0
	ctx.r[6].s64 = ctx.r[1].s64 + 928;
	// 830DB33C: 60A58B57  ori r5, r5, 0x8b57
	ctx.r[5].u64 = ctx.r[5].u64 | 35671;
	// 830DB340: 806B7630  lwz r3, 0x7630(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30256 as u32) ) } as u64;
	// 830DB344: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DB348: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 830DB34C: 38EB9ECC  addi r7, r11, -0x6134
	ctx.r[7].s64 = ctx.r[11].s64 + -24884;
	// 830DB350: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB354: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DB358: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DB35C: 4E800421  bctrl
	ctx.lr = 0x830DB360;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DB360: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 830DB364: 4BC7D0CD  bl 0x82d58430
	ctx.lr = 0x830DB368;
	sub_82D58430(ctx, base);
            }
            0x830DB368 => {
    //   block [0x830DB368..0x830DB380)
	// 830DB368: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DB36C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DB370: 388B9EC0  addi r4, r11, -0x6140
	ctx.r[4].s64 = ctx.r[11].s64 + -24896;
	// 830DB374: 4BC7CDBD  bl 0x82d58130
	ctx.lr = 0x830DB378;
	sub_82D58130(ctx, base);
	// 830DB378: 38210600  addi r1, r1, 0x600
	ctx.r[1].s64 = ctx.r[1].s64 + 1536;
	// 830DB37C: 4BBCE0C0  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DB380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DB380 size=616
    let mut pc: u32 = 0x830DB380;
    'dispatch: loop {
        match pc {
            0x830DB380 => {
    //   block [0x830DB380..0x830DB3C4)
	// 830DB380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DB384: 4BBCE071  bl 0x82ca93f4
	ctx.lr = 0x830DB388;
	sub_82CA93D0(ctx, base);
	// 830DB388: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DB38C: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 830DB390: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830DB394: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830DB398: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830DB39C: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 830DB3A0: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 830DB3A4: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 830DB3A8: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 830DB3AC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830DB3B0: 419A0028  beq cr6, 0x830db3d8
	if ctx.cr[6].eq {
	pc = 0x830DB3D8; continue 'dispatch;
	}
	// 830DB3B4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB3B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DB3BC: 419A001C  beq cr6, 0x830db3d8
	if ctx.cr[6].eq {
	pc = 0x830DB3D8; continue 'dispatch;
	}
	// 830DB3C0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x830DB3C4; continue 'dispatch;
            }
            0x830DB3C4 => {
    //   block [0x830DB3C4..0x830DB3D8)
	// 830DB3C4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830DB3C8: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 830DB3CC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB3D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830DB3D4: 409AFFF0  bne cr6, 0x830db3c4
	if !ctx.cr[6].eq {
	pc = 0x830DB3C4; continue 'dispatch;
	}
	pc = 0x830DB3D8; continue 'dispatch;
            }
            0x830DB3D8 => {
    //   block [0x830DB3D8..0x830DB400)
	// 830DB3D8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 830DB3DC: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 830DB3E0: 3F808000  lis r28, -0x8000
	ctx.r[28].s64 = -2147483648;
	// 830DB3E4: 395B0005  addi r10, r27, 5
	ctx.r[10].s64 = ctx.r[27].s64 + 5;
	// 830DB3E8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DB3EC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830DB3F0: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 830DB3F4: 40990020  ble cr6, 0x830db414
	if !ctx.cr[6].gt {
	pc = 0x830DB414; continue 'dispatch;
	}
	// 830DB3F8: 40980008  bge cr6, 0x830db400
	if !ctx.cr[6].lt {
	pc = 0x830DB400; continue 'dispatch;
	}
	// 830DB3FC: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x830DB400; continue 'dispatch;
            }
            0x830DB400 => {
    //   block [0x830DB400..0x830DB414)
	// 830DB400: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 830DB404: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 830DB408: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830DB40C: 4BC7BB05  bl 0x82d56f10
	ctx.lr = 0x830DB410;
	sub_82D56F10(ctx, base);
	// 830DB410: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x830DB414; continue 'dispatch;
            }
            0x830DB414 => {
    //   block [0x830DB414..0x830DB454)
	// 830DB414: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 830DB418: 419A003C  beq cr6, 0x830db454
	if ctx.cr[6].eq {
	pc = 0x830DB454; continue 'dispatch;
	}
	// 830DB41C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 830DB420: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DB424: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DB428: 394A86B4  addi r10, r10, -0x794c
	ctx.r[10].s64 = ctx.r[10].s64 + -31052;
	// 830DB42C: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 830DB430: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830DB434: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DB438: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830DB43C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830DB440: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DB444: 7F0B512E  stwx r24, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[24].u32) };
	// 830DB448: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830DB44C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830DB450: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	pc = 0x830DB454; continue 'dispatch;
            }
            0x830DB454 => {
    //   block [0x830DB454..0x830DB4C4)
	// 830DB454: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 830DB458: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DB45C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DB460: 394A3D6C  addi r10, r10, 0x3d6c
	ctx.r[10].s64 = ctx.r[10].s64 + 15724;
	// 830DB464: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830DB468: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 830DB46C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830DB470: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830DB474: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830DB478: 4BC7A2D9  bl 0x82d55750
	ctx.lr = 0x830DB47C;
	sub_82D55750(ctx, base);
	// 830DB47C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830DB480: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830DB484: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DB488: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DB48C: 7C6B512E  stwx r3, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[3].u32) };
	// 830DB490: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830DB494: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830DB498: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830DB49C: 419A0028  beq cr6, 0x830db4c4
	if ctx.cr[6].eq {
	pc = 0x830DB4C4; continue 'dispatch;
	}
	// 830DB4A0: 7D4BDA14  add r10, r11, r27
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830DB4A4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DB4A8: 5765103A  slwi r5, r27, 2
	ctx.r[5].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830DB4AC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830DB4B0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 830DB4B4: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DB4B8: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830DB4BC: 4BC7D875  bl 0x82d58d30
	ctx.lr = 0x830DB4C0;
	sub_82D58D30(ctx, base);
	// 830DB4C0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x830DB4C4; continue 'dispatch;
            }
            0x830DB4C4 => {
    //   block [0x830DB4C4..0x830DB5DC)
	// 830DB4C4: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830DB4C8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DB4CC: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 830DB4D0: 3BCB9C40  addi r30, r11, -0x63c0
	ctx.r[30].s64 = ctx.r[11].s64 + -25536;
	// 830DB4D4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DB4D8: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830DB4DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DB4E0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830DB4E4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830DB4E8: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 830DB4EC: 7FE9592E  stwx r31, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[31].u32) };
	// 830DB4F0: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830DB4F4: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DB4F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830DB4FC: 88EA0000  lbz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB500: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830DB504: 4BFFF10D  bl 0x830da610
	ctx.lr = 0x830DB508;
	sub_830DA610(ctx, base);
	// 830DB508: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB50C: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 830DB510: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 830DB514: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 830DB518: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 830DB51C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 830DB520: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 830DB524: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DB528: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 830DB52C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830DB530: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DB534: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 830DB538: 93810084  stw r28, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[28].u32 ) };
	// 830DB53C: 93E10088  stw r31, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[31].u32 ) };
	// 830DB540: 93E1008C  stw r31, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[31].u32 ) };
	// 830DB544: 93810090  stw r28, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[28].u32 ) };
	// 830DB548: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 830DB54C: 93E10098  stw r31, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[31].u32 ) };
	// 830DB550: 9381009C  stw r28, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[28].u32 ) };
	// 830DB554: 93E100A0  stw r31, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[31].u32 ) };
	// 830DB558: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DB55C: 4E800421  bctrl
	ctx.lr = 0x830DB560;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DB560: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830DB564: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DB568: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 830DB56C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830DB570: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830DB574: 88CB0000  lbz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB578: 4BFFF199  bl 0x830da710
	ctx.lr = 0x830DB57C;
	sub_830DA710(ctx, base);
	// 830DB57C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB580: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DB584: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830DB588: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DB58C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DB590: 4E800421  bctrl
	ctx.lr = 0x830DB594;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DB594: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830DB598: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830DB59C: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB5A0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DB5A4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830DB5A8: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830DB5AC: 4BC9A07D  bl 0x82d75628
	ctx.lr = 0x830DB5B0;
	sub_82D75628(ctx, base);
	// 830DB5B0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DB5B4: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DB5B8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DB5BC: 409A0020  bne cr6, 0x830db5dc
	if !ctx.cr[6].eq {
	pc = 0x830DB5DC; continue 'dispatch;
	}
	// 830DB5C0: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB5C4: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DB5C8: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DB5CC: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DB5D0: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830DB5D4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DB5D8: 4BC79CF1  bl 0x82d552c8
	ctx.lr = 0x830DB5DC;
	sub_82D552C8(ctx, base);
            }
            0x830DB5DC => {
    //   block [0x830DB5DC..0x830DB5E8)
	// 830DB5DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DB5E0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 830DB5E4: 4BBCDE60  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DB5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DB5E8 size=168
    let mut pc: u32 = 0x830DB5E8;
    'dispatch: loop {
        match pc {
            0x830DB5E8 => {
    //   block [0x830DB5E8..0x830DB620)
	// 830DB5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DB5EC: 4BBCDE15  bl 0x82ca9400
	ctx.lr = 0x830DB5F0;
	sub_82CA93D0(ctx, base);
	// 830DB5F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DB5F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830DB5F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830DB5FC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830DB600: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 830DB604: 4BC7CC95  bl 0x82d58298
	ctx.lr = 0x830DB608;
	sub_82D58298(ctx, base);
	// 830DB608: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DB60C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830DB610: 4BC7A351  bl 0x82d55960
	ctx.lr = 0x830DB614;
	sub_82D55960(ctx, base);
	// 830DB614: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DB618: 40990044  ble cr6, 0x830db65c
	if !ctx.cr[6].gt {
	pc = 0x830DB65C; continue 'dispatch;
	}
	// 830DB61C: 3B7D0008  addi r27, r29, 8
	ctx.r[27].s64 = ctx.r[29].s64 + 8;
	pc = 0x830DB620; continue 'dispatch;
            }
            0x830DB620 => {
    //   block [0x830DB620..0x830DB65C)
	// 830DB620: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DB624: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DB628: 3B410058  addi r26, r1, 0x58
	ctx.r[26].s64 = ctx.r[1].s64 + 88;
	// 830DB62C: 4BC7A35D  bl 0x82d55988
	ctx.lr = 0x830DB630;
	sub_82D55988(ctx, base);
	// 830DB630: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830DB634: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830DB638: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830DB63C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 830DB640: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830DB644: 4BFFF46D  bl 0x830daab0
	ctx.lr = 0x830DB648;
	sub_830DAAB0(ctx, base);
	// 830DB648: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DB64C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830DB650: 4BC7A311  bl 0x82d55960
	ctx.lr = 0x830DB654;
	sub_82D55960(ctx, base);
	// 830DB654: 7F1F1800  cmpw cr6, r31, r3
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[3].s32, &mut ctx.xer);
	// 830DB658: 4198FFC8  blt cr6, 0x830db620
	if ctx.cr[6].lt {
	pc = 0x830DB620; continue 'dispatch;
	}
	pc = 0x830DB65C; continue 'dispatch;
            }
            0x830DB65C => {
    //   block [0x830DB65C..0x830DB690)
	// 830DB65C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830DB660: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830DB664: 4BC7C60D  bl 0x82d57c70
	ctx.lr = 0x830DB668;
	sub_82D57C70(ctx, base);
	// 830DB668: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830DB66C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830DB670: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB674: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DB678: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830DB67C: 557FDFFE  rlwinm r31, r11, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830DB680: 4BC7CDB1  bl 0x82d58430
	ctx.lr = 0x830DB684;
	sub_82D58430(ctx, base);
	// 830DB684: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DB688: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830DB68C: 4BBCDDC4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DB690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DB690 size=152
    let mut pc: u32 = 0x830DB690;
    'dispatch: loop {
        match pc {
            0x830DB690 => {
    //   block [0x830DB690..0x830DB6D8)
	// 830DB690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DB694: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830DB698: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830DB69C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830DB6A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DB6A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DB6A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830DB6AC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DB6B0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DB6B4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DB6B8: 409A0020  bne cr6, 0x830db6d8
	if !ctx.cr[6].eq {
	pc = 0x830DB6D8; continue 'dispatch;
	}
	// 830DB6BC: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB6C0: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DB6C4: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DB6C8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DB6CC: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DB6D0: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DB6D4: 4BC79BF5  bl 0x82d552c8
	ctx.lr = 0x830DB6D8;
	sub_82D552C8(ctx, base);
	pc = 0x830DB6D8; continue 'dispatch;
            }
            0x830DB6D8 => {
    //   block [0x830DB6D8..0x830DB70C)
	// 830DB6D8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830DB6DC: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 830DB6E0: 396B39E0  addi r11, r11, 0x39e0
	ctx.r[11].s64 = ctx.r[11].s64 + 14816;
	// 830DB6E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830DB6E8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830DB6EC: 419A0020  beq cr6, 0x830db70c
	if ctx.cr[6].eq {
	pc = 0x830DB70C; continue 'dispatch;
	}
	// 830DB6F0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB6F4: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830DB6F8: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 830DB6FC: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DB700: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DB704: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830DB708: 4BC79BC1  bl 0x82d552c8
	ctx.lr = 0x830DB70C;
	sub_82D552C8(ctx, base);
	pc = 0x830DB70C; continue 'dispatch;
            }
            0x830DB70C => {
    //   block [0x830DB70C..0x830DB728)
	// 830DB70C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DB710: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830DB714: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830DB718: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830DB71C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830DB720: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830DB724: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DB728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830DB728 size=4
    let mut pc: u32 = 0x830DB728;
    'dispatch: loop {
        match pc {
            0x830DB728 => {
    //   block [0x830DB728..0x830DB72C)
	// 830DB728: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DB730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830DB730 size=4
    let mut pc: u32 = 0x830DB730;
    'dispatch: loop {
        match pc {
            0x830DB730 => {
    //   block [0x830DB730..0x830DB734)
	// 830DB730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DB738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DB738 size=392
    let mut pc: u32 = 0x830DB738;
    'dispatch: loop {
        match pc {
            0x830DB738 => {
    //   block [0x830DB738..0x830DB788)
	// 830DB738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DB73C: 4BBCDCA9  bl 0x82ca93e4
	ctx.lr = 0x830DB740;
	sub_82CA93D0(ctx, base);
	// 830DB740: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DB744: 89640000  lbz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB748: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 830DB74C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830DB750: 7E7A9B78  mr r26, r19
	ctx.r[26].u64 = ctx.r[19].u64;
	// 830DB754: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 830DB758: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DB75C: 419A0154  beq cr6, 0x830db8b0
	if ctx.cr[6].eq {
	pc = 0x830DB8B0; continue 'dispatch;
	}
	// 830DB760: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DB764: 3B0BA388  addi r24, r11, -0x5c78
	ctx.r[24].s64 = ctx.r[11].s64 + -23672;
	// 830DB768: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DB76C: 3AEBA380  addi r23, r11, -0x5c80
	ctx.r[23].s64 = ctx.r[11].s64 + -23680;
	// 830DB770: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DB774: 3ACBA378  addi r22, r11, -0x5c88
	ctx.r[22].s64 = ctx.r[11].s64 + -23688;
	// 830DB778: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DB77C: 3AABA374  addi r21, r11, -0x5c8c
	ctx.r[21].s64 = ctx.r[11].s64 + -23692;
	// 830DB780: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DB784: 3B2BA370  addi r25, r11, -0x5c90
	ctx.r[25].s64 = ctx.r[11].s64 + -23696;
	pc = 0x830DB788; continue 'dispatch;
            }
            0x830DB788 => {
    //   block [0x830DB788..0x830DB7AC)
	// 830DB788: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB78C: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 830DB790: 2B0B0026  cmplwi cr6, r11, 0x26
	ctx.cr[6].compare_u32(ctx.r[11].u32, 38 as u32, &mut ctx.xer);
	// 830DB794: 409A0108  bne cr6, 0x830db89c
	if !ctx.cr[6].eq {
	pc = 0x830DB89C; continue 'dispatch;
	}
	// 830DB798: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB79C: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 830DB7A0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DB7A4: 2F0B003B  cmpwi cr6, r11, 0x3b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 59, &mut ctx.xer);
	// 830DB7A8: 419A0020  beq cr6, 0x830db7c8
	if ctx.cr[6].eq {
	pc = 0x830DB7C8; continue 'dispatch;
	}
	pc = 0x830DB7AC; continue 'dispatch;
            }
            0x830DB7AC => {
    //   block [0x830DB7AC..0x830DB7C8)
	// 830DB7AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DB7B0: 419A00E0  beq cr6, 0x830db890
	if ctx.cr[6].eq {
	pc = 0x830DB890; continue 'dispatch;
	}
	// 830DB7B4: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 830DB7B8: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB7BC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DB7C0: 2F0B003B  cmpwi cr6, r11, 0x3b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 59, &mut ctx.xer);
	// 830DB7C4: 409AFFE8  bne cr6, 0x830db7ac
	if !ctx.cr[6].eq {
	pc = 0x830DB7AC; continue 'dispatch;
	}
	pc = 0x830DB7C8; continue 'dispatch;
            }
            0x830DB7C8 => {
    //   block [0x830DB7C8..0x830DB810)
	// 830DB7C8: 897C0000  lbz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB7CC: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 830DB7D0: 2B0B0023  cmplwi cr6, r11, 0x23
	ctx.cr[6].compare_u32(ctx.r[11].u32, 35 as u32, &mut ctx.xer);
	// 830DB7D4: 409A003C  bne cr6, 0x830db810
	if !ctx.cr[6].eq {
	pc = 0x830DB810; continue 'dispatch;
	}
	// 830DB7D8: 7D7CD850  subf r11, r28, r27
	ctx.r[11].s64 = ctx.r[27].s64 - ctx.r[28].s64;
	// 830DB7DC: 3BEBFFFE  addi r31, r11, -2
	ctx.r[31].s64 = ctx.r[11].s64 + -2;
	// 830DB7E0: 2F1F000A  cmpwi cr6, r31, 0xa
	ctx.cr[6].compare_i32(ctx.r[31].s32, 10, &mut ctx.xer);
	// 830DB7E4: 409800AC  bge cr6, 0x830db890
	if !ctx.cr[6].lt {
	pc = 0x830DB890; continue 'dispatch;
	}
	// 830DB7E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830DB7EC: 389C0001  addi r4, r28, 1
	ctx.r[4].s64 = ctx.r[28].s64 + 1;
	// 830DB7F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830DB7F4: 4BC7D425  bl 0x82d58c18
	ctx.lr = 0x830DB7F8;
	sub_82D58C18(ctx, base);
	// 830DB7F8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830DB7FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830DB800: 7E9F59AE  stbx r20, r31, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[20].u8) };
	// 830DB804: 4BC7D44D  bl 0x82d58c50
	ctx.lr = 0x830DB808;
	sub_82D58C50(ctx, base);
	// 830DB808: 987A0000  stb r3, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[3].u8 ) };
	// 830DB80C: 48000094  b 0x830db8a0
	pc = 0x830DB8A0; continue 'dispatch;
            }
            0x830DB810 => {
    //   block [0x830DB810..0x830DB830)
	// 830DB810: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 830DB814: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	// 830DB818: 92A10064  stw r21, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u32 ) };
	// 830DB81C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 830DB820: 92C10068  stw r22, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[22].u32 ) };
	// 830DB824: 92E1006C  stw r23, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[23].u32 ) };
	// 830DB828: 93010070  stw r24, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[24].u32 ) };
	// 830DB82C: 92810074  stw r20, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[20].u32 ) };
	pc = 0x830DB830; continue 'dispatch;
            }
            0x830DB830 => {
    //   block [0x830DB830..0x830DB874)
	// 830DB830: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 830DB834: 8BAB0000  lbz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB838: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DB83C: 4BC7D3ED  bl 0x82d58c28
	ctx.lr = 0x830DB840;
	sub_82D58C28(ctx, base);
	// 830DB840: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830DB844: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DB848: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DB84C: 4BC7D1BD  bl 0x82d58a08
	ctx.lr = 0x830DB850;
	sub_82D58A08(ctx, base);
	// 830DB850: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DB854: 419A0020  beq cr6, 0x830db874
	if ctx.cr[6].eq {
	pc = 0x830DB874; continue 'dispatch;
	}
	// 830DB858: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830DB85C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 830DB860: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830DB864: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830DB868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DB86C: 409AFFC4  bne cr6, 0x830db830
	if !ctx.cr[6].eq {
	pc = 0x830DB830; continue 'dispatch;
	}
	// 830DB870: 4800000C  b 0x830db87c
	pc = 0x830DB87C; continue 'dispatch;
            }
            0x830DB874 => {
    //   block [0x830DB874..0x830DB87C)
	// 830DB874: 9BBA0000  stb r29, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 830DB878: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	pc = 0x830DB87C; continue 'dispatch;
            }
            0x830DB87C => {
    //   block [0x830DB87C..0x830DB890)
	// 830DB87C: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DB880: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 830DB884: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DB888: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DB88C: 409A0018  bne cr6, 0x830db8a4
	if !ctx.cr[6].eq {
	pc = 0x830DB8A4; continue 'dispatch;
	}
	pc = 0x830DB890; continue 'dispatch;
            }
            0x830DB890 => {
    //   block [0x830DB890..0x830DB89C)
	// 830DB890: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 830DB894: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 830DB898: 4BBCDB9C  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DB89C => {
    //   block [0x830DB89C..0x830DB8A0)
	// 830DB89C: 997A0000  stb r11, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	pc = 0x830DB8A0; continue 'dispatch;
            }
            0x830DB8A0 => {
    //   block [0x830DB8A0..0x830DB8A4)
	// 830DB8A0: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	pc = 0x830DB8A4; continue 'dispatch;
            }
            0x830DB8A4 => {
    //   block [0x830DB8A4..0x830DB8B0)
	// 830DB8A4: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB8A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DB8AC: 409AFEDC  bne cr6, 0x830db788
	if !ctx.cr[6].eq {
	pc = 0x830DB788; continue 'dispatch;
	}
	pc = 0x830DB8B0; continue 'dispatch;
            }
            0x830DB8B0 => {
    //   block [0x830DB8B0..0x830DB8C0)
	// 830DB8B0: 7C73D050  subf r3, r19, r26
	ctx.r[3].s64 = ctx.r[26].s64 - ctx.r[19].s64;
	// 830DB8B4: 9A9A0000  stb r20, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[20].u8 ) };
	// 830DB8B8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 830DB8BC: 4BBCDB78  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DB8C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830DB8C0 size=64
    let mut pc: u32 = 0x830DB8C0;
    'dispatch: loop {
        match pc {
            0x830DB8C0 => {
    //   block [0x830DB8C0..0x830DB8DC)
	// 830DB8C0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830DB8C4: 419A0034  beq cr6, 0x830db8f8
	if ctx.cr[6].eq {
	pc = 0x830DB8F8; continue 'dispatch;
	}
	// 830DB8C8: 89640000  lbz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB8CC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DB8D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DB8D4: 419A0024  beq cr6, 0x830db8f8
	if ctx.cr[6].eq {
	pc = 0x830DB8F8; continue 'dispatch;
	}
	// 830DB8D8: 7C6A0774  extsb r10, r3
	ctx.r[10].s64 = ctx.r[3].s8 as i64;
	pc = 0x830DB8DC; continue 'dispatch;
            }
            0x830DB8DC => {
    //   block [0x830DB8DC..0x830DB8F8)
	// 830DB8DC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DB8E0: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 830DB8E4: 419A001C  beq cr6, 0x830db900
	if ctx.cr[6].eq {
		sub_830DB900(ctx, base);
		return;
	}
	// 830DB8E8: 89640000  lbz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB8EC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DB8F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DB8F4: 409AFFE8  bne cr6, 0x830db8dc
	if !ctx.cr[6].eq {
	pc = 0x830DB8DC; continue 'dispatch;
	}
	pc = 0x830DB8F8; continue 'dispatch;
            }
            0x830DB8F8 => {
    //   block [0x830DB8F8..0x830DB900)
	// 830DB8F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830DB8FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DB900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830DB900 size=8
    let mut pc: u32 = 0x830DB900;
    'dispatch: loop {
        match pc {
            0x830DB900 => {
    //   block [0x830DB900..0x830DB908)
	// 830DB900: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830DB904: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DB908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830DB908 size=268
    let mut pc: u32 = 0x830DB908;
    'dispatch: loop {
        match pc {
            0x830DB908 => {
    //   block [0x830DB908..0x830DB92C)
	// 830DB908: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 830DB90C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 830DB910: 89640000  lbz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB914: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 830DB918: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830DB91C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830DB920: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DB924: 419A00DC  beq cr6, 0x830dba00
	if ctx.cr[6].eq {
	pc = 0x830DBA00; continue 'dispatch;
	}
	// 830DB928: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	pc = 0x830DB92C; continue 'dispatch;
            }
            0x830DB92C => {
    //   block [0x830DB92C..0x830DB970)
	// 830DB92C: 89040000  lbz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB930: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 830DB934: 7D090774  extsb r9, r8
	ctx.r[9].s64 = ctx.r[8].s8 as i64;
	// 830DB938: 2F090020  cmpwi cr6, r9, 0x20
	ctx.cr[6].compare_i32(ctx.r[9].s32, 32, &mut ctx.xer);
	// 830DB93C: 419A0078  beq cr6, 0x830db9b4
	if ctx.cr[6].eq {
	pc = 0x830DB9B4; continue 'dispatch;
	}
	// 830DB940: 2F090009  cmpwi cr6, r9, 9
	ctx.cr[6].compare_i32(ctx.r[9].s32, 9, &mut ctx.xer);
	// 830DB944: 419A0070  beq cr6, 0x830db9b4
	if ctx.cr[6].eq {
	pc = 0x830DB9B4; continue 'dispatch;
	}
	// 830DB948: 2F09000A  cmpwi cr6, r9, 0xa
	ctx.cr[6].compare_i32(ctx.r[9].s32, 10, &mut ctx.xer);
	// 830DB94C: 419A0068  beq cr6, 0x830db9b4
	if ctx.cr[6].eq {
	pc = 0x830DB9B4; continue 'dispatch;
	}
	// 830DB950: 2F09000D  cmpwi cr6, r9, 0xd
	ctx.cr[6].compare_i32(ctx.r[9].s32, 13, &mut ctx.xer);
	// 830DB954: 419A0060  beq cr6, 0x830db9b4
	if ctx.cr[6].eq {
	pc = 0x830DB9B4; continue 'dispatch;
	}
	// 830DB958: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 830DB95C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 830DB960: 419A0030  beq cr6, 0x830db990
	if ctx.cr[6].eq {
	pc = 0x830DB990; continue 'dispatch;
	}
	// 830DB964: 8BC50000  lbz r30, 0(r5)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB968: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830DB96C: 419A0024  beq cr6, 0x830db990
	if ctx.cr[6].eq {
	pc = 0x830DB990; continue 'dispatch;
	}
	pc = 0x830DB970; continue 'dispatch;
            }
            0x830DB970 => {
    //   block [0x830DB970..0x830DB990)
	// 830DB970: 8BCB0000  lbz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB974: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830DB978: 7FDE0774  extsb r30, r30
	ctx.r[30].s64 = ctx.r[30].s8 as i64;
	// 830DB97C: 7F09F000  cmpw cr6, r9, r30
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830DB980: 419A002C  beq cr6, 0x830db9ac
	if ctx.cr[6].eq {
	pc = 0x830DB9AC; continue 'dispatch;
	}
	// 830DB984: 8BCB0000  lbz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB988: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830DB98C: 409AFFE4  bne cr6, 0x830db970
	if !ctx.cr[6].eq {
	pc = 0x830DB970; continue 'dispatch;
	}
	pc = 0x830DB990; continue 'dispatch;
            }
            0x830DB990 => {
    //   block [0x830DB990..0x830DB994)
	// 830DB990: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x830DB994; continue 'dispatch;
            }
            0x830DB994 => {
    //   block [0x830DB994..0x830DB9AC)
	// 830DB994: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830DB998: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DB99C: 409A0018  bne cr6, 0x830db9b4
	if !ctx.cr[6].eq {
	pc = 0x830DB9B4; continue 'dispatch;
	}
	// 830DB9A0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 830DB9A4: 990A0000  stb r8, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 830DB9A8: 48000020  b 0x830db9c8
	pc = 0x830DB9C8; continue 'dispatch;
            }
            0x830DB9AC => {
    //   block [0x830DB9AC..0x830DB9B4)
	// 830DB9AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830DB9B0: 4BFFFFE4  b 0x830db994
	pc = 0x830DB994; continue 'dispatch;
            }
            0x830DB9B4 => {
    //   block [0x830DB9B4..0x830DB9C8)
	// 830DB9B4: 7CEB0774  extsb r11, r7
	ctx.r[11].s64 = ctx.r[7].s8 as i64;
	// 830DB9B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DB9BC: 409A0010  bne cr6, 0x830db9cc
	if !ctx.cr[6].eq {
	pc = 0x830DB9CC; continue 'dispatch;
	}
	// 830DB9C0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830DB9C4: 98CA0000  stb r6, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u8 ) };
	pc = 0x830DB9C8; continue 'dispatch;
            }
            0x830DB9C8 => {
    //   block [0x830DB9C8..0x830DB9CC)
	// 830DB9C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	pc = 0x830DB9CC; continue 'dispatch;
            }
            0x830DB9CC => {
    //   block [0x830DB9CC..0x830DBA00)
	// 830DB9CC: 89640000  lbz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DB9D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DB9D4: 409AFF58  bne cr6, 0x830db92c
	if !ctx.cr[6].eq {
	pc = 0x830DB92C; continue 'dispatch;
	}
	// 830DB9D8: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830DB9DC: 419A0024  beq cr6, 0x830dba00
	if ctx.cr[6].eq {
	pc = 0x830DBA00; continue 'dispatch;
	}
	// 830DB9E0: 7CEB0774  extsb r11, r7
	ctx.r[11].s64 = ctx.r[7].s8 as i64;
	// 830DB9E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DB9E8: 419A0018  beq cr6, 0x830dba00
	if ctx.cr[6].eq {
	pc = 0x830DBA00; continue 'dispatch;
	}
	// 830DB9EC: 9BEAFFFF  stb r31, -1(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-1 as u32), ctx.r[31].u8 ) };
	// 830DB9F0: 7C635050  subf r3, r3, r10
	ctx.r[3].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 830DB9F4: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830DB9F8: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 830DB9FC: 4E800020  blr
	return;
            }
            0x830DBA00 => {
    //   block [0x830DBA00..0x830DBA14)
	// 830DBA00: 9BEA0000  stb r31, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	// 830DBA04: 7C635050  subf r3, r3, r10
	ctx.r[3].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 830DBA08: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830DBA0C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 830DBA10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DBA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830DBA18 size=52
    let mut pc: u32 = 0x830DBA18;
    'dispatch: loop {
        match pc {
            0x830DBA18 => {
    //   block [0x830DBA18..0x830DBA40)
	// 830DBA18: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 830DBA1C: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 830DBA20: 419A0020  beq cr6, 0x830dba40
	if ctx.cr[6].eq {
	pc = 0x830DBA40; continue 'dispatch;
	}
	// 830DBA24: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 830DBA28: 419A0018  beq cr6, 0x830dba40
	if ctx.cr[6].eq {
	pc = 0x830DBA40; continue 'dispatch;
	}
	// 830DBA2C: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 830DBA30: 419A0010  beq cr6, 0x830dba40
	if ctx.cr[6].eq {
	pc = 0x830DBA40; continue 'dispatch;
	}
	// 830DBA34: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 830DBA38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830DBA3C: 409A0008  bne cr6, 0x830dba44
	if !ctx.cr[6].eq {
	pc = 0x830DBA44; continue 'dispatch;
	}
	pc = 0x830DBA40; continue 'dispatch;
            }
            0x830DBA40 => {
    //   block [0x830DBA40..0x830DBA44)
	// 830DBA40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830DBA44; continue 'dispatch;
            }
            0x830DBA44 => {
    //   block [0x830DBA44..0x830DBA4C)
	// 830DBA44: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830DBA48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DBA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830DBA50 size=72
    let mut pc: u32 = 0x830DBA50;
    'dispatch: loop {
        match pc {
            0x830DBA50 => {
    //   block [0x830DBA50..0x830DBA7C)
	// 830DBA50: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DBA54: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DBA58: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 830DBA5C: 419A0020  beq cr6, 0x830dba7c
	if ctx.cr[6].eq {
	pc = 0x830DBA7C; continue 'dispatch;
	}
	// 830DBA60: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 830DBA64: 419A0018  beq cr6, 0x830dba7c
	if ctx.cr[6].eq {
	pc = 0x830DBA7C; continue 'dispatch;
	}
	// 830DBA68: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 830DBA6C: 419A0010  beq cr6, 0x830dba7c
	if ctx.cr[6].eq {
	pc = 0x830DBA7C; continue 'dispatch;
	}
	// 830DBA70: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 830DBA74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830DBA78: 409A0008  bne cr6, 0x830dba80
	if !ctx.cr[6].eq {
	pc = 0x830DBA80; continue 'dispatch;
	}
	pc = 0x830DBA7C; continue 'dispatch;
            }
            0x830DBA7C => {
    //   block [0x830DBA7C..0x830DBA80)
	// 830DBA7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830DBA80; continue 'dispatch;
            }
            0x830DBA80 => {
    //   block [0x830DBA80..0x830DBA98)
	// 830DBA80: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DBA84: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DBA88: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 830DBA8C: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 830DBA90: 4BFFFFC0  b 0x830dba50
	pc = 0x830DBA50; continue 'dispatch;
	// 830DBA94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DBA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DBA98 size=248
    let mut pc: u32 = 0x830DBA98;
    'dispatch: loop {
        match pc {
            0x830DBA98 => {
    //   block [0x830DBA98..0x830DBAC0)
	// 830DBA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DBA9C: 4BBCD969  bl 0x82ca9404
	ctx.lr = 0x830DBAA0;
	sub_82CA93D0(ctx, base);
	// 830DBAA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DBAA4: 3D602D2D  lis r11, 0x2d2d
	ctx.r[11].s64 = 757923840;
	// 830DBAA8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830DBAAC: 616B3E00  ori r11, r11, 0x3e00
	ctx.r[11].u64 = ctx.r[11].u64 | 15872;
	// 830DBAB0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830DBAB4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830DBAB8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830DBABC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x830DBAC0; continue 'dispatch;
            }
            0x830DBAC0 => {
    //   block [0x830DBAC0..0x830DBACC)
	// 830DBAC0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830DBAC4: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830DBAC8: 40990050  ble cr6, 0x830dbb18
	if !ctx.cr[6].gt {
	pc = 0x830DBB18; continue 'dispatch;
	}
	pc = 0x830DBACC; continue 'dispatch;
            }
            0x830DBACC => {
    //   block [0x830DBACC..0x830DBB00)
	// 830DBACC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830DBAD0: 7D7FE8AE  lbzx r11, r31, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830DBAD4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DBAD8: 7D5E50AE  lbzx r10, r30, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DBADC: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 830DBAE0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830DBAE4: 409A001C  bne cr6, 0x830dbb00
	if !ctx.cr[6].eq {
	pc = 0x830DBB00; continue 'dispatch;
	}
	// 830DBAE8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830DBAEC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830DBAF0: 7D7E58AE  lbzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830DBAF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DBAF8: 419A0020  beq cr6, 0x830dbb18
	if ctx.cr[6].eq {
	pc = 0x830DBB18; continue 'dispatch;
	}
	// 830DBAFC: 48000010  b 0x830dbb0c
	pc = 0x830DBB0C; continue 'dispatch;
            }
            0x830DBB00 => {
    //   block [0x830DBB00..0x830DBB0C)
	// 830DBB00: 2F0B002D  cmpwi cr6, r11, 0x2d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 45, &mut ctx.xer);
	// 830DBB04: 419A0008  beq cr6, 0x830dbb0c
	if ctx.cr[6].eq {
	pc = 0x830DBB0C; continue 'dispatch;
	}
	// 830DBB08: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x830DBB0C; continue 'dispatch;
            }
            0x830DBB0C => {
    //   block [0x830DBB0C..0x830DBB18)
	// 830DBB0C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830DBB10: 7F1F2000  cmpw cr6, r31, r4
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[4].s32, &mut ctx.xer);
	// 830DBB14: 4198FFB8  blt cr6, 0x830dbacc
	if ctx.cr[6].lt {
	pc = 0x830DBACC; continue 'dispatch;
	}
	pc = 0x830DBB18; continue 'dispatch;
            }
            0x830DBB18 => {
    //   block [0x830DBB18..0x830DBB64)
	// 830DBB18: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DBB1C: 7F1F2000  cmpw cr6, r31, r4
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[4].s32, &mut ctx.xer);
	// 830DBB20: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DBB24: 409A0040  bne cr6, 0x830dbb64
	if !ctx.cr[6].eq {
	pc = 0x830DBB64; continue 'dispatch;
	}
	// 830DBB28: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830DBB2C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830DBB30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DBB34: 4E800421  bctrl
	ctx.lr = 0x830DBB38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DBB38: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DBB3C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830DBB40: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DBB44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DBB48: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DBB4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DBB50: 4E800421  bctrl
	ctx.lr = 0x830DBB54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DBB54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830DBB58: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830DBB5C: 419A002C  beq cr6, 0x830dbb88
	if ctx.cr[6].eq {
	pc = 0x830DBB88; continue 'dispatch;
	}
	// 830DBB60: 4BFFFF60  b 0x830dbac0
	pc = 0x830DBAC0; continue 'dispatch;
            }
            0x830DBB64 => {
    //   block [0x830DBB64..0x830DBB88)
	// 830DBB64: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830DBB68: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DBB6C: 4E800421  bctrl
	ctx.lr = 0x830DBB70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DBB70: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DBB74: 389F0001  addi r4, r31, 1
	ctx.r[4].s64 = ctx.r[31].s64 + 1;
	// 830DBB78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DBB7C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830DBB80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DBB84: 4E800421  bctrl
	ctx.lr = 0x830DBB88;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DBB88 => {
    //   block [0x830DBB88..0x830DBB90)
	// 830DBB88: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830DBB8C: 4BBCD8C8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DBB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DBB90 size=132
    let mut pc: u32 = 0x830DBB90;
    'dispatch: loop {
        match pc {
            0x830DBB90 => {
    //   block [0x830DBB90..0x830DBBBC)
	// 830DBB90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DBB94: 4BBCD871  bl 0x82ca9404
	ctx.lr = 0x830DBB98;
	sub_82CA93D0(ctx, base);
	// 830DBB98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DBB9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DBBA0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830DBBA4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830DBBA8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830DBBAC: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830DBBB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DBBB4: 40990034  ble cr6, 0x830dbbe8
	if !ctx.cr[6].gt {
	pc = 0x830DBBE8; continue 'dispatch;
	}
	// 830DBBB8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x830DBBBC; continue 'dispatch;
            }
            0x830DBBBC => {
    //   block [0x830DBBBC..0x830DBBE8)
	// 830DBBBC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830DBBC0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DBBC4: 7C7D582E  lwzx r3, r29, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830DBBC8: 4BC7CE11  bl 0x82d589d8
	ctx.lr = 0x830DBBCC;
	sub_82D589D8(ctx, base);
	// 830DBBCC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DBBD0: 419A0024  beq cr6, 0x830dbbf4
	if ctx.cr[6].eq {
	pc = 0x830DBBF4; continue 'dispatch;
	}
	// 830DBBD4: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830DBBD8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830DBBDC: 3BBD0018  addi r29, r29, 0x18
	ctx.r[29].s64 = ctx.r[29].s64 + 24;
	// 830DBBE0: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DBBE4: 4198FFD8  blt cr6, 0x830dbbbc
	if ctx.cr[6].lt {
	pc = 0x830DBBBC; continue 'dispatch;
	}
	pc = 0x830DBBE8; continue 'dispatch;
            }
            0x830DBBE8 => {
    //   block [0x830DBBE8..0x830DBBF4)
	// 830DBBE8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830DBBEC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830DBBF0: 4BBCD864  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DBBF4 => {
    //   block [0x830DBBF4..0x830DBC14)
	// 830DBBF4: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DBBF8: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830DBBFC: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830DBC00: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DBC04: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830DBC08: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DBC0C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830DBC10: 4BBCD844  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DBC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DBC18 size=216
    let mut pc: u32 = 0x830DBC18;
    'dispatch: loop {
        match pc {
            0x830DBC18 => {
    //   block [0x830DBC18..0x830DBC38)
	// 830DBC18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DBC1C: 4BBCD7E5  bl 0x82ca9400
	ctx.lr = 0x830DBC20;
	sub_82CA93D0(ctx, base);
	// 830DBC20: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DBC24: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830DBC28: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830DBC2C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830DBC30: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830DBC34: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	pc = 0x830DBC38; continue 'dispatch;
            }
            0x830DBC38 => {
    //   block [0x830DBC38..0x830DBC44)
	// 830DBC38: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830DBC3C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830DBC40: 4099001C  ble cr6, 0x830dbc5c
	if !ctx.cr[6].gt {
	pc = 0x830DBC5C; continue 'dispatch;
	}
	pc = 0x830DBC44; continue 'dispatch;
            }
            0x830DBC44 => {
    //   block [0x830DBC44..0x830DBC5C)
	// 830DBC44: 7D7FE0AE  lbzx r11, r31, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830DBC48: 2B0B003E  cmplwi cr6, r11, 0x3e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 62 as u32, &mut ctx.xer);
	// 830DBC4C: 419A0010  beq cr6, 0x830dbc5c
	if ctx.cr[6].eq {
	pc = 0x830DBC5C; continue 'dispatch;
	}
	// 830DBC50: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830DBC54: 7F1FF000  cmpw cr6, r31, r30
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830DBC58: 4198FFEC  blt cr6, 0x830dbc44
	if ctx.cr[6].lt {
	pc = 0x830DBC44; continue 'dispatch;
	}
	pc = 0x830DBC5C; continue 'dispatch;
            }
            0x830DBC5C => {
    //   block [0x830DBC5C..0x830DBC78)
	// 830DBC5C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 830DBC60: 419A0018  beq cr6, 0x830dbc78
	if ctx.cr[6].eq {
	pc = 0x830DBC78; continue 'dispatch;
	}
	// 830DBC64: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 830DBC68: 809A0004  lwz r4, 4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DBC6C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830DBC70: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830DBC74: 480016F5  bl 0x830dd368
	ctx.lr = 0x830DBC78;
	sub_830DD368(ctx, base);
	pc = 0x830DBC78; continue 'dispatch;
            }
            0x830DBC78 => {
    //   block [0x830DBC78..0x830DBCC4)
	// 830DBC78: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DBC7C: 7F1FF000  cmpw cr6, r31, r30
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830DBC80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DBC84: 409A0040  bne cr6, 0x830dbcc4
	if !ctx.cr[6].eq {
	pc = 0x830DBCC4; continue 'dispatch;
	}
	// 830DBC88: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830DBC8C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830DBC90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DBC94: 4E800421  bctrl
	ctx.lr = 0x830DBC98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DBC98: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DBC9C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830DBCA0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DBCA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DBCA8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DBCAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DBCB0: 4E800421  bctrl
	ctx.lr = 0x830DBCB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DBCB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DBCB8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830DBCBC: 419A002C  beq cr6, 0x830dbce8
	if ctx.cr[6].eq {
	pc = 0x830DBCE8; continue 'dispatch;
	}
	// 830DBCC0: 4BFFFF78  b 0x830dbc38
	pc = 0x830DBC38; continue 'dispatch;
            }
            0x830DBCC4 => {
    //   block [0x830DBCC4..0x830DBCE8)
	// 830DBCC4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830DBCC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DBCCC: 4E800421  bctrl
	ctx.lr = 0x830DBCD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DBCD0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DBCD4: 389F0001  addi r4, r31, 1
	ctx.r[4].s64 = ctx.r[31].s64 + 1;
	// 830DBCD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DBCDC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830DBCE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DBCE4: 4E800421  bctrl
	ctx.lr = 0x830DBCE8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DBCE8 => {
    //   block [0x830DBCE8..0x830DBCF0)
	// 830DBCE8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830DBCEC: 4BBCD764  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DBCF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DBCF0 size=208
    let mut pc: u32 = 0x830DBCF0;
    'dispatch: loop {
        match pc {
            0x830DBCF0 => {
    //   block [0x830DBCF0..0x830DBD10)
	// 830DBCF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DBCF4: 4BBCD70D  bl 0x82ca9400
	ctx.lr = 0x830DBCF8;
	sub_82CA93D0(ctx, base);
	// 830DBCF8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DBCFC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830DBD00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830DBD04: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830DBD08: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830DBD0C: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	pc = 0x830DBD10; continue 'dispatch;
            }
            0x830DBD10 => {
    //   block [0x830DBD10..0x830DBD1C)
	// 830DBD10: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830DBD14: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830DBD18: 4099001C  ble cr6, 0x830dbd34
	if !ctx.cr[6].gt {
	pc = 0x830DBD34; continue 'dispatch;
	}
	pc = 0x830DBD1C; continue 'dispatch;
            }
            0x830DBD1C => {
    //   block [0x830DBD1C..0x830DBD34)
	// 830DBD1C: 7D7FE8AE  lbzx r11, r31, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 830DBD20: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 830DBD24: 419A0010  beq cr6, 0x830dbd34
	if ctx.cr[6].eq {
	pc = 0x830DBD34; continue 'dispatch;
	}
	// 830DBD28: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830DBD2C: 7F1FF000  cmpw cr6, r31, r30
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830DBD30: 4198FFEC  blt cr6, 0x830dbd1c
	if ctx.cr[6].lt {
	pc = 0x830DBD1C; continue 'dispatch;
	}
	pc = 0x830DBD34; continue 'dispatch;
            }
            0x830DBD34 => {
    //   block [0x830DBD34..0x830DBD94)
	// 830DBD34: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 830DBD38: 809A0004  lwz r4, 4(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DBD3C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830DBD40: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830DBD44: 48001625  bl 0x830dd368
	ctx.lr = 0x830DBD48;
	sub_830DD368(ctx, base);
	// 830DBD48: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DBD4C: 7F1FF000  cmpw cr6, r31, r30
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830DBD50: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DBD54: 409A0040  bne cr6, 0x830dbd94
	if !ctx.cr[6].eq {
	pc = 0x830DBD94; continue 'dispatch;
	}
	// 830DBD58: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830DBD5C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830DBD60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DBD64: 4E800421  bctrl
	ctx.lr = 0x830DBD68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DBD68: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DBD6C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830DBD70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DBD74: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DBD78: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DBD7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DBD80: 4E800421  bctrl
	ctx.lr = 0x830DBD84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DBD84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DBD88: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830DBD8C: 419A002C  beq cr6, 0x830dbdb8
	if ctx.cr[6].eq {
	pc = 0x830DBDB8; continue 'dispatch;
	}
	// 830DBD90: 4BFFFF80  b 0x830dbd10
	pc = 0x830DBD10; continue 'dispatch;
            }
            0x830DBD94 => {
    //   block [0x830DBD94..0x830DBDB8)
	// 830DBD94: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830DBD98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DBD9C: 4E800421  bctrl
	ctx.lr = 0x830DBDA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DBDA0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DBDA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DBDA8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DBDAC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830DBDB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DBDB4: 4E800421  bctrl
	ctx.lr = 0x830DBDB8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DBDB8 => {
    //   block [0x830DBDB8..0x830DBDC0)
	// 830DBDB8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830DBDBC: 4BBCD694  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DBDC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DBDC0 size=112
    let mut pc: u32 = 0x830DBDC0;
    'dispatch: loop {
        match pc {
            0x830DBDC0 => {
    //   block [0x830DBDC0..0x830DBDFC)
	// 830DBDC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DBDC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830DBDC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830DBDCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830DBDD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DBDD4: 3BE30008  addi r31, r3, 8
	ctx.r[31].s64 = ctx.r[3].s64 + 8;
	// 830DBDD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830DBDDC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DBDE0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DBDE4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DBDE8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DBDEC: 409A0010  bne cr6, 0x830dbdfc
	if !ctx.cr[6].eq {
	pc = 0x830DBDFC; continue 'dispatch;
	}
	// 830DBDF0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 830DBDF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DBDF8: 4BC7B1A1  bl 0x82d56f98
	ctx.lr = 0x830DBDFC;
	sub_82D56F98(ctx, base);
	pc = 0x830DBDFC; continue 'dispatch;
            }
            0x830DBDFC => {
    //   block [0x830DBDFC..0x830DBE30)
	// 830DBDFC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DBE00: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DBE04: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DBE08: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 830DBE0C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DBE10: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830DBE14: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830DBE18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830DBE1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830DBE20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830DBE24: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830DBE28: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830DBE2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DBE38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DBE38 size=460
    let mut pc: u32 = 0x830DBE38;
    'dispatch: loop {
        match pc {
            0x830DBE38 => {
    //   block [0x830DBE38..0x830DBE80)
	// 830DBE38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DBE3C: 4BBCD5C5  bl 0x82ca9400
	ctx.lr = 0x830DBE40;
	sub_82CA93D0(ctx, base);
	// 830DBE40: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DBE44: 834D0000  lwz r26, 0(r13)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DBE48: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DBE4C: 3B600004  li r27, 4
	ctx.r[27].s64 = 4;
	// 830DBE50: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830DBE54: 83BE0010  lwz r29, 0x10(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DBE58: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 830DBE5C: 397D0010  addi r11, r29, 0x10
	ctx.r[11].s64 = ctx.r[29].s64 + 16;
	// 830DBE60: 55640036  rlwinm r4, r11, 0, 0, 0x1b
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DBE64: 83E30020  lwz r31, 0x20(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 830DBE68: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 830DBE6C: 7D7F2214  add r11, r31, r4
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[4].u64;
	// 830DBE70: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830DBE74: 4199000C  bgt cr6, 0x830dbe80
	if ctx.cr[6].gt {
	pc = 0x830DBE80; continue 'dispatch;
	}
	// 830DBE78: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830DBE7C: 48000018  b 0x830dbe94
	pc = 0x830DBE94; continue 'dispatch;
            }
            0x830DBE80 => {
    //   block [0x830DBE80..0x830DBE94)
	// 830DBE80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DBE84: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830DBE88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DBE8C: 4E800421  bctrl
	ctx.lr = 0x830DBE90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DBE90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            0x830DBE94 => {
    //   block [0x830DBE94..0x830DBEF4)
	// 830DBE94: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830DBE98: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DBE9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DBEA0: 67BC8000  oris r28, r29, 0x8000
	ctx.r[28].u64 = ctx.r[29].u64 | 2147483648;
	// 830DBEA4: 3BBE000C  addi r29, r30, 0xc
	ctx.r[29].s64 = ctx.r[30].s64 + 12;
	// 830DBEA8: 4BFFFA61  bl 0x830db908
	ctx.lr = 0x830DBEAC;
	sub_830DB908(ctx, base);
	// 830DBEAC: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 830DBEB0: 419A0100  beq cr6, 0x830dbfb0
	if ctx.cr[6].eq {
	pc = 0x830DBFB0; continue 'dispatch;
	}
	// 830DBEB4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830DBEB8: 419A0064  beq cr6, 0x830dbf1c
	if ctx.cr[6].eq {
	pc = 0x830DBF1C; continue 'dispatch;
	}
	// 830DBEBC: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DBEC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DBEC4: 419A0058  beq cr6, 0x830dbf1c
	if ctx.cr[6].eq {
	pc = 0x830DBF1C; continue 'dispatch;
	}
	// 830DBEC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DBECC: 4BC7CD5D  bl 0x82d58c28
	ctx.lr = 0x830DBED0;
	sub_82D58C28(ctx, base);
	// 830DBED0: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DBED4: 3BC30001  addi r30, r3, 1
	ctx.r[30].s64 = ctx.r[3].s64 + 1;
	// 830DBED8: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DBEDC: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830DBEE0: 40980024  bge cr6, 0x830dbf04
	if !ctx.cr[6].lt {
	pc = 0x830DBF04; continue 'dispatch;
	}
	// 830DBEE4: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DBEE8: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DBEEC: 41980008  blt cr6, 0x830dbef4
	if ctx.cr[6].lt {
	pc = 0x830DBEF4; continue 'dispatch;
	}
	// 830DBEF0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x830DBEF4; continue 'dispatch;
            }
            0x830DBEF4 => {
    //   block [0x830DBEF4..0x830DBF04)
	// 830DBEF4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DBEF8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830DBEFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DBF00: 4BC7B011  bl 0x82d56f10
	ctx.lr = 0x830DBF04;
	sub_82D56F10(ctx, base);
	pc = 0x830DBF04; continue 'dispatch;
            }
            0x830DBF04 => {
    //   block [0x830DBF04..0x830DBF1C)
	// 830DBF04: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830DBF08: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DBF0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DBF10: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830DBF14: 4BC7CE1D  bl 0x82d58d30
	ctx.lr = 0x830DBF18;
	sub_82D58D30(ctx, base);
	// 830DBF18: 48000044  b 0x830dbf5c
	pc = 0x830DBF5C; continue 'dispatch;
            }
            0x830DBF1C => {
    //   block [0x830DBF1C..0x830DBF3C)
	// 830DBF1C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DBF20: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DBF24: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830DBF28: 40980020  bge cr6, 0x830dbf48
	if !ctx.cr[6].lt {
	pc = 0x830DBF48; continue 'dispatch;
	}
	// 830DBF2C: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830DBF30: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 830DBF34: 41990008  bgt cr6, 0x830dbf3c
	if ctx.cr[6].gt {
	pc = 0x830DBF3C; continue 'dispatch;
	}
	// 830DBF38: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	pc = 0x830DBF3C; continue 'dispatch;
            }
            0x830DBF3C => {
    //   block [0x830DBF3C..0x830DBF48)
	// 830DBF3C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DBF40: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DBF44: 4BC7AFCD  bl 0x82d56f10
	ctx.lr = 0x830DBF48;
	sub_82D56F10(ctx, base);
	pc = 0x830DBF48; continue 'dispatch;
            }
            0x830DBF48 => {
    //   block [0x830DBF48..0x830DBF5C)
	// 830DBF48: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830DBF4C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DBF50: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830DBF54: 913D0004  stw r9, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830DBF58: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	pc = 0x830DBF5C; continue 'dispatch;
            }
            0x830DBF5C => {
    //   block [0x830DBF5C..0x830DBF84)
	// 830DBF5C: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 830DBF60: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830DBF64: 93E30020  stw r31, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 830DBF68: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830DBF6C: 409A0018  bne cr6, 0x830dbf84
	if !ctx.cr[6].eq {
	pc = 0x830DBF84; continue 'dispatch;
	}
	// 830DBF70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DBF74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DBF78: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830DBF7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DBF80: 4E800421  bctrl
	ctx.lr = 0x830DBF84;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DBF84 => {
    //   block [0x830DBF84..0x830DBFA4)
	// 830DBF84: 578B0000  rlwinm r11, r28, 0, 0, 0
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 830DBF88: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DBF8C: 409A0018  bne cr6, 0x830dbfa4
	if !ctx.cr[6].eq {
	pc = 0x830DBFA4; continue 'dispatch;
	}
	// 830DBF90: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DBF94: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 830DBF98: 578500BE  clrlwi r5, r28, 2
	ctx.r[5].u64 = ctx.r[28].u32 as u64 & 0x3FFFFFFFu64;
	// 830DBF9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DBFA0: 4BC79329  bl 0x82d552c8
	ctx.lr = 0x830DBFA4;
	sub_82D552C8(ctx, base);
	pc = 0x830DBFA4; continue 'dispatch;
            }
            0x830DBFA4 => {
    //   block [0x830DBFA4..0x830DBFB0)
	// 830DBFA4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830DBFA8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830DBFAC: 4BBCD4A4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DBFB0 => {
    //   block [0x830DBFB0..0x830DBFD8)
	// 830DBFB0: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 830DBFB4: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830DBFB8: 93E30020  stw r31, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 830DBFBC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830DBFC0: 409A0018  bne cr6, 0x830dbfd8
	if !ctx.cr[6].eq {
	pc = 0x830DBFD8; continue 'dispatch;
	}
	// 830DBFC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DBFC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DBFCC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830DBFD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DBFD4: 4E800421  bctrl
	ctx.lr = 0x830DBFD8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DBFD8 => {
    //   block [0x830DBFD8..0x830DBFF8)
	// 830DBFD8: 578B0000  rlwinm r11, r28, 0, 0, 0
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 830DBFDC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DBFE0: 409A0018  bne cr6, 0x830dbff8
	if !ctx.cr[6].eq {
	pc = 0x830DBFF8; continue 'dispatch;
	}
	// 830DBFE4: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DBFE8: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 830DBFEC: 578500BE  clrlwi r5, r28, 2
	ctx.r[5].u64 = ctx.r[28].u32 as u64 & 0x3FFFFFFFu64;
	// 830DBFF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DBFF4: 4BC792D5  bl 0x82d552c8
	ctx.lr = 0x830DBFF8;
	sub_82D552C8(ctx, base);
	pc = 0x830DBFF8; continue 'dispatch;
            }
            0x830DBFF8 => {
    //   block [0x830DBFF8..0x830DC004)
	// 830DBFF8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830DBFFC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830DC000: 4BBCD450  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DC008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DC008 size=112
    let mut pc: u32 = 0x830DC008;
    'dispatch: loop {
        match pc {
            0x830DC008 => {
    //   block [0x830DC008..0x830DC078)
	// 830DC008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DC00C: 4BBCD401  bl 0x82ca940c
	ctx.lr = 0x830DC010;
	sub_82CA93D0(ctx, base);
	// 830DC010: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DC014: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DC018: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC01C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DC020: 396BA3B4  addi r11, r11, -0x5c4c
	ctx.r[11].s64 = ctx.r[11].s64 + -23628;
	// 830DC024: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 830DC028: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830DC02C: 3D208000  lis r9, -0x8000
	ctx.r[9].s64 = -2147483648;
	// 830DC030: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 830DC034: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830DC038: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 830DC03C: B3BF0006  sth r29, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[29].u16 ) };
	// 830DC040: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DC044: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830DC048: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 830DC04C: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 830DC050: 7C68502E  lwzx r3, r8, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DC054: 4BC791F5  bl 0x82d55248
	ctx.lr = 0x830DC058;
	sub_82D55248(ctx, base);
	// 830DC058: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830DC05C: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 830DC060: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 830DC064: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DC068: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830DC06C: 9BCB0000  stb r30, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 830DC070: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830DC074: 4BBCD3E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DC078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DC078 size=212
    let mut pc: u32 = 0x830DC078;
    'dispatch: loop {
        match pc {
            0x830DC078 => {
    //   block [0x830DC078..0x830DC0A8)
	// 830DC078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DC07C: 4BBCD391  bl 0x82ca940c
	ctx.lr = 0x830DC080;
	sub_82CA93D0(ctx, base);
	// 830DC080: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DC084: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DC088: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DC08C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830DC090: 396BA3B4  addi r11, r11, -0x5c4c
	ctx.r[11].s64 = ctx.r[11].s64 + -23628;
	// 830DC094: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DC098: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DC09C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830DC0A0: 40990040  ble cr6, 0x830dc0e0
	if !ctx.cr[6].gt {
	pc = 0x830DC0E0; continue 'dispatch;
	}
	// 830DC0A4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x830DC0A8; continue 'dispatch;
            }
            0x830DC0A8 => {
    //   block [0x830DC0A8..0x830DC0CC)
	// 830DC0A8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DC0AC: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830DC0B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DC0B4: 419A0018  beq cr6, 0x830dc0cc
	if ctx.cr[6].eq {
	pc = 0x830DC0CC; continue 'dispatch;
	}
	// 830DC0B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC0BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DC0C0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC0C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DC0C8: 4E800421  bctrl
	ctx.lr = 0x830DC0CC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DC0CC => {
    //   block [0x830DC0CC..0x830DC0E0)
	// 830DC0CC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DC0D0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830DC0D4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 830DC0D8: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DC0DC: 4198FFCC  blt cr6, 0x830dc0a8
	if ctx.cr[6].lt {
	pc = 0x830DC0A8; continue 'dispatch;
	}
	pc = 0x830DC0E0; continue 'dispatch;
            }
            0x830DC0E0 => {
    //   block [0x830DC0E0..0x830DC10C)
	// 830DC0E0: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 830DC0E4: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DC0E8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DC0EC: 409A0020  bne cr6, 0x830dc10c
	if !ctx.cr[6].eq {
	pc = 0x830DC10C; continue 'dispatch;
	}
	// 830DC0F0: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC0F4: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DC0F8: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DC0FC: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830DC100: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DC104: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DC108: 4BC791C1  bl 0x82d552c8
	ctx.lr = 0x830DC10C;
	sub_82D552C8(ctx, base);
	pc = 0x830DC10C; continue 'dispatch;
            }
            0x830DC10C => {
    //   block [0x830DC10C..0x830DC138)
	// 830DC10C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DC110: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DC114: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DC118: 409A0020  bne cr6, 0x830dc138
	if !ctx.cr[6].eq {
	pc = 0x830DC138; continue 'dispatch;
	}
	// 830DC11C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC120: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DC124: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DC128: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DC12C: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830DC130: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DC134: 4BC79195  bl 0x82d552c8
	ctx.lr = 0x830DC138;
	sub_82D552C8(ctx, base);
	pc = 0x830DC138; continue 'dispatch;
            }
            0x830DC138 => {
    //   block [0x830DC138..0x830DC14C)
	// 830DC138: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830DC13C: 396B39E0  addi r11, r11, 0x39e0
	ctx.r[11].s64 = ctx.r[11].s64 + 14816;
	// 830DC140: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830DC144: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830DC148: 4BBCD314  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DC150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DC150 size=1444
    let mut pc: u32 = 0x830DC150;
    'dispatch: loop {
        match pc {
            0x830DC150 => {
    //   block [0x830DC150..0x830DC170)
	// 830DC150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DC154: 4BBCD291  bl 0x82ca93e4
	ctx.lr = 0x830DC158;
	sub_82CA93D0(ctx, base);
	// 830DC158: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DC15C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DC160: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 830DC164: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 830DC168: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 830DC16C: 3E608000  lis r19, -0x8000
	ctx.r[19].s64 = -2147483648;
	pc = 0x830DC170; continue 'dispatch;
            }
            0x830DC170 => {
    //   block [0x830DC170..0x830DC174)
	// 830DC170: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	pc = 0x830DC174; continue 'dispatch;
            }
            0x830DC174 => {
    //   block [0x830DC174..0x830DC1A0)
	// 830DC174: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC178: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DC17C: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 830DC180: 419A0020  beq cr6, 0x830dc1a0
	if ctx.cr[6].eq {
	pc = 0x830DC1A0; continue 'dispatch;
	}
	// 830DC184: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 830DC188: 419A0018  beq cr6, 0x830dc1a0
	if ctx.cr[6].eq {
	pc = 0x830DC1A0; continue 'dispatch;
	}
	// 830DC18C: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 830DC190: 419A0010  beq cr6, 0x830dc1a0
	if ctx.cr[6].eq {
	pc = 0x830DC1A0; continue 'dispatch;
	}
	// 830DC194: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 830DC198: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 830DC19C: 409A0008  bne cr6, 0x830dc1a4
	if !ctx.cr[6].eq {
	pc = 0x830DC1A4; continue 'dispatch;
	}
	pc = 0x830DC1A0; continue 'dispatch;
            }
            0x830DC1A0 => {
    //   block [0x830DC1A0..0x830DC1A4)
	// 830DC1A0: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	pc = 0x830DC1A4; continue 'dispatch;
            }
            0x830DC1A4 => {
    //   block [0x830DC1A4..0x830DC1B8)
	// 830DC1A4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DC1A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DC1AC: 419A000C  beq cr6, 0x830dc1b8
	if ctx.cr[6].eq {
	pc = 0x830DC1B8; continue 'dispatch;
	}
	// 830DC1B0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830DC1B4: 4BFFFFC0  b 0x830dc174
	pc = 0x830DC174; continue 'dispatch;
            }
            0x830DC1B8 => {
    //   block [0x830DC1B8..0x830DC210)
	// 830DC1B8: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC1BC: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 830DC1C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DC1C4: 419A0510  beq cr6, 0x830dc6d4
	if ctx.cr[6].eq {
	pc = 0x830DC6D4; continue 'dispatch;
	}
	// 830DC1C8: 82ED0000  lwz r23, 0(r13)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC1CC: 3B000004  li r24, 4
	ctx.r[24].s64 = 4;
	// 830DC1D0: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 830DC1D4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DC1D8: 7C78B82E  lwzx r3, r24, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 830DC1DC: 4BC7906D  bl 0x82d55248
	ctx.lr = 0x830DC1E0;
	sub_82D55248(ctx, base);
	// 830DC1E0: 90610070  stw r3, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u32 ) };
	// 830DC1E4: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 830DC1E8: 92810074  stw r20, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[20].u32 ) };
	// 830DC1EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DC1F0: 92810078  stw r20, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[20].u32 ) };
	// 830DC1F4: 9AC30000  stb r22, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[22].u8 ) };
	// 830DC1F8: 7C78B82E  lwzx r3, r24, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 830DC1FC: 4BC7904D  bl 0x82d55248
	ctx.lr = 0x830DC200;
	sub_82D55248(ctx, base);
	// 830DC200: 9061007C  stw r3, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 830DC204: 92810080  stw r20, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[20].u32 ) };
	// 830DC208: 92810084  stw r20, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[20].u32 ) };
	// 830DC20C: 9AC30000  stb r22, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[22].u8 ) };
	pc = 0x830DC210; continue 'dispatch;
            }
            0x830DC210 => {
    //   block [0x830DC210..0x830DC23C)
	// 830DC210: 895C0000  lbz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC214: 7D4B0774  extsb r11, r10
	ctx.r[11].s64 = ctx.r[10].s8 as i64;
	// 830DC218: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 830DC21C: 419A0020  beq cr6, 0x830dc23c
	if ctx.cr[6].eq {
	pc = 0x830DC23C; continue 'dispatch;
	}
	// 830DC220: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 830DC224: 419A0018  beq cr6, 0x830dc23c
	if ctx.cr[6].eq {
	pc = 0x830DC23C; continue 'dispatch;
	}
	// 830DC228: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 830DC22C: 419A0010  beq cr6, 0x830dc23c
	if ctx.cr[6].eq {
	pc = 0x830DC23C; continue 'dispatch;
	}
	// 830DC230: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 830DC234: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 830DC238: 409A0008  bne cr6, 0x830dc240
	if !ctx.cr[6].eq {
	pc = 0x830DC240; continue 'dispatch;
	}
	pc = 0x830DC23C; continue 'dispatch;
            }
            0x830DC23C => {
    //   block [0x830DC23C..0x830DC240)
	// 830DC23C: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	pc = 0x830DC240; continue 'dispatch;
            }
            0x830DC240 => {
    //   block [0x830DC240..0x830DC264)
	// 830DC240: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DC244: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DC248: 409A0080  bne cr6, 0x830dc2c8
	if !ctx.cr[6].eq {
	pc = 0x830DC2C8; continue 'dispatch;
	}
	// 830DC24C: 7D4B0774  extsb r11, r10
	ctx.r[11].s64 = ctx.r[10].s8 as i64;
	// 830DC250: 2F0B003D  cmpwi cr6, r11, 0x3d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 61, &mut ctx.xer);
	// 830DC254: 419A0074  beq cr6, 0x830dc2c8
	if ctx.cr[6].eq {
	pc = 0x830DC2C8; continue 'dispatch;
	}
	// 830DC258: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DC25C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830DC260: 409AFFB0  bne cr6, 0x830dc210
	if !ctx.cr[6].eq {
	pc = 0x830DC210; continue 'dispatch;
	}
	pc = 0x830DC264; continue 'dispatch;
            }
            0x830DC264 => {
    //   block [0x830DC264..0x830DC290)
	// 830DC264: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 830DC268: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DC26C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DC270: 409A0020  bne cr6, 0x830dc290
	if !ctx.cr[6].eq {
	pc = 0x830DC290; continue 'dispatch;
	}
	// 830DC274: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC278: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DC27C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DC280: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 830DC284: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DC288: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DC28C: 4BC7903D  bl 0x82d552c8
	ctx.lr = 0x830DC290;
	sub_82D552C8(ctx, base);
	pc = 0x830DC290; continue 'dispatch;
            }
            0x830DC290 => {
    //   block [0x830DC290..0x830DC2BC)
	// 830DC290: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830DC294: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DC298: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DC29C: 409A0020  bne cr6, 0x830dc2bc
	if !ctx.cr[6].eq {
	pc = 0x830DC2BC; continue 'dispatch;
	}
	// 830DC2A0: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC2A4: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DC2A8: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DC2AC: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830DC2B0: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DC2B4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DC2B8: 4BC79011  bl 0x82d552c8
	ctx.lr = 0x830DC2BC;
	sub_82D552C8(ctx, base);
	pc = 0x830DC2BC; continue 'dispatch;
            }
            0x830DC2BC => {
    //   block [0x830DC2BC..0x830DC2C8)
	// 830DC2BC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830DC2C0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 830DC2C4: 4BBCD170  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DC2C8 => {
    //   block [0x830DC2C8..0x830DC2F0)
	// 830DC2C8: 7FFDE050  subf r31, r29, r28
	ctx.r[31].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 830DC2CC: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 830DC2D0: 92C10054  stw r22, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[22].u32 ) };
	// 830DC2D4: 3BDF0001  addi r30, r31, 1
	ctx.r[30].s64 = ctx.r[31].s64 + 1;
	// 830DC2D8: 92610058  stw r19, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[19].u32 ) };
	// 830DC2DC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830DC2E0: 4099001C  ble cr6, 0x830dc2fc
	if !ctx.cr[6].gt {
	pc = 0x830DC2FC; continue 'dispatch;
	}
	// 830DC2E4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 830DC2E8: 41980008  blt cr6, 0x830dc2f0
	if ctx.cr[6].lt {
	pc = 0x830DC2F0; continue 'dispatch;
	}
	// 830DC2EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	pc = 0x830DC2F0; continue 'dispatch;
            }
            0x830DC2F0 => {
    //   block [0x830DC2F0..0x830DC2FC)
	// 830DC2F0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DC2F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830DC2F8: 4BC7AC19  bl 0x82d56f10
	ctx.lr = 0x830DC2FC;
	sub_82D56F10(ctx, base);
	pc = 0x830DC2FC; continue 'dispatch;
            }
            0x830DC2FC => {
    //   block [0x830DC2FC..0x830DC340)
	// 830DC2FC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830DC300: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DC304: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DC308: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 830DC30C: 4BC7CA25  bl 0x82d58d30
	ctx.lr = 0x830DC310;
	sub_82D58D30(ctx, base);
	// 830DC310: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DC314: 7ECBF9AE  stbx r22, r11, r31
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[22].u8) };
	// 830DC318: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830DC31C: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DC320: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830DC324: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 830DC328: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DC32C: 40980024  bge cr6, 0x830dc350
	if !ctx.cr[6].lt {
	pc = 0x830DC350; continue 'dispatch;
	}
	// 830DC330: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830DC334: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830DC338: 40980008  bge cr6, 0x830dc340
	if !ctx.cr[6].lt {
	pc = 0x830DC340; continue 'dispatch;
	}
	// 830DC33C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x830DC340; continue 'dispatch;
            }
            0x830DC340 => {
    //   block [0x830DC340..0x830DC350)
	// 830DC340: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DC344: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830DC348: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830DC34C: 4BC7ABC5  bl 0x82d56f10
	ctx.lr = 0x830DC350;
	sub_82D56F10(ctx, base);
	pc = 0x830DC350; continue 'dispatch;
            }
            0x830DC350 => {
    //   block [0x830DC350..0x830DC388)
	// 830DC350: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830DC354: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DC358: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830DC35C: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 830DC360: 4BC7C9D1  bl 0x82d58d30
	ctx.lr = 0x830DC364;
	sub_82D58D30(ctx, base);
	// 830DC364: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DC368: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DC36C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DC370: 409A0018  bne cr6, 0x830dc388
	if !ctx.cr[6].eq {
	pc = 0x830DC388; continue 'dispatch;
	}
	// 830DC374: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DC378: 7C78B82E  lwzx r3, r24, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 830DC37C: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DC380: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DC384: 4BC78F45  bl 0x82d552c8
	ctx.lr = 0x830DC388;
	sub_82D552C8(ctx, base);
	pc = 0x830DC388; continue 'dispatch;
            }
            0x830DC388 => {
    //   block [0x830DC388..0x830DC38C)
	// 830DC388: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x830DC38C; continue 'dispatch;
            }
            0x830DC38C => {
    //   block [0x830DC38C..0x830DC3B8)
	// 830DC38C: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC390: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DC394: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 830DC398: 419A0020  beq cr6, 0x830dc3b8
	if ctx.cr[6].eq {
	pc = 0x830DC3B8; continue 'dispatch;
	}
	// 830DC39C: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 830DC3A0: 419A0018  beq cr6, 0x830dc3b8
	if ctx.cr[6].eq {
	pc = 0x830DC3B8; continue 'dispatch;
	}
	// 830DC3A4: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 830DC3A8: 419A0010  beq cr6, 0x830dc3b8
	if ctx.cr[6].eq {
	pc = 0x830DC3B8; continue 'dispatch;
	}
	// 830DC3AC: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 830DC3B0: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 830DC3B4: 409A0008  bne cr6, 0x830dc3bc
	if !ctx.cr[6].eq {
	pc = 0x830DC3BC; continue 'dispatch;
	}
	pc = 0x830DC3B8; continue 'dispatch;
            }
            0x830DC3B8 => {
    //   block [0x830DC3B8..0x830DC3BC)
	// 830DC3B8: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	pc = 0x830DC3BC; continue 'dispatch;
            }
            0x830DC3BC => {
    //   block [0x830DC3BC..0x830DC3D0)
	// 830DC3BC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DC3C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DC3C4: 419A000C  beq cr6, 0x830dc3d0
	if ctx.cr[6].eq {
	pc = 0x830DC3D0; continue 'dispatch;
	}
	// 830DC3C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830DC3CC: 4BFFFFC0  b 0x830dc38c
	pc = 0x830DC38C; continue 'dispatch;
            }
            0x830DC3D0 => {
    //   block [0x830DC3D0..0x830DC3DC)
	// 830DC3D0: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC3D4: 2B0B003D  cmplwi cr6, r11, 0x3d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 61 as u32, &mut ctx.xer);
	// 830DC3D8: 409A0308  bne cr6, 0x830dc6e0
	if !ctx.cr[6].eq {
	pc = 0x830DC6E0; continue 'dispatch;
	}
	pc = 0x830DC3DC; continue 'dispatch;
            }
            0x830DC3DC => {
    //   block [0x830DC3DC..0x830DC40C)
	// 830DC3DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830DC3E0: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC3E4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DC3E8: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 830DC3EC: 419A0020  beq cr6, 0x830dc40c
	if ctx.cr[6].eq {
	pc = 0x830DC40C; continue 'dispatch;
	}
	// 830DC3F0: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 830DC3F4: 419A0018  beq cr6, 0x830dc40c
	if ctx.cr[6].eq {
	pc = 0x830DC40C; continue 'dispatch;
	}
	// 830DC3F8: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 830DC3FC: 419A0010  beq cr6, 0x830dc40c
	if ctx.cr[6].eq {
	pc = 0x830DC40C; continue 'dispatch;
	}
	// 830DC400: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 830DC404: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 830DC408: 409A0008  bne cr6, 0x830dc410
	if !ctx.cr[6].eq {
	pc = 0x830DC410; continue 'dispatch;
	}
	pc = 0x830DC40C; continue 'dispatch;
            }
            0x830DC40C => {
    //   block [0x830DC40C..0x830DC410)
	// 830DC40C: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	pc = 0x830DC410; continue 'dispatch;
            }
            0x830DC410 => {
    //   block [0x830DC410..0x830DC440)
	// 830DC410: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DC414: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DC418: 409AFFC4  bne cr6, 0x830dc3dc
	if !ctx.cr[6].eq {
	pc = 0x830DC3DC; continue 'dispatch;
	}
	// 830DC41C: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC420: 2B0B0022  cmplwi cr6, r11, 0x22
	ctx.cr[6].compare_u32(ctx.r[11].u32, 34 as u32, &mut ctx.xer);
	// 830DC424: 409A02BC  bne cr6, 0x830dc6e0
	if !ctx.cr[6].eq {
	pc = 0x830DC6E0; continue 'dispatch;
	}
	// 830DC428: 3B2A0001  addi r25, r10, 1
	ctx.r[25].s64 = ctx.r[10].s64 + 1;
	// 830DC42C: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 830DC430: 89790000  lbz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC434: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DC438: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 830DC43C: 419A0020  beq cr6, 0x830dc45c
	if ctx.cr[6].eq {
	pc = 0x830DC45C; continue 'dispatch;
	}
	pc = 0x830DC440; continue 'dispatch;
            }
            0x830DC440 => {
    //   block [0x830DC440..0x830DC45C)
	// 830DC440: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DC444: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 830DC448: 419AFE1C  beq cr6, 0x830dc264
	if ctx.cr[6].eq {
	pc = 0x830DC264; continue 'dispatch;
	}
	// 830DC44C: 89790000  lbz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC450: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DC454: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 830DC458: 409AFFE8  bne cr6, 0x830dc440
	if !ctx.cr[6].eq {
	pc = 0x830DC440; continue 'dispatch;
	}
	pc = 0x830DC45C; continue 'dispatch;
            }
            0x830DC45C => {
    //   block [0x830DC45C..0x830DC484)
	// 830DC45C: 7FFDC850  subf r31, r29, r25
	ctx.r[31].s64 = ctx.r[25].s64 - ctx.r[29].s64;
	// 830DC460: 92C10060  stw r22, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[22].u32 ) };
	// 830DC464: 92C10064  stw r22, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[22].u32 ) };
	// 830DC468: 3BDF0001  addi r30, r31, 1
	ctx.r[30].s64 = ctx.r[31].s64 + 1;
	// 830DC46C: 92610068  stw r19, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[19].u32 ) };
	// 830DC470: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830DC474: 4099001C  ble cr6, 0x830dc490
	if !ctx.cr[6].gt {
	pc = 0x830DC490; continue 'dispatch;
	}
	// 830DC478: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 830DC47C: 41980008  blt cr6, 0x830dc484
	if ctx.cr[6].lt {
	pc = 0x830DC484; continue 'dispatch;
	}
	// 830DC480: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	pc = 0x830DC484; continue 'dispatch;
            }
            0x830DC484 => {
    //   block [0x830DC484..0x830DC490)
	// 830DC484: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DC488: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830DC48C: 4BC7AA85  bl 0x82d56f10
	ctx.lr = 0x830DC490;
	sub_82D56F10(ctx, base);
	pc = 0x830DC490; continue 'dispatch;
            }
            0x830DC490 => {
    //   block [0x830DC490..0x830DC4D4)
	// 830DC490: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830DC494: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DC498: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DC49C: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 830DC4A0: 4BC7C891  bl 0x82d58d30
	ctx.lr = 0x830DC4A4;
	sub_82D58D30(ctx, base);
	// 830DC4A4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DC4A8: 7ECBF9AE  stbx r22, r11, r31
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[22].u8) };
	// 830DC4AC: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 830DC4B0: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DC4B4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830DC4B8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 830DC4BC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DC4C0: 40980024  bge cr6, 0x830dc4e4
	if !ctx.cr[6].lt {
	pc = 0x830DC4E4; continue 'dispatch;
	}
	// 830DC4C4: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830DC4C8: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830DC4CC: 40980008  bge cr6, 0x830dc4d4
	if !ctx.cr[6].lt {
	pc = 0x830DC4D4; continue 'dispatch;
	}
	// 830DC4D0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x830DC4D4; continue 'dispatch;
            }
            0x830DC4D4 => {
    //   block [0x830DC4D4..0x830DC4E4)
	// 830DC4D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DC4D8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830DC4DC: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 830DC4E0: 4BC7AA31  bl 0x82d56f10
	ctx.lr = 0x830DC4E4;
	sub_82D56F10(ctx, base);
	pc = 0x830DC4E4; continue 'dispatch;
            }
            0x830DC4E4 => {
    //   block [0x830DC4E4..0x830DC51C)
	// 830DC4E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830DC4E8: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DC4EC: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 830DC4F0: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 830DC4F4: 4BC7C83D  bl 0x82d58d30
	ctx.lr = 0x830DC4F8;
	sub_82D58D30(ctx, base);
	// 830DC4F8: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830DC4FC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DC500: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DC504: 409A0018  bne cr6, 0x830dc51c
	if !ctx.cr[6].eq {
	pc = 0x830DC51C; continue 'dispatch;
	}
	// 830DC508: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DC50C: 7C78B82E  lwzx r3, r24, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 830DC510: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DC514: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DC518: 4BC78DB1  bl 0x82d552c8
	ctx.lr = 0x830DC51C;
	sub_82D552C8(ctx, base);
	pc = 0x830DC51C; continue 'dispatch;
            }
            0x830DC51C => {
    //   block [0x830DC51C..0x830DC540)
	// 830DC51C: 83550008  lwz r26, 8(r21)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DC520: 83950004  lwz r28, 4(r21)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DC524: 574A00BE  clrlwi r10, r26, 2
	ctx.r[10].u64 = ctx.r[26].u32 as u64 & 0x3FFFFFFFu64;
	// 830DC528: 7F1C5000  cmpw cr6, r28, r10
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830DC52C: 409A012C  bne cr6, 0x830dc658
	if !ctx.cr[6].eq {
	pc = 0x830DC658; continue 'dispatch;
	}
	// 830DC530: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830DC534: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DC538: 409A0008  bne cr6, 0x830dc540
	if !ctx.cr[6].eq {
	pc = 0x830DC540; continue 'dispatch;
	}
	// 830DC53C: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	pc = 0x830DC540; continue 'dispatch;
            }
            0x830DC540 => {
    //   block [0x830DC540..0x830DC558)
	// 830DC540: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830DC544: 40990114  ble cr6, 0x830dc658
	if !ctx.cr[6].gt {
	pc = 0x830DC658; continue 'dispatch;
	}
	// 830DC548: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830DC54C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830DC550: 40980008  bge cr6, 0x830dc558
	if !ctx.cr[6].lt {
	pc = 0x830DC558; continue 'dispatch;
	}
	// 830DC554: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x830DC558; continue 'dispatch;
            }
            0x830DC558 => {
    //   block [0x830DC558..0x830DC578)
	// 830DC558: 83750000  lwz r27, 0(r21)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC55C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DC560: 92D50000  stw r22, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	// 830DC564: 92D50004  stw r22, 4(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(4 as u32), ctx.r[22].u32 ) };
	// 830DC568: 92750008  stw r19, 8(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(8 as u32), ctx.r[19].u32 ) };
	// 830DC56C: 4099001C  ble cr6, 0x830dc588
	if !ctx.cr[6].gt {
	pc = 0x830DC588; continue 'dispatch;
	}
	// 830DC570: 40980008  bge cr6, 0x830dc578
	if !ctx.cr[6].lt {
	pc = 0x830DC578; continue 'dispatch;
	}
	// 830DC574: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x830DC578; continue 'dispatch;
            }
            0x830DC578 => {
    //   block [0x830DC578..0x830DC588)
	// 830DC578: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 830DC57C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830DC580: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 830DC584: 4BC7A98D  bl 0x82d56f10
	ctx.lr = 0x830DC588;
	sub_82D56F10(ctx, base);
	pc = 0x830DC588; continue 'dispatch;
            }
            0x830DC588 => {
    //   block [0x830DC588..0x830DC59C)
	// 830DC588: 83F50000  lwz r31, 0(r21)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC58C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830DC590: 40990030  ble cr6, 0x830dc5c0
	if !ctx.cr[6].gt {
	pc = 0x830DC5C0; continue 'dispatch;
	}
	// 830DC594: 7FBFD850  subf r29, r31, r27
	ctx.r[29].s64 = ctx.r[27].s64 - ctx.r[31].s64;
	// 830DC598: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x830DC59C; continue 'dispatch;
            }
            0x830DC59C => {
    //   block [0x830DC59C..0x830DC5B0)
	// 830DC59C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830DC5A0: 419A0010  beq cr6, 0x830dc5b0
	if ctx.cr[6].eq {
	pc = 0x830DC5B0; continue 'dispatch;
	}
	// 830DC5A4: 7C9DFA14  add r4, r29, r31
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 830DC5A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DC5AC: 4800102D  bl 0x830dd5d8
	ctx.lr = 0x830DC5B0;
	sub_830DD5D8(ctx, base);
	pc = 0x830DC5B0; continue 'dispatch;
            }
            0x830DC5B0 => {
    //   block [0x830DC5B0..0x830DC5C0)
	// 830DC5B0: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 830DC5B4: 3BFF0018  addi r31, r31, 0x18
	ctx.r[31].s64 = ctx.r[31].s64 + 24;
	// 830DC5B8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830DC5BC: 409AFFE0  bne cr6, 0x830dc59c
	if !ctx.cr[6].eq {
	pc = 0x830DC59C; continue 'dispatch;
	}
	pc = 0x830DC5C0; continue 'dispatch;
            }
            0x830DC5C0 => {
    //   block [0x830DC5C0..0x830DC5D4)
	// 830DC5C0: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830DC5C4: 93950004  stw r28, 4(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830DC5C8: 40990064  ble cr6, 0x830dc62c
	if !ctx.cr[6].gt {
	pc = 0x830DC62C; continue 'dispatch;
	}
	// 830DC5CC: 3BFB0014  addi r31, r27, 0x14
	ctx.r[31].s64 = ctx.r[27].s64 + 20;
	// 830DC5D0: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x830DC5D4; continue 'dispatch;
            }
            0x830DC5D4 => {
    //   block [0x830DC5D4..0x830DC5F8)
	// 830DC5D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC5D8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DC5DC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DC5E0: 409A0018  bne cr6, 0x830dc5f8
	if !ctx.cr[6].eq {
	pc = 0x830DC5F8; continue 'dispatch;
	}
	// 830DC5E4: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DC5E8: 809FFFF8  lwz r4, -8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830DC5EC: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DC5F0: 7C78B82E  lwzx r3, r24, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 830DC5F4: 4BC78CD5  bl 0x82d552c8
	ctx.lr = 0x830DC5F8;
	sub_82D552C8(ctx, base);
	pc = 0x830DC5F8; continue 'dispatch;
            }
            0x830DC5F8 => {
    //   block [0x830DC5F8..0x830DC61C)
	// 830DC5F8: 817FFFF4  lwz r11, -0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) } as u64;
	// 830DC5FC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DC600: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DC604: 409A0018  bne cr6, 0x830dc61c
	if !ctx.cr[6].eq {
	pc = 0x830DC61C; continue 'dispatch;
	}
	// 830DC608: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DC60C: 809FFFEC  lwz r4, -0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-20 as u32) ) } as u64;
	// 830DC610: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DC614: 7C78B82E  lwzx r3, r24, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 830DC618: 4BC78CB1  bl 0x82d552c8
	ctx.lr = 0x830DC61C;
	sub_82D552C8(ctx, base);
	pc = 0x830DC61C; continue 'dispatch;
            }
            0x830DC61C => {
    //   block [0x830DC61C..0x830DC62C)
	// 830DC61C: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 830DC620: 3BFF0018  addi r31, r31, 0x18
	ctx.r[31].s64 = ctx.r[31].s64 + 24;
	// 830DC624: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830DC628: 409AFFAC  bne cr6, 0x830dc5d4
	if !ctx.cr[6].eq {
	pc = 0x830DC5D4; continue 'dispatch;
	}
	pc = 0x830DC62C; continue 'dispatch;
            }
            0x830DC62C => {
    //   block [0x830DC62C..0x830DC658)
	// 830DC62C: 574B0000  rlwinm r11, r26, 0, 0, 0
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0xFFFFFFFFu64;
	// 830DC630: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DC634: 409A0024  bne cr6, 0x830dc658
	if !ctx.cr[6].eq {
	pc = 0x830DC658; continue 'dispatch;
	}
	// 830DC638: 574B00BE  clrlwi r11, r26, 2
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x3FFFFFFFu64;
	// 830DC63C: 7C78B82E  lwzx r3, r24, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 830DC640: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DC644: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830DC648: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830DC64C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830DC650: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830DC654: 4BC78C75  bl 0x82d552c8
	ctx.lr = 0x830DC658;
	sub_82D552C8(ctx, base);
	pc = 0x830DC658; continue 'dispatch;
            }
            0x830DC658 => {
    //   block [0x830DC658..0x830DC684)
	// 830DC658: 397C0001  addi r11, r28, 1
	ctx.r[11].s64 = ctx.r[28].s64 + 1;
	// 830DC65C: 81550000  lwz r10, 0(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC660: 91750004  stw r11, 4(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830DC664: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DC668: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 830DC66C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DC670: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830DC674: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DC678: 419A000C  beq cr6, 0x830dc684
	if ctx.cr[6].eq {
	pc = 0x830DC684; continue 'dispatch;
	}
	// 830DC67C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830DC680: 48000F59  bl 0x830dd5d8
	ctx.lr = 0x830DC684;
	sub_830DD5D8(ctx, base);
	pc = 0x830DC684; continue 'dispatch;
            }
            0x830DC684 => {
    //   block [0x830DC684..0x830DC6AC)
	// 830DC684: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 830DC688: 3BF90001  addi r31, r25, 1
	ctx.r[31].s64 = ctx.r[25].s64 + 1;
	// 830DC68C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DC690: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DC694: 409A0018  bne cr6, 0x830dc6ac
	if !ctx.cr[6].eq {
	pc = 0x830DC6AC; continue 'dispatch;
	}
	// 830DC698: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DC69C: 7C78B82E  lwzx r3, r24, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 830DC6A0: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DC6A4: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 830DC6A8: 4BC78C21  bl 0x82d552c8
	ctx.lr = 0x830DC6AC;
	sub_82D552C8(ctx, base);
	pc = 0x830DC6AC; continue 'dispatch;
            }
            0x830DC6AC => {
    //   block [0x830DC6AC..0x830DC6D4)
	// 830DC6AC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830DC6B0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DC6B4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DC6B8: 409AFAB8  bne cr6, 0x830dc170
	if !ctx.cr[6].eq {
	pc = 0x830DC170; continue 'dispatch;
	}
	// 830DC6BC: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DC6C0: 7C78B82E  lwzx r3, r24, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 830DC6C4: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DC6C8: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830DC6CC: 4BC78BFD  bl 0x82d552c8
	ctx.lr = 0x830DC6D0;
	sub_82D552C8(ctx, base);
	// 830DC6D0: 4BFFFAA0  b 0x830dc170
	pc = 0x830DC170; continue 'dispatch;
            }
            0x830DC6D4 => {
    //   block [0x830DC6D4..0x830DC6E0)
	// 830DC6D4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830DC6D8: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 830DC6DC: 4BBCCD58  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DC6E0 => {
    //   block [0x830DC6E0..0x830DC6F4)
	// 830DC6E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830DC6E4: 48000E75  bl 0x830dd558
	ctx.lr = 0x830DC6E8;
	sub_830DD558(ctx, base);
	// 830DC6E8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830DC6EC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 830DC6F0: 4BBCCD44  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DC6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DC6F8 size=2436
    let mut pc: u32 = 0x830DC6F8;
    'dispatch: loop {
        match pc {
            0x830DC6F8 => {
    //   block [0x830DC6F8..0x830DC768)
	// 830DC6F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DC6FC: 4BBCCCF1  bl 0x82ca93ec
	ctx.lr = 0x830DC700;
	sub_82CA93D0(ctx, base);
	// 830DC700: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DC704: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 830DC708: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 830DC70C: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 830DC710: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 830DC714: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 830DC718: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 830DC71C: 4813AB95  bl 0x832172b0
	ctx.lr = 0x830DC720;
	sub_832172B0(ctx, base);
	// 830DC720: 8176000C  lwz r11, 0xc(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DC724: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DC728: 419A0040  beq cr6, 0x830dc768
	if ctx.cr[6].eq {
	pc = 0x830DC768; continue 'dispatch;
	}
	// 830DC72C: 39760008  addi r11, r22, 8
	ctx.r[11].s64 = ctx.r[22].s64 + 8;
	// 830DC730: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 830DC734: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DC738: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC73C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830DC740: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830DC744: 814AFFFC  lwz r10, -4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830DC748: 91550000  stw r10, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830DC74C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DC750: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830DC754: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830DC758: 4813AC61  bl 0x832173b8
	ctx.lr = 0x830DC75C;
	sub_832173B8(ctx, base);
	// 830DC75C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830DC760: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 830DC764: 4BBCCCD8  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DC768 => {
    //   block [0x830DC768..0x830DC7BC)
	// 830DC768: 388100B8  addi r4, r1, 0xb8
	ctx.r[4].s64 = ctx.r[1].s64 + 184;
	// 830DC76C: 93350000  stw r25, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 830DC770: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830DC774: 4813A2FD  bl 0x83216a70
	ctx.lr = 0x830DC778;
	sub_83216A70(ctx, base);
	// 830DC778: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC77C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DC780: 409A0074  bne cr6, 0x830dc7f4
	if !ctx.cr[6].eq {
	pc = 0x830DC7F4; continue 'dispatch;
	}
	// 830DC784: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DC788: 3BD60014  addi r30, r22, 0x14
	ctx.r[30].s64 = ctx.r[22].s64 + 20;
	// 830DC78C: 3BABA400  addi r29, r11, -0x5c00
	ctx.r[29].s64 = ctx.r[11].s64 + -23552;
	// 830DC790: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DC794: 4BC7C495  bl 0x82d58c28
	ctx.lr = 0x830DC798;
	sub_82D58C28(ctx, base);
	// 830DC798: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DC79C: 3BE30001  addi r31, r3, 1
	ctx.r[31].s64 = ctx.r[3].s64 + 1;
	// 830DC7A0: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DC7A4: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830DC7A8: 40980024  bge cr6, 0x830dc7cc
	if !ctx.cr[6].lt {
	pc = 0x830DC7CC; continue 'dispatch;
	}
	// 830DC7AC: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DC7B0: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DC7B4: 41980008  blt cr6, 0x830dc7bc
	if ctx.cr[6].lt {
	pc = 0x830DC7BC; continue 'dispatch;
	}
	// 830DC7B8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x830DC7BC; continue 'dispatch;
            }
            0x830DC7BC => {
    //   block [0x830DC7BC..0x830DC7CC)
	// 830DC7BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DC7C0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830DC7C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DC7C8: 4BC7A749  bl 0x82d56f10
	ctx.lr = 0x830DC7CC;
	sub_82D56F10(ctx, base);
	pc = 0x830DC7CC; continue 'dispatch;
            }
            0x830DC7CC => {
    //   block [0x830DC7CC..0x830DC7F4)
	// 830DC7CC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830DC7D0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC7D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DC7D8: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 830DC7DC: 4BC7C555  bl 0x82d58d30
	ctx.lr = 0x830DC7E0;
	sub_82D58D30(ctx, base);
	// 830DC7E0: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 830DC7E4: 4813ABD5  bl 0x832173b8
	ctx.lr = 0x830DC7E8;
	sub_832173B8(ctx, base);
	// 830DC7E8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830DC7EC: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 830DC7F0: 4BBCCC4C  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DC7F4 => {
    //   block [0x830DC7F4..0x830DC854)
	// 830DC7F4: 3F008000  lis r24, -0x8000
	ctx.r[24].s64 = -2147483648;
	// 830DC7F8: 806100C0  lwz r3, 0xc0(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 830DC7FC: 93210068  stw r25, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 830DC800: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 830DC804: 9321006C  stw r25, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[25].u32 ) };
	// 830DC808: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DC80C: 93010070  stw r24, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[24].u32 ) };
	// 830DC810: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC814: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830DC818: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DC81C: 4E800421  bctrl
	ctx.lr = 0x830DC820;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DC820: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC824: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 830DC828: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 830DC82C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DC830: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DC834: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DC838: 4E800421  bctrl
	ctx.lr = 0x830DC83C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DC83C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DC840: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830DC844: 419A0174  beq cr6, 0x830dc9b8
	if ctx.cr[6].eq {
	pc = 0x830DC9B8; continue 'dispatch;
	}
	// 830DC848: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DC84C: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 830DC850: 3BABA3FC  addi r29, r11, -0x5c04
	ctx.r[29].s64 = ctx.r[11].s64 + -23556;
            }
            0x830DC854 => {
    //   block [0x830DC854..0x830DC89C)
	// 830DC854: 896100D0  lbz r11, 0xd0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 830DC858: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DC85C: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 830DC860: 409A0100  bne cr6, 0x830dc960
	if !ctx.cr[6].eq {
	pc = 0x830DC960; continue 'dispatch;
	}
	// 830DC864: 2F1F0002  cmpwi cr6, r31, 2
	ctx.cr[6].compare_i32(ctx.r[31].s32, 2, &mut ctx.xer);
	// 830DC868: 41980150  blt cr6, 0x830dc9b8
	if ctx.cr[6].lt {
	pc = 0x830DC9B8; continue 'dispatch;
	}
	// 830DC86C: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 830DC870: 409A00F0  bne cr6, 0x830dc960
	if !ctx.cr[6].eq {
	pc = 0x830DC960; continue 'dispatch;
	}
	// 830DC874: 896100D1  lbz r11, 0xd1(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(209 as u32) ) } as u64;
	// 830DC878: 2B0B003F  cmplwi cr6, r11, 0x3f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 63 as u32, &mut ctx.xer);
	// 830DC87C: 409A0020  bne cr6, 0x830dc89c
	if !ctx.cr[6].eq {
	pc = 0x830DC89C; continue 'dispatch;
	}
	// 830DC880: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830DC884: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830DC888: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 830DC88C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DC890: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 830DC894: 4BFFF385  bl 0x830dbc18
	ctx.lr = 0x830DC898;
	sub_830DBC18(ctx, base);
	// 830DC898: 480000E0  b 0x830dc978
	pc = 0x830DC978; continue 'dispatch;
            }
            0x830DC89C => {
    //   block [0x830DC89C..0x830DC8D4)
	// 830DC89C: 2F1F0004  cmpwi cr6, r31, 4
	ctx.cr[6].compare_i32(ctx.r[31].s32, 4, &mut ctx.xer);
	// 830DC8A0: 41980034  blt cr6, 0x830dc8d4
	if ctx.cr[6].lt {
	pc = 0x830DC8D4; continue 'dispatch;
	}
	// 830DC8A4: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 830DC8A8: 388100D1  addi r4, r1, 0xd1
	ctx.r[4].s64 = ctx.r[1].s64 + 209;
	// 830DC8AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DC8B0: 4BC7C159  bl 0x82d58a08
	ctx.lr = 0x830DC8B4;
	sub_82D58A08(ctx, base);
	// 830DC8B4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DC8B8: 409A001C  bne cr6, 0x830dc8d4
	if !ctx.cr[6].eq {
	pc = 0x830DC8D4; continue 'dispatch;
	}
	// 830DC8BC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830DC8C0: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 830DC8C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DC8C8: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 830DC8CC: 4BFFF1CD  bl 0x830dba98
	ctx.lr = 0x830DC8D0;
	sub_830DBA98(ctx, base);
	// 830DC8D0: 480000A8  b 0x830dc978
	pc = 0x830DC978; continue 'dispatch;
            }
            0x830DC8D4 => {
    //   block [0x830DC8D4..0x830DC908)
	// 830DC8D4: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830DC8D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DC8DC: 419A01DC  beq cr6, 0x830dcab8
	if ctx.cr[6].eq {
	pc = 0x830DCAB8; continue 'dispatch;
	}
	// 830DC8E0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC8E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DC8E8: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830DC8EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DC8F0: 4E800421  bctrl
	ctx.lr = 0x830DC8F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DC8F4: 8121006C  lwz r9, 0x6c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830DC8F8: 81010068  lwz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830DC8FC: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 830DC900: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830DC904: 4099004C  ble cr6, 0x830dc950
	if !ctx.cr[6].gt {
	pc = 0x830DC950; continue 'dispatch;
	}
            }
            0x830DC908 => {
    //   block [0x830DC908..0x830DC934)
	// 830DC908: 7D6850AE  lbzx r11, r8, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DC90C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DC910: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 830DC914: 419A0020  beq cr6, 0x830dc934
	if ctx.cr[6].eq {
	pc = 0x830DC934; continue 'dispatch;
	}
	// 830DC918: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 830DC91C: 419A0018  beq cr6, 0x830dc934
	if ctx.cr[6].eq {
	pc = 0x830DC934; continue 'dispatch;
	}
	// 830DC920: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 830DC924: 419A0010  beq cr6, 0x830dc934
	if ctx.cr[6].eq {
	pc = 0x830DC934; continue 'dispatch;
	}
	// 830DC928: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 830DC92C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 830DC930: 409A0008  bne cr6, 0x830dc938
	if !ctx.cr[6].eq {
	pc = 0x830DC938; continue 'dispatch;
	}
	pc = 0x830DC934; continue 'dispatch;
            }
            0x830DC934 => {
    //   block [0x830DC934..0x830DC938)
	// 830DC934: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x830DC938; continue 'dispatch;
            }
            0x830DC938 => {
    //   block [0x830DC938..0x830DC950)
	// 830DC938: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DC93C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DC940: 419A0010  beq cr6, 0x830dc950
	if ctx.cr[6].eq {
	pc = 0x830DC950; continue 'dispatch;
	}
	// 830DC944: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830DC948: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830DC94C: 4198FFBC  blt cr6, 0x830dc908
	if ctx.cr[6].lt {
	pc = 0x830DC908; continue 'dispatch;
	}
	pc = 0x830DC950; continue 'dispatch;
            }
            0x830DC950 => {
    //   block [0x830DC950..0x830DC960)
	// 830DC950: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830DC954: 409A00B4  bne cr6, 0x830dca08
	if !ctx.cr[6].eq {
	pc = 0x830DCA08; continue 'dispatch;
	}
	// 830DC958: 9321006C  stw r25, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[25].u32 ) };
	// 830DC95C: 4800001C  b 0x830dc978
	pc = 0x830DC978; continue 'dispatch;
            }
            0x830DC960 => {
    //   block [0x830DC960..0x830DC978)
	// 830DC960: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 830DC964: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830DC968: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 830DC96C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DC970: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 830DC974: 4BFFF37D  bl 0x830dbcf0
	ctx.lr = 0x830DC978;
	sub_830DBCF0(ctx, base);
	pc = 0x830DC978; continue 'dispatch;
            }
            0x830DC978 => {
    //   block [0x830DC978..0x830DC9B8)
	// 830DC978: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC97C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 830DC980: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DC984: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830DC988: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DC98C: 4E800421  bctrl
	ctx.lr = 0x830DC990;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DC990: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC994: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 830DC998: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 830DC99C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DC9A0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DC9A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DC9A8: 4E800421  bctrl
	ctx.lr = 0x830DC9AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DC9AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DC9B0: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830DC9B4: 409AFEA0  bne cr6, 0x830dc854
	if !ctx.cr[6].eq {
	pc = 0x830DC854; continue 'dispatch;
	}
            }
            0x830DC9B8 => {
    //   block [0x830DC9B8..0x830DC9C8)
	// 830DC9B8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DC9BC: 38760014  addi r3, r22, 0x14
	ctx.r[3].s64 = ctx.r[22].s64 + 20;
	// 830DC9C0: 388BA3E4  addi r4, r11, -0x5c1c
	ctx.r[4].s64 = ctx.r[11].s64 + -23580;
	// 830DC9C4: 4BC7C4CD  bl 0x82d58e90
	ctx.lr = 0x830DC9C8;
	sub_82D58E90(ctx, base);
	pc = 0x830DC9C8; continue 'dispatch;
            }
            0x830DC9C8 => {
    //   block [0x830DC9C8..0x830DC9F4)
	// 830DC9C8: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830DC9CC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DC9D0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DC9D4: 409A0020  bne cr6, 0x830dc9f4
	if !ctx.cr[6].eq {
	pc = 0x830DC9F4; continue 'dispatch;
	}
	// 830DC9D8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DC9DC: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DC9E0: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DC9E4: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830DC9E8: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DC9EC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DC9F0: 4BC788D9  bl 0x82d552c8
	ctx.lr = 0x830DC9F4;
	sub_82D552C8(ctx, base);
	pc = 0x830DC9F4; continue 'dispatch;
            }
            0x830DC9F4 => {
    //   block [0x830DC9F4..0x830DCA08)
	// 830DC9F4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 830DC9F8: 4813A9C1  bl 0x832173b8
	ctx.lr = 0x830DC9FC;
	sub_832173B8(ctx, base);
	// 830DC9FC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830DCA00: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 830DCA04: 4BBCCA38  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DCA08 => {
    //   block [0x830DCA08..0x830DCA2C)
	// 830DCA08: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830DCA0C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DCA10: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DCA14: 409A0018  bne cr6, 0x830dca2c
	if !ctx.cr[6].eq {
	pc = 0x830DCA2C; continue 'dispatch;
	}
	// 830DCA18: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DCA1C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 830DCA20: 4BC7A579  bl 0x82d56f98
	ctx.lr = 0x830DCA24;
	sub_82D56F98(ctx, base);
	// 830DCA24: 8121006C  lwz r9, 0x6c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830DCA28: 81010068  lwz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	pc = 0x830DCA2C; continue 'dispatch;
            }
            0x830DCA2C => {
    //   block [0x830DCA2C..0x830DCAA4)
	// 830DCA2C: 7F2941AE  stbx r25, r9, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[25].u8) };
	// 830DCA30: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830DCA34: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830DCA38: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830DCA3C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 830DCA40: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830DCA44: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 830DCA48: 4BFFECF1  bl 0x830db738
	ctx.lr = 0x830DCA4C;
	sub_830DB738(ctx, base);
	// 830DCA4C: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DCA50: 3BE00004  li r31, 4
	ctx.r[31].s64 = 4;
	// 830DCA54: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DCA58: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 830DCA5C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830DCA60: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830DCA64: 4BC787E5  bl 0x82d55248
	ctx.lr = 0x830DCA68;
	sub_82D55248(ctx, base);
	// 830DCA68: 39600018  li r11, 0x18
	ctx.r[11].s64 = 24;
	// 830DCA6C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830DCA70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DCA74: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 830DCA78: 48000A49  bl 0x830dd4c0
	ctx.lr = 0x830DCA7C;
	sub_830DD4C0(ctx, base);
	// 830DCA7C: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830DCA80: 90750000  stw r3, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830DCA84: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DCA88: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DCA8C: 409A0018  bne cr6, 0x830dcaa4
	if !ctx.cr[6].eq {
	pc = 0x830DCAA4; continue 'dispatch;
	}
	// 830DCA90: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DCA94: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830DCA98: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DCA9C: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830DCAA0: 4BC78829  bl 0x82d552c8
	ctx.lr = 0x830DCAA4;
	sub_82D552C8(ctx, base);
	pc = 0x830DCAA4; continue 'dispatch;
            }
            0x830DCAA4 => {
    //   block [0x830DCAA4..0x830DCAB8)
	// 830DCAA4: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 830DCAA8: 4813A911  bl 0x832173b8
	ctx.lr = 0x830DCAAC;
	sub_832173B8(ctx, base);
	// 830DCAAC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830DCAB0: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 830DCAB4: 4BBCC988  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DCAB8 => {
    //   block [0x830DCAB8..0x830DCB28)
	// 830DCAB8: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 830DCABC: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 830DCAC0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830DCAC4: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 830DCAC8: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 830DCACC: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 830DCAD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DCAD4: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 830DCAD8: 4BFFF141  bl 0x830dbc18
	ctx.lr = 0x830DCADC;
	sub_830DBC18(ctx, base);
	// 830DCADC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830DCAE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DCAE4: 409A0044  bne cr6, 0x830dcb28
	if !ctx.cr[6].eq {
	pc = 0x830DCB28; continue 'dispatch;
	}
	// 830DCAE8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DCAEC: 38760014  addi r3, r22, 0x14
	ctx.r[3].s64 = ctx.r[22].s64 + 20;
	// 830DCAF0: 388BA3D8  addi r4, r11, -0x5c28
	ctx.r[4].s64 = ctx.r[11].s64 + -23592;
	// 830DCAF4: 4BC7C39D  bl 0x82d58e90
	ctx.lr = 0x830DCAF8;
	sub_82D58E90(ctx, base);
	// 830DCAF8: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DCAFC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DCB00: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DCB04: 409AFEC4  bne cr6, 0x830dc9c8
	if !ctx.cr[6].eq {
	pc = 0x830DC9C8; continue 'dispatch;
	}
	// 830DCB08: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DCB0C: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DCB10: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DCB14: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DCB18: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DCB1C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DCB20: 4BC787A9  bl 0x82d552c8
	ctx.lr = 0x830DCB24;
	sub_82D552C8(ctx, base);
	// 830DCB24: 4BFFFEA4  b 0x830dc9c8
	pc = 0x830DC9C8; continue 'dispatch;
            }
            0x830DCB28 => {
    //   block [0x830DCB28..0x830DCB48)
	// 830DCB28: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DCB2C: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 830DCB30: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830DCB34: 409A0014  bne cr6, 0x830dcb48
	if !ctx.cr[6].eq {
	pc = 0x830DCB48; continue 'dispatch;
	}
	// 830DCB38: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DCB3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830DCB40: 4BC7A459  bl 0x82d56f98
	ctx.lr = 0x830DCB44;
	sub_82D56F98(ctx, base);
	// 830DCB44: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x830DCB48; continue 'dispatch;
            }
            0x830DCB48 => {
    //   block [0x830DCB48..0x830DCBB0)
	// 830DCB48: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DCB4C: 7F2B51AE  stbx r25, r11, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[25].u8) };
	// 830DCB50: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830DCB54: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DCB58: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830DCB5C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 830DCB60: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830DCB64: 4BFFEBD5  bl 0x830db738
	ctx.lr = 0x830DCB68;
	sub_830DB738(ctx, base);
	// 830DCB68: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 830DCB6C: 409A0044  bne cr6, 0x830dcbb0
	if !ctx.cr[6].eq {
	pc = 0x830DCBB0; continue 'dispatch;
	}
	// 830DCB70: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DCB74: 38760014  addi r3, r22, 0x14
	ctx.r[3].s64 = ctx.r[22].s64 + 20;
	// 830DCB78: 388BA3D0  addi r4, r11, -0x5c30
	ctx.r[4].s64 = ctx.r[11].s64 + -23600;
	// 830DCB7C: 4BC7C315  bl 0x82d58e90
	ctx.lr = 0x830DCB80;
	sub_82D58E90(ctx, base);
	// 830DCB80: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DCB84: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DCB88: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DCB8C: 409AFE3C  bne cr6, 0x830dc9c8
	if !ctx.cr[6].eq {
	pc = 0x830DC9C8; continue 'dispatch;
	}
	// 830DCB90: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DCB94: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DCB98: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DCB9C: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DCBA0: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DCBA4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DCBA8: 4BC78721  bl 0x82d552c8
	ctx.lr = 0x830DCBAC;
	sub_82D552C8(ctx, base);
	// 830DCBAC: 4BFFFE1C  b 0x830dc9c8
	pc = 0x830DC9C8; continue 'dispatch;
            }
            0x830DCBB0 => {
    //   block [0x830DCBB0..0x830DCC0C)
	// 830DCBB0: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 830DCBB4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DCBB8: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 830DCBBC: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 830DCBC0: 2B0A002F  cmplwi cr6, r10, 0x2f
	ctx.cr[6].compare_u32(ctx.r[10].u32, 47 as u32, &mut ctx.xer);
	// 830DCBC4: 409A0138  bne cr6, 0x830dccfc
	if !ctx.cr[6].eq {
	pc = 0x830DCCFC; continue 'dispatch;
	}
	// 830DCBC8: 3BCB0002  addi r30, r11, 2
	ctx.r[30].s64 = ctx.r[11].s64 + 2;
	// 830DCBCC: 93210088  stw r25, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[25].u32 ) };
	// 830DCBD0: 9321008C  stw r25, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[25].u32 ) };
	// 830DCBD4: 93010090  stw r24, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[24].u32 ) };
	// 830DCBD8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830DCBDC: 419A0058  beq cr6, 0x830dcc34
	if ctx.cr[6].eq {
	pc = 0x830DCC34; continue 'dispatch;
	}
	// 830DCBE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DCBE4: 4BC7C045  bl 0x82d58c28
	ctx.lr = 0x830DCBE8;
	sub_82D58C28(ctx, base);
	// 830DCBE8: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 830DCBEC: 3BE30001  addi r31, r3, 1
	ctx.r[31].s64 = ctx.r[3].s64 + 1;
	// 830DCBF0: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DCBF4: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830DCBF8: 40980024  bge cr6, 0x830dcc1c
	if !ctx.cr[6].lt {
	pc = 0x830DCC1C; continue 'dispatch;
	}
	// 830DCBFC: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DCC00: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DCC04: 41980008  blt cr6, 0x830dcc0c
	if ctx.cr[6].lt {
	pc = 0x830DCC0C; continue 'dispatch;
	}
	// 830DCC08: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x830DCC0C; continue 'dispatch;
            }
            0x830DCC0C => {
    //   block [0x830DCC0C..0x830DCC1C)
	// 830DCC0C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DCC10: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830DCC14: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 830DCC18: 4BC7A2F9  bl 0x82d56f10
	ctx.lr = 0x830DCC1C;
	sub_82D56F10(ctx, base);
	pc = 0x830DCC1C; continue 'dispatch;
            }
            0x830DCC1C => {
    //   block [0x830DCC1C..0x830DCC34)
	// 830DCC1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830DCC20: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830DCC24: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830DCC28: 93E1008C  stw r31, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[31].u32 ) };
	// 830DCC2C: 4BC7C105  bl 0x82d58d30
	ctx.lr = 0x830DCC30;
	sub_82D58D30(ctx, base);
	// 830DCC30: 48000020  b 0x830dcc50
	pc = 0x830DCC50; continue 'dispatch;
            }
            0x830DCC34 => {
    //   block [0x830DCC34..0x830DCC50)
	// 830DCC34: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DCC38: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DCC3C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 830DCC40: 4BC7A2D1  bl 0x82d56f10
	ctx.lr = 0x830DCC44;
	sub_82D56F10(ctx, base);
	// 830DCC44: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830DCC48: 92E1008C  stw r23, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[23].u32 ) };
	// 830DCC4C: 9B2B0000  stb r25, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	pc = 0x830DCC50; continue 'dispatch;
            }
            0x830DCC50 => {
    //   block [0x830DCC50..0x830DCCA0)
	// 830DCC50: 83CD0000  lwz r30, 0(r13)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DCC54: 3BE00004  li r31, 4
	ctx.r[31].s64 = 4;
	// 830DCC58: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DCC5C: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 830DCC60: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830DCC64: 4BC785E5  bl 0x82d55248
	ctx.lr = 0x830DCC68;
	sub_82D55248(ctx, base);
	// 830DCC68: 39600018  li r11, 0x18
	ctx.r[11].s64 = 24;
	// 830DCC6C: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 830DCC70: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 830DCC74: 480007C5  bl 0x830dd438
	ctx.lr = 0x830DCC78;
	sub_830DD438(ctx, base);
	// 830DCC78: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 830DCC7C: 90750000  stw r3, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830DCC80: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DCC84: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DCC88: 409A0018  bne cr6, 0x830dcca0
	if !ctx.cr[6].eq {
	pc = 0x830DCCA0; continue 'dispatch;
	}
	// 830DCC8C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DCC90: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830DCC94: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DCC98: 80810088  lwz r4, 0x88(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830DCC9C: 4BC7862D  bl 0x82d552c8
	ctx.lr = 0x830DCCA0;
	sub_82D552C8(ctx, base);
	pc = 0x830DCCA0; continue 'dispatch;
            }
            0x830DCCA0 => {
    //   block [0x830DCCA0..0x830DCCC4)
	// 830DCCA0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DCCA4: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DCCA8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DCCAC: 409A0018  bne cr6, 0x830dccc4
	if !ctx.cr[6].eq {
	pc = 0x830DCCC4; continue 'dispatch;
	}
	// 830DCCB0: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DCCB4: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830DCCB8: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DCCBC: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DCCC0: 4BC78609  bl 0x82d552c8
	ctx.lr = 0x830DCCC4;
	sub_82D552C8(ctx, base);
	pc = 0x830DCCC4; continue 'dispatch;
            }
            0x830DCCC4 => {
    //   block [0x830DCCC4..0x830DCCE8)
	// 830DCCC4: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830DCCC8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DCCCC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DCCD0: 409A0018  bne cr6, 0x830dcce8
	if !ctx.cr[6].eq {
	pc = 0x830DCCE8; continue 'dispatch;
	}
	// 830DCCD4: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DCCD8: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830DCCDC: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DCCE0: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830DCCE4: 4BC785E5  bl 0x82d552c8
	ctx.lr = 0x830DCCE8;
	sub_82D552C8(ctx, base);
	pc = 0x830DCCE8; continue 'dispatch;
            }
            0x830DCCE8 => {
    //   block [0x830DCCE8..0x830DCCFC)
	// 830DCCE8: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 830DCCEC: 4813A6CD  bl 0x832173b8
	ctx.lr = 0x830DCCF0;
	sub_832173B8(ctx, base);
	// 830DCCF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830DCCF4: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 830DCCF8: 4BBCC744  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DCCFC => {
    //   block [0x830DCCFC..0x830DCD30)
	// 830DCCFC: 7D4B1A14  add r10, r11, r3
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 830DCD00: 892AFFFF  lbz r9, -1(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-1 as u32) ) } as u64;
	// 830DCD04: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 830DCD08: 3929FFD1  addi r9, r9, -0x2f
	ctx.r[9].s64 = ctx.r[9].s64 + -47;
	// 830DCD0C: 7D290034  cntlzw r9, r9
	ctx.r[9].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 830DCD10: 553CDFFE  rlwinm r28, r9, 0x1b, 0x1f, 0x1f
	ctx.r[28].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 830DCD14: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830DCD18: 419A0018  beq cr6, 0x830dcd30
	if ctx.cr[6].eq {
	pc = 0x830DCD30; continue 'dispatch;
	}
	// 830DCD1C: 9B2AFFFF  stb r25, -1(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-1 as u32), ctx.r[25].u8 ) };
	// 830DCD20: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830DCD24: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 830DCD28: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DCD2C: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	pc = 0x830DCD30; continue 'dispatch;
            }
            0x830DCD30 => {
    //   block [0x830DCD30..0x830DCD3C)
	// 830DCD30: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 830DCD34: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830DCD38: 4099001C  ble cr6, 0x830dcd54
	if !ctx.cr[6].gt {
	pc = 0x830DCD54; continue 'dispatch;
	}
	pc = 0x830DCD3C; continue 'dispatch;
            }
            0x830DCD3C => {
    //   block [0x830DCD3C..0x830DCD54)
	// 830DCD3C: 7D4BF8AE  lbzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830DCD40: 2B0A0020  cmplwi cr6, r10, 0x20
	ctx.cr[6].compare_u32(ctx.r[10].u32, 32 as u32, &mut ctx.xer);
	// 830DCD44: 419A0010  beq cr6, 0x830dcd54
	if ctx.cr[6].eq {
	pc = 0x830DCD54; continue 'dispatch;
	}
	// 830DCD48: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830DCD4C: 7F1F4000  cmpw cr6, r31, r8
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830DCD50: 4198FFEC  blt cr6, 0x830dcd3c
	if ctx.cr[6].lt {
	pc = 0x830DCD3C; continue 'dispatch;
	}
	pc = 0x830DCD54; continue 'dispatch;
            }
            0x830DCD54 => {
    //   block [0x830DCD54..0x830DCD84)
	// 830DCD54: 93210078  stw r25, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[25].u32 ) };
	// 830DCD58: 7F1F4000  cmpw cr6, r31, r8
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830DCD5C: 9321007C  stw r25, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[25].u32 ) };
	// 830DCD60: 93010080  stw r24, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[24].u32 ) };
	// 830DCD64: 419A0020  beq cr6, 0x830dcd84
	if ctx.cr[6].eq {
	pc = 0x830DCD84; continue 'dispatch;
	}
	// 830DCD68: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 830DCD6C: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830DCD70: 4BFFF3E1  bl 0x830dc150
	ctx.lr = 0x830DCD74;
	sub_830DC150(ctx, base);
	// 830DCD74: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DCD78: 7F2BF9AE  stbx r25, r11, r31
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[25].u8) };
	// 830DCD7C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DCD80: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	pc = 0x830DCD84; continue 'dispatch;
            }
            0x830DCD84 => {
    //   block [0x830DCD84..0x830DCDEC)
	// 830DCD84: 834D0000  lwz r26, 0(r13)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DCD88: 3B600004  li r27, 4
	ctx.r[27].s64 = 4;
	// 830DCD8C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DCD90: 38800024  li r4, 0x24
	ctx.r[4].s64 = 36;
	// 830DCD94: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 830DCD98: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 830DCD9C: 4BC784AD  bl 0x82d55248
	ctx.lr = 0x830DCDA0;
	sub_82D55248(ctx, base);
	// 830DCDA0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DCDA4: 39600024  li r11, 0x24
	ctx.r[11].s64 = 36;
	// 830DCDA8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830DCDAC: B17E0004  sth r11, 4(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 830DCDB0: 93210098  stw r25, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[25].u32 ) };
	// 830DCDB4: 9321009C  stw r25, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[25].u32 ) };
	// 830DCDB8: 930100A0  stw r24, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[24].u32 ) };
	// 830DCDBC: 419A0058  beq cr6, 0x830dce14
	if ctx.cr[6].eq {
	pc = 0x830DCE14; continue 'dispatch;
	}
	// 830DCDC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DCDC4: 4BC7BE65  bl 0x82d58c28
	ctx.lr = 0x830DCDC8;
	sub_82D58C28(ctx, base);
	// 830DCDC8: 816100A0  lwz r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 830DCDCC: 3BE30001  addi r31, r3, 1
	ctx.r[31].s64 = ctx.r[3].s64 + 1;
	// 830DCDD0: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DCDD4: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830DCDD8: 40980024  bge cr6, 0x830dcdfc
	if !ctx.cr[6].lt {
	pc = 0x830DCDFC; continue 'dispatch;
	}
	// 830DCDDC: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DCDE0: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DCDE4: 41980008  blt cr6, 0x830dcdec
	if ctx.cr[6].lt {
	pc = 0x830DCDEC; continue 'dispatch;
	}
	// 830DCDE8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x830DCDEC; continue 'dispatch;
            }
            0x830DCDEC => {
    //   block [0x830DCDEC..0x830DCDFC)
	// 830DCDEC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DCDF0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830DCDF4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 830DCDF8: 4BC7A119  bl 0x82d56f10
	ctx.lr = 0x830DCDFC;
	sub_82D56F10(ctx, base);
	pc = 0x830DCDFC; continue 'dispatch;
            }
            0x830DCDFC => {
    //   block [0x830DCDFC..0x830DCE14)
	// 830DCDFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830DCE00: 80610098  lwz r3, 0x98(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 830DCE04: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DCE08: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 830DCE0C: 4BC7BF25  bl 0x82d58d30
	ctx.lr = 0x830DCE10;
	sub_82D58D30(ctx, base);
	// 830DCE10: 48000020  b 0x830dce30
	pc = 0x830DCE30; continue 'dispatch;
            }
            0x830DCE14 => {
    //   block [0x830DCE14..0x830DCE30)
	// 830DCE14: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DCE18: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DCE1C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 830DCE20: 4BC7A0F1  bl 0x82d56f10
	ctx.lr = 0x830DCE24;
	sub_82D56F10(ctx, base);
	// 830DCE24: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 830DCE28: 92E1009C  stw r23, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[23].u32 ) };
	// 830DCE2C: 9B2B0000  stb r25, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	pc = 0x830DCE30; continue 'dispatch;
            }
            0x830DCE30 => {
    //   block [0x830DCE30..0x830DCE64)
	// 830DCE30: 38810098  addi r4, r1, 0x98
	ctx.r[4].s64 = ctx.r[1].s64 + 152;
	// 830DCE34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DCE38: 48000959  bl 0x830dd790
	ctx.lr = 0x830DCE3C;
	sub_830DD790(ctx, base);
	// 830DCE3C: 816100A0  lwz r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 830DCE40: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DCE44: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DCE48: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DCE4C: 409A0018  bne cr6, 0x830dce64
	if !ctx.cr[6].eq {
	pc = 0x830DCE64; continue 'dispatch;
	}
	// 830DCE50: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DCE54: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 830DCE58: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DCE5C: 80810098  lwz r4, 0x98(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 830DCE60: 4BC78469  bl 0x82d552c8
	ctx.lr = 0x830DCE64;
	sub_82D552C8(ctx, base);
	pc = 0x830DCE64; continue 'dispatch;
            }
            0x830DCE64 => {
    //   block [0x830DCE64..0x830DCEF8)
	// 830DCE64: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830DCE68: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830DCE6C: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830DCE70: 915E0018  stw r10, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 830DCE74: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 830DCE78: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 830DCE7C: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 830DCE80: 915E001C  stw r10, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 830DCE84: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 830DCE88: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830DCE8C: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 830DCE90: 915E0020  stw r10, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830DCE94: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 830DCE98: 419A00E0  beq cr6, 0x830dcf78
	if ctx.cr[6].eq {
	pc = 0x830DCF78; continue 'dispatch;
	}
	// 830DCE9C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DCEA0: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 830DCEA4: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 830DCEA8: 4BC783A1  bl 0x82d55248
	ctx.lr = 0x830DCEAC;
	sub_82D55248(ctx, base);
	// 830DCEAC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830DCEB0: 39600018  li r11, 0x18
	ctx.r[11].s64 = 24;
	// 830DCEB4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830DCEB8: B17C0004  sth r11, 4(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 830DCEBC: 932100A8  stw r25, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[25].u32 ) };
	// 830DCEC0: 932100AC  stw r25, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[25].u32 ) };
	// 830DCEC4: 930100B0  stw r24, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[24].u32 ) };
	// 830DCEC8: 419A0058  beq cr6, 0x830dcf20
	if ctx.cr[6].eq {
	pc = 0x830DCF20; continue 'dispatch;
	}
	// 830DCECC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DCED0: 4BC7BD59  bl 0x82d58c28
	ctx.lr = 0x830DCED4;
	sub_82D58C28(ctx, base);
	// 830DCED4: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 830DCED8: 3BE30001  addi r31, r3, 1
	ctx.r[31].s64 = ctx.r[3].s64 + 1;
	// 830DCEDC: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DCEE0: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830DCEE4: 40980024  bge cr6, 0x830dcf08
	if !ctx.cr[6].lt {
	pc = 0x830DCF08; continue 'dispatch;
	}
	// 830DCEE8: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DCEEC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DCEF0: 41980008  blt cr6, 0x830dcef8
	if ctx.cr[6].lt {
	pc = 0x830DCEF8; continue 'dispatch;
	}
	// 830DCEF4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x830DCEF8; continue 'dispatch;
            }
            0x830DCEF8 => {
    //   block [0x830DCEF8..0x830DCF08)
	// 830DCEF8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DCEFC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830DCF00: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 830DCF04: 4BC7A00D  bl 0x82d56f10
	ctx.lr = 0x830DCF08;
	sub_82D56F10(ctx, base);
	pc = 0x830DCF08; continue 'dispatch;
            }
            0x830DCF08 => {
    //   block [0x830DCF08..0x830DCF20)
	// 830DCF08: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830DCF0C: 806100A8  lwz r3, 0xa8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 830DCF10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DCF14: 93E100AC  stw r31, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[31].u32 ) };
	// 830DCF18: 4BC7BE19  bl 0x82d58d30
	ctx.lr = 0x830DCF1C;
	sub_82D58D30(ctx, base);
	// 830DCF1C: 48000020  b 0x830dcf3c
	pc = 0x830DCF3C; continue 'dispatch;
            }
            0x830DCF20 => {
    //   block [0x830DCF20..0x830DCF3C)
	// 830DCF20: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DCF24: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DCF28: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 830DCF2C: 4BC79FE5  bl 0x82d56f10
	ctx.lr = 0x830DCF30;
	sub_82D56F10(ctx, base);
	// 830DCF30: 816100A8  lwz r11, 0xa8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 830DCF34: 92E100AC  stw r23, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[23].u32 ) };
	// 830DCF38: 9B2B0000  stb r25, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	pc = 0x830DCF3C; continue 'dispatch;
            }
            0x830DCF3C => {
    //   block [0x830DCF3C..0x830DCF78)
	// 830DCF3C: 388100A8  addi r4, r1, 0xa8
	ctx.r[4].s64 = ctx.r[1].s64 + 168;
	// 830DCF40: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DCF44: 480004F5  bl 0x830dd438
	ctx.lr = 0x830DCF48;
	sub_830DD438(ctx, base);
	// 830DCF48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830DCF4C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830DCF50: 4BFFEE71  bl 0x830dbdc0
	ctx.lr = 0x830DCF54;
	sub_830DBDC0(ctx, base);
	// 830DCF54: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 830DCF58: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DCF5C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DCF60: 409A0018  bne cr6, 0x830dcf78
	if !ctx.cr[6].eq {
	pc = 0x830DCF78; continue 'dispatch;
	}
	// 830DCF64: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DCF68: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 830DCF6C: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DCF70: 808100A8  lwz r4, 0xa8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 830DCF74: 4BC78355  bl 0x82d552c8
	ctx.lr = 0x830DCF78;
	sub_82D552C8(ctx, base);
	pc = 0x830DCF78; continue 'dispatch;
            }
            0x830DCF78 => {
    //   block [0x830DCF78..0x830DCF90)
	// 830DCF78: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 830DCF7C: 93D50000  stw r30, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830DCF80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DCF84: 4099006C  ble cr6, 0x830dcff0
	if !ctx.cr[6].gt {
	pc = 0x830DCFF0; continue 'dispatch;
	}
	// 830DCF88: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 830DCF8C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	pc = 0x830DCF90; continue 'dispatch;
            }
            0x830DCF90 => {
    //   block [0x830DCF90..0x830DCFBC)
	// 830DCF90: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830DCF94: 7FFE5A14  add r31, r30, r11
	ctx.r[31].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830DCF98: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830DCF9C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DCFA0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DCFA4: 409A0018  bne cr6, 0x830dcfbc
	if !ctx.cr[6].eq {
	pc = 0x830DCFBC; continue 'dispatch;
	}
	// 830DCFA8: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DCFAC: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DCFB0: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DCFB4: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 830DCFB8: 4BC78311  bl 0x82d552c8
	ctx.lr = 0x830DCFBC;
	sub_82D552C8(ctx, base);
	pc = 0x830DCFBC; continue 'dispatch;
            }
            0x830DCFBC => {
    //   block [0x830DCFBC..0x830DCFE0)
	// 830DCFBC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DCFC0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DCFC4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DCFC8: 409A0018  bne cr6, 0x830dcfe0
	if !ctx.cr[6].eq {
	pc = 0x830DCFE0; continue 'dispatch;
	}
	// 830DCFCC: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DCFD0: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DCFD4: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DCFD8: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 830DCFDC: 4BC782ED  bl 0x82d552c8
	ctx.lr = 0x830DCFE0;
	sub_82D552C8(ctx, base);
	pc = 0x830DCFE0; continue 'dispatch;
            }
            0x830DCFE0 => {
    //   block [0x830DCFE0..0x830DCFF0)
	// 830DCFE0: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 830DCFE4: 3BDE0018  addi r30, r30, 0x18
	ctx.r[30].s64 = ctx.r[30].s64 + 24;
	// 830DCFE8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830DCFEC: 409AFFA4  bne cr6, 0x830dcf90
	if !ctx.cr[6].eq {
	pc = 0x830DCF90; continue 'dispatch;
	}
	pc = 0x830DCFF0; continue 'dispatch;
            }
            0x830DCFF0 => {
    //   block [0x830DCFF0..0x830DD020)
	// 830DCFF0: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 830DCFF4: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DCFF8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DCFFC: 409A0024  bne cr6, 0x830dd020
	if !ctx.cr[6].eq {
	pc = 0x830DD020; continue 'dispatch;
	}
	// 830DD000: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DD004: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 830DD008: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DD00C: 80810078  lwz r4, 0x78(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830DD010: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830DD014: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830DD018: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830DD01C: 4BC782AD  bl 0x82d552c8
	ctx.lr = 0x830DD020;
	sub_82D552C8(ctx, base);
	pc = 0x830DD020; continue 'dispatch;
            }
            0x830DD020 => {
    //   block [0x830DD020..0x830DD044)
	// 830DD020: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DD024: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DD028: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DD02C: 409A0018  bne cr6, 0x830dd044
	if !ctx.cr[6].eq {
	pc = 0x830DD044; continue 'dispatch;
	}
	// 830DD030: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DD034: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 830DD038: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DD03C: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DD040: 4BC78289  bl 0x82d552c8
	ctx.lr = 0x830DD044;
	sub_82D552C8(ctx, base);
	pc = 0x830DD044; continue 'dispatch;
            }
            0x830DD044 => {
    //   block [0x830DD044..0x830DD068)
	// 830DD044: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830DD048: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DD04C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DD050: 409A0018  bne cr6, 0x830dd068
	if !ctx.cr[6].eq {
	pc = 0x830DD068; continue 'dispatch;
	}
	// 830DD054: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DD058: 7C7BD02E  lwzx r3, r27, r26
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 830DD05C: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DD060: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830DD064: 4BC78265  bl 0x82d552c8
	ctx.lr = 0x830DD068;
	sub_82D552C8(ctx, base);
	pc = 0x830DD068; continue 'dispatch;
            }
            0x830DD068 => {
    //   block [0x830DD068..0x830DD07C)
	// 830DD068: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 830DD06C: 4813A34D  bl 0x832173b8
	ctx.lr = 0x830DD070;
	sub_832173B8(ctx, base);
	// 830DD070: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830DD074: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 830DD078: 4BBCC3C4  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DD080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DD080 size=516
    let mut pc: u32 = 0x830DD080;
    'dispatch: loop {
        match pc {
            0x830DD080 => {
    //   block [0x830DD080..0x830DD0F8)
	// 830DD080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DD084: 4BBCC37D  bl 0x82ca9400
	ctx.lr = 0x830DD088;
	sub_82CA93D0(ctx, base);
	// 830DD088: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DD08C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830DD090: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830DD094: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830DD098: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830DD09C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830DD0A0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830DD0A4: 4813A20D  bl 0x832172b0
	ctx.lr = 0x830DD0A8;
	sub_832172B0(ctx, base);
	// 830DD0A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DD0AC: 4800025D  bl 0x830dd308
	ctx.lr = 0x830DD0B0;
	sub_830DD308(ctx, base);
	// 830DD0B0: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 830DD0B4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 830DD0B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DD0BC: 4813AB95  bl 0x83217c50
	ctx.lr = 0x830DD0C0;
	sub_83217C50(ctx, base);
	// 830DD0C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830DD0C4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830DD0C8: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830DD0CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DD0D0: 4813ABE1  bl 0x83217cb0
	ctx.lr = 0x830DD0D4;
	sub_83217CB0(ctx, base);
	// 830DD0D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830DD0D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DD0DC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830DD0E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830DD0E4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830DD0E8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830DD0EC: 4BFFF60D  bl 0x830dc6f8
	ctx.lr = 0x830DD0F0;
	sub_830DC6F8(ctx, base);
	// 830DD0F0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DD0F4: 409A0104  bne cr6, 0x830dd1f8
	if !ctx.cr[6].eq {
	pc = 0x830DD1F8; continue 'dispatch;
	}
	pc = 0x830DD0F8; continue 'dispatch;
            }
            0x830DD0F8 => {
    //   block [0x830DD0F8..0x830DD138)
	// 830DD0F8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DD0FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DD100: 419A00B4  beq cr6, 0x830dd1b4
	if ctx.cr[6].eq {
	pc = 0x830DD1B4; continue 'dispatch;
	}
	// 830DD104: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DD108: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830DD10C: 419A00BC  beq cr6, 0x830dd1c8
	if ctx.cr[6].eq {
	pc = 0x830DD1C8; continue 'dispatch;
	}
	// 830DD110: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830DD114: 419A0024  beq cr6, 0x830dd138
	if ctx.cr[6].eq {
	pc = 0x830DD138; continue 'dispatch;
	}
	// 830DD118: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830DD11C: 409A00C4  bne cr6, 0x830dd1e0
	if !ctx.cr[6].eq {
	pc = 0x830DD1E0; continue 'dispatch;
	}
	// 830DD120: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830DD124: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830DD128: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830DD12C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DD130: 4813AB81  bl 0x83217cb0
	ctx.lr = 0x830DD134;
	sub_83217CB0(ctx, base);
	// 830DD134: 480000AC  b 0x830dd1e0
	pc = 0x830DD1E0; continue 'dispatch;
            }
            0x830DD138 => {
    //   block [0x830DD138..0x830DD170)
	// 830DD138: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830DD13C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DD140: 4813AB09  bl 0x83217c48
	ctx.lr = 0x830DD144;
	sub_83217C48(ctx, base);
	// 830DD144: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD148: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DD14C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 830DD150: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DD154: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830DD158: 409A0018  bne cr6, 0x830dd170
	if !ctx.cr[6].eq {
	pc = 0x830DD170; continue 'dispatch;
	}
	// 830DD15C: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DD160: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DD164: 4BC7B875  bl 0x82d589d8
	ctx.lr = 0x830DD168;
	sub_82D589D8(ctx, base);
	// 830DD168: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DD16C: 409A00DC  bne cr6, 0x830dd248
	if !ctx.cr[6].eq {
	pc = 0x830DD248; continue 'dispatch;
	}
	pc = 0x830DD170; continue 'dispatch;
            }
            0x830DD170 => {
    //   block [0x830DD170..0x830DD1AC)
	// 830DD170: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DD174: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830DD178: 409A00FC  bne cr6, 0x830dd274
	if !ctx.cr[6].eq {
	pc = 0x830DD274; continue 'dispatch;
	}
	// 830DD17C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830DD180: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DD184: 4813AB1D  bl 0x83217ca0
	ctx.lr = 0x830DD188;
	sub_83217CA0(ctx, base);
	// 830DD188: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DD18C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DD190: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DD194: 419A0018  beq cr6, 0x830dd1ac
	if ctx.cr[6].eq {
	pc = 0x830DD1AC; continue 'dispatch;
	}
	// 830DD198: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD19C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DD1A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD1A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DD1A8: 4E800421  bctrl
	ctx.lr = 0x830DD1AC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DD1AC => {
    //   block [0x830DD1AC..0x830DD1B4)
	// 830DD1AC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830DD1B0: 409A0030  bne cr6, 0x830dd1e0
	if !ctx.cr[6].eq {
	pc = 0x830DD1E0; continue 'dispatch;
	}
	pc = 0x830DD1B4; continue 'dispatch;
            }
            0x830DD1B4 => {
    //   block [0x830DD1B4..0x830DD1C8)
	// 830DD1B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830DD1B8: 4813A201  bl 0x832173b8
	ctx.lr = 0x830DD1BC;
	sub_832173B8(ctx, base);
	// 830DD1BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830DD1C0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830DD1C4: 4BBCC28C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DD1C8 => {
    //   block [0x830DD1C8..0x830DD1E0)
	// 830DD1C8: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 830DD1CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830DD1D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830DD1D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DD1D8: 4813AAD9  bl 0x83217cb0
	ctx.lr = 0x830DD1DC;
	sub_83217CB0(ctx, base);
	// 830DD1DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	pc = 0x830DD1E0; continue 'dispatch;
            }
            0x830DD1E0 => {
    //   block [0x830DD1E0..0x830DD1F8)
	// 830DD1E0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830DD1E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830DD1E8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830DD1EC: 4BFFF50D  bl 0x830dc6f8
	ctx.lr = 0x830DD1F0;
	sub_830DC6F8(ctx, base);
	// 830DD1F0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DD1F4: 419AFF04  beq cr6, 0x830dd0f8
	if ctx.cr[6].eq {
	pc = 0x830DD0F8; continue 'dispatch;
	}
	pc = 0x830DD1F8; continue 'dispatch;
            }
            0x830DD1F8 => {
    //   block [0x830DD1F8..0x830DD220)
	// 830DD1F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830DD1FC: 419A0038  beq cr6, 0x830dd234
	if ctx.cr[6].eq {
	pc = 0x830DD234; continue 'dispatch;
	}
	// 830DD200: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830DD204: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DD208: 4813AA41  bl 0x83217c48
	ctx.lr = 0x830DD20C;
	sub_83217C48(ctx, base);
	// 830DD20C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD210: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DD214: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830DD218: 419A0008  beq cr6, 0x830dd220
	if ctx.cr[6].eq {
	pc = 0x830DD220; continue 'dispatch;
	}
	// 830DD21C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830DD220; continue 'dispatch;
            }
            0x830DD220 => {
    //   block [0x830DD220..0x830DD22C)
	// 830DD220: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830DD224: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DD228: 388AA450  addi r4, r10, -0x5bb0
	ctx.r[4].s64 = ctx.r[10].s64 + -23472;
	pc = 0x830DD22C; continue 'dispatch;
            }
            0x830DD22C => {
    //   block [0x830DD22C..0x830DD234)
	// 830DD22C: 387A0014  addi r3, r26, 0x14
	ctx.r[3].s64 = ctx.r[26].s64 + 20;
	// 830DD230: 4BC7BC61  bl 0x82d58e90
	ctx.lr = 0x830DD234;
	sub_82D58E90(ctx, base);
	pc = 0x830DD234; continue 'dispatch;
            }
            0x830DD234 => {
    //   block [0x830DD234..0x830DD248)
	// 830DD234: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830DD238: 4813A181  bl 0x832173b8
	ctx.lr = 0x830DD23C;
	sub_832173B8(ctx, base);
	// 830DD23C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830DD240: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830DD244: 4BBCC20C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DD248 => {
    //   block [0x830DD248..0x830DD274)
	// 830DD248: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DD24C: 80DC000C  lwz r6, 0xc(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DD250: 387A0014  addi r3, r26, 0x14
	ctx.r[3].s64 = ctx.r[26].s64 + 20;
	// 830DD254: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DD258: 388BA428  addi r4, r11, -0x5bd8
	ctx.r[4].s64 = ctx.r[11].s64 + -23512;
	// 830DD25C: 4BC7BC35  bl 0x82d58e90
	ctx.lr = 0x830DD260;
	sub_82D58E90(ctx, base);
	// 830DD260: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830DD264: 4813A155  bl 0x832173b8
	ctx.lr = 0x830DD268;
	sub_832173B8(ctx, base);
	// 830DD268: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830DD26C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830DD270: 4BBCC1E0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DD274 => {
    //   block [0x830DD274..0x830DD284)
	// 830DD274: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DD278: 80BC000C  lwz r5, 0xc(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DD27C: 388BA410  addi r4, r11, -0x5bf0
	ctx.r[4].s64 = ctx.r[11].s64 + -23536;
	// 830DD280: 4BFFFFAC  b 0x830dd22c
	pc = 0x830DD22C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DD288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DD288 size=124
    let mut pc: u32 = 0x830DD288;
    'dispatch: loop {
        match pc {
            0x830DD288 => {
    //   block [0x830DD288..0x830DD2C4)
	// 830DD288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DD28C: 4BBCC181  bl 0x82ca940c
	ctx.lr = 0x830DD290;
	sub_82CA93D0(ctx, base);
	// 830DD290: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DD294: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830DD298: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830DD29C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DD2A0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830DD2A4: 4BFFF455  bl 0x830dc6f8
	ctx.lr = 0x830DD2A8;
	sub_830DC6F8(ctx, base);
	// 830DD2A8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DD2AC: 409A0034  bne cr6, 0x830dd2e0
	if !ctx.cr[6].eq {
	pc = 0x830DD2E0; continue 'dispatch;
	}
	// 830DD2B0: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DD2B4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830DD2B8: 409A000C  bne cr6, 0x830dd2c4
	if !ctx.cr[6].eq {
	pc = 0x830DD2C4; continue 'dispatch;
	}
	// 830DD2BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830DD2C0: 4BBCC19C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DD2C4 => {
    //   block [0x830DD2C4..0x830DD2E0)
	// 830DD2C4: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DD2C8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830DD2CC: 419A0020  beq cr6, 0x830dd2ec
	if ctx.cr[6].eq {
	pc = 0x830DD2EC; continue 'dispatch;
	}
	// 830DD2D0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DD2D4: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 830DD2D8: 388BA46C  addi r4, r11, -0x5b94
	ctx.r[4].s64 = ctx.r[11].s64 + -23444;
	// 830DD2DC: 4BC7BBB5  bl 0x82d58e90
	ctx.lr = 0x830DD2E0;
	sub_82D58E90(ctx, base);
	pc = 0x830DD2E0; continue 'dispatch;
            }
            0x830DD2E0 => {
    //   block [0x830DD2E0..0x830DD2EC)
	// 830DD2E0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830DD2E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830DD2E8: 4BBCC174  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DD2EC => {
    //   block [0x830DD2EC..0x830DD304)
	// 830DD2EC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830DD2F0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830DD2F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DD2F8: 4BFFFD89  bl 0x830dd080
	ctx.lr = 0x830DD2FC;
	sub_830DD080(ctx, base);
	// 830DD2FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830DD300: 4BBCC15C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DD308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DD308 size=92
    let mut pc: u32 = 0x830DD308;
    'dispatch: loop {
        match pc {
            0x830DD308 => {
    //   block [0x830DD308..0x830DD334)
	// 830DD308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DD30C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830DD310: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830DD314: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830DD318: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DD31C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DD320: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 830DD324: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DD328: 4813A929  bl 0x83217c50
	ctx.lr = 0x830DD32C;
	sub_83217C50(ctx, base);
	// 830DD32C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DD330: 419A001C  beq cr6, 0x830dd34c
	if ctx.cr[6].eq {
	pc = 0x830DD34C; continue 'dispatch;
	}
	pc = 0x830DD334; continue 'dispatch;
            }
            0x830DD334 => {
    //   block [0x830DD334..0x830DD34C)
	// 830DD334: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830DD338: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD33C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DD340: 4813AA61  bl 0x83217da0
	ctx.lr = 0x830DD344;
	sub_83217DA0(ctx, base);
	// 830DD344: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DD348: 409AFFEC  bne cr6, 0x830dd334
	if !ctx.cr[6].eq {
	pc = 0x830DD334; continue 'dispatch;
	}
	pc = 0x830DD34C; continue 'dispatch;
            }
            0x830DD34C => {
    //   block [0x830DD34C..0x830DD364)
	// 830DD34C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830DD350: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830DD354: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830DD358: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830DD35C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830DD360: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DD368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DD368 size=208
    let mut pc: u32 = 0x830DD368;
    'dispatch: loop {
        match pc {
            0x830DD368 => {
    //   block [0x830DD368..0x830DD3B0)
	// 830DD368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DD36C: 4BBCC095  bl 0x82ca9400
	ctx.lr = 0x830DD370;
	sub_82CA93D0(ctx, base);
	// 830DD370: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DD374: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DD378: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830DD37C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830DD380: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830DD384: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DD388: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DD38C: 7F6BEA14  add r27, r11, r29
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830DD390: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 830DD394: 7F9E5850  subf r28, r30, r11
	ctx.r[28].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 830DD398: 7F0AD800  cmpw cr6, r10, r27
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[27].s32, &mut ctx.xer);
	// 830DD39C: 40980024  bge cr6, 0x830dd3c0
	if !ctx.cr[6].lt {
	pc = 0x830DD3C0; continue 'dispatch;
	}
	// 830DD3A0: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DD3A4: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DD3A8: 41980008  blt cr6, 0x830dd3b0
	if ctx.cr[6].lt {
	pc = 0x830DD3B0; continue 'dispatch;
	}
	// 830DD3AC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x830DD3B0; continue 'dispatch;
            }
            0x830DD3B0 => {
    //   block [0x830DD3B0..0x830DD3C0)
	// 830DD3B0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DD3B4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830DD3B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DD3BC: 4BC79B55  bl 0x82d56f10
	ctx.lr = 0x830DD3C0;
	sub_82D56F10(ctx, base);
	pc = 0x830DD3C0; continue 'dispatch;
            }
            0x830DD3C0 => {
    //   block [0x830DD3C0..0x830DD3E0)
	// 830DD3C0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD3C4: 397CFFFF  addi r11, r28, -1
	ctx.r[11].s64 = ctx.r[28].s64 + -1;
	// 830DD3C8: 7D2AF214  add r9, r10, r30
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 830DD3CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DD3D0: 7D09EA14  add r8, r9, r29
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 830DD3D4: 41980024  blt cr6, 0x830dd3f8
	if ctx.cr[6].lt {
	pc = 0x830DD3F8; continue 'dispatch;
	}
	// 830DD3D8: 7D4B4214  add r10, r11, r8
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830DD3DC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	pc = 0x830DD3E0; continue 'dispatch;
            }
            0x830DD3E0 => {
    //   block [0x830DD3E0..0x830DD3F8)
	// 830DD3E0: 7D0950AE  lbzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DD3E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830DD3E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DD3EC: 990A0000  stb r8, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 830DD3F0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830DD3F4: 4098FFEC  bge cr6, 0x830dd3e0
	if !ctx.cr[6].lt {
	pc = 0x830DD3E0; continue 'dispatch;
	}
	pc = 0x830DD3F8; continue 'dispatch;
            }
            0x830DD3F8 => {
    //   block [0x830DD3F8..0x830DD414)
	// 830DD3F8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD3FC: 397DFFFF  addi r11, r29, -1
	ctx.r[11].s64 = ctx.r[29].s64 + -1;
	// 830DD400: 7D2AF214  add r9, r10, r30
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 830DD404: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DD408: 41980024  blt cr6, 0x830dd42c
	if ctx.cr[6].lt {
	pc = 0x830DD42C; continue 'dispatch;
	}
	// 830DD40C: 7D4B4A14  add r10, r11, r9
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830DD410: 7D29D050  subf r9, r9, r26
	ctx.r[9].s64 = ctx.r[26].s64 - ctx.r[9].s64;
	pc = 0x830DD414; continue 'dispatch;
            }
            0x830DD414 => {
    //   block [0x830DD414..0x830DD42C)
	// 830DD414: 7D0950AE  lbzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DD418: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830DD41C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DD420: 990A0000  stb r8, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 830DD424: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830DD428: 4098FFEC  bge cr6, 0x830dd414
	if !ctx.cr[6].lt {
	pc = 0x830DD414; continue 'dispatch;
	}
	pc = 0x830DD42C; continue 'dispatch;
            }
            0x830DD42C => {
    //   block [0x830DD42C..0x830DD438)
	// 830DD42C: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830DD430: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830DD434: 4BBCC01C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DD438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DD438 size=136
    let mut pc: u32 = 0x830DD438;
    'dispatch: loop {
        match pc {
            0x830DD438 => {
    //   block [0x830DD438..0x830DD4A0)
	// 830DD438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DD43C: 4BBCBFCD  bl 0x82ca9408
	ctx.lr = 0x830DD440;
	sub_82CA93D0(ctx, base);
	// 830DD440: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DD444: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DD448: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DD44C: 396BA394  addi r11, r11, -0x5c6c
	ctx.r[11].s64 = ctx.r[11].s64 + -23660;
	// 830DD450: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830DD454: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 830DD458: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	// 830DD45C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830DD460: 3CE08000  lis r7, -0x8000
	ctx.r[7].s64 = -2147483648;
	// 830DD464: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830DD468: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830DD46C: B13E0006  sth r9, 6(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(6 as u32), ctx.r[9].u16 ) };
	// 830DD470: 911E0008  stw r8, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 830DD474: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830DD478: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830DD47C: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 830DD480: 83BC0004  lwz r29, 4(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DD484: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830DD488: 40990018  ble cr6, 0x830dd4a0
	if !ctx.cr[6].gt {
	pc = 0x830DD4A0; continue 'dispatch;
	}
	// 830DD48C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 830DD490: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DD494: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 830DD498: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DD49C: 4BC79A75  bl 0x82d56f10
	ctx.lr = 0x830DD4A0;
	sub_82D56F10(ctx, base);
	pc = 0x830DD4A0; continue 'dispatch;
            }
            0x830DD4A0 => {
    //   block [0x830DD4A0..0x830DD4C0)
	// 830DD4A0: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830DD4A4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD4A8: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DD4AC: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD4B0: 4BC7B881  bl 0x82d58d30
	ctx.lr = 0x830DD4B4;
	sub_82D58D30(ctx, base);
	// 830DD4B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DD4B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830DD4BC: 4BBCBF9C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DD4C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DD4C0 size=152
    let mut pc: u32 = 0x830DD4C0;
    'dispatch: loop {
        match pc {
            0x830DD4C0 => {
    //   block [0x830DD4C0..0x830DD524)
	// 830DD4C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DD4C4: 4BBCBF3D  bl 0x82ca9400
	ctx.lr = 0x830DD4C8;
	sub_82CA93D0(ctx, base);
	// 830DD4C8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DD4CC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DD4D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DD4D4: 396BA3A4  addi r11, r11, -0x5c5c
	ctx.r[11].s64 = ctx.r[11].s64 + -23644;
	// 830DD4D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830DD4DC: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 830DD4E0: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	// 830DD4E4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830DD4E8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830DD4EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830DD4F0: 3D008000  lis r8, -0x8000
	ctx.r[8].s64 = -2147483648;
	// 830DD4F4: B15E0006  sth r10, 6(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 830DD4F8: 3B9D0001  addi r28, r29, 1
	ctx.r[28].s64 = ctx.r[29].s64 + 1;
	// 830DD4FC: 913E0008  stw r9, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830DD500: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830DD504: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 830DD508: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830DD50C: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830DD510: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 830DD514: 4099001C  ble cr6, 0x830dd530
	if !ctx.cr[6].gt {
	pc = 0x830DD530; continue 'dispatch;
	}
	// 830DD518: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830DD51C: 41980008  blt cr6, 0x830dd524
	if ctx.cr[6].lt {
	pc = 0x830DD524; continue 'dispatch;
	}
	// 830DD520: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x830DD524; continue 'dispatch;
            }
            0x830DD524 => {
    //   block [0x830DD524..0x830DD530)
	// 830DD524: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DD528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DD52C: 4BC799E5  bl 0x82d56f10
	ctx.lr = 0x830DD530;
	sub_82D56F10(ctx, base);
	pc = 0x830DD530; continue 'dispatch;
            }
            0x830DD530 => {
    //   block [0x830DD530..0x830DD558)
	// 830DD530: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830DD534: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD538: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830DD53C: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830DD540: 4BC7B7F1  bl 0x82d58d30
	ctx.lr = 0x830DD544;
	sub_82D58D30(ctx, base);
	// 830DD544: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD548: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DD54C: 7F6BE9AE  stbx r27, r11, r29
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), ctx.r[27].u8) };
	// 830DD550: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830DD554: 4BBCBEFC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DD558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DD558 size=128
    let mut pc: u32 = 0x830DD558;
    'dispatch: loop {
        match pc {
            0x830DD558 => {
    //   block [0x830DD558..0x830DD598)
	// 830DD558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DD55C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830DD560: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830DD564: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DD568: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DD56C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830DD570: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DD574: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DD578: 409A0020  bne cr6, 0x830dd598
	if !ctx.cr[6].eq {
	pc = 0x830DD598; continue 'dispatch;
	}
	// 830DD57C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD580: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DD584: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DD588: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DD58C: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DD590: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DD594: 4BC77D35  bl 0x82d552c8
	ctx.lr = 0x830DD598;
	sub_82D552C8(ctx, base);
	pc = 0x830DD598; continue 'dispatch;
            }
            0x830DD598 => {
    //   block [0x830DD598..0x830DD5C4)
	// 830DD598: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DD59C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DD5A0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DD5A4: 409A0020  bne cr6, 0x830dd5c4
	if !ctx.cr[6].eq {
	pc = 0x830DD5C4; continue 'dispatch;
	}
	// 830DD5A8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD5AC: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DD5B0: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DD5B4: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD5B8: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DD5BC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DD5C0: 4BC77D09  bl 0x82d552c8
	ctx.lr = 0x830DD5C4;
	sub_82D552C8(ctx, base);
	pc = 0x830DD5C4; continue 'dispatch;
            }
            0x830DD5C4 => {
    //   block [0x830DD5C4..0x830DD5D8)
	// 830DD5C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830DD5C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830DD5CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830DD5D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830DD5D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DD5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DD5D8 size=184
    let mut pc: u32 = 0x830DD5D8;
    'dispatch: loop {
        match pc {
            0x830DD5D8 => {
    //   block [0x830DD5D8..0x830DD618)
	// 830DD5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DD5DC: 4BBCBE25  bl 0x82ca9400
	ctx.lr = 0x830DD5E0;
	sub_82CA93D0(ctx, base);
	// 830DD5E0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DD5E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DD5E8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830DD5EC: 3F408000  lis r26, -0x8000
	ctx.r[26].s64 = -2147483648;
	// 830DD5F0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830DD5F4: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830DD5F8: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830DD5FC: 935F0008  stw r26, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 830DD600: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DD604: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830DD608: 4099001C  ble cr6, 0x830dd624
	if !ctx.cr[6].gt {
	pc = 0x830DD624; continue 'dispatch;
	}
	// 830DD60C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DD610: 41980008  blt cr6, 0x830dd618
	if ctx.cr[6].lt {
	pc = 0x830DD618; continue 'dispatch;
	}
	// 830DD614: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	pc = 0x830DD618; continue 'dispatch;
            }
            0x830DD618 => {
    //   block [0x830DD618..0x830DD624)
	// 830DD618: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DD61C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DD620: 4BC798F1  bl 0x82d56f10
	ctx.lr = 0x830DD624;
	sub_82D56F10(ctx, base);
	pc = 0x830DD624; continue 'dispatch;
            }
            0x830DD624 => {
    //   block [0x830DD624..0x830DD664)
	// 830DD624: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830DD628: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD62C: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DD630: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD634: 4BC7B6FD  bl 0x82d58d30
	ctx.lr = 0x830DD638;
	sub_82D58D30(ctx, base);
	// 830DD638: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 830DD63C: 3B7D000C  addi r27, r29, 0xc
	ctx.r[27].s64 = ctx.r[29].s64 + 12;
	// 830DD640: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830DD644: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830DD648: 935E0008  stw r26, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 830DD64C: 83BB0004  lwz r29, 4(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DD650: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830DD654: 4099001C  ble cr6, 0x830dd670
	if !ctx.cr[6].gt {
	pc = 0x830DD670; continue 'dispatch;
	}
	// 830DD658: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DD65C: 41980008  blt cr6, 0x830dd664
	if ctx.cr[6].lt {
	pc = 0x830DD664; continue 'dispatch;
	}
	// 830DD660: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x830DD664; continue 'dispatch;
            }
            0x830DD664 => {
    //   block [0x830DD664..0x830DD670)
	// 830DD664: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DD668: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DD66C: 4BC798A5  bl 0x82d56f10
	ctx.lr = 0x830DD670;
	sub_82D56F10(ctx, base);
	pc = 0x830DD670; continue 'dispatch;
            }
            0x830DD670 => {
    //   block [0x830DD670..0x830DD690)
	// 830DD670: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830DD674: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD678: 80BB0004  lwz r5, 4(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DD67C: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD680: 4BC7B6B1  bl 0x82d58d30
	ctx.lr = 0x830DD684;
	sub_82D58D30(ctx, base);
	// 830DD684: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DD688: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830DD68C: 4BBCBDC4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DD690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DD690 size=152
    let mut pc: u32 = 0x830DD690;
    'dispatch: loop {
        match pc {
            0x830DD690 => {
    //   block [0x830DD690..0x830DD6D8)
	// 830DD690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DD694: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830DD698: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830DD69C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830DD6A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DD6A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DD6A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830DD6AC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830DD6B0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DD6B4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DD6B8: 409A0020  bne cr6, 0x830dd6d8
	if !ctx.cr[6].eq {
	pc = 0x830DD6D8; continue 'dispatch;
	}
	// 830DD6BC: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD6C0: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DD6C4: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DD6C8: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DD6CC: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DD6D0: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DD6D4: 4BC77BF5  bl 0x82d552c8
	ctx.lr = 0x830DD6D8;
	sub_82D552C8(ctx, base);
	pc = 0x830DD6D8; continue 'dispatch;
            }
            0x830DD6D8 => {
    //   block [0x830DD6D8..0x830DD70C)
	// 830DD6D8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830DD6DC: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 830DD6E0: 396B39E0  addi r11, r11, 0x39e0
	ctx.r[11].s64 = ctx.r[11].s64 + 14816;
	// 830DD6E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830DD6E8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830DD6EC: 419A0020  beq cr6, 0x830dd70c
	if ctx.cr[6].eq {
	pc = 0x830DD70C; continue 'dispatch;
	}
	// 830DD6F0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD6F4: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830DD6F8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830DD6FC: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DD700: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DD704: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830DD708: 4BC77BC1  bl 0x82d552c8
	ctx.lr = 0x830DD70C;
	sub_82D552C8(ctx, base);
	pc = 0x830DD70C; continue 'dispatch;
            }
            0x830DD70C => {
    //   block [0x830DD70C..0x830DD728)
	// 830DD70C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DD710: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830DD714: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830DD718: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830DD71C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830DD720: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830DD724: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DD728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DD728 size=100
    let mut pc: u32 = 0x830DD728;
    'dispatch: loop {
        match pc {
            0x830DD728 => {
    //   block [0x830DD728..0x830DD770)
	// 830DD728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DD72C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830DD730: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830DD734: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830DD738: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DD73C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DD740: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830DD744: 4BFFE935  bl 0x830dc078
	ctx.lr = 0x830DD748;
	sub_830DC078(ctx, base);
	// 830DD748: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 830DD74C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DD750: 419A0020  beq cr6, 0x830dd770
	if ctx.cr[6].eq {
	pc = 0x830DD770; continue 'dispatch;
	}
	// 830DD754: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD758: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830DD75C: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 830DD760: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DD764: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DD768: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830DD76C: 4BC77B5D  bl 0x82d552c8
	ctx.lr = 0x830DD770;
	sub_82D552C8(ctx, base);
	pc = 0x830DD770; continue 'dispatch;
            }
            0x830DD770 => {
    //   block [0x830DD770..0x830DD78C)
	// 830DD770: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DD774: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830DD778: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830DD77C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830DD780: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830DD784: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830DD788: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DD790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DD790 size=148
    let mut pc: u32 = 0x830DD790;
    'dispatch: loop {
        match pc {
            0x830DD790 => {
    //   block [0x830DD790..0x830DD7EC)
	// 830DD790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DD794: 4BBCBC6D  bl 0x82ca9400
	ctx.lr = 0x830DD798;
	sub_82CA93D0(ctx, base);
	// 830DD798: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DD79C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DD7A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DD7A4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830DD7A8: 396BA3C4  addi r11, r11, -0x5c3c
	ctx.r[11].s64 = ctx.r[11].s64 + -23612;
	// 830DD7AC: 3BDF000C  addi r30, r31, 0xc
	ctx.r[30].s64 = ctx.r[31].s64 + 12;
	// 830DD7B0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830DD7B4: 3F408000  lis r26, -0x8000
	ctx.r[26].s64 = -2147483648;
	// 830DD7B8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830DD7BC: B15F0006  sth r10, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 830DD7C0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830DD7C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830DD7C8: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830DD7CC: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830DD7D0: 935E0008  stw r26, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 830DD7D4: 837C0004  lwz r27, 4(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DD7D8: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830DD7DC: 4099001C  ble cr6, 0x830dd7f8
	if !ctx.cr[6].gt {
	pc = 0x830DD7F8; continue 'dispatch;
	}
	// 830DD7E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DD7E4: 41980008  blt cr6, 0x830dd7ec
	if ctx.cr[6].lt {
	pc = 0x830DD7EC; continue 'dispatch;
	}
	// 830DD7E8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	pc = 0x830DD7EC; continue 'dispatch;
            }
            0x830DD7EC => {
    //   block [0x830DD7EC..0x830DD7F8)
	// 830DD7EC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DD7F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DD7F4: 4BC7971D  bl 0x82d56f10
	ctx.lr = 0x830DD7F8;
	sub_82D56F10(ctx, base);
	pc = 0x830DD7F8; continue 'dispatch;
            }
            0x830DD7F8 => {
    //   block [0x830DD7F8..0x830DD824)
	// 830DD7F8: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 830DD7FC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD800: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DD804: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD808: 4BC7B529  bl 0x82d58d30
	ctx.lr = 0x830DD80C;
	sub_82D58D30(ctx, base);
	// 830DD80C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DD810: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 830DD814: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 830DD818: 935F0020  stw r26, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	// 830DD81C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830DD820: 4BBCBC30  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DD828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DD828 size=268
    let mut pc: u32 = 0x830DD828;
    'dispatch: loop {
        match pc {
            0x830DD828 => {
    //   block [0x830DD828..0x830DD84C)
	// 830DD828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DD82C: 4BBCBBDD  bl 0x82ca9408
	ctx.lr = 0x830DD830;
	sub_82CA93D0(ctx, base);
	// 830DD830: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DD834: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830DD838: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 830DD83C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DD840: 4099007C  ble cr6, 0x830dd8bc
	if !ctx.cr[6].gt {
	pc = 0x830DD8BC; continue 'dispatch;
	}
	// 830DD844: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830DD848: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	pc = 0x830DD84C; continue 'dispatch;
            }
            0x830DD84C => {
    //   block [0x830DD84C..0x830DD880)
	// 830DD84C: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 830DD850: 7FFE5A14  add r31, r30, r11
	ctx.r[31].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830DD854: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830DD858: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DD85C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DD860: 409A0020  bne cr6, 0x830dd880
	if !ctx.cr[6].eq {
	pc = 0x830DD880; continue 'dispatch;
	}
	// 830DD864: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD868: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DD86C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DD870: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DD874: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DD878: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DD87C: 4BC77A4D  bl 0x82d552c8
	ctx.lr = 0x830DD880;
	sub_82D552C8(ctx, base);
	pc = 0x830DD880; continue 'dispatch;
            }
            0x830DD880 => {
    //   block [0x830DD880..0x830DD8AC)
	// 830DD880: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DD884: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DD888: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DD88C: 409A0020  bne cr6, 0x830dd8ac
	if !ctx.cr[6].eq {
	pc = 0x830DD8AC; continue 'dispatch;
	}
	// 830DD890: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD894: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DD898: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DD89C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD8A0: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DD8A4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DD8A8: 4BC77A21  bl 0x82d552c8
	ctx.lr = 0x830DD8AC;
	sub_82D552C8(ctx, base);
	pc = 0x830DD8AC; continue 'dispatch;
            }
            0x830DD8AC => {
    //   block [0x830DD8AC..0x830DD8BC)
	// 830DD8AC: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 830DD8B0: 3BDE0018  addi r30, r30, 0x18
	ctx.r[30].s64 = ctx.r[30].s64 + 24;
	// 830DD8B4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830DD8B8: 409AFF94  bne cr6, 0x830dd84c
	if !ctx.cr[6].eq {
	pc = 0x830DD84C; continue 'dispatch;
	}
	pc = 0x830DD8BC; continue 'dispatch;
            }
            0x830DD8BC => {
    //   block [0x830DD8BC..0x830DD8F4)
	// 830DD8BC: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 830DD8C0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DD8C4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DD8C8: 409A002C  bne cr6, 0x830dd8f4
	if !ctx.cr[6].eq {
	pc = 0x830DD8F4; continue 'dispatch;
	}
	// 830DD8CC: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD8D0: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DD8D4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DD8D8: 809D0018  lwz r4, 0x18(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 830DD8DC: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DD8E0: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DD8E4: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830DD8E8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830DD8EC: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830DD8F0: 4BC779D9  bl 0x82d552c8
	ctx.lr = 0x830DD8F4;
	sub_82D552C8(ctx, base);
	pc = 0x830DD8F4; continue 'dispatch;
            }
            0x830DD8F4 => {
    //   block [0x830DD8F4..0x830DD920)
	// 830DD8F4: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 830DD8F8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DD8FC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DD900: 409A0020  bne cr6, 0x830dd920
	if !ctx.cr[6].eq {
	pc = 0x830DD920; continue 'dispatch;
	}
	// 830DD904: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD908: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DD90C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DD910: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DD914: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DD918: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DD91C: 4BC779AD  bl 0x82d552c8
	ctx.lr = 0x830DD920;
	sub_82D552C8(ctx, base);
	pc = 0x830DD920; continue 'dispatch;
            }
            0x830DD920 => {
    //   block [0x830DD920..0x830DD934)
	// 830DD920: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830DD924: 396B39E0  addi r11, r11, 0x39e0
	ctx.r[11].s64 = ctx.r[11].s64 + 14816;
	// 830DD928: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830DD92C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830DD930: 4BBCBB28  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DD938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DD938 size=100
    let mut pc: u32 = 0x830DD938;
    'dispatch: loop {
        match pc {
            0x830DD938 => {
    //   block [0x830DD938..0x830DD980)
	// 830DD938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DD93C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830DD940: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830DD944: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830DD948: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DD94C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DD950: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830DD954: 4BFFFED5  bl 0x830dd828
	ctx.lr = 0x830DD958;
	sub_830DD828(ctx, base);
	// 830DD958: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 830DD95C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DD960: 419A0020  beq cr6, 0x830dd980
	if ctx.cr[6].eq {
	pc = 0x830DD980; continue 'dispatch;
	}
	// 830DD964: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD968: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830DD96C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830DD970: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DD974: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DD978: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830DD97C: 4BC7794D  bl 0x82d552c8
	ctx.lr = 0x830DD980;
	sub_82D552C8(ctx, base);
	pc = 0x830DD980; continue 'dispatch;
            }
            0x830DD980 => {
    //   block [0x830DD980..0x830DD99C)
	// 830DD980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DD984: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830DD988: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830DD98C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830DD990: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830DD994: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830DD998: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DD9A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DD9A8 size=124
    let mut pc: u32 = 0x830DD9A8;
    'dispatch: loop {
        match pc {
            0x830DD9A8 => {
    //   block [0x830DD9A8..0x830DDA04)
	// 830DD9A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DD9AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830DD9B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830DD9B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DD9B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DD9BC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DD9C0: 396BA49C  addi r11, r11, -0x5b64
	ctx.r[11].s64 = ctx.r[11].s64 + -23396;
	// 830DD9C4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DD9C8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830DD9CC: A1630004  lhz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DD9D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DD9D4: 419A0030  beq cr6, 0x830dda04
	if ctx.cr[6].eq {
	pc = 0x830DDA04; continue 'dispatch;
	}
	// 830DD9D8: A1630006  lhz r11, 6(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(6 as u32) ) } as u64;
	// 830DD9DC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830DD9E0: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 830DD9E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DD9E8: B1630006  sth r11, 6(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 830DD9EC: 409A0018  bne cr6, 0x830dda04
	if !ctx.cr[6].eq {
	pc = 0x830DDA04; continue 'dispatch;
	}
	// 830DD9F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD9F4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DD9F8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DD9FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DDA00: 4E800421  bctrl
	ctx.lr = 0x830DDA04;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DDA04 => {
    //   block [0x830DDA04..0x830DDA24)
	// 830DDA04: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830DDA08: 396B39E0  addi r11, r11, 0x39e0
	ctx.r[11].s64 = ctx.r[11].s64 + 14816;
	// 830DDA0C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830DDA10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830DDA14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830DDA18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830DDA1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830DDA20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DDA58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DDA58 size=44
    let mut pc: u32 = 0x830DDA58;
    'dispatch: loop {
        match pc {
            0x830DDA58 => {
    //   block [0x830DDA58..0x830DDA74)
	// 830DDA58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DDA5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830DDA60: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DDA64: 4BC7F30D  bl 0x82d5cd70
	ctx.lr = 0x830DDA68;
	sub_82D5CD70(ctx, base);
	// 830DDA68: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DDA6C: 409A0008  bne cr6, 0x830dda74
	if !ctx.cr[6].eq {
	pc = 0x830DDA74; continue 'dispatch;
	}
	// 830DDA70: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x830DDA74; continue 'dispatch;
            }
            0x830DDA74 => {
    //   block [0x830DDA74..0x830DDA84)
	// 830DDA74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830DDA78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830DDA7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830DDA80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DDAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DDAB0 size=208
    let mut pc: u32 = 0x830DDAB0;
    'dispatch: loop {
        match pc {
            0x830DDAB0 => {
    //   block [0x830DDAB0..0x830DDAEC)
	// 830DDAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DDAB4: 4BBCB951  bl 0x82ca9404
	ctx.lr = 0x830DDAB8;
	sub_82CA93D0(ctx, base);
	// 830DDAB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DDABC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830DDAC0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830DDAC4: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 830DDAC8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830DDACC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830DDAD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DDAD4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 830DDAD8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 830DDADC: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 830DDAE0: 4BFFEC19  bl 0x830dc6f8
	ctx.lr = 0x830DDAE4;
	sub_830DC6F8(ctx, base);
	// 830DDAE4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DDAE8: 409A0054  bne cr6, 0x830ddb3c
	if !ctx.cr[6].eq {
	pc = 0x830DDB3C; continue 'dispatch;
	}
	pc = 0x830DDAEC; continue 'dispatch;
            }
            0x830DDAEC => {
    //   block [0x830DDAEC..0x830DDB24)
	// 830DDAEC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DDAF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DDAF4: 419A0048  beq cr6, 0x830ddb3c
	if ctx.cr[6].eq {
	pc = 0x830DDB3C; continue 'dispatch;
	}
	// 830DDAF8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DDAFC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830DDB00: 419A0044  beq cr6, 0x830ddb44
	if ctx.cr[6].eq {
	pc = 0x830DDB44; continue 'dispatch;
	}
	// 830DDB04: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830DDB08: 419A001C  beq cr6, 0x830ddb24
	if ctx.cr[6].eq {
	pc = 0x830DDB24; continue 'dispatch;
	}
	// 830DDB0C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830DDB10: 409A0038  bne cr6, 0x830ddb48
	if !ctx.cr[6].eq {
	pc = 0x830DDB48; continue 'dispatch;
	}
	// 830DDB14: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830DDB18: 409A0030  bne cr6, 0x830ddb48
	if !ctx.cr[6].eq {
	pc = 0x830DDB48; continue 'dispatch;
	}
	// 830DDB1C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 830DDB20: 48000028  b 0x830ddb48
	pc = 0x830DDB48; continue 'dispatch;
            }
            0x830DDB24 => {
    //   block [0x830DDB24..0x830DDB3C)
	// 830DDB24: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 830DDB28: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830DDB2C: 409A001C  bne cr6, 0x830ddb48
	if !ctx.cr[6].eq {
	pc = 0x830DDB48; continue 'dispatch;
	}
	// 830DDB30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830DDB34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DDB38: 4BFFE289  bl 0x830dbdc0
	ctx.lr = 0x830DDB3C;
	sub_830DBDC0(ctx, base);
	pc = 0x830DDB3C; continue 'dispatch;
            }
            0x830DDB3C => {
    //   block [0x830DDB3C..0x830DDB44)
	// 830DDB3C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830DDB40: 4BBCB914  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DDB44 => {
    //   block [0x830DDB44..0x830DDB48)
	// 830DDB44: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	pc = 0x830DDB48; continue 'dispatch;
            }
            0x830DDB48 => {
    //   block [0x830DDB48..0x830DDB80)
	// 830DDB48: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DDB4C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DDB50: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DDB54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DDB58: 4E800421  bctrl
	ctx.lr = 0x830DDB5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DDB5C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830DDB60: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830DDB64: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 830DDB68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DDB6C: 4BFFEB8D  bl 0x830dc6f8
	ctx.lr = 0x830DDB70;
	sub_830DC6F8(ctx, base);
	// 830DDB70: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DDB74: 419AFF78  beq cr6, 0x830ddaec
	if ctx.cr[6].eq {
	pc = 0x830DDAEC; continue 'dispatch;
	}
	// 830DDB78: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830DDB7C: 4BBCB8D8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DDB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DDB80 size=152
    let mut pc: u32 = 0x830DDB80;
    'dispatch: loop {
        match pc {
            0x830DDB80 => {
    //   block [0x830DDB80..0x830DDB9C)
	// 830DDB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DDB84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830DDB88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830DDB8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830DDB90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DDB94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DDB98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	pc = 0x830DDB9C; continue 'dispatch;
            }
            0x830DDB9C => {
    //   block [0x830DDB9C..0x830DDBC8)
	// 830DDB9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DDBA0: 4BC831A9  bl 0x82d60d48
	ctx.lr = 0x830DDBA4;
	sub_82D60D48(ctx, base);
	// 830DDBA4: 2F030020  cmpwi cr6, r3, 0x20
	ctx.cr[6].compare_i32(ctx.r[3].s32, 32, &mut ctx.xer);
	// 830DDBA8: 419A0020  beq cr6, 0x830ddbc8
	if ctx.cr[6].eq {
	pc = 0x830DDBC8; continue 'dispatch;
	}
	// 830DDBAC: 2F030009  cmpwi cr6, r3, 9
	ctx.cr[6].compare_i32(ctx.r[3].s32, 9, &mut ctx.xer);
	// 830DDBB0: 419A0018  beq cr6, 0x830ddbc8
	if ctx.cr[6].eq {
	pc = 0x830DDBC8; continue 'dispatch;
	}
	// 830DDBB4: 2F03000A  cmpwi cr6, r3, 0xa
	ctx.cr[6].compare_i32(ctx.r[3].s32, 10, &mut ctx.xer);
	// 830DDBB8: 419A0010  beq cr6, 0x830ddbc8
	if ctx.cr[6].eq {
	pc = 0x830DDBC8; continue 'dispatch;
	}
	// 830DDBBC: 2F03000D  cmpwi cr6, r3, 0xd
	ctx.cr[6].compare_i32(ctx.r[3].s32, 13, &mut ctx.xer);
	// 830DDBC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830DDBC4: 409A0008  bne cr6, 0x830ddbcc
	if !ctx.cr[6].eq {
	pc = 0x830DDBCC; continue 'dispatch;
	}
	pc = 0x830DDBC8; continue 'dispatch;
            }
            0x830DDBC8 => {
    //   block [0x830DDBC8..0x830DDBCC)
	// 830DDBC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830DDBCC; continue 'dispatch;
            }
            0x830DDBCC => {
    //   block [0x830DDBCC..0x830DDBE8)
	// 830DDBCC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DDBD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DDBD4: 409AFFC8  bne cr6, 0x830ddb9c
	if !ctx.cr[6].eq {
	pc = 0x830DDB9C; continue 'dispatch;
	}
	// 830DDBD8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830DDBDC: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DDBE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DDBE4: 419A001C  beq cr6, 0x830ddc00
	if ctx.cr[6].eq {
	pc = 0x830DDC00; continue 'dispatch;
	}
	pc = 0x830DDBE8; continue 'dispatch;
            }
            0x830DDBE8 => {
    //   block [0x830DDBE8..0x830DDC00)
	// 830DDBE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DDBEC: 4BC8315D  bl 0x82d60d48
	ctx.lr = 0x830DDBF0;
	sub_82D60D48(ctx, base);
	// 830DDBF0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830DDBF4: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DDBF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DDBFC: 409AFFEC  bne cr6, 0x830ddbe8
	if !ctx.cr[6].eq {
	pc = 0x830DDBE8; continue 'dispatch;
	}
	pc = 0x830DDC00; continue 'dispatch;
            }
            0x830DDC00 => {
    //   block [0x830DDC00..0x830DDC18)
	// 830DDC00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830DDC04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830DDC08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830DDC0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830DDC10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830DDC14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DDC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DDC18 size=636
    let mut pc: u32 = 0x830DDC18;
    'dispatch: loop {
        match pc {
            0x830DDC18 => {
    //   block [0x830DDC18..0x830DDCB8)
	// 830DDC18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DDC1C: 4BBCB7E5  bl 0x82ca9400
	ctx.lr = 0x830DDC20;
	sub_82CA93D0(ctx, base);
	// 830DDC20: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DDC24: 3D605555  lis r11, 0x5555
	ctx.r[11].s64 = 1431633920;
	// 830DDC28: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830DDC2C: 61685556  ori r8, r11, 0x5556
	ctx.r[8].u64 = ctx.r[11].u64 | 21846;
	// 830DDC30: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 830DDC34: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 830DDC38: 7D455BD6  divw r10, r5, r11
	ctx.r[10].s32 = ctx.r[5].s32 / ctx.r[11].s32;
	// 830DDC3C: 9BE10054  stb r31, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u8 ) };
	// 830DDC40: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 830DDC44: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 830DDC48: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830DDC4C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830DDC50: 39610055  addi r11, r1, 0x55
	ctx.r[11].s64 = ctx.r[1].s64 + 85;
	// 830DDC54: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 830DDC58: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830DDC5C: 9121007C  stw r9, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	// 830DDC60: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830DDC64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830DDC68: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 830DDC6C: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 830DDC70: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 830DDC74: 9BEB0000  stb r31, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	// 830DDC78: 9BEB0001  stb r31, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[31].u8 ) };
	// 830DDC7C: 9BEB0002  stb r31, 2(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[31].u8 ) };
	// 830DDC80: 7D654096  mulhw r11, r5, r8
	ctx.r[11].s64 = ((ctx.r[5].s32 as i64 * ctx.r[8].s32 as i64) >> 32);
	// 830DDC84: 90C10078  stw r6, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[6].u32 ) };
	// 830DDC88: 55690FFE  srwi r9, r11, 0x1f
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830DDC8C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830DDC90: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830DDC94: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830DDC98: 7D6B2850  subf r11, r11, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 830DDC9C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DDCA0: 7D6B382E  lwzx r11, r11, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 830DDCA4: 7F8B5214  add r28, r11, r10
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830DDCA8: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830DDCAC: 409900C4  ble cr6, 0x830ddd70
	if !ctx.cr[6].gt {
	pc = 0x830DDD70; continue 'dispatch;
	}
	// 830DDCB0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DDCB4: 3B4BA4B0  addi r26, r11, -0x5b50
	ctx.r[26].s64 = ctx.r[11].s64 + -23376;
	pc = 0x830DDCB8; continue 'dispatch;
            }
            0x830DDCB8 => {
    //   block [0x830DDCB8..0x830DDD68)
	// 830DDCB8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DDCBC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DDCC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830DDCC4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830DDCC8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DDCCC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DDCD0: 4E800421  bctrl
	ctx.lr = 0x830DDCD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DDCD4: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 830DDCD8: 409A0128  bne cr6, 0x830dde00
	if !ctx.cr[6].eq {
	pc = 0x830DDE00; continue 'dispatch;
	}
	// 830DDCDC: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DDCE0: 556A067E  clrlwi r10, r11, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000007Fu64;
	// 830DDCE4: 7D4AD0AE  lbzx r10, r10, r26
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 830DDCE8: 2B0A00FF  cmplwi cr6, r10, 0xff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 255 as u32, &mut ctx.xer);
	// 830DDCEC: 419A007C  beq cr6, 0x830ddd68
	if ctx.cr[6].eq {
	pc = 0x830DDD68; continue 'dispatch;
	}
	// 830DDCF0: 7D6BD0AE  lbzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 830DDCF4: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 830DDCF8: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 830DDCFC: 7D7D51AE  stbx r11, r29, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u8) };
	// 830DDD00: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830DDD04: 2F1D0004  cmpwi cr6, r29, 4
	ctx.cr[6].compare_i32(ctx.r[29].s32, 4, &mut ctx.xer);
	// 830DDD08: 409A0060  bne cr6, 0x830ddd68
	if !ctx.cr[6].eq {
	pc = 0x830DDD68; continue 'dispatch;
	}
	// 830DDD0C: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830DDD10: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 830DDD14: 89410056  lbz r10, 0x56(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 830DDD18: 5569103E  rotlwi r9, r11, 2
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 830DDD1C: 89610055  lbz r11, 0x55(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(85 as u32) ) } as u64;
	// 830DDD20: 5547303E  rotlwi r7, r10, 6
	ctx.r[7].u64 = ((ctx.r[10].u32).rotate_left(6)) as u64;
	// 830DDD24: 88C10057  lbz r6, 0x57(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 830DDD28: 5568203E  rotlwi r8, r11, 4
	ctx.r[8].u64 = ((ctx.r[11].u32).rotate_left(4)) as u64;
	// 830DDD2C: 9BE10057  stb r31, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[31].u8 ) };
	// 830DDD30: 556BE13E  srwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DDD34: 9BE10056  stb r31, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[31].u8 ) };
	// 830DDD38: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830DDD3C: 9BE10055  stb r31, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[31].u8 ) };
	// 830DDD40: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 830DDD44: 9BE10054  stb r31, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u8 ) };
	// 830DDD48: 5508063E  clrlwi r8, r8, 0x18
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 830DDD4C: 7CE73378  or r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 830DDD50: 7D2B5B78  or r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 | ctx.r[11].u64;
	// 830DDD54: 7D0A5378  or r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 | ctx.r[10].u64;
	// 830DDD58: 98FE0002  stb r7, 2(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(2 as u32), ctx.r[7].u8 ) };
	// 830DDD5C: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830DDD60: 995E0001  stb r10, 1(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(1 as u32), ctx.r[10].u8 ) };
	// 830DDD64: 3BDE0003  addi r30, r30, 3
	ctx.r[30].s64 = ctx.r[30].s64 + 3;
            }
            0x830DDD68 => {
    //   block [0x830DDD68..0x830DDD70)
	// 830DDD68: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830DDD6C: 4199FF4C  bgt cr6, 0x830ddcb8
	if ctx.cr[6].gt {
	pc = 0x830DDCB8; continue 'dispatch;
	}
	pc = 0x830DDD70; continue 'dispatch;
            }
            0x830DDD70 => {
    //   block [0x830DDD70..0x830DDD94)
	// 830DDD70: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DDD74: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830DDD78: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 830DDD7C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DDD80: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DDD84: 4E800421  bctrl
	ctx.lr = 0x830DDD88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DDD88: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DDD8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DDD90: 419A008C  beq cr6, 0x830dde1c
	if ctx.cr[6].eq {
	pc = 0x830DDE1C; continue 'dispatch;
	}
            }
            0x830DDD94 => {
    //   block [0x830DDD94..0x830DDE00)
	// 830DDD94: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DDD98: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DDD9C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830DDDA0: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830DDDA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DDDA8: 4E800421  bctrl
	ctx.lr = 0x830DDDAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DDDAC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DDDB0: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 830DDDB4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DDDB8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830DDDBC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830DDDC0: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DDDC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DDDC8: 4E800421  bctrl
	ctx.lr = 0x830DDDCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DDDCC: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DDDD0: 2B0B003D  cmplwi cr6, r11, 0x3d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 61 as u32, &mut ctx.xer);
	// 830DDDD4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DDDD8: 409A0034  bne cr6, 0x830dde0c
	if !ctx.cr[6].eq {
	pc = 0x830DDE0C; continue 'dispatch;
	}
	// 830DDDDC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DDDE0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830DDDE4: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 830DDDE8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DDDEC: 4E800421  bctrl
	ctx.lr = 0x830DDDF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DDDF0: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DDDF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DDDF8: 409AFF9C  bne cr6, 0x830ddd94
	if !ctx.cr[6].eq {
	pc = 0x830DDD94; continue 'dispatch;
	}
	// 830DDDFC: 48000020  b 0x830dde1c
	pc = 0x830DDE1C; continue 'dispatch;
            }
            0x830DDE00 => {
    //   block [0x830DDE00..0x830DDE0C)
	// 830DDE00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830DDE04: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830DDE08: 4BBCB648  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DDE0C => {
    //   block [0x830DDE0C..0x830DDE1C)
	// 830DDE0C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830DDE10: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830DDE14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DDE18: 4E800421  bctrl
	ctx.lr = 0x830DDE1C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DDE1C => {
    //   block [0x830DDE1C..0x830DDE88)
	// 830DDE1C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830DDE20: 419A0068  beq cr6, 0x830dde88
	if ctx.cr[6].eq {
	pc = 0x830DDE88; continue 'dispatch;
	}
	// 830DDE24: 89610054  lbz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830DDE28: 57A9103A  slwi r9, r29, 2
	ctx.r[9].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830DDE2C: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 830DDE30: 89410055  lbz r10, 0x55(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(85 as u32) ) } as u64;
	// 830DDE34: 5567103E  rotlwi r7, r11, 2
	ctx.r[7].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 830DDE38: 89610056  lbz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 830DDE3C: 5546203E  rotlwi r6, r10, 4
	ctx.r[6].u64 = ((ctx.r[10].u32).rotate_left(4)) as u64;
	// 830DDE40: 88610057  lbz r3, 0x57(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 830DDE44: 5564303E  rotlwi r4, r11, 6
	ctx.r[4].u64 = ((ctx.r[11].u32).rotate_left(6)) as u64;
	// 830DDE48: 554AE13E  srwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830DDE4C: 7CA9402E  lwzx r5, r9, r8
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830DDE50: 54E9063E  clrlwi r9, r7, 0x18
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 830DDE54: 54C8063E  clrlwi r8, r6, 0x18
	ctx.r[8].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 830DDE58: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DDE5C: 7C871B78  or r7, r4, r3
	ctx.r[7].u64 = ctx.r[4].u64 | ctx.r[3].u64;
	// 830DDE60: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 830DDE64: 7D0B5B78  or r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 | ctx.r[11].u64;
	// 830DDE68: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830DDE6C: 98E10056  stb r7, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[7].u8 ) };
	// 830DDE70: 99410054  stb r10, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u8 ) };
	// 830DDE74: 99610055  stb r11, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[11].u8 ) };
	// 830DDE78: 40990010  ble cr6, 0x830dde88
	if !ctx.cr[6].gt {
	pc = 0x830DDE88; continue 'dispatch;
	}
	// 830DDE7C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830DDE80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DDE84: 4BBCBA85  bl 0x82ca9908
	ctx.lr = 0x830DDE88;
	sub_82CA9908(ctx, base);
	pc = 0x830DDE88; continue 'dispatch;
            }
            0x830DDE88 => {
    //   block [0x830DDE88..0x830DDE94)
	// 830DDE88: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830DDE8C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830DDE90: 4BBCB5C0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DDE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DDE98 size=164
    let mut pc: u32 = 0x830DDE98;
    'dispatch: loop {
        match pc {
            0x830DDE98 => {
    //   block [0x830DDE98..0x830DDEF8)
	// 830DDE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DDE9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830DDEA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830DDEA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DDEA8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DDEAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DDEB0: 396BA49C  addi r11, r11, -0x5b64
	ctx.r[11].s64 = ctx.r[11].s64 + -23396;
	// 830DDEB4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830DDEB8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830DDEBC: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 830DDEC0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830DDEC4: B15F0006  sth r10, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 830DDEC8: 419A0030  beq cr6, 0x830ddef8
	if ctx.cr[6].eq {
	pc = 0x830DDEF8; continue 'dispatch;
	}
	// 830DDECC: A1640004  lhz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DDED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DDED4: 419A0054  beq cr6, 0x830ddf28
	if ctx.cr[6].eq {
	pc = 0x830DDF28; continue 'dispatch;
	}
	// 830DDED8: A1640006  lhz r11, 6(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 830DDEDC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830DDEE0: B1640006  sth r11, 6(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(6 as u32), ctx.r[11].u16 ) };
	// 830DDEE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830DDEE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830DDEEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830DDEF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830DDEF4: 4E800020  blr
	return;
            }
            0x830DDEF8 => {
    //   block [0x830DDEF8..0x830DDF28)
	// 830DDEF8: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DDEFC: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830DDF00: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 830DDF04: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 830DDF08: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830DDF0C: 4BC7733D  bl 0x82d55248
	ctx.lr = 0x830DDF10;
	sub_82D55248(ctx, base);
	// 830DDF10: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 830DDF14: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 830DDF18: 4BFFE0F1  bl 0x830dc008
	ctx.lr = 0x830DDF1C;
	sub_830DC008(ctx, base);
	// 830DDF1C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830DDF20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DDF24: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x830DDF28; continue 'dispatch;
            }
            0x830DDF28 => {
    //   block [0x830DDF28..0x830DDF3C)
	// 830DDF28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830DDF2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830DDF30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830DDF34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830DDF38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DDF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830DDF40 size=1208
    let mut pc: u32 = 0x830DDF40;
    'dispatch: loop {
        match pc {
            0x830DDF40 => {
    //   block [0x830DDF40..0x830DDFF4)
	// 830DDF40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DDF44: 4BBCB4C1  bl 0x82ca9404
	ctx.lr = 0x830DDF48;
	sub_82CA93D0(ctx, base);
	// 830DDF48: 9421FD60  stwu r1, -0x2a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-672 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DDF4C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830DDF50: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830DDF54: 397DFFFF  addi r11, r29, -1
	ctx.r[11].s64 = ctx.r[29].s64 + -1;
	// 830DDF58: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830DDF5C: 2B0B001D  cmplwi cr6, r11, 0x1d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 29 as u32, &mut ctx.xer);
	// 830DDF60: 41990410  bgt cr6, 0x830de370
	if ctx.cr[6].gt {
	pc = 0x830DE370; continue 'dispatch;
	}
	// 830DDF64: 3D80830E  lis r12, -0x7cf2
	ctx.r[12].s64 = -2096234496;
	// 830DDF68: 398CDF7C  addi r12, r12, -0x2084
	ctx.r[12].s64 = ctx.r[12].s64 + -8324;
	// 830DDF6C: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 830DDF70: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 830DDF74: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 830DDF78: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x830DDFF4; continue 'dispatch;
		},
		1 => {
	pc = 0x830DE004; continue 'dispatch;
		},
		2 => {
	pc = 0x830DE018; continue 'dispatch;
		},
		3 => {
	pc = 0x830DE018; continue 'dispatch;
		},
		4 => {
	pc = 0x830DE030; continue 'dispatch;
		},
		5 => {
	pc = 0x830DE040; continue 'dispatch;
		},
		6 => {
	pc = 0x830DE050; continue 'dispatch;
		},
		7 => {
	pc = 0x830DE060; continue 'dispatch;
		},
		8 => {
	pc = 0x830DE070; continue 'dispatch;
		},
		9 => {
	pc = 0x830DE080; continue 'dispatch;
		},
		10 => {
	pc = 0x830DE0A8; continue 'dispatch;
		},
		11 => {
	pc = 0x830DE0B8; continue 'dispatch;
		},
		12 => {
	pc = 0x830DE0B8; continue 'dispatch;
		},
		13 => {
	pc = 0x830DE0EC; continue 'dispatch;
		},
		14 => {
	pc = 0x830DE0EC; continue 'dispatch;
		},
		15 => {
	pc = 0x830DE16C; continue 'dispatch;
		},
		16 => {
	pc = 0x830DE1F8; continue 'dispatch;
		},
		17 => {
	pc = 0x830DE2BC; continue 'dispatch;
		},
		18 => {
	pc = 0x830DE370; continue 'dispatch;
		},
		19 => {
	pc = 0x830DE370; continue 'dispatch;
		},
		20 => {
	pc = 0x830DE370; continue 'dispatch;
		},
		21 => {
	pc = 0x830DE370; continue 'dispatch;
		},
		22 => {
	pc = 0x830DE370; continue 'dispatch;
		},
		23 => {
	pc = 0x830DE370; continue 'dispatch;
		},
		24 => {
	pc = 0x830DE370; continue 'dispatch;
		},
		25 => {
	pc = 0x830DE370; continue 'dispatch;
		},
		26 => {
	pc = 0x830DE370; continue 'dispatch;
		},
		27 => {
	pc = 0x830DE370; continue 'dispatch;
		},
		28 => {
	pc = 0x830DE370; continue 'dispatch;
		},
		29 => {
	pc = 0x830DE090; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 830DDF7C: 830DDFF4  lwz r24, -0x200c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-8204 as u32) ) } as u64;
	// 830DDF80: 830DE004  lwz r24, -0x1ffc(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-8188 as u32) ) } as u64;
	// 830DDF84: 830DE018  lwz r24, -0x1fe8(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-8168 as u32) ) } as u64;
	// 830DDF88: 830DE018  lwz r24, -0x1fe8(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-8168 as u32) ) } as u64;
	// 830DDF8C: 830DE030  lwz r24, -0x1fd0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-8144 as u32) ) } as u64;
	// 830DDF90: 830DE040  lwz r24, -0x1fc0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-8128 as u32) ) } as u64;
	// 830DDF94: 830DE050  lwz r24, -0x1fb0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-8112 as u32) ) } as u64;
	// 830DDF98: 830DE060  lwz r24, -0x1fa0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-8096 as u32) ) } as u64;
	// 830DDF9C: 830DE070  lwz r24, -0x1f90(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-8080 as u32) ) } as u64;
	// 830DDFA0: 830DE080  lwz r24, -0x1f80(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-8064 as u32) ) } as u64;
	// 830DDFA4: 830DE0A8  lwz r24, -0x1f58(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-8024 as u32) ) } as u64;
	// 830DDFA8: 830DE0B8  lwz r24, -0x1f48(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-8008 as u32) ) } as u64;
	// 830DDFAC: 830DE0B8  lwz r24, -0x1f48(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-8008 as u32) ) } as u64;
	// 830DDFB0: 830DE0EC  lwz r24, -0x1f14(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-7956 as u32) ) } as u64;
	// 830DDFB4: 830DE0EC  lwz r24, -0x1f14(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-7956 as u32) ) } as u64;
	// 830DDFB8: 830DE16C  lwz r24, -0x1e94(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-7828 as u32) ) } as u64;
	// 830DDFBC: 830DE1F8  lwz r24, -0x1e08(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-7688 as u32) ) } as u64;
	// 830DDFC0: 830DE2BC  lwz r24, -0x1d44(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-7492 as u32) ) } as u64;
	// 830DDFC4: 830DE370  lwz r24, -0x1c90(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-7312 as u32) ) } as u64;
	// 830DDFC8: 830DE370  lwz r24, -0x1c90(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-7312 as u32) ) } as u64;
	// 830DDFCC: 830DE370  lwz r24, -0x1c90(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-7312 as u32) ) } as u64;
	// 830DDFD0: 830DE370  lwz r24, -0x1c90(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-7312 as u32) ) } as u64;
	// 830DDFD4: 830DE370  lwz r24, -0x1c90(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-7312 as u32) ) } as u64;
	// 830DDFD8: 830DE370  lwz r24, -0x1c90(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-7312 as u32) ) } as u64;
	// 830DDFDC: 830DE370  lwz r24, -0x1c90(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-7312 as u32) ) } as u64;
	// 830DDFE0: 830DE370  lwz r24, -0x1c90(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-7312 as u32) ) } as u64;
	// 830DDFE4: 830DE370  lwz r24, -0x1c90(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-7312 as u32) ) } as u64;
	// 830DDFE8: 830DE370  lwz r24, -0x1c90(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-7312 as u32) ) } as u64;
	// 830DDFEC: 830DE370  lwz r24, -0x1c90(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-7312 as u32) ) } as u64;
	// 830DDFF0: 830DE090  lwz r24, -0x1f70(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-8048 as u32) ) } as u64;
            }
            0x830DDFF4 => {
    //   block [0x830DDFF4..0x830DE004)
	// 830DDFF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DDFF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DDFFC: 48138FA5  bl 0x83216fa0
	ctx.lr = 0x830DE000;
	sub_83216FA0(ctx, base);
	// 830DE000: 480003D4  b 0x830de3d4
	pc = 0x830DE3D4; continue 'dispatch;
            }
            0x830DE004 => {
    //   block [0x830DE004..0x830DE018)
	// 830DE004: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DE008: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DE00C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE010: 48139289  bl 0x83217298
	ctx.lr = 0x830DE014;
	sub_83217298(ctx, base);
	// 830DE014: 480003C0  b 0x830de3d4
	pc = 0x830DE3D4; continue 'dispatch;
            }
            0x830DE018 => {
    //   block [0x830DE018..0x830DE030)
	// 830DE018: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830DE01C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE020: 481394F1  bl 0x83217510
	ctx.lr = 0x830DE024;
	sub_83217510(ctx, base);
	// 830DE024: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DE028: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830DE02C: 480003A8  b 0x830de3d4
	pc = 0x830DE3D4; continue 'dispatch;
            }
            0x830DE030 => {
    //   block [0x830DE030..0x830DE040)
	// 830DE030: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DE034: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE038: 48139409  bl 0x83217440
	ctx.lr = 0x830DE03C;
	sub_83217440(ctx, base);
	// 830DE03C: 48000398  b 0x830de3d4
	pc = 0x830DE3D4; continue 'dispatch;
            }
            0x830DE040 => {
    //   block [0x830DE040..0x830DE050)
	// 830DE040: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DE044: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE048: 48139461  bl 0x832174a8
	ctx.lr = 0x830DE04C;
	sub_832174A8(ctx, base);
	// 830DE04C: 48000388  b 0x830de3d4
	pc = 0x830DE3D4; continue 'dispatch;
            }
            0x830DE050 => {
    //   block [0x830DE050..0x830DE060)
	// 830DE050: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DE054: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE058: 481394B9  bl 0x83217510
	ctx.lr = 0x830DE05C;
	sub_83217510(ctx, base);
	// 830DE05C: 48000378  b 0x830de3d4
	pc = 0x830DE3D4; continue 'dispatch;
            }
            0x830DE060 => {
    //   block [0x830DE060..0x830DE070)
	// 830DE060: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DE064: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE068: 48139509  bl 0x83217570
	ctx.lr = 0x830DE06C;
	sub_83217570(ctx, base);
	// 830DE06C: 48000368  b 0x830de3d4
	pc = 0x830DE3D4; continue 'dispatch;
            }
            0x830DE070 => {
    //   block [0x830DE070..0x830DE080)
	// 830DE070: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DE074: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE078: 48139559  bl 0x832175d0
	ctx.lr = 0x830DE07C;
	sub_832175D0(ctx, base);
	// 830DE07C: 48000358  b 0x830de3d4
	pc = 0x830DE3D4; continue 'dispatch;
            }
            0x830DE080 => {
    //   block [0x830DE080..0x830DE090)
	// 830DE080: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DE084: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE088: 481395A9  bl 0x83217630
	ctx.lr = 0x830DE08C;
	sub_83217630(ctx, base);
	// 830DE08C: 48000348  b 0x830de3d4
	pc = 0x830DE3D4; continue 'dispatch;
            }
            0x830DE090 => {
    //   block [0x830DE090..0x830DE0A8)
	// 830DE090: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830DE094: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE098: 48139599  bl 0x83217630
	ctx.lr = 0x830DE09C;
	sub_83217630(ctx, base);
	// 830DE09C: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830DE0A0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830DE0A4: 48000330  b 0x830de3d4
	pc = 0x830DE3D4; continue 'dispatch;
            }
            0x830DE0A8 => {
    //   block [0x830DE0A8..0x830DE0B8)
	// 830DE0A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DE0AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE0B0: 481390D9  bl 0x83217188
	ctx.lr = 0x830DE0B4;
	sub_83217188(ctx, base);
	// 830DE0B4: 48000320  b 0x830de3d4
	pc = 0x830DE3D4; continue 'dispatch;
            }
            0x830DE0B8 => {
    //   block [0x830DE0B8..0x830DE0EC)
	// 830DE0B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DE0BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE0C0: 3BBF000C  addi r29, r31, 0xc
	ctx.r[29].s64 = ctx.r[31].s64 + 12;
	// 830DE0C4: 3B9F0008  addi r28, r31, 8
	ctx.r[28].s64 = ctx.r[31].s64 + 8;
	// 830DE0C8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 830DE0CC: 481390BD  bl 0x83217188
	ctx.lr = 0x830DE0D0;
	sub_83217188(ctx, base);
	// 830DE0D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DE0D4: 481390B5  bl 0x83217188
	ctx.lr = 0x830DE0D8;
	sub_83217188(ctx, base);
	// 830DE0D8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DE0DC: 481390AD  bl 0x83217188
	ctx.lr = 0x830DE0E0;
	sub_83217188(ctx, base);
	// 830DE0E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DE0E4: 481390A5  bl 0x83217188
	ctx.lr = 0x830DE0E8;
	sub_83217188(ctx, base);
	// 830DE0E8: 480002EC  b 0x830de3d4
	pc = 0x830DE3D4; continue 'dispatch;
            }
            0x830DE0EC => {
    //   block [0x830DE0EC..0x830DE16C)
	// 830DE0EC: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 830DE0F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830DE0F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DE0F8: 4BC7AC49  bl 0x82d58d40
	ctx.lr = 0x830DE0FC;
	sub_82D58D40(ctx, base);
	// 830DE0FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DE100: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE104: 3BBF0008  addi r29, r31, 8
	ctx.r[29].s64 = ctx.r[31].s64 + 8;
	// 830DE108: 3B9F0004  addi r28, r31, 4
	ctx.r[28].s64 = ctx.r[31].s64 + 4;
	// 830DE10C: 4813907D  bl 0x83217188
	ctx.lr = 0x830DE110;
	sub_83217188(ctx, base);
	// 830DE110: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DE114: 48139075  bl 0x83217188
	ctx.lr = 0x830DE118;
	sub_83217188(ctx, base);
	// 830DE118: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DE11C: 4813906D  bl 0x83217188
	ctx.lr = 0x830DE120;
	sub_83217188(ctx, base);
	// 830DE120: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 830DE124: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE128: 3BBF0018  addi r29, r31, 0x18
	ctx.r[29].s64 = ctx.r[31].s64 + 24;
	// 830DE12C: 3B9F0014  addi r28, r31, 0x14
	ctx.r[28].s64 = ctx.r[31].s64 + 20;
	// 830DE130: 48139059  bl 0x83217188
	ctx.lr = 0x830DE134;
	sub_83217188(ctx, base);
	// 830DE134: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DE138: 48139051  bl 0x83217188
	ctx.lr = 0x830DE13C;
	sub_83217188(ctx, base);
	// 830DE13C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DE140: 48139049  bl 0x83217188
	ctx.lr = 0x830DE144;
	sub_83217188(ctx, base);
	// 830DE144: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 830DE148: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE14C: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 830DE150: 3BFF0024  addi r31, r31, 0x24
	ctx.r[31].s64 = ctx.r[31].s64 + 36;
	// 830DE154: 48139035  bl 0x83217188
	ctx.lr = 0x830DE158;
	sub_83217188(ctx, base);
	// 830DE158: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DE15C: 4813902D  bl 0x83217188
	ctx.lr = 0x830DE160;
	sub_83217188(ctx, base);
	// 830DE160: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DE164: 48139025  bl 0x83217188
	ctx.lr = 0x830DE168;
	sub_83217188(ctx, base);
	// 830DE168: 4800026C  b 0x830de3d4
	pc = 0x830DE3D4; continue 'dispatch;
            }
            0x830DE16C => {
    //   block [0x830DE16C..0x830DE1F8)
	// 830DE16C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DE170: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE174: 3BBF0008  addi r29, r31, 8
	ctx.r[29].s64 = ctx.r[31].s64 + 8;
	// 830DE178: 3B9F0004  addi r28, r31, 4
	ctx.r[28].s64 = ctx.r[31].s64 + 4;
	// 830DE17C: 4813900D  bl 0x83217188
	ctx.lr = 0x830DE180;
	sub_83217188(ctx, base);
	// 830DE180: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DE184: 48139005  bl 0x83217188
	ctx.lr = 0x830DE188;
	sub_83217188(ctx, base);
	// 830DE188: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DE18C: 48138FFD  bl 0x83217188
	ctx.lr = 0x830DE190;
	sub_83217188(ctx, base);
	// 830DE190: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 830DE194: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE198: 3BBF001C  addi r29, r31, 0x1c
	ctx.r[29].s64 = ctx.r[31].s64 + 28;
	// 830DE19C: 3B9F0018  addi r28, r31, 0x18
	ctx.r[28].s64 = ctx.r[31].s64 + 24;
	// 830DE1A0: 3B7F0014  addi r27, r31, 0x14
	ctx.r[27].s64 = ctx.r[31].s64 + 20;
	// 830DE1A4: 48138FE5  bl 0x83217188
	ctx.lr = 0x830DE1A8;
	sub_83217188(ctx, base);
	// 830DE1A8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830DE1AC: 48138FDD  bl 0x83217188
	ctx.lr = 0x830DE1B0;
	sub_83217188(ctx, base);
	// 830DE1B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DE1B4: 48138FD5  bl 0x83217188
	ctx.lr = 0x830DE1B8;
	sub_83217188(ctx, base);
	// 830DE1B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DE1BC: 48138FCD  bl 0x83217188
	ctx.lr = 0x830DE1C0;
	sub_83217188(ctx, base);
	// 830DE1C0: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 830DE1C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE1C8: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 830DE1CC: 3B9F0024  addi r28, r31, 0x24
	ctx.r[28].s64 = ctx.r[31].s64 + 36;
	// 830DE1D0: 48138FB9  bl 0x83217188
	ctx.lr = 0x830DE1D4;
	sub_83217188(ctx, base);
	// 830DE1D4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DE1D8: 48138FB1  bl 0x83217188
	ctx.lr = 0x830DE1DC;
	sub_83217188(ctx, base);
	// 830DE1DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DE1E0: 48138FA9  bl 0x83217188
	ctx.lr = 0x830DE1E4;
	sub_83217188(ctx, base);
	// 830DE1E4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830DE1E8: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830DE1EC: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 830DE1F0: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830DE1F4: 480001E0  b 0x830de3d4
	pc = 0x830DE3D4; continue 'dispatch;
            }
            0x830DE1F8 => {
    //   block [0x830DE1F8..0x830DE2BC)
	// 830DE1F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DE1FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE200: 3BBF000C  addi r29, r31, 0xc
	ctx.r[29].s64 = ctx.r[31].s64 + 12;
	// 830DE204: 3B9F0008  addi r28, r31, 8
	ctx.r[28].s64 = ctx.r[31].s64 + 8;
	// 830DE208: 3B7F0004  addi r27, r31, 4
	ctx.r[27].s64 = ctx.r[31].s64 + 4;
	// 830DE20C: 48138F7D  bl 0x83217188
	ctx.lr = 0x830DE210;
	sub_83217188(ctx, base);
	// 830DE210: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830DE214: 48138F75  bl 0x83217188
	ctx.lr = 0x830DE218;
	sub_83217188(ctx, base);
	// 830DE218: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DE21C: 48138F6D  bl 0x83217188
	ctx.lr = 0x830DE220;
	sub_83217188(ctx, base);
	// 830DE220: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DE224: 48138F65  bl 0x83217188
	ctx.lr = 0x830DE228;
	sub_83217188(ctx, base);
	// 830DE228: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 830DE22C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE230: 3BBF001C  addi r29, r31, 0x1c
	ctx.r[29].s64 = ctx.r[31].s64 + 28;
	// 830DE234: 3B9F0018  addi r28, r31, 0x18
	ctx.r[28].s64 = ctx.r[31].s64 + 24;
	// 830DE238: 3B7F0014  addi r27, r31, 0x14
	ctx.r[27].s64 = ctx.r[31].s64 + 20;
	// 830DE23C: 48138F4D  bl 0x83217188
	ctx.lr = 0x830DE240;
	sub_83217188(ctx, base);
	// 830DE240: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830DE244: 48138F45  bl 0x83217188
	ctx.lr = 0x830DE248;
	sub_83217188(ctx, base);
	// 830DE248: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DE24C: 48138F3D  bl 0x83217188
	ctx.lr = 0x830DE250;
	sub_83217188(ctx, base);
	// 830DE250: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DE254: 48138F35  bl 0x83217188
	ctx.lr = 0x830DE258;
	sub_83217188(ctx, base);
	// 830DE258: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 830DE25C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE260: 3BBF002C  addi r29, r31, 0x2c
	ctx.r[29].s64 = ctx.r[31].s64 + 44;
	// 830DE264: 3B9F0028  addi r28, r31, 0x28
	ctx.r[28].s64 = ctx.r[31].s64 + 40;
	// 830DE268: 3B7F0024  addi r27, r31, 0x24
	ctx.r[27].s64 = ctx.r[31].s64 + 36;
	// 830DE26C: 48138F1D  bl 0x83217188
	ctx.lr = 0x830DE270;
	sub_83217188(ctx, base);
	// 830DE270: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830DE274: 48138F15  bl 0x83217188
	ctx.lr = 0x830DE278;
	sub_83217188(ctx, base);
	// 830DE278: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DE27C: 48138F0D  bl 0x83217188
	ctx.lr = 0x830DE280;
	sub_83217188(ctx, base);
	// 830DE280: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DE284: 48138F05  bl 0x83217188
	ctx.lr = 0x830DE288;
	sub_83217188(ctx, base);
	// 830DE288: 389F0030  addi r4, r31, 0x30
	ctx.r[4].s64 = ctx.r[31].s64 + 48;
	// 830DE28C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE290: 3BBF003C  addi r29, r31, 0x3c
	ctx.r[29].s64 = ctx.r[31].s64 + 60;
	// 830DE294: 3B9F0038  addi r28, r31, 0x38
	ctx.r[28].s64 = ctx.r[31].s64 + 56;
	// 830DE298: 3BFF0034  addi r31, r31, 0x34
	ctx.r[31].s64 = ctx.r[31].s64 + 52;
	// 830DE29C: 48138EED  bl 0x83217188
	ctx.lr = 0x830DE2A0;
	sub_83217188(ctx, base);
	// 830DE2A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DE2A4: 48138EE5  bl 0x83217188
	ctx.lr = 0x830DE2A8;
	sub_83217188(ctx, base);
	// 830DE2A8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DE2AC: 48138EDD  bl 0x83217188
	ctx.lr = 0x830DE2B0;
	sub_83217188(ctx, base);
	// 830DE2B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DE2B4: 48138ED5  bl 0x83217188
	ctx.lr = 0x830DE2B8;
	sub_83217188(ctx, base);
	// 830DE2B8: 4800011C  b 0x830de3d4
	pc = 0x830DE3D4; continue 'dispatch;
            }
            0x830DE2BC => {
    //   block [0x830DE2BC..0x830DE370)
	// 830DE2BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DE2C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE2C4: 3BBF0008  addi r29, r31, 8
	ctx.r[29].s64 = ctx.r[31].s64 + 8;
	// 830DE2C8: 3B9F0004  addi r28, r31, 4
	ctx.r[28].s64 = ctx.r[31].s64 + 4;
	// 830DE2CC: 48138EBD  bl 0x83217188
	ctx.lr = 0x830DE2D0;
	sub_83217188(ctx, base);
	// 830DE2D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DE2D4: 48138EB5  bl 0x83217188
	ctx.lr = 0x830DE2D8;
	sub_83217188(ctx, base);
	// 830DE2D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DE2DC: 48138EAD  bl 0x83217188
	ctx.lr = 0x830DE2E0;
	sub_83217188(ctx, base);
	// 830DE2E0: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 830DE2E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE2E8: 3BBF0018  addi r29, r31, 0x18
	ctx.r[29].s64 = ctx.r[31].s64 + 24;
	// 830DE2EC: 3B9F0014  addi r28, r31, 0x14
	ctx.r[28].s64 = ctx.r[31].s64 + 20;
	// 830DE2F0: 48138E99  bl 0x83217188
	ctx.lr = 0x830DE2F4;
	sub_83217188(ctx, base);
	// 830DE2F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DE2F8: 48138E91  bl 0x83217188
	ctx.lr = 0x830DE2FC;
	sub_83217188(ctx, base);
	// 830DE2FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DE300: 48138E89  bl 0x83217188
	ctx.lr = 0x830DE304;
	sub_83217188(ctx, base);
	// 830DE304: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 830DE308: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE30C: 3BBF0028  addi r29, r31, 0x28
	ctx.r[29].s64 = ctx.r[31].s64 + 40;
	// 830DE310: 3B9F0024  addi r28, r31, 0x24
	ctx.r[28].s64 = ctx.r[31].s64 + 36;
	// 830DE314: 48138E75  bl 0x83217188
	ctx.lr = 0x830DE318;
	sub_83217188(ctx, base);
	// 830DE318: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DE31C: 48138E6D  bl 0x83217188
	ctx.lr = 0x830DE320;
	sub_83217188(ctx, base);
	// 830DE320: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DE324: 48138E65  bl 0x83217188
	ctx.lr = 0x830DE328;
	sub_83217188(ctx, base);
	// 830DE328: 389F0030  addi r4, r31, 0x30
	ctx.r[4].s64 = ctx.r[31].s64 + 48;
	// 830DE32C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE330: 3BBF0038  addi r29, r31, 0x38
	ctx.r[29].s64 = ctx.r[31].s64 + 56;
	// 830DE334: 3B9F0034  addi r28, r31, 0x34
	ctx.r[28].s64 = ctx.r[31].s64 + 52;
	// 830DE338: 48138E51  bl 0x83217188
	ctx.lr = 0x830DE33C;
	sub_83217188(ctx, base);
	// 830DE33C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DE340: 48138E49  bl 0x83217188
	ctx.lr = 0x830DE344;
	sub_83217188(ctx, base);
	// 830DE344: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DE348: 48138E41  bl 0x83217188
	ctx.lr = 0x830DE34C;
	sub_83217188(ctx, base);
	// 830DE34C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830DE350: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830DE354: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830DE358: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 830DE35C: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 830DE360: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830DE364: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830DE368: D1BF003C  stfs f13, 0x3c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 830DE36C: 48000068  b 0x830de3d4
	pc = 0x830DE3D4; continue 'dispatch;
            }
            0x830DE370 => {
    //   block [0x830DE370..0x830DE3D4)
	// 830DE370: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 830DE374: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830DE378: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830DE37C: 4BC7966D  bl 0x82d579e8
	ctx.lr = 0x830DE380;
	sub_82D579E8(ctx, base);
	// 830DE380: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DE384: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830DE388: 388BA558  addi r4, r11, -0x5aa8
	ctx.r[4].s64 = ctx.r[11].s64 + -23208;
	// 830DE38C: 4BC79A65  bl 0x82d57df0
	ctx.lr = 0x830DE390;
	sub_82D57DF0(ctx, base);
	// 830DE390: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DE394: 4BC79B95  bl 0x82d57f28
	ctx.lr = 0x830DE398;
	sub_82D57F28(ctx, base);
	// 830DE398: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830DE39C: 3CA019FC  lis r5, 0x19fc
	ctx.r[5].s64 = 435945472;
	// 830DE3A0: 39000104  li r8, 0x104
	ctx.r[8].s64 = 260;
	// 830DE3A4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 830DE3A8: 60A5A9AD  ori r5, r5, 0xa9ad
	ctx.r[5].u64 = ctx.r[5].u64 | 43437;
	// 830DE3AC: 806B7630  lwz r3, 0x7630(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30256 as u32) ) } as u64;
	// 830DE3B0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DE3B4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 830DE3B8: 38EBA530  addi r7, r11, -0x5ad0
	ctx.r[7].s64 = ctx.r[11].s64 + -23248;
	// 830DE3BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE3C0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DE3C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DE3C8: 4E800421  bctrl
	ctx.lr = 0x830DE3CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DE3CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830DE3D0: 4BC7A061  bl 0x82d58430
	ctx.lr = 0x830DE3D4;
	sub_82D58430(ctx, base);
            }
            0x830DE3D4 => {
    //   block [0x830DE3D4..0x830DE3F8)
	// 830DE3D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830DE3D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830DE3DC: 48138695  bl 0x83216a70
	ctx.lr = 0x830DE3E0;
	sub_83216A70(ctx, base);
	// 830DE3E0: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE3E4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DE3E8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830DE3EC: 5563DFFE  rlwinm r3, r11, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830DE3F0: 382102A0  addi r1, r1, 0x2a0
	ctx.r[1].s64 = ctx.r[1].s64 + 672;
	// 830DE3F4: 4BBCB060  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DE3F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DE3F8 size=96
    let mut pc: u32 = 0x830DE3F8;
    'dispatch: loop {
        match pc {
            0x830DE3F8 => {
    //   block [0x830DE3F8..0x830DE44C)
	// 830DE3F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DE3FC: 4BBCB011  bl 0x82ca940c
	ctx.lr = 0x830DE400;
	sub_82CA93D0(ctx, base);
	// 830DE400: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DE404: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830DE408: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830DE40C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DE410: 388B96B8  addi r4, r11, -0x6948
	ctx.r[4].s64 = ctx.r[11].s64 + -26952;
	// 830DE414: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830DE418: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830DE41C: 4BFFF765  bl 0x830ddb80
	ctx.lr = 0x830DE420;
	sub_830DDB80(ctx, base);
	// 830DE420: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830DE424: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830DE428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DE42C: 4BFFF7ED  bl 0x830ddc18
	ctx.lr = 0x830DE430;
	sub_830DDC18(ctx, base);
	// 830DE430: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DE434: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830DE438: 409A0014  bne cr6, 0x830de44c
	if !ctx.cr[6].eq {
	pc = 0x830DE44C; continue 'dispatch;
	}
	// 830DE43C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830DE440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DE444: 388B96D0  addi r4, r11, -0x6930
	ctx.r[4].s64 = ctx.r[11].s64 + -26928;
	// 830DE448: 4BFFF739  bl 0x830ddb80
	ctx.lr = 0x830DE44C;
	sub_830DDB80(ctx, base);
	pc = 0x830DE44C; continue 'dispatch;
            }
            0x830DE44C => {
    //   block [0x830DE44C..0x830DE458)
	// 830DE44C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE450: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830DE454: 4BBCB008  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DE458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DE458 size=144
    let mut pc: u32 = 0x830DE458;
    'dispatch: loop {
        match pc {
            0x830DE458 => {
    //   block [0x830DE458..0x830DE4AC)
	// 830DE458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DE45C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830DE460: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830DE464: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830DE468: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DE46C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830DE470: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830DE474: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 830DE478: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830DE47C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830DE480: 4BFFE279  bl 0x830dc6f8
	ctx.lr = 0x830DE484;
	sub_830DC6F8(ctx, base);
	// 830DE484: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DE488: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DE48C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830DE490: 409A001C  bne cr6, 0x830de4ac
	if !ctx.cr[6].eq {
	pc = 0x830DE4AC; continue 'dispatch;
	}
	// 830DE494: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DE498: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DE49C: 4BC7A53D  bl 0x82d589d8
	ctx.lr = 0x830DE4A0;
	sub_82D589D8(ctx, base);
	// 830DE4A0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DE4A4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DE4A8: 419A0008  beq cr6, 0x830de4b0
	if ctx.cr[6].eq {
	pc = 0x830DE4B0; continue 'dispatch;
	}
	pc = 0x830DE4AC; continue 'dispatch;
            }
            0x830DE4AC => {
    //   block [0x830DE4AC..0x830DE4B0)
	// 830DE4AC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x830DE4B0; continue 'dispatch;
            }
            0x830DE4B0 => {
    //   block [0x830DE4B0..0x830DE4CC)
	// 830DE4B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DE4B4: 419A0018  beq cr6, 0x830de4cc
	if ctx.cr[6].eq {
	pc = 0x830DE4CC; continue 'dispatch;
	}
	// 830DE4B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE4BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DE4C0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE4C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DE4C8: 4E800421  bctrl
	ctx.lr = 0x830DE4CC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DE4CC => {
    //   block [0x830DE4CC..0x830DE4E8)
	// 830DE4CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE4D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830DE4D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830DE4D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830DE4DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830DE4E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830DE4E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DE4E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DE4E8 size=224
    let mut pc: u32 = 0x830DE4E8;
    'dispatch: loop {
        match pc {
            0x830DE4E8 => {
    //   block [0x830DE4E8..0x830DE530)
	// 830DE4E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DE4EC: 4BBCAF15  bl 0x82ca9400
	ctx.lr = 0x830DE4F0;
	sub_82CA93D0(ctx, base);
	// 830DE4F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DE4F4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830DE4F8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830DE4FC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830DE500: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 830DE504: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DE508: 397EFFFF  addi r11, r30, -1
	ctx.r[11].s64 = ctx.r[30].s64 + -1;
	// 830DE50C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830DE510: 409A0020  bne cr6, 0x830de530
	if !ctx.cr[6].eq {
	pc = 0x830DE530; continue 'dispatch;
	}
	// 830DE514: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE518: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE51C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DE520: 409A0010  bne cr6, 0x830de530
	if !ctx.cr[6].eq {
	pc = 0x830DE530; continue 'dispatch;
	}
	// 830DE524: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830DE528: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830DE52C: 4BBCAF24  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DE530 => {
    //   block [0x830DE530..0x830DE584)
	// 830DE530: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830DE534: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DE538: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830DE53C: 48001C3D  bl 0x830e0178
	ctx.lr = 0x830DE540;
	sub_830E0178(ctx, base);
	// 830DE540: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE544: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830DE548: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE54C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830DE550: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE554: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 830DE558: 4BC7A7D9  bl 0x82d58d30
	ctx.lr = 0x830DE55C;
	sub_82D58D30(ctx, base);
	// 830DE55C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DE560: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DE564: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DE568: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 830DE56C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 830DE570: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DE574: 409A0010  bne cr6, 0x830de584
	if !ctx.cr[6].eq {
	pc = 0x830DE584; continue 'dispatch;
	}
	// 830DE578: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 830DE57C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DE580: 4BC78A19  bl 0x82d56f98
	ctx.lr = 0x830DE584;
	sub_82D56F98(ctx, base);
	pc = 0x830DE584; continue 'dispatch;
            }
            0x830DE584 => {
    //   block [0x830DE584..0x830DE5C8)
	// 830DE584: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DE588: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830DE58C: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830DE590: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE594: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DE598: 7D4B492A  stdx r10, r11, r9
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u64) };
	// 830DE59C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DE5A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830DE5A4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830DE5A8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE5AC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DE5B0: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 830DE5B4: 394A000F  addi r10, r10, 0xf
	ctx.r[10].s64 = ctx.r[10].s64 + 15;
	// 830DE5B8: 554A0036  rlwinm r10, r10, 0, 0, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830DE5BC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830DE5C0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830DE5C4: 4BBCAE8C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DE5C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DE5C8 size=292
    let mut pc: u32 = 0x830DE5C8;
    'dispatch: loop {
        match pc {
            0x830DE5C8 => {
    //   block [0x830DE5C8..0x830DE658)
	// 830DE5C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DE5CC: 4BBCAE3D  bl 0x82ca9408
	ctx.lr = 0x830DE5D0;
	sub_82CA93D0(ctx, base);
	// 830DE5D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DE5D4: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE5D8: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830DE5DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830DE5E0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830DE5E4: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 830DE5E8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DE5EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DE5F0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830DE5F4: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 830DE5F8: 4BC76C51  bl 0x82d55248
	ctx.lr = 0x830DE5FC;
	sub_82D55248(ctx, base);
	// 830DE5FC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830DE600: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830DE604: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830DE608: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830DE60C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830DE610: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830DE614: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE618: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830DE61C: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830DE620: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 830DE624: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830DE628: 4BFFE0D1  bl 0x830dc6f8
	ctx.lr = 0x830DE62C;
	sub_830DC6F8(ctx, base);
	// 830DE62C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DE630: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DE634: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830DE638: 409A0094  bne cr6, 0x830de6cc
	if !ctx.cr[6].eq {
	pc = 0x830DE6CC; continue 'dispatch;
	}
	// 830DE63C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 830DE640: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830DE644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DE648: 419A0010  beq cr6, 0x830de658
	if ctx.cr[6].eq {
	pc = 0x830DE658; continue 'dispatch;
	}
	// 830DE64C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DE650: 388BA57C  addi r4, r11, -0x5a84
	ctx.r[4].s64 = ctx.r[11].s64 + -23172;
	// 830DE654: 4BFFD7E5  bl 0x830dbe38
	ctx.lr = 0x830DE658;
	sub_830DBE38(ctx, base);
	pc = 0x830DE658; continue 'dispatch;
            }
            0x830DE658 => {
    //   block [0x830DE658..0x830DE67C)
	// 830DE658: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DE65C: 83DD0010  lwz r30, 0x10(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 830DE660: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DE664: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830DE668: 40980024  bge cr6, 0x830de68c
	if !ctx.cr[6].lt {
	pc = 0x830DE68C; continue 'dispatch;
	}
	// 830DE66C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DE670: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DE674: 41980008  blt cr6, 0x830de67c
	if ctx.cr[6].lt {
	pc = 0x830DE67C; continue 'dispatch;
	}
	// 830DE678: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x830DE67C; continue 'dispatch;
            }
            0x830DE67C => {
    //   block [0x830DE67C..0x830DE68C)
	// 830DE67C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DE680: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830DE684: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DE688: 4BC78889  bl 0x82d56f10
	ctx.lr = 0x830DE68C;
	sub_82D56F10(ctx, base);
	pc = 0x830DE68C; continue 'dispatch;
            }
            0x830DE68C => {
    //   block [0x830DE68C..0x830DE6CC)
	// 830DE68C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830DE690: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830DE694: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE698: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DE69C: 4BC7A695  bl 0x82d58d30
	ctx.lr = 0x830DE6A0;
	sub_82D58D30(ctx, base);
	// 830DE6A0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DE6A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DE6A8: 419A0038  beq cr6, 0x830de6e0
	if ctx.cr[6].eq {
	pc = 0x830DE6E0; continue 'dispatch;
	}
	// 830DE6AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE6B0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DE6B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE6B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DE6BC: 4E800421  bctrl
	ctx.lr = 0x830DE6C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DE6C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DE6C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830DE6C8: 4BBCAD90  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DE6CC => {
    //   block [0x830DE6CC..0x830DE6E0)
	// 830DE6CC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830DE6D0: 409A0010  bne cr6, 0x830de6e0
	if !ctx.cr[6].eq {
	pc = 0x830DE6E0; continue 'dispatch;
	}
	// 830DE6D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830DE6D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DE6DC: 4BFFD6E5  bl 0x830dbdc0
	ctx.lr = 0x830DE6E0;
	sub_830DBDC0(ctx, base);
	pc = 0x830DE6E0; continue 'dispatch;
            }
            0x830DE6E0 => {
    //   block [0x830DE6E0..0x830DE6EC)
	// 830DE6E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DE6E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830DE6E8: 4BBCAD70  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DE6F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830DE6F0 size=936
    let mut pc: u32 = 0x830DE6F0;
    'dispatch: loop {
        match pc {
            0x830DE6F0 => {
    //   block [0x830DE6F0..0x830DE7B8)
	// 830DE6F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DE6F4: 4BBCACF1  bl 0x82ca93e4
	ctx.lr = 0x830DE6F8;
	sub_82CA93D0(ctx, base);
	// 830DE6F8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DE6FC: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 830DE700: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DE704: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 830DE708: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830DE70C: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 830DE710: 7EF8BB78  mr r24, r23
	ctx.r[24].u64 = ctx.r[23].u64;
	// 830DE714: 4BC7E905  bl 0x82d5d018
	ctx.lr = 0x830DE718;
	sub_82D5D018(ctx, base);
	// 830DE718: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 830DE71C: 3973FFFF  addi r11, r19, -1
	ctx.r[11].s64 = ctx.r[19].s64 + -1;
	// 830DE720: 2B0B001D  cmplwi cr6, r11, 0x1d
	ctx.cr[6].compare_u32(ctx.r[11].u32, 29 as u32, &mut ctx.xer);
	// 830DE724: 41990344  bgt cr6, 0x830dea68
	if ctx.cr[6].gt {
	pc = 0x830DEA68; continue 'dispatch;
	}
	// 830DE728: 3D80830E  lis r12, -0x7cf2
	ctx.r[12].s64 = -2096234496;
	// 830DE72C: 398CE740  addi r12, r12, -0x18c0
	ctx.r[12].s64 = ctx.r[12].s64 + -6336;
	// 830DE730: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 830DE734: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 830DE738: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 830DE73C: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		1 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		2 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		3 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		4 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		5 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		6 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		7 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		8 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		9 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		10 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		11 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		12 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		13 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		14 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		15 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		16 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		17 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		18 => {
	pc = 0x830DEA68; continue 'dispatch;
		},
		19 => {
	pc = 0x830DE860; continue 'dispatch;
		},
		20 => {
	pc = 0x830DE860; continue 'dispatch;
		},
		21 => {
	pc = 0x830DEA68; continue 'dispatch;
		},
		22 => {
	pc = 0x830DEA68; continue 'dispatch;
		},
		23 => {
	pc = 0x830DEA68; continue 'dispatch;
		},
		24 => {
	pc = 0x830DEA68; continue 'dispatch;
		},
		25 => {
	pc = 0x830DEA68; continue 'dispatch;
		},
		26 => {
	pc = 0x830DEA68; continue 'dispatch;
		},
		27 => {
	pc = 0x830DE860; continue 'dispatch;
		},
		28 => {
	pc = 0x830DEA68; continue 'dispatch;
		},
		29 => {
	pc = 0x830DE7B8; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 830DE740: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
	// 830DE744: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
	// 830DE748: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
	// 830DE74C: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
	// 830DE750: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
	// 830DE754: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
	// 830DE758: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
	// 830DE75C: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
	// 830DE760: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
	// 830DE764: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
	// 830DE768: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
	// 830DE76C: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
	// 830DE770: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
	// 830DE774: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
	// 830DE778: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
	// 830DE77C: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
	// 830DE780: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
	// 830DE784: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
	// 830DE788: 830DEA68  lwz r24, -0x1598(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5528 as u32) ) } as u64;
	// 830DE78C: 830DE860  lwz r24, -0x17a0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6048 as u32) ) } as u64;
	// 830DE790: 830DE860  lwz r24, -0x17a0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6048 as u32) ) } as u64;
	// 830DE794: 830DEA68  lwz r24, -0x1598(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5528 as u32) ) } as u64;
	// 830DE798: 830DEA68  lwz r24, -0x1598(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5528 as u32) ) } as u64;
	// 830DE79C: 830DEA68  lwz r24, -0x1598(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5528 as u32) ) } as u64;
	// 830DE7A0: 830DEA68  lwz r24, -0x1598(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5528 as u32) ) } as u64;
	// 830DE7A4: 830DEA68  lwz r24, -0x1598(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5528 as u32) ) } as u64;
	// 830DE7A8: 830DEA68  lwz r24, -0x1598(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5528 as u32) ) } as u64;
	// 830DE7AC: 830DE860  lwz r24, -0x17a0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6048 as u32) ) } as u64;
	// 830DE7B0: 830DEA68  lwz r24, -0x1598(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5528 as u32) ) } as u64;
	// 830DE7B4: 830DE7B8  lwz r24, -0x1848(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-6216 as u32) ) } as u64;
            }
            0x830DE7B8 => {
    //   block [0x830DE7B8..0x830DE80C)
	// 830DE7B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DE7BC: 4BC7E865  bl 0x82d5d020
	ctx.lr = 0x830DE7C0;
	sub_82D5D020(ctx, base);
	// 830DE7C0: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DE7C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DE7C8: 80960000  lwz r4, 0(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE7CC: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 830DE7D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830DE7D4: 48138B75  bl 0x83217348
	ctx.lr = 0x830DE7D8;
	sub_83217348(ctx, base);
	// 830DE7D8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DE7DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DE7E0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830DE7E4: 48001995  bl 0x830e0178
	ctx.lr = 0x830DE7E8;
	sub_830E0178(ctx, base);
	// 830DE7E8: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE7EC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830DE7F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830DE7F4: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 830DE7F8: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE7FC: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830DE800: 4BFFF741  bl 0x830ddf40
	ctx.lr = 0x830DE804;
	sub_830DDF40(ctx, base);
	// 830DE804: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DE808: 409A004C  bne cr6, 0x830de854
	if !ctx.cr[6].eq {
	pc = 0x830DE854; continue 'dispatch;
	}
	pc = 0x830DE80C; continue 'dispatch;
            }
            0x830DE80C => {
    //   block [0x830DE80C..0x830DE854)
	// 830DE80C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE810: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DE814: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DE818: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830DE81C: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 830DE820: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DE824: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 830DE828: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830DE82C: 4800194D  bl 0x830e0178
	ctx.lr = 0x830DE830;
	sub_830E0178(ctx, base);
	// 830DE830: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE834: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830DE838: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830DE83C: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 830DE840: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE844: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830DE848: 4BFFF6F9  bl 0x830ddf40
	ctx.lr = 0x830DE84C;
	sub_830DDF40(ctx, base);
	// 830DE84C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DE850: 419AFFBC  beq cr6, 0x830de80c
	if ctx.cr[6].eq {
	pc = 0x830DE80C; continue 'dispatch;
	}
	pc = 0x830DE854; continue 'dispatch;
            }
            0x830DE854 => {
    //   block [0x830DE854..0x830DE860)
	// 830DE854: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830DE858: 48138B61  bl 0x832173b8
	ctx.lr = 0x830DE85C;
	sub_832173B8(ctx, base);
	// 830DE85C: 4800020C  b 0x830dea68
	pc = 0x830DEA68; continue 'dispatch;
            }
            0x830DE860 => {
    //   block [0x830DE860..0x830DE878)
	// 830DE860: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DE864: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 830DE868: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 830DE86C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DE870: 408101A0  ble 0x830dea10
	if !ctx.cr[0].gt {
	pc = 0x830DEA10; continue 'dispatch;
	}
	// 830DE874: 3EA08000  lis r21, -0x8000
	ctx.r[21].s64 = -2147483648;
	pc = 0x830DE878; continue 'dispatch;
            }
            0x830DE878 => {
    //   block [0x830DE878..0x830DE8A8)
	// 830DE878: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE87C: 7D6BC8AE  lbzx r11, r11, r25
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 830DE880: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DE884: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 830DE888: 419A0020  beq cr6, 0x830de8a8
	if ctx.cr[6].eq {
	pc = 0x830DE8A8; continue 'dispatch;
	}
	// 830DE88C: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 830DE890: 419A0018  beq cr6, 0x830de8a8
	if ctx.cr[6].eq {
	pc = 0x830DE8A8; continue 'dispatch;
	}
	// 830DE894: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 830DE898: 419A0010  beq cr6, 0x830de8a8
	if ctx.cr[6].eq {
	pc = 0x830DE8A8; continue 'dispatch;
	}
	// 830DE89C: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 830DE8A0: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 830DE8A4: 409A0008  bne cr6, 0x830de8ac
	if !ctx.cr[6].eq {
	pc = 0x830DE8AC; continue 'dispatch;
	}
	pc = 0x830DE8A8; continue 'dispatch;
            }
            0x830DE8A8 => {
    //   block [0x830DE8A8..0x830DE8AC)
	// 830DE8A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830DE8AC; continue 'dispatch;
            }
            0x830DE8AC => {
    //   block [0x830DE8AC..0x830DE904)
	// 830DE8AC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DE8B0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DE8B4: 419A0148  beq cr6, 0x830de9fc
	if ctx.cr[6].eq {
	pc = 0x830DE9FC; continue 'dispatch;
	}
	// 830DE8B8: 7F1DC800  cmpw cr6, r29, r25
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[25].s32, &mut ctx.xer);
	// 830DE8BC: 419A013C  beq cr6, 0x830de9f8
	if ctx.cr[6].eq {
	pc = 0x830DE9F8; continue 'dispatch;
	}
	// 830DE8C0: 836D0000  lwz r27, 0(r13)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE8C4: 3B800004  li r28, 4
	ctx.r[28].s64 = 4;
	// 830DE8C8: 7FDDC850  subf r30, r29, r25
	ctx.r[30].s64 = ctx.r[25].s64 - ctx.r[29].s64;
	// 830DE8CC: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 830DE8D0: 92E10064  stw r23, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[23].u32 ) };
	// 830DE8D4: 3BFE0001  addi r31, r30, 1
	ctx.r[31].s64 = ctx.r[30].s64 + 1;
	// 830DE8D8: 92A10068  stw r21, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[21].u32 ) };
	// 830DE8DC: 7D7CD82E  lwzx r11, r28, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 830DE8E0: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 830DE8E4: 55440036  rlwinm r4, r10, 0, 0, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830DE8E8: 806B0020  lwz r3, 0x20(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830DE8EC: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 830DE8F0: 7D432214  add r10, r3, r4
	ctx.r[10].u64 = ctx.r[3].u64 + ctx.r[4].u64;
	// 830DE8F4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830DE8F8: 4199000C  bgt cr6, 0x830de904
	if ctx.cr[6].gt {
	pc = 0x830DE904; continue 'dispatch;
	}
	// 830DE8FC: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830DE900: 48000018  b 0x830de918
	pc = 0x830DE918; continue 'dispatch;
            }
            0x830DE904 => {
    //   block [0x830DE904..0x830DE918)
	// 830DE904: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE908: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830DE90C: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 830DE910: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DE914: 4E800421  bctrl
	ctx.lr = 0x830DE918;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DE918 => {
    //   block [0x830DE918..0x830DE958)
	// 830DE918: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE91C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830DE920: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 830DE924: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830DE928: 9061006C  stw r3, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[3].u32 ) };
	// 830DE92C: 7FEBAB78  or r11, r31, r21
	ctx.r[11].u64 = ctx.r[31].u64 | ctx.r[21].u64;
	// 830DE930: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 830DE934: 4BC7A3FD  bl 0x82d58d30
	ctx.lr = 0x830DE938;
	sub_82D58D30(ctx, base);
	// 830DE938: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830DE93C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DE940: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830DE944: 40980024  bge cr6, 0x830de968
	if !ctx.cr[6].lt {
	pc = 0x830DE968; continue 'dispatch;
	}
	// 830DE948: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DE94C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DE950: 41980008  blt cr6, 0x830de958
	if ctx.cr[6].lt {
	pc = 0x830DE958; continue 'dispatch;
	}
	// 830DE954: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x830DE958; continue 'dispatch;
            }
            0x830DE958 => {
    //   block [0x830DE958..0x830DE968)
	// 830DE958: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DE95C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830DE960: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830DE964: 4BC785AD  bl 0x82d56f10
	ctx.lr = 0x830DE968;
	sub_82D56F10(ctx, base);
	pc = 0x830DE968; continue 'dispatch;
            }
            0x830DE968 => {
    //   block [0x830DE968..0x830DE9D4)
	// 830DE968: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DE96C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DE970: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 830DE974: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 830DE978: 7D7D5850  subf r11, r29, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 830DE97C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830DE980: 7EEBC9AE  stbx r23, r11, r25
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[25].u32), ctx.r[23].u8) };
	// 830DE984: 480017F5  bl 0x830e0178
	ctx.lr = 0x830DE988;
	sub_830E0178(ctx, base);
	// 830DE988: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830DE98C: 80A10060  lwz r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DE990: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 830DE994: 4BC96D9D  bl 0x82d75730
	ctx.lr = 0x830DE998;
	sub_82D75730(ctx, base);
	// 830DE998: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE99C: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 830DE9A0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DE9A4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830DE9A8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830DE9AC: 7C7CD82E  lwzx r3, r28, r27
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 830DE9B0: 8081006C  lwz r4, 0x6c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830DE9B4: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830DE9B8: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 830DE9BC: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830DE9C0: 409A0014  bne cr6, 0x830de9d4
	if !ctx.cr[6].eq {
	pc = 0x830DE9D4; continue 'dispatch;
	}
	// 830DE9C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DE9C8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830DE9CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DE9D0: 4E800421  bctrl
	ctx.lr = 0x830DE9D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DE9D4 => {
    //   block [0x830DE9D4..0x830DE9F8)
	// 830DE9D4: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830DE9D8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DE9DC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DE9E0: 409A0018  bne cr6, 0x830de9f8
	if !ctx.cr[6].eq {
	pc = 0x830DE9F8; continue 'dispatch;
	}
	// 830DE9E4: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DE9E8: 7C7CD82E  lwzx r3, r28, r27
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 830DE9EC: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DE9F0: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DE9F4: 4BC768D5  bl 0x82d552c8
	ctx.lr = 0x830DE9F8;
	sub_82D552C8(ctx, base);
	pc = 0x830DE9F8; continue 'dispatch;
            }
            0x830DE9F8 => {
    //   block [0x830DE9F8..0x830DE9FC)
	// 830DE9F8: 3BB90001  addi r29, r25, 1
	ctx.r[29].s64 = ctx.r[25].s64 + 1;
	pc = 0x830DE9FC; continue 'dispatch;
            }
            0x830DE9FC => {
    //   block [0x830DE9FC..0x830DEA10)
	// 830DE9FC: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DEA00: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 830DEA04: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830DEA08: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DEA0C: 4198FE6C  blt cr6, 0x830de878
	if ctx.cr[6].lt {
	pc = 0x830DE878; continue 'dispatch;
	}
	pc = 0x830DEA10; continue 'dispatch;
            }
            0x830DEA10 => {
    //   block [0x830DEA10..0x830DEA58)
	// 830DEA10: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DEA14: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830DEA18: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DEA1C: 419A003C  beq cr6, 0x830dea58
	if ctx.cr[6].eq {
	pc = 0x830DEA58; continue 'dispatch;
	}
	// 830DEA20: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DEA24: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 830DEA28: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830DEA2C: 4800174D  bl 0x830e0178
	ctx.lr = 0x830DEA30;
	sub_830E0178(ctx, base);
	// 830DEA30: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DEA34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830DEA38: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 830DEA3C: 7CABEA14  add r5, r11, r29
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830DEA40: 4BC96CF1  bl 0x82d75730
	ctx.lr = 0x830DEA44;
	sub_82D75730(ctx, base);
	// 830DEA44: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DEA48: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 830DEA4C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DEA50: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830DEA54: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x830DEA58; continue 'dispatch;
            }
            0x830DEA58 => {
    //   block [0x830DEA58..0x830DEA68)
	// 830DEA58: 2F13001C  cmpwi cr6, r19, 0x1c
	ctx.cr[6].compare_i32(ctx.r[19].s32, 28, &mut ctx.xer);
	// 830DEA5C: 409A000C  bne cr6, 0x830dea68
	if !ctx.cr[6].eq {
	pc = 0x830DEA68; continue 'dispatch;
	}
	// 830DEA60: 7F0B0E70  srawi r11, r24, 1
	ctx.xer.ca = (ctx.r[24].s32 < 0) && ((ctx.r[24].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[24].s32 >> 1) as i64;
	// 830DEA64: 7F0B0194  addze r24, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[24].s64 = tmp.s64;
	pc = 0x830DEA68; continue 'dispatch;
            }
            0x830DEA68 => {
    //   block [0x830DEA68..0x830DEA98)
	// 830DEA68: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830DEA6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830DEA70: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830DEA74: 48001705  bl 0x830e0178
	ctx.lr = 0x830DEA78;
	sub_830E0178(ctx, base);
	// 830DEA78: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DEA7C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 830DEA80: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DEA84: 394A000F  addi r10, r10, 0xf
	ctx.r[10].s64 = ctx.r[10].s64 + 15;
	// 830DEA88: 554A0036  rlwinm r10, r10, 0, 0, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830DEA8C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830DEA90: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830DEA94: 4BBCA9A0  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DEA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DEA98 size=5088
    let mut pc: u32 = 0x830DEA98;
    'dispatch: loop {
        match pc {
            0x830DEA98 => {
    //   block [0x830DEA98..0x830DEB04)
	// 830DEA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DEA9C: 4BBCA935  bl 0x82ca93d0
	ctx.lr = 0x830DEAA0;
	sub_82CA93D0(ctx, base);
	// 830DEAA0: 9421FD90  stwu r1, -0x270(r1)
	ea = ctx.r[1].u32.wrapping_add(-624 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DEAA4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 830DEAA8: 90610284  stw r3, 0x284(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(644 as u32), ctx.r[3].u32 ) };
	// 830DEAAC: 7CF13B78  mr r17, r7
	ctx.r[17].u64 = ctx.r[7].u64;
	// 830DEAB0: 7D104378  mr r16, r8
	ctx.r[16].u64 = ctx.r[8].u64;
	// 830DEAB4: 7C8E2378  mr r14, r4
	ctx.r[14].u64 = ctx.r[4].u64;
	// 830DEAB8: 7CB32B78  mr r19, r5
	ctx.r[19].u64 = ctx.r[5].u64;
	// 830DEABC: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830DEAC0: 93E1029C  stw r31, 0x29c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(668 as u32), ctx.r[31].u32 ) };
	// 830DEAC4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830DEAC8: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 830DEACC: 7D324B78  mr r18, r9
	ctx.r[18].u64 = ctx.r[9].u64;
	// 830DEAD0: 4BFFDC29  bl 0x830dc6f8
	ctx.lr = 0x830DEAD4;
	sub_830DC6F8(ctx, base);
	// 830DEAD4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DEAD8: 409A1344  bne cr6, 0x830dfe1c
	if !ctx.cr[6].eq {
	pc = 0x830DFE1C; continue 'dispatch;
	}
	// 830DEADC: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830DEAE0: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 830DEAE4: 396B7634  addi r11, r11, 0x7634
	ctx.r[11].s64 = ctx.r[11].s64 + 30260;
	// 830DEAE8: 91610128  stw r11, 0x128(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 830DEAEC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DEAF0: 396BA580  addi r11, r11, -0x5a80
	ctx.r[11].s64 = ctx.r[11].s64 + -23168;
	// 830DEAF4: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 830DEAF8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 830DEAFC: 396B86B4  addi r11, r11, -0x794c
	ctx.r[11].s64 = ctx.r[11].s64 + -31052;
	// 830DEB00: 91610124  stw r11, 0x124(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	pc = 0x830DEB04; continue 'dispatch;
            }
            0x830DEB04 => {
    //   block [0x830DEB04..0x830DEB7C)
	// 830DEB04: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830DEB08: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DEB0C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830DEB10: 409A12B0  bne cr6, 0x830dfdc0
	if !ctx.cr[6].eq {
	pc = 0x830DFDC0; continue 'dispatch;
	}
	// 830DEB14: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830DEB18: 80810124  lwz r4, 0x124(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 830DEB1C: 7C6F1B78  mr r15, r3
	ctx.r[15].u64 = ctx.r[3].u64;
	// 830DEB20: 4BFFD071  bl 0x830dbb90
	ctx.lr = 0x830DEB24;
	sub_830DBB90(ctx, base);
	// 830DEB24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830DEB28: 80610284  lwz r3, 0x284(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(644 as u32) ) } as u64;
	// 830DEB2C: 4BC76EED  bl 0x82d55a18
	ctx.lr = 0x830DEB30;
	sub_82D55A18(ctx, base);
	// 830DEB30: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 830DEB34: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 830DEB38: 409A0044  bne cr6, 0x830deb7c
	if !ctx.cr[6].eq {
	pc = 0x830DEB7C; continue 'dispatch;
	}
	// 830DEB3C: 3D60830E  lis r11, -0x7cf2
	ctx.r[11].s64 = -2096234496;
	// 830DEB40: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 830DEB44: 396BDA88  addi r11, r11, -0x2578
	ctx.r[11].s64 = ctx.r[11].s64 + -9592;
	// 830DEB48: 386101B4  addi r3, r1, 0x1b4
	ctx.r[3].s64 = ctx.r[1].s64 + 436;
	// 830DEB4C: 916101B0  stw r11, 0x1b0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), ctx.r[11].u32 ) };
	// 830DEB50: 48139089  bl 0x83217bd8
	ctx.lr = 0x830DEB54;
	sub_83217BD8(ctx, base);
	// 830DEB54: 7E068378  mr r6, r16
	ctx.r[6].u64 = ctx.r[16].u64;
	// 830DEB58: 38A101B0  addi r5, r1, 0x1b0
	ctx.r[5].s64 = ctx.r[1].s64 + 432;
	// 830DEB5C: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 830DEB60: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 830DEB64: 4BFFE51D  bl 0x830dd080
	ctx.lr = 0x830DEB68;
	sub_830DD080(ctx, base);
	// 830DEB68: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 830DEB6C: 4BFFE79D  bl 0x830dd308
	ctx.lr = 0x830DEB70;
	sub_830DD308(ctx, base);
	// 830DEB70: 386101B4  addi r3, r1, 0x1b4
	ctx.r[3].s64 = ctx.r[1].s64 + 436;
	// 830DEB74: 4813907D  bl 0x83217bf0
	ctx.lr = 0x830DEB78;
	sub_83217BF0(ctx, base);
	// 830DEB78: 4800128C  b 0x830dfe04
	pc = 0x830DFE04; continue 'dispatch;
            }
            0x830DEB7C => {
    //   block [0x830DEB7C..0x830DEC20)
	// 830DEB7C: 8957000C  lbz r10, 0xc(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DEB80: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 830DEB84: 2B0B001E  cmplwi cr6, r11, 0x1e
	ctx.cr[6].compare_u32(ctx.r[11].u32, 30 as u32, &mut ctx.xer);
	// 830DEB88: 419911C4  bgt cr6, 0x830dfd4c
	if ctx.cr[6].gt {
	pc = 0x830DFD4C; continue 'dispatch;
	}
	// 830DEB8C: 3D80830E  lis r12, -0x7cf2
	ctx.r[12].s64 = -2096234496;
	// 830DEB90: 398CEBA4  addi r12, r12, -0x145c
	ctx.r[12].s64 = ctx.r[12].s64 + -5212;
	// 830DEB94: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 830DEB98: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 830DEB9C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 830DEBA0: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		1 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		2 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		3 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		4 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		5 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		6 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		7 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		8 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		9 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		10 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		11 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		12 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		13 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		14 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		15 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		16 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		17 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		18 => {
	pc = 0x830DFD4C; continue 'dispatch;
		},
		19 => {
	pc = 0x830DED28; continue 'dispatch;
		},
		20 => {
	pc = 0x830DED28; continue 'dispatch;
		},
		21 => {
	pc = 0x830DEFC4; continue 'dispatch;
		},
		22 => {
	pc = 0x830DEFC4; continue 'dispatch;
		},
		23 => {
	pc = 0x830DF310; continue 'dispatch;
		},
		24 => {
	pc = 0x830DF384; continue 'dispatch;
		},
		25 => {
	pc = 0x830DEFC4; continue 'dispatch;
		},
		26 => {
	pc = 0x830DF478; continue 'dispatch;
		},
		27 => {
	pc = 0x830DF9C8; continue 'dispatch;
		},
		28 => {
	pc = 0x830DECE0; continue 'dispatch;
		},
		29 => {
	pc = 0x830DEC20; continue 'dispatch;
		},
		30 => {
	pc = 0x830DFBD0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 830DEBA4: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEBA8: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEBAC: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEBB0: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEBB4: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEBB8: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEBBC: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEBC0: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEBC4: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEBC8: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEBCC: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEBD0: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEBD4: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEBD8: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEBDC: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEBE0: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEBE4: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEBE8: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEBEC: 830DFD4C  lwz r24, -0x2b4(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-692 as u32) ) } as u64;
	// 830DEBF0: 830DED28  lwz r24, -0x12d8(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-4824 as u32) ) } as u64;
	// 830DEBF4: 830DED28  lwz r24, -0x12d8(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-4824 as u32) ) } as u64;
	// 830DEBF8: 830DEFC4  lwz r24, -0x103c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-4156 as u32) ) } as u64;
	// 830DEBFC: 830DEFC4  lwz r24, -0x103c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-4156 as u32) ) } as u64;
	// 830DEC00: 830DF310  lwz r24, -0xcf0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-3312 as u32) ) } as u64;
	// 830DEC04: 830DF384  lwz r24, -0xc7c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-3196 as u32) ) } as u64;
	// 830DEC08: 830DEFC4  lwz r24, -0x103c(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-4156 as u32) ) } as u64;
	// 830DEC0C: 830DF478  lwz r24, -0xb88(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-2952 as u32) ) } as u64;
	// 830DEC10: 830DF9C8  lwz r24, -0x638(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-1592 as u32) ) } as u64;
	// 830DEC14: 830DECE0  lwz r24, -0x1320(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-4896 as u32) ) } as u64;
	// 830DEC18: 830DEC20  lwz r24, -0x13e0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-5088 as u32) ) } as u64;
	// 830DEC1C: 830DFBD0  lwz r24, -0x430(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(-1072 as u32) ) } as u64;
            }
            0x830DEC20 => {
    //   block [0x830DEC20..0x830DEC78)
	// 830DEC20: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830DEC24: 7DE67B78  mr r6, r15
	ctx.r[6].u64 = ctx.r[15].u64;
	// 830DEC28: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830DEC2C: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 830DEC30: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 830DEC34: 4BFFF995  bl 0x830de5c8
	ctx.lr = 0x830DEC38;
	sub_830DE5C8(ctx, base);
	// 830DEC38: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 830DEC3C: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 830DEC40: 80810130  lwz r4, 0x130(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(304 as u32) ) } as u64;
	// 830DEC44: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 830DEC48: 48138701  bl 0x83217348
	ctx.lr = 0x830DEC4C;
	sub_83217348(ctx, base);
	// 830DEC4C: 81530000  lwz r10, 0(r19)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DEC50: A1770012  lhz r11, 0x12(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[23].u32.wrapping_add(18 as u32) ) } as u64;
	// 830DEC54: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 830DEC58: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DEC5C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830DEC60: 7FCB7214  add r30, r11, r14
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[14].u64;
	// 830DEC64: 4BC7E10D  bl 0x82d5cd70
	ctx.lr = 0x830DEC68;
	sub_82D5CD70(ctx, base);
	// 830DEC68: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DEC6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830DEC70: 409A0008  bne cr6, 0x830dec78
	if !ctx.cr[6].eq {
	pc = 0x830DEC78; continue 'dispatch;
	}
	// 830DEC74: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	pc = 0x830DEC78; continue 'dispatch;
            }
            0x830DEC78 => {
    //   block [0x830DEC78..0x830DECA0)
	// 830DEC78: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 830DEC7C: 4BC7E125  bl 0x82d5cda0
	ctx.lr = 0x830DEC80;
	sub_82D5CDA0(ctx, base);
	// 830DEC80: 546B083E  rotlwi r11, r3, 1
	ctx.r[11].u64 = ((ctx.r[3].u32).rotate_left(1)) as u64;
	// 830DEC84: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830DEC88: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830DEC8C: 7FA3FBD6  divw r29, r3, r31
	ctx.r[29].s32 = ctx.r[3].s32 / ctx.r[31].s32;
	// 830DEC90: 7FEB5878  andc r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 & !ctx.r[11].u64;
	// 830DEC94: 0CDF0000  twi 6, r31, 0
	// 830DEC98: 0CABFFFF  twi 5, r11, -1
	// 830DEC9C: 40990024  ble cr6, 0x830decc0
	if !ctx.cr[6].gt {
	pc = 0x830DECC0; continue 'dispatch;
	}
	pc = 0x830DECA0; continue 'dispatch;
            }
            0x830DECA0 => {
    //   block [0x830DECA0..0x830DECC0)
	// 830DECA0: 38A101C0  addi r5, r1, 0x1c0
	ctx.r[5].s64 = ctx.r[1].s64 + 448;
	// 830DECA4: 8877000C  lbz r3, 0xc(r23)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DECA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830DECAC: 4BFFF295  bl 0x830ddf40
	ctx.lr = 0x830DECB0;
	sub_830DDF40(ctx, base);
	// 830DECB0: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 830DECB4: 7FDDF214  add r30, r29, r30
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 830DECB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830DECBC: 409AFFE4  bne cr6, 0x830deca0
	if !ctx.cr[6].eq {
	pc = 0x830DECA0; continue 'dispatch;
	}
	pc = 0x830DECC0; continue 'dispatch;
            }
            0x830DECC0 => {
    //   block [0x830DECC0..0x830DECE0)
	// 830DECC0: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 830DECC4: 481386F5  bl 0x832173b8
	ctx.lr = 0x830DECC8;
	sub_832173B8(ctx, base);
	// 830DECC8: 81610138  lwz r11, 0x138(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(312 as u32) ) } as u64;
	// 830DECCC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DECD0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DECD4: 409A1078  bne cr6, 0x830dfd4c
	if !ctx.cr[6].eq {
	pc = 0x830DFD4C; continue 'dispatch;
	}
	// 830DECD8: 80810130  lwz r4, 0x130(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(304 as u32) ) } as u64;
	// 830DECDC: 48001058  b 0x830dfd34
	pc = 0x830DFD34; continue 'dispatch;
            }
            0x830DECE0 => {
    //   block [0x830DECE0..0x830DED28)
	// 830DECE0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830DECE4: 7DE67B78  mr r6, r15
	ctx.r[6].u64 = ctx.r[15].u64;
	// 830DECE8: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830DECEC: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 830DECF0: 38610168  addi r3, r1, 0x168
	ctx.r[3].s64 = ctx.r[1].s64 + 360;
	// 830DECF4: 4BFFF8D5  bl 0x830de5c8
	ctx.lr = 0x830DECF8;
	sub_830DE5C8(ctx, base);
	// 830DECF8: A1770012  lhz r11, 0x12(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[23].u32.wrapping_add(18 as u32) ) } as u64;
	// 830DECFC: 7E469378  mr r6, r18
	ctx.r[6].u64 = ctx.r[18].u64;
	// 830DED00: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 830DED04: 38810168  addi r4, r1, 0x168
	ctx.r[4].s64 = ctx.r[1].s64 + 360;
	// 830DED08: 7C6B7214  add r3, r11, r14
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[14].u64;
	// 830DED0C: 4BFFF7DD  bl 0x830de4e8
	ctx.lr = 0x830DED10;
	sub_830DE4E8(ctx, base);
	// 830DED10: 81610170  lwz r11, 0x170(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) } as u64;
	// 830DED14: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DED18: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DED1C: 409A1030  bne cr6, 0x830dfd4c
	if !ctx.cr[6].eq {
	pc = 0x830DFD4C; continue 'dispatch;
	}
	// 830DED20: 80810168  lwz r4, 0x168(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(360 as u32) ) } as u64;
	// 830DED24: 48001010  b 0x830dfd34
	pc = 0x830DFD34; continue 'dispatch;
            }
            0x830DED28 => {
    //   block [0x830DED28..0x830DED84)
	// 830DED28: 2B0A0014  cmplwi cr6, r10, 0x14
	ctx.cr[6].compare_u32(ctx.r[10].u32, 20 as u32, &mut ctx.xer);
	// 830DED2C: 409A0058  bne cr6, 0x830ded84
	if !ctx.cr[6].eq {
	pc = 0x830DED84; continue 'dispatch;
	}
	// 830DED30: 8977000D  lbz r11, 0xd(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(13 as u32) ) } as u64;
	// 830DED34: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830DED38: 409A004C  bne cr6, 0x830ded84
	if !ctx.cr[6].eq {
	pc = 0x830DED84; continue 'dispatch;
	}
	// 830DED3C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830DED40: 7DE67B78  mr r6, r15
	ctx.r[6].u64 = ctx.r[15].u64;
	// 830DED44: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830DED48: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 830DED4C: 38610188  addi r3, r1, 0x188
	ctx.r[3].s64 = ctx.r[1].s64 + 392;
	// 830DED50: 4BFFF879  bl 0x830de5c8
	ctx.lr = 0x830DED54;
	sub_830DE5C8(ctx, base);
	// 830DED54: A1770012  lhz r11, 0x12(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[23].u32.wrapping_add(18 as u32) ) } as u64;
	// 830DED58: 7E469378  mr r6, r18
	ctx.r[6].u64 = ctx.r[18].u64;
	// 830DED5C: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 830DED60: 38810188  addi r4, r1, 0x188
	ctx.r[4].s64 = ctx.r[1].s64 + 392;
	// 830DED64: 7C6B7214  add r3, r11, r14
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[14].u64;
	// 830DED68: 4BFFF781  bl 0x830de4e8
	ctx.lr = 0x830DED6C;
	sub_830DE4E8(ctx, base);
	// 830DED6C: 81610190  lwz r11, 0x190(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) } as u64;
	// 830DED70: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DED74: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DED78: 409A0FD4  bne cr6, 0x830dfd4c
	if !ctx.cr[6].eq {
	pc = 0x830DFD4C; continue 'dispatch;
	}
	// 830DED7C: 80810188  lwz r4, 0x188(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) } as u64;
	// 830DED80: 48000FB4  b 0x830dfd34
	pc = 0x830DFD34; continue 'dispatch;
            }
            0x830DED84 => {
    //   block [0x830DED84..0x830DEDB8)
	// 830DED84: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830DED88: 7DE67B78  mr r6, r15
	ctx.r[6].u64 = ctx.r[15].u64;
	// 830DED8C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830DED90: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 830DED94: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 830DED98: 4BFFF831  bl 0x830de5c8
	ctx.lr = 0x830DED9C;
	sub_830DE5C8(ctx, base);
	// 830DED9C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 830DEDA0: 7E98A378  mr r24, r20
	ctx.r[24].u64 = ctx.r[20].u64;
	// 830DEDA4: 4BC7DFCD  bl 0x82d5cd70
	ctx.lr = 0x830DEDA8;
	sub_82D5CD70(ctx, base);
	// 830DEDA8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DEDAC: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 830DEDB0: 409A0008  bne cr6, 0x830dedb8
	if !ctx.cr[6].eq {
	pc = 0x830DEDB8; continue 'dispatch;
	}
	// 830DEDB4: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	pc = 0x830DEDB8; continue 'dispatch;
            }
            0x830DEDB8 => {
    //   block [0x830DEDB8..0x830DEDF4)
	// 830DEDB8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 830DEDBC: 4BC7DFE5  bl 0x82d5cda0
	ctx.lr = 0x830DEDC0;
	sub_82D5CDA0(ctx, base);
	// 830DEDC0: 546A083E  rotlwi r10, r3, 1
	ctx.r[10].u64 = ((ctx.r[3].u32).rotate_left(1)) as u64;
	// 830DEDC4: A1770012  lhz r11, 0x12(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[23].u32.wrapping_add(18 as u32) ) } as u64;
	// 830DEDC8: 7E9BA378  mr r27, r20
	ctx.r[27].u64 = ctx.r[20].u64;
	// 830DEDCC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830DEDD0: 7EAB7214  add r21, r11, r14
	ctx.r[21].u64 = ctx.r[11].u64 + ctx.r[14].u64;
	// 830DEDD4: 7ECB5078  andc r11, r22, r10
	ctx.r[11].u64 = ctx.r[22].u64 & !ctx.r[10].u64;
	// 830DEDD8: 7EE3B3D6  divw r23, r3, r22
	ctx.r[23].s32 = ctx.r[3].s32 / ctx.r[22].s32;
	// 830DEDDC: 0CD60000  twi 6, r22, 0
	// 830DEDE0: 7E9AA378  mr r26, r20
	ctx.r[26].u64 = ctx.r[20].u64;
	// 830DEDE4: 0CABFFFF  twi 5, r11, -1
	// 830DEDE8: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 830DEDEC: 40990190  ble cr6, 0x830def7c
	if !ctx.cr[6].gt {
	pc = 0x830DEF7C; continue 'dispatch;
	}
	// 830DEDF0: 7EB9AB78  mr r25, r21
	ctx.r[25].u64 = ctx.r[21].u64;
	pc = 0x830DEDF4; continue 'dispatch;
            }
            0x830DEDF4 => {
    //   block [0x830DEDF4..0x830DEE34)
	// 830DEDF4: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 830DEDF8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830DEDFC: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DEE00: 4098017C  bge cr6, 0x830def7c
	if !ctx.cr[6].lt {
	pc = 0x830DEF7C; continue 'dispatch;
	}
	// 830DEE04: 816100B8  lwz r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 830DEE08: 7D6BD0AE  lbzx r11, r11, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 830DEE0C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DEE10: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 830DEE14: 419A0020  beq cr6, 0x830dee34
	if ctx.cr[6].eq {
	pc = 0x830DEE34; continue 'dispatch;
	}
	// 830DEE18: 2F0B0009  cmpwi cr6, r11, 9
	ctx.cr[6].compare_i32(ctx.r[11].s32, 9, &mut ctx.xer);
	// 830DEE1C: 419A0018  beq cr6, 0x830dee34
	if ctx.cr[6].eq {
	pc = 0x830DEE34; continue 'dispatch;
	}
	// 830DEE20: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 830DEE24: 419A0010  beq cr6, 0x830dee34
	if ctx.cr[6].eq {
	pc = 0x830DEE34; continue 'dispatch;
	}
	// 830DEE28: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 830DEE2C: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 830DEE30: 409A0008  bne cr6, 0x830dee38
	if !ctx.cr[6].eq {
	pc = 0x830DEE38; continue 'dispatch;
	}
	pc = 0x830DEE34; continue 'dispatch;
            }
            0x830DEE34 => {
    //   block [0x830DEE34..0x830DEE38)
	// 830DEE34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830DEE38; continue 'dispatch;
            }
            0x830DEE38 => {
    //   block [0x830DEE38..0x830DEE94)
	// 830DEE38: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DEE3C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DEE40: 419A0130  beq cr6, 0x830def70
	if ctx.cr[6].eq {
	pc = 0x830DEF70; continue 'dispatch;
	}
	// 830DEE44: 7F1BD000  cmpw cr6, r27, r26
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[26].s32, &mut ctx.xer);
	// 830DEE48: 419A0124  beq cr6, 0x830def6c
	if ctx.cr[6].eq {
	pc = 0x830DEF6C; continue 'dispatch;
	}
	// 830DEE4C: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 830DEE50: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DEE54: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 830DEE58: 92810080  stw r20, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[20].u32 ) };
	// 830DEE5C: 7FDBD050  subf r30, r27, r26
	ctx.r[30].s64 = ctx.r[26].s64 - ctx.r[27].s64;
	// 830DEE60: 92810084  stw r20, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[20].u32 ) };
	// 830DEE64: 3BFE0001  addi r31, r30, 1
	ctx.r[31].s64 = ctx.r[30].s64 + 1;
	// 830DEE68: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 830DEE6C: 7D7DE02E  lwzx r11, r29, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830DEE70: 395F0010  addi r10, r31, 0x10
	ctx.r[10].s64 = ctx.r[31].s64 + 16;
	// 830DEE74: 55440036  rlwinm r4, r10, 0, 0, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830DEE78: 806B0020  lwz r3, 0x20(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830DEE7C: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 830DEE80: 7D432214  add r10, r3, r4
	ctx.r[10].u64 = ctx.r[3].u64 + ctx.r[4].u64;
	// 830DEE84: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830DEE88: 4199000C  bgt cr6, 0x830dee94
	if ctx.cr[6].gt {
	pc = 0x830DEE94; continue 'dispatch;
	}
	// 830DEE8C: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830DEE90: 48000018  b 0x830deea8
	pc = 0x830DEEA8; continue 'dispatch;
            }
            0x830DEE94 => {
    //   block [0x830DEE94..0x830DEEA8)
	// 830DEE94: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DEE98: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830DEE9C: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 830DEEA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DEEA4: 4E800421  bctrl
	ctx.lr = 0x830DEEA8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DEEA8 => {
    //   block [0x830DEEA8..0x830DEEE8)
	// 830DEEA8: 816100B8  lwz r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 830DEEAC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830DEEB0: 90610080  stw r3, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 830DEEB4: 7C8BDA14  add r4, r11, r27
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830DEEB8: 9061008C  stw r3, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 830DEEBC: 67EB8000  oris r11, r31, 0x8000
	ctx.r[11].u64 = ctx.r[31].u64 | 2147483648;
	// 830DEEC0: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 830DEEC4: 4BC79E6D  bl 0x82d58d30
	ctx.lr = 0x830DEEC8;
	sub_82D58D30(ctx, base);
	// 830DEEC8: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830DEECC: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DEED0: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830DEED4: 40980024  bge cr6, 0x830deef8
	if !ctx.cr[6].lt {
	pc = 0x830DEEF8; continue 'dispatch;
	}
	// 830DEED8: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DEEDC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DEEE0: 41980008  blt cr6, 0x830deee8
	if ctx.cr[6].lt {
	pc = 0x830DEEE8; continue 'dispatch;
	}
	// 830DEEE4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x830DEEE8; continue 'dispatch;
            }
            0x830DEEE8 => {
    //   block [0x830DEEE8..0x830DEEF8)
	// 830DEEE8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DEEEC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830DEEF0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830DEEF4: 4BC7801D  bl 0x82d56f10
	ctx.lr = 0x830DEEF8;
	sub_82D56F10(ctx, base);
	pc = 0x830DEEF8; continue 'dispatch;
            }
            0x830DEEF8 => {
    //   block [0x830DEEF8..0x830DEF48)
	// 830DEEF8: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 830DEEFC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830DEF00: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 830DEF04: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 830DEF08: 7D7B5850  subf r11, r27, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 830DEF0C: 7E8BD1AE  stbx r20, r11, r26
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32), ctx.r[20].u8) };
	// 830DEF10: 80A10080  lwz r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 830DEF14: 4BC9681D  bl 0x82d75730
	ctx.lr = 0x830DEF18;
	sub_82D75730(ctx, base);
	// 830DEF18: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830DEF1C: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 830DEF20: 8081008C  lwz r4, 0x8c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 830DEF24: 7F39BA14  add r25, r25, r23
	ctx.r[25].u64 = ctx.r[25].u64 + ctx.r[23].u64;
	// 830DEF28: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830DEF2C: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 830DEF30: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830DEF34: 409A0014  bne cr6, 0x830def48
	if !ctx.cr[6].eq {
	pc = 0x830DEF48; continue 'dispatch;
	}
	// 830DEF38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DEF3C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830DEF40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DEF44: 4E800421  bctrl
	ctx.lr = 0x830DEF48;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DEF48 => {
    //   block [0x830DEF48..0x830DEF6C)
	// 830DEF48: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830DEF4C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DEF50: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DEF54: 409A0018  bne cr6, 0x830def6c
	if !ctx.cr[6].eq {
	pc = 0x830DEF6C; continue 'dispatch;
	}
	// 830DEF58: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DEF5C: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830DEF60: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DEF64: 80810080  lwz r4, 0x80(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 830DEF68: 4BC76361  bl 0x82d552c8
	ctx.lr = 0x830DEF6C;
	sub_82D552C8(ctx, base);
	pc = 0x830DEF6C; continue 'dispatch;
            }
            0x830DEF6C => {
    //   block [0x830DEF6C..0x830DEF70)
	// 830DEF6C: 3B7A0001  addi r27, r26, 1
	ctx.r[27].s64 = ctx.r[26].s64 + 1;
	pc = 0x830DEF70; continue 'dispatch;
            }
            0x830DEF70 => {
    //   block [0x830DEF70..0x830DEF7C)
	// 830DEF70: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 830DEF74: 7F18B000  cmpw cr6, r24, r22
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[22].s32, &mut ctx.xer);
	// 830DEF78: 4198FE7C  blt cr6, 0x830dedf4
	if ctx.cr[6].lt {
	pc = 0x830DEDF4; continue 'dispatch;
	}
	pc = 0x830DEF7C; continue 'dispatch;
            }
            0x830DEF7C => {
    //   block [0x830DEF7C..0x830DEFAC)
	// 830DEF7C: 816100BC  lwz r11, 0xbc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 830DEF80: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830DEF84: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DEF88: 419A0024  beq cr6, 0x830defac
	if ctx.cr[6].eq {
	pc = 0x830DEFAC; continue 'dispatch;
	}
	// 830DEF8C: 7F18B000  cmpw cr6, r24, r22
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[22].s32, &mut ctx.xer);
	// 830DEF90: 4098001C  bge cr6, 0x830defac
	if !ctx.cr[6].lt {
	pc = 0x830DEFAC; continue 'dispatch;
	}
	// 830DEF94: 7D77C1D6  mullw r11, r23, r24
	ctx.r[11].s32 = ((ctx.r[23].s32 as i64 * ctx.r[24].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 830DEF98: 7C8BAA14  add r4, r11, r21
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[21].u64;
	// 830DEF9C: 816100B8  lwz r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 830DEFA0: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 830DEFA4: 7CABDA14  add r5, r11, r27
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830DEFA8: 4BC96789  bl 0x82d75730
	ctx.lr = 0x830DEFAC;
	sub_82D75730(ctx, base);
	pc = 0x830DEFAC; continue 'dispatch;
            }
            0x830DEFAC => {
    //   block [0x830DEFAC..0x830DEFC4)
	// 830DEFAC: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 830DEFB0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DEFB4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DEFB8: 409A0D94  bne cr6, 0x830dfd4c
	if !ctx.cr[6].eq {
	pc = 0x830DFD4C; continue 'dispatch;
	}
	// 830DEFBC: 808100B8  lwz r4, 0xb8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 830DEFC0: 48000D74  b 0x830dfd34
	pc = 0x830DFD34; continue 'dispatch;
            }
            0x830DEFC4 => {
    //   block [0x830DEFC4..0x830DF058)
	// 830DEFC4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DEFC8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830DEFCC: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 830DEFD0: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 830DEFD4: 480011A5  bl 0x830e0178
	ctx.lr = 0x830DEFD8;
	sub_830E0178(ctx, base);
	// 830DEFD8: 8977000D  lbz r11, 0xd(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(13 as u32) ) } as u64;
	// 830DEFDC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830DEFE0: 2B0B0019  cmplwi cr6, r11, 0x19
	ctx.cr[6].compare_u32(ctx.r[11].u32, 25 as u32, &mut ctx.xer);
	// 830DEFE4: 409A0108  bne cr6, 0x830df0ec
	if !ctx.cr[6].eq {
	pc = 0x830DF0EC; continue 'dispatch;
	}
	// 830DEFE8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830DEFEC: 8081006C  lwz r4, 0x6c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830DEFF0: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 830DEFF4: 4BFFCB9D  bl 0x830dbb90
	ctx.lr = 0x830DEFF8;
	sub_830DBB90(ctx, base);
	// 830DEFF8: 4BC79C59  bl 0x82d58c50
	ctx.lr = 0x830DEFFC;
	sub_82D58C50(ctx, base);
	// 830DEFFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DF000: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 830DF004: 4BC7DD5D  bl 0x82d5cd60
	ctx.lr = 0x830DF008;
	sub_82D5CD60(ctx, base);
	// 830DF008: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830DF00C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830DF010: 419A00C0  beq cr6, 0x830df0d0
	if ctx.cr[6].eq {
	pc = 0x830DF0D0; continue 'dispatch;
	}
	// 830DF014: 4BC76ACD  bl 0x82d55ae0
	ctx.lr = 0x830DF018;
	sub_82D55AE0(ctx, base);
	// 830DF018: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830DF01C: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830DF020: 7FFBF1D6  mullw r31, r27, r30
	ctx.r[31].s32 = ((ctx.r[27].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[31].s64 = ctx.r[31].s32 as i64;
	// 830DF024: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 830DF028: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DF02C: 4800114D  bl 0x830e0178
	ctx.lr = 0x830DF030;
	sub_830E0178(ctx, base);
	// 830DF030: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF034: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830DF038: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF03C: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 830DF040: 394A000F  addi r10, r10, 0xf
	ctx.r[10].s64 = ctx.r[10].s64 + 15;
	// 830DF044: 554A0036  rlwinm r10, r10, 0, 0, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830DF048: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830DF04C: 40990274  ble cr6, 0x830df2c0
	if !ctx.cr[6].gt {
	pc = 0x830DF2C0; continue 'dispatch;
	}
	// 830DF050: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 830DF054: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	pc = 0x830DF058; continue 'dispatch;
            }
            0x830DF058 => {
    //   block [0x830DF058..0x830DF080)
	// 830DF058: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830DF05C: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 830DF060: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830DF064: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 830DF068: 4BFFD691  bl 0x830dc6f8
	ctx.lr = 0x830DF06C;
	sub_830DC6F8(ctx, base);
	// 830DF06C: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DF070: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DF074: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830DF078: 419A0008  beq cr6, 0x830df080
	if ctx.cr[6].eq {
	pc = 0x830DF080; continue 'dispatch;
	}
	// 830DF07C: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	pc = 0x830DF080; continue 'dispatch;
            }
            0x830DF080 => {
    //   block [0x830DF080..0x830DF0BC)
	// 830DF080: 7E499378  mr r9, r18
	ctx.r[9].u64 = ctx.r[18].u64;
	// 830DF084: 7E088378  mr r8, r16
	ctx.r[8].u64 = ctx.r[16].u64;
	// 830DF088: 7E278B78  mr r7, r17
	ctx.r[7].u64 = ctx.r[17].u64;
	// 830DF08C: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 830DF090: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DF094: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DF098: 4BFFFA01  bl 0x830dea98
	ctx.lr = 0x830DF09C;
	sub_830DEA98(ctx, base);
	// 830DF09C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DF0A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DF0A4: 419A0018  beq cr6, 0x830df0bc
	if ctx.cr[6].eq {
	pc = 0x830DF0BC; continue 'dispatch;
	}
	// 830DF0A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF0AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DF0B0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF0B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DF0B8: 4E800421  bctrl
	ctx.lr = 0x830DF0BC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DF0BC => {
    //   block [0x830DF0BC..0x830DF0D0)
	// 830DF0BC: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 830DF0C0: 7FFFDA14  add r31, r31, r27
	ctx.r[31].u64 = ctx.r[31].u64 + ctx.r[27].u64;
	// 830DF0C4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830DF0C8: 409AFF90  bne cr6, 0x830df058
	if !ctx.cr[6].eq {
	pc = 0x830DF058; continue 'dispatch;
	}
	// 830DF0CC: 480001F4  b 0x830df2c0
	pc = 0x830DF2C0; continue 'dispatch;
            }
            0x830DF0D0 => {
    //   block [0x830DF0D0..0x830DF0EC)
	// 830DF0D0: 7E078378  mr r7, r16
	ctx.r[7].u64 = ctx.r[16].u64;
	// 830DF0D4: 80610284  lwz r3, 0x284(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(644 as u32) ) } as u64;
	// 830DF0D8: 7DE67B78  mr r6, r15
	ctx.r[6].u64 = ctx.r[15].u64;
	// 830DF0DC: 7E258B78  mr r5, r17
	ctx.r[5].u64 = ctx.r[17].u64;
	// 830DF0E0: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 830DF0E4: 4BFFE9CD  bl 0x830ddab0
	ctx.lr = 0x830DF0E8;
	sub_830DDAB0(ctx, base);
	// 830DF0E8: 480001D8  b 0x830df2c0
	pc = 0x830DF2C0; continue 'dispatch;
            }
            0x830DF0EC => {
    //   block [0x830DF0EC..0x830DF160)
	// 830DF0EC: 2B0B0018  cmplwi cr6, r11, 0x18
	ctx.cr[6].compare_u32(ctx.r[11].u32, 24 as u32, &mut ctx.xer);
	// 830DF0F0: 419A01D0  beq cr6, 0x830df2c0
	if ctx.cr[6].eq {
	pc = 0x830DF2C0; continue 'dispatch;
	}
	// 830DF0F4: 2B0B001F  cmplwi cr6, r11, 0x1f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 31 as u32, &mut ctx.xer);
	// 830DF0F8: 419A01C8  beq cr6, 0x830df2c0
	if ctx.cr[6].eq {
	pc = 0x830DF2C0; continue 'dispatch;
	}
	// 830DF0FC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 830DF100: 4BC7DF19  bl 0x82d5d018
	ctx.lr = 0x830DF104;
	sub_82D5D018(ctx, base);
	// 830DF104: 2F03001D  cmpwi cr6, r3, 0x1d
	ctx.cr[6].compare_i32(ctx.r[3].s32, 29, &mut ctx.xer);
	// 830DF108: 409A0128  bne cr6, 0x830df230
	if !ctx.cr[6].eq {
	pc = 0x830DF230; continue 'dispatch;
	}
	// 830DF10C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830DF110: 8081006C  lwz r4, 0x6c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830DF114: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 830DF118: 4BFFCA79  bl 0x830dbb90
	ctx.lr = 0x830DF11C;
	sub_830DBB90(ctx, base);
	// 830DF11C: 4BC79B35  bl 0x82d58c50
	ctx.lr = 0x830DF120;
	sub_82D58C50(ctx, base);
	// 830DF120: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DF124: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830DF128: 57DF103A  slwi r31, r30, 2
	ctx.r[31].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 830DF12C: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 830DF130: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DF134: 48001045  bl 0x830e0178
	ctx.lr = 0x830DF138;
	sub_830E0178(ctx, base);
	// 830DF138: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF13C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830DF140: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF144: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 830DF148: 394A000F  addi r10, r10, 0xf
	ctx.r[10].s64 = ctx.r[10].s64 + 15;
	// 830DF14C: 554A0036  rlwinm r10, r10, 0, 0, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830DF150: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830DF154: 4099016C  ble cr6, 0x830df2c0
	if !ctx.cr[6].gt {
	pc = 0x830DF2C0; continue 'dispatch;
	}
	// 830DF158: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 830DF15C: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x830DF160; continue 'dispatch;
            }
            0x830DF160 => {
    //   block [0x830DF160..0x830DF1C0)
	// 830DF160: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830DF164: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 830DF168: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830DF16C: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 830DF170: 4BFFD589  bl 0x830dc6f8
	ctx.lr = 0x830DF174;
	sub_830DC6F8(ctx, base);
	// 830DF174: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830DF178: 7DE67B78  mr r6, r15
	ctx.r[6].u64 = ctx.r[15].u64;
	// 830DF17C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830DF180: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 830DF184: 38610178  addi r3, r1, 0x178
	ctx.r[3].s64 = ctx.r[1].s64 + 376;
	// 830DF188: 4BFFF441  bl 0x830de5c8
	ctx.lr = 0x830DF18C;
	sub_830DE5C8(ctx, base);
	// 830DF18C: 7E469378  mr r6, r18
	ctx.r[6].u64 = ctx.r[18].u64;
	// 830DF190: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 830DF194: 38810178  addi r4, r1, 0x178
	ctx.r[4].s64 = ctx.r[1].s64 + 376;
	// 830DF198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DF19C: 4BFFF34D  bl 0x830de4e8
	ctx.lr = 0x830DF1A0;
	sub_830DE4E8(ctx, base);
	// 830DF1A0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DF1A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DF1A8: 419A0018  beq cr6, 0x830df1c0
	if ctx.cr[6].eq {
	pc = 0x830DF1C0; continue 'dispatch;
	}
	// 830DF1AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF1B0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DF1B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF1B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DF1BC: 4E800421  bctrl
	ctx.lr = 0x830DF1C0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DF1C0 => {
    //   block [0x830DF1C0..0x830DF1F0)
	// 830DF1C0: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830DF1C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830DF1C8: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 830DF1CC: 4BFFD52D  bl 0x830dc6f8
	ctx.lr = 0x830DF1D0;
	sub_830DC6F8(ctx, base);
	// 830DF1D0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DF1D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DF1D8: 419A0018  beq cr6, 0x830df1f0
	if ctx.cr[6].eq {
	pc = 0x830DF1F0; continue 'dispatch;
	}
	// 830DF1DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF1E0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DF1E4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF1E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DF1EC: 4E800421  bctrl
	ctx.lr = 0x830DF1F0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DF1F0 => {
    //   block [0x830DF1F0..0x830DF21C)
	// 830DF1F0: 81610180  lwz r11, 0x180(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(384 as u32) ) } as u64;
	// 830DF1F4: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DF1F8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DF1FC: 409A0020  bne cr6, 0x830df21c
	if !ctx.cr[6].eq {
	pc = 0x830DF21C; continue 'dispatch;
	}
	// 830DF200: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF204: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DF208: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DF20C: 80810178  lwz r4, 0x178(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) } as u64;
	// 830DF210: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DF214: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DF218: 4BC760B1  bl 0x82d552c8
	ctx.lr = 0x830DF21C;
	sub_82D552C8(ctx, base);
	pc = 0x830DF21C; continue 'dispatch;
            }
            0x830DF21C => {
    //   block [0x830DF21C..0x830DF230)
	// 830DF21C: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 830DF220: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 830DF224: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830DF228: 409AFF38  bne cr6, 0x830df160
	if !ctx.cr[6].eq {
	pc = 0x830DF160; continue 'dispatch;
	}
	// 830DF22C: 48000094  b 0x830df2c0
	pc = 0x830DF2C0; continue 'dispatch;
            }
            0x830DF230 => {
    //   block [0x830DF230..0x830DF25C)
	// 830DF230: 8977000D  lbz r11, 0xd(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(13 as u32) ) } as u64;
	// 830DF234: 7DE67B78  mr r6, r15
	ctx.r[6].u64 = ctx.r[15].u64;
	// 830DF238: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830DF23C: 409A0020  bne cr6, 0x830df25c
	if !ctx.cr[6].eq {
	pc = 0x830DF25C; continue 'dispatch;
	}
	// 830DF240: 7E078378  mr r7, r16
	ctx.r[7].u64 = ctx.r[16].u64;
	// 830DF244: 80610284  lwz r3, 0x284(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(644 as u32) ) } as u64;
	// 830DF248: 7E258B78  mr r5, r17
	ctx.r[5].u64 = ctx.r[17].u64;
	// 830DF24C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 830DF250: 4BFFE861  bl 0x830ddab0
	ctx.lr = 0x830DF254;
	sub_830DDAB0(ctx, base);
	// 830DF254: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	// 830DF258: 48000068  b 0x830df2c0
	pc = 0x830DF2C0; continue 'dispatch;
            }
            0x830DF25C => {
    //   block [0x830DF25C..0x830DF2C0)
	// 830DF25C: 396BFFE7  addi r11, r11, -0x19
	ctx.r[11].s64 = ctx.r[11].s64 + -25;
	// 830DF260: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830DF264: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830DF268: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 830DF26C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830DF270: 38610198  addi r3, r1, 0x198
	ctx.r[3].s64 = ctx.r[1].s64 + 408;
	// 830DF274: 69670001  xori r7, r11, 1
	ctx.r[7].u64 = ctx.r[11].u64 ^ 1;
	// 830DF278: 4BFFF351  bl 0x830de5c8
	ctx.lr = 0x830DF27C;
	sub_830DE5C8(ctx, base);
	// 830DF27C: 7E469378  mr r6, r18
	ctx.r[6].u64 = ctx.r[18].u64;
	// 830DF280: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 830DF284: 38810198  addi r4, r1, 0x198
	ctx.r[4].s64 = ctx.r[1].s64 + 408;
	// 830DF288: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 830DF28C: 4BFFF465  bl 0x830de6f0
	ctx.lr = 0x830DF290;
	sub_830DE6F0(ctx, base);
	// 830DF290: 816101A0  lwz r11, 0x1a0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(416 as u32) ) } as u64;
	// 830DF294: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DF298: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DF29C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DF2A0: 409A0020  bne cr6, 0x830df2c0
	if !ctx.cr[6].eq {
	pc = 0x830DF2C0; continue 'dispatch;
	}
	// 830DF2A4: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF2A8: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DF2AC: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DF2B0: 80810198  lwz r4, 0x198(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(408 as u32) ) } as u64;
	// 830DF2B4: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DF2B8: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DF2BC: 4BC7600D  bl 0x82d552c8
	ctx.lr = 0x830DF2C0;
	sub_82D552C8(ctx, base);
	pc = 0x830DF2C0; continue 'dispatch;
            }
            0x830DF2C0 => {
    //   block [0x830DF2C0..0x830DF2F8)
	// 830DF2C0: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF2C4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830DF2C8: A1570012  lhz r10, 0x12(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[23].u32.wrapping_add(18 as u32) ) } as u64;
	// 830DF2CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF2D0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830DF2D4: 7FEB7214  add r31, r11, r14
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[14].u64;
	// 830DF2D8: 929F0000  stw r20, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[20].u32 ) };
	// 830DF2DC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830DF2E0: 40990018  ble cr6, 0x830df2f8
	if !ctx.cr[6].gt {
	pc = 0x830DF2F8; continue 'dispatch;
	}
	// 830DF2E4: A1770012  lhz r11, 0x12(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[23].u32.wrapping_add(18 as u32) ) } as u64;
	// 830DF2E8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830DF2EC: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 830DF2F0: 7C8B7214  add r4, r11, r14
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[14].u64;
	// 830DF2F4: 4BC97FCD  bl 0x82d772c0
	ctx.lr = 0x830DF2F8;
	sub_82D772C0(ctx, base);
	pc = 0x830DF2F8; continue 'dispatch;
            }
            0x830DF2F8 => {
    //   block [0x830DF2F8..0x830DF310)
	// 830DF2F8: 8977000C  lbz r11, 0xc(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DF2FC: 2B0B001A  cmplwi cr6, r11, 0x1a
	ctx.cr[6].compare_u32(ctx.r[11].u32, 26 as u32, &mut ctx.xer);
	// 830DF300: 419A0A4C  beq cr6, 0x830dfd4c
	if ctx.cr[6].eq {
	pc = 0x830DFD4C; continue 'dispatch;
	}
	// 830DF304: 67CBC000  oris r11, r30, 0xc000
	ctx.r[11].u64 = ctx.r[30].u64 | 3221225472;
	// 830DF308: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830DF30C: 48000A40  b 0x830dfd4c
	pc = 0x830DFD4C; continue 'dispatch;
            }
            0x830DF310 => {
    //   block [0x830DF310..0x830DF36C)
	// 830DF310: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830DF314: 7DE67B78  mr r6, r15
	ctx.r[6].u64 = ctx.r[15].u64;
	// 830DF318: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830DF31C: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 830DF320: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 830DF324: 4BFFF2A5  bl 0x830de5c8
	ctx.lr = 0x830DF328;
	sub_830DE5C8(ctx, base);
	// 830DF328: 81610144  lwz r11, 0x144(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 830DF32C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DF330: 4182003C  beq 0x830df36c
	if ctx.cr[0].eq {
	pc = 0x830DF36C; continue 'dispatch;
	}
	// 830DF334: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 830DF338: 4BC7DA49  bl 0x82d5cd80
	ctx.lr = 0x830DF33C;
	sub_82D5CD80(ctx, base);
	// 830DF33C: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 830DF340: 80810140  lwz r4, 0x140(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(320 as u32) ) } as u64;
	// 830DF344: 928100A0  stw r20, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[20].u32 ) };
	// 830DF348: 4BC7F211  bl 0x82d5e558
	ctx.lr = 0x830DF34C;
	sub_82D5E558(ctx, base);
	// 830DF34C: 81530000  lwz r10, 0(r19)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF350: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 830DF354: A1770012  lhz r11, 0x12(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[23].u32.wrapping_add(18 as u32) ) } as u64;
	// 830DF358: 80A100A0  lwz r5, 0xa0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 830DF35C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF360: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830DF364: 7C8B7214  add r4, r11, r14
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[14].u64;
	// 830DF368: 4BC7DD81  bl 0x82d5d0e8
	ctx.lr = 0x830DF36C;
	sub_82D5D0E8(ctx, base);
	pc = 0x830DF36C; continue 'dispatch;
            }
            0x830DF36C => {
    //   block [0x830DF36C..0x830DF384)
	// 830DF36C: 81610148  lwz r11, 0x148(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(328 as u32) ) } as u64;
	// 830DF370: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DF374: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DF378: 409A09D4  bne cr6, 0x830dfd4c
	if !ctx.cr[6].eq {
	pc = 0x830DFD4C; continue 'dispatch;
	}
	// 830DF37C: 80810140  lwz r4, 0x140(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(320 as u32) ) } as u64;
	// 830DF380: 480009B4  b 0x830dfd34
	pc = 0x830DFD34; continue 'dispatch;
            }
            0x830DF384 => {
    //   block [0x830DF384..0x830DF388)
	// 830DF384: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	pc = 0x830DF388; continue 'dispatch;
            }
            0x830DF388 => {
    //   block [0x830DF388..0x830DF3A0)
	// 830DF388: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 830DF38C: 4BC7D9E5  bl 0x82d5cd70
	ctx.lr = 0x830DF390;
	sub_82D5CD70(ctx, base);
	// 830DF390: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830DF394: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DF398: 409A0008  bne cr6, 0x830df3a0
	if !ctx.cr[6].eq {
	pc = 0x830DF3A0; continue 'dispatch;
	}
	// 830DF39C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830DF3A0; continue 'dispatch;
            }
            0x830DF3A0 => {
    //   block [0x830DF3A0..0x830DF44C)
	// 830DF3A0: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DF3A4: 409809A8  bge cr6, 0x830dfd4c
	if !ctx.cr[6].lt {
	pc = 0x830DFD4C; continue 'dispatch;
	}
	// 830DF3A8: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830DF3AC: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 830DF3B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830DF3B4: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 830DF3B8: 4BFFD341  bl 0x830dc6f8
	ctx.lr = 0x830DF3BC;
	sub_830DC6F8(ctx, base);
	// 830DF3BC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DF3C0: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DF3C4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830DF3C8: 409A00A4  bne cr6, 0x830df46c
	if !ctx.cr[6].eq {
	pc = 0x830DF46C; continue 'dispatch;
	}
	// 830DF3CC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 830DF3D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830DF3D4: 4BC7D98D  bl 0x82d5cd60
	ctx.lr = 0x830DF3D8;
	sub_82D5CD60(ctx, base);
	// 830DF3D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DF3DC: 419A0070  beq cr6, 0x830df44c
	if ctx.cr[6].eq {
	pc = 0x830DF44C; continue 'dispatch;
	}
	// 830DF3E0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 830DF3E4: A3F70012  lhz r31, 0x12(r23)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[23].u32.wrapping_add(18 as u32) ) } as u64;
	// 830DF3E8: 4BC7D971  bl 0x82d5cd58
	ctx.lr = 0x830DF3EC;
	sub_82D5CD58(ctx, base);
	// 830DF3EC: 4BC766F5  bl 0x82d55ae0
	ctx.lr = 0x830DF3F0;
	sub_82D55AE0(ctx, base);
	// 830DF3F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830DF3F4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 830DF3F8: 7D6BE9D6  mullw r11, r11, r29
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[29].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 830DF3FC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830DF400: 7FEB7214  add r31, r11, r14
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[14].u64;
	// 830DF404: 4BC7D955  bl 0x82d5cd58
	ctx.lr = 0x830DF408;
	sub_82D5CD58(ctx, base);
	// 830DF408: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DF40C: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 830DF410: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830DF414: 7E278B78  mr r7, r17
	ctx.r[7].u64 = ctx.r[17].u64;
	// 830DF418: 7E088378  mr r8, r16
	ctx.r[8].u64 = ctx.r[16].u64;
	// 830DF41C: 7E499378  mr r9, r18
	ctx.r[9].u64 = ctx.r[18].u64;
	// 830DF420: 4BFFF679  bl 0x830dea98
	ctx.lr = 0x830DF424;
	sub_830DEA98(ctx, base);
	// 830DF424: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DF428: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DF42C: 419A0038  beq cr6, 0x830df464
	if ctx.cr[6].eq {
	pc = 0x830DF464; continue 'dispatch;
	}
	// 830DF430: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF434: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DF438: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF43C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DF440: 4E800421  bctrl
	ctx.lr = 0x830DF444;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DF444: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830DF448: 4BFFFF40  b 0x830df388
	pc = 0x830DF388; continue 'dispatch;
            }
            0x830DF44C => {
    //   block [0x830DF44C..0x830DF464)
	// 830DF44C: 7E078378  mr r7, r16
	ctx.r[7].u64 = ctx.r[16].u64;
	// 830DF450: 80610284  lwz r3, 0x284(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(644 as u32) ) } as u64;
	// 830DF454: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830DF458: 7E258B78  mr r5, r17
	ctx.r[5].u64 = ctx.r[17].u64;
	// 830DF45C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 830DF460: 4BFFE651  bl 0x830ddab0
	ctx.lr = 0x830DF464;
	sub_830DDAB0(ctx, base);
	pc = 0x830DF464; continue 'dispatch;
            }
            0x830DF464 => {
    //   block [0x830DF464..0x830DF46C)
	// 830DF464: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830DF468: 4BFFFF20  b 0x830df388
	pc = 0x830DF388; continue 'dispatch;
            }
            0x830DF46C => {
    //   block [0x830DF46C..0x830DF478)
	// 830DF46C: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 830DF470: 4BFFC951  bl 0x830dbdc0
	ctx.lr = 0x830DF474;
	sub_830DBDC0(ctx, base);
	// 830DF474: 480008D8  b 0x830dfd4c
	pc = 0x830DFD4C; continue 'dispatch;
            }
            0x830DF478 => {
    //   block [0x830DF478..0x830DF4C8)
	// 830DF478: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830DF47C: 8081006C  lwz r4, 0x6c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830DF480: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 830DF484: 4BFFC70D  bl 0x830dbb90
	ctx.lr = 0x830DF488;
	sub_830DBB90(ctx, base);
	// 830DF488: 4BC797C9  bl 0x82d58c50
	ctx.lr = 0x830DF48C;
	sub_82D58C50(ctx, base);
	// 830DF48C: 82AD0000  lwz r21, 0(r13)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF490: 3AC00004  li r22, 4
	ctx.r[22].s64 = 4;
	// 830DF494: 92810090  stw r20, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[20].u32 ) };
	// 830DF498: 3FE08000  lis r31, -0x8000
	ctx.r[31].s64 = -2147483648;
	// 830DF49C: 92810094  stw r20, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[20].u32 ) };
	// 830DF4A0: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 830DF4A4: 7C76A82E  lwzx r3, r22, r21
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 830DF4A8: 93E10098  stw r31, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[31].u32 ) };
	// 830DF4AC: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 830DF4B0: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 830DF4B4: 394B0410  addi r10, r11, 0x410
	ctx.r[10].s64 = ctx.r[11].s64 + 1040;
	// 830DF4B8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830DF4BC: 4199000C  bgt cr6, 0x830df4c8
	if ctx.cr[6].gt {
	pc = 0x830DF4C8; continue 'dispatch;
	}
	// 830DF4C0: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830DF4C4: 4800001C  b 0x830df4e0
	pc = 0x830DF4E0; continue 'dispatch;
            }
            0x830DF4C8 => {
    //   block [0x830DF4C8..0x830DF4E0)
	// 830DF4C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF4CC: 38800410  li r4, 0x410
	ctx.r[4].s64 = 1040;
	// 830DF4D0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830DF4D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DF4D8: 4E800421  bctrl
	ctx.lr = 0x830DF4DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DF4DC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
            }
            0x830DF4E0 => {
    //   block [0x830DF4E0..0x830DF524)
	// 830DF4E0: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 830DF4E4: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 830DF4E8: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 830DF4EC: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 830DF4F0: 614A0400  ori r10, r10, 0x400
	ctx.r[10].u64 = ctx.r[10].u64 | 1024;
	// 830DF4F4: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 830DF4F8: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830DF4FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830DF500: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 830DF504: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830DF508: 91410098  stw r10, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 830DF50C: 4BFFD1ED  bl 0x830dc6f8
	ctx.lr = 0x830DF510;
	sub_830DC6F8(ctx, base);
	// 830DF510: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DF514: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DF518: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830DF51C: 419A0008  beq cr6, 0x830df524
	if ctx.cr[6].eq {
	pc = 0x830DF524; continue 'dispatch;
	}
	// 830DF520: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	pc = 0x830DF524; continue 'dispatch;
            }
            0x830DF524 => {
    //   block [0x830DF524..0x830DF618)
	// 830DF524: 83A10128  lwz r29, 0x128(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(296 as u32) ) } as u64;
	// 830DF528: 928100F0  stw r20, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[20].u32 ) };
	// 830DF52C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DF530: 928100F4  stw r20, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[20].u32 ) };
	// 830DF534: 93E100F8  stw r31, 0xf8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[31].u32 ) };
	// 830DF538: 928100FC  stw r20, 0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[20].u32 ) };
	// 830DF53C: 92810100  stw r20, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[20].u32 ) };
	// 830DF540: 93E10104  stw r31, 0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[31].u32 ) };
	// 830DF544: 92810108  stw r20, 0x108(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[20].u32 ) };
	// 830DF548: 9281010C  stw r20, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[20].u32 ) };
	// 830DF54C: 93E10110  stw r31, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[31].u32 ) };
	// 830DF550: 92810114  stw r20, 0x114(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), ctx.r[20].u32 ) };
	// 830DF554: 92810118  stw r20, 0x118(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[20].u32 ) };
	// 830DF558: 93E1011C  stw r31, 0x11c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), ctx.r[31].u32 ) };
	// 830DF55C: 92810120  stw r20, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[20].u32 ) };
	// 830DF560: 4BC76581  bl 0x82d55ae0
	ctx.lr = 0x830DF564;
	sub_82D55AE0(ctx, base);
	// 830DF564: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830DF568: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830DF56C: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830DF570: 48000C09  bl 0x830e0178
	ctx.lr = 0x830DF574;
	sub_830E0178(ctx, base);
	// 830DF574: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DF578: 4BC76569  bl 0x82d55ae0
	ctx.lr = 0x830DF57C;
	sub_82D55AE0(ctx, base);
	// 830DF57C: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DF580: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830DF584: 392100F0  addi r9, r1, 0xf0
	ctx.r[9].s64 = ctx.r[1].s64 + 240;
	// 830DF588: 7E088378  mr r8, r16
	ctx.r[8].u64 = ctx.r[16].u64;
	// 830DF58C: 7E278B78  mr r7, r17
	ctx.r[7].u64 = ctx.r[17].u64;
	// 830DF590: 83EA0004  lwz r31, 4(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF594: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830DF598: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830DF59C: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830DF5A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830DF5A4: 396B000F  addi r11, r11, 0xf
	ctx.r[11].s64 = ctx.r[11].s64 + 15;
	// 830DF5A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DF5AC: 556B0036  rlwinm r11, r11, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DF5B0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830DF5B4: 4BFFF4E5  bl 0x830dea98
	ctx.lr = 0x830DF5B8;
	sub_830DEA98(ctx, base);
	// 830DF5B8: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830DF5BC: 80810094  lwz r4, 0x94(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 830DF5C0: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 830DF5C4: 48000BB5  bl 0x830e0178
	ctx.lr = 0x830DF5C8;
	sub_830E0178(ctx, base);
	// 830DF5C8: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF5CC: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 830DF5D0: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 830DF5D4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF5D8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830DF5DC: 394A000F  addi r10, r10, 0xf
	ctx.r[10].s64 = ctx.r[10].s64 + 15;
	// 830DF5E0: 554A0036  rlwinm r10, r10, 0, 0, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830DF5E4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830DF5E8: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF5EC: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DF5F0: 80A10094  lwz r5, 0x94(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 830DF5F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF5F8: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF5FC: 7C6BCA14  add r3, r11, r25
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 830DF600: 4BC79731  bl 0x82d58d30
	ctx.lr = 0x830DF604;
	sub_82D58D30(ctx, base);
	// 830DF604: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 830DF608: 7E9FA378  mr r31, r20
	ctx.r[31].u64 = ctx.r[20].u64;
	// 830DF60C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DF610: 4099003C  ble cr6, 0x830df64c
	if !ctx.cr[6].gt {
	pc = 0x830DF64C; continue 'dispatch;
	}
	// 830DF614: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	pc = 0x830DF618; continue 'dispatch;
            }
            0x830DF618 => {
    //   block [0x830DF618..0x830DF64C)
	// 830DF618: 816100F0  lwz r11, 0xf0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) } as u64;
	// 830DF61C: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 830DF620: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830DF624: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF628: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF62C: 7CAACA14  add r5, r10, r25
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[25].u64;
	// 830DF630: 7C8BCA14  add r4, r11, r25
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 830DF634: 4BC97C8D  bl 0x82d772c0
	ctx.lr = 0x830DF638;
	sub_82D772C0(ctx, base);
	// 830DF638: 816100F4  lwz r11, 0xf4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 830DF63C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830DF640: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 830DF644: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DF648: 4198FFD0  blt cr6, 0x830df618
	if ctx.cr[6].lt {
	pc = 0x830DF618; continue 'dispatch;
	}
	pc = 0x830DF64C; continue 'dispatch;
            }
            0x830DF64C => {
    //   block [0x830DF64C..0x830DF664)
	// 830DF64C: 81610100  lwz r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) } as u64;
	// 830DF650: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	// 830DF654: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DF658: 40990088  ble cr6, 0x830df6e0
	if !ctx.cr[6].gt {
	pc = 0x830DF6E0; continue 'dispatch;
	}
	// 830DF65C: 3BF2000C  addi r31, r18, 0xc
	ctx.r[31].s64 = ctx.r[18].s64 + 12;
	// 830DF660: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	pc = 0x830DF664; continue 'dispatch;
            }
            0x830DF664 => {
    //   block [0x830DF664..0x830DF69C)
	// 830DF664: 816100FC  lwz r11, 0xfc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 830DF668: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DF66C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830DF670: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF674: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 830DF678: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830DF67C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF680: 838B0004  lwz r28, 4(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF684: 836B0008  lwz r27, 8(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DF688: 7F4ACA14  add r26, r10, r25
	ctx.r[26].u64 = ctx.r[10].u64 + ctx.r[25].u64;
	// 830DF68C: 409A0010  bne cr6, 0x830df69c
	if !ctx.cr[6].eq {
	pc = 0x830DF69C; continue 'dispatch;
	}
	// 830DF690: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 830DF694: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DF698: 4BC77901  bl 0x82d56f98
	ctx.lr = 0x830DF69C;
	sub_82D56F98(ctx, base);
	pc = 0x830DF69C; continue 'dispatch;
            }
            0x830DF69C => {
    //   block [0x830DF69C..0x830DF6E0)
	// 830DF69C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF6A0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830DF6A4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF6A8: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 830DF6AC: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830DF6B0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830DF6B4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DF6B8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830DF6BC: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 830DF6C0: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830DF6C4: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 830DF6C8: 81610100  lwz r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) } as u64;
	// 830DF6CC: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DF6D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF6D4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830DF6D8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830DF6DC: 4198FF88  blt cr6, 0x830df664
	if ctx.cr[6].lt {
	pc = 0x830DF664; continue 'dispatch;
	}
	pc = 0x830DF6E0; continue 'dispatch;
            }
            0x830DF6E0 => {
    //   block [0x830DF6E0..0x830DF6F8)
	// 830DF6E0: 8161010C  lwz r11, 0x10c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 830DF6E4: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	// 830DF6E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DF6EC: 4099007C  ble cr6, 0x830df768
	if !ctx.cr[6].gt {
	pc = 0x830DF768; continue 'dispatch;
	}
	// 830DF6F0: 3BF20018  addi r31, r18, 0x18
	ctx.r[31].s64 = ctx.r[18].s64 + 24;
	// 830DF6F4: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	pc = 0x830DF6F8; continue 'dispatch;
            }
            0x830DF6F8 => {
    //   block [0x830DF6F8..0x830DF734)
	// 830DF6F8: 81610108  lwz r11, 0x108(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) } as u64;
	// 830DF6FC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DF700: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830DF704: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF708: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 830DF70C: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830DF710: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF714: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF718: 91610154  stw r11, 0x154(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(340 as u32), ctx.r[11].u32 ) };
	// 830DF71C: 7D795214  add r11, r25, r10
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[10].u64;
	// 830DF720: 91610150  stw r11, 0x150(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 830DF724: 409A0010  bne cr6, 0x830df734
	if !ctx.cr[6].eq {
	pc = 0x830DF734; continue 'dispatch;
	}
	// 830DF728: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 830DF72C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DF730: 4BC77869  bl 0x82d56f98
	ctx.lr = 0x830DF734;
	sub_82D56F98(ctx, base);
	pc = 0x830DF734; continue 'dispatch;
            }
            0x830DF734 => {
    //   block [0x830DF734..0x830DF768)
	// 830DF734: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF738: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830DF73C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF740: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 830DF744: E9210150  ld r9, 0x150(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(336 as u32) ) };
	// 830DF748: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DF74C: 7D2B512A  stdx r9, r11, r10
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u64) };
	// 830DF750: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF754: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830DF758: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830DF75C: 8161010C  lwz r11, 0x10c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 830DF760: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DF764: 4198FF94  blt cr6, 0x830df6f8
	if ctx.cr[6].lt {
	pc = 0x830DF6F8; continue 'dispatch;
	}
	pc = 0x830DF768; continue 'dispatch;
            }
            0x830DF768 => {
    //   block [0x830DF768..0x830DF77C)
	// 830DF768: 81610118  lwz r11, 0x118(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(280 as u32) ) } as u64;
	// 830DF76C: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	// 830DF770: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DF774: 40990038  ble cr6, 0x830df7ac
	if !ctx.cr[6].gt {
	pc = 0x830DF7AC; continue 'dispatch;
	}
	// 830DF778: 7E9FA378  mr r31, r20
	ctx.r[31].u64 = ctx.r[20].u64;
	pc = 0x830DF77C; continue 'dispatch;
            }
            0x830DF77C => {
    //   block [0x830DF77C..0x830DF7AC)
	// 830DF77C: 81610114  lwz r11, 0x114(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 830DF780: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 830DF784: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 830DF788: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF78C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF790: 7C8ACA14  add r4, r10, r25
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[25].u64;
	// 830DF794: 4BC95F9D  bl 0x82d75730
	ctx.lr = 0x830DF798;
	sub_82D75730(ctx, base);
	// 830DF798: 81610118  lwz r11, 0x118(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(280 as u32) ) } as u64;
	// 830DF79C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 830DF7A0: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 830DF7A4: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DF7A8: 4198FFD4  blt cr6, 0x830df77c
	if ctx.cr[6].lt {
	pc = 0x830DF77C; continue 'dispatch;
	}
	pc = 0x830DF7AC; continue 'dispatch;
            }
            0x830DF7AC => {
    //   block [0x830DF7AC..0x830DF7DC)
	// 830DF7AC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DF7B0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 830DF7B4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF7B8: 4BC95DF1  bl 0x82d755a8
	ctx.lr = 0x830DF7BC;
	sub_82D755A8(ctx, base);
	// 830DF7BC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DF7C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DF7C4: 419A0018  beq cr6, 0x830df7dc
	if ctx.cr[6].eq {
	pc = 0x830DF7DC; continue 'dispatch;
	}
	// 830DF7C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF7CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DF7D0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF7D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DF7D8: 4E800421  bctrl
	ctx.lr = 0x830DF7DC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DF7DC => {
    //   block [0x830DF7DC..0x830DF848)
	// 830DF7DC: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 830DF7E0: 4BC95E49  bl 0x82d75628
	ctx.lr = 0x830DF7E4;
	sub_82D75628(ctx, base);
	// 830DF7E4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830DF7E8: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF7EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DF7F0: 4BC762F1  bl 0x82d55ae0
	ctx.lr = 0x830DF7F4;
	sub_82D55AE0(ctx, base);
	// 830DF7F4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830DF7F8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DF7FC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830DF800: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 830DF804: 48000975  bl 0x830e0178
	ctx.lr = 0x830DF808;
	sub_830E0178(ctx, base);
	// 830DF808: 7FFCC1D6  mullw r31, r28, r24
	ctx.r[31].s32 = ((ctx.r[28].s32 as i64 * ctx.r[24].s32 as i64) as i32);
	ctx.r[31].s64 = ctx.r[31].s32 as i64;
	// 830DF80C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830DF810: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830DF814: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 830DF818: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DF81C: 4800095D  bl 0x830e0178
	ctx.lr = 0x830DF820;
	sub_830E0178(ctx, base);
	// 830DF820: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF824: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 830DF828: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF82C: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 830DF830: 394A000F  addi r10, r10, 0xf
	ctx.r[10].s64 = ctx.r[10].s64 + 15;
	// 830DF834: 554A0036  rlwinm r10, r10, 0, 0, 0x1b
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830DF838: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830DF83C: 40990080  ble cr6, 0x830df8bc
	if !ctx.cr[6].gt {
	pc = 0x830DF8BC; continue 'dispatch;
	}
	// 830DF840: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 830DF844: 7F1DC378  mr r29, r24
	ctx.r[29].u64 = ctx.r[24].u64;
	pc = 0x830DF848; continue 'dispatch;
            }
            0x830DF848 => {
    //   block [0x830DF848..0x830DF870)
	// 830DF848: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830DF84C: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 830DF850: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830DF854: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 830DF858: 4BFFCEA1  bl 0x830dc6f8
	ctx.lr = 0x830DF85C;
	sub_830DC6F8(ctx, base);
	// 830DF85C: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DF860: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DF864: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830DF868: 419A0008  beq cr6, 0x830df870
	if ctx.cr[6].eq {
	pc = 0x830DF870; continue 'dispatch;
	}
	// 830DF86C: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	pc = 0x830DF870; continue 'dispatch;
            }
            0x830DF870 => {
    //   block [0x830DF870..0x830DF8AC)
	// 830DF870: 7E499378  mr r9, r18
	ctx.r[9].u64 = ctx.r[18].u64;
	// 830DF874: 7E088378  mr r8, r16
	ctx.r[8].u64 = ctx.r[16].u64;
	// 830DF878: 7E278B78  mr r7, r17
	ctx.r[7].u64 = ctx.r[17].u64;
	// 830DF87C: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 830DF880: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DF884: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830DF888: 4BFFF211  bl 0x830dea98
	ctx.lr = 0x830DF88C;
	sub_830DEA98(ctx, base);
	// 830DF88C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DF890: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DF894: 419A0018  beq cr6, 0x830df8ac
	if ctx.cr[6].eq {
	pc = 0x830DF8AC; continue 'dispatch;
	}
	// 830DF898: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF89C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DF8A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF8A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DF8A8: 4E800421  bctrl
	ctx.lr = 0x830DF8AC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DF8AC => {
    //   block [0x830DF8AC..0x830DF8BC)
	// 830DF8AC: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 830DF8B0: 7FFCFA14  add r31, r28, r31
	ctx.r[31].u64 = ctx.r[28].u64 + ctx.r[31].u64;
	// 830DF8B4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830DF8B8: 409AFF90  bne cr6, 0x830df848
	if !ctx.cr[6].eq {
	pc = 0x830DF848; continue 'dispatch;
	}
	pc = 0x830DF8BC; continue 'dispatch;
            }
            0x830DF8BC => {
    //   block [0x830DF8BC..0x830DF90C)
	// 830DF8BC: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF8C0: A1570012  lhz r10, 0x12(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[23].u32.wrapping_add(18 as u32) ) } as u64;
	// 830DF8C4: 93210164  stw r25, 0x164(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(356 as u32), ctx.r[25].u32 ) };
	// 830DF8C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF8CC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830DF8D0: 7D6B7214  add r11, r11, r14
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[14].u64;
	// 830DF8D4: 928B0000  stw r20, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[20].u32 ) };
	// 830DF8D8: 928B0004  stw r20, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[20].u32 ) };
	// 830DF8DC: 930B0008  stw r24, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 830DF8E0: A1770012  lhz r11, 0x12(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[23].u32.wrapping_add(18 as u32) ) } as u64;
	// 830DF8E4: 81520008  lwz r10, 8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DF8E8: 7D6B7214  add r11, r11, r14
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[14].u64;
	// 830DF8EC: 81320004  lwz r9, 4(r18)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF8F0: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 830DF8F4: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830DF8F8: 91610160  stw r11, 0x160(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[11].u32 ) };
	// 830DF8FC: 409A0010  bne cr6, 0x830df90c
	if !ctx.cr[6].eq {
	pc = 0x830DF90C; continue 'dispatch;
	}
	// 830DF900: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 830DF904: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 830DF908: 4BC77691  bl 0x82d56f98
	ctx.lr = 0x830DF90C;
	sub_82D56F98(ctx, base);
	pc = 0x830DF90C; continue 'dispatch;
            }
            0x830DF90C => {
    //   block [0x830DF90C..0x830DF964)
	// 830DF90C: 81720004  lwz r11, 4(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF910: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 830DF914: E9410160  ld r10, 0x160(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(352 as u32) ) };
	// 830DF918: 81320000  lwz r9, 0(r18)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF91C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DF920: 7D4B492A  stdx r10, r11, r9
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u64) };
	// 830DF924: 81720004  lwz r11, 4(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF928: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830DF92C: 91720004  stw r11, 4(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830DF930: 40990054  ble cr6, 0x830df984
	if !ctx.cr[6].gt {
	pc = 0x830DF984; continue 'dispatch;
	}
	// 830DF934: A1570012  lhz r10, 0x12(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[23].u32.wrapping_add(18 as u32) ) } as u64;
	// 830DF938: 81320008  lwz r9, 8(r18)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DF93C: 7D4A7214  add r10, r10, r14
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[14].u64;
	// 830DF940: 9361015C  stw r27, 0x15c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(348 as u32), ctx.r[27].u32 ) };
	// 830DF944: 552900BE  clrlwi r9, r9, 2
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x3FFFFFFFu64;
	// 830DF948: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830DF94C: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830DF950: 91410158  stw r10, 0x158(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), ctx.r[10].u32 ) };
	// 830DF954: 409A0010  bne cr6, 0x830df964
	if !ctx.cr[6].eq {
	pc = 0x830DF964; continue 'dispatch;
	}
	// 830DF958: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 830DF95C: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 830DF960: 4BC77639  bl 0x82d56f98
	ctx.lr = 0x830DF964;
	sub_82D56F98(ctx, base);
	pc = 0x830DF964; continue 'dispatch;
            }
            0x830DF964 => {
    //   block [0x830DF964..0x830DF984)
	// 830DF964: 81720004  lwz r11, 4(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF968: E9410158  ld r10, 0x158(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(344 as u32) ) };
	// 830DF96C: 81320000  lwz r9, 0(r18)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF970: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830DF974: 7D4B492A  stdx r10, r11, r9
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u64) };
	// 830DF978: 81720004  lwz r11, 4(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DF97C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830DF980: 91720004  stw r11, 4(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x830DF984; continue 'dispatch;
            }
            0x830DF984 => {
    //   block [0x830DF984..0x830DF9AC)
	// 830DF984: 7C76A82E  lwzx r3, r22, r21
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 830DF988: 8081009C  lwz r4, 0x9c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 830DF98C: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830DF990: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 830DF994: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830DF998: 409A0014  bne cr6, 0x830df9ac
	if !ctx.cr[6].eq {
	pc = 0x830DF9AC; continue 'dispatch;
	}
	// 830DF99C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DF9A0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830DF9A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DF9A8: 4E800421  bctrl
	ctx.lr = 0x830DF9AC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DF9AC => {
    //   block [0x830DF9AC..0x830DF9C8)
	// 830DF9AC: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 830DF9B0: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DF9B4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DF9B8: 409A0394  bne cr6, 0x830dfd4c
	if !ctx.cr[6].eq {
	pc = 0x830DFD4C; continue 'dispatch;
	}
	// 830DF9BC: 7C76A82E  lwzx r3, r22, r21
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 830DF9C0: 80810090  lwz r4, 0x90(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 830DF9C4: 4800037C  b 0x830dfd40
	pc = 0x830DFD40; continue 'dispatch;
            }
            0x830DF9C8 => {
    //   block [0x830DF9C8..0x830DFA24)
	// 830DF9C8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 830DF9CC: 7DE67B78  mr r6, r15
	ctx.r[6].u64 = ctx.r[15].u64;
	// 830DF9D0: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830DF9D4: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 830DF9D8: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 830DF9DC: 4BFFEBED  bl 0x830de5c8
	ctx.lr = 0x830DF9E0;
	sub_830DE5C8(ctx, base);
	// 830DF9E0: 3CC07FFF  lis r6, 0x7fff
	ctx.r[6].s64 = 2147418112;
	// 830DF9E4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830DF9E8: 60C6FFFF  ori r6, r6, 0xffff
	ctx.r[6].u64 = ctx.r[6].u64 | 65535;
	// 830DF9EC: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 830DF9F0: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 830DF9F4: 4BC795F5  bl 0x82d58fe8
	ctx.lr = 0x830DF9F8;
	sub_82D58FE8(ctx, base);
	// 830DF9F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830DF9FC: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 830DFA00: 419A01B8  beq cr6, 0x830dfbb8
	if ctx.cr[6].eq {
	pc = 0x830DFBB8; continue 'dispatch;
	}
	// 830DFA04: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 830DFA08: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 830DFA0C: A1570012  lhz r10, 0x12(r23)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[23].u32.wrapping_add(18 as u32) ) } as u64;
	// 830DFA10: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830DFA14: 7F6A7214  add r27, r10, r14
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[14].u64;
	// 830DFA18: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DFA1C: 40990008  ble cr6, 0x830dfa24
	if !ctx.cr[6].gt {
	pc = 0x830DFA24; continue 'dispatch;
	}
	// 830DFA20: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	pc = 0x830DFA24; continue 'dispatch;
            }
            0x830DFA24 => {
    //   block [0x830DFA24..0x830DFA50)
	// 830DFA24: 3F408000  lis r26, -0x8000
	ctx.r[26].s64 = -2147483648;
	// 830DFA28: 838100C8  lwz r28, 0xc8(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 830DFA2C: 3BDF0001  addi r30, r31, 1
	ctx.r[30].s64 = ctx.r[31].s64 + 1;
	// 830DFA30: 92810060  stw r20, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[20].u32 ) };
	// 830DFA34: 92810064  stw r20, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[20].u32 ) };
	// 830DFA38: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830DFA3C: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 830DFA40: 4099001C  ble cr6, 0x830dfa5c
	if !ctx.cr[6].gt {
	pc = 0x830DFA5C; continue 'dispatch;
	}
	// 830DFA44: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 830DFA48: 41980008  blt cr6, 0x830dfa50
	if ctx.cr[6].lt {
	pc = 0x830DFA50; continue 'dispatch;
	}
	// 830DFA4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	pc = 0x830DFA50; continue 'dispatch;
            }
            0x830DFA50 => {
    //   block [0x830DFA50..0x830DFA5C)
	// 830DFA50: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DFA54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830DFA58: 4BC774B9  bl 0x82d56f10
	ctx.lr = 0x830DFA5C;
	sub_82D56F10(ctx, base);
	pc = 0x830DFA5C; continue 'dispatch;
            }
            0x830DFA5C => {
    //   block [0x830DFA5C..0x830DFAB0)
	// 830DFA5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830DFA60: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DFA64: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830DFA68: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 830DFA6C: 4BC792C5  bl 0x82d58d30
	ctx.lr = 0x830DFA70;
	sub_82D58D30(ctx, base);
	// 830DFA70: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DFA74: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830DFA78: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 830DFA7C: 7E8BF9AE  stbx r20, r11, r31
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[20].u8) };
	// 830DFA80: 80A10060  lwz r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DFA84: 4BC95CAD  bl 0x82d75730
	ctx.lr = 0x830DFA88;
	sub_82D75730(ctx, base);
	// 830DFA88: 3D407FFF  lis r10, 0x7fff
	ctx.r[10].s64 = 2147418112;
	// 830DFA8C: 397D0001  addi r11, r29, 1
	ctx.r[11].s64 = ctx.r[29].s64 + 1;
	// 830DFA90: 615FFFFF  ori r31, r10, 0xffff
	ctx.r[31].u64 = ctx.r[10].u64 | 65535;
	// 830DFA94: 814100CC  lwz r10, 0xcc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 830DFA98: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830DFA9C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 830DFAA0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830DFAA4: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830DFAA8: 40980008  bge cr6, 0x830dfab0
	if !ctx.cr[6].lt {
	pc = 0x830DFAB0; continue 'dispatch;
	}
	// 830DFAAC: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	pc = 0x830DFAB0; continue 'dispatch;
            }
            0x830DFAB0 => {
    //   block [0x830DFAB0..0x830DFADC)
	// 830DFAB0: 814100C8  lwz r10, 0xc8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 830DFAB4: 3BDF0001  addi r30, r31, 1
	ctx.r[30].s64 = ctx.r[31].s64 + 1;
	// 830DFAB8: 92810070  stw r20, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[20].u32 ) };
	// 830DFABC: 7FAA5A14  add r29, r10, r11
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830DFAC0: 92810074  stw r20, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[20].u32 ) };
	// 830DFAC4: 93410078  stw r26, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[26].u32 ) };
	// 830DFAC8: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830DFACC: 4099001C  ble cr6, 0x830dfae8
	if !ctx.cr[6].gt {
	pc = 0x830DFAE8; continue 'dispatch;
	}
	// 830DFAD0: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 830DFAD4: 41980008  blt cr6, 0x830dfadc
	if ctx.cr[6].lt {
	pc = 0x830DFADC; continue 'dispatch;
	}
	// 830DFAD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	pc = 0x830DFADC; continue 'dispatch;
            }
            0x830DFADC => {
    //   block [0x830DFADC..0x830DFAE8)
	// 830DFADC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DFAE0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830DFAE4: 4BC7742D  bl 0x82d56f10
	ctx.lr = 0x830DFAE8;
	sub_82D56F10(ctx, base);
	pc = 0x830DFAE8; continue 'dispatch;
            }
            0x830DFAE8 => {
    //   block [0x830DFAE8..0x830DFB2C)
	// 830DFAE8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830DFAEC: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830DFAF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830DFAF4: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 830DFAF8: 4BC79239  bl 0x82d58d30
	ctx.lr = 0x830DFAFC;
	sub_82D58D30(ctx, base);
	// 830DFAFC: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830DFB00: 7E8BF9AE  stbx r20, r11, r31
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[20].u8) };
	// 830DFB04: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830DFB08: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DFB0C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 830DFB10: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 830DFB14: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830DFB18: 40980024  bge cr6, 0x830dfb3c
	if !ctx.cr[6].lt {
	pc = 0x830DFB3C; continue 'dispatch;
	}
	// 830DFB1C: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830DFB20: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830DFB24: 40980008  bge cr6, 0x830dfb2c
	if !ctx.cr[6].lt {
	pc = 0x830DFB2C; continue 'dispatch;
	}
	// 830DFB28: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x830DFB2C; continue 'dispatch;
            }
            0x830DFB2C => {
    //   block [0x830DFB2C..0x830DFB3C)
	// 830DFB2C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DFB30: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830DFB34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830DFB38: 4BC773D9  bl 0x82d56f10
	ctx.lr = 0x830DFB3C;
	sub_82D56F10(ctx, base);
	pc = 0x830DFB3C; continue 'dispatch;
            }
            0x830DFB3C => {
    //   block [0x830DFB3C..0x830DFB7C)
	// 830DFB3C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830DFB40: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830DFB44: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DFB48: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 830DFB4C: 4BC791E5  bl 0x82d58d30
	ctx.lr = 0x830DFB50;
	sub_82D58D30(ctx, base);
	// 830DFB50: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830DFB54: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DFB58: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DFB5C: 409A0020  bne cr6, 0x830dfb7c
	if !ctx.cr[6].eq {
	pc = 0x830DFB7C; continue 'dispatch;
	}
	// 830DFB60: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DFB64: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DFB68: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DFB6C: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830DFB70: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DFB74: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DFB78: 4BC75751  bl 0x82d552c8
	ctx.lr = 0x830DFB7C;
	sub_82D552C8(ctx, base);
	pc = 0x830DFB7C; continue 'dispatch;
            }
            0x830DFB7C => {
    //   block [0x830DFB7C..0x830DFBB8)
	// 830DFB7C: 389B0004  addi r4, r27, 4
	ctx.r[4].s64 = ctx.r[27].s64 + 4;
	// 830DFB80: 80A10060  lwz r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DFB84: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 830DFB88: 4BC95BA9  bl 0x82d75730
	ctx.lr = 0x830DFB8C;
	sub_82D75730(ctx, base);
	// 830DFB8C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830DFB90: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DFB94: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DFB98: 409A0020  bne cr6, 0x830dfbb8
	if !ctx.cr[6].eq {
	pc = 0x830DFBB8; continue 'dispatch;
	}
	// 830DFB9C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DFBA0: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DFBA4: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DFBA8: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830DFBAC: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DFBB0: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DFBB4: 4BC75715  bl 0x82d552c8
	ctx.lr = 0x830DFBB8;
	sub_82D552C8(ctx, base);
	pc = 0x830DFBB8; continue 'dispatch;
            }
            0x830DFBB8 => {
    //   block [0x830DFBB8..0x830DFBD0)
	// 830DFBB8: 816100D0  lwz r11, 0xd0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 830DFBBC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DFBC0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DFBC4: 409A0188  bne cr6, 0x830dfd4c
	if !ctx.cr[6].eq {
	pc = 0x830DFD4C; continue 'dispatch;
	}
	// 830DFBC8: 808100C8  lwz r4, 0xc8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 830DFBCC: 48000168  b 0x830dfd34
	pc = 0x830DFD34; continue 'dispatch;
            }
            0x830DFBD0 => {
    //   block [0x830DFBD0..0x830DFC2C)
	// 830DFBD0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830DFBD4: 7DE67B78  mr r6, r15
	ctx.r[6].u64 = ctx.r[15].u64;
	// 830DFBD8: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830DFBDC: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 830DFBE0: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 830DFBE4: 4BFFE9E5  bl 0x830de5c8
	ctx.lr = 0x830DFBE8;
	sub_830DE5C8(ctx, base);
	// 830DFBE8: 816100DC  lwz r11, 0xdc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 830DFBEC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830DFBF0: 41820130  beq 0x830dfd20
	if ctx.cr[0].eq {
	pc = 0x830DFD20; continue 'dispatch;
	}
	// 830DFBF4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 830DFBF8: 4BC7D189  bl 0x82d5cd80
	ctx.lr = 0x830DFBFC;
	sub_82D5CD80(ctx, base);
	// 830DFBFC: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 830DFC00: 80A100DC  lwz r5, 0xdc(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 830DFC04: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830DFC08: 928100A8  stw r20, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[20].u32 ) };
	// 830DFC0C: 928100AC  stw r20, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[20].u32 ) };
	// 830DFC10: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830DFC14: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830DFC18: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 830DFC1C: 40990020  ble cr6, 0x830dfc3c
	if !ctx.cr[6].gt {
	pc = 0x830DFC3C; continue 'dispatch;
	}
	// 830DFC20: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 830DFC24: 41980008  blt cr6, 0x830dfc2c
	if ctx.cr[6].lt {
	pc = 0x830DFC2C; continue 'dispatch;
	}
	// 830DFC28: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	pc = 0x830DFC2C; continue 'dispatch;
            }
            0x830DFC2C => {
    //   block [0x830DFC2C..0x830DFC3C)
	// 830DFC2C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830DFC30: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 830DFC34: 4BC772DD  bl 0x82d56f10
	ctx.lr = 0x830DFC38;
	sub_82D56F10(ctx, base);
	// 830DFC38: 80A100DC  lwz r5, 0xdc(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	pc = 0x830DFC3C; continue 'dispatch;
            }
            0x830DFC3C => {
    //   block [0x830DFC3C..0x830DFC5C)
	// 830DFC3C: 808100D8  lwz r4, 0xd8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) } as u64;
	// 830DFC40: 806100A8  lwz r3, 0xa8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 830DFC44: 93E100AC  stw r31, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[31].u32 ) };
	// 830DFC48: 4BC78FD1  bl 0x82d58c18
	ctx.lr = 0x830DFC4C;
	sub_82D58C18(ctx, base);
	// 830DFC4C: 83E100A8  lwz r31, 0xa8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 830DFC50: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	// 830DFC54: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830DFC58: 419A007C  beq cr6, 0x830dfcd4
	if ctx.cr[6].eq {
	pc = 0x830DFCD4; continue 'dispatch;
	}
	pc = 0x830DFC5C; continue 'dispatch;
            }
            0x830DFC5C => {
    //   block [0x830DFC5C..0x830DFC7C)
	// 830DFC5C: 3880007C  li r4, 0x7c
	ctx.r[4].s64 = 124;
	// 830DFC60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DFC64: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	// 830DFC68: 4BC79029  bl 0x82d58c90
	ctx.lr = 0x830DFC6C;
	sub_82D58C90(ctx, base);
	// 830DFC6C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DFC70: 419A000C  beq cr6, 0x830dfc7c
	if ctx.cr[6].eq {
	pc = 0x830DFC7C; continue 'dispatch;
	}
	// 830DFC74: 3BC30001  addi r30, r3, 1
	ctx.r[30].s64 = ctx.r[3].s64 + 1;
	// 830DFC78: 9A830000  stb r20, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[20].u8 ) };
	pc = 0x830DFC7C; continue 'dispatch;
            }
            0x830DFC7C => {
    //   block [0x830DFC7C..0x830DFCA4)
	// 830DFC7C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DFC80: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830DFC84: 2F0B0030  cmpwi cr6, r11, 0x30
	ctx.cr[6].compare_i32(ctx.r[11].s32, 48, &mut ctx.xer);
	// 830DFC88: 4198001C  blt cr6, 0x830dfca4
	if ctx.cr[6].lt {
	pc = 0x830DFCA4; continue 'dispatch;
	}
	// 830DFC8C: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 830DFC90: 41990014  bgt cr6, 0x830dfca4
	if ctx.cr[6].gt {
	pc = 0x830DFCA4; continue 'dispatch;
	}
	// 830DFC94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DFC98: 4BC78FB9  bl 0x82d58c50
	ctx.lr = 0x830DFC9C;
	sub_82D58C50(ctx, base);
	// 830DFC9C: 7C7DEB78  or r29, r3, r29
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[29].u64;
	// 830DFCA0: 48000028  b 0x830dfcc8
	pc = 0x830DFCC8; continue 'dispatch;
            }
            0x830DFCA4 => {
    //   block [0x830DFCA4..0x830DFCC8)
	// 830DFCA4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830DFCA8: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 830DFCAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830DFCB0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830DFCB4: 4BC7E8A5  bl 0x82d5e558
	ctx.lr = 0x830DFCB8;
	sub_82D5E558(ctx, base);
	// 830DFCB8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DFCBC: 409A000C  bne cr6, 0x830dfcc8
	if !ctx.cr[6].eq {
	pc = 0x830DFCC8; continue 'dispatch;
	}
	// 830DFCC0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DFCC4: 7D7DEB78  or r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 | ctx.r[29].u64;
	pc = 0x830DFCC8; continue 'dispatch;
            }
            0x830DFCC8 => {
    //   block [0x830DFCC8..0x830DFCD4)
	// 830DFCC8: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 830DFCCC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830DFCD0: 409AFF8C  bne cr6, 0x830dfc5c
	if !ctx.cr[6].eq {
	pc = 0x830DFC5C; continue 'dispatch;
	}
	pc = 0x830DFCD4; continue 'dispatch;
            }
            0x830DFCD4 => {
    //   block [0x830DFCD4..0x830DFD20)
	// 830DFCD4: 81530000  lwz r10, 0(r19)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DFCD8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830DFCDC: A1770012  lhz r11, 0x12(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[23].u32.wrapping_add(18 as u32) ) } as u64;
	// 830DFCE0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 830DFCE4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DFCE8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830DFCEC: 7C8B7214  add r4, r11, r14
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[14].u64;
	// 830DFCF0: 4BC7D3F9  bl 0x82d5d0e8
	ctx.lr = 0x830DFCF4;
	sub_82D5D0E8(ctx, base);
	// 830DFCF4: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 830DFCF8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DFCFC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DFD00: 409A0020  bne cr6, 0x830dfd20
	if !ctx.cr[6].eq {
	pc = 0x830DFD20; continue 'dispatch;
	}
	// 830DFD04: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DFD08: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DFD0C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DFD10: 808100A8  lwz r4, 0xa8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 830DFD14: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DFD18: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830DFD1C: 4BC755AD  bl 0x82d552c8
	ctx.lr = 0x830DFD20;
	sub_82D552C8(ctx, base);
	pc = 0x830DFD20; continue 'dispatch;
            }
            0x830DFD20 => {
    //   block [0x830DFD20..0x830DFD34)
	// 830DFD20: 816100E0  lwz r11, 0xe0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) } as u64;
	// 830DFD24: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DFD28: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830DFD2C: 409A0020  bne cr6, 0x830dfd4c
	if !ctx.cr[6].eq {
	pc = 0x830DFD4C; continue 'dispatch;
	}
	// 830DFD30: 808100D8  lwz r4, 0xd8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) } as u64;
	pc = 0x830DFD34; continue 'dispatch;
            }
            0x830DFD34 => {
    //   block [0x830DFD34..0x830DFD40)
	// 830DFD34: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DFD38: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830DFD3C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	pc = 0x830DFD40; continue 'dispatch;
            }
            0x830DFD40 => {
    //   block [0x830DFD40..0x830DFD4C)
	// 830DFD40: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830DFD44: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830DFD48: 4BC75581  bl 0x82d552c8
	ctx.lr = 0x830DFD4C;
	sub_82D552C8(ctx, base);
	pc = 0x830DFD4C; continue 'dispatch;
            }
            0x830DFD4C => {
    //   block [0x830DFD4C..0x830DFD8C)
	// 830DFD4C: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830DFD50: 92810050  stw r20, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u32 ) };
	// 830DFD54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830DFD58: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 830DFD5C: 7E9FA378  mr r31, r20
	ctx.r[31].u64 = ctx.r[20].u64;
	// 830DFD60: 4BFFC999  bl 0x830dc6f8
	ctx.lr = 0x830DFD64;
	sub_830DC6F8(ctx, base);
	// 830DFD64: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DFD68: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DFD6C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830DFD70: 409A001C  bne cr6, 0x830dfd8c
	if !ctx.cr[6].eq {
	pc = 0x830DFD8C; continue 'dispatch;
	}
	// 830DFD74: 808F000C  lwz r4, 0xc(r15)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DFD78: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DFD7C: 4BC78C5D  bl 0x82d589d8
	ctx.lr = 0x830DFD80;
	sub_82D589D8(ctx, base);
	// 830DFD80: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DFD84: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DFD88: 419A0008  beq cr6, 0x830dfd90
	if ctx.cr[6].eq {
	pc = 0x830DFD90; continue 'dispatch;
	}
	pc = 0x830DFD8C; continue 'dispatch;
            }
            0x830DFD8C => {
    //   block [0x830DFD8C..0x830DFD90)
	// 830DFD8C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	pc = 0x830DFD90; continue 'dispatch;
            }
            0x830DFD90 => {
    //   block [0x830DFD90..0x830DFDAC)
	// 830DFD90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DFD94: 419A0018  beq cr6, 0x830dfdac
	if ctx.cr[6].eq {
	pc = 0x830DFDAC; continue 'dispatch;
	}
	// 830DFD98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DFD9C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DFDA0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DFDA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DFDA8: 4E800421  bctrl
	ctx.lr = 0x830DFDAC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DFDAC => {
    //   block [0x830DFDAC..0x830DFDC0)
	// 830DFDAC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830DFDB0: 2F1F0001  cmpwi cr6, r31, 1
	ctx.cr[6].compare_i32(ctx.r[31].s32, 1, &mut ctx.xer);
	// 830DFDB4: 419A0074  beq cr6, 0x830dfe28
	if ctx.cr[6].eq {
	pc = 0x830DFE28; continue 'dispatch;
	}
	// 830DFDB8: 83E1029C  lwz r31, 0x29c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(668 as u32) ) } as u64;
	// 830DFDBC: 4800002C  b 0x830dfde8
	pc = 0x830DFDE8; continue 'dispatch;
            }
            0x830DFDC0 => {
    //   block [0x830DFDC0..0x830DFDE8)
	// 830DFDC0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830DFDC4: 409A0024  bne cr6, 0x830dfde8
	if !ctx.cr[6].eq {
	pc = 0x830DFDE8; continue 'dispatch;
	}
	// 830DFDC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830DFDCC: 419A001C  beq cr6, 0x830dfde8
	if ctx.cr[6].eq {
	pc = 0x830DFDE8; continue 'dispatch;
	}
	// 830DFDD0: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DFDD4: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DFDD8: 4BC78C01  bl 0x82d589d8
	ctx.lr = 0x830DFDDC;
	sub_82D589D8(ctx, base);
	// 830DFDDC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DFDE0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830DFDE4: 419A006C  beq cr6, 0x830dfe50
	if ctx.cr[6].eq {
	pc = 0x830DFE50; continue 'dispatch;
	}
	pc = 0x830DFDE8; continue 'dispatch;
            }
            0x830DFDE8 => {
    //   block [0x830DFDE8..0x830DFE04)
	// 830DFDE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DFDEC: 419A0018  beq cr6, 0x830dfe04
	if ctx.cr[6].eq {
	pc = 0x830DFE04; continue 'dispatch;
	}
	// 830DFDF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DFDF4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DFDF8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DFDFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DFE00: 4E800421  bctrl
	ctx.lr = 0x830DFE04;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DFE04 => {
    //   block [0x830DFE04..0x830DFE1C)
	// 830DFE04: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 830DFE08: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 830DFE0C: 7E238B78  mr r3, r17
	ctx.r[3].u64 = ctx.r[17].u64;
	// 830DFE10: 4BFFC8E9  bl 0x830dc6f8
	ctx.lr = 0x830DFE14;
	sub_830DC6F8(ctx, base);
	// 830DFE14: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DFE18: 419AECEC  beq cr6, 0x830deb04
	if ctx.cr[6].eq {
	pc = 0x830DEB04; continue 'dispatch;
	}
	pc = 0x830DFE1C; continue 'dispatch;
            }
            0x830DFE1C => {
    //   block [0x830DFE1C..0x830DFE28)
	// 830DFE1C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830DFE20: 38210270  addi r1, r1, 0x270
	ctx.r[1].s64 = ctx.r[1].s64 + 624;
	// 830DFE24: 4BBC95FC  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DFE28 => {
    //   block [0x830DFE28..0x830DFE50)
	// 830DFE28: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DFE2C: 419AFFF0  beq cr6, 0x830dfe1c
	if ctx.cr[6].eq {
	pc = 0x830DFE1C; continue 'dispatch;
	}
	// 830DFE30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DFE34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DFE38: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DFE3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DFE40: 4E800421  bctrl
	ctx.lr = 0x830DFE44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DFE44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830DFE48: 38210270  addi r1, r1, 0x270
	ctx.r[1].s64 = ctx.r[1].s64 + 624;
	// 830DFE4C: 4BBC95D4  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            0x830DFE50 => {
    //   block [0x830DFE50..0x830DFE6C)
	// 830DFE50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DFE54: 419A0018  beq cr6, 0x830dfe6c
	if ctx.cr[6].eq {
	pc = 0x830DFE6C; continue 'dispatch;
	}
	// 830DFE58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DFE5C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DFE60: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DFE64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DFE68: 4E800421  bctrl
	ctx.lr = 0x830DFE6C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830DFE6C => {
    //   block [0x830DFE6C..0x830DFE78)
	// 830DFE6C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830DFE70: 38210270  addi r1, r1, 0x270
	ctx.r[1].s64 = ctx.r[1].s64 + 624;
	// 830DFE74: 4BBC95AC  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830DFE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830DFE78 size=404
    let mut pc: u32 = 0x830DFE78;
    'dispatch: loop {
        match pc {
            0x830DFE78 => {
    //   block [0x830DFE78..0x830DFF68)
	// 830DFE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830DFE7C: 4BBC9585  bl 0x82ca9400
	ctx.lr = 0x830DFE80;
	sub_82CA93D0(ctx, base);
	// 830DFE80: 9421FD50  stwu r1, -0x2b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-688 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830DFE84: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 830DFE88: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830DFE8C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830DFE90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830DFE94: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830DFE98: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 830DFE9C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830DFEA0: 807B0008  lwz r3, 8(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DFEA4: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 830DFEA8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830DFEAC: 4BFFC84D  bl 0x830dc6f8
	ctx.lr = 0x830DFEB0;
	sub_830DC6F8(ctx, base);
	// 830DFEB0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DFEB4: 409A014C  bne cr6, 0x830e0000
	if !ctx.cr[6].eq {
	pc = 0x830E0000; continue 'dispatch;
	}
	// 830DFEB8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830DFEBC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DFEC0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830DFEC4: 409A00A4  bne cr6, 0x830dff68
	if !ctx.cr[6].eq {
	pc = 0x830DFF68; continue 'dispatch;
	}
	// 830DFEC8: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DFECC: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830DFED0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830DFED4: 388A9C40  addi r4, r10, -0x63c0
	ctx.r[4].s64 = ctx.r[10].s64 + -25536;
	// 830DFED8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830DFEDC: 4BC78AFD  bl 0x82d589d8
	ctx.lr = 0x830DFEE0;
	sub_82D589D8(ctx, base);
	// 830DFEE0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830DFEE4: 409A00FC  bne cr6, 0x830dffe0
	if !ctx.cr[6].eq {
	pc = 0x830DFFE0; continue 'dispatch;
	}
	// 830DFEE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DFEEC: 4BC75BF5  bl 0x82d55ae0
	ctx.lr = 0x830DFEF0;
	sub_82D55AE0(ctx, base);
	// 830DFEF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830DFEF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 830DFEF8: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830DFEFC: 4800027D  bl 0x830e0178
	ctx.lr = 0x830DFF00;
	sub_830E0178(ctx, base);
	// 830DFF00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DFF04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DFF08: 4BC75BD9  bl 0x82d55ae0
	ctx.lr = 0x830DFF0C;
	sub_82D55AE0(ctx, base);
	// 830DFF0C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830DFF10: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 830DFF14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DFF18: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830DFF1C: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 830DFF20: 396B000F  addi r11, r11, 0xf
	ctx.r[11].s64 = ctx.r[11].s64 + 15;
	// 830DFF24: 556B0036  rlwinm r11, r11, 0, 0, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830DFF28: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830DFF2C: 4BC75825  bl 0x82d55750
	ctx.lr = 0x830DFF30;
	sub_82D55750(ctx, base);
	// 830DFF30: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 830DFF34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830DFF38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830DFF3C: 4BC9746D  bl 0x82d773a8
	ctx.lr = 0x830DFF40;
	sub_82D773A8(ctx, base);
	// 830DFF40: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 830DFF44: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 830DFF48: 80FB0008  lwz r7, 8(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 830DFF4C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830DFF50: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830DFF54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830DFF58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830DFF5C: 4BFFEB3D  bl 0x830dea98
	ctx.lr = 0x830DFF60;
	sub_830DEA98(ctx, base);
	// 830DFF60: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830DFF64: 4800007C  b 0x830dffe0
	pc = 0x830DFFE0; continue 'dispatch;
            }
            0x830DFF68 => {
    //   block [0x830DFF68..0x830DFF7C)
	// 830DFF68: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830DFF6C: 409A0010  bne cr6, 0x830dff7c
	if !ctx.cr[6].eq {
	pc = 0x830DFF7C; continue 'dispatch;
	}
	// 830DFF70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830DFF74: 4BFFBEC5  bl 0x830dbe38
	ctx.lr = 0x830DFF78;
	sub_830DBE38(ctx, base);
	// 830DFF78: 48000068  b 0x830dffe0
	pc = 0x830DFFE0; continue 'dispatch;
            }
            0x830DFF7C => {
    //   block [0x830DFF7C..0x830DFFE0)
	// 830DFF7C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830DFF80: 419A0064  beq cr6, 0x830dffe4
	if ctx.cr[6].eq {
	pc = 0x830DFFE4; continue 'dispatch;
	}
	// 830DFF84: 38A00200  li r5, 0x200
	ctx.r[5].s64 = 512;
	// 830DFF88: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830DFF8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830DFF90: 4BC77A59  bl 0x82d579e8
	ctx.lr = 0x830DFF94;
	sub_82D579E8(ctx, base);
	// 830DFF94: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DFF98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830DFF9C: 388BA58C  addi r4, r11, -0x5a74
	ctx.r[4].s64 = ctx.r[11].s64 + -23156;
	// 830DFFA0: 4BC77E51  bl 0x82d57df0
	ctx.lr = 0x830DFFA4;
	sub_82D57DF0(ctx, base);
	// 830DFFA4: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830DFFA8: 3CA06A85  lis r5, 0x6a85
	ctx.r[5].s64 = 1787101184;
	// 830DFFAC: 390003D6  li r8, 0x3d6
	ctx.r[8].s64 = 982;
	// 830DFFB0: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 830DFFB4: 60A58EC3  ori r5, r5, 0x8ec3
	ctx.r[5].u64 = ctx.r[5].u64 | 36547;
	// 830DFFB8: 806B7630  lwz r3, 0x7630(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30256 as u32) ) } as u64;
	// 830DFFBC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830DFFC0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 830DFFC4: 38EBA530  addi r7, r11, -0x5ad0
	ctx.r[7].s64 = ctx.r[11].s64 + -23248;
	// 830DFFC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DFFCC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830DFFD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DFFD4: 4E800421  bctrl
	ctx.lr = 0x830DFFD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830DFFD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830DFFDC: 4BC78455  bl 0x82d58430
	ctx.lr = 0x830DFFE0;
	sub_82D58430(ctx, base);
            }
            0x830DFFE0 => {
    //   block [0x830DFFE0..0x830DFFE4)
	// 830DFFE0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x830DFFE4; continue 'dispatch;
            }
            0x830DFFE4 => {
    //   block [0x830DFFE4..0x830E0000)
	// 830DFFE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 830DFFE8: 419A0018  beq cr6, 0x830e0000
	if ctx.cr[6].eq {
	pc = 0x830E0000; continue 'dispatch;
	}
	// 830DFFEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DFFF0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830DFFF4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830DFFF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830DFFFC: 4E800421  bctrl
	ctx.lr = 0x830E0000;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830E0000 => {
    //   block [0x830E0000..0x830E000C)
	// 830E0000: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E0004: 382102B0  addi r1, r1, 0x2b0
	ctx.r[1].s64 = ctx.r[1].s64 + 688;
	// 830E0008: 4BBC9448  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E0010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E0010 size=256
    let mut pc: u32 = 0x830E0010;
    'dispatch: loop {
        match pc {
            0x830E0010 => {
    //   block [0x830E0010..0x830E0064)
	// 830E0010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E0014: 4BBC93ED  bl 0x82ca9400
	ctx.lr = 0x830E0018;
	sub_82CA93D0(ctx, base);
	// 830E0018: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E001C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E0020: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 830E0024: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 830E0028: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E002C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830E0030: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830E0034: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E0038: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 830E003C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830E0040: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 830E0044: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 830E0048: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 830E004C: 40990018  ble cr6, 0x830e0064
	if !ctx.cr[6].gt {
	pc = 0x830E0064; continue 'dispatch;
	}
	// 830E0050: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 830E0054: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830E0058: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830E005C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E0060: 4BC76EB1  bl 0x82d56f10
	ctx.lr = 0x830E0064;
	sub_82D56F10(ctx, base);
	pc = 0x830E0064; continue 'dispatch;
            }
            0x830E0064 => {
    //   block [0x830E0064..0x830E00CC)
	// 830E0064: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 830E0068: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830E006C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 830E0070: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830E0074: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E0078: 4BFFFE01  bl 0x830dfe78
	ctx.lr = 0x830E007C;
	sub_830DFE78(ctx, base);
	// 830E007C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830E0080: 409A0058  bne cr6, 0x830e00d8
	if !ctx.cr[6].eq {
	pc = 0x830E00D8; continue 'dispatch;
	}
	// 830E0084: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E0088: 7F05F800  cmpw cr6, r5, r31
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830E008C: 4199004C  bgt cr6, 0x830e00d8
	if ctx.cr[6].gt {
	pc = 0x830E00D8; continue 'dispatch;
	}
	// 830E0090: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830E0094: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E0098: 4BC78C99  bl 0x82d58d30
	ctx.lr = 0x830E009C;
	sub_82D58D30(ctx, base);
	// 830E009C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830E00A0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E00A4: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E00A8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E00AC: 409A0020  bne cr6, 0x830e00cc
	if !ctx.cr[6].eq {
	pc = 0x830E00CC; continue 'dispatch;
	}
	// 830E00B0: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E00B4: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830E00B8: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830E00BC: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E00C0: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830E00C4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830E00C8: 4BC75201  bl 0x82d552c8
	ctx.lr = 0x830E00CC;
	sub_82D552C8(ctx, base);
	pc = 0x830E00CC; continue 'dispatch;
            }
            0x830E00CC => {
    //   block [0x830E00CC..0x830E00D8)
	// 830E00CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E00D0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830E00D4: 4BBC937C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x830E00D8 => {
    //   block [0x830E00D8..0x830E0104)
	// 830E00D8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830E00DC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E00E0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E00E4: 409A0020  bne cr6, 0x830e0104
	if !ctx.cr[6].eq {
	pc = 0x830E0104; continue 'dispatch;
	}
	// 830E00E8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E00EC: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830E00F0: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830E00F4: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E00F8: 556500BE  clrlwi r5, r11, 2
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830E00FC: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830E0100: 4BC751C9  bl 0x82d552c8
	ctx.lr = 0x830E0104;
	sub_82D552C8(ctx, base);
	pc = 0x830E0104; continue 'dispatch;
            }
            0x830E0104 => {
    //   block [0x830E0104..0x830E0110)
	// 830E0104: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 830E0108: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830E010C: 4BBC9344  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E0110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E0110 size=100
    let mut pc: u32 = 0x830E0110;
    'dispatch: loop {
        match pc {
            0x830E0110 => {
    //   block [0x830E0110..0x830E0158)
	// 830E0110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E0114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E0118: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E011C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E0120: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E0124: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E0128: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E012C: 4BFFD87D  bl 0x830dd9a8
	ctx.lr = 0x830E0130;
	sub_830DD9A8(ctx, base);
	// 830E0130: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 830E0134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E0138: 419A0020  beq cr6, 0x830e0158
	if ctx.cr[6].eq {
	pc = 0x830E0158; continue 'dispatch;
	}
	// 830E013C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0140: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830E0144: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 830E0148: A0BF0004  lhz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E014C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E0150: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830E0154: 4BC75175  bl 0x82d552c8
	ctx.lr = 0x830E0158;
	sub_82D552C8(ctx, base);
	pc = 0x830E0158; continue 'dispatch;
            }
            0x830E0158 => {
    //   block [0x830E0158..0x830E0174)
	// 830E0158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E015C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E0160: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E0164: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E0168: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E016C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E0170: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E0178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E0178 size=164
    let mut pc: u32 = 0x830E0178;
    'dispatch: loop {
        match pc {
            0x830E0178 => {
    //   block [0x830E0178..0x830E01D0)
	// 830E0178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E017C: 4BBC9289  bl 0x82ca9404
	ctx.lr = 0x830E0180;
	sub_82CA93D0(ctx, base);
	// 830E0180: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E0184: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830E0188: 3945FFFF  addi r10, r5, -1
	ctx.r[10].s64 = ctx.r[5].s64 + -1;
	// 830E018C: 83DB0000  lwz r30, 0(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0190: 839E0004  lwz r28, 4(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E0194: 7D7C2214  add r11, r28, r4
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[4].u64;
	// 830E0198: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 830E019C: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 830E01A0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830E01A4: 7D7F5078  andc r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 & !ctx.r[10].u64;
	// 830E01A8: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830E01AC: 40990058  ble cr6, 0x830e0204
	if !ctx.cr[6].gt {
	pc = 0x830E0204; continue 'dispatch;
	}
	// 830E01B0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E01B4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830E01B8: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830E01BC: 40980024  bge cr6, 0x830e01e0
	if !ctx.cr[6].lt {
	pc = 0x830E01E0; continue 'dispatch;
	}
	// 830E01C0: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E01C4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E01C8: 41980008  blt cr6, 0x830e01d0
	if ctx.cr[6].lt {
	pc = 0x830E01D0; continue 'dispatch;
	}
	// 830E01CC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x830E01D0; continue 'dispatch;
            }
            0x830E01D0 => {
    //   block [0x830E01D0..0x830E01E0)
	// 830E01D0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830E01D4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830E01D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E01DC: 4BC76D35  bl 0x82d56f10
	ctx.lr = 0x830E01E0;
	sub_82D56F10(ctx, base);
	pc = 0x830E01E0; continue 'dispatch;
            }
            0x830E01E0 => {
    //   block [0x830E01E0..0x830E01F0)
	// 830E01E0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 830E01E4: 7F1DF800  cmpw cr6, r29, r31
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830E01E8: 4098001C  bge cr6, 0x830e0204
	if !ctx.cr[6].lt {
	pc = 0x830E0204; continue 'dispatch;
	}
	// 830E01EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x830E01F0; continue 'dispatch;
            }
            0x830E01F0 => {
    //   block [0x830E01F0..0x830E0204)
	// 830E01F0: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E01F4: 7D4959AE  stbx r10, r9, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u8) };
	// 830E01F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830E01FC: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830E0200: 4198FFF0  blt cr6, 0x830e01f0
	if ctx.cr[6].lt {
	pc = 0x830E01F0; continue 'dispatch;
	}
	pc = 0x830E0204; continue 'dispatch;
            }
            0x830E0204 => {
    //   block [0x830E0204..0x830E021C)
	// 830E0204: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 830E0208: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E020C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0210: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830E0214: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E0218: 4BBC923C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E0220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E0220 size=308
    let mut pc: u32 = 0x830E0220;
    'dispatch: loop {
        match pc {
            0x830E0220 => {
    //   block [0x830E0220..0x830E02F4)
	// 830E0220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E0224: 4BBC91E1  bl 0x82ca9404
	ctx.lr = 0x830E0228;
	sub_82CA93D0(ctx, base);
	// 830E0228: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E022C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830E0230: 91660000  stw r11, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E0234: 4099011C  ble cr6, 0x830e0350
	if !ctx.cr[6].gt {
	pc = 0x830E0350; continue 'dispatch;
	}
	// 830E0238: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830E023C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 830E0240: 3BAB7530  addi r29, r11, 0x7530
	ctx.r[29].s64 = ctx.r[11].s64 + 30000;
	// 830E0244: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E0248: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830E024C: 3B630020  addi r27, r3, 0x20
	ctx.r[27].s64 = ctx.r[3].s64 + 32;
	// 830E0250: C00ABE14  lfs f0, -0x41ec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E0254: 3B8B14A0  addi r28, r11, 0x14a0
	ctx.r[28].s64 = ctx.r[11].s64 + 5280;
	// 830E0258: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830E025C: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 830E0260: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0264: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E0268: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830E026C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E0270: 40990084  ble cr6, 0x830e02f4
	if !ctx.cr[6].gt {
	pc = 0x830E02F4; continue 'dispatch;
	}
	pc = 0x830E02F4; continue 'dispatch;
            }
            0x830E02F4 => {
    //   block [0x830E02F4..0x830E0350)
	// 830E02F4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830E02F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E02FC: 409A0030  bne cr6, 0x830e032c
	if !ctx.cr[6].eq {
	pc = 0x830E032C; continue 'dispatch;
	}
	// 830E0300: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0304: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0308: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830E030C: 7D4B41AE  stbx r10, r11, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[10].u8) };
	// 830E0310: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0314: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 830E0318: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E031C: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x830E0350; continue 'dispatch;
            }
            0x830E0350 => {
    //   block [0x830E0350..0x830E0354)
	// 830E0350: 4BBC9104  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E0358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E0358 size=352
    let mut pc: u32 = 0x830E0358;
    'dispatch: loop {
        match pc {
            0x830E0358 => {
    //   block [0x830E0358..0x830E03B0)
	// 830E0358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E035C: 4BBC90A1  bl 0x82ca93fc
	ctx.lr = 0x830E0360;
	sub_82CA93D0(ctx, base);
	// 830E0360: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E0364: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E0368: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E036C: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 830E0370: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E0374: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 830E0378: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830E037C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830E0380: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E0384: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830E0388: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 830E038C: 55640036  rlwinm r4, r11, 0, 0, 0x1b
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E0390: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E0394: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 830E0398: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 830E039C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830E03A0: 41990010  bgt cr6, 0x830e03b0
	if ctx.cr[6].gt {
	pc = 0x830E03B0; continue 'dispatch;
	}
	// 830E03A4: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 830E03A8: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830E03AC: 48000018  b 0x830e03c4
	pc = 0x830E03C4; continue 'dispatch;
            }
            0x830E03B0 => {
    //   block [0x830E03B0..0x830E03C4)
	// 830E03B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E03B4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830E03B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830E03BC: 4E800421  bctrl
	ctx.lr = 0x830E03C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830E03C0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
            }
            0x830E03C4 => {
    //   block [0x830E03C4..0x830E03F8)
	// 830E03C4: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E03C8: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830E03CC: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 830E03D0: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830E03D4: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 830E03D8: 83C30020  lwz r30, 0x20(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E03DC: 55640036  rlwinm r4, r11, 0, 0, 0x1b
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E03E0: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 830E03E4: 7D7E2214  add r11, r30, r4
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[4].u64;
	// 830E03E8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830E03EC: 4199000C  bgt cr6, 0x830e03f8
	if ctx.cr[6].gt {
	pc = 0x830E03F8; continue 'dispatch;
	}
	// 830E03F0: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830E03F4: 48000018  b 0x830e040c
	pc = 0x830E040C; continue 'dispatch;
            }
            0x830E03F8 => {
    //   block [0x830E03F8..0x830E040C)
	// 830E03F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E03FC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830E0400: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830E0404: 4E800421  bctrl
	ctx.lr = 0x830E0408;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830E0408: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
            }
            0x830E040C => {
    //   block [0x830E040C..0x830E0420)
	// 830E040C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 830E0410: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 830E0414: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 830E0418: 409A0008  bne cr6, 0x830e0420
	if !ctx.cr[6].eq {
	pc = 0x830E0420; continue 'dispatch;
	}
	// 830E041C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x830E0420; continue 'dispatch;
            }
            0x830E0420 => {
    //   block [0x830E0420..0x830E0484)
	// 830E0420: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 830E0424: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830E0428: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830E042C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E0430: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830E0434: 4BFFFDED  bl 0x830e0220
	ctx.lr = 0x830E0438;
	sub_830E0220(ctx, base);
	// 830E0438: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E043C: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830E0440: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830E0444: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830E0448: 57EA103A  slwi r10, r31, 2
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830E044C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E0450: 81230028  lwz r9, 0x28(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830E0454: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 830E0458: 93C30020  stw r30, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 830E045C: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830E0460: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830E0464: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830E0468: 3BEB0020  addi r31, r11, 0x20
	ctx.r[31].s64 = ctx.r[11].s64 + 32;
	// 830E046C: 409A0018  bne cr6, 0x830e0484
	if !ctx.cr[6].eq {
	pc = 0x830E0484; continue 'dispatch;
	}
	// 830E0470: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0474: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E0478: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830E047C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830E0480: 4E800421  bctrl
	ctx.lr = 0x830E0484;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830E0484 => {
    //   block [0x830E0484..0x830E04AC)
	// 830E0484: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830E0488: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830E048C: 93430020  stw r26, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[26].u32 ) };
	// 830E0490: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E0494: 409A0018  bne cr6, 0x830e04ac
	if !ctx.cr[6].eq {
	pc = 0x830E04AC; continue 'dispatch;
	}
	// 830E0498: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E049C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830E04A0: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830E04A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830E04A8: 4E800421  bctrl
	ctx.lr = 0x830E04AC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830E04AC => {
    //   block [0x830E04AC..0x830E04B8)
	// 830E04AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E04B0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830E04B4: 4BBC8F98  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E04B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E04B8 size=752
    let mut pc: u32 = 0x830E04B8;
    'dispatch: loop {
        match pc {
            0x830E04B8 => {
    //   block [0x830E04B8..0x830E0514)
	// 830E04B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E04BC: 4BBC8F31  bl 0x82ca93ec
	ctx.lr = 0x830E04C0;
	sub_82CA93D0(ctx, base);
	// 830E04C0: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E04C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E04C8: 82ED0000  lwz r23, 0(r13)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E04CC: 3B000004  li r24, 4
	ctx.r[24].s64 = 4;
	// 830E04D0: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E04D4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830E04D8: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830E04DC: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 830E04E0: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E04E4: 7C78B82E  lwzx r3, r24, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 830E04E8: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 830E04EC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 830E04F0: 55640036  rlwinm r4, r11, 0, 0, 0x1b
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E04F4: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E04F8: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 830E04FC: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 830E0500: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830E0504: 41990010  bgt cr6, 0x830e0514
	if ctx.cr[6].gt {
	pc = 0x830E0514; continue 'dispatch;
	}
	// 830E0508: 7D795B78  mr r25, r11
	ctx.r[25].u64 = ctx.r[11].u64;
	// 830E050C: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830E0510: 48000018  b 0x830e0528
	pc = 0x830E0528; continue 'dispatch;
            }
            0x830E0514 => {
    //   block [0x830E0514..0x830E0528)
	// 830E0514: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0518: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830E051C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830E0520: 4E800421  bctrl
	ctx.lr = 0x830E0524;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830E0524: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
            }
            0x830E0528 => {
    //   block [0x830E0528..0x830E0560)
	// 830E0528: 57EA083C  slwi r10, r31, 1
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830E052C: 7C78B82E  lwzx r3, r24, r23
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 830E0530: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 830E0534: 7F9F5214  add r28, r31, r10
	ctx.r[28].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 830E0538: 395C0010  addi r10, r28, 0x10
	ctx.r[10].s64 = ctx.r[28].s64 + 16;
	// 830E053C: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E0540: 55440036  rlwinm r4, r10, 0, 0, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 830E0544: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 830E0548: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 830E054C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830E0550: 41990010  bgt cr6, 0x830e0560
	if ctx.cr[6].gt {
	pc = 0x830E0560; continue 'dispatch;
	}
	// 830E0554: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 830E0558: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830E055C: 48000018  b 0x830e0574
	pc = 0x830E0574; continue 'dispatch;
            }
            0x830E0560 => {
    //   block [0x830E0560..0x830E0574)
	// 830E0560: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0564: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830E0568: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830E056C: 4E800421  bctrl
	ctx.lr = 0x830E0570;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830E0570: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
            }
            0x830E0574 => {
    //   block [0x830E0574..0x830E07A8)
	// 830E0574: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 830E0578: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 830E057C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830E0580: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830E0584: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E0588: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830E058C: 4BFFFC95  bl 0x830e0220
	ctx.lr = 0x830E0590;
	sub_830E0220(ctx, base);
	// 830E0590: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E0594: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 830E0598: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830E059C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 830E05A0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 830E05A4: 4BCE1B25  bl 0x82dc20c8
	ctx.lr = 0x830E05A8;
	sub_82DC20C8(ctx, base);
	// 830E05A8: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 830E05AC: C0010090  lfs f0, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E05B0: 9BA1007C  stb r29, 0x7c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u8 ) };
	// 830E05B4: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830E05B8: 3BD60020  addi r30, r22, 0x20
	ctx.r[30].s64 = ctx.r[22].s64 + 32;
	// 830E05BC: C0010094  lfs f0, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E05C0: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830E05C4: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E07A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E07A8 size=344
    let mut pc: u32 = 0x830E07A8;
    'dispatch: loop {
        match pc {
            0x830E07A8 => {
    //   block [0x830E07A8..0x830E0824)
	// 830E07A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E07AC: 4BBC8C5D  bl 0x82ca9408
	ctx.lr = 0x830E07B0;
	sub_82CA93D0(ctx, base);
	// 830E07B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E07B4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830E07B8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E07BC: 4BCD6D4D  bl 0x82db7508
	ctx.lr = 0x830E07C0;
	sub_82DB7508(ctx, base);
	// 830E07C0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 830E07C4: 3BFC0060  addi r31, r28, 0x60
	ctx.r[31].s64 = ctx.r[28].s64 + 96;
	// 830E07C8: 396B082C  addi r11, r11, 0x82c
	ctx.r[11].s64 = ctx.r[11].s64 + 2092;
	// 830E07CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830E07D0: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 830E07D4: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E07D8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830E07DC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830E07E0: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830E07E4: 9BBC006C  stb r29, 0x6c(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(108 as u32), ctx.r[29].u8 ) };
	// 830E07E8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E07EC: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E07F0: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830E07F4: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830E07F8: 40980060  bge cr6, 0x830e0858
	if !ctx.cr[6].lt {
	pc = 0x830E0858; continue 'dispatch;
	}
	// 830E07FC: 556B0000  rlwinm r11, r11, 0, 0, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E0800: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E0804: 409A0020  bne cr6, 0x830e0824
	if !ctx.cr[6].eq {
	pc = 0x830E0824; continue 'dispatch;
	}
	// 830E0808: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E080C: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830E0810: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830E0814: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0818: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830E081C: 7C69582E  lwzx r3, r9, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830E0820: 4BC74AA9  bl 0x82d552c8
	ctx.lr = 0x830E0824;
	sub_82D552C8(ctx, base);
	pc = 0x830E0824; continue 'dispatch;
            }
            0x830E0824 => {
    //   block [0x830E0824..0x830E0858)
	// 830E0824: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0828: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830E082C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E0830: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 830E0834: 5524103A  slwi r4, r9, 2
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830E0838: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830E083C: 4BC74A0D  bl 0x82d55248
	ctx.lr = 0x830E0840;
	sub_82D55248(ctx, base);
	// 830E0840: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E0844: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830E0848: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E084C: 556B0042  rlwinm r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E0850: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 830E0854: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x830E0858; continue 'dispatch;
            }
            0x830E0858 => {
    //   block [0x830E0858..0x830E0890)
	// 830E0858: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E085C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830E0860: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0864: 2F080004  cmpwi cr6, r8, 4
	ctx.cr[6].compare_i32(ctx.r[8].s32, 4, &mut ctx.xer);
	// 830E0868: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 830E086C: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0870: 41980054  blt cr6, 0x830e08c4
	if ctx.cr[6].lt {
	pc = 0x830E08C4; continue 'dispatch;
	}
	// 830E0874: 3968FFFC  addi r11, r8, -4
	ctx.r[11].s64 = ctx.r[8].s64 + -4;
	// 830E0878: 3945000C  addi r10, r5, 0xc
	ctx.r[10].s64 = ctx.r[5].s64 + 12;
	// 830E087C: 5569F0BE  srwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830E0880: 39670004  addi r11, r7, 4
	ctx.r[11].s64 = ctx.r[7].s64 + 4;
	// 830E0884: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830E0888: 7C872850  subf r4, r7, r5
	ctx.r[4].s64 = ctx.r[5].s64 - ctx.r[7].s64;
	// 830E088C: 5526103A  slwi r6, r9, 2
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	pc = 0x830E0890; continue 'dispatch;
            }
            0x830E0890 => {
    //   block [0x830E0890..0x830E08C4)
	// 830E0890: C00AFFF4  lfs f0, -0xc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E0894: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 830E0898: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 830E089C: 7C045C2E  lfsx f0, r4, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E08A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830E08A4: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830E08A8: C00AFFFC  lfs f0, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E08AC: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830E08B0: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E08B4: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 830E08B8: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830E08BC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 830E08C0: 409AFFD0  bne cr6, 0x830e0890
	if !ctx.cr[6].eq {
	pc = 0x830E0890; continue 'dispatch;
	}
	pc = 0x830E08C4; continue 'dispatch;
            }
            0x830E08C4 => {
    //   block [0x830E08C4..0x830E08DC)
	// 830E08C4: 7F064000  cmpw cr6, r6, r8
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830E08C8: 4098002C  bge cr6, 0x830e08f4
	if !ctx.cr[6].lt {
	pc = 0x830E08F4; continue 'dispatch;
	}
	// 830E08CC: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E08D0: 7D272850  subf r9, r7, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[7].s64;
	// 830E08D4: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 830E08D8: 7D464050  subf r10, r6, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[6].s64;
	pc = 0x830E08DC; continue 'dispatch;
            }
            0x830E08DC => {
    //   block [0x830E08DC..0x830E08F4)
	// 830E08DC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 830E08E0: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E08E4: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830E08E8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830E08EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830E08F0: 409AFFEC  bne cr6, 0x830e08dc
	if !ctx.cr[6].eq {
	pc = 0x830E08DC; continue 'dispatch;
	}
	pc = 0x830E08F4; continue 'dispatch;
            }
            0x830E08F4 => {
    //   block [0x830E08F4..0x830E0900)
	// 830E08F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E08F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830E08FC: 4BBC8B5C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E0900(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E0900 size=368
    let mut pc: u32 = 0x830E0900;
    'dispatch: loop {
        match pc {
            0x830E0900 => {
    //   block [0x830E0900..0x830E0A70)
	// 830E0900: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E0904: 4BBC8AF5  bl 0x82ca93f8
	ctx.lr = 0x830E0908;
	sub_82CA93D0(ctx, base);
	// 830E0908: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E090C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E0910: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830E0914: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 830E0918: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 830E091C: 396B082C  addi r11, r11, 0x82c
	ctx.r[11].s64 = ctx.r[11].s64 + 2092;
	// 830E0920: 39200018  li r9, 0x18
	ctx.r[9].s64 = 24;
	// 830E0924: B15F0006  sth r10, 6(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 830E0928: 3B9F0060  addi r28, r31, 0x60
	ctx.r[28].s64 = ctx.r[31].s64 + 96;
	// 830E092C: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 830E0930: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E0934: 931F0008  stw r24, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 830E0938: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E093C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E0940: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 830E0944: 931C0000  stw r24, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 830E0948: 931C0004  stw r24, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 830E094C: 915C0008  stw r10, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830E0950: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E0954: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830E0958: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 830E095C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830E0960: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0964: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 830E0968: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830E096C: 4E800421  bctrl
	ctx.lr = 0x830E0970;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830E0970: 80FF0014  lwz r7, 0x14(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830E0974: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E0978: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 830E097C: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 830E0980: 7FA731D6  mullw r29, r7, r6
	ctx.r[29].s32 = ((ctx.r[7].s32 as i64 * ctx.r[6].s32 as i64) as i32);
	ctx.r[29].s64 = ctx.r[29].s32 as i64;
	// 830E0984: 88E30000  lbz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0988: 98FF006C  stb r7, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[7].u8 ) };
	// 830E098C: C01E0018  lfs f0, 0x18(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E0990: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E0A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E0A70 size=816
    let mut pc: u32 = 0x830E0A70;
    'dispatch: loop {
        match pc {
            0x830E0A70 => {
    //   block [0x830E0A70..0x830E0AEC)
	// 830E0A70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E0A74: 4BBC8985  bl 0x82ca93f8
	ctx.lr = 0x830E0A78;
	sub_82CA93D0(ctx, base);
	// 830E0A78: A1640004  lhz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E0A7C: 3BE00030  li r31, 0x30
	ctx.r[31].s64 = 48;
	// 830E0A80: A1240006  lhz r9, 6(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 830E0A84: 3F408200  lis r26, -0x7e00
	ctx.r[26].s64 = -2113929216;
	// 830E0A88: 556A383E  rotlwi r10, r11, 7
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(7)) as u64;
	// 830E0A8C: 552B383E  rotlwi r11, r9, 7
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(7)) as u64;
	// 830E0A90: 7D0A2A14  add r8, r10, r5
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 830E0A94: 7FCB2A14  add r30, r11, r5
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 830E0A98: 39640010  addi r11, r4, 0x10
	ctx.r[11].s64 = ctx.r[4].s64 + 16;
	// 830E0A9C: C01A0C18  lfs f0, 0xc18(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E0AA0: 38A80010  addi r5, r8, 0x10
	ctx.r[5].s64 = ctx.r[8].s64 + 16;
	// 830E0AA4: 38880020  addi r4, r8, 0x20
	ctx.r[4].s64 = ctx.r[8].s64 + 32;
	pc = 0x830E0AEC; continue 'dispatch;
            }
            0x830E0AEC => {
    //   block [0x830E0AEC..0x830E0B78)
	// 830E0AEC: 890B0003  lbz r8, 3(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 830E0AF0: 7D1A0774  extsb r26, r8
	ctx.r[26].s64 = ctx.r[8].s8 as i64;
	// 830E0AF4: 2B1A0018  cmplwi cr6, r26, 0x18
	ctx.cr[6].compare_u32(ctx.r[26].u32, 24 as u32, &mut ctx.xer);
	// 830E0AF8: 4199FFF4  bgt cr6, 0x830e0aec
	if ctx.cr[6].gt {
	pc = 0x830E0AEC; continue 'dispatch;
	}
	// 830E0AFC: 3D80830E  lis r12, -0x7cf2
	ctx.r[12].s64 = -2096234496;
	// 830E0B00: 398C0B14  addi r12, r12, 0xb14
	ctx.r[12].s64 = ctx.r[12].s64 + 2836;
	// 830E0B04: 5740103A  slwi r0, r26, 2
	ctx.r[0].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 830E0B08: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 830E0B0C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 830E0B10: 4E800420  bctr
	match ctx.r[26].u64 {
		0 => {
	pc = 0x830E0D9C; continue 'dispatch;
		},
		1 => {
	pc = 0x830E0D9C; continue 'dispatch;
		},
		2 => {
	pc = 0x830E0B9C; continue 'dispatch;
		},
		3 => {
	pc = 0x830E0B78; continue 'dispatch;
		},
		4 => {
	pc = 0x830E0AEC; continue 'dispatch;
		},
		5 => {
	pc = 0x830E0CD4; continue 'dispatch;
		},
		6 => {
	pc = 0x830E0D38; continue 'dispatch;
		},
		7 => {
	pc = 0x830E0B78; continue 'dispatch;
		},
		8 => {
	pc = 0x830E0B78; continue 'dispatch;
		},
		9 => {
	pc = 0x830E0B78; continue 'dispatch;
		},
		10 => {
	pc = 0x830E0AEC; continue 'dispatch;
		},
		11 => {
	pc = 0x830E0B78; continue 'dispatch;
		},
		12 => {
	pc = 0x830E0B78; continue 'dispatch;
		},
		13 => {
	pc = 0x830E0B78; continue 'dispatch;
		},
		14 => {
	pc = 0x830E0B78; continue 'dispatch;
		},
		15 => {
	pc = 0x830E0BA8; continue 'dispatch;
		},
		16 => {
	pc = 0x830E0BA8; continue 'dispatch;
		},
		17 => {
	pc = 0x830E0BA8; continue 'dispatch;
		},
		18 => {
	pc = 0x830E0BA8; continue 'dispatch;
		},
		19 => {
	pc = 0x830E0C14; continue 'dispatch;
		},
		20 => {
	pc = 0x830E0C14; continue 'dispatch;
		},
		21 => {
	pc = 0x830E0D9C; continue 'dispatch;
		},
		22 => {
	pc = 0x830E0D9C; continue 'dispatch;
		},
		23 => {
	pc = 0x830E0B78; continue 'dispatch;
		},
		24 => {
	pc = 0x830E0B78; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 830E0B14: 830E0D9C  lwz r24, 0xd9c(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(3484 as u32) ) } as u64;
	// 830E0B18: 830E0D9C  lwz r24, 0xd9c(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(3484 as u32) ) } as u64;
	// 830E0B1C: 830E0B9C  lwz r24, 0xb9c(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(2972 as u32) ) } as u64;
	// 830E0B20: 830E0B78  lwz r24, 0xb78(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(2936 as u32) ) } as u64;
	// 830E0B24: 830E0AEC  lwz r24, 0xaec(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(2796 as u32) ) } as u64;
	// 830E0B28: 830E0CD4  lwz r24, 0xcd4(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(3284 as u32) ) } as u64;
	// 830E0B2C: 830E0D38  lwz r24, 0xd38(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(3384 as u32) ) } as u64;
	// 830E0B30: 830E0B78  lwz r24, 0xb78(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(2936 as u32) ) } as u64;
	// 830E0B34: 830E0B78  lwz r24, 0xb78(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(2936 as u32) ) } as u64;
	// 830E0B38: 830E0B78  lwz r24, 0xb78(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(2936 as u32) ) } as u64;
	// 830E0B3C: 830E0AEC  lwz r24, 0xaec(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(2796 as u32) ) } as u64;
	// 830E0B40: 830E0B78  lwz r24, 0xb78(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(2936 as u32) ) } as u64;
	// 830E0B44: 830E0B78  lwz r24, 0xb78(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(2936 as u32) ) } as u64;
	// 830E0B48: 830E0B78  lwz r24, 0xb78(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(2936 as u32) ) } as u64;
	// 830E0B4C: 830E0B78  lwz r24, 0xb78(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(2936 as u32) ) } as u64;
	// 830E0B50: 830E0BA8  lwz r24, 0xba8(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(2984 as u32) ) } as u64;
	// 830E0B54: 830E0BA8  lwz r24, 0xba8(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(2984 as u32) ) } as u64;
	// 830E0B58: 830E0BA8  lwz r24, 0xba8(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(2984 as u32) ) } as u64;
	// 830E0B5C: 830E0BA8  lwz r24, 0xba8(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(2984 as u32) ) } as u64;
	// 830E0B60: 830E0C14  lwz r24, 0xc14(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(3092 as u32) ) } as u64;
	// 830E0B64: 830E0C14  lwz r24, 0xc14(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(3092 as u32) ) } as u64;
	// 830E0B68: 830E0D9C  lwz r24, 0xd9c(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(3484 as u32) ) } as u64;
	// 830E0B6C: 830E0D9C  lwz r24, 0xd9c(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(3484 as u32) ) } as u64;
	// 830E0B70: 830E0B78  lwz r24, 0xb78(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(2936 as u32) ) } as u64;
	// 830E0B74: 830E0B78  lwz r24, 0xb78(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(2936 as u32) ) } as u64;
            }
            0x830E0B78 => {
    //   block [0x830E0B78..0x830E0B9C)
	// 830E0B78: 7F5A0774  extsb r26, r26
	ctx.r[26].s64 = ctx.r[26].s8 as i64;
	// 830E0B7C: 7D080774  extsb r8, r8
	ctx.r[8].s64 = ctx.r[8].s8 as i64;
	// 830E0B80: 7D08C8AE  lbzx r8, r8, r25
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 830E0B84: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 830E0B88: 890B0003  lbz r8, 3(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 830E0B8C: 7D180774  extsb r24, r8
	ctx.r[24].s64 = ctx.r[8].s8 as i64;
	// 830E0B90: 7F18D000  cmpw cr6, r24, r26
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[26].s32, &mut ctx.xer);
	// 830E0B94: 419AFFE8  beq cr6, 0x830e0b7c
	if ctx.cr[6].eq {
	pc = 0x830E0B7C; continue 'dispatch;
	}
	// 830E0B98: 4BFFFF54  b 0x830e0aec
	pc = 0x830E0AEC; continue 'dispatch;
            }
            0x830E0B9C => {
    //   block [0x830E0B9C..0x830E0BA8)
	// 830E0B9C: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E0BA0: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 830E0BA4: 4BFFFF48  b 0x830e0aec
	pc = 0x830E0AEC; continue 'dispatch;
            }
            0x830E0BA8 => {
    //   block [0x830E0BA8..0x830E0C14)
	// 830E0BA8: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 830E0BAC: 419901F0  bgt cr6, 0x830e0d9c
	if ctx.cr[6].gt {
	pc = 0x830E0D9C; continue 'dispatch;
	}
	pc = 0x830E0C14; continue 'dispatch;
            }
            0x830E0C14 => {
    //   block [0x830E0C14..0x830E0CD4)
	// 830E0C14: 7F093000  cmpw cr6, r9, r6
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[6].s32, &mut ctx.xer);
	// 830E0C18: 41990184  bgt cr6, 0x830e0d9c
	if ctx.cr[6].gt {
	pc = 0x830E0D9C; continue 'dispatch;
	}
	pc = 0x830E0CD4; continue 'dispatch;
            }
            0x830E0CD4 => {
    //   block [0x830E0CD4..0x830E0D38)
	// 830E0CD4: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 830E0CD8: 419900C4  bgt cr6, 0x830e0d9c
	if ctx.cr[6].gt {
	pc = 0x830E0D9C; continue 'dispatch;
	}
	pc = 0x830E0D38; continue 'dispatch;
            }
            0x830E0D38 => {
    //   block [0x830E0D38..0x830E0D9C)
	// 830E0D38: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 830E0D3C: 41990060  bgt cr6, 0x830e0d9c
	if ctx.cr[6].gt {
	pc = 0x830E0D9C; continue 'dispatch;
	}
	pc = 0x830E0D9C; continue 'dispatch;
            }
            0x830E0D9C => {
    //   block [0x830E0D9C..0x830E0DA0)
	// 830E0D9C: 4BBC86AC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E0DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E0DA0 size=244
    let mut pc: u32 = 0x830E0DA0;
    'dispatch: loop {
        match pc {
            0x830E0DA0 => {
    //   block [0x830E0DA0..0x830E0E28)
	// 830E0DA0: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 830E0DA4: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 830E0DA8: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 830E0DAC: 3BC30030  addi r30, r3, 0x30
	ctx.r[30].s64 = ctx.r[3].s64 + 48;
	// 830E0DB0: 354BFFFF  addic. r10, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E0DB4: 408100D4  ble 0x830e0e88
	if !ctx.cr[0].gt {
	pc = 0x830E0E88; continue 'dispatch;
	}
	// 830E0DB8: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 830E0DBC: 38A30004  addi r5, r3, 4
	ctx.r[5].s64 = ctx.r[3].s64 + 4;
	// 830E0DC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E0DC4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E0DC8: 409800A4  bge cr6, 0x830e0e6c
	if !ctx.cr[6].lt {
	pc = 0x830E0E6C; continue 'dispatch;
	}
	// 830E0DCC: 3945FFFC  addi r10, r5, -4
	ctx.r[10].s64 = ctx.r[5].s64 + -4;
	// 830E0DD0: 3965000C  addi r11, r5, 0xc
	ctx.r[11].s64 = ctx.r[5].s64 + 12;
	// 830E0DD4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0DD8: 81050000  lwz r8, 0(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0DDC: 80E90030  lwz r7, 0x30(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) } as u64;
	// 830E0DE0: 80C80030  lwz r6, 0x30(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(48 as u32) ) } as u64;
	// 830E0DE4: 7F063800  cmpw cr6, r6, r7
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[7].s32, &mut ctx.xer);
	// 830E0DE8: 41980070  blt cr6, 0x830e0e58
	if ctx.cr[6].lt {
	pc = 0x830E0E58; continue 'dispatch;
	}
	// 830E0DEC: 409A003C  bne cr6, 0x830e0e28
	if !ctx.cr[6].eq {
	pc = 0x830E0E28; continue 'dispatch;
	}
	// 830E0DF0: 39080010  addi r8, r8, 0x10
	ctx.r[8].s64 = ctx.r[8].s64 + 16;
	// 830E0DF4: 38E1FFE0  addi r7, r1, -0x20
	ctx.r[7].s64 = ctx.r[1].s64 + -32;
	// 830E0DF8: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 830E0DFC: 38C1FFE4  addi r6, r1, -0x1c
	ctx.r[6].s64 = ctx.r[1].s64 + -28;
	pc = 0x830E0E28; continue 'dispatch;
            }
            0x830E0E28 => {
    //   block [0x830E0E28..0x830E0E58)
	// 830E0E28: 80CBFFFC  lwz r6, -4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830E0E2C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0E30: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E0E34: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E0E38: 90CA0000  stw r6, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 830E0E3C: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0E40: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 830E0E44: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E0E48: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 830E0E4C: 912BFFFC  stw r9, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[9].u32 ) };
	// 830E0E50: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830E0E54: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	pc = 0x830E0E58; continue 'dispatch;
            }
            0x830E0E58 => {
    //   block [0x830E0E58..0x830E0E6C)
	// 830E0E58: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0E5C: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 830E0E60: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 830E0E64: 7F044800  cmpw cr6, r4, r9
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830E0E68: 4198FF6C  blt cr6, 0x830e0dd4
	if ctx.cr[6].lt {
	pc = 0x830E0DD4; continue 'dispatch;
	}
	pc = 0x830E0E6C; continue 'dispatch;
            }
            0x830E0E6C => {
    //   block [0x830E0E6C..0x830E0E88)
	// 830E0E6C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E0E70: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830E0E74: 38A5000C  addi r5, r5, 0xc
	ctx.r[5].s64 = ctx.r[5].s64 + 12;
	// 830E0E78: 395FFFFF  addi r10, r31, -1
	ctx.r[10].s64 = ctx.r[31].s64 + -1;
	// 830E0E7C: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 830E0E80: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830E0E84: 4198FF3C  blt cr6, 0x830e0dc0
	if ctx.cr[6].lt {
	pc = 0x830E0DC0; continue 'dispatch;
	}
	pc = 0x830E0E88; continue 'dispatch;
            }
            0x830E0E88 => {
    //   block [0x830E0E88..0x830E0E94)
	// 830E0E88: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E0E8C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 830E0E90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E0E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E0E98 size=68
    let mut pc: u32 = 0x830E0E98;
    'dispatch: loop {
        match pc {
            0x830E0E98 => {
    //   block [0x830E0E98..0x830E0EDC)
	// 830E0E98: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E0EE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E0EE0 size=360
    let mut pc: u32 = 0x830E0EE0;
    'dispatch: loop {
        match pc {
            0x830E0EE0 => {
    //   block [0x830E0EE0..0x830E1048)
	// 830E0EE0: 39640010  addi r11, r4, 0x10
	ctx.r[11].s64 = ctx.r[4].s64 + 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E1048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E1048 size=168
    let mut pc: u32 = 0x830E1048;
    'dispatch: loop {
        match pc {
            0x830E1048 => {
    //   block [0x830E1048..0x830E10F0)
	// 830E1048: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E10F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E10F0 size=816
    let mut pc: u32 = 0x830E10F0;
    'dispatch: loop {
        match pc {
            0x830E10F0 => {
    //   block [0x830E10F0..0x830E1420)
	// 830E10F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E10F4: 4BBC8319  bl 0x82ca940c
	ctx.lr = 0x830E10F8;
	sub_82CA93D0(ctx, base);
	// 830E10F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E10FC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E1100: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E1104: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830E1108: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 830E110C: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E1420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E1420 size=616
    let mut pc: u32 = 0x830E1420;
    'dispatch: loop {
        match pc {
            0x830E1420 => {
    //   block [0x830E1420..0x830E1688)
	// 830E1420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E1424: 4BBC7FE1  bl 0x82ca9404
	ctx.lr = 0x830E1428;
	sub_82CA93D0(ctx, base);
	// 830E1428: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E142C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E1430: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830E1434: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E1438: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830E143C: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E1688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E1688 size=1524
    let mut pc: u32 = 0x830E1688;
    'dispatch: loop {
        match pc {
            0x830E1688 => {
    //   block [0x830E1688..0x830E16F4)
	// 830E1688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E168C: 4BBC7D5D  bl 0x82ca93e8
	ctx.lr = 0x830E1690;
	sub_82CA93D0(ctx, base);
	// 830E1690: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E1694: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E1698: 3D405555  lis r10, 0x5555
	ctx.r[10].s64 = 1431633920;
	// 830E169C: 3B030030  addi r24, r3, 0x30
	ctx.r[24].s64 = ctx.r[3].s64 + 48;
	// 830E16A0: 3B400010  li r26, 0x10
	ctx.r[26].s64 = 16;
	// 830E16A4: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 830E16A8: C08B0A58  lfs f4, 0xa58(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2648 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 830E16AC: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	// 830E16B0: 3AC00002  li r22, 2
	ctx.r[22].s64 = 2;
	// 830E16B4: 615E5556  ori r30, r10, 0x5556
	ctx.r[30].u64 = ctx.r[10].u64 | 21846;
	// 830E16B8: 3AE00003  li r23, 3
	ctx.r[23].s64 = 3;
	// 830E16BC: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E16C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830E16C4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 830E16C8: 419905AC  bgt cr6, 0x830e1c74
	if ctx.cr[6].gt {
	pc = 0x830E1C74; continue 'dispatch;
	}
	// 830E16CC: 3D80830E  lis r12, -0x7cf2
	ctx.r[12].s64 = -2096234496;
	// 830E16D0: 398C16E4  addi r12, r12, 0x16e4
	ctx.r[12].s64 = ctx.r[12].s64 + 5860;
	// 830E16D4: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 830E16D8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 830E16DC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 830E16E0: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x830E1B24; continue 'dispatch;
		},
		1 => {
	pc = 0x830E1B44; continue 'dispatch;
		},
		2 => {
	pc = 0x830E16F4; continue 'dispatch;
		},
		3 => {
	pc = 0x830E18A0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 830E16E4: 830E1B24  lwz r24, 0x1b24(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(6948 as u32) ) } as u64;
	// 830E16E8: 830E1B44  lwz r24, 0x1b44(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(6980 as u32) ) } as u64;
	// 830E16EC: 830E16F4  lwz r24, 0x16f4(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(5876 as u32) ) } as u64;
	// 830E16F0: 830E18A0  lwz r24, 0x18a0(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(6304 as u32) ) } as u64;
            }
            0x830E16F4 => {
    //   block [0x830E16F4..0x830E18A0)
	// 830E16F4: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 830E16F8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830E16FC: 8083001C  lwz r4, 0x1c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 830E1700: 3B630038  addi r27, r3, 0x38
	ctx.r[27].s64 = ctx.r[3].s64 + 56;
	// 830E1704: 38AB0010  addi r5, r11, 0x10
	ctx.r[5].s64 = ctx.r[11].s64 + 16;
	// 830E1708: 3B23001C  addi r25, r3, 0x1c
	ctx.r[25].s64 = ctx.r[3].s64 + 28;
	// 830E170C: 4BFFF7D5  bl 0x830e0ee0
	ctx.lr = 0x830E1710;
	sub_830E0EE0(ctx, base);
	// 830E1710: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E1714: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 830E1718: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	pc = 0x830E18A0; continue 'dispatch;
            }
            0x830E18A0 => {
    //   block [0x830E18A0..0x830E1B24)
	// 830E18A0: 4BFFF501  bl 0x830e0da0
	ctx.lr = 0x830E18A4;
	sub_830E0DA0(ctx, base);
	// 830E18A4: 7E9FA378  mr r31, r20
	ctx.r[31].u64 = ctx.r[20].u64;
	// 830E18A8: 3B830038  addi r28, r3, 0x38
	ctx.r[28].s64 = ctx.r[3].s64 + 56;
	// 830E18AC: 3B630028  addi r27, r3, 0x28
	ctx.r[27].s64 = ctx.r[3].s64 + 40;
	// 830E18B0: 397F0002  addi r11, r31, 2
	ctx.r[11].s64 = ctx.r[31].s64 + 2;
	// 830E18B4: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E18B8: 395F0001  addi r10, r31, 1
	ctx.r[10].s64 = ctx.r[31].s64 + 1;
	// 830E18BC: 80DB0000  lwz r6, 0(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E18C0: 7CABF096  mulhw r5, r11, r30
	ctx.r[5].s64 = ((ctx.r[11].s32 as i64 * ctx.r[30].s32 as i64) >> 32);
	// 830E18C4: 54BD0FFE  srwi r29, r5, 0x1f
	ctx.r[29].u32 = ctx.r[5].u32.wrapping_shr(31);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 830E18C8: 7C8AF096  mulhw r4, r10, r30
	ctx.r[4].s64 = ((ctx.r[10].s32 as i64 * ctx.r[30].s32 as i64) >> 32);
	// 830E18CC: 7CA5EA14  add r5, r5, r29
	ctx.r[5].u64 = ctx.r[5].u64 + ctx.r[29].u64;
	// 830E18D0: 549D0FFE  srwi r29, r4, 0x1f
	ctx.r[29].u32 = ctx.r[4].u32.wrapping_shr(31);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 830E18D4: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 830E18D8: 39080010  addi r8, r8, 0x10
	ctx.r[8].s64 = ctx.r[8].s64 + 16;
	// 830E18DC: 7C84EA14  add r4, r4, r29
	ctx.r[4].u64 = ctx.r[4].u64 + ctx.r[29].u64;
	// 830E18E0: 54BD083C  slwi r29, r5, 1
	ctx.r[29].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 830E18E4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830E18E8: 7CA5EA14  add r5, r5, r29
	ctx.r[5].u64 = ctx.r[5].u64 + ctx.r[29].u64;
	// 830E18EC: 7D655850  subf r11, r5, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 830E18F0: 5485083C  slwi r5, r4, 1
	ctx.r[5].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830E18F4: 7CA42A14  add r5, r4, r5
	ctx.r[5].u64 = ctx.r[4].u64 + ctx.r[5].u64;
	// 830E18F8: 7D455050  subf r10, r5, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[5].s64;
	// 830E18FC: 5565083C  slwi r5, r11, 1
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830E1900: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 830E1904: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E1908: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 830E190C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E1910: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E1914: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830E1918: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E191C: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 830E1920: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E1924: 4BFFFAFD  bl 0x830e1420
	ctx.lr = 0x830E1928;
	sub_830E1420(ctx, base);
	// 830E1928: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 830E192C: 3921005C  addi r9, r1, 0x5c
	ctx.r[9].s64 = ctx.r[1].s64 + 92;
	pc = 0x830E1B24; continue 'dispatch;
            }
            0x830E1B24 => {
    //   block [0x830E1B24..0x830E1B44)
	// 830E1B24: 8143003C  lwz r10, 0x3c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 830E1B28: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 830E1B2C: 38CA0010  addi r6, r10, 0x10
	ctx.r[6].s64 = ctx.r[10].s64 + 16;
	// 830E1B30: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E1B34: 38AB0010  addi r5, r11, 0x10
	ctx.r[5].s64 = ctx.r[11].s64 + 16;
	// 830E1B38: 4BFFF3A9  bl 0x830e0ee0
	ctx.lr = 0x830E1B3C;
	sub_830E0EE0(ctx, base);
	// 830E1B3C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 830E1B40: 4BBC78F8  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            0x830E1B44 => {
    //   block [0x830E1B44..0x830E1C74)
	// 830E1B44: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 830E1B48: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 830E1B4C: 80830010  lwz r4, 0x10(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E1B50: 38E30038  addi r7, r3, 0x38
	ctx.r[7].s64 = ctx.r[3].s64 + 56;
	// 830E1B54: 38AB0010  addi r5, r11, 0x10
	ctx.r[5].s64 = ctx.r[11].s64 + 16;
	// 830E1B58: 3BE30010  addi r31, r3, 0x10
	ctx.r[31].s64 = ctx.r[3].s64 + 16;
	// 830E1B5C: 4BFFF385  bl 0x830e0ee0
	ctx.lr = 0x830E1B60;
	sub_830E0EE0(ctx, base);
	// 830E1B60: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E1B64: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	pc = 0x830E1C74; continue 'dispatch;
            }
            0x830E1C74 => {
    //   block [0x830E1C74..0x830E1C7C)
	// 830E1C74: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 830E1C78: 4BBC77C0  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E1C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E1C80 size=780
    let mut pc: u32 = 0x830E1C80;
    'dispatch: loop {
        match pc {
            0x830E1C80 => {
    //   block [0x830E1C80..0x830E1F8C)
	// 830E1C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E1C84: 4BBC7769  bl 0x82ca93ec
	ctx.lr = 0x830E1C88;
	sub_82CA93D0(ctx, base);
	// 830E1C88: DBC1FF90  stfd f30, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 830E1C8C: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 830E1C90: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E1C94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E1C98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E1C9C: 3B000010  li r24, 0x10
	ctx.r[24].s64 = 16;
	// 830E1CA0: 3B7E0010  addi r27, r30, 0x10
	ctx.r[27].s64 = ctx.r[30].s64 + 16;
	// 830E1CA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E1CA8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830E1CAC: C03F0040  lfs f1, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830E1CB0: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E1F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E1F90 size=8
    let mut pc: u32 = 0x830E1F90;
    'dispatch: loop {
        match pc {
            0x830E1F90 => {
    //   block [0x830E1F90..0x830E1F98)
	// 830E1F90: 48003A40  b 0x830e59d0
	sub_830E59D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E1F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E1F98 size=36
    let mut pc: u32 = 0x830E1F98;
    'dispatch: loop {
        match pc {
            0x830E1F98 => {
    //   block [0x830E1F98..0x830E1FBC)
	// 830E1F98: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E1F9C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E1FA0: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E1FA4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830E1FA8: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 830E1FAC: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 830E1FB0: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 830E1FB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E1FB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E1FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E1FC0 size=64
    let mut pc: u32 = 0x830E1FC0;
    'dispatch: loop {
        match pc {
            0x830E1FC0 => {
    //   block [0x830E1FC0..0x830E1FD4)
	// 830E1FC0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E1FC4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830E1FC8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E1FCC: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 830E1FD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830E1FD4; continue 'dispatch;
            }
            0x830E1FD4 => {
    //   block [0x830E1FD4..0x830E2000)
	// 830E1FD4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E1FD8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830E1FDC: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 830E1FE0: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 830E1FE4: C009000C  lfs f0, 0xc(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E1FE8: EC000828  fsubs f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 830E1FEC: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830E1FF0: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E1FF4: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830E1FF8: 4198FFDC  blt cr6, 0x830e1fd4
	if ctx.cr[6].lt {
	pc = 0x830E1FD4; continue 'dispatch;
	}
	// 830E1FFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E2000 size=1380
    let mut pc: u32 = 0x830E2000;
    'dispatch: loop {
        match pc {
            0x830E2000 => {
    //   block [0x830E2000..0x830E2564)
	// 830E2000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E2004: 4BBC73E5  bl 0x82ca93e8
	ctx.lr = 0x830E2008;
	sub_82CA93D0(ctx, base);
	// 830E2008: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 830E200C: 4BBCBCB5  bl 0x82cadcc0
	ctx.lr = 0x830E2010;
	sub_82CADCA0(ctx, base);
	// 830E2010: 3981FF40  addi r12, r1, -0xc0
	ctx.r[12].s64 = ctx.r[1].s64 + -192;
	// 830E2014: 4BF249C1  bl 0x830069d4
	ctx.lr = 0x830E2018;
	sub_83006760(ctx, base);
	// 830E2018: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E201C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 830E2020: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E2024: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 830E2028: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 830E202C: 7CF43B78  mr r20, r7
	ctx.r[20].u64 = ctx.r[7].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E2568 size=1200
    let mut pc: u32 = 0x830E2568;
    'dispatch: loop {
        match pc {
            0x830E2568 => {
    //   block [0x830E2568..0x830E2A18)
	// 830E2568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E256C: 4BBC6E95  bl 0x82ca9400
	ctx.lr = 0x830E2570;
	sub_82CA93D0(ctx, base);
	// 830E2570: DBA1FFB0  stfd f29, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[29].u64 ) };
	// 830E2574: DBC1FFB8  stfd f30, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[30].u64 ) };
	// 830E2578: DBE1FFC0  stfd f31, -0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 830E257C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E2580: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 830E2584: C04B0C18  lfs f2, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 830E2588: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 830E258C: FC001090  fmr f0, f2
	ctx.f[0].f64 = ctx.f[2].f64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E2A18 size=280
    let mut pc: u32 = 0x830E2A18;
    'dispatch: loop {
        match pc {
            0x830E2A18 => {
    //   block [0x830E2A18..0x830E2AB0)
	// 830E2A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E2A1C: 4BBC69F1  bl 0x82ca940c
	ctx.lr = 0x830E2A20;
	sub_82CA93D0(ctx, base);
	// 830E2A20: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E2A24: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830E2A28: 38A0001E  li r5, 0x1e
	ctx.r[5].s64 = 30;
	// 830E2A2C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 830E2A30: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 830E2A34: 4BFFFB35  bl 0x830e2568
	ctx.lr = 0x830E2A38;
	sub_830E2568(ctx, base);
	// 830E2A38: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E2A3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E2A40: 409A0070  bne cr6, 0x830e2ab0
	if !ctx.cr[6].eq {
	pc = 0x830E2AB0; continue 'dispatch;
	}
	// 830E2A44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E2A48: C1AB0C14  lfs f13, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E2A4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E2A50: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830E2A54: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 830E2A58: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 830E2A5C: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E2A60: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830E2A64: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830E2A68: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830E2A6C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 830E2A70: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830E2A74: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830E2A78: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 830E2A7C: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	pc = 0x830E2AB0; continue 'dispatch;
            }
            0x830E2AB0 => {
    //   block [0x830E2AB0..0x830E2B30)
	// 830E2AB0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E2B30 size=92
    let mut pc: u32 = 0x830E2B30;
    'dispatch: loop {
        match pc {
            0x830E2B30 => {
    //   block [0x830E2B30..0x830E2B84)
	// 830E2B30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E2B34: C1A30000  lfs f13, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E2B38: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E2B3C: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E2B40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E2B44: D001FFFC  stfs f0, -4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 830E2B48: FC006A10  fabs f0, f13
	ctx.f[0].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 830E2B4C: FDA06210  fabs f13, f12
	ctx.f[13].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 830E2B50: C1830008  lfs f12, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E2B54: FD806210  fabs f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 830E2B58: ED606828  fsubs f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830E2B5C: FC0B682E  fsel f0, f11, f0, f13
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 830E2B60: EDAC0028  fsubs f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 830E2B64: FDAD032E  fsel f13, f13, f12, f0
	ctx.f[13].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 830E2B68: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E2B6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E2B70: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830E2B74: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 830E2B78: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 830E2B7C: 41980008  blt cr6, 0x830e2b84
	if ctx.cr[6].lt {
	pc = 0x830E2B84; continue 'dispatch;
	}
	// 830E2B80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830E2B84; continue 'dispatch;
            }
            0x830E2B84 => {
    //   block [0x830E2B84..0x830E2B8C)
	// 830E2B84: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830E2B88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E2B90 size=680
    let mut pc: u32 = 0x830E2B90;
    'dispatch: loop {
        match pc {
            0x830E2B90 => {
    //   block [0x830E2B90..0x830E2E38)
	// 830E2B90: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 830E2B94: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830E2B98: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E2B9C: C00BA5EC  lfs f0, -0x5a14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23060 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E2BA0: 3D605555  lis r11, 0x5555
	ctx.r[11].s64 = 1431633920;
	// 830E2BA4: D001FFA0  stfs f0, -0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), tmp.u32 ) };
	// 830E2BA8: 616A5556  ori r10, r11, 0x5556
	ctx.r[10].u64 = ctx.r[11].u64 | 21846;
	// 830E2BAC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830E2BB0: C00BA5E8  lfs f0, -0x5a18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23064 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E2BB4: 3961FFA0  addi r11, r1, -0x60
	ctx.r[11].s64 = ctx.r[1].s64 + -96;
	// 830E2BB8: D001FFB0  stfs f0, -0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E2E38 size=348
    let mut pc: u32 = 0x830E2E38;
    'dispatch: loop {
        match pc {
            0x830E2E38 => {
    //   block [0x830E2E38..0x830E2F94)
	// 830E2E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E2E3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E2E40: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E2E44: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E2F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E2F98 size=352
    let mut pc: u32 = 0x830E2F98;
    'dispatch: loop {
        match pc {
            0x830E2F98 => {
    //   block [0x830E2F98..0x830E30F8)
	// 830E2F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E2F9C: 4BBC644D  bl 0x82ca93e8
	ctx.lr = 0x830E2FA0;
	sub_82CA93D0(ctx, base);
	// 830E2FA0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E2FA4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 830E2FA8: FD800890  fmr f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = ctx.f[1].f64;
	// 830E2FAC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 830E2FB0: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 830E2FB4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830E2FB8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E30F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E30F8 size=348
    let mut pc: u32 = 0x830E30F8;
    'dispatch: loop {
        match pc {
            0x830E30F8 => {
    //   block [0x830E30F8..0x830E3254)
	// 830E30F8: D0210024  stfs f1, 0x24(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 830E30FC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 830E3100: 7D261850  subf r9, r6, r3
	ctx.r[9].s64 = ctx.r[3].s64 - ctx.r[6].s64;
	// 830E3104: 7D062050  subf r8, r6, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[6].s64;
	// 830E3108: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 830E310C: 38E10024  addi r7, r1, 0x24
	ctx.r[7].s64 = ctx.r[1].s64 + 36;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E3258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E3258 size=616
    let mut pc: u32 = 0x830E3258;
    'dispatch: loop {
        match pc {
            0x830E3258 => {
    //   block [0x830E3258..0x830E32F0)
	// 830E3258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E325C: 4BBC61A1  bl 0x82ca93fc
	ctx.lr = 0x830E3260;
	sub_82CA93D0(ctx, base);
	// 830E3260: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E3264: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E3268: FD800890  fmr f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = ctx.f[1].f64;
	// 830E326C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E3270: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E3274: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830E3278: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830E327C: C0EB0C18  lfs f7, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830E3280: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 830E3284: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 830E3288: FD603890  fmr f11, f7
	ctx.f[11].f64 = ctx.f[7].f64;
	// 830E328C: FD203890  fmr f9, f7
	ctx.f[9].f64 = ctx.f[7].f64;
	// 830E3290: 4BFFFBA9  bl 0x830e2e38
	ctx.lr = 0x830E3294;
	sub_830E2E38(ctx, base);
	// 830E3294: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830E3298: FCC00890  fmr f6, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[6].f64 = ctx.f[1].f64;
	// 830E329C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830E32A0: FC206090  fmr f1, f12
	ctx.f[1].f64 = ctx.f[12].f64;
	// 830E32A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E32A8: 4BFFFE51  bl 0x830e30f8
	ctx.lr = 0x830E32AC;
	sub_830E30F8(ctx, base);
	// 830E32AC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830E32B0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830E32B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E32B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E32BC: 4BFFFB7D  bl 0x830e2e38
	ctx.lr = 0x830E32C0;
	sub_830E2E38(ctx, base);
	// 830E32C0: FD400890  fmr f10, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = ctx.f[1].f64;
	// 830E32C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E32C8: FD006090  fmr f8, f12
	ctx.f[8].f64 = ctx.f[12].f64;
	// 830E32CC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 830E32D0: C0AB0BFC  lfs f5, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 830E32D4: FF0A3000  fcmpu cr6, f10, f6
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[6].f64);
	// 830E32D8: 40980080  bge cr6, 0x830e3358
	if !ctx.cr[6].lt {
	pc = 0x830E3358; continue 'dispatch;
	}
	// 830E32DC: FD605090  fmr f11, f10
	ctx.f[11].f64 = ctx.f[10].f64;
	// 830E32E0: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830E32E4: 409900D8  ble cr6, 0x830e33bc
	if !ctx.cr[6].gt {
	pc = 0x830E33BC; continue 'dispatch;
	}
	// 830E32E8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830E32EC: C14B84AC  lfs f10, -0x7b54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-31572 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	pc = 0x830E32F0; continue 'dispatch;
            }
            0x830E32F0 => {
    //   block [0x830E32F0..0x830E334C)
	// 830E32F0: ED0802B2  fmuls f8, f8, f10
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[10].f64) as f32) as f64);
	// 830E32F4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830E32F8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830E32FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E3300: FC204090  fmr f1, f8
	ctx.f[1].f64 = ctx.f[8].f64;
	// 830E3304: 4BFFFDF5  bl 0x830e30f8
	ctx.lr = 0x830E3308;
	sub_830E30F8(ctx, base);
	// 830E3308: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830E330C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830E3310: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E3314: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3318: 4BFFFB21  bl 0x830e2e38
	ctx.lr = 0x830E331C;
	sub_830E2E38(ctx, base);
	// 830E331C: FD200890  fmr f9, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[9].f64 = ctx.f[1].f64;
	// 830E3320: FF0B4800  fcmpu cr6, f11, f9
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[9].f64);
	// 830E3324: 41980098  blt cr6, 0x830e33bc
	if ctx.cr[6].lt {
	pc = 0x830E33BC; continue 'dispatch;
	}
	// 830E3328: 397AFFFF  addi r11, r26, -1
	ctx.r[11].s64 = ctx.r[26].s64 + -1;
	// 830E332C: FD804090  fmr f12, f8
	ctx.f[12].f64 = ctx.f[8].f64;
	// 830E3330: FD604890  fmr f11, f9
	ctx.f[11].f64 = ctx.f[9].f64;
	// 830E3334: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E3338: 419A0014  beq cr6, 0x830e334c
	if ctx.cr[6].eq {
	pc = 0x830E334C; continue 'dispatch;
	}
	// 830E333C: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 830E3340: 7F19D000  cmpw cr6, r25, r26
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[26].s32, &mut ctx.xer);
	// 830E3344: 4198FFAC  blt cr6, 0x830e32f0
	if ctx.cr[6].lt {
	pc = 0x830E32F0; continue 'dispatch;
	}
	// 830E3348: 48000074  b 0x830e33bc
	pc = 0x830E33BC; continue 'dispatch;
            }
            0x830E334C => {
    //   block [0x830E334C..0x830E3358)
	// 830E334C: FC204090  fmr f1, f8
	ctx.f[1].f64 = ctx.f[8].f64;
	// 830E3350: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830E3354: 4BBC60F8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830E3358 => {
    //   block [0x830E3358..0x830E3364)
	// 830E3358: FD205090  fmr f9, f10
	ctx.f[9].f64 = ctx.f[10].f64;
	// 830E335C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830E3360: 4099005C  ble cr6, 0x830e33bc
	if !ctx.cr[6].gt {
	pc = 0x830E33BC; continue 'dispatch;
	}
	pc = 0x830E3364; continue 'dispatch;
            }
            0x830E3364 => {
    //   block [0x830E3364..0x830E33A4)
	// 830E3364: ED8C0172  fmuls f12, f12, f5
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[5].f64) as f32) as f64);
	// 830E3368: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830E336C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830E3370: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E3374: FC206090  fmr f1, f12
	ctx.f[1].f64 = ctx.f[12].f64;
	// 830E3378: 4BFFFD81  bl 0x830e30f8
	ctx.lr = 0x830E337C;
	sub_830E30F8(ctx, base);
	// 830E337C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830E3380: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830E3384: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E3388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E338C: 4BFFFAAD  bl 0x830e2e38
	ctx.lr = 0x830E3390;
	sub_830E2E38(ctx, base);
	// 830E3390: FD600890  fmr f11, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].f64 = ctx.f[1].f64;
	// 830E3394: FF0B3000  fcmpu cr6, f11, f6
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[6].f64);
	// 830E3398: 4098000C  bge cr6, 0x830e33a4
	if !ctx.cr[6].lt {
	pc = 0x830E33A4; continue 'dispatch;
	}
	// 830E339C: FF0B5000  fcmpu cr6, f11, f10
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[10].f64);
	// 830E33A0: 4198001C  blt cr6, 0x830e33bc
	if ctx.cr[6].lt {
	pc = 0x830E33BC; continue 'dispatch;
	}
	pc = 0x830E33A4; continue 'dispatch;
            }
            0x830E33A4 => {
    //   block [0x830E33A4..0x830E33BC)
	// 830E33A4: 397AFFFF  addi r11, r26, -1
	ctx.r[11].s64 = ctx.r[26].s64 + -1;
	// 830E33A8: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E33AC: 419A0104  beq cr6, 0x830e34b0
	if ctx.cr[6].eq {
	pc = 0x830E34B0; continue 'dispatch;
	}
	// 830E33B0: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 830E33B4: 7F19D000  cmpw cr6, r25, r26
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[26].s32, &mut ctx.xer);
	// 830E33B8: 4198FFAC  blt cr6, 0x830e3364
	if ctx.cr[6].lt {
	pc = 0x830E3364; continue 'dispatch;
	}
	pc = 0x830E33BC; continue 'dispatch;
            }
            0x830E33BC => {
    //   block [0x830E33BC..0x830E3400)
	// 830E33BC: FF0C3800  fcmpu cr6, f12, f7
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[7].f64);
	// 830E33C0: 419800F0  blt cr6, 0x830e34b0
	if ctx.cr[6].lt {
	pc = 0x830E34B0; continue 'dispatch;
	}
	// 830E33C4: FF0C4000  fcmpu cr6, f12, f8
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[8].f64);
	// 830E33C8: 419900E8  bgt cr6, 0x830e34b0
	if ctx.cr[6].gt {
	pc = 0x830E34B0; continue 'dispatch;
	}
	// 830E33CC: FF065800  fcmpu cr6, f6, f11
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[11].f64);
	// 830E33D0: 419800E0  blt cr6, 0x830e34b0
	if ctx.cr[6].lt {
	pc = 0x830E34B0; continue 'dispatch;
	}
	// 830E33D4: FF095800  fcmpu cr6, f9, f11
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[11].f64);
	// 830E33D8: 419800D8  blt cr6, 0x830e34b0
	if ctx.cr[6].lt {
	pc = 0x830E34B0; continue 'dispatch;
	}
	// 830E33DC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830E33E0: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830E33E4: C00BBE10  lfs f0, -0x41f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E33E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830E33EC: EDA0002C  fsqrts f13, f0
	ctx.f[13].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 830E33F0: C00BBDF4  lfs f0, -0x420c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E33F4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830E33F8: ED200172  fmuls f9, f0, f5
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[5].f64) as f32) as f64);
	// 830E33FC: 409900A8  ble cr6, 0x830e34a4
	if !ctx.cr[6].gt {
	pc = 0x830E34A4; continue 'dispatch;
	}
	pc = 0x830E3400; continue 'dispatch;
            }
            0x830E3400 => {
    //   block [0x830E3400..0x830E3454)
	// 830E3400: EC0C3828  fsubs f0, f12, f7
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[7].f64) as f32) as f64);
	// 830E3404: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830E3408: EDA86028  fsubs f13, f8, f12
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 830E340C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830E3410: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E3414: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830E3418: 40990044  ble cr6, 0x830e345c
	if !ctx.cr[6].gt {
	pc = 0x830E345C; continue 'dispatch;
	}
	// 830E341C: ED40627C  fnmsubs f10, f0, f9, f12
	ctx.f[10].f64 = -(((ctx.f[0].f64 * ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 830E3420: FC205090  fmr f1, f10
	ctx.f[1].f64 = ctx.f[10].f64;
	// 830E3424: 4BFFFCD5  bl 0x830e30f8
	ctx.lr = 0x830E3428;
	sub_830E30F8(ctx, base);
	// 830E3428: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830E342C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830E3430: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E3434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3438: 4BFFFA01  bl 0x830e2e38
	ctx.lr = 0x830E343C;
	sub_830E2E38(ctx, base);
	// 830E343C: FF015800  fcmpu cr6, f1, f11
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[11].f64);
	// 830E3440: 40980014  bge cr6, 0x830e3454
	if !ctx.cr[6].lt {
	pc = 0x830E3454; continue 'dispatch;
	}
	// 830E3444: FD006090  fmr f8, f12
	ctx.f[8].f64 = ctx.f[12].f64;
	// 830E3448: FD805090  fmr f12, f10
	ctx.f[12].f64 = ctx.f[10].f64;
	// 830E344C: FD600890  fmr f11, f1
	ctx.f[11].f64 = ctx.f[1].f64;
	// 830E3450: 48000048  b 0x830e3498
	pc = 0x830E3498; continue 'dispatch;
            }
            0x830E3454 => {
    //   block [0x830E3454..0x830E345C)
	// 830E3454: FCE05090  fmr f7, f10
	ctx.f[7].f64 = ctx.f[10].f64;
	// 830E3458: 48000040  b 0x830e3498
	pc = 0x830E3498; continue 'dispatch;
            }
            0x830E345C => {
    //   block [0x830E345C..0x830E3494)
	// 830E345C: ED4D627A  fmadds f10, f13, f9, f12
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[9].f64 + ctx.f[12].f64) as f32) as f64);
	// 830E3460: FC205090  fmr f1, f10
	ctx.f[1].f64 = ctx.f[10].f64;
	// 830E3464: 4BFFFC95  bl 0x830e30f8
	ctx.lr = 0x830E3468;
	sub_830E30F8(ctx, base);
	// 830E3468: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830E346C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830E3470: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E3474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E3478: 4BFFF9C1  bl 0x830e2e38
	ctx.lr = 0x830E347C;
	sub_830E2E38(ctx, base);
	// 830E347C: FF015800  fcmpu cr6, f1, f11
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[11].f64);
	// 830E3480: 40980014  bge cr6, 0x830e3494
	if !ctx.cr[6].lt {
	pc = 0x830E3494; continue 'dispatch;
	}
	// 830E3484: FCE06090  fmr f7, f12
	ctx.f[7].f64 = ctx.f[12].f64;
	// 830E3488: FD805090  fmr f12, f10
	ctx.f[12].f64 = ctx.f[10].f64;
	// 830E348C: FD600890  fmr f11, f1
	ctx.f[11].f64 = ctx.f[1].f64;
	// 830E3490: 48000008  b 0x830e3498
	pc = 0x830E3498; continue 'dispatch;
            }
            0x830E3494 => {
    //   block [0x830E3494..0x830E3498)
	// 830E3494: FD005090  fmr f8, f10
	ctx.f[8].f64 = ctx.f[10].f64;
	pc = 0x830E3498; continue 'dispatch;
            }
            0x830E3498 => {
    //   block [0x830E3498..0x830E34A4)
	// 830E3498: 3B5AFFFF  addi r26, r26, -1
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	// 830E349C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 830E34A0: 409AFF60  bne cr6, 0x830e3400
	if !ctx.cr[6].eq {
	pc = 0x830E3400; continue 'dispatch;
	}
	pc = 0x830E34A4; continue 'dispatch;
            }
            0x830E34A4 => {
    //   block [0x830E34A4..0x830E34B0)
	// 830E34A4: FC206090  fmr f1, f12
	ctx.f[1].f64 = ctx.f[12].f64;
	// 830E34A8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830E34AC: 4BBC5FA0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830E34B0 => {
    //   block [0x830E34B0..0x830E34C0)
	// 830E34B0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E34B4: C02B0EE0  lfs f1, 0xee0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3808 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830E34B8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830E34BC: 4BBC5F90  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E34C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E34C0 size=328
    let mut pc: u32 = 0x830E34C0;
    'dispatch: loop {
        match pc {
            0x830E34C0 => {
    //   block [0x830E34C0..0x830E3608)
	// 830E34C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E34C4: 4BBC5F31  bl 0x82ca93f4
	ctx.lr = 0x830E34C8;
	sub_82CA93D0(ctx, base);
	// 830E34C8: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 830E34CC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E34D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830E34D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E34D8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830E34DC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830E34E0: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 830E34E4: C10BBE14  lfs f8, -0x41ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16876 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 830E34E8: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 830E34EC: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 830E34F0: 4BFFF949  bl 0x830e2e38
	ctx.lr = 0x830E34F4;
	sub_830E2E38(ctx, base);
	// 830E34F4: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E3608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E3608 size=108
    let mut pc: u32 = 0x830E3608;
    'dispatch: loop {
        match pc {
            0x830E3608 => {
    //   block [0x830E3608..0x830E3674)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E3678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E3678 size=256
    let mut pc: u32 = 0x830E3678;
    'dispatch: loop {
        match pc {
            0x830E3678 => {
    //   block [0x830E3678..0x830E3778)
	// 830E3678: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E3778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E3778 size=324
    let mut pc: u32 = 0x830E3778;
    'dispatch: loop {
        match pc {
            0x830E3778 => {
    //   block [0x830E3778..0x830E38BC)
	// 830E3778: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E38C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E38C0 size=608
    let mut pc: u32 = 0x830E38C0;
    'dispatch: loop {
        match pc {
            0x830E38C0 => {
    //   block [0x830E38C0..0x830E3914)
	// 830E38C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E38C4: 4BBC5B39  bl 0x82ca93fc
	ctx.lr = 0x830E38C8;
	sub_82CA93D0(ctx, base);
	// 830E38C8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 830E38CC: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E38D0: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 830E38D4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830E38D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E38DC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830E38E0: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 830E38E4: 2B1A0003  cmplwi cr6, r26, 3
	ctx.cr[6].compare_u32(ctx.r[26].u32, 3 as u32, &mut ctx.xer);
	// 830E38E8: 41990200  bgt cr6, 0x830e3ae8
	if ctx.cr[6].gt {
	pc = 0x830E3AE8; continue 'dispatch;
	}
	// 830E38EC: 3D80830E  lis r12, -0x7cf2
	ctx.r[12].s64 = -2096234496;
	// 830E38F0: 398C3904  addi r12, r12, 0x3904
	ctx.r[12].s64 = ctx.r[12].s64 + 14596;
	// 830E38F4: 5740103A  slwi r0, r26, 2
	ctx.r[0].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 830E38F8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 830E38FC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 830E3900: 4E800420  bctr
	match ctx.r[26].u64 {
		0 => {
	pc = 0x830E3914; continue 'dispatch;
		},
		1 => {
	pc = 0x830E3940; continue 'dispatch;
		},
		2 => {
	pc = 0x830E3960; continue 'dispatch;
		},
		3 => {
	pc = 0x830E39E0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 830E3904: 830E3914  lwz r24, 0x3914(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(14612 as u32) ) } as u64;
	// 830E3908: 830E3940  lwz r24, 0x3940(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(14656 as u32) ) } as u64;
	// 830E390C: 830E3960  lwz r24, 0x3960(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(14688 as u32) ) } as u64;
	// 830E3910: 830E39E0  lwz r24, 0x39e0(r14)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(14816 as u32) ) } as u64;
            }
            0x830E3914 => {
    //   block [0x830E3914..0x830E3940)
	// 830E3914: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	pc = 0x830E3940; continue 'dispatch;
            }
            0x830E3940 => {
    //   block [0x830E3940..0x830E3960)
	// 830E3940: 3960FFF0  li r11, -0x10
	ctx.r[11].s64 = -16;
	pc = 0x830E3960; continue 'dispatch;
            }
            0x830E3960 => {
    //   block [0x830E3960..0x830E39E0)
	// 830E3960: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830E3964: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 830E3968: 397DFFF0  addi r11, r29, -0x10
	ctx.r[11].s64 = ctx.r[29].s64 + -16;
	// 830E396C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 830E3970: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 830E3974: C00A0BFC  lfs f0, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E3978: 3940FFE0  li r10, -0x20
	ctx.r[10].s64 = -32;
	// 830E397C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	pc = 0x830E39E0; continue 'dispatch;
            }
            0x830E39E0 => {
    //   block [0x830E39E0..0x830E3AE8)
	// 830E39E0: 38DDFFD0  addi r6, r29, -0x30
	ctx.r[6].s64 = ctx.r[29].s64 + -48;
	// 830E39E4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830E39E8: 38BDFFE0  addi r5, r29, -0x20
	ctx.r[5].s64 = ctx.r[29].s64 + -32;
	// 830E39EC: 389DFFF0  addi r4, r29, -0x10
	ctx.r[4].s64 = ctx.r[29].s64 + -16;
	// 830E39F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830E39F4: 4BFFFC85  bl 0x830e3678
	ctx.lr = 0x830E39F8;
	sub_830E3678(ctx, base);
	pc = 0x830E3AE8; continue 'dispatch;
            }
            0x830E3AE8 => {
    //   block [0x830E3AE8..0x830E3B20)
	// 830E3AE8: 38FDFFC0  addi r7, r29, -0x40
	ctx.r[7].s64 = ctx.r[29].s64 + -64;
	// 830E3AEC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830E3AF0: 38DDFFD0  addi r6, r29, -0x30
	ctx.r[6].s64 = ctx.r[29].s64 + -48;
	// 830E3AF4: 38BDFFE0  addi r5, r29, -0x20
	ctx.r[5].s64 = ctx.r[29].s64 + -32;
	// 830E3AF8: 389DFFF0  addi r4, r29, -0x10
	ctx.r[4].s64 = ctx.r[29].s64 + -16;
	// 830E3AFC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830E3B00: 4BFFFC79  bl 0x830e3778
	ctx.lr = 0x830E3B04;
	sub_830E3778(ctx, base);
	// 830E3B04: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E3B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E3B20 size=220
    let mut pc: u32 = 0x830E3B20;
    'dispatch: loop {
        match pc {
            0x830E3B20 => {
    //   block [0x830E3B20..0x830E3B84)
	// 830E3B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E3B24: 4BBC58E1  bl 0x82ca9404
	ctx.lr = 0x830E3B28;
	sub_82CA93D0(ctx, base);
	// 830E3B28: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 830E3B2C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E3B30: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E3B34: 838D0000  lwz r28, 0(r13)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E3B38: 3BA00004  li r29, 4
	ctx.r[29].s64 = 4;
	// 830E3B3C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830E3B40: 38A00007  li r5, 7
	ctx.r[5].s64 = 7;
	// 830E3B44: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830E3B48: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E3B4C: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830E3B50: 55642036  slwi r4, r11, 4
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830E3B54: 4BC71925  bl 0x82d55478
	ctx.lr = 0x830E3B58;
	sub_82D55478(ctx, base);
	// 830E3B58: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E3B5C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E3B60: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E3B64: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 830E3B68: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830E3B6C: 7D4B0194  addze r10, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[10].s64 = tmp.s64;
	// 830E3B70: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830E3B74: 40990054  ble cr6, 0x830e3bc8
	if !ctx.cr[6].gt {
	pc = 0x830E3BC8; continue 'dispatch;
	}
	// 830E3B78: 5547103A  slwi r7, r10, 2
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 830E3B7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E3B80: 395E0008  addi r10, r30, 8
	ctx.r[10].s64 = ctx.r[30].s64 + 8;
	pc = 0x830E3B84; continue 'dispatch;
            }
            0x830E3B84 => {
    //   block [0x830E3B84..0x830E3BC8)
	// 830E3B84: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E3B88: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830E3B8C: 7C085C2E  lfsx f0, r8, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E3B90: D00AFFF8  stfs f0, -8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 830E3B94: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E3B98: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 830E3B9C: C0080004  lfs f0, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E3BA0: D00AFFFC  stfs f0, -4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 830E3BA4: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E3BA8: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 830E3BAC: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 830E3BB0: C0080008  lfs f0, 8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E3BB4: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830E3BB8: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E3BBC: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 830E3BC0: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830E3BC4: 4198FFC0  blt cr6, 0x830e3b84
	if ctx.cr[6].lt {
	pc = 0x830E3B84; continue 'dispatch;
	}
	pc = 0x830E3BC8; continue 'dispatch;
            }
            0x830E3BC8 => {
    //   block [0x830E3BC8..0x830E3BFC)
	// 830E3BC8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830E3BCC: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E3BD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E3BD4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830E3BD8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830E3BDC: 4BFFFCE5  bl 0x830e38c0
	ctx.lr = 0x830E3BE0;
	sub_830E38C0(ctx, base);
	// 830E3BE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E3BE4: 7C7DE02E  lwzx r3, r29, r28
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 830E3BE8: 4BC718E9  bl 0x82d554d0
	ctx.lr = 0x830E3BEC;
	sub_82D554D0(ctx, base);
	// 830E3BEC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830E3BF0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E3BF4: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 830E3BF8: 4BBC585C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E3C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E3C00 size=356
    let mut pc: u32 = 0x830E3C00;
    'dispatch: loop {
        match pc {
            0x830E3C00 => {
    //   block [0x830E3C00..0x830E3C54)
	// 830E3C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E3C04: 4BBC57F1  bl 0x82ca93f4
	ctx.lr = 0x830E3C08;
	sub_82CA93D0(ctx, base);
	// 830E3C08: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E3C0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E3C10: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 830E3C14: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 830E3C18: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 830E3C1C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E3C20: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 830E3C24: 409A0030  bne cr6, 0x830e3c54
	if !ctx.cr[6].eq {
	pc = 0x830E3C54; continue 'dispatch;
	}
	// 830E3C28: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E3C2C: 546A073E  clrlwi r10, r3, 0x1c
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x0000000Fu64;
	// 830E3C30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830E3C34: 409A0020  bne cr6, 0x830e3c54
	if !ctx.cr[6].eq {
	pc = 0x830E3C54; continue 'dispatch;
	}
	// 830E3C38: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 830E3C3C: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E3C40: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 830E3C44: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 830E3C48: 48008939  bl 0x830ec580
	ctx.lr = 0x830E3C4C;
	sub_830EC580(ctx, base);
	// 830E3C4C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830E3C50: 4BBC57F4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x830E3C54 => {
    //   block [0x830E3C54..0x830E3C8C)
	// 830E3C54: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830E3C58: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E3C5C: 3D008000  lis r8, -0x8000
	ctx.r[8].s64 = -2147483648;
	// 830E3C60: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 830E3C64: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 830E3C68: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 830E3C6C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830E3C70: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830E3C74: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 830E3C78: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 830E3C7C: 4099009C  ble cr6, 0x830e3d18
	if !ctx.cr[6].gt {
	pc = 0x830E3D18; continue 'dispatch;
	}
	// 830E3C80: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 830E3C84: 557A103A  slwi r26, r11, 2
	ctx.r[26].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 830E3C88: 48000008  b 0x830e3c90
	pc = 0x830E3C90; continue 'dispatch;
            }
            0x830E3C8C => {
    //   block [0x830E3C8C..0x830E3C90)
	// 830E3C8C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x830E3C90; continue 'dispatch;
            }
            0x830E3C90 => {
    //   block [0x830E3C90..0x830E3CB8)
	// 830E3C90: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830E3C94: 3BAA0001  addi r29, r10, 1
	ctx.r[29].s64 = ctx.r[10].s64 + 1;
	// 830E3C98: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 830E3C9C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830E3CA0: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830E3CA4: 40980024  bge cr6, 0x830e3cc8
	if !ctx.cr[6].lt {
	pc = 0x830E3CC8; continue 'dispatch;
	}
	// 830E3CA8: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E3CAC: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E3CB0: 41980008  blt cr6, 0x830e3cb8
	if ctx.cr[6].lt {
	pc = 0x830E3CB8; continue 'dispatch;
	}
	// 830E3CB4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x830E3CB8; continue 'dispatch;
            }
            0x830E3CB8 => {
    //   block [0x830E3CB8..0x830E3CC8)
	// 830E3CB8: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830E3CBC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830E3CC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E3CC4: 4BC7324D  bl 0x82d56f10
	ctx.lr = 0x830E3CC8;
	sub_82D56F10(ctx, base);
	pc = 0x830E3CC8; continue 'dispatch;
            }
            0x830E3CC8 => {
    //   block [0x830E3CC8..0x830E3D18)
	// 830E3CC8: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3CCC: 576B2036  slwi r11, r27, 4
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E3CD0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E3CD4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830E3CD8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830E3CDC: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 830E3CE0: 7C0AFC2E  lfsx f0, r10, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E3CE4: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830E3CE8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E3CEC: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 830E3CF0: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E3CF4: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830E3CF8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E3CFC: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 830E3D00: 7FFAFA14  add r31, r26, r31
	ctx.r[31].u64 = ctx.r[26].u64 + ctx.r[31].u64;
	// 830E3D04: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E3D08: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830E3D0C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E3D10: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E3D14: 4198FF78  blt cr6, 0x830e3c8c
	if ctx.cr[6].lt {
	pc = 0x830E3C8C; continue 'dispatch;
	}
	pc = 0x830E3D18; continue 'dispatch;
            }
            0x830E3D18 => {
    //   block [0x830E3D18..0x830E3D5C)
	// 830E3D18: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 830E3D1C: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E3D20: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 830E3D24: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3D28: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 830E3D2C: 48008855  bl 0x830ec580
	ctx.lr = 0x830E3D30;
	sub_830EC580(ctx, base);
	// 830E3D30: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830E3D34: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E3D38: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E3D3C: 409A0020  bne cr6, 0x830e3d5c
	if !ctx.cr[6].eq {
	pc = 0x830E3D5C; continue 'dispatch;
	}
	// 830E3D40: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E3D44: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830E3D48: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830E3D4C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E3D50: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830E3D54: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830E3D58: 4BC71571  bl 0x82d552c8
	ctx.lr = 0x830E3D5C;
	sub_82D552C8(ctx, base);
	pc = 0x830E3D5C; continue 'dispatch;
            }
            0x830E3D5C => {
    //   block [0x830E3D5C..0x830E3D64)
	// 830E3D5C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830E3D60: 4BBC56E4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E3D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E3D68 size=2556
    let mut pc: u32 = 0x830E3D68;
    'dispatch: loop {
        match pc {
            0x830E3D68 => {
    //   block [0x830E3D68..0x830E4764)
	// 830E3D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E3D6C: 4BBC5679  bl 0x82ca93e4
	ctx.lr = 0x830E3D70;
	sub_82CA93D0(ctx, base);
	// 830E3D70: DBA1FF78  stfd f29, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[29].u64 ) };
	// 830E3D74: DBC1FF80  stfd f30, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 830E3D78: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 830E3D7C: 3980FF60  li r12, -0xa0
	ctx.r[12].s64 = -160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E4768 size=432
    let mut pc: u32 = 0x830E4768;
    'dispatch: loop {
        match pc {
            0x830E4768 => {
    //   block [0x830E4768..0x830E47C8)
	// 830E4768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E476C: 4BBC4C95  bl 0x82ca9400
	ctx.lr = 0x830E4770;
	sub_82CA93D0(ctx, base);
	// 830E4770: 9421FB10  stwu r1, -0x4f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1264 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E4774: 83AD0000  lwz r29, 0(r13)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E4778: 3BE00008  li r31, 8
	ctx.r[31].s64 = 8;
	// 830E477C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830E4780: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E4784: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830E4788: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830E478C: 7D5DF82E  lwzx r10, r29, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830E4790: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E4794: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E4798: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830E479C: 4098002C  bge cr6, 0x830e47c8
	if !ctx.cr[6].lt {
	pc = 0x830E47C8; continue 'dispatch;
	}
	// 830E47A0: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 830E47A4: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 830E47A8: 3929A608  addi r9, r9, -0x59f8
	ctx.r[9].s64 = ctx.r[9].s64 + -23032;
	// 830E47AC: 3908A600  addi r8, r8, -0x5a00
	ctx.r[8].s64 = ctx.r[8].s64 + -23040;
	// 830E47B0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830E47B4: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 830E47B8: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 830E47BC: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 830E47C0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830E47C4: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x830E47C8; continue 'dispatch;
            }
            0x830E47C8 => {
    //   block [0x830E47C8..0x830E4820)
	// 830E47C8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830E47CC: 4800890D  bl 0x830ed0d8
	ctx.lr = 0x830E47D0;
	sub_830ED0D8(ctx, base);
	// 830E47D0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830E47D4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830E47D8: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 830E47DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830E47E0: 4BFFF421  bl 0x830e3c00
	ctx.lr = 0x830E47E4;
	sub_830E3C00(ctx, base);
	// 830E47E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E47E8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830E47EC: 4800655D  bl 0x830ead48
	ctx.lr = 0x830E47F0;
	sub_830EAD48(ctx, base);
	// 830E47F0: 7D5DF82E  lwzx r10, r29, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830E47F4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E47F8: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E47FC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830E4800: 40980020  bge cr6, 0x830e4820
	if !ctx.cr[6].lt {
	pc = 0x830E4820; continue 'dispatch;
	}
	// 830E4804: 3D208208  lis r9, -0x7df8
	ctx.r[9].s64 = -2113404928;
	// 830E4808: 3929A5F4  addi r9, r9, -0x5a0c
	ctx.r[9].s64 = ctx.r[9].s64 + -23052;
	// 830E480C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830E4810: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 830E4814: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 830E4818: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830E481C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x830E4820; continue 'dispatch;
            }
            0x830E4820 => {
    //   block [0x830E4820..0x830E48E8)
	// 830E4820: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830E4824: 395CFFFE  addi r10, r28, -2
	ctx.r[10].s64 = ctx.r[28].s64 + -2;
	// 830E4828: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 830E482C: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 830E4830: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830E4834: C1ABA5E4  lfs f13, -0x5a1c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E4838: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830E483C: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 830E4840: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830E4844: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830E4848: D1A10090  stfs f13, 0x90(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 830E484C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E4850: C00BA5E0  lfs f0, -0x5a20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23072 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E4854: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E4858: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830E485C: C00B0DB0  lfs f0, 0xdb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E4860: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E4864: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830E4868: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830E486C: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 830E4870: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 830E4874: C18B0AC4  lfs f12, 0xac4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2756 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E4878: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E487C: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830E4880: D181008C  stfs f12, 0x8c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 830E4884: C16B0AB4  lfs f11, 0xab4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2740 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830E4888: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E488C: D1610074  stfs f11, 0x74(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 830E4890: 99610060  stb r11, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 830E4894: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 830E4898: C16B1448  lfs f11, 0x1448(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5192 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830E489C: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 830E48A0: D1610080  stfs f11, 0x80(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 830E48A4: 99610062  stb r11, 0x62(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[11].u8 ) };
	// 830E48A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E48AC: C00B0AD4  lfs f0, 0xad4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2772 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E48B0: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 830E48B4: 4800657D  bl 0x830eae30
	ctx.lr = 0x830E48B8;
	sub_830EAE30(ctx, base);
	// 830E48B8: 7D7DF82E  lwzx r11, r29, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830E48BC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E48C0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E48C4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830E48C8: 40980020  bge cr6, 0x830e48e8
	if !ctx.cr[6].lt {
	pc = 0x830E48E8; continue 'dispatch;
	}
	// 830E48CC: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 830E48D0: 39296468  addi r9, r9, 0x6468
	ctx.r[9].s64 = ctx.r[9].s64 + 25704;
	// 830E48D4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830E48D8: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 830E48DC: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 830E48E0: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830E48E4: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x830E48E8; continue 'dispatch;
            }
            0x830E48E8 => {
    //   block [0x830E48E8..0x830E4910)
	// 830E48E8: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 830E48EC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E48F0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E48F4: 409A001C  bne cr6, 0x830e4910
	if !ctx.cr[6].eq {
	pc = 0x830E4910; continue 'dispatch;
	}
	// 830E48F8: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830E48FC: 808100A4  lwz r4, 0xa4(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 830E4900: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830E4904: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830E4908: 7C7D502E  lwzx r3, r29, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830E490C: 4BC709BD  bl 0x82d552c8
	ctx.lr = 0x830E4910;
	sub_82D552C8(ctx, base);
	pc = 0x830E4910; continue 'dispatch;
            }
            0x830E4910 => {
    //   block [0x830E4910..0x830E4918)
	// 830E4910: 382104F0  addi r1, r1, 0x4f0
	ctx.r[1].s64 = ctx.r[1].s64 + 1264;
	// 830E4914: 4BBC4B3C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E4918 size=116
    let mut pc: u32 = 0x830E4918;
    'dispatch: loop {
        match pc {
            0x830E4918 => {
    //   block [0x830E4918..0x830E4984)
	// 830E4918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E491C: 4BBC4AF1  bl 0x82ca940c
	ctx.lr = 0x830E4920;
	sub_82CA93D0(ctx, base);
	// 830E4920: 9421FB80  stwu r1, -0x480(r1)
	ea = ctx.r[1].u32.wrapping_add(-1152 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E4924: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E4928: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E492C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830E4930: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830E4934: 480087A5  bl 0x830ed0d8
	ctx.lr = 0x830E4938;
	sub_830ED0D8(ctx, base);
	// 830E4938: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830E493C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830E4940: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E4944: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4948: 4BFFF2B9  bl 0x830e3c00
	ctx.lr = 0x830E494C;
	sub_830E3C00(ctx, base);
	// 830E494C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E4950: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E4954: 480063F5  bl 0x830ead48
	ctx.lr = 0x830E4958;
	sub_830EAD48(ctx, base);
	// 830E4958: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 830E495C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E4960: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E4964: 409A0020  bne cr6, 0x830e4984
	if !ctx.cr[6].eq {
	pc = 0x830E4984; continue 'dispatch;
	}
	// 830E4968: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E496C: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830E4970: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830E4974: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E4978: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830E497C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830E4980: 4BC70949  bl 0x82d552c8
	ctx.lr = 0x830E4984;
	sub_82D552C8(ctx, base);
	pc = 0x830E4984; continue 'dispatch;
            }
            0x830E4984 => {
    //   block [0x830E4984..0x830E498C)
	// 830E4984: 38210480  addi r1, r1, 0x480
	ctx.r[1].s64 = ctx.r[1].s64 + 1152;
	// 830E4988: 4BBC4AD4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E4990 size=180
    let mut pc: u32 = 0x830E4990;
    'dispatch: loop {
        match pc {
            0x830E4990 => {
    //   block [0x830E4990..0x830E49F8)
	// 830E4990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E4994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E4998: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E499C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E49A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E49A4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830E49A8: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 830E49AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E49B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E49B4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 830E49B8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830E49BC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830E49C0: 48001011  bl 0x830e59d0
	ctx.lr = 0x830E49C4;
	sub_830E59D0(ctx, base);
	// 830E49C4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E49C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E49CC: 4099002C  ble cr6, 0x830e49f8
	if !ctx.cr[6].gt {
	pc = 0x830E49F8; continue 'dispatch;
	}
	// 830E49D0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E49D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830E49D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830E49DC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 830E49E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E49E4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 830E49E8: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 830E49EC: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 830E49F0: 4BFFFF29  bl 0x830e4918
	ctx.lr = 0x830E49F4;
	sub_830E4918(ctx, base);
	// 830E49F4: 4800000C  b 0x830e4a00
	pc = 0x830E4A00; continue 'dispatch;
            }
            0x830E49F8 => {
    //   block [0x830E49F8..0x830E4A00)
	// 830E49F8: 93FE0010  stw r31, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 830E49FC: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x830E4A00; continue 'dispatch;
            }
            0x830E4A00 => {
    //   block [0x830E4A00..0x830E4A2C)
	// 830E4A00: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830E4A04: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E4A08: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E4A0C: 409A0020  bne cr6, 0x830e4a2c
	if !ctx.cr[6].eq {
	pc = 0x830E4A2C; continue 'dispatch;
	}
	// 830E4A10: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E4A14: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830E4A18: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830E4A1C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E4A20: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830E4A24: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830E4A28: 4BC708A1  bl 0x82d552c8
	ctx.lr = 0x830E4A2C;
	sub_82D552C8(ctx, base);
	pc = 0x830E4A2C; continue 'dispatch;
            }
            0x830E4A2C => {
    //   block [0x830E4A2C..0x830E4A44)
	// 830E4A2C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E4A30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E4A34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E4A38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E4A3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E4A40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E4A48 size=1084
    let mut pc: u32 = 0x830E4A48;
    'dispatch: loop {
        match pc {
            0x830E4A48 => {
    //   block [0x830E4A48..0x830E4ADC)
	// 830E4A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E4A4C: 4BBC49A5  bl 0x82ca93f0
	ctx.lr = 0x830E4A50;
	sub_82CA93D0(ctx, base);
	// 830E4A50: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 830E4A54: 9421FA30  stwu r1, -0x5d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-1488 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E4A58: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830E4A5C: 3FE08000  lis r31, -0x8000
	ctx.r[31].s64 = -2147483648;
	// 830E4A60: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E4A64: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 830E4A68: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 830E4A6C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830E4A70: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 830E4A74: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 830E4A78: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 830E4A7C: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 830E4A80: 9361007C  stw r27, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	// 830E4A84: 93610080  stw r27, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[27].u32 ) };
	// 830E4A88: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 830E4A8C: 4800864D  bl 0x830ed0d8
	ctx.lr = 0x830E4A90;
	sub_830ED0D8(ctx, base);
	// 830E4A90: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830E4A94: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 830E4A98: 38810160  addi r4, r1, 0x160
	ctx.r[4].s64 = ctx.r[1].s64 + 352;
	// 830E4A9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830E4AA0: 4BFFF161  bl 0x830e3c00
	ctx.lr = 0x830E4AA4;
	sub_830E3C00(ctx, base);
	// 830E4AA4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830E4AA8: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 830E4AAC: 4800629D  bl 0x830ead48
	ctx.lr = 0x830E4AB0;
	sub_830EAD48(ctx, base);
	// 830E4AB0: 8161016C  lwz r11, 0x16c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(364 as u32) ) } as u64;
	// 830E4AB4: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E4AB8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E4ABC: 409A0020  bne cr6, 0x830e4adc
	if !ctx.cr[6].eq {
	pc = 0x830E4ADC; continue 'dispatch;
	}
	// 830E4AC0: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E4AC4: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830E4AC8: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830E4ACC: 80810164  lwz r4, 0x164(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 830E4AD0: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830E4AD4: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830E4AD8: 4BC707F1  bl 0x82d552c8
	ctx.lr = 0x830E4ADC;
	sub_82D552C8(ctx, base);
	pc = 0x830E4ADC; continue 'dispatch;
            }
            0x830E4ADC => {
    //   block [0x830E4ADC..0x830E4B24)
	// 830E4ADC: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 830E4AE0: 3B200004  li r25, 4
	ctx.r[25].s64 = 4;
	// 830E4AE4: 830D0000  lwz r24, 0(r13)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E4AE8: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830E4AEC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 830E4AF0: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 830E4AF4: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830E4AF8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 830E4AFC: 7D79C02E  lwzx r11, r25, r24
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 830E4B00: 393E0001  addi r9, r30, 1
	ctx.r[9].s64 = ctx.r[30].s64 + 1;
	// 830E4B04: 55242036  slwi r4, r9, 4
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830E4B08: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E4B0C: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 830E4B10: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 830E4B14: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830E4B18: 4199000C  bgt cr6, 0x830e4b24
	if ctx.cr[6].gt {
	pc = 0x830E4B24; continue 'dispatch;
	}
	// 830E4B1C: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 830E4B20: 4800001C  b 0x830e4b3c
	pc = 0x830E4B3C; continue 'dispatch;
            }
            0x830E4B24 => {
    //   block [0x830E4B24..0x830E4B3C)
	// 830E4B24: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E4B28: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830E4B2C: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 830E4B30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830E4B34: 4E800421  bctrl
	ctx.lr = 0x830E4B38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830E4B38: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
            }
            0x830E4B3C => {
    //   block [0x830E4B3C..0x830E4B74)
	// 830E4B3C: 7FC9FB78  or r9, r30, r31
	ctx.r[9].u64 = ctx.r[30].u64 | ctx.r[31].u64;
	// 830E4B40: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 830E4B44: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830E4B48: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 830E4B4C: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830E4B50: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830E4B54: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 830E4B58: 552900BE  clrlwi r9, r9, 2
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x3FFFFFFFu64;
	// 830E4B5C: 7F09F800  cmpw cr6, r9, r31
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830E4B60: 40980028  bge cr6, 0x830e4b88
	if !ctx.cr[6].lt {
	pc = 0x830E4B88; continue 'dispatch;
	}
	// 830E4B64: 552B083C  slwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E4B68: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E4B6C: 41980008  blt cr6, 0x830e4b74
	if ctx.cr[6].lt {
	pc = 0x830E4B74; continue 'dispatch;
	}
	// 830E4B70: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x830E4B74; continue 'dispatch;
            }
            0x830E4B74 => {
    //   block [0x830E4B74..0x830E4B88)
	// 830E4B74: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830E4B78: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830E4B7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E4B80: 4BC72391  bl 0x82d56f10
	ctx.lr = 0x830E4B84;
	sub_82D56F10(ctx, base);
	// 830E4B84: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	pc = 0x830E4B88; continue 'dispatch;
            }
            0x830E4B88 => {
    //   block [0x830E4B88..0x830E4C24)
	// 830E4B88: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 830E4B8C: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 830E4B90: 3B800010  li r28, 0x10
	ctx.r[28].s64 = 16;
	// 830E4B94: 3BA00020  li r29, 0x20
	ctx.r[29].s64 = 32;
	// 830E4B98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E4B9C: 40990088  ble cr6, 0x830e4c24
	if !ctx.cr[6].gt {
	pc = 0x830E4C24; continue 'dispatch;
	}
	// 830E4BA0: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 830E4BA4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 830E4BA8: 8101007C  lwz r8, 0x7c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 830E4BAC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830E4BB0: 80E10070  lwz r7, 0x70(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830E4BB4: 7D0B402E  lwzx r8, r11, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830E4BB8: 55082036  slwi r8, r8, 4
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	pc = 0x830E4C24; continue 'dispatch;
            }
            0x830E4C24 => {
    //   block [0x830E4C24..0x830E4E84)
	// 830E4C24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E4C28: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830E4C2C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 830E4C30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830E4C34: C02B0BE8  lfs f1, 0xbe8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830E4C38: 4BFFF131  bl 0x830e3d68
	ctx.lr = 0x830E4C3C;
	sub_830E3D68(ctx, base);
	// 830E4C3C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830E4C40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E4C44: 409A01E0  bne cr6, 0x830e4e24
	if !ctx.cr[6].eq {
	pc = 0x830E4E24; continue 'dispatch;
	}
	// 830E4C48: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E4C4C: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830E4C50: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E4C54: 390100B0  addi r8, r1, 0xb0
	ctx.r[8].s64 = ctx.r[1].s64 + 176;
	// 830E4C58: 38E10100  addi r7, r1, 0x100
	ctx.r[7].s64 = ctx.r[1].s64 + 256;
	// 830E4C5C: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 830E4C60: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830E4C64: C1AB0C14  lfs f13, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E4C68: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E4C6C: D1A100A0  stfs f13, 0xa0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 830E4C70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E4C74: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 830E4C78: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830E4C7C: D1A100B8  stfs f13, 0xb8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 830E4C80: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E4C84: 39610100  addi r11, r1, 0x100
	ctx.r[11].s64 = ctx.r[1].s64 + 256;
	// 830E4C88: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 830E4C8C: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 830E4C90: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 830E4C94: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 830E4C98: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 830E4C9C: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 830E4CA0: D001009C  stfs f0, 0x9c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 830E4CA4: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E4E88 size=136
    let mut pc: u32 = 0x830E4E88;
    'dispatch: loop {
        match pc {
            0x830E4E88 => {
    //   block [0x830E4E88..0x830E4F10)
	// 830E4E88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E4E8C: 54AA2036  slwi r10, r5, 4
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830E4E90: 54892036  slwi r9, r4, 4
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830E4E94: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830E4E98: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 830E4E9C: 54C82036  slwi r8, r6, 4
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 830E4EA0: 38C1FFF0  addi r6, r1, -0x10
	ctx.r[6].s64 = ctx.r[1].s64 + -16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E4F10 size=184
    let mut pc: u32 = 0x830E4F10;
    'dispatch: loop {
        match pc {
            0x830E4F10 => {
    //   block [0x830E4F10..0x830E4FC8)
	// 830E4F10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E4F14: 54CA2036  slwi r10, r6, 4
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830E4F18: 54A92036  slwi r9, r5, 4
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830E4F1C: 54882036  slwi r8, r4, 4
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 830E4F20: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830E4F24: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 830E4F28: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 830E4F2C: 3861FFE0  addi r3, r1, -0x20
	ctx.r[3].s64 = ctx.r[1].s64 + -32;
	// 830E4F30: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E4FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E4FC8 size=160
    let mut pc: u32 = 0x830E4FC8;
    'dispatch: loop {
        match pc {
            0x830E4FC8 => {
    //   block [0x830E4FC8..0x830E5068)
	// 830E4FC8: C18B000C  lfs f12, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E4FCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E4FD0: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 830E4FD4: D181FFF0  stfs f12, -0x10(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 830E4FD8: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E4FDC: 3941FFE0  addi r10, r1, -0x20
	ctx.r[10].s64 = ctx.r[1].s64 + -32;
	// 830E4FE0: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 830E4FE4: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E4FE8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E4FEC: D001FFFC  stfs f0, -4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 830E4FF0: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E4FF4: 90870010  stw r4, 0x10(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 830E4FF8: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 830E4FFC: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 830E5000: FC006050  fneg f0, f12
	ctx.f[0].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 830E5004: D001FFF8  stfs f0, -8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 830E5008: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E500C: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 830E5010: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830E5014: D001FFE0  stfs f0, -0x20(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5068(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E5068 size=496
    let mut pc: u32 = 0x830E5068;
    'dispatch: loop {
        match pc {
            0x830E5068 => {
    //   block [0x830E5068..0x830E51D4)
	// 830E5068: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E506C: 4BBC4375  bl 0x82ca93e0
	ctx.lr = 0x830E5070;
	sub_82CA93D0(ctx, base);
	// 830E5070: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E5074: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830E5078: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 830E507C: 7D1F4378  mr r31, r8
	ctx.r[31].u64 = ctx.r[8].u64;
	// 830E5080: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830E5084: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 830E5088: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 830E508C: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830E5090: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 830E5094: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830E5098: 3B7E0010  addi r27, r30, 0x10
	ctx.r[27].s64 = ctx.r[30].s64 + 16;
	// 830E509C: 917E0018  stw r11, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 830E50A0: 3B5E0014  addi r26, r30, 0x14
	ctx.r[26].s64 = ctx.r[30].s64 + 20;
	// 830E50A4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830E50A8: 3B3E0018  addi r25, r30, 0x18
	ctx.r[25].s64 = ctx.r[30].s64 + 24;
	// 830E50AC: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830E50B0: 3ABF0010  addi r21, r31, 0x10
	ctx.r[21].s64 = ctx.r[31].s64 + 16;
	// 830E50B4: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 830E50B8: 3B1F0014  addi r24, r31, 0x14
	ctx.r[24].s64 = ctx.r[31].s64 + 20;
	// 830E50BC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E50C0: 3AFF0018  addi r23, r31, 0x18
	ctx.r[23].s64 = ctx.r[31].s64 + 24;
	// 830E50C4: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 830E50C8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830E50CC: 3A5D0004  addi r18, r29, 4
	ctx.r[18].s64 = ctx.r[29].s64 + 4;
	// 830E50D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E50D4: 40990114  ble cr6, 0x830e51e8
	if !ctx.cr[6].gt {
	pc = 0x830E51E8; continue 'dispatch;
	}
	// 830E50D8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830E50DC: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830E50E0: 3D608203  lis r11, -0x7dfd
	ctx.r[11].s64 = -2113732608;
	// 830E50E4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830E50E8: 3A6B2AF0  addi r19, r11, 0x2af0
	ctx.r[19].s64 = ctx.r[11].s64 + 10992;
	// 830E50EC: C1690A5C  lfs f11, 0xa5c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2652 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830E50F0: C14AA618  lfs f10, -0x59e8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-23016 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830E50F4: 7F062000  cmpw cr6, r6, r4
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[4].s32, &mut ctx.xer);
	// 830E50F8: 419A00DC  beq cr6, 0x830e51d4
	if ctx.cr[6].eq {
	pc = 0x830E51D4; continue 'dispatch;
	}
	// 830E50FC: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 830E5100: 419A00D4  beq cr6, 0x830e51d4
	if ctx.cr[6].eq {
	pc = 0x830E51D4; continue 'dispatch;
	}
	// 830E5104: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 830E5108: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E510C: 4BFFFE05  bl 0x830e4f10
	ctx.lr = 0x830E5110;
	sub_830E4F10(ctx, base);
	// 830E5110: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 830E5114: 409A00C0  bne cr6, 0x830e51d4
	if !ctx.cr[6].eq {
	pc = 0x830E51D4; continue 'dispatch;
	}
	// 830E5118: 56CB063E  clrlwi r11, r22, 0x18
	ctx.r[11].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	// 830E511C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830E5120: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	pc = 0x830E51D4; continue 'dispatch;
            }
            0x830E51D4 => {
    //   block [0x830E51D4..0x830E51E8)
	// 830E51D4: 81720000  lwz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E51D8: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 830E51DC: 3B9C0010  addi r28, r28, 0x10
	ctx.r[28].s64 = ctx.r[28].s64 + 16;
	// 830E51E0: 7F065800  cmpw cr6, r6, r11
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E51E4: 4198FF10  blt cr6, 0x830e50f4
	if ctx.cr[6].lt {
	pc = 0x830E50F4; continue 'dispatch;
	}
	pc = 0x830E51E8; continue 'dispatch;
            }
            0x830E51E8 => {
    //   block [0x830E51E8..0x830E5258)
	// 830E51E8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E51EC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830E51F0: 409A0024  bne cr6, 0x830e5214
	if !ctx.cr[6].eq {
	pc = 0x830E5214; continue 'dispatch;
	}
	// 830E51F4: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E51F8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830E51FC: 419A0050  beq cr6, 0x830e524c
	if ctx.cr[6].eq {
	pc = 0x830E524C; continue 'dispatch;
	}
	// 830E5200: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E5204: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5208: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E520C: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5210: 91790000  stw r11, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E5214: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5218: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830E521C: 409A0024  bne cr6, 0x830e5240
	if !ctx.cr[6].eq {
	pc = 0x830E5240; continue 'dispatch;
	}
	// 830E5220: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5224: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 830E5228: 419A0024  beq cr6, 0x830e524c
	if ctx.cr[6].eq {
	pc = 0x830E524C; continue 'dispatch;
	}
	// 830E522C: 91750000  stw r11, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E5230: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5234: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E5238: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E523C: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830E5240: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830E5244: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 830E5248: 4BBC41E8  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
	// 830E524C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E5250: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 830E5254: 4BBC41DC  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E5258 size=500
    let mut pc: u32 = 0x830E5258;
    'dispatch: loop {
        match pc {
            0x830E5258 => {
    //   block [0x830E5258..0x830E5420)
	// 830E5258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E525C: 4BBC4189  bl 0x82ca93e4
	ctx.lr = 0x830E5260;
	sub_82CA93D0(ctx, base);
	// 830E5260: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 830E5264: 4BBC8A71  bl 0x82cadcd4
	ctx.lr = 0x830E5268;
	sub_82CADCA0(ctx, base);
	// 830E5268: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E526C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830E5270: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E5274: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 830E5278: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 830E527C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830E5280: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E5284: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 830E5288: C3CB0C64  lfs f30, 0xc64(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3172 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830E528C: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 830E5290: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	// 830E5294: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 830E5298: 7E759B78  mr r21, r19
	ctx.r[21].u64 = ctx.r[19].u64;
	// 830E529C: 7E7D9B78  mr r29, r19
	ctx.r[29].u64 = ctx.r[19].u64;
	// 830E52A0: 3ADE0004  addi r22, r30, 4
	ctx.r[22].s64 = ctx.r[30].s64 + 4;
	// 830E52A4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E52A8: 4099018C  ble cr6, 0x830e5434
	if !ctx.cr[6].gt {
	pc = 0x830E5434; continue 'dispatch;
	}
	// 830E52AC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 830E52B0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830E52B4: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 830E52B8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 830E52BC: 7E7C9B78  mr r28, r19
	ctx.r[28].u64 = ctx.r[19].u64;
	// 830E52C0: C3A80AD4  lfs f29, 0xad4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2772 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830E52C4: 3AEB4C30  addi r23, r11, 0x4c30
	ctx.r[23].s64 = ctx.r[11].s64 + 19504;
	// 830E52C8: C3890C14  lfs f28, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 830E52CC: C36A1448  lfs f27, 0x1448(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5192 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 830E52D0: 7F1DD000  cmpw cr6, r29, r26
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[26].s32, &mut ctx.xer);
	// 830E52D4: 419A014C  beq cr6, 0x830e5420
	if ctx.cr[6].eq {
	pc = 0x830E5420; continue 'dispatch;
	}
	// 830E52D8: 7F1DC800  cmpw cr6, r29, r25
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[25].s32, &mut ctx.xer);
	// 830E52DC: 419A0144  beq cr6, 0x830e5420
	if ctx.cr[6].eq {
	pc = 0x830E5420; continue 'dispatch;
	}
	// 830E52E0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x830E5420; continue 'dispatch;
            }
            0x830E5420 => {
    //   block [0x830E5420..0x830E5434)
	// 830E5420: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5424: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830E5428: 3B9C0010  addi r28, r28, 0x10
	ctx.r[28].s64 = ctx.r[28].s64 + 16;
	// 830E542C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E5430: 4198FEA0  blt cr6, 0x830e52d0
	if ctx.cr[6].lt {
	pc = 0x830E52D0; continue 'dispatch;
	}
	pc = 0x830E5434; continue 'dispatch;
            }
            0x830E5434 => {
    //   block [0x830E5434..0x830E544C)
	// 830E5434: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 830E5438: 9AB40000  stb r21, 0(r20)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), ctx.r[21].u8 ) };
	// 830E543C: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 830E5440: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 830E5444: 4BBC88DD  bl 0x82cadd20
	ctx.lr = 0x830E5448;
	sub_82CADCEC(ctx, base);
	// 830E5448: 4BBC3FEC  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E5450 size=792
    let mut pc: u32 = 0x830E5450;
    'dispatch: loop {
        match pc {
            0x830E5450 => {
    //   block [0x830E5450..0x830E54CC)
	// 830E5450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E5454: 4BBC3F99  bl 0x82ca93ec
	ctx.lr = 0x830E5458;
	sub_82CA93D0(ctx, base);
	// 830E5458: DBA1FF88  stfd f29, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[29].u64 ) };
	// 830E545C: DBC1FF90  stfd f30, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 830E5460: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 830E5464: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E5468: 3EE08000  lis r23, -0x8000
	ctx.r[23].s64 = -2147483648;
	// 830E546C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830E5470: 3B61007C  addi r27, r1, 0x7c
	ctx.r[27].s64 = ctx.r[1].s64 + 124;
	// 830E5474: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830E5478: 62F70020  ori r23, r23, 0x20
	ctx.r[23].u64 = ctx.r[23].u64 | 32;
	// 830E547C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830E5480: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830E5484: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E5488: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 830E548C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830E5490: 90A10074  stw r5, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[5].u32 ) };
	// 830E5494: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830E5498: 92E10078  stw r23, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[23].u32 ) };
	// 830E549C: C3A90A5C  lfs f29, 0xa5c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2652 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830E54A0: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 830E54A4: C3EA0B6C  lfs f31, 0xb6c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2924 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830E54A8: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 830E54AC: C3CB0BE4  lfs f30, 0xbe4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3044 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830E54B0: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 830E54B4: 3B5F0004  addi r26, r31, 4
	ctx.r[26].s64 = ctx.r[31].s64 + 4;
	// 830E54B8: 3AC0FFFF  li r22, -1
	ctx.r[22].s64 = -1;
	// 830E54BC: 48000010  b 0x830e54cc
	pc = 0x830E54CC; continue 'dispatch;
	// 830E54C0: 82E10078  lwz r23, 0x78(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830E54C4: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 830E54C8: 83610070  lwz r27, 0x70(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
            }
            0x830E54CC => {
    //   block [0x830E54CC..0x830E55B0)
	// 830E54CC: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	// 830E54D0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E54D4: 92C1005C  stw r22, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[22].u32 ) };
	// 830E54D8: FDA0F090  fmr f13, f30
	ctx.f[13].f64 = ctx.f[30].f64;
	// 830E54DC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830E54E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E54E4: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 830E54E8: 409901FC  ble cr6, 0x830e56e4
	if !ctx.cr[6].gt {
	pc = 0x830E56E4; continue 'dispatch;
	}
	// 830E54EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E54F0: 38670001  addi r3, r7, 1
	ctx.r[3].s64 = ctx.r[7].s64 + 1;
	// 830E54F4: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 830E54F8: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E54FC: 409800B4  bge cr6, 0x830e55b0
	if !ctx.cr[6].lt {
	pc = 0x830E55B0; continue 'dispatch;
	}
	// 830E5500: 38C40010  addi r6, r4, 0x10
	ctx.r[6].s64 = ctx.r[4].s64 + 16;
	// 830E5504: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5508: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	pc = 0x830E55B0; continue 'dispatch;
            }
            0x830E55B0 => {
    //   block [0x830E55B0..0x830E56E4)
	// 830E55B0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E55B4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 830E55B8: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 830E55BC: 7F075800  cmpw cr6, r7, r11
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E55C0: 4198FF30  blt cr6, 0x830e54f0
	if ctx.cr[6].lt {
	pc = 0x830E54F0; continue 'dispatch;
	}
	// 830E55C4: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 830E55C8: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 830E55CC: 419A0118  beq cr6, 0x830e56e4
	if ctx.cr[6].eq {
	pc = 0x830E56E4; continue 'dispatch;
	}
	// 830E55D0: 56EB00BE  clrlwi r11, r23, 2
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x3FFFFFFFu64;
	// 830E55D4: 7F055800  cmpw cr6, r5, r11
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E55D8: 409A0018  bne cr6, 0x830e55f0
	if !ctx.cr[6].eq {
	pc = 0x830E55F0; continue 'dispatch;
	}
	// 830E55DC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 830E55E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 830E55E4: 4BC719B5  bl 0x82d56f98
	ctx.lr = 0x830E55E8;
	sub_82D56F98(ctx, base);
	// 830E55E8: 80A10074  lwz r5, 0x74(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 830E55EC: 83610070  lwz r27, 0x70(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830E55F0: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830E55F4: 54AB1838  slwi r11, r5, 3
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E55F8: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 830E55FC: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 830E5600: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E5604: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E5608: 7D4BD92A  stdx r10, r11, r27
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32), ctx.r[10].u64) };
	// 830E560C: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 830E5610: 80DC0000  lwz r6, 0(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5614: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830E5618: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E561C: 54CA2036  slwi r10, r6, 4
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830E5620: 54A92036  slwi r9, r5, 4
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830E5624: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830E5628: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E562C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830E5630: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	pc = 0x830E56E4; continue 'dispatch;
            }
            0x830E56E4 => {
    //   block [0x830E56E4..0x830E5768)
	// 830E56E4: 56EB0000  rlwinm r11, r23, 0, 0, 0
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0xFFFFFFFFu64;
	// 830E56E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E56EC: 409A0020  bne cr6, 0x830e570c
	if !ctx.cr[6].eq {
	pc = 0x830E570C; continue 'dispatch;
	}
	// 830E56F0: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E56F4: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830E56F8: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830E56FC: 56E51838  slwi r5, r23, 3
	ctx.r[5].u32 = ctx.r[23].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830E5700: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830E5704: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830E5708: 4BC6FBC1  bl 0x82d552c8
	ctx.lr = 0x830E570C;
	sub_82D552C8(ctx, base);
	// 830E570C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E5710: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 830E5714: CBA1FF88  lfd f29, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 830E5718: CBC1FF90  lfd f30, -0x70(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 830E571C: CBE1FF98  lfd f31, -0x68(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 830E5720: 4BBC3D1C  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
	// 830E5724: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830E5728: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E572C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E5730: 409A0020  bne cr6, 0x830e5750
	if !ctx.cr[6].eq {
	pc = 0x830E5750; continue 'dispatch;
	}
	// 830E5734: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5738: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830E573C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830E5740: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830E5744: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830E5748: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830E574C: 4BC6FB7D  bl 0x82d552c8
	ctx.lr = 0x830E5750;
	sub_82D552C8(ctx, base);
	// 830E5750: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E5754: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 830E5758: CBA1FF88  lfd f29, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 830E575C: CBC1FF90  lfd f30, -0x70(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 830E5760: CBE1FF98  lfd f31, -0x68(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 830E5764: 4BBC3CD8  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E5768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E5768 size=612
    let mut pc: u32 = 0x830E5768;
    'dispatch: loop {
        match pc {
            0x830E5768 => {
    //   block [0x830E5768..0x830E57A0)
	// 830E5768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E576C: 4BBC3C95  bl 0x82ca9400
	ctx.lr = 0x830E5770;
	sub_82CA93D0(ctx, base);
	// 830E5770: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E5774: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830E5778: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830E577C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E5780: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830E5784: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 830E5788: 80FC0004  lwz r7, 4(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E578C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 830E5790: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 830E5794: 40990078  ble cr6, 0x830e580c
	if !ctx.cr[6].gt {
	pc = 0x830E580C; continue 'dispatch;
	}
	// 830E5798: 811D0000  lwz r8, 0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E579C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x830E57A0; continue 'dispatch;
            }
            0x830E57A0 => {
    //   block [0x830E57A0..0x830E57BC)
	// 830E57A0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E57A4: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830E57A8: 409A0014  bne cr6, 0x830e57bc
	if !ctx.cr[6].eq {
	pc = 0x830E57BC; continue 'dispatch;
	}
	// 830E57AC: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E57B0: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E57B4: 7F062800  cmpw cr6, r6, r5
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[5].s32, &mut ctx.xer);
	// 830E57B8: 419A001C  beq cr6, 0x830e57d4
	if ctx.cr[6].eq {
	pc = 0x830E57D4; continue 'dispatch;
	}
	pc = 0x830E57BC; continue 'dispatch;
            }
            0x830E57BC => {
    //   block [0x830E57BC..0x830E57D4)
	// 830E57BC: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E57C0: 7F064000  cmpw cr6, r6, r8
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[8].s32, &mut ctx.xer);
	// 830E57C4: 409A0018  bne cr6, 0x830e57dc
	if !ctx.cr[6].eq {
	pc = 0x830E57DC; continue 'dispatch;
	}
	// 830E57C8: 80DD0004  lwz r6, 4(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E57CC: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 830E57D0: 409A000C  bne cr6, 0x830e57dc
	if !ctx.cr[6].eq {
	pc = 0x830E57DC; continue 'dispatch;
	}
	pc = 0x830E57D4; continue 'dispatch;
            }
            0x830E57D4 => {
    //   block [0x830E57D4..0x830E57DC)
	// 830E57D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830E57D8: 48000008  b 0x830e57e0
	pc = 0x830E57E0; continue 'dispatch;
            }
            0x830E57DC => {
    //   block [0x830E57DC..0x830E57E0)
	// 830E57DC: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x830E57E0; continue 'dispatch;
            }
            0x830E57E0 => {
    //   block [0x830E57E0..0x830E5804)
	// 830E57E0: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 830E57E4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E57E8: 409A001C  bne cr6, 0x830e5804
	if !ctx.cr[6].eq {
	pc = 0x830E5804; continue 'dispatch;
	}
	// 830E57EC: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E57F0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830E57F4: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 830E57F8: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830E57FC: 4198FFA4  blt cr6, 0x830e57a0
	if ctx.cr[6].lt {
	pc = 0x830E57A0; continue 'dispatch;
	}
	// 830E5800: 4800000C  b 0x830e580c
	pc = 0x830E580C; continue 'dispatch;
            }
            0x830E5804 => {
    //   block [0x830E5804..0x830E580C)
	// 830E5804: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 830E5808: 409A01BC  bne cr6, 0x830e59c4
	if !ctx.cr[6].eq {
	pc = 0x830E59C4; continue 'dispatch;
	}
	pc = 0x830E580C; continue 'dispatch;
            }
            0x830E580C => {
    //   block [0x830E580C..0x830E5828)
	// 830E580C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E5810: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830E5814: 7F075800  cmpw cr6, r7, r11
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E5818: 409A0010  bne cr6, 0x830e5828
	if !ctx.cr[6].eq {
	pc = 0x830E5828; continue 'dispatch;
	}
	// 830E581C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 830E5820: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E5824: 4BC71775  bl 0x82d56f98
	ctx.lr = 0x830E5828;
	sub_82D56F98(ctx, base);
	pc = 0x830E5828; continue 'dispatch;
            }
            0x830E5828 => {
    //   block [0x830E5828..0x830E59C4)
	// 830E5828: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E582C: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 830E5830: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5834: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 830E5838: 38CB0001  addi r6, r11, 1
	ctx.r[6].s64 = ctx.r[11].s64 + 1;
	// 830E583C: 556A2834  slwi r10, r11, 5
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830E5840: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 830E5844: 7D6A4214  add r11, r10, r8
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 830E5848: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830E584C: 90DC0004  stw r6, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 830E5850: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830E5854: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5858: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830E585C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E5860: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830E5864: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E5868: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x830E59C4; continue 'dispatch;
            }
            0x830E59C4 => {
    //   block [0x830E59C4..0x830E59CC)
	// 830E59C4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 830E59C8: 4BBC3A88  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E59D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E59D0 size=1848
    let mut pc: u32 = 0x830E59D0;
    'dispatch: loop {
        match pc {
            0x830E59D0 => {
    //   block [0x830E59D0..0x830E5A28)
	// 830E59D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E59D4: 4BBC3A29  bl 0x82ca93fc
	ctx.lr = 0x830E59D8;
	sub_82CA93D0(ctx, base);
	// 830E59D8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 830E59DC: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 830E59E0: 9421EED0  stwu r1, -0x1130(r1)
	ea = ctx.r[1].u32.wrapping_add(-4400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E59E4: 812D0000  lwz r9, 0(r13)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E59E8: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 830E59EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E59F0: 7F295A14  add r25, r9, r11
	ctx.r[25].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 830E59F4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830E59F8: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E59FC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E5A00: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E5A04: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830E5A08: 40980020  bge cr6, 0x830e5a28
	if !ctx.cr[6].lt {
	pc = 0x830E5A28; continue 'dispatch;
	}
	// 830E5A0C: 3D008208  lis r8, -0x7df8
	ctx.r[8].s64 = -2113404928;
	// 830E5A10: 3908A61C  addi r8, r8, -0x59e4
	ctx.r[8].s64 = ctx.r[8].s64 + -23012;
	// 830E5A14: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830E5A18: 7D0C42E6  mftb r8, 0x10c
	ctx.r[8].u64 = crate::rt::rdtsc_u64();
	// 830E5A1C: 38EB000C  addi r7, r11, 0xc
	ctx.r[7].s64 = ctx.r[11].s64 + 12;
	// 830E5A20: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 830E5A24: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	pc = 0x830E5A28; continue 'dispatch;
            }
            0x830E5A28 => {
    //   block [0x830E5A28..0x830E5A70)
	// 830E5A28: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 830E5A2C: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E5A30: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830E5A34: 7F495A14  add r26, r9, r11
	ctx.r[26].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 830E5A38: 3FA08000  lis r29, -0x8000
	ctx.r[29].s64 = -2147483648;
	// 830E5A3C: 395F0001  addi r10, r31, 1
	ctx.r[10].s64 = ctx.r[31].s64 + 1;
	// 830E5A40: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 830E5A44: 55442036  slwi r4, r10, 4
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830E5A48: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5A4C: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 830E5A50: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 830E5A54: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830E5A58: 810B002C  lwz r8, 0x2c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 830E5A5C: 7D2A2214  add r9, r10, r4
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 830E5A60: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830E5A64: 4199000C  bgt cr6, 0x830e5a70
	if ctx.cr[6].gt {
	pc = 0x830E5A70; continue 'dispatch;
	}
	// 830E5A68: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 830E5A6C: 4800001C  b 0x830e5a88
	pc = 0x830E5A88; continue 'dispatch;
            }
            0x830E5A70 => {
    //   block [0x830E5A70..0x830E5A88)
	// 830E5A70: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5A74: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 830E5A78: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 830E5A7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830E5A80: 4E800421  bctrl
	ctx.lr = 0x830E5A84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830E5A84: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
            }
            0x830E5A88 => {
    //   block [0x830E5A88..0x830E5AD4)
	// 830E5A88: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E5A8C: 7FEBEB78  or r11, r31, r29
	ctx.r[11].u64 = ctx.r[31].u64 | ctx.r[29].u64;
	// 830E5A90: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 830E5A94: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 830E5A98: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830E5A9C: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 830E5AA0: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 830E5AA4: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 830E5AA8: 4099002C  ble cr6, 0x830e5ad4
	if !ctx.cr[6].gt {
	pc = 0x830E5AD4; continue 'dispatch;
	}
	// 830E5AAC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 830E5AB0: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5AB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	pc = 0x830E5AD4; continue 'dispatch;
            }
            0x830E5AD4 => {
    //   block [0x830E5AD4..0x830E6108)
	// 830E5AD4: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 830E5AD8: 4099001C  ble cr6, 0x830e5af4
	if !ctx.cr[6].gt {
	pc = 0x830E5AF4; continue 'dispatch;
	}
	// 830E5ADC: 3D60830E  lis r11, -0x7cf2
	ctx.r[11].s64 = -2096234496;
	// 830E5AE0: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830E5AE4: 38A9FFFF  addi r5, r9, -1
	ctx.r[5].s64 = ctx.r[9].s64 + -1;
	// 830E5AE8: 38CB6A18  addi r6, r11, 0x6a18
	ctx.r[6].s64 = ctx.r[11].s64 + 27160;
	// 830E5AEC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E5AF0: 48000619  bl 0x830e6108
	ctx.lr = 0x830E5AF4;
	sub_830E6108(ctx, base);
	// 830E5AF4: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 830E5AF8: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 830E5AFC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830E5B00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830E5B04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830E5B08: 4BFFF949  bl 0x830e5450
	ctx.lr = 0x830E5B0C;
	sub_830E5450(ctx, base);
	// 830E5B0C: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 830E5B10: 409A0090  bne cr6, 0x830e5ba0
	if !ctx.cr[6].eq {
	pc = 0x830E5BA0; continue 'dispatch;
	}
	// 830E5B14: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5B18: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E5B1C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E5B20: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830E5B24: 40980020  bge cr6, 0x830e5b44
	if !ctx.cr[6].lt {
	pc = 0x830E5B44; continue 'dispatch;
	}
	// 830E5B28: 3D208202  lis r9, -0x7dfe
	ctx.r[9].s64 = -2113798144;
	// 830E5B2C: 392964CC  addi r9, r9, 0x64cc
	ctx.r[9].s64 = ctx.r[9].s64 + 25804;
	// 830E5B30: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830E5B34: 7D2C42E6  mftb r9, 0x10c
	ctx.r[9].u64 = crate::rt::rdtsc_u64();
	// 830E5B38: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 830E5B3C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830E5B40: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 830E5B44: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5B48: 8081006C  lwz r4, 0x6c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830E5B4C: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830E5B50: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 830E5B54: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E5B58: 409A0014  bne cr6, 0x830e5b6c
	if !ctx.cr[6].eq {
	pc = 0x830E5B6C; continue 'dispatch;
	}
	// 830E5B5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5B60: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830E5B64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830E5B68: 4E800421  bctrl
	ctx.lr = 0x830E5B6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830E5B6C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830E5B70: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830E5B74: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E5B78: 409A0018  bne cr6, 0x830e5b90
	if !ctx.cr[6].eq {
	pc = 0x830E5B90; continue 'dispatch;
	}
	// 830E5B7C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830E5B80: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5B84: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830E5B88: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830E5B8C: 4BC6F73D  bl 0x82d552c8
	ctx.lr = 0x830E5B90;
	sub_82D552C8(ctx, base);
	// 830E5B90: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830E5B94: 38211130  addi r1, r1, 0x1130
	ctx.r[1].s64 = ctx.r[1].s64 + 4400;
	// 830E5B98: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 830E5B9C: 4BBC38B0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
	// 830E5BA0: 394100E0  addi r10, r1, 0xe0
	ctx.r[10].s64 = ctx.r[1].s64 + 224;
	// 830E5BA4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E5BA8: 3D208000  lis r9, -0x8000
	ctx.r[9].s64 = -2147483648;
	// 830E5BAC: 936100D4  stw r27, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[27].u32 ) };
	// 830E5BB0: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830E5BB4: 61290080  ori r9, r9, 0x80
	ctx.r[9].u64 = ctx.r[9].u64 | 128;
	// 830E5BB8: 3BBC0008  addi r29, r28, 8
	ctx.r[29].s64 = ctx.r[28].s64 + 8;
	// 830E5BBC: 914100D0  stw r10, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 830E5BC0: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 830E5BC4: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E5BC8: 912100D8  stw r9, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[9].u32 ) };
	// 830E5BCC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E5BD0: 409A0010  bne cr6, 0x830e5be0
	if !ctx.cr[6].eq {
	pc = 0x830E5BE0; continue 'dispatch;
	}
	// 830E5BD4: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 830E5BD8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E5BDC: 4BC713BD  bl 0x82d56f98
	ctx.lr = 0x830E5BE0;
	sub_82D56F98(ctx, base);
	// 830E5BE0: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 830E5BE4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5BE8: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E5BEC: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6108 size=332
    let mut pc: u32 = 0x830E6108;
    'dispatch: loop {
        match pc {
            0x830E6108 => {
    //   block [0x830E6108..0x830E6254)
	// 830E6108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E610C: 4BBC32F1  bl 0x82ca93fc
	ctx.lr = 0x830E6110;
	sub_82CA93D0(ctx, base);
	// 830E6110: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6114: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830E6118: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830E611C: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 830E6120: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830E6124: 7D7ACA14  add r11, r26, r25
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[25].u64;
	// 830E6128: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 830E612C: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 830E6130: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 830E6134: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E6258 size=32
    let mut pc: u32 = 0x830E6258;
    'dispatch: loop {
        match pc {
            0x830E6258 => {
    //   block [0x830E6258..0x830E6278)
	// 830E6258: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E625C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E6260: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 830E6264: 40980014  bge cr6, 0x830e6278
	if !ctx.cr[6].lt {
		sub_830E6278(ctx, base);
		return;
	}
	// 830E6268: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E626C: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E6270: EC201028  fsubs f1, f0, f2
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[2].f64) as f32) as f64);
	// 830E6274: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E6278 size=16
    let mut pc: u32 = 0x830E6278;
    'dispatch: loop {
        match pc {
            0x830E6278 => {
    //   block [0x830E6278..0x830E6288)
	// 830E6278: FF020000  fcmpu cr6, f2, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 830E627C: 4099000C  ble cr6, 0x830e6288
	if !ctx.cr[6].gt {
		sub_830E6288(ctx, base);
		return;
	}
	// 830E6280: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 830E6284: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E6288 size=16
    let mut pc: u32 = 0x830E6288;
    'dispatch: loop {
        match pc {
            0x830E6288 => {
    //   block [0x830E6288..0x830E6298)
	// 830E6288: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E628C: C00B0A4C  lfs f0, 0xa4c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2636 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E6290: EC201028  fsubs f1, f0, f2
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[2].f64) as f32) as f64);
	// 830E6294: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E6298 size=4
    let mut pc: u32 = 0x830E6298;
    'dispatch: loop {
        match pc {
            0x830E6298 => {
    //   block [0x830E6298..0x830E629C)
	// 830E6298: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E62A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E62A0 size=188
    let mut pc: u32 = 0x830E62A0;
    'dispatch: loop {
        match pc {
            0x830E62A0 => {
    //   block [0x830E62A0..0x830E635C)
	// 830E62A0: C1A40000  lfs f13, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E62A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E62A8: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E62AC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E635C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E635C size=252
    let mut pc: u32 = 0x830E635C;
    'dispatch: loop {
        match pc {
            0x830E635C => {
    //   block [0x830E635C..0x830E6458)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E6458 size=52
    let mut pc: u32 = 0x830E6458;
    'dispatch: loop {
        match pc {
            0x830E6458 => {
    //   block [0x830E6458..0x830E648C)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E648C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E648C size=196
    let mut pc: u32 = 0x830E648C;
    'dispatch: loop {
        match pc {
            0x830E648C => {
    //   block [0x830E648C..0x830E6550)
	// 830E648C: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 830E6490: 3941FFE0  addi r10, r1, -0x20
	ctx.r[10].s64 = ctx.r[1].s64 + -32;
	// 830E6494: 3921FFE0  addi r9, r1, -0x20
	ctx.r[9].s64 = ctx.r[1].s64 + -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E6550 size=348
    let mut pc: u32 = 0x830E6550;
    'dispatch: loop {
        match pc {
            0x830E6550 => {
    //   block [0x830E6550..0x830E65A0)
	// 830E6550: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E6554: FD800210  fabs f12, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 830E6558: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830E655C: C0E30030  lfs f7, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830E6560: C12B0DB0  lfs f9, 0xdb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3504 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830E6564: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830E6568: C10A0C24  lfs f8, 0xc24(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3108 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 830E656C: C0CBBDF8  lfs f6, -0x4208(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16904 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 830E6570: FF0C4800  fcmpu cr6, f12, f9
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[9].f64);
	// 830E6574: 4098002C  bge cr6, 0x830e65a0
	if !ctx.cr[6].lt {
	pc = 0x830E65A0; continue 'dispatch;
	}
	// 830E6578: FD806A10  fabs f12, f13
	ctx.f[12].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 830E657C: FF0C4000  fcmpu cr6, f12, f8
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[8].f64);
	// 830E6580: 40980020  bge cr6, 0x830e65a0
	if !ctx.cr[6].lt {
	pc = 0x830E65A0; continue 'dispatch;
	}
	// 830E6584: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E6588: 396B0C18  addi r11, r11, 0xc18
	ctx.r[11].s64 = ctx.r[11].s64 + 3096;
	// 830E658C: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830E6590: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E6594: C00B0A4C  lfs f0, 0xa4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2636 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E6598: FC2D02AE  fsel f1, f13, f10, f0
	ctx.f[1].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[10].f64 } else { ctx.f[0].f64 };
	// 830E659C: 480000F0  b 0x830e668c
	pc = 0x830E668C; continue 'dispatch;
            }
            0x830E65A0 => {
    //   block [0x830E65A0..0x830E65EC)
	// 830E65A0: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 830E65A4: FD606A10  fabs f11, f13
	ctx.f[11].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 830E65A8: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 830E65AC: 4099004C  ble cr6, 0x830e65f8
	if !ctx.cr[6].gt {
	pc = 0x830E65F8; continue 'dispatch;
	}
	// 830E65B0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830E65B4: ED8D0024  fdivs f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 830E65B8: C1ABA630  lfs f13, -0x59d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22992 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E65BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E65C0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830E65C4: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E65C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E65CC: EDA06028  fsubs f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 830E65D0: 396B0C18  addi r11, r11, 0xc18
	ctx.r[11].s64 = ctx.r[11].s64 + 3096;
	// 830E65D4: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830E65D8: 40980014  bge cr6, 0x830e65ec
	if !ctx.cr[6].lt {
	pc = 0x830E65EC; continue 'dispatch;
	}
	// 830E65DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E65E0: C00B0A4C  lfs f0, 0xa4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2636 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E65E4: EC20682A  fadds f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830E65E8: 480000A4  b 0x830e668c
	pc = 0x830E668C; continue 'dispatch;
            }
            0x830E65EC => {
    //   block [0x830E65EC..0x830E65F8)
	// 830E65EC: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	// 830E65F0: EC20682A  fadds f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 830E65F4: 48000098  b 0x830e668c
	pc = 0x830E668C; continue 'dispatch;
            }
            0x830E65F8 => {
    //   block [0x830E65F8..0x830E6630)
	// 830E65F8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830E65FC: ED606824  fdivs f11, f0, f13
	ctx.f[11].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 830E6600: C18BA62C  lfs f12, -0x59d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22996 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E6604: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E6608: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 830E660C: 396B0C18  addi r11, r11, 0xc18
	ctx.r[11].s64 = ctx.r[11].s64 + 3096;
	// 830E6610: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830E6614: 4098001C  bge cr6, 0x830e6630
	if !ctx.cr[6].lt {
	pc = 0x830E6630; continue 'dispatch;
	}
	// 830E6618: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 830E661C: FF0C4800  fcmpu cr6, f12, f9
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[9].f64);
	// 830E6620: 40980010  bge cr6, 0x830e6630
	if !ctx.cr[6].lt {
	pc = 0x830E6630; continue 'dispatch;
	}
	// 830E6624: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E6628: C18B0A4C  lfs f12, 0xa4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2636 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E662C: 48000028  b 0x830e6654
	pc = 0x830E6654; continue 'dispatch;
            }
            0x830E6630 => {
    //   block [0x830E6630..0x830E664C)
	// 830E6630: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830E6634: C18BA630  lfs f12, -0x59d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22992 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E6638: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 830E663C: 40980010  bge cr6, 0x830e664c
	if !ctx.cr[6].lt {
	pc = 0x830E664C; continue 'dispatch;
	}
	// 830E6640: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E6644: C18B0A4C  lfs f12, 0xa4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2636 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E6648: 48000008  b 0x830e6650
	pc = 0x830E6650; continue 'dispatch;
            }
            0x830E664C => {
    //   block [0x830E664C..0x830E6650)
	// 830E664C: FD805090  fmr f12, f10
	ctx.f[12].f64 = ctx.f[10].f64;
	pc = 0x830E6650; continue 'dispatch;
            }
            0x830E6650 => {
    //   block [0x830E6650..0x830E6654)
	// 830E6650: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	pc = 0x830E6654; continue 'dispatch;
            }
            0x830E6654 => {
    //   block [0x830E6654..0x830E6668)
	// 830E6654: FD606210  fabs f11, f12
	ctx.f[11].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 830E6658: FF0B3800  fcmpu cr6, f11, f7
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[7].f64);
	// 830E665C: 4098000C  bge cr6, 0x830e6668
	if !ctx.cr[6].lt {
	pc = 0x830E6668; continue 'dispatch;
	}
	// 830E6660: FC205090  fmr f1, f10
	ctx.f[1].f64 = ctx.f[10].f64;
	// 830E6664: 48000028  b 0x830e668c
	pc = 0x830E668C; continue 'dispatch;
            }
            0x830E6668 => {
    //   block [0x830E6668..0x830E6684)
	// 830E6668: FF0D4800  fcmpu cr6, f13, f9
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[9].f64);
	// 830E666C: 40990018  ble cr6, 0x830e6684
	if !ctx.cr[6].gt {
	pc = 0x830E6684; continue 'dispatch;
	}
	// 830E6670: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 830E6674: FF004000  fcmpu cr6, f0, f8
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[8].f64);
	// 830E6678: 4098000C  bge cr6, 0x830e6684
	if !ctx.cr[6].lt {
	pc = 0x830E6684; continue 'dispatch;
	}
	// 830E667C: FC003090  fmr f0, f6
	ctx.f[0].f64 = ctx.f[6].f64;
	// 830E6680: 48000008  b 0x830e6688
	pc = 0x830E6688; continue 'dispatch;
            }
            0x830E6684 => {
    //   block [0x830E6684..0x830E6688)
	// 830E6684: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	pc = 0x830E6688; continue 'dispatch;
            }
            0x830E6688 => {
    //   block [0x830E6688..0x830E668C)
	// 830E6688: EC20602A  fadds f1, f0, f12
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	pc = 0x830E668C; continue 'dispatch;
            }
            0x830E668C => {
    //   block [0x830E668C..0x830E669C)
	// 830E668C: FC003850  fneg f0, f7
	ctx.f[0].u64 = ctx.f[7].u64 ^ 0x8000_0000_0000_0000u64;
	// 830E6690: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 830E6694: 40980008  bge cr6, 0x830e669c
	if !ctx.cr[6].lt {
	pc = 0x830E669C; continue 'dispatch;
	}
	// 830E6698: EC21302A  fadds f1, f1, f6
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[6].f64) as f32) as f64;
	pc = 0x830E669C; continue 'dispatch;
            }
            0x830E669C => {
    //   block [0x830E669C..0x830E66AC)
	// 830E669C: FF013000  fcmpu cr6, f1, f6
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[6].f64);
	// 830E66A0: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 830E66A4: FC205090  fmr f1, f10
	ctx.f[1].f64 = ctx.f[10].f64;
	// 830E66A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E66B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E66B0 size=868
    let mut pc: u32 = 0x830E66B0;
    'dispatch: loop {
        match pc {
            0x830E66B0 => {
    //   block [0x830E66B0..0x830E66EC)
	// 830E66B0: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 830E66B4: 419A0038  beq cr6, 0x830e66ec
	if ctx.cr[6].eq {
	pc = 0x830E66EC; continue 'dispatch;
	}
	// 830E66B8: A1650000  lhz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E66BC: A1460000  lhz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E66C0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830E66C4: 409A0028  bne cr6, 0x830e66ec
	if !ctx.cr[6].eq {
	pc = 0x830E66EC; continue 'dispatch;
	}
	// 830E66C8: A1650002  lhz r11, 2(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E66CC: A1460002  lhz r10, 2(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E66D0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830E66D4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 830E66D8: 7D6B222E  lhzx r11, r11, r4
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830E66DC: 7D4A222E  lhzx r10, r10, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830E66E0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830E66E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830E66E8: 409A0008  bne cr6, 0x830e66f0
	if !ctx.cr[6].eq {
	pc = 0x830E66F0; continue 'dispatch;
	}
	pc = 0x830E66EC; continue 'dispatch;
            }
            0x830E66EC => {
    //   block [0x830E66EC..0x830E66F0)
	// 830E66EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x830E66F0; continue 'dispatch;
            }
            0x830E66F0 => {
    //   block [0x830E66F0..0x830E672C)
	// 830E66F0: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830E66F4: 419A0038  beq cr6, 0x830e672c
	if ctx.cr[6].eq {
	pc = 0x830E672C; continue 'dispatch;
	}
	// 830E66F8: A1670000  lhz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E66FC: A1280000  lhz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6700: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830E6704: 409A0028  bne cr6, 0x830e672c
	if !ctx.cr[6].eq {
	pc = 0x830E672C; continue 'dispatch;
	}
	// 830E6708: A1670002  lhz r11, 2(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E670C: A1280002  lhz r9, 2(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E6710: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830E6714: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 830E6718: 7D6B222E  lhzx r11, r11, r4
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830E671C: 7D29222E  lhzx r9, r9, r4
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830E6720: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830E6724: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E6728: 409A0008  bne cr6, 0x830e6730
	if !ctx.cr[6].eq {
	pc = 0x830E6730; continue 'dispatch;
	}
	pc = 0x830E672C; continue 'dispatch;
            }
            0x830E672C => {
    //   block [0x830E672C..0x830E6730)
	// 830E672C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830E6730; continue 'dispatch;
            }
            0x830E6730 => {
    //   block [0x830E6730..0x830E674C)
	// 830E6730: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 830E6734: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E6738: 419A0014  beq cr6, 0x830e674c
	if ctx.cr[6].eq {
	pc = 0x830E674C; continue 'dispatch;
	}
	// 830E673C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830E6740: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E6744: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E6748: 409A0008  bne cr6, 0x830e6750
	if !ctx.cr[6].eq {
	pc = 0x830E6750; continue 'dispatch;
	}
	pc = 0x830E674C; continue 'dispatch;
            }
            0x830E674C => {
    //   block [0x830E674C..0x830E6750)
	// 830E674C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830E6750; continue 'dispatch;
            }
            0x830E6750 => {
    //   block [0x830E6750..0x830E67A4)
	// 830E6750: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 830E6754: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830E6758: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E675C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 830E6760: 7F054040  cmplw cr6, r5, r8
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830E6764: 419A0040  beq cr6, 0x830e67a4
	if ctx.cr[6].eq {
	pc = 0x830E67A4; continue 'dispatch;
	}
	// 830E6768: A1650000  lhz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E676C: A1480000  lhz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6770: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830E6774: 409A0030  bne cr6, 0x830e67a4
	if !ctx.cr[6].eq {
	pc = 0x830E67A4; continue 'dispatch;
	}
	// 830E6778: A1650002  lhz r11, 2(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E677C: A1480002  lhz r10, 2(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E6780: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830E6784: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 830E6788: 7D6B222E  lhzx r11, r11, r4
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830E678C: 7D4A222E  lhzx r10, r10, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830E6790: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830E6794: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830E6798: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830E679C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 830E67A0: 48000008  b 0x830e67a8
	pc = 0x830E67A8; continue 'dispatch;
            }
            0x830E67A4 => {
    //   block [0x830E67A4..0x830E67A8)
	// 830E67A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830E67A8; continue 'dispatch;
            }
            0x830E67A8 => {
    //   block [0x830E67A8..0x830E67F8)
	// 830E67A8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830E67AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E67B0: 419A0048  beq cr6, 0x830e67f8
	if ctx.cr[6].eq {
	pc = 0x830E67F8; continue 'dispatch;
	}
	// 830E67B4: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830E67B8: 419A0040  beq cr6, 0x830e67f8
	if ctx.cr[6].eq {
	pc = 0x830E67F8; continue 'dispatch;
	}
	// 830E67BC: A1670000  lhz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E67C0: A1480000  lhz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E67C4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830E67C8: 409A0030  bne cr6, 0x830e67f8
	if !ctx.cr[6].eq {
	pc = 0x830E67F8; continue 'dispatch;
	}
	// 830E67CC: A1670002  lhz r11, 2(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E67D0: A1480002  lhz r10, 2(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E67D4: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830E67D8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 830E67DC: 7D6B222E  lhzx r11, r11, r4
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830E67E0: 7D4A222E  lhzx r10, r10, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830E67E4: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 830E67E8: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830E67EC: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830E67F0: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 830E67F4: 48000008  b 0x830e67fc
	pc = 0x830E67FC; continue 'dispatch;
            }
            0x830E67F8 => {
    //   block [0x830E67F8..0x830E67FC)
	// 830E67F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830E67FC; continue 'dispatch;
            }
            0x830E67FC => {
    //   block [0x830E67FC..0x830E684C)
	// 830E67FC: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830E6800: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E6804: 419A0048  beq cr6, 0x830e684c
	if ctx.cr[6].eq {
	pc = 0x830E684C; continue 'dispatch;
	}
	// 830E6808: A1650002  lhz r11, 2(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E680C: A1480000  lhz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6810: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830E6814: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 830E6818: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E681C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830E6820: 409A002C  bne cr6, 0x830e684c
	if !ctx.cr[6].eq {
	pc = 0x830E684C; continue 'dispatch;
	}
	// 830E6824: A1480002  lhz r10, 2(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E6828: A1250000  lhz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E682C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 830E6830: 7D4A222E  lhzx r10, r10, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830E6834: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830E6838: 409A0014  bne cr6, 0x830e684c
	if !ctx.cr[6].eq {
	pc = 0x830E684C; continue 'dispatch;
	}
	// 830E683C: 7D6B4050  subf r11, r11, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 830E6840: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830E6844: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830E6848: 48000008  b 0x830e6850
	pc = 0x830E6850; continue 'dispatch;
            }
            0x830E684C => {
    //   block [0x830E684C..0x830E6850)
	// 830E684C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830E6850; continue 'dispatch;
            }
            0x830E6850 => {
    //   block [0x830E6850..0x830E68A0)
	// 830E6850: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830E6854: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E6858: 419A0048  beq cr6, 0x830e68a0
	if ctx.cr[6].eq {
	pc = 0x830E68A0; continue 'dispatch;
	}
	// 830E685C: A1670002  lhz r11, 2(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E6860: A1480000  lhz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6864: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830E6868: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 830E686C: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6870: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830E6874: 409A002C  bne cr6, 0x830e68a0
	if !ctx.cr[6].eq {
	pc = 0x830E68A0; continue 'dispatch;
	}
	// 830E6878: A1480002  lhz r10, 2(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E687C: A1270000  lhz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6880: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 830E6884: 7D4A222E  lhzx r10, r10, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830E6888: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830E688C: 409A0014  bne cr6, 0x830e68a0
	if !ctx.cr[6].eq {
	pc = 0x830E68A0; continue 'dispatch;
	}
	// 830E6890: 7D6B4050  subf r11, r11, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 830E6894: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830E6898: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830E689C: 48000008  b 0x830e68a4
	pc = 0x830E68A4; continue 'dispatch;
            }
            0x830E68A0 => {
    //   block [0x830E68A0..0x830E68A4)
	// 830E68A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830E68A4; continue 'dispatch;
            }
            0x830E68A4 => {
    //   block [0x830E68A4..0x830E68EC)
	// 830E68A4: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 830E68A8: 7F053040  cmplw cr6, r5, r6
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[6].u32, &mut ctx.xer);
	// 830E68AC: 419A0040  beq cr6, 0x830e68ec
	if ctx.cr[6].eq {
	pc = 0x830E68EC; continue 'dispatch;
	}
	// 830E68B0: A1650000  lhz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E68B4: A1260000  lhz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E68B8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830E68BC: 409A0030  bne cr6, 0x830e68ec
	if !ctx.cr[6].eq {
	pc = 0x830E68EC; continue 'dispatch;
	}
	// 830E68C0: A1650002  lhz r11, 2(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E68C4: A1260002  lhz r9, 2(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E68C8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830E68CC: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 830E68D0: 7D6B222E  lhzx r11, r11, r4
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830E68D4: 7D29222E  lhzx r9, r9, r4
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830E68D8: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 830E68DC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830E68E0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830E68E4: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 830E68E8: 48000008  b 0x830e68f0
	pc = 0x830E68F0; continue 'dispatch;
            }
            0x830E68EC => {
    //   block [0x830E68EC..0x830E68F0)
	// 830E68EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830E68F0; continue 'dispatch;
            }
            0x830E68F0 => {
    //   block [0x830E68F0..0x830E6940)
	// 830E68F0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830E68F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E68F8: 419A0048  beq cr6, 0x830e6940
	if ctx.cr[6].eq {
	pc = 0x830E6940; continue 'dispatch;
	}
	// 830E68FC: 7F073040  cmplw cr6, r7, r6
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[6].u32, &mut ctx.xer);
	// 830E6900: 419A0040  beq cr6, 0x830e6940
	if ctx.cr[6].eq {
	pc = 0x830E6940; continue 'dispatch;
	}
	// 830E6904: A1660000  lhz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6908: A1270000  lhz r9, 0(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E690C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E6910: 409A0030  bne cr6, 0x830e6940
	if !ctx.cr[6].eq {
	pc = 0x830E6940; continue 'dispatch;
	}
	// 830E6914: A1660002  lhz r11, 2(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E6918: A1270002  lhz r9, 2(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E691C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830E6920: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 830E6924: 7D6B222E  lhzx r11, r11, r4
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830E6928: 7D29222E  lhzx r9, r9, r4
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830E692C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 830E6930: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830E6934: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830E6938: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 830E693C: 48000008  b 0x830e6944
	pc = 0x830E6944; continue 'dispatch;
            }
            0x830E6940 => {
    //   block [0x830E6940..0x830E6944)
	// 830E6940: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830E6944; continue 'dispatch;
            }
            0x830E6944 => {
    //   block [0x830E6944..0x830E6994)
	// 830E6944: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830E6948: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E694C: 419A0048  beq cr6, 0x830e6994
	if ctx.cr[6].eq {
	pc = 0x830E6994; continue 'dispatch;
	}
	// 830E6950: A1650002  lhz r11, 2(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E6954: A1260000  lhz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6958: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830E695C: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 830E6960: A10B0000  lhz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6964: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830E6968: 409A002C  bne cr6, 0x830e6994
	if !ctx.cr[6].eq {
	pc = 0x830E6994; continue 'dispatch;
	}
	// 830E696C: A1260002  lhz r9, 2(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E6970: A1050000  lhz r8, 0(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6974: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 830E6978: 7D29222E  lhzx r9, r9, r4
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830E697C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830E6980: 409A0014  bne cr6, 0x830e6994
	if !ctx.cr[6].eq {
	pc = 0x830E6994; continue 'dispatch;
	}
	// 830E6984: 7D6B3050  subf r11, r11, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 830E6988: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830E698C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830E6990: 48000008  b 0x830e6998
	pc = 0x830E6998; continue 'dispatch;
            }
            0x830E6994 => {
    //   block [0x830E6994..0x830E6998)
	// 830E6994: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830E6998; continue 'dispatch;
            }
            0x830E6998 => {
    //   block [0x830E6998..0x830E69E8)
	// 830E6998: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830E699C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E69A0: 419A0048  beq cr6, 0x830e69e8
	if ctx.cr[6].eq {
	pc = 0x830E69E8; continue 'dispatch;
	}
	// 830E69A4: A1670002  lhz r11, 2(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E69A8: A1260000  lhz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E69AC: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830E69B0: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 830E69B4: A10B0000  lhz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E69B8: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830E69BC: 409A002C  bne cr6, 0x830e69e8
	if !ctx.cr[6].eq {
	pc = 0x830E69E8; continue 'dispatch;
	}
	// 830E69C0: A1260002  lhz r9, 2(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E69C4: A1070000  lhz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E69C8: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 830E69CC: 7D29222E  lhzx r9, r9, r4
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 830E69D0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830E69D4: 409A0014  bne cr6, 0x830e69e8
	if !ctx.cr[6].eq {
	pc = 0x830E69E8; continue 'dispatch;
	}
	// 830E69D8: 7D6B3050  subf r11, r11, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 830E69DC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830E69E0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830E69E4: 48000008  b 0x830e69ec
	pc = 0x830E69EC; continue 'dispatch;
            }
            0x830E69E8 => {
    //   block [0x830E69E8..0x830E69EC)
	// 830E69E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830E69EC; continue 'dispatch;
            }
            0x830E69EC => {
    //   block [0x830E69EC..0x830E6A08)
	// 830E69EC: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 830E69F0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E69F4: 419A0014  beq cr6, 0x830e6a08
	if ctx.cr[6].eq {
	pc = 0x830E6A08; continue 'dispatch;
	}
	// 830E69F8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830E69FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E6A00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E6A04: 409A0008  bne cr6, 0x830e6a0c
	if !ctx.cr[6].eq {
	pc = 0x830E6A0C; continue 'dispatch;
	}
	pc = 0x830E6A08; continue 'dispatch;
            }
            0x830E6A08 => {
    //   block [0x830E6A08..0x830E6A0C)
	// 830E6A08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830E6A0C; continue 'dispatch;
            }
            0x830E6A0C => {
    //   block [0x830E6A0C..0x830E6A14)
	// 830E6A0C: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830E6A10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E6A18 size=28
    let mut pc: u32 = 0x830E6A18;
    'dispatch: loop {
        match pc {
            0x830E6A18 => {
    //   block [0x830E6A18..0x830E6A34)
	// 830E6A18: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E6A1C: C1A50000  lfs f13, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E6A20: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830E6A24: 40980010  bge cr6, 0x830e6a34
	if !ctx.cr[6].lt {
		sub_830E6A34(ctx, base);
		return;
	}
	// 830E6A28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E6A2C: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830E6A30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6A34(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E6A34 size=80
    let mut pc: u32 = 0x830E6A34;
    'dispatch: loop {
        match pc {
            0x830E6A34 => {
    //   block [0x830E6A34..0x830E6A4C)
	// 830E6A34: FF006800  fcmpu cr6, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830E6A38: 409A0014  bne cr6, 0x830e6a4c
	if !ctx.cr[6].eq {
	pc = 0x830E6A4C; continue 'dispatch;
	}
	// 830E6A3C: C1840004  lfs f12, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E6A40: C1650004  lfs f11, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830E6A44: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 830E6A48: 4198FFE0  blt cr6, 0x830e6a28
	if ctx.cr[6].lt {
		sub_830E6A18(ctx, base);
		return;
	}
	pc = 0x830E6A4C; continue 'dispatch;
            }
            0x830E6A4C => {
    //   block [0x830E6A4C..0x830E6A78)
	// 830E6A4C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830E6A50: 409A0028  bne cr6, 0x830e6a78
	if !ctx.cr[6].eq {
	pc = 0x830E6A78; continue 'dispatch;
	}
	// 830E6A54: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E6A58: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E6A5C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830E6A60: 409A0018  bne cr6, 0x830e6a78
	if !ctx.cr[6].eq {
	pc = 0x830E6A78; continue 'dispatch;
	}
	// 830E6A64: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E6A68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E6A6C: C1A50008  lfs f13, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E6A70: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830E6A74: 41980008  blt cr6, 0x830e6a7c
	if ctx.cr[6].lt {
	pc = 0x830E6A7C; continue 'dispatch;
	}
	pc = 0x830E6A78; continue 'dispatch;
            }
            0x830E6A78 => {
    //   block [0x830E6A78..0x830E6A7C)
	// 830E6A78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830E6A7C; continue 'dispatch;
            }
            0x830E6A7C => {
    //   block [0x830E6A7C..0x830E6A84)
	// 830E6A7C: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830E6A80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E6A88 size=32
    let mut pc: u32 = 0x830E6A88;
    'dispatch: loop {
        match pc {
            0x830E6A88 => {
    //   block [0x830E6A88..0x830E6AA0)
	// 830E6A88: C0040004  lfs f0, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E6A8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E6A90: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E6A94: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830E6A98: 41980008  blt cr6, 0x830e6aa0
	if ctx.cr[6].lt {
	pc = 0x830E6AA0; continue 'dispatch;
	}
	// 830E6A9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830E6AA0; continue 'dispatch;
            }
            0x830E6AA0 => {
    //   block [0x830E6AA0..0x830E6AA8)
	// 830E6AA0: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830E6AA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x830E6AA8 size=32
    let mut pc: u32 = 0x830E6AA8;
    'dispatch: loop {
        match pc {
            0x830E6AA8 => {
    //   block [0x830E6AA8..0x830E6AC0)
	// 830E6AA8: C0040010  lfs f0, 0x10(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E6AAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E6AB0: C1A50010  lfs f13, 0x10(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E6AB4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830E6AB8: 41980008  blt cr6, 0x830e6ac0
	if ctx.cr[6].lt {
	pc = 0x830E6AC0; continue 'dispatch;
	}
	// 830E6ABC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830E6AC0; continue 'dispatch;
            }
            0x830E6AC0 => {
    //   block [0x830E6AC0..0x830E6AC8)
	// 830E6AC0: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830E6AC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E6AC8 size=244
    let mut pc: u32 = 0x830E6AC8;
    'dispatch: loop {
        match pc {
            0x830E6AC8 => {
    //   block [0x830E6AC8..0x830E6BBC)
	// 830E6AC8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E6ACC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E6AD0: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 830E6AD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6AD8: 39240010  addi r9, r4, 0x10
	ctx.r[9].s64 = ctx.r[4].s64 + 16;
	// 830E6ADC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6BC8 size=488
    let mut pc: u32 = 0x830E6BC8;
    'dispatch: loop {
        match pc {
            0x830E6BC8 => {
    //   block [0x830E6BC8..0x830E6DB0)
	// 830E6BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6BCC: 4BBC2839  bl 0x82ca9404
	ctx.lr = 0x830E6BD0;
	sub_82CA93D0(ctx, base);
	// 830E6BD0: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6BD4: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 830E6BD8: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 830E6BDC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E6BE0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830E6BE4: 4BFFFEE5  bl 0x830e6ac8
	ctx.lr = 0x830E6BE8;
	sub_830E6AC8(ctx, base);
	// 830E6BE8: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 830E6BEC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E6DB0 size=352
    let mut pc: u32 = 0x830E6DB0;
    'dispatch: loop {
        match pc {
            0x830E6DB0 => {
    //   block [0x830E6DB0..0x830E6F10)
	// 830E6DB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6DB4: 4BBC2651  bl 0x82ca9404
	ctx.lr = 0x830E6DB8;
	sub_82CA93D0(ctx, base);
	// 830E6DB8: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6DBC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830E6DC0: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E6DC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E6DC8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830E6DCC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6F10 size=140
    let mut pc: u32 = 0x830E6F10;
    'dispatch: loop {
        match pc {
            0x830E6F10 => {
    //   block [0x830E6F10..0x830E6F58)
	// 830E6F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6F14: 4BBC24E9  bl 0x82ca93fc
	ctx.lr = 0x830E6F18;
	sub_82CA93D0(ctx, base);
	// 830E6F18: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6F1C: 832D0000  lwz r25, 0(r13)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6F20: 3B400004  li r26, 4
	ctx.r[26].s64 = 4;
	// 830E6F24: 38A00015  li r5, 0x15
	ctx.r[5].s64 = 21;
	// 830E6F28: 38800080  li r4, 0x80
	ctx.r[4].s64 = 128;
	// 830E6F2C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E6F30: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 830E6F34: 4BC6E545  bl 0x82d55478
	ctx.lr = 0x830E6F38;
	sub_82D55478(ctx, base);
	// 830E6F38: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E6F3C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830E6F40: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830E6F44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E6F48: 40990040  ble cr6, 0x830e6f88
	if !ctx.cr[6].gt {
	pc = 0x830E6F88; continue 'dispatch;
	}
	// 830E6F4C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830E6F50: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830E6F54: 3B6BA634  addi r27, r11, -0x59cc
	ctx.r[27].s64 = ctx.r[11].s64 + -22988;
	pc = 0x830E6F58; continue 'dispatch;
            }
            0x830E6F58 => {
    //   block [0x830E6F58..0x830E6F88)
	// 830E6F58: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E6F5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830E6F60: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830E6F64: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830E6F68: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830E6F6C: A0CB0004  lhz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E6F70: 4BC71A21  bl 0x82d58990
	ctx.lr = 0x830E6F74;
	sub_82D58990(ctx, base);
	// 830E6F74: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E6F78: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830E6F7C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 830E6F80: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E6F84: 4198FFD4  blt cr6, 0x830e6f58
	if ctx.cr[6].lt {
	pc = 0x830E6F58; continue 'dispatch;
	}
	pc = 0x830E6F88; continue 'dispatch;
            }
            0x830E6F88 => {
    //   block [0x830E6F88..0x830E6F9C)
	// 830E6F88: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 830E6F8C: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 830E6F90: 4BC6E541  bl 0x82d554d0
	ctx.lr = 0x830E6F94;
	sub_82D554D0(ctx, base);
	// 830E6F94: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830E6F98: 4BBC24B4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E6FA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E6FA0 size=788
    let mut pc: u32 = 0x830E6FA0;
    'dispatch: loop {
        match pc {
            0x830E6FA0 => {
    //   block [0x830E6FA0..0x830E700C)
	// 830E6FA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E6FA4: 4BBC245D  bl 0x82ca9400
	ctx.lr = 0x830E6FA8;
	sub_82CA93D0(ctx, base);
	// 830E6FA8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E6FAC: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E6FB0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830E6FB4: 83E50000  lwz r31, 0(r5)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6FB8: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 830E6FBC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 830E6FC0: 409802E0  bge cr6, 0x830e72a0
	if !ctx.cr[6].lt {
	pc = 0x830E72A0; continue 'dispatch;
	}
	// 830E6FC4: 81460008  lwz r10, 8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E6FC8: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 830E6FCC: 409802D4  bge cr6, 0x830e72a0
	if !ctx.cr[6].lt {
	pc = 0x830E72A0; continue 'dispatch;
	}
	// 830E6FD0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830E6FD4: 3BC00003  li r30, 3
	ctx.r[30].s64 = 3;
	// 830E6FD8: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 830E6FDC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 830E6FE0: 409A006C  bne cr6, 0x830e704c
	if !ctx.cr[6].eq {
	pc = 0x830E704C; continue 'dispatch;
	}
	// 830E6FE4: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E6FE8: A12A0002  lhz r9, 2(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E6FEC: A16A0000  lhz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E6FF0: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 830E6FF4: 7D49522E  lhzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830E6FF8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E6FFC: 40980010  bge cr6, 0x830e700c
	if !ctx.cr[6].lt {
	pc = 0x830E700C; continue 'dispatch;
	}
	// 830E7000: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830E7004: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 830E7008: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x830E700C; continue 'dispatch;
            }
            0x830E700C => {
    //   block [0x830E700C..0x830E7044)
	// 830E700C: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E7010: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E7014: 2F050002  cmpwi cr6, r5, 2
	ctx.cr[6].compare_i32(ctx.r[5].s32, 2, &mut ctx.xer);
	// 830E7018: A0890000  lhz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E701C: 409A0068  bne cr6, 0x830e7084
	if !ctx.cr[6].eq {
	pc = 0x830E7084; continue 'dispatch;
	}
	// 830E7020: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830E7024: A1090002  lhz r8, 2(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E7028: 5508183E  rotlwi r8, r8, 3
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(3)) as u64;
	// 830E702C: 7D084A2E  lhzx r8, r8, r9
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830E7030: 7F082000  cmpw cr6, r8, r4
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[4].s32, &mut ctx.xer);
	// 830E7034: 40980010  bge cr6, 0x830e7044
	if !ctx.cr[6].lt {
	pc = 0x830E7044; continue 'dispatch;
	}
	// 830E7038: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 830E703C: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 830E7040: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	pc = 0x830E7044; continue 'dispatch;
            }
            0x830E7044 => {
    //   block [0x830E7044..0x830E704C)
	// 830E7044: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 830E7048: 4800003C  b 0x830e7084
	pc = 0x830E7084; continue 'dispatch;
            }
            0x830E704C => {
    //   block [0x830E704C..0x830E7084)
	// 830E704C: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 830E7050: 409A0228  bne cr6, 0x830e7278
	if !ctx.cr[6].eq {
	pc = 0x830E7278; continue 'dispatch;
	}
	// 830E7054: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E7058: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E705C: A12A0002  lhz r9, 2(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 830E7060: A08A0000  lhz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E7064: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 830E7068: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E706C: 7D49522E  lhzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830E7070: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E7074: 40980010  bge cr6, 0x830e7084
	if !ctx.cr[6].lt {
	pc = 0x830E7084; continue 'dispatch;
	}
	// 830E7078: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830E707C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 830E7080: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x830E7084; continue 'dispatch;
            }
            0x830E7084 => {
    //   block [0x830E7084..0x830E7278)
	// 830E7084: 55692036  slwi r9, r11, 4
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830E7088: 55462036  slwi r6, r10, 4
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 830E708C: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 830E7090: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830E7094: 549C2036  slwi r28, r4, 4
	ctx.r[28].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	pc = 0x830E7278; continue 'dispatch;
            }
            0x830E7278 => {
    //   block [0x830E7278..0x830E72A0)
	// 830E7278: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E727C: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E7280: A08A0000  lhz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E7284: A0AB0000  lhz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E7288: 480059D1  bl 0x830ecc58
	ctx.lr = 0x830E728C;
	sub_830ECC58(ctx, base);
	// 830E728C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830E7290: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E7294: 997D0000  stb r11, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830E7298: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830E729C: 4BBC21B4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x830E72A0 => {
    //   block [0x830E72A0..0x830E72B4)
	// 830E72A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E72A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830E72A8: 997D0000  stb r11, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830E72AC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830E72B0: 4BBC21A0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E72B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E72B8 size=456
    let mut pc: u32 = 0x830E72B8;
    'dispatch: loop {
        match pc {
            0x830E72B8 => {
    //   block [0x830E72B8..0x830E73E0)
	// 830E72B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E72BC: 4BBC2135  bl 0x82ca93f0
	ctx.lr = 0x830E72C0;
	sub_82CA93D0(ctx, base);
	// 830E72C0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E72C4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 830E72C8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830E72CC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E72D0: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 830E72D4: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 830E72D8: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E72DC: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 830E72E0: 83C90000  lwz r30, 0(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E72E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830E72E8: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E72EC: 3B890004  addi r28, r9, 4
	ctx.r[28].s64 = ctx.r[9].s64 + 4;
	// 830E72F0: 3B680004  addi r27, r8, 4
	ctx.r[27].s64 = ctx.r[8].s64 + 4;
	// 830E72F4: 3B5F0004  addi r26, r31, 4
	ctx.r[26].s64 = ctx.r[31].s64 + 4;
	// 830E72F8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830E72FC: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830E7300: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E7304: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 830E7308: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 830E730C: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 830E7310: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830E7314: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E7318: A14A0000  lhz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E731C: 554A203E  rotlwi r10, r10, 4
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(4)) as u64;
	// 830E7320: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E7324: 7CCAF214  add r6, r10, r30
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 830E7328: 556B203E  rotlwi r11, r11, 4
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(4)) as u64;
	// 830E732C: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 830E7330: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830E7334: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 830E7338: 4BFFEF69  bl 0x830e62a0
	ctx.lr = 0x830E733C;
	sub_830E62A0(ctx, base);
	// 830E733C: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E7340: 81480008  lwz r10, 8(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E7344: 3AE90008  addi r23, r9, 8
	ctx.r[23].s64 = ctx.r[9].s64 + 8;
	// 830E7348: 3AC80008  addi r22, r8, 8
	ctx.r[22].s64 = ctx.r[8].s64 + 8;
	// 830E734C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830E7350: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 830E7354: 5578083C  slwi r24, r11, 1
	ctx.r[24].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[24].u64 = ctx.r[24].u32 as u64;
	// 830E7358: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 830E735C: 4099011C  ble cr6, 0x830e7478
	if !ctx.cr[6].gt {
	pc = 0x830E7478; continue 'dispatch;
	}
	// 830E7360: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E7364: C14B0C24  lfs f10, 0xc24(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3108 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830E7368: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E736C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830E7370: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 830E7374: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830E7378: 41980068  blt cr6, 0x830e73e0
	if ctx.cr[6].lt {
	pc = 0x830E73E0; continue 'dispatch;
	}
	// 830E737C: 55091838  slwi r9, r8, 3
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830E7380: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x830E73E0; continue 'dispatch;
            }
            0x830E73E0 => {
    //   block [0x830E73E0..0x830E7478)
	// 830E73E0: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E73E4: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 830E73E8: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830E73EC: 41980068  blt cr6, 0x830e7454
	if ctx.cr[6].lt {
	pc = 0x830E7454; continue 'dispatch;
	}
	// 830E73F0: 55091838  slwi r9, r8, 3
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830E73F4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x830E7478; continue 'dispatch;
            }
            0x830E7478 => {
    //   block [0x830E7478..0x830E7480)
	// 830E7478: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830E747C: 4BBC1FC4  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E7480 size=124
    let mut pc: u32 = 0x830E7480;
    'dispatch: loop {
        match pc {
            0x830E7480 => {
    //   block [0x830E7480..0x830E74A8)
	// 830E7480: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E7484: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830E7488: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E748C: A14A0000  lhz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E7490: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830E7494: 40990014  ble cr6, 0x830e74a8
	if !ctx.cr[6].gt {
	pc = 0x830E74A8; continue 'dispatch;
	}
	// 830E7498: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830E749C: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E74A0: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 830E74A4: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	pc = 0x830E74A8; continue 'dispatch;
            }
            0x830E74A8 => {
    //   block [0x830E74A8..0x830E74D0)
	// 830E74A8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 830E74AC: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830E74B0: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E74B4: A14A0000  lhz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E74B8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E74BC: 40990014  ble cr6, 0x830e74d0
	if !ctx.cr[6].gt {
	pc = 0x830E74D0; continue 'dispatch;
	}
	// 830E74C0: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 830E74C4: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830E74C8: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 830E74CC: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x830E74D0; continue 'dispatch;
            }
            0x830E74D0 => {
    //   block [0x830E74D0..0x830E74FC)
	// 830E74D0: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E74D4: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830E74D8: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E74DC: A14A0000  lhz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E74E0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830E74E4: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 830E74E8: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 830E74EC: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 830E74F0: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 830E74F4: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830E74F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E7500 size=348
    let mut pc: u32 = 0x830E7500;
    'dispatch: loop {
        match pc {
            0x830E7500 => {
    //   block [0x830E7500..0x830E7598)
	// 830E7500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7504: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7508: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E750C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7510: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7514: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 830E7518: 3BC30004  addi r30, r3, 4
	ctx.r[30].s64 = ctx.r[3].s64 + 4;
	// 830E751C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E7520: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E7524: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 830E7528: 7D274B78  mr r7, r9
	ctx.r[7].u64 = ctx.r[9].u64;
	// 830E752C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830E7530: 4198008C  blt cr6, 0x830e75bc
	if ctx.cr[6].lt {
	pc = 0x830E75BC; continue 'dispatch;
	}
	// 830E7534: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E7538: 38C7FFF0  addi r6, r7, -0x10
	ctx.r[6].s64 = ctx.r[7].s64 + -16;
	// 830E753C: C1AB0BE8  lfs f13, 0xbe8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E7540: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E7544: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 830E7548: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830E754C: 4198004C  blt cr6, 0x830e7598
	if ctx.cr[6].lt {
	pc = 0x830E7598; continue 'dispatch;
	}
	// 830E7550: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E7554: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830E7558: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E755C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 830E7560: 41980038  blt cr6, 0x830e7598
	if ctx.cr[6].lt {
	pc = 0x830E7598; continue 'dispatch;
	}
	pc = 0x830E7598; continue 'dispatch;
            }
            0x830E7598 => {
    //   block [0x830E7598..0x830E75BC)
	// 830E7598: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	pc = 0x830E75BC; continue 'dispatch;
            }
            0x830E75BC => {
    //   block [0x830E75BC..0x830E765C)
	// 830E75BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E75C0: 7D6B3850  subf r11, r11, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 830E75C4: 7D7F2670  srawi r31, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 830E75C8: 93E50000  stw r31, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 830E75CC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E75D0: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830E75D4: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830E75D8: 4098001C  bge cr6, 0x830e75f4
	if !ctx.cr[6].lt {
	pc = 0x830E75F4; continue 'dispatch;
	}
	// 830E75DC: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830E75E0: 7F1F2000  cmpw cr6, r31, r4
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[4].s32, &mut ctx.xer);
	// 830E75E4: 41980008  blt cr6, 0x830e75ec
	if ctx.cr[6].lt {
	pc = 0x830E75EC; continue 'dispatch;
	}
	// 830E75E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830E75EC: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830E75F0: 4BC6F921  bl 0x82d56f10
	ctx.lr = 0x830E75F4;
	sub_82D56F10(ctx, base);
	// 830E75F4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 830E75F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830E75FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830E7600: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830E7604: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830E7608: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830E760C: 4E800020  blr
	return;
	// 830E7610: 3968FFFF  addi r11, r8, -1
	ctx.r[11].s64 = ctx.r[8].s64 + -1;
	// 830E7614: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E7618: 4198FF94  blt cr6, 0x830e75ac
	if ctx.cr[6].lt {
	pc = 0x830E75AC; continue 'dispatch;
	}
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E7660 size=1696
    let mut pc: u32 = 0x830E7660;
    'dispatch: loop {
        match pc {
            0x830E7660 => {
    //   block [0x830E7660..0x830E7D00)
	// 830E7660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7664: 4BBC1D6D  bl 0x82ca93d0
	ctx.lr = 0x830E7668;
	sub_82CA93D0(ctx, base);
	// 830E7668: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 830E766C: 4BBC6665  bl 0x82cadcd0
	ctx.lr = 0x830E7670;
	sub_82CADCA0(ctx, base);
	// 830E7670: 3980FF00  li r12, -0x100
	ctx.r[12].s64 = -256;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E7D00 size=420
    let mut pc: u32 = 0x830E7D00;
    'dispatch: loop {
        match pc {
            0x830E7D00 => {
    //   block [0x830E7D00..0x830E7D50)
	// 830E7D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7D04: 4BBC16F1  bl 0x82ca93f4
	ctx.lr = 0x830E7D08;
	sub_82CA93D0(ctx, base);
	// 830E7D08: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7D0C: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 830E7D10: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830E7D14: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 830E7D18: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830E7D1C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 830E7D20: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E7D24: 3B1F0004  addi r24, r31, 4
	ctx.r[24].s64 = ctx.r[31].s64 + 4;
	// 830E7D28: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E7D2C: 3AFF0008  addi r23, r31, 8
	ctx.r[23].s64 = ctx.r[31].s64 + 8;
	// 830E7D30: 3BDC0001  addi r30, r28, 1
	ctx.r[30].s64 = ctx.r[28].s64 + 1;
	// 830E7D34: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830E7D38: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830E7D3C: 40980024  bge cr6, 0x830e7d60
	if !ctx.cr[6].lt {
	pc = 0x830E7D60; continue 'dispatch;
	}
	// 830E7D40: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E7D44: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E7D48: 41980008  blt cr6, 0x830e7d50
	if ctx.cr[6].lt {
	pc = 0x830E7D50; continue 'dispatch;
	}
	// 830E7D4C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x830E7D50; continue 'dispatch;
            }
            0x830E7D50 => {
    //   block [0x830E7D50..0x830E7D60)
	// 830E7D50: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830E7D54: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830E7D58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E7D5C: 4BC6F1B5  bl 0x82d56f10
	ctx.lr = 0x830E7D60;
	sub_82D56F10(ctx, base);
	pc = 0x830E7D60; continue 'dispatch;
            }
            0x830E7D60 => {
    //   block [0x830E7D60..0x830E7EA4)
	// 830E7D60: 93D80000  stw r30, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E7EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E7EA8 size=352
    let mut pc: u32 = 0x830E7EA8;
    'dispatch: loop {
        match pc {
            0x830E7EA8 => {
    //   block [0x830E7EA8..0x830E7F18)
	// 830E7EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E7EAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830E7EB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830E7EB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830E7EB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E7EBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830E7EC0: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 830E7EC4: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E7EC8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E7ECC: C0070C18  lfs f0, 0xc18(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E7ED0: 392AFFFF  addi r9, r10, -1
	ctx.r[9].s64 = ctx.r[10].s64 + -1;
	// 830E7ED4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 830E7ED8: 39090001  addi r8, r9, 1
	ctx.r[8].s64 = ctx.r[9].s64 + 1;
	// 830E7EDC: 2F080004  cmpwi cr6, r8, 4
	ctx.cr[6].compare_i32(ctx.r[8].s32, 4, &mut ctx.xer);
	// 830E7EE0: 4198009C  blt cr6, 0x830e7f7c
	if ctx.cr[6].lt {
	pc = 0x830E7F7C; continue 'dispatch;
	}
	// 830E7EE4: 5507F0BE  srwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shr(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 830E7EE8: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 830E7EEC: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 830E7EF0: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 830E7EF4: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 830E7EF8: 38C00030  li r6, 0x30
	ctx.r[6].s64 = 48;
	// 830E7EFC: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E7F00: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830E7F04: 409A0014  bne cr6, 0x830e7f18
	if !ctx.cr[6].eq {
	pc = 0x830E7F18; continue 'dispatch;
	}
	// 830E7F08: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	pc = 0x830E7F18; continue 'dispatch;
            }
            0x830E7F18 => {
    //   block [0x830E7F18..0x830E7F7C)
	// 830E7F18: C1AA001C  lfs f13, 0x1c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E7F1C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830E7F20: 409A0014  bne cr6, 0x830e7f34
	if !ctx.cr[6].eq {
	pc = 0x830E7F34; continue 'dispatch;
	}
	// 830E7F24: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	pc = 0x830E7F7C; continue 'dispatch;
            }
            0x830E7F7C => {
    //   block [0x830E7F7C..0x830E8008)
	// 830E7F7C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830E7F80: 41980030  blt cr6, 0x830e7fb0
	if ctx.cr[6].lt {
	pc = 0x830E7FB0; continue 'dispatch;
	}
	// 830E7F84: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E7F88: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830E7F8C: 409A0014  bne cr6, 0x830e7fa0
	if !ctx.cr[6].eq {
	pc = 0x830E7FA0; continue 'dispatch;
	}
	// 830E7F90: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830E8008 size=472
    let mut pc: u32 = 0x830E8008;
    'dispatch: loop {
        match pc {
            0x830E8008 => {
    //   block [0x830E8008..0x830E81E0)
	// 830E8008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E800C: 4BBC1401  bl 0x82ca940c
	ctx.lr = 0x830E8010;
	sub_82CA93D0(ctx, base);
	// 830E8010: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E8014: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E81E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E81E0 size=940
    let mut pc: u32 = 0x830E81E0;
    'dispatch: loop {
        match pc {
            0x830E81E0 => {
    //   block [0x830E81E0..0x830E821C)
	// 830E81E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E81E4: 4BBC1215  bl 0x82ca93f8
	ctx.lr = 0x830E81E8;
	sub_82CA93D0(ctx, base);
	// 830E81E8: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 830E81EC: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E81F0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830E81F4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 830E81F8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830E81FC: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 830E8200: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 830E8204: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E8208: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E820C: 409A0010  bne cr6, 0x830e821c
	if !ctx.cr[6].eq {
	pc = 0x830E821C; continue 'dispatch;
	}
	// 830E8210: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8214: C3EA0004  lfs f31, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830E8218: 48000034  b 0x830e824c
	pc = 0x830E824C; continue 'dispatch;
            }
            0x830E821C => {
    //   block [0x830E821C..0x830E8234)
	// 830E821C: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E8220: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E8224: 409A0010  bne cr6, 0x830e8234
	if !ctx.cr[6].eq {
	pc = 0x830E8234; continue 'dispatch;
	}
	// 830E8228: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E822C: C3EA0004  lfs f31, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830E8230: 4800001C  b 0x830e824c
	pc = 0x830E824C; continue 'dispatch;
            }
            0x830E8234 => {
    //   block [0x830E8234..0x830E824C)
	// 830E8234: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8238: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E823C: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8240: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E8244: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 830E8248: FFEC682E  fsel f31, f12, f0, f13
	ctx.f[31].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	pc = 0x830E824C; continue 'dispatch;
            }
            0x830E824C => {
    //   block [0x830E824C..0x830E8260)
	// 830E824C: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E8250: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 830E8254: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E8258: 4099018C  ble cr6, 0x830e83e4
	if !ctx.cr[6].gt {
	pc = 0x830E83E4; continue 'dispatch;
	}
	// 830E825C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x830E8260; continue 'dispatch;
            }
            0x830E8260 => {
    //   block [0x830E8260..0x830E82C4)
	// 830E8260: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8264: C1B80000  lfs f13, 0(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E8268: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 830E826C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8270: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 830E8274: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830E8278: 4199016C  bgt cr6, 0x830e83e4
	if ctx.cr[6].gt {
	pc = 0x830E83E4; continue 'dispatch;
	}
	// 830E827C: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8280: C1BA0010  lfs f13, 0x10(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E8284: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8288: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830E828C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E8290: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830E8294: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 830E8298: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830E829C: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 830E82A0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830E82A4: A0CA0000  lhz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E82A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830E82AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830E82B0: 90C1005C  stw r6, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[6].u32 ) };
	// 830E82B4: 409900AC  ble cr6, 0x830e8360
	if !ctx.cr[6].gt {
	pc = 0x830E8360; continue 'dispatch;
	}
	// 830E82B8: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E82BC: A0EB0000  lhz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E82C0: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	pc = 0x830E82C4; continue 'dispatch;
            }
            0x830E82C4 => {
    //   block [0x830E82C4..0x830E82F8)
	// 830E82C4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E82C8: A1290000  lhz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E82CC: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 830E82D0: 409A0028  bne cr6, 0x830e82f8
	if !ctx.cr[6].eq {
	pc = 0x830E82F8; continue 'dispatch;
	}
	// 830E82D4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E82D8: A09E0000  lhz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E82DC: A1290000  lhz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E82E0: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830E82E4: 409A0014  bne cr6, 0x830e82f8
	if !ctx.cr[6].eq {
	pc = 0x830E82F8; continue 'dispatch;
	}
	// 830E82E8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E82EC: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 830E82F0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830E82F4: 419A0008  beq cr6, 0x830e82fc
	if ctx.cr[6].eq {
	pc = 0x830E82FC; continue 'dispatch;
	}
	pc = 0x830E82F8; continue 'dispatch;
            }
            0x830E82F8 => {
    //   block [0x830E82F8..0x830E82FC)
	// 830E82F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x830E82FC; continue 'dispatch;
            }
            0x830E82FC => {
    //   block [0x830E82FC..0x830E8320)
	// 830E82FC: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 830E8300: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830E8304: 409A001C  bne cr6, 0x830e8320
	if !ctx.cr[6].eq {
	pc = 0x830E8320; continue 'dispatch;
	}
	// 830E8308: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E830C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830E8310: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 830E8314: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830E8318: 4198FFAC  blt cr6, 0x830e82c4
	if ctx.cr[6].lt {
	pc = 0x830E82C4; continue 'dispatch;
	}
	// 830E831C: 48000044  b 0x830e8360
	pc = 0x830E8360; continue 'dispatch;
            }
            0x830E8320 => {
    //   block [0x830E8320..0x830E8348)
	// 830E8320: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E8324: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830E8328: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E832C: 7D4B4214  add r10, r11, r8
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830E8330: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E8334: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830E8338: 40980024  bge cr6, 0x830e835c
	if !ctx.cr[6].lt {
	pc = 0x830E835C; continue 'dispatch;
	}
	// 830E833C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830E8340: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 830E8344: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x830E8348; continue 'dispatch;
            }
            0x830E8348 => {
    //   block [0x830E8348..0x830E835C)
	// 830E8348: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E834C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830E8350: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830E8354: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830E8358: 4200FFF0  bdnz 0x830e8348
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x830E8348; continue 'dispatch;
	}
	pc = 0x830E835C; continue 'dispatch;
            }
            0x830E835C => {
    //   block [0x830E835C..0x830E8360)
	// 830E835C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	pc = 0x830E8360; continue 'dispatch;
            }
            0x830E8360 => {
    //   block [0x830E8360..0x830E838C)
	// 830E8360: 7CAB0774  extsb r11, r5
	ctx.r[11].s64 = ctx.r[5].s8 as i64;
	// 830E8364: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E8368: 409A0068  bne cr6, 0x830e83d0
	if !ctx.cr[6].eq {
	pc = 0x830E83D0; continue 'dispatch;
	}
	// 830E836C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E8370: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E8374: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830E8378: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E837C: 409A0010  bne cr6, 0x830e838c
	if !ctx.cr[6].eq {
	pc = 0x830E838C; continue 'dispatch;
	}
	// 830E8380: 38800014  li r4, 0x14
	ctx.r[4].s64 = 20;
	// 830E8384: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E8388: 4BC6EC11  bl 0x82d56f98
	ctx.lr = 0x830E838C;
	sub_82D56F98(ctx, base);
	pc = 0x830E838C; continue 'dispatch;
            }
            0x830E838C => {
    //   block [0x830E838C..0x830E83B0)
	// 830E838C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E8390: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830E8394: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8398: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 830E839C: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 830E83A0: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 830E83A4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E83A8: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830E83AC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x830E83B0; continue 'dispatch;
            }
            0x830E83B0 => {
    //   block [0x830E83B0..0x830E83D0)
	// 830E83B0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E83B4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830E83B8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830E83BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830E83C0: 4200FFF0  bdnz 0x830e83b0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x830E83B0; continue 'dispatch;
	}
	// 830E83C4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E83C8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830E83CC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x830E83D0; continue 'dispatch;
            }
            0x830E83D0 => {
    //   block [0x830E83D0..0x830E83E4)
	// 830E83D0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E83D4: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 830E83D8: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 830E83DC: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E83E0: 4198FE80  blt cr6, 0x830e8260
	if ctx.cr[6].lt {
	pc = 0x830E8260; continue 'dispatch;
	}
	pc = 0x830E83E4; continue 'dispatch;
            }
            0x830E83E4 => {
    //   block [0x830E83E4..0x830E83FC)
	// 830E83E4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E83E8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830E83EC: 83DA0000  lwz r30, 0(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E83F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E83F4: 4099018C  ble cr6, 0x830e8580
	if !ctx.cr[6].gt {
	pc = 0x830E8580; continue 'dispatch;
	}
	// 830E83F8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x830E83FC; continue 'dispatch;
            }
            0x830E83FC => {
    //   block [0x830E83FC..0x830E8460)
	// 830E83FC: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8400: C1B80000  lfs f13, 0(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E8404: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 830E8408: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E840C: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 830E8410: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830E8414: 4199016C  bgt cr6, 0x830e8580
	if ctx.cr[6].gt {
	pc = 0x830E8580; continue 'dispatch;
	}
	// 830E8418: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E841C: C1BA0010  lfs f13, 0x10(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E8420: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8424: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 830E8428: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E842C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830E8430: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 830E8434: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830E8438: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 830E843C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830E8440: A0AA0000  lhz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8444: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830E8448: 90C10054  stw r6, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[6].u32 ) };
	// 830E844C: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 830E8450: 409900AC  ble cr6, 0x830e84fc
	if !ctx.cr[6].gt {
	pc = 0x830E84FC; continue 'dispatch;
	}
	// 830E8454: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8458: A0FE0000  lhz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E845C: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	pc = 0x830E8460; continue 'dispatch;
            }
            0x830E8460 => {
    //   block [0x830E8460..0x830E8494)
	// 830E8460: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8464: A1290000  lhz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8468: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 830E846C: 409A0028  bne cr6, 0x830e8494
	if !ctx.cr[6].eq {
	pc = 0x830E8494; continue 'dispatch;
	}
	// 830E8470: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E8474: A0660000  lhz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8478: A1290000  lhz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E847C: 7F091840  cmplw cr6, r9, r3
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[3].u32, &mut ctx.xer);
	// 830E8480: 409A0014  bne cr6, 0x830e8494
	if !ctx.cr[6].eq {
	pc = 0x830E8494; continue 'dispatch;
	}
	// 830E8484: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830E8488: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 830E848C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830E8490: 419A0008  beq cr6, 0x830e8498
	if ctx.cr[6].eq {
	pc = 0x830E8498; continue 'dispatch;
	}
	pc = 0x830E8494; continue 'dispatch;
            }
            0x830E8494 => {
    //   block [0x830E8494..0x830E8498)
	// 830E8494: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x830E8498; continue 'dispatch;
            }
            0x830E8498 => {
    //   block [0x830E8498..0x830E84BC)
	// 830E8498: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 830E849C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830E84A0: 409A001C  bne cr6, 0x830e84bc
	if !ctx.cr[6].eq {
	pc = 0x830E84BC; continue 'dispatch;
	}
	// 830E84A4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E84A8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830E84AC: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 830E84B0: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830E84B4: 4198FFAC  blt cr6, 0x830e8460
	if ctx.cr[6].lt {
	pc = 0x830E8460; continue 'dispatch;
	}
	// 830E84B8: 48000044  b 0x830e84fc
	pc = 0x830E84FC; continue 'dispatch;
            }
            0x830E84BC => {
    //   block [0x830E84BC..0x830E84E4)
	// 830E84BC: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E84C0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830E84C4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E84C8: 7D4B4214  add r10, r11, r8
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830E84CC: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E84D0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830E84D4: 40980024  bge cr6, 0x830e84f8
	if !ctx.cr[6].lt {
	pc = 0x830E84F8; continue 'dispatch;
	}
	// 830E84D8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830E84DC: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 830E84E0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x830E84E4; continue 'dispatch;
            }
            0x830E84E4 => {
    //   block [0x830E84E4..0x830E84F8)
	// 830E84E4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E84E8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830E84EC: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830E84F0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830E84F4: 4200FFF0  bdnz 0x830e84e4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x830E84E4; continue 'dispatch;
	}
	pc = 0x830E84F8; continue 'dispatch;
            }
            0x830E84F8 => {
    //   block [0x830E84F8..0x830E84FC)
	// 830E84F8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	pc = 0x830E84FC; continue 'dispatch;
            }
            0x830E84FC => {
    //   block [0x830E84FC..0x830E8528)
	// 830E84FC: 7C8B0774  extsb r11, r4
	ctx.r[11].s64 = ctx.r[4].s8 as i64;
	// 830E8500: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E8504: 409A0068  bne cr6, 0x830e856c
	if !ctx.cr[6].eq {
	pc = 0x830E856C; continue 'dispatch;
	}
	// 830E8508: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E850C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E8510: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830E8514: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E8518: 409A0010  bne cr6, 0x830e8528
	if !ctx.cr[6].eq {
	pc = 0x830E8528; continue 'dispatch;
	}
	// 830E851C: 38800014  li r4, 0x14
	ctx.r[4].s64 = 20;
	// 830E8520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830E8524: 4BC6EA75  bl 0x82d56f98
	ctx.lr = 0x830E8528;
	sub_82D56F98(ctx, base);
	pc = 0x830E8528; continue 'dispatch;
            }
            0x830E8528 => {
    //   block [0x830E8528..0x830E854C)
	// 830E8528: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E852C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830E8530: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8534: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 830E8538: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 830E853C: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 830E8540: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E8544: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 830E8548: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x830E854C; continue 'dispatch;
            }
            0x830E854C => {
    //   block [0x830E854C..0x830E856C)
	// 830E854C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E8550: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 830E8554: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830E8558: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830E855C: 4200FFF0  bdnz 0x830e854c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x830E854C; continue 'dispatch;
	}
	// 830E8560: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E8564: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830E8568: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x830E856C; continue 'dispatch;
            }
            0x830E856C => {
    //   block [0x830E856C..0x830E8580)
	// 830E856C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E8570: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830E8574: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 830E8578: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E857C: 4198FE80  blt cr6, 0x830e83fc
	if ctx.cr[6].lt {
	pc = 0x830E83FC; continue 'dispatch;
	}
	pc = 0x830E8580; continue 'dispatch;
            }
            0x830E8580 => {
    //   block [0x830E8580..0x830E858C)
	// 830E8580: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830E8584: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 830E8588: 4BBC0EC0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830E8590 size=1956
    let mut pc: u32 = 0x830E8590;
    'dispatch: loop {
        match pc {
            0x830E8590 => {
    //   block [0x830E8590..0x830E8D34)
	// 830E8590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E8594: 4BBC0E3D  bl 0x82ca93d0
	ctx.lr = 0x830E8598;
	sub_82CA93D0(ctx, base);
	// 830E8598: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 830E859C: 4BBC5725  bl 0x82cadcc0
	ctx.lr = 0x830E85A0;
	sub_82CADCA0(ctx, base);
	// 830E85A0: 3980FEE0  li r12, -0x120
	ctx.r[12].s64 = -288;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E8D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E8D38 size=1272
    let mut pc: u32 = 0x830E8D38;
    'dispatch: loop {
        match pc {
            0x830E8D38 => {
    //   block [0x830E8D38..0x830E9230)
	// 830E8D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E8D3C: 4BBC06B9  bl 0x82ca93f4
	ctx.lr = 0x830E8D40;
	sub_82CA93D0(ctx, base);
	// 830E8D40: 9421FD50  stwu r1, -0x2b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-688 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E8D44: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E8D48: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830E8D4C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830E8D50: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830E8D54: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 830E8D58: C1AB0C14  lfs f13, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E8D5C: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	// 830E8D60: C00A0C18  lfs f0, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E8D64: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 830E8D68: D1A10080  stfs f13, 0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 830E8D6C: 39610190  addi r11, r1, 0x190
	ctx.r[11].s64 = ctx.r[1].s64 + 400;
	// 830E8D70: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 830E8D74: 3940000D  li r10, 0xd
	ctx.r[10].s64 = 13;
	// 830E8D78: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 830E8D7C: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 830E8D80: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 830E8D84: C1890EE0  lfs f12, 0xee0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3808 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E8D88: 39210190  addi r9, r1, 0x190
	ctx.r[9].s64 = ctx.r[1].s64 + 400;
	// 830E8D8C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830E8D90: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830E8D94: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E9230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E9230 size=744
    let mut pc: u32 = 0x830E9230;
    'dispatch: loop {
        match pc {
            0x830E9230 => {
    //   block [0x830E9230..0x830E925C)
	// 830E9230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E9234: 4BBC01C9  bl 0x82ca93fc
	ctx.lr = 0x830E9238;
	sub_82CA93D0(ctx, base);
	// 830E9238: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E923C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E9240: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830E9244: 3B630004  addi r27, r3, 4
	ctx.r[27].s64 = ctx.r[3].s64 + 4;
	// 830E9248: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830E924C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830E9250: C1AA0C18  lfs f13, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830E9254: 40990028  ble cr6, 0x830e927c
	if !ctx.cr[6].gt {
	pc = 0x830E927C; continue 'dispatch;
	}
	// 830E9258: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x830E925C; continue 'dispatch;
            }
            0x830E925C => {
    //   block [0x830E925C..0x830E927C)
	// 830E925C: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9260: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830E9264: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830E9268: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 830E926C: D1A9000C  stfs f13, 0xc(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830E9270: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9274: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830E9278: 4198FFE4  blt cr6, 0x830e925c
	if ctx.cr[6].lt {
	pc = 0x830E925C; continue 'dispatch;
	}
	pc = 0x830E927C; continue 'dispatch;
            }
            0x830E927C => {
    //   block [0x830E927C..0x830E94C8)
	// 830E927C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9280: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E9284: 40990288  ble cr6, 0x830e950c
	if !ctx.cr[6].gt {
	pc = 0x830E950C; continue 'dispatch;
	}
	// 830E9288: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830E928C: 3D408203  lis r10, -0x7dfd
	ctx.r[10].s64 = -2113732608;
	// 830E9290: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830E9294: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 830E9298: 3BCA2AF0  addi r30, r10, 0x2af0
	ctx.r[30].s64 = ctx.r[10].s64 + 10992;
	// 830E929C: C0090C14  lfs f0, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830E92A0: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 830E92A4: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E92A8: 4098024C  bge cr6, 0x830e94f4
	if !ctx.cr[6].lt {
	pc = 0x830E94F4; continue 'dispatch;
	}
	// 830E92AC: 389C0010  addi r4, r28, 0x10
	ctx.r[4].s64 = ctx.r[28].s64 + 16;
	// 830E92B0: 3BB90001  addi r29, r25, 1
	ctx.r[29].s64 = ctx.r[25].s64 + 1;
	// 830E92B4: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 830E92B8: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E92BC: 40980220  bge cr6, 0x830e94dc
	if !ctx.cr[6].lt {
	pc = 0x830E94DC; continue 'dispatch;
	}
	// 830E92C0: 38C40010  addi r6, r4, 0x10
	ctx.r[6].s64 = ctx.r[4].s64 + 16;
	// 830E92C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E92C8: 7D3C5A14  add r9, r28, r11
	ctx.r[9].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 830E92CC: 38A9000C  addi r5, r9, 0xc
	ctx.r[5].s64 = ctx.r[9].s64 + 12;
	// 830E92D0: C189000C  lfs f12, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E92D4: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 830E92D8: 419A01F0  beq cr6, 0x830e94c8
	if ctx.cr[6].eq {
	pc = 0x830E94C8; continue 'dispatch;
	}
	// 830E92DC: 7D445A14  add r10, r4, r11
	ctx.r[10].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 830E92E0: 38EA000C  addi r7, r10, 0xc
	ctx.r[7].s64 = ctx.r[10].s64 + 12;
	// 830E92E4: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E92E8: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 830E92EC: 419A01DC  beq cr6, 0x830e94c8
	if ctx.cr[6].eq {
	pc = 0x830E94C8; continue 'dispatch;
	}
	// 830E92F0: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 830E92F4: 390B000C  addi r8, r11, 0xc
	ctx.r[8].s64 = ctx.r[11].s64 + 12;
	// 830E92F8: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830E92FC: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 830E9300: 419A01C8  beq cr6, 0x830e94c8
	if ctx.cr[6].eq {
	pc = 0x830E94C8; continue 'dispatch;
	}
	pc = 0x830E94C8; continue 'dispatch;
            }
            0x830E94C8 => {
    //   block [0x830E94C8..0x830E94DC)
	// 830E94C8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E94CC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830E94D0: 38C60010  addi r6, r6, 0x10
	ctx.r[6].s64 = ctx.r[6].s64 + 16;
	// 830E94D4: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E94D8: 4198FDEC  blt cr6, 0x830e92c4
	if ctx.cr[6].lt {
	pc = 0x830E92C4; continue 'dispatch;
	}
	pc = 0x830E94DC; continue 'dispatch;
            }
            0x830E94DC => {
    //   block [0x830E94DC..0x830E94F4)
	// 830E94DC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E94E0: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 830E94E4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830E94E8: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 830E94EC: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E94F0: 4198FDC4  blt cr6, 0x830e92b4
	if ctx.cr[6].lt {
	pc = 0x830E92B4; continue 'dispatch;
	}
	pc = 0x830E94F4; continue 'dispatch;
            }
            0x830E94F4 => {
    //   block [0x830E94F4..0x830E950C)
	// 830E94F4: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 830E94F8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E94FC: 3B9C0010  addi r28, r28, 0x10
	ctx.r[28].s64 = ctx.r[28].s64 + 16;
	// 830E9500: 3959FFFF  addi r10, r25, -1
	ctx.r[10].s64 = ctx.r[25].s64 + -1;
	// 830E9504: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E9508: 4198FD98  blt cr6, 0x830e92a0
	if ctx.cr[6].lt {
	pc = 0x830E92A0; continue 'dispatch;
	}
	pc = 0x830E950C; continue 'dispatch;
            }
            0x830E950C => {
    //   block [0x830E950C..0x830E9518)
	// 830E950C: 4BFFE99D  bl 0x830e7ea8
	ctx.lr = 0x830E9510;
	sub_830E7EA8(ctx, base);
	// 830E9510: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 830E9514: 4BBBFF38  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830E9518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830E9518 size=2924
    let mut pc: u32 = 0x830E9518;
    'dispatch: loop {
        match pc {
            0x830E9518 => {
    //   block [0x830E9518..0x830E95E8)
	// 830E9518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830E951C: 4BBBFEB5  bl 0x82ca93d0
	ctx.lr = 0x830E9520;
	sub_82CA93D0(ctx, base);
	// 830E9520: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 830E9524: 3981FF60  addi r12, r1, -0xa0
	ctx.r[12].s64 = ctx.r[1].s64 + -160;
	// 830E9528: 4BF1D4AD  bl 0x830069d4
	ctx.lr = 0x830E952C;
	sub_83006760(ctx, base);
	// 830E952C: 9421FDD0  stwu r1, -0x230(r1)
	ea = ctx.r[1].u32.wrapping_add(-560 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830E9530: 7CB32B78  mr r19, r5
	ctx.r[19].u64 = ctx.r[5].u64;
	// 830E9534: 90610244  stw r3, 0x244(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(580 as u32), ctx.r[3].u32 ) };
	// 830E9538: 7CCF3378  mr r15, r6
	ctx.r[15].u64 = ctx.r[6].u64;
	// 830E953C: 9081024C  stw r4, 0x24c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(588 as u32), ctx.r[4].u32 ) };
	// 830E9540: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 830E9544: 3A330008  addi r17, r19, 8
	ctx.r[17].s64 = ctx.r[19].s64 + 8;
	// 830E9548: 7D124378  mr r18, r8
	ctx.r[18].u64 = ctx.r[8].u64;
	// 830E954C: 81730008  lwz r11, 8(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E9550: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 830E9554: 83530004  lwz r26, 4(r19)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E9558: 7D4E5378  mr r14, r10
	ctx.r[14].u64 = ctx.r[10].u64;
	// 830E955C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E9560: 82F30000  lwz r23, 0(r19)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9564: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830E9568: 92610254  stw r19, 0x254(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(596 as u32), ctx.r[19].u32 ) };
	// 830E956C: 91E1025C  stw r15, 0x25c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(604 as u32), ctx.r[15].u32 ) };
	// 830E9570: 3A930004  addi r20, r19, 4
	ctx.r[20].s64 = ctx.r[19].s64 + 4;
	// 830E9574: 93210264  stw r25, 0x264(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(612 as u32), ctx.r[25].u32 ) };
	// 830E9578: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 830E957C: 92210050  stw r17, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[17].u32 ) };
	// 830E9580: C3EB0C14  lfs f31, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830E9584: 409902E0  ble cr6, 0x830e9864
	if !ctx.cr[6].gt {
	pc = 0x830E9864; continue 'dispatch;
	}
	// 830E9588: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 830E958C: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9590: 7D76582A  ldx r11, r22, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[11].u32)) };
	// 830E9594: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 830E9598: A1610094  lhz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 830E959C: 557F183E  rotlwi r31, r11, 3
	ctx.r[31].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830E95A0: 7F155800  cmpw cr6, r21, r11
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E95A4: 7D5FD214  add r10, r31, r26
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[26].u64;
	// 830E95A8: A3CA0004  lhz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E95AC: 40980298  bge cr6, 0x830e9844
	if !ctx.cr[6].lt {
	pc = 0x830E9844; continue 'dispatch;
	}
	// 830E95B0: 7F15F000  cmpw cr6, r21, r30
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830E95B4: 40980290  bge cr6, 0x830e9844
	if !ctx.cr[6].lt {
	pc = 0x830E9844; continue 'dispatch;
	}
	// 830E95B8: 83980004  lwz r28, 4(r24)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E95BC: 3B780004  addi r27, r24, 4
	ctx.r[27].s64 = ctx.r[24].s64 + 4;
	// 830E95C0: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 830E95C4: 3B380008  addi r25, r24, 8
	ctx.r[25].s64 = ctx.r[24].s64 + 8;
	// 830E95C8: 3BBC0001  addi r29, r28, 1
	ctx.r[29].s64 = ctx.r[28].s64 + 1;
	// 830E95CC: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830E95D0: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830E95D4: 40980024  bge cr6, 0x830e95f8
	if !ctx.cr[6].lt {
	pc = 0x830E95F8; continue 'dispatch;
	}
	// 830E95D8: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E95DC: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E95E0: 41980008  blt cr6, 0x830e95e8
	if ctx.cr[6].lt {
	pc = 0x830E95E8; continue 'dispatch;
	}
	// 830E95E4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x830E95E8; continue 'dispatch;
            }
            0x830E95E8 => {
    //   block [0x830E95E8..0x830E95F8)
	// 830E95E8: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830E95EC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830E95F0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 830E95F4: 4BC6D91D  bl 0x82d56f10
	ctx.lr = 0x830E95F8;
	sub_82D56F10(ctx, base);
	pc = 0x830E95F8; continue 'dispatch;
            }
            0x830E95F8 => {
    //   block [0x830E95F8..0x830E9844)
	// 830E95F8: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830E95FC: 80D80000  lwz r6, 0(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9600: 57872036  slwi r7, r28, 4
	ctx.r[7].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 830E9604: 93BB0000  stw r29, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830E9608: 7FCBD214  add r30, r11, r26
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 830E960C: A1610090  lhz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 830E9610: 7C9FD22E  lhzx r4, r31, r26
	ctx.r[4].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 830E9614: 7F9FD214  add r28, r31, r26
	ctx.r[28].u64 = ctx.r[31].u64 + ctx.r[26].u64;
	// 830E9618: 7FE73214  add r31, r7, r6
	ctx.r[31].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 830E961C: 5565203E  rotlwi r5, r11, 4
	ctx.r[5].u64 = ((ctx.r[11].u32).rotate_left(4)) as u64;
	// 830E9620: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9624: 5486203E  rotlwi r6, r4, 4
	ctx.r[6].u64 = ((ctx.r[4].u32).rotate_left(4)) as u64;
	// 830E9628: A0FE0000  lhz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E962C: 7CA55A14  add r5, r5, r11
	ctx.r[5].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 830E9630: 7CC65A14  add r6, r6, r11
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 830E9634: 54E7203E  rotlwi r7, r7, 4
	ctx.r[7].u64 = ((ctx.r[7].u32).rotate_left(4)) as u64;
	// 830E9638: 39210110  addi r9, r1, 0x110
	ctx.r[9].s64 = ctx.r[1].s64 + 272;
	// 830E963C: 7C875A14  add r4, r7, r11
	ctx.r[4].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 830E9640: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 830E9644: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 830E9648: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 830E964C: 39410120  addi r10, r1, 0x120
	ctx.r[10].s64 = ctx.r[1].s64 + 288;
	// 830E9650: 39010140  addi r8, r1, 0x140
	ctx.r[8].s64 = ctx.r[1].s64 + 320;
	// 830E9654: E8870000  ld r4, 0(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 830E9658: E8AB0000  ld r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 830E965C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 830E9660: E8E70008  ld r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 830E9664: E8660000  ld r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	// 830E9668: F8890000  std r4, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 830E966C: F8AA0000  std r5, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 830E9670: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 830E9674: 39610120  addi r11, r1, 0x120
	ctx.r[11].s64 = ctx.r[1].s64 + 288;
	// 830E9678: F8E90008  std r7, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 830E967C: 39210110  addi r9, r1, 0x110
	ctx.r[9].s64 = ctx.r[1].s64 + 272;
	// 830E9680: E8C60008  ld r6, 8(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	// 830E9684: F8680000  std r3, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[3].u64 ) };
	pc = 0x830E9844; continue 'dispatch;
            }
            0x830E9844 => {
    //   block [0x830E9844..0x830E9864)
	// 830E9844: 82210050  lwz r17, 0x50(r1)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830E9848: 3AB50001  addi r21, r21, 1
	ctx.r[21].s64 = ctx.r[21].s64 + 1;
	// 830E984C: 3AD60008  addi r22, r22, 8
	ctx.r[22].s64 = ctx.r[22].s64 + 8;
	// 830E9850: 81710000  lwz r11, 0(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9854: 7F155800  cmpw cr6, r21, r11
	ctx.cr[6].compare_i32(ctx.r[21].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E9858: 4198FD34  blt cr6, 0x830e958c
	if ctx.cr[6].lt {
	pc = 0x830E958C; continue 'dispatch;
	}
	// 830E985C: 81E1025C  lwz r15, 0x25c(r1)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(604 as u32) ) } as u64;
	// 830E9860: 83210264  lwz r25, 0x264(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(612 as u32) ) } as u64;
	pc = 0x830E9864; continue 'dispatch;
            }
            0x830E9864 => {
    //   block [0x830E9864..0x830EA084)
	// 830E9864: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 830E9868: 3A0E0004  addi r16, r14, 4
	ctx.r[16].s64 = ctx.r[14].s64 + 4;
	// 830E986C: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 830E9870: 9A920000  stb r20, 0(r18)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[18].u32.wrapping_add(0 as u32), ctx.r[20].u8 ) };
	// 830E9874: 816E0004  lwz r11, 4(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(4 as u32) ) } as u64;
	// 830E9878: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830E987C: 409902DC  ble cr6, 0x830e9b58
	if !ctx.cr[6].gt {
	pc = 0x830E9B58; continue 'dispatch;
	}
	// 830E9880: 7ECFB378  mr r15, r22
	ctx.r[15].u64 = ctx.r[22].u64;
	// 830E9884: 81700000  lwz r11, 0(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E9888: 7DF17B78  mr r17, r15
	ctx.r[17].u64 = ctx.r[15].u64;
	// 830E988C: 7F0F5800  cmpw cr6, r15, r11
	ctx.cr[6].compare_i32(ctx.r[15].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830E9890: 409802A4  bge cr6, 0x830e9b34
	if !ctx.cr[6].lt {
	pc = 0x830E9B34; continue 'dispatch;
	}
	// 830E9894: 8161024C  lwz r11, 0x24c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(588 as u32) ) } as u64;
	// 830E9898: 3AB40020  addi r21, r20, 0x20
	ctx.r[21].s64 = ctx.r[20].s64 + 32;
	// 830E989C: 3A6B0018  addi r19, r11, 0x18
	ctx.r[19].s64 = ctx.r[11].s64 + 24;
	// 830E98A0: 812E0000  lwz r9, 0(r14)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(0 as u32) ) } as u64;
	// 830E98A4: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 830E98A8: 394100B0  addi r10, r1, 0xb0
	ctx.r[10].s64 = ctx.r[1].s64 + 176;
	// 830E98AC: 7D09A214  add r8, r9, r20
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[20].u64;
	// 830E98B0: 7CC9AA14  add r6, r9, r21
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[21].u64;
	// 830E98B4: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 830E98B8: 7CC83378  mr r8, r6
	ctx.r[8].u64 = ctx.r[6].u64;
	// 830E98BC: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 830E98C0: E8C90000  ld r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 830E98C4: E8890008  ld r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 830E98C8: EBE90010  ld r31, 0x10(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	// 830E98CC: E9290018  ld r9, 0x18(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) };
	// 830E98D0: E8A80000  ld r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 830E98D4: F8CB0000  std r6, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 830E98D8: F88B0008  std r4, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u64 ) };
	// 830E98DC: E8680008  ld r3, 8(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 830E98E0: FBEB0010  std r31, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[31].u64 ) };
	// 830E98E4: EBC80010  ld r30, 0x10(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) };
	// 830E98E8: F92B0018  std r9, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u64 ) };
	// 830E98EC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 830E98F0: E9080018  ld r8, 0x18(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) };
	// 830E98F4: F8AA0000  std r5, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 830E98F8: F86A0008  std r3, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[3].u64 ) };
	// 830E98FC: FBCA0010  std r30, 0x10(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[30].u64 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EA088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EA088 size=560
    let mut pc: u32 = 0x830EA088;
    'dispatch: loop {
        match pc {
            0x830EA088 => {
    //   block [0x830EA088..0x830EA0BC)
	// 830EA088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EA08C: 4BBBF371  bl 0x82ca93fc
	ctx.lr = 0x830EA090;
	sub_82CA93D0(ctx, base);
	// 830EA090: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 830EA094: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EA098: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830EA09C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830EA0A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EA0A4: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA0A8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EA0AC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830EA0B0: C3EA0C4C  lfs f31, 0xc4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830EA0B4: 40990034  ble cr6, 0x830ea0e8
	if !ctx.cr[6].gt {
	pc = 0x830EA0E8; continue 'dispatch;
	}
	// 830EA0B8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x830EA0BC; continue 'dispatch;
            }
            0x830EA0BC => {
    //   block [0x830EA0BC..0x830EA0E8)
	// 830EA0BC: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA0C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830EA0C4: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA0C8: 7D2A4A2E  lhzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830EA0CC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 830EA0D0: 5529203E  rotlwi r9, r9, 4
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(4)) as u64;
	// 830EA0D4: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 830EA0D8: D3E9000C  stfs f31, 0xc(r9)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830EA0DC: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA0E0: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830EA0E4: 4198FFD8  blt cr6, 0x830ea0bc
	if ctx.cr[6].lt {
	pc = 0x830EA0BC; continue 'dispatch;
	}
	pc = 0x830EA0E8; continue 'dispatch;
            }
            0x830EA0E8 => {
    //   block [0x830EA0E8..0x830EA120)
	// 830EA0E8: 832D0000  lwz r25, 0(r13)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA0EC: 3B400004  li r26, 4
	ctx.r[26].s64 = 4;
	// 830EA0F0: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA0F4: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 830EA0F8: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 830EA0FC: 55641036  rlwinm r4, r11, 2, 0, 0x1b
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830EA100: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 830EA104: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 830EA108: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 830EA10C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830EA110: 41990010  bgt cr6, 0x830ea120
	if ctx.cr[6].gt {
	pc = 0x830EA120; continue 'dispatch;
	}
	// 830EA114: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 830EA118: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830EA11C: 48000018  b 0x830ea134
	pc = 0x830EA134; continue 'dispatch;
            }
            0x830EA120 => {
    //   block [0x830EA120..0x830EA134)
	// 830EA120: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA124: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EA128: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EA12C: 4E800421  bctrl
	ctx.lr = 0x830EA130;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830EA130: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
            }
            0x830EA134 => {
    //   block [0x830EA134..0x830EA18C)
	// 830EA134: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA138: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830EA13C: 67DE8000  oris r30, r30, 0x8000
	ctx.r[30].u64 = ctx.r[30].u64 | 2147483648;
	// 830EA140: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EA144: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EA148: 40990060  ble cr6, 0x830ea1a8
	if !ctx.cr[6].gt {
	pc = 0x830EA1A8; continue 'dispatch;
	}
	// 830EA14C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830EA150: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830EA154: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 830EA158: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 830EA15C: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA160: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 830EA164: C009000C  lfs f0, 0xc(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EA168: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830EA16C: 409A0020  bne cr6, 0x830ea18c
	if !ctx.cr[6].eq {
	pc = 0x830EA18C; continue 'dispatch;
	}
	// 830EA170: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	pc = 0x830EA18C; continue 'dispatch;
            }
            0x830EA18C => {
    //   block [0x830EA18C..0x830EA1A8)
	// 830EA18C: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 830EA190: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA194: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 830EA198: 39080010  addi r8, r8, 0x10
	ctx.r[8].s64 = ctx.r[8].s64 + 16;
	// 830EA19C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 830EA1A0: 7F065000  cmpw cr6, r6, r10
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830EA1A4: 4198FFB8  blt cr6, 0x830ea15c
	if ctx.cr[6].lt {
	pc = 0x830EA15C; continue 'dispatch;
	}
	pc = 0x830EA1A8; continue 'dispatch;
            }
            0x830EA1A8 => {
    //   block [0x830EA1A8..0x830EA2B8)
	// 830EA1A8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA1AC: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830EA1B0: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830EA1B4: 40980024  bge cr6, 0x830ea1d8
	if !ctx.cr[6].lt {
	pc = 0x830EA1D8; continue 'dispatch;
	}
	// 830EA1B8: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EA1BC: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EA1C0: 41980008  blt cr6, 0x830ea1c8
	if ctx.cr[6].lt {
	pc = 0x830EA1C8; continue 'dispatch;
	}
	// 830EA1C4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 830EA1C8: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830EA1CC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830EA1D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830EA1D4: 4BC6CD3D  bl 0x82d56f10
	ctx.lr = 0x830EA1D8;
	sub_82D56F10(ctx, base);
	// 830EA1D8: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 830EA1DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EA1E0: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA1E4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EA1E8: 40990034  ble cr6, 0x830ea21c
	if !ctx.cr[6].gt {
	pc = 0x830EA21C; continue 'dispatch;
	}
	// 830EA1EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830EA1F0: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA1F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830EA1F8: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830EA1FC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 830EA200: A1090000  lhz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA204: 5508103E  rotlwi r8, r8, 2
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(2)) as u64;
	// 830EA208: 7D08D82E  lwzx r8, r8, r27
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 830EA20C: B1090000  sth r8, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 830EA210: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA214: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830EA218: 4198FFD8  blt cr6, 0x830ea1f0
	if ctx.cr[6].lt {
	pc = 0x830EA1F0; continue 'dispatch;
	}
	// 830EA21C: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 830EA220: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830EA224: 93630020  stw r27, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[27].u32 ) };
	// 830EA228: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830EA22C: 409A0018  bne cr6, 0x830ea244
	if !ctx.cr[6].eq {
	pc = 0x830EA244; continue 'dispatch;
	}
	// 830EA230: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA234: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830EA238: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EA23C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EA240: 4E800421  bctrl
	ctx.lr = 0x830EA244;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830EA244: 57CB0000  rlwinm r11, r30, 0, 0, 0
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 830EA248: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EA24C: 409A0018  bne cr6, 0x830ea264
	if !ctx.cr[6].eq {
	pc = 0x830EA264; continue 'dispatch;
	}
	// 830EA250: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830EA254: 7C7AC82E  lwzx r3, r26, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 830EA258: 57C5103A  slwi r5, r30, 2
	ctx.r[5].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830EA25C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830EA260: 4BC6B069  bl 0x82d552c8
	ctx.lr = 0x830EA264;
	sub_82D552C8(ctx, base);
	// 830EA264: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA268: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830EA26C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EA270: 4099003C  ble cr6, 0x830ea2ac
	if !ctx.cr[6].gt {
	pc = 0x830EA2AC; continue 'dispatch;
	}
	// 830EA274: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830EA278: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EA27C: C0090C18  lfs f0, 0xc18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EA280: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA284: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830EA288: 811C0000  lwz r8, 0(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA28C: 7D2B4A2E  lhzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830EA290: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 830EA294: 5529203E  rotlwi r9, r9, 4
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(4)) as u64;
	// 830EA298: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 830EA29C: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830EA2A0: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA2A4: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830EA2A8: 4198FFD8  blt cr6, 0x830ea280
	if ctx.cr[6].lt {
	pc = 0x830EA280; continue 'dispatch;
	}
	// 830EA2AC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830EA2B0: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 830EA2B4: 4BBBF198  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EA2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EA2B8 size=384
    let mut pc: u32 = 0x830EA2B8;
    'dispatch: loop {
        match pc {
            0x830EA2B8 => {
    //   block [0x830EA2B8..0x830EA2F4)
	// 830EA2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EA2BC: 4BBBF135  bl 0x82ca93f0
	ctx.lr = 0x830EA2C0;
	sub_82CA93D0(ctx, base);
	// 830EA2C0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EA2C4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 830EA2C8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 830EA2CC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 830EA2D0: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA2D4: 83F90008  lwz r31, 8(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA2D8: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830EA2DC: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830EA2E0: 40980024  bge cr6, 0x830ea304
	if !ctx.cr[6].lt {
	pc = 0x830EA304; continue 'dispatch;
	}
	// 830EA2E4: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EA2E8: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EA2EC: 41980008  blt cr6, 0x830ea2f4
	if ctx.cr[6].lt {
	pc = 0x830EA2F4; continue 'dispatch;
	}
	// 830EA2F0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x830EA2F4; continue 'dispatch;
            }
            0x830EA2F4 => {
    //   block [0x830EA2F4..0x830EA304)
	// 830EA2F4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 830EA2F8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830EA2FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EA300: 4BC6CC11  bl 0x82d56f10
	ctx.lr = 0x830EA304;
	sub_82D56F10(ctx, base);
	pc = 0x830EA304; continue 'dispatch;
            }
            0x830EA304 => {
    //   block [0x830EA304..0x830EA32C)
	// 830EA304: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 830EA308: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 830EA30C: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA310: 82DB0008  lwz r22, 8(r27)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA314: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EA318: 409900C0  ble cr6, 0x830ea3d8
	if !ctx.cr[6].gt {
	pc = 0x830EA3D8; continue 'dispatch;
	}
	// 830EA31C: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 830EA320: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830EA324: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830EA328: 6177FFFF  ori r23, r11, 0xffff
	ctx.r[23].u64 = ctx.r[11].u64 | 65535;
	pc = 0x830EA32C; continue 'dispatch;
            }
            0x830EA32C => {
    //   block [0x830EA32C..0x830EA354)
	// 830EA32C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA330: 7FDA5A14  add r30, r26, r11
	ctx.r[30].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 830EA334: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 830EA338: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830EA33C: 419A0018  beq cr6, 0x830ea354
	if ctx.cr[6].eq {
	pc = 0x830EA354; continue 'dispatch;
	}
	// 830EA340: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830EA344: 419A0010  beq cr6, 0x830ea354
	if ctx.cr[6].eq {
	pc = 0x830EA354; continue 'dispatch;
	}
	// 830EA348: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA34C: 7EFC5B2E  sthx r23, r28, r11
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32), ctx.r[23].u16) };
	// 830EA350: 48000070  b 0x830ea3c0
	pc = 0x830EA3C0; continue 'dispatch;
            }
            0x830EA354 => {
    //   block [0x830EA354..0x830EA384)
	// 830EA354: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA358: 3BFB0004  addi r31, r27, 4
	ctx.r[31].s64 = ctx.r[27].s64 + 4;
	// 830EA35C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA360: 7D7C532E  sthx r11, r28, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u16) };
	// 830EA364: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA368: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA36C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830EA370: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EA374: 409A0010  bne cr6, 0x830ea384
	if !ctx.cr[6].eq {
	pc = 0x830EA384; continue 'dispatch;
	}
	// 830EA378: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 830EA37C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EA380: 4BC6CC19  bl 0x82d56f98
	ctx.lr = 0x830EA384;
	sub_82D56F98(ctx, base);
	pc = 0x830EA384; continue 'dispatch;
            }
            0x830EA384 => {
    //   block [0x830EA384..0x830EA3C0)
	// 830EA384: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA388: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA38C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EA390: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830EA394: A15E0000  lhz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA398: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 830EA39C: A15E0002  lhz r10, 2(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 830EA3A0: B14B0002  sth r10, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[10].u16 ) };
	// 830EA3A4: A15E0004  lhz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA3A8: B14B0004  sth r10, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 830EA3AC: A15E0006  lhz r10, 6(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 830EA3B0: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 830EA3B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA3B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830EA3BC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x830EA3C0; continue 'dispatch;
            }
            0x830EA3C0 => {
    //   block [0x830EA3C0..0x830EA3D8)
	// 830EA3C0: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA3C4: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 830EA3C8: 3B5A0008  addi r26, r26, 8
	ctx.r[26].s64 = ctx.r[26].s64 + 8;
	// 830EA3CC: 3B9C0002  addi r28, r28, 2
	ctx.r[28].s64 = ctx.r[28].s64 + 2;
	// 830EA3D0: 7F185800  cmpw cr6, r24, r11
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EA3D4: 4198FF58  blt cr6, 0x830ea32c
	if ctx.cr[6].lt {
	pc = 0x830EA32C; continue 'dispatch;
	}
	pc = 0x830EA3D8; continue 'dispatch;
            }
            0x830EA3D8 => {
    //   block [0x830EA3D8..0x830EA3EC)
	// 830EA3D8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA3DC: 7EC9B378  mr r9, r22
	ctx.r[9].u64 = ctx.r[22].u64;
	// 830EA3E0: 7F165800  cmpw cr6, r22, r11
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EA3E4: 4098004C  bge cr6, 0x830ea430
	if !ctx.cr[6].lt {
	pc = 0x830EA430; continue 'dispatch;
	}
	// 830EA3E8: 56CA1838  slwi r10, r22, 3
	ctx.r[10].u32 = ctx.r[22].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	pc = 0x830EA3EC; continue 'dispatch;
            }
            0x830EA3EC => {
    //   block [0x830EA3EC..0x830EA430)
	// 830EA3EC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA3F0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830EA3F4: 811D0000  lwz r8, 0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA3F8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830EA3FC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 830EA400: A0EB0002  lhz r7, 2(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 830EA404: A0CB0004  lhz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA408: 54E7083E  rotlwi r7, r7, 1
	ctx.r[7].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 830EA40C: 54C6083E  rotlwi r6, r6, 1
	ctx.r[6].u64 = ((ctx.r[6].u32).rotate_left(1)) as u64;
	// 830EA410: 7D07422E  lhzx r8, r7, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830EA414: B10B0002  sth r8, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[8].u16 ) };
	// 830EA418: 811D0000  lwz r8, 0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA41C: 7D06422E  lhzx r8, r6, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830EA420: B10B0004  sth r8, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u16 ) };
	// 830EA424: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA428: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EA42C: 4198FFC0  blt cr6, 0x830ea3ec
	if ctx.cr[6].lt {
	pc = 0x830EA3EC; continue 'dispatch;
	}
	pc = 0x830EA430; continue 'dispatch;
            }
            0x830EA430 => {
    //   block [0x830EA430..0x830EA438)
	// 830EA430: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 830EA434: 4BBBF00C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EA438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EA438 size=432
    let mut pc: u32 = 0x830EA438;
    'dispatch: loop {
        match pc {
            0x830EA438 => {
    //   block [0x830EA438..0x830EA4C0)
	// 830EA438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EA43C: 4BBBEFB5  bl 0x82ca93f0
	ctx.lr = 0x830EA440;
	sub_82CA93D0(ctx, base);
	// 830EA440: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 830EA444: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 830EA448: 9421FD30  stwu r1, -0x2d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-720 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EA44C: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 830EA450: 82C40000  lwz r22, 0(r4)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA454: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830EA458: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830EA45C: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 830EA460: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 830EA464: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA468: 7D174378  mr r23, r8
	ctx.r[23].u64 = ctx.r[8].u64;
	// 830EA46C: C3DB000C  lfs f30, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830EA470: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830EA474: 40990164  ble cr6, 0x830ea5d8
	if !ctx.cr[6].gt {
	pc = 0x830EA5D8; continue 'dispatch;
	}
	// 830EA478: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA47C: C009000C  lfs f0, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EA480: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EA484: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830EA488: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 830EA48C: 4098014C  bge cr6, 0x830ea5d8
	if !ctx.cr[6].lt {
	pc = 0x830EA5D8; continue 'dispatch;
	}
	// 830EA490: 3961005C  addi r11, r1, 0x5c
	ctx.r[11].s64 = ctx.r[1].s64 + 92;
	// 830EA494: 3D008000  lis r8, -0x8000
	ctx.r[8].s64 = -2147483648;
	// 830EA498: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830EA49C: 61080040  ori r8, r8, 0x40
	ctx.r[8].u64 = ctx.r[8].u64 | 64;
	// 830EA4A0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EA4A4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830EA4A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EA4AC: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 830EA4B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830EA4B4: C3E90004  lfs f31, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830EA4B8: 4099007C  ble cr6, 0x830ea534
	if !ctx.cr[6].gt {
	pc = 0x830EA534; continue 'dispatch;
	}
	// 830EA4BC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x830EA4C0; continue 'dispatch;
            }
            0x830EA4C0 => {
    //   block [0x830EA4C0..0x830EA4F8)
	// 830EA4C0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA4C4: 7FDC5214  add r30, r28, r10
	ctx.r[30].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 830EA4C8: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EA4CC: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 830EA4D0: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 830EA4D4: 41990060  bgt cr6, 0x830ea534
	if ctx.cr[6].gt {
	pc = 0x830EA534; continue 'dispatch;
	}
	// 830EA4D8: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EA4DC: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 830EA4E0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830EA4E4: 409A0014  bne cr6, 0x830ea4f8
	if !ctx.cr[6].eq {
	pc = 0x830EA4F8; continue 'dispatch;
	}
	// 830EA4E8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 830EA4EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EA4F0: 4BC6CAA9  bl 0x82d56f98
	ctx.lr = 0x830EA4F4;
	sub_82D56F98(ctx, base);
	// 830EA4F4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x830EA4F8; continue 'dispatch;
            }
            0x830EA4F8 => {
    //   block [0x830EA4F8..0x830EA534)
	// 830EA4F8: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA4FC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EA500: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA504: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830EA508: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830EA50C: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 830EA510: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830EA514: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA518: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830EA51C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EA520: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA524: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830EA528: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830EA52C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830EA530: 4198FF90  blt cr6, 0x830ea4c0
	if ctx.cr[6].lt {
	pc = 0x830EA4C0; continue 'dispatch;
	}
	pc = 0x830EA534; continue 'dispatch;
            }
            0x830EA534 => {
    //   block [0x830EA534..0x830EA598)
	// 830EA534: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830EA538: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830EA53C: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 830EA540: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 830EA544: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 830EA548: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 830EA54C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830EA550: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830EA554: 4BFFDAB5  bl 0x830e8008
	ctx.lr = 0x830EA558;
	sub_830E8008(ctx, base);
	// 830EA558: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA55C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA560: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA564: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830EA568: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA56C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EA570: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA574: D3EB0004  stfs f31, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EA578: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA57C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830EA580: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830EA584: 40980020  bge cr6, 0x830ea5a4
	if !ctx.cr[6].lt {
	pc = 0x830EA5A4; continue 'dispatch;
	}
	// 830EA588: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830EA58C: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 830EA590: 41990008  bgt cr6, 0x830ea598
	if ctx.cr[6].gt {
	pc = 0x830EA598; continue 'dispatch;
	}
	// 830EA594: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	pc = 0x830EA598; continue 'dispatch;
            }
            0x830EA598 => {
    //   block [0x830EA598..0x830EA5A4)
	// 830EA598: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 830EA59C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EA5A0: 4BC6C971  bl 0x82d56f10
	ctx.lr = 0x830EA5A4;
	sub_82D56F10(ctx, base);
	pc = 0x830EA5A4; continue 'dispatch;
            }
            0x830EA5A4 => {
    //   block [0x830EA5A4..0x830EA5D8)
	// 830EA5A4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EA5A8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EA5AC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EA5B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830EA5B4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830EA5B8: 409A0020  bne cr6, 0x830ea5d8
	if !ctx.cr[6].eq {
	pc = 0x830EA5D8; continue 'dispatch;
	}
	// 830EA5BC: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA5C0: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830EA5C4: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830EA5C8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA5CC: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830EA5D0: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830EA5D4: 4BC6ACF5  bl 0x82d552c8
	ctx.lr = 0x830EA5D8;
	sub_82D552C8(ctx, base);
	pc = 0x830EA5D8; continue 'dispatch;
            }
            0x830EA5D8 => {
    //   block [0x830EA5D8..0x830EA5E8)
	// 830EA5D8: 382102D0  addi r1, r1, 0x2d0
	ctx.r[1].s64 = ctx.r[1].s64 + 720;
	// 830EA5DC: CBC1FF98  lfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 830EA5E0: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 830EA5E4: 4BBBEE5C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EA5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EA5E8 size=320
    let mut pc: u32 = 0x830EA5E8;
    'dispatch: loop {
        match pc {
            0x830EA5E8 => {
    //   block [0x830EA5E8..0x830EA64C)
	// 830EA5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EA5EC: 4BBBEE1D  bl 0x82ca9408
	ctx.lr = 0x830EA5F0;
	sub_82CA93D0(ctx, base);
	// 830EA5F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EA5F4: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 830EA5F8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830EA5FC: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 830EA600: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA604: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830EA608: 409A0118  bne cr6, 0x830ea720
	if !ctx.cr[6].eq {
	pc = 0x830EA720; continue 'dispatch;
	}
	// 830EA60C: 838100F4  lwz r28, 0xf4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 830EA610: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA614: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830EA618: 409A0108  bne cr6, 0x830ea720
	if !ctx.cr[6].eq {
	pc = 0x830EA720; continue 'dispatch;
	}
	// 830EA61C: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA620: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA624: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830EA628: 419A0024  beq cr6, 0x830ea64c
	if ctx.cr[6].eq {
	pc = 0x830EA64C; continue 'dispatch;
	}
	// 830EA62C: 54CA043E  clrlwi r10, r6, 0x10
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x0000FFFFu64;
	// 830EA630: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 830EA634: 419A0018  beq cr6, 0x830ea64c
	if ctx.cr[6].eq {
	pc = 0x830EA64C; continue 'dispatch;
	}
	// 830EA638: 80C40004  lwz r6, 4(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA63C: A0C60000  lhz r6, 0(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA640: 7F065040  cmplw cr6, r6, r10
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830EA644: 409A0008  bne cr6, 0x830ea64c
	if !ctx.cr[6].eq {
	pc = 0x830EA64C; continue 'dispatch;
	}
	// 830EA648: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x830EA64C; continue 'dispatch;
            }
            0x830EA64C => {
    //   block [0x830EA64C..0x830EA6E8)
	// 830EA64C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA650: C003000C  lfs f0, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EA654: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA658: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EA65C: C19E0004  lfs f12, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830EA660: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 830EA664: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 830EA668: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830EA66C: 409800B4  bge cr6, 0x830ea720
	if !ctx.cr[6].lt {
	pc = 0x830EA720; continue 'dispatch;
	}
	// 830EA670: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830EA674: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 830EA678: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 830EA67C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EA680: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 830EA684: 3941005C  addi r10, r1, 0x5c
	ctx.r[10].s64 = ctx.r[1].s64 + 92;
	// 830EA688: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 830EA68C: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 830EA690: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 830EA694: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 830EA698: C02B0004  lfs f1, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830EA69C: E8BE0000  ld r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 830EA6A0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830EA6A4: F8A1005C  std r5, 0x5c(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u64 ) };
	// 830EA6A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 830EA6AC: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 830EA6B0: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 830EA6B4: F9610064  std r11, 0x64(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u64 ) };
	// 830EA6B8: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 830EA6BC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830EA6C0: 4BFFD949  bl 0x830e8008
	ctx.lr = 0x830EA6C4;
	sub_830E8008(ctx, base);
	// 830EA6C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA6C8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA6CC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA6D0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA6D4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830EA6D8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830EA6DC: C00A0BFC  lfs f0, 0xbfc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EA6E0: 419A0008  beq cr6, 0x830ea6e8
	if ctx.cr[6].eq {
	pc = 0x830EA6E8; continue 'dispatch;
	}
	// 830EA6E4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x830EA6E8; continue 'dispatch;
            }
            0x830EA6E8 => {
    //   block [0x830EA6E8..0x830EA720)
	// 830EA6E8: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EA6EC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 830EA6F0: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EA6F4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EA6F8: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EA6FC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EA700: 409A0020  bne cr6, 0x830ea720
	if !ctx.cr[6].eq {
	pc = 0x830EA720; continue 'dispatch;
	}
	// 830EA704: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA708: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830EA70C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830EA710: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA714: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830EA718: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830EA71C: 4BC6ABAD  bl 0x82d552c8
	ctx.lr = 0x830EA720;
	sub_82D552C8(ctx, base);
	pc = 0x830EA720; continue 'dispatch;
            }
            0x830EA720 => {
    //   block [0x830EA720..0x830EA728)
	// 830EA720: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830EA724: 4BBBED34  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EA728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EA728 size=356
    let mut pc: u32 = 0x830EA728;
    'dispatch: loop {
        match pc {
            0x830EA728 => {
    //   block [0x830EA728..0x830EA760)
	// 830EA728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EA72C: 4BBBECD5  bl 0x82ca9400
	ctx.lr = 0x830EA730;
	sub_82CA93D0(ctx, base);
	// 830EA730: 9421FD60  stwu r1, -0x2a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-672 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EA734: 3961005C  addi r11, r1, 0x5c
	ctx.r[11].s64 = ctx.r[1].s64 + 92;
	// 830EA738: 83A40004  lwz r29, 4(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA73C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830EA740: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 830EA744: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830EA748: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 830EA74C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830EA750: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 830EA754: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 830EA758: 616B0080  ori r11, r11, 0x80
	ctx.r[11].u64 = ctx.r[11].u64 | 128;
	// 830EA75C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	pc = 0x830EA760; continue 'dispatch;
            }
            0x830EA760 => {
    //   block [0x830EA760..0x830EA77C)
	// 830EA760: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA764: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EA768: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830EA76C: 838BFFFC  lwz r28, -4(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830EA770: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 830EA774: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830EA778: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x830EA77C; continue 'dispatch;
            }
            0x830EA77C => {
    //   block [0x830EA77C..0x830EA7A4)
	// 830EA77C: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA780: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830EA784: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830EA788: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 830EA78C: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 830EA790: 419A0014  beq cr6, 0x830ea7a4
	if ctx.cr[6].eq {
	pc = 0x830EA7A4; continue 'dispatch;
	}
	// 830EA794: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 830EA798: 419A00D4  beq cr6, 0x830ea86c
	if ctx.cr[6].eq {
	pc = 0x830EA86C; continue 'dispatch;
	}
	// 830EA79C: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 830EA7A0: 409A000C  bne cr6, 0x830ea7ac
	if !ctx.cr[6].eq {
	pc = 0x830EA7AC; continue 'dispatch;
	}
	pc = 0x830EA7A4; continue 'dispatch;
            }
            0x830EA7A4 => {
    //   block [0x830EA7A4..0x830EA7AC)
	// 830EA7A4: 7F0AD800  cmpw cr6, r10, r27
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[27].s32, &mut ctx.xer);
	// 830EA7A8: 409A00D0  bne cr6, 0x830ea878
	if !ctx.cr[6].eq {
	pc = 0x830EA878; continue 'dispatch;
	}
	pc = 0x830EA7AC; continue 'dispatch;
            }
            0x830EA7AC => {
    //   block [0x830EA7AC..0x830EA7B0)
	// 830EA7AC: B36B0006  sth r27, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[27].u16 ) };
	pc = 0x830EA7B0; continue 'dispatch;
            }
            0x830EA7B0 => {
    //   block [0x830EA7B0..0x830EA7C0)
	// 830EA7B0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830EA7B4: 409AFFC8  bne cr6, 0x830ea77c
	if !ctx.cr[6].eq {
	pc = 0x830EA77C; continue 'dispatch;
	}
	// 830EA7B8: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EA7BC: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	pc = 0x830EA7C0; continue 'dispatch;
            }
            0x830EA7C0 => {
    //   block [0x830EA7C0..0x830EA804)
	// 830EA7C0: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA7C4: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830EA7C8: 7FEBEA14  add r31, r11, r29
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830EA7CC: A17F0002  lhz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 830EA7D0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830EA7D4: 7FCBEA14  add r30, r11, r29
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830EA7D8: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 830EA7DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EA7E0: 409A003C  bne cr6, 0x830ea81c
	if !ctx.cr[6].eq {
	pc = 0x830EA81C; continue 'dispatch;
	}
	// 830EA7E4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EA7E8: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830EA7EC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EA7F0: 409A0014  bne cr6, 0x830ea804
	if !ctx.cr[6].eq {
	pc = 0x830EA804; continue 'dispatch;
	}
	// 830EA7F4: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 830EA7F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EA7FC: 4BC6C79D  bl 0x82d56f98
	ctx.lr = 0x830EA800;
	sub_82D56F98(ctx, base);
	// 830EA800: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x830EA804; continue 'dispatch;
            }
            0x830EA804 => {
    //   block [0x830EA804..0x830EA81C)
	// 830EA804: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EA808: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA80C: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 830EA810: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EA814: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 830EA818: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x830EA81C; continue 'dispatch;
            }
            0x830EA81C => {
    //   block [0x830EA81C..0x830EA83C)
	// 830EA81C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830EA820: 409AFFA0  bne cr6, 0x830ea7c0
	if !ctx.cr[6].eq {
	pc = 0x830EA7C0; continue 'dispatch;
	}
	// 830EA824: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EA828: 409AFF38  bne cr6, 0x830ea760
	if !ctx.cr[6].eq {
	pc = 0x830EA760; continue 'dispatch;
	}
	// 830EA82C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EA830: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EA834: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EA838: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x830EA83C; continue 'dispatch;
            }
            0x830EA83C => {
    //   block [0x830EA83C..0x830EA860)
	// 830EA83C: 995A0000  stb r10, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 830EA840: 409A0020  bne cr6, 0x830ea860
	if !ctx.cr[6].eq {
	pc = 0x830EA860; continue 'dispatch;
	}
	// 830EA844: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA848: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830EA84C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830EA850: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EA854: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830EA858: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830EA85C: 4BC6AA6D  bl 0x82d552c8
	ctx.lr = 0x830EA860;
	sub_82D552C8(ctx, base);
	pc = 0x830EA860; continue 'dispatch;
            }
            0x830EA860 => {
    //   block [0x830EA860..0x830EA86C)
	// 830EA860: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830EA864: 382102A0  addi r1, r1, 0x2a0
	ctx.r[1].s64 = ctx.r[1].s64 + 672;
	// 830EA868: 4BBBEBE8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x830EA86C => {
    //   block [0x830EA86C..0x830EA878)
	// 830EA86C: 2F1B0003  cmpwi cr6, r27, 3
	ctx.cr[6].compare_i32(ctx.r[27].s32, 3, &mut ctx.xer);
	// 830EA870: 419AFF40  beq cr6, 0x830ea7b0
	if ctx.cr[6].eq {
	pc = 0x830EA7B0; continue 'dispatch;
	}
	// 830EA874: 4BFFFF38  b 0x830ea7ac
	pc = 0x830EA7AC; continue 'dispatch;
            }
            0x830EA878 => {
    //   block [0x830EA878..0x830EA88C)
	// 830EA878: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EA87C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830EA880: 55690000  rlwinm r9, r11, 0, 0, 0
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EA884: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EA888: 4BFFFFB4  b 0x830ea83c
	pc = 0x830EA83C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EA890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EA890 size=1208
    let mut pc: u32 = 0x830EA890;
    'dispatch: loop {
        match pc {
            0x830EA890 => {
    //   block [0x830EA890..0x830EA8C4)
	// 830EA890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EA894: 4BBBEB59  bl 0x82ca93ec
	ctx.lr = 0x830EA898;
	sub_82CA93D0(ctx, base);
	// 830EA898: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EA89C: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 830EA8A0: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 830EA8A4: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 830EA8A8: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 830EA8AC: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 830EA8B0: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA8B4: 82F90004  lwz r23, 4(r25)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA8B8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EA8BC: 40990028  ble cr6, 0x830ea8e4
	if !ctx.cr[6].gt {
	pc = 0x830EA8E4; continue 'dispatch;
	}
	// 830EA8C0: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	pc = 0x830EA8C4; continue 'dispatch;
            }
            0x830EA8C4 => {
    //   block [0x830EA8C4..0x830EA8E4)
	// 830EA8C4: 81390004  lwz r9, 4(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA8C8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830EA8CC: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830EA8D0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 830EA8D4: B2C90006  sth r22, 6(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(6 as u32), ctx.r[22].u16 ) };
	// 830EA8D8: 81390008  lwz r9, 8(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EA8DC: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830EA8E0: 4198FFE4  blt cr6, 0x830ea8c4
	if ctx.cr[6].lt {
	pc = 0x830EA8C4; continue 'dispatch;
	}
	pc = 0x830EA8E4; continue 'dispatch;
            }
            0x830EA8E4 => {
    //   block [0x830EA8E4..0x830EA900)
	// 830EA8E4: 7CDA0774  extsb r26, r6
	ctx.r[26].s64 = ctx.r[6].s8 as i64;
	// 830EA8E8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA8EC: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 830EA8F0: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830EA8F4: 419A000C  beq cr6, 0x830ea900
	if ctx.cr[6].eq {
	pc = 0x830EA900; continue 'dispatch;
	}
	// 830EA8F8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA8FC: 48000008  b 0x830ea904
	pc = 0x830EA904; continue 'dispatch;
            }
            0x830EA900 => {
    //   block [0x830EA900..0x830EA904)
	// 830EA900: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x830EA904; continue 'dispatch;
            }
            0x830EA904 => {
    //   block [0x830EA904..0x830EA91C)
	// 830EA904: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA908: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 830EA90C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EA910: 41980074  blt cr6, 0x830ea984
	if ctx.cr[6].lt {
	pc = 0x830EA984; continue 'dispatch;
	}
	// 830EA914: 552A2036  slwi r10, r9, 4
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EA918: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	pc = 0x830EA91C; continue 'dispatch;
            }
            0x830EA91C => {
    //   block [0x830EA91C..0x830EA930)
	// 830EA91C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA920: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830EA924: 419A000C  beq cr6, 0x830ea930
	if ctx.cr[6].eq {
	pc = 0x830EA930; continue 'dispatch;
	}
	// 830EA928: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830EA92C: 4800000C  b 0x830ea938
	pc = 0x830EA938; continue 'dispatch;
            }
            0x830EA930 => {
    //   block [0x830EA930..0x830EA938)
	// 830EA930: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830EA934: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x830EA938; continue 'dispatch;
            }
            0x830EA938 => {
    //   block [0x830EA938..0x830EA95C)
	// 830EA938: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830EA93C: 419A0030  beq cr6, 0x830ea96c
	if ctx.cr[6].eq {
	pc = 0x830EA96C; continue 'dispatch;
	}
	// 830EA940: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 830EA944: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 830EA948: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830EA94C: 419A0010  beq cr6, 0x830ea95c
	if ctx.cr[6].eq {
	pc = 0x830EA95C; continue 'dispatch;
	}
	// 830EA950: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 830EA954: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830EA958: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	pc = 0x830EA95C; continue 'dispatch;
            }
            0x830EA95C => {
    //   block [0x830EA95C..0x830EA96C)
	// 830EA95C: A0AB0006  lhz r5, 6(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 830EA960: 2B050003  cmplwi cr6, r5, 3
	ctx.cr[6].compare_u32(ctx.r[5].u32, 3 as u32, &mut ctx.xer);
	// 830EA964: 419A0034  beq cr6, 0x830ea998
	if ctx.cr[6].eq {
	pc = 0x830EA998; continue 'dispatch;
	}
	// 830EA968: B0CB0006  sth r6, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[6].u16 ) };
	pc = 0x830EA96C; continue 'dispatch;
            }
            0x830EA96C => {
    //   block [0x830EA96C..0x830EA984)
	// 830EA96C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 830EA970: 394AFFF0  addi r10, r10, -0x10
	ctx.r[10].s64 = ctx.r[10].s64 + -16;
	// 830EA974: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EA978: 4098FFA4  bge cr6, 0x830ea91c
	if !ctx.cr[6].lt {
	pc = 0x830EA91C; continue 'dispatch;
	}
	// 830EA97C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 830EA980: 409A0028  bne cr6, 0x830ea9a8
	if !ctx.cr[6].eq {
	pc = 0x830EA9A8; continue 'dispatch;
	}
	pc = 0x830EA984; continue 'dispatch;
            }
            0x830EA984 => {
    //   block [0x830EA984..0x830EA998)
	// 830EA984: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EA988: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 830EA98C: 99750000  stb r11, 0(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830EA990: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830EA994: 4BBBEAA8  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830EA998 => {
    //   block [0x830EA998..0x830EA9A8)
	// 830EA998: 9AD50000  stb r22, 0(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[22].u8 ) };
	// 830EA99C: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 830EA9A0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830EA9A4: 4BBBEA98  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x830EA9A8 => {
    //   block [0x830EA9A8..0x830EA9BC)
	// 830EA9A8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA9AC: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830EA9B0: 419A000C  beq cr6, 0x830ea9bc
	if ctx.cr[6].eq {
	pc = 0x830EA9BC; continue 'dispatch;
	}
	// 830EA9B4: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA9B8: 48000008  b 0x830ea9c0
	pc = 0x830EA9C0; continue 'dispatch;
            }
            0x830EA9BC => {
    //   block [0x830EA9BC..0x830EA9C0)
	// 830EA9BC: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x830EA9C0; continue 'dispatch;
            }
            0x830EA9C0 => {
    //   block [0x830EA9C0..0x830EA9DC)
	// 830EA9C0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EA9C4: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 830EA9C8: 390BFFFF  addi r8, r11, -1
	ctx.r[8].s64 = ctx.r[11].s64 + -1;
	// 830EA9CC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830EA9D0: 4198007C  blt cr6, 0x830eaa4c
	if ctx.cr[6].lt {
	pc = 0x830EAA4C; continue 'dispatch;
	}
	// 830EA9D4: 55092036  slwi r9, r8, 4
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830EA9D8: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	pc = 0x830EA9DC; continue 'dispatch;
            }
            0x830EA9DC => {
    //   block [0x830EA9DC..0x830EA9F0)
	// 830EA9DC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EA9E0: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830EA9E4: 419A000C  beq cr6, 0x830ea9f0
	if ctx.cr[6].eq {
	pc = 0x830EA9F0; continue 'dispatch;
	}
	// 830EA9E8: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830EA9EC: 4800000C  b 0x830ea9f8
	pc = 0x830EA9F8; continue 'dispatch;
            }
            0x830EA9F0 => {
    //   block [0x830EA9F0..0x830EA9F8)
	// 830EA9F0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830EA9F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x830EA9F8; continue 'dispatch;
            }
            0x830EA9F8 => {
    //   block [0x830EA9F8..0x830EAA18)
	// 830EA9F8: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 830EA9FC: 419A0040  beq cr6, 0x830eaa3c
	if ctx.cr[6].eq {
	pc = 0x830EAA3C; continue 'dispatch;
	}
	// 830EAA00: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 830EAA04: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830EAA08: 409A0010  bne cr6, 0x830eaa18
	if !ctx.cr[6].eq {
	pc = 0x830EAA18; continue 'dispatch;
	}
	// 830EAA0C: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 830EAA10: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830EAA14: 7D6BBA14  add r11, r11, r23
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	pc = 0x830EAA18; continue 'dispatch;
            }
            0x830EAA18 => {
    //   block [0x830EAA18..0x830EAA38)
	// 830EAA18: A14B0006  lhz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 830EAA1C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830EAA20: 41980018  blt cr6, 0x830eaa38
	if ctx.cr[6].lt {
	pc = 0x830EAA38; continue 'dispatch;
	}
	// 830EAA24: 419AFF74  beq cr6, 0x830ea998
	if ctx.cr[6].eq {
	pc = 0x830EA998; continue 'dispatch;
	}
	// 830EAA28: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 830EAA2C: 409A0010  bne cr6, 0x830eaa3c
	if !ctx.cr[6].eq {
	pc = 0x830EAA3C; continue 'dispatch;
	}
	// 830EAA30: B0CB0006  sth r6, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[6].u16 ) };
	// 830EAA34: 48000008  b 0x830eaa3c
	pc = 0x830EAA3C; continue 'dispatch;
            }
            0x830EAA38 => {
    //   block [0x830EAA38..0x830EAA3C)
	// 830EAA38: B30B0006  sth r24, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[24].u16 ) };
	pc = 0x830EAA3C; continue 'dispatch;
            }
            0x830EAA3C => {
    //   block [0x830EAA3C..0x830EAA4C)
	// 830EAA3C: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 830EAA40: 3929FFF0  addi r9, r9, -0x10
	ctx.r[9].s64 = ctx.r[9].s64 + -16;
	// 830EAA44: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830EAA48: 4098FF94  bge cr6, 0x830ea9dc
	if !ctx.cr[6].lt {
	pc = 0x830EA9DC; continue 'dispatch;
	}
	pc = 0x830EAA4C; continue 'dispatch;
            }
            0x830EAA4C => {
    //   block [0x830EAA4C..0x830EAA64)
	// 830EAA4C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAA50: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 830EAA54: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830EAA58: 419A000C  beq cr6, 0x830eaa64
	if ctx.cr[6].eq {
	pc = 0x830EAA64; continue 'dispatch;
	}
	// 830EAA5C: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAA60: 48000008  b 0x830eaa68
	pc = 0x830EAA68; continue 'dispatch;
            }
            0x830EAA64 => {
    //   block [0x830EAA64..0x830EAA68)
	// 830EAA64: 838B0004  lwz r28, 4(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x830EAA68; continue 'dispatch;
            }
            0x830EAA68 => {
    //   block [0x830EAA68..0x830EAA7C)
	// 830EAA68: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EAA6C: 3BABFFFF  addi r29, r11, -1
	ctx.r[29].s64 = ctx.r[11].s64 + -1;
	// 830EAA70: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830EAA74: 419800EC  blt cr6, 0x830eab60
	if ctx.cr[6].lt {
	pc = 0x830EAB60; continue 'dispatch;
	}
	// 830EAA78: 57BE2036  slwi r30, r29, 4
	ctx.r[30].u32 = ctx.r[29].u32.wrapping_shl(4);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	pc = 0x830EAA7C; continue 'dispatch;
            }
            0x830EAA7C => {
    //   block [0x830EAA7C..0x830EAA90)
	// 830EAA7C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAA80: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830EAA84: 419A000C  beq cr6, 0x830eaa90
	if ctx.cr[6].eq {
	pc = 0x830EAA90; continue 'dispatch;
	}
	// 830EAA88: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 830EAA8C: 4800000C  b 0x830eaa98
	pc = 0x830EAA98; continue 'dispatch;
            }
            0x830EAA90 => {
    //   block [0x830EAA90..0x830EAA98)
	// 830EAA90: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830EAA94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x830EAA98; continue 'dispatch;
            }
            0x830EAA98 => {
    //   block [0x830EAA98..0x830EAAB4)
	// 830EAA98: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830EAA9C: 419A00B4  beq cr6, 0x830eab50
	if ctx.cr[6].eq {
	pc = 0x830EAB50; continue 'dispatch;
	}
	// 830EAAA0: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 830EAAA4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830EAAA8: 419A000C  beq cr6, 0x830eaab4
	if ctx.cr[6].eq {
	pc = 0x830EAAB4; continue 'dispatch;
	}
	// 830EAAAC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 830EAAB0: 48000010  b 0x830eaac0
	pc = 0x830EAAC0; continue 'dispatch;
            }
            0x830EAAB4 => {
    //   block [0x830EAAB4..0x830EAAC0)
	// 830EAAB4: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 830EAAB8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830EAABC: 7FEBBA14  add r31, r11, r23
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	pc = 0x830EAAC0; continue 'dispatch;
            }
            0x830EAAC0 => {
    //   block [0x830EAAC0..0x830EAAFC)
	// 830EAAC0: A17F0006  lhz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 830EAAC4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830EAAC8: 409A003C  bne cr6, 0x830eab04
	if !ctx.cr[6].eq {
	pc = 0x830EAB04; continue 'dispatch;
	}
	// 830EAACC: 7CCB0774  extsb r11, r6
	ctx.r[11].s64 = ctx.r[6].s8 as i64;
	// 830EAAD0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EAAD4: 419A0028  beq cr6, 0x830eaafc
	if ctx.cr[6].eq {
	pc = 0x830EAAFC; continue 'dispatch;
	}
	// 830EAAD8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 830EAADC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830EAAE0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830EAAE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EAAE8: 4BFFFC41  bl 0x830ea728
	ctx.lr = 0x830EAAEC;
	sub_830EA728(ctx, base);
	// 830EAAEC: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAAF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EAAF4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 830EAAF8: 409A0008  bne cr6, 0x830eab00
	if !ctx.cr[6].eq {
	pc = 0x830EAB00; continue 'dispatch;
	}
	pc = 0x830EAAFC; continue 'dispatch;
            }
            0x830EAAFC => {
    //   block [0x830EAAFC..0x830EAB00)
	// 830EAAFC: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x830EAB00; continue 'dispatch;
            }
            0x830EAB00 => {
    //   block [0x830EAB00..0x830EAB04)
	// 830EAB00: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x830EAB04; continue 'dispatch;
            }
            0x830EAB04 => {
    //   block [0x830EAB04..0x830EAB48)
	// 830EAB04: A17F0002  lhz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 830EAB08: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830EAB0C: 7CABBA14  add r5, r11, r23
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 830EAB10: A1650006  lhz r11, 6(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(6 as u32) ) } as u64;
	// 830EAB14: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 830EAB18: 409A0038  bne cr6, 0x830eab50
	if !ctx.cr[6].eq {
	pc = 0x830EAB50; continue 'dispatch;
	}
	// 830EAB1C: 7CCB0774  extsb r11, r6
	ctx.r[11].s64 = ctx.r[6].s8 as i64;
	// 830EAB20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EAB24: 419A0024  beq cr6, 0x830eab48
	if ctx.cr[6].eq {
	pc = 0x830EAB48; continue 'dispatch;
	}
	// 830EAB28: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 830EAB2C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830EAB30: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 830EAB34: 4BFFFBF5  bl 0x830ea728
	ctx.lr = 0x830EAB38;
	sub_830EA728(ctx, base);
	// 830EAB38: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAB3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EAB40: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 830EAB44: 409A0008  bne cr6, 0x830eab4c
	if !ctx.cr[6].eq {
	pc = 0x830EAB4C; continue 'dispatch;
	}
	pc = 0x830EAB48; continue 'dispatch;
            }
            0x830EAB48 => {
    //   block [0x830EAB48..0x830EAB4C)
	// 830EAB48: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x830EAB4C; continue 'dispatch;
            }
            0x830EAB4C => {
    //   block [0x830EAB4C..0x830EAB50)
	// 830EAB4C: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x830EAB50; continue 'dispatch;
            }
            0x830EAB50 => {
    //   block [0x830EAB50..0x830EAB60)
	// 830EAB50: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 830EAB54: 3BDEFFF0  addi r30, r30, -0x10
	ctx.r[30].s64 = ctx.r[30].s64 + -16;
	// 830EAB58: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830EAB5C: 4098FF20  bge cr6, 0x830eaa7c
	if !ctx.cr[6].lt {
	pc = 0x830EAA7C; continue 'dispatch;
	}
	pc = 0x830EAB60; continue 'dispatch;
            }
            0x830EAB60 => {
    //   block [0x830EAB60..0x830EAB74)
	// 830EAB60: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAB64: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830EAB68: 419A000C  beq cr6, 0x830eab74
	if ctx.cr[6].eq {
	pc = 0x830EAB74; continue 'dispatch;
	}
	// 830EAB6C: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAB70: 48000008  b 0x830eab78
	pc = 0x830EAB78; continue 'dispatch;
            }
            0x830EAB74 => {
    //   block [0x830EAB74..0x830EAB78)
	// 830EAB74: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x830EAB78; continue 'dispatch;
            }
            0x830EAB78 => {
    //   block [0x830EAB78..0x830EAB8C)
	// 830EAB78: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EAB7C: 3BCBFFFF  addi r30, r11, -1
	ctx.r[30].s64 = ctx.r[11].s64 + -1;
	// 830EAB80: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830EAB84: 41980168  blt cr6, 0x830eacec
	if ctx.cr[6].lt {
	pc = 0x830EACEC; continue 'dispatch;
	}
	// 830EAB88: 57DF2036  slwi r31, r30, 4
	ctx.r[31].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	pc = 0x830EAB8C; continue 'dispatch;
            }
            0x830EAB8C => {
    //   block [0x830EAB8C..0x830EABA0)
	// 830EAB8C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAB90: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830EAB94: 419A000C  beq cr6, 0x830eaba0
	if ctx.cr[6].eq {
	pc = 0x830EABA0; continue 'dispatch;
	}
	// 830EAB98: 7D6AF82E  lwzx r11, r10, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 830EAB9C: 4800000C  b 0x830eaba8
	pc = 0x830EABA8; continue 'dispatch;
            }
            0x830EABA0 => {
    //   block [0x830EABA0..0x830EABA8)
	// 830EABA0: 7D6AFA14  add r11, r10, r31
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 830EABA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x830EABA8; continue 'dispatch;
            }
            0x830EABA8 => {
    //   block [0x830EABA8..0x830EABC4)
	// 830EABA8: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830EABAC: 419A0130  beq cr6, 0x830eacdc
	if ctx.cr[6].eq {
	pc = 0x830EACDC; continue 'dispatch;
	}
	// 830EABB0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 830EABB4: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830EABB8: 419A000C  beq cr6, 0x830eabc4
	if ctx.cr[6].eq {
	pc = 0x830EABC4; continue 'dispatch;
	}
	// 830EABBC: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 830EABC0: 48000010  b 0x830eabd0
	pc = 0x830EABD0; continue 'dispatch;
            }
            0x830EABC4 => {
    //   block [0x830EABC4..0x830EABD0)
	// 830EABC4: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 830EABC8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830EABCC: 7CABBA14  add r5, r11, r23
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	pc = 0x830EABD0; continue 'dispatch;
            }
            0x830EABD0 => {
    //   block [0x830EABD0..0x830EABF0)
	// 830EABD0: A1650006  lhz r11, 6(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(6 as u32) ) } as u64;
	// 830EABD4: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 830EABD8: 409A0104  bne cr6, 0x830eacdc
	if !ctx.cr[6].eq {
	pc = 0x830EACDC; continue 'dispatch;
	}
	// 830EABDC: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 830EABE0: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830EABE4: 419A000C  beq cr6, 0x830eabf0
	if ctx.cr[6].eq {
	pc = 0x830EABF0; continue 'dispatch;
	}
	// 830EABE8: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EABEC: 48000008  b 0x830eabf4
	pc = 0x830EABF4; continue 'dispatch;
            }
            0x830EABF0 => {
    //   block [0x830EABF0..0x830EABF4)
	// 830EABF0: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x830EABF4; continue 'dispatch;
            }
            0x830EABF4 => {
    //   block [0x830EABF4..0x830EAC0C)
	// 830EABF4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EABF8: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 830EABFC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EAC00: 41980050  blt cr6, 0x830eac50
	if ctx.cr[6].lt {
	pc = 0x830EAC50; continue 'dispatch;
	}
	// 830EAC04: 552B2036  slwi r11, r9, 4
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EAC08: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x830EAC0C; continue 'dispatch;
            }
            0x830EAC0C => {
    //   block [0x830EAC0C..0x830EAC1C)
	// 830EAC0C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830EAC10: 419A000C  beq cr6, 0x830eac1c
	if ctx.cr[6].eq {
	pc = 0x830EAC1C; continue 'dispatch;
	}
	// 830EAC14: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAC18: 48000008  b 0x830eac20
	pc = 0x830EAC20; continue 'dispatch;
            }
            0x830EAC1C => {
    //   block [0x830EAC1C..0x830EAC20)
	// 830EAC1C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x830EAC20; continue 'dispatch;
            }
            0x830EAC20 => {
    //   block [0x830EAC20..0x830EAC38)
	// 830EAC20: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830EAC24: 419A0014  beq cr6, 0x830eac38
	if ctx.cr[6].eq {
	pc = 0x830EAC38; continue 'dispatch;
	}
	// 830EAC28: A08B0006  lhz r4, 6(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 830EAC2C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 830EAC30: 2B040002  cmplwi cr6, r4, 2
	ctx.cr[6].compare_u32(ctx.r[4].u32, 2 as u32, &mut ctx.xer);
	// 830EAC34: 409A0018  bne cr6, 0x830eac4c
	if !ctx.cr[6].eq {
	pc = 0x830EAC4C; continue 'dispatch;
	}
	pc = 0x830EAC38; continue 'dispatch;
            }
            0x830EAC38 => {
    //   block [0x830EAC38..0x830EAC4C)
	// 830EAC38: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 830EAC3C: 394AFFF0  addi r10, r10, -0x10
	ctx.r[10].s64 = ctx.r[10].s64 + -16;
	// 830EAC40: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EAC44: 4098FFC8  bge cr6, 0x830eac0c
	if !ctx.cr[6].lt {
	pc = 0x830EAC0C; continue 'dispatch;
	}
	// 830EAC48: 48000008  b 0x830eac50
	pc = 0x830EAC50; continue 'dispatch;
            }
            0x830EAC4C => {
    //   block [0x830EAC4C..0x830EAC50)
	// 830EAC4C: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	pc = 0x830EAC50; continue 'dispatch;
            }
            0x830EAC50 => {
    //   block [0x830EAC50..0x830EAC6C)
	// 830EAC50: 81390008  lwz r9, 8(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EAC54: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 830EAC58: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 830EAC5C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EAC60: 40990030  ble cr6, 0x830eac90
	if !ctx.cr[6].gt {
	pc = 0x830EAC90; continue 'dispatch;
	}
	// 830EAC64: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EAC68: 394A0006  addi r10, r10, 6
	ctx.r[10].s64 = ctx.r[10].s64 + 6;
	pc = 0x830EAC6C; continue 'dispatch;
            }
            0x830EAC6C => {
    //   block [0x830EAC6C..0x830EAC8C)
	// 830EAC6C: A08A0000  lhz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAC70: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 830EAC74: 419A0018  beq cr6, 0x830eac8c
	if ctx.cr[6].eq {
	pc = 0x830EAC8C; continue 'dispatch;
	}
	// 830EAC78: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830EAC7C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 830EAC80: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830EAC84: 4198FFE8  blt cr6, 0x830eac6c
	if ctx.cr[6].lt {
	pc = 0x830EAC6C; continue 'dispatch;
	}
	// 830EAC88: 48000008  b 0x830eac90
	pc = 0x830EAC90; continue 'dispatch;
            }
            0x830EAC8C => {
    //   block [0x830EAC8C..0x830EAC90)
	// 830EAC8C: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	pc = 0x830EAC90; continue 'dispatch;
            }
            0x830EAC90 => {
    //   block [0x830EAC90..0x830EACD4)
	// 830EAC90: 7CEB0774  extsb r11, r7
	ctx.r[11].s64 = ctx.r[7].s8 as i64;
	// 830EAC94: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EAC98: 419A0044  beq cr6, 0x830eacdc
	if ctx.cr[6].eq {
	pc = 0x830EACDC; continue 'dispatch;
	}
	// 830EAC9C: 7D0B0774  extsb r11, r8
	ctx.r[11].s64 = ctx.r[8].s8 as i64;
	// 830EACA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EACA4: 419A0038  beq cr6, 0x830eacdc
	if ctx.cr[6].eq {
	pc = 0x830EACDC; continue 'dispatch;
	}
	// 830EACA8: 7CCB0774  extsb r11, r6
	ctx.r[11].s64 = ctx.r[6].s8 as i64;
	// 830EACAC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EACB0: 419A0024  beq cr6, 0x830eacd4
	if ctx.cr[6].eq {
	pc = 0x830EACD4; continue 'dispatch;
	}
	// 830EACB4: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 830EACB8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830EACBC: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 830EACC0: 4BFFFA69  bl 0x830ea728
	ctx.lr = 0x830EACC4;
	sub_830EA728(ctx, base);
	// 830EACC4: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EACC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EACCC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 830EACD0: 409A0008  bne cr6, 0x830eacd8
	if !ctx.cr[6].eq {
	pc = 0x830EACD8; continue 'dispatch;
	}
	pc = 0x830EACD4; continue 'dispatch;
            }
            0x830EACD4 => {
    //   block [0x830EACD4..0x830EACD8)
	// 830EACD4: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x830EACD8; continue 'dispatch;
            }
            0x830EACD8 => {
    //   block [0x830EACD8..0x830EACDC)
	// 830EACD8: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x830EACDC; continue 'dispatch;
            }
            0x830EACDC => {
    //   block [0x830EACDC..0x830EACEC)
	// 830EACDC: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 830EACE0: 3BFFFFF0  addi r31, r31, -0x10
	ctx.r[31].s64 = ctx.r[31].s64 + -16;
	// 830EACE4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 830EACE8: 4098FEA4  bge cr6, 0x830eab8c
	if !ctx.cr[6].lt {
	pc = 0x830EAB8C; continue 'dispatch;
	}
	pc = 0x830EACEC; continue 'dispatch;
            }
            0x830EACEC => {
    //   block [0x830EACEC..0x830EACFC)
	// 830EACEC: 81390008  lwz r9, 8(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EACF0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EACF4: 40990044  ble cr6, 0x830ead38
	if !ctx.cr[6].gt {
	pc = 0x830EAD38; continue 'dispatch;
	}
	// 830EACF8: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x830EACFC; continue 'dispatch;
            }
            0x830EACFC => {
    //   block [0x830EACFC..0x830EAD20)
	// 830EACFC: 7CCA0774  extsb r10, r6
	ctx.r[10].s64 = ctx.r[6].s8 as i64;
	// 830EAD00: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EAD04: 419A001C  beq cr6, 0x830ead20
	if ctx.cr[6].eq {
	pc = 0x830EAD20; continue 'dispatch;
	}
	// 830EAD08: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EAD0C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830EAD10: A14A0006  lhz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 830EAD14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830EAD18: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 830EAD1C: 409A0008  bne cr6, 0x830ead24
	if !ctx.cr[6].eq {
	pc = 0x830EAD24; continue 'dispatch;
	}
	pc = 0x830EAD20; continue 'dispatch;
            }
            0x830EAD20 => {
    //   block [0x830EAD20..0x830EAD24)
	// 830EAD20: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	pc = 0x830EAD24; continue 'dispatch;
            }
            0x830EAD24 => {
    //   block [0x830EAD24..0x830EAD38)
	// 830EAD24: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 830EAD28: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 830EAD2C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 830EAD30: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830EAD34: 409AFFC8  bne cr6, 0x830eacfc
	if !ctx.cr[6].eq {
	pc = 0x830EACFC; continue 'dispatch;
	}
	pc = 0x830EAD38; continue 'dispatch;
            }
            0x830EAD38 => {
    //   block [0x830EAD38..0x830EAD48)
	// 830EAD38: 98D50000  stb r6, 0(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[6].u8 ) };
	// 830EAD3C: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 830EAD40: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830EAD44: 4BBBE6F8  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EAD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EAD48 size=232
    let mut pc: u32 = 0x830EAD48;
    'dispatch: loop {
        match pc {
            0x830EAD48 => {
    //   block [0x830EAD48..0x830EAD74)
	// 830EAD48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EAD4C: 4BBBE6A1  bl 0x82ca93ec
	ctx.lr = 0x830EAD50;
	sub_82CA93D0(ctx, base);
	// 830EAD50: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EAD54: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 830EAD58: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 830EAD5C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 830EAD60: 81760008  lwz r11, 8(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EAD64: 83160004  lwz r24, 4(r22)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EAD68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EAD6C: 409900BC  ble cr6, 0x830eae28
	if !ctx.cr[6].gt {
	pc = 0x830EAE28; continue 'dispatch;
	}
	// 830EAD70: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	pc = 0x830EAD74; continue 'dispatch;
            }
            0x830EAD74 => {
    //   block [0x830EAD74..0x830EADE0)
	// 830EAD74: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EAD78: 7D75582A  ldx r11, r21, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[11].u32)) };
	// 830EAD7C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 830EAD80: A1610054  lhz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EAD84: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EAD88: 4098008C  bge cr6, 0x830eae14
	if !ctx.cr[6].lt {
	pc = 0x830EAE14; continue 'dispatch;
	}
	// 830EAD8C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EAD90: 7D6BC214  add r11, r11, r24
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 830EAD94: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EAD98: 7F195000  cmpw cr6, r25, r10
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830EAD9C: 40980078  bge cr6, 0x830eae14
	if !ctx.cr[6].lt {
	pc = 0x830EAE14; continue 'dispatch;
	}
	// 830EADA0: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 830EADA4: A36B0000  lhz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EADA8: 3BF7000C  addi r31, r23, 0xc
	ctx.r[31].s64 = ctx.r[23].s64 + 12;
	// 830EADAC: A3810050  lhz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EADB0: 554B183E  rotlwi r11, r10, 3
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 830EADB4: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EADB8: 7F4BC22E  lhzx r26, r11, r24
	ctx.r[26].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 830EADBC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EADC0: 3BBE0001  addi r29, r30, 1
	ctx.r[29].s64 = ctx.r[30].s64 + 1;
	// 830EADC4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830EADC8: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830EADCC: 40980024  bge cr6, 0x830eadf0
	if !ctx.cr[6].lt {
	pc = 0x830EADF0; continue 'dispatch;
	}
	// 830EADD0: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EADD4: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EADD8: 41980008  blt cr6, 0x830eade0
	if ctx.cr[6].lt {
	pc = 0x830EADE0; continue 'dispatch;
	}
	// 830EADDC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x830EADE0; continue 'dispatch;
            }
            0x830EADE0 => {
    //   block [0x830EADE0..0x830EADF0)
	// 830EADE0: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 830EADE4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830EADE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EADEC: 4BC6C125  bl 0x82d56f10
	ctx.lr = 0x830EADF0;
	sub_82D56F10(ctx, base);
	pc = 0x830EADF0; continue 'dispatch;
            }
            0x830EADF0 => {
    //   block [0x830EADF0..0x830EAE14)
	// 830EADF0: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EADF4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EADF8: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830EADFC: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830EAE00: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EAE04: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830EAE08: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 830EAE0C: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 830EAE10: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x830EAE14; continue 'dispatch;
            }
            0x830EAE14 => {
    //   block [0x830EAE14..0x830EAE28)
	// 830EAE14: 81760008  lwz r11, 8(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EAE18: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 830EAE1C: 3AB50008  addi r21, r21, 8
	ctx.r[21].s64 = ctx.r[21].s64 + 8;
	// 830EAE20: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EAE24: 4198FF50  blt cr6, 0x830ead74
	if ctx.cr[6].lt {
	pc = 0x830EAD74; continue 'dispatch;
	}
	pc = 0x830EAE28; continue 'dispatch;
            }
            0x830EAE28 => {
    //   block [0x830EAE28..0x830EAE30)
	// 830EAE28: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830EAE2C: 4BBBE610  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EAE30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EAE30 size=132
    let mut pc: u32 = 0x830EAE30;
    'dispatch: loop {
        match pc {
            0x830EAE30 => {
    //   block [0x830EAE30..0x830EAE9C)
	// 830EAE30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EAE34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EAE38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EAE3C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EAE40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EAE44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EAE48: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 830EAE4C: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 830EAE50: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 830EAE54: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830EAE58: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 830EAE5C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830EAE60: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 830EAE64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EAE68: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830EAE6C: 4BFFE6AD  bl 0x830e9518
	ctx.lr = 0x830EAE70;
	sub_830E9518(ctx, base);
	// 830EAE70: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830EAE74: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EAE78: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EAE7C: 409A0020  bne cr6, 0x830eae9c
	if !ctx.cr[6].eq {
	pc = 0x830EAE9C; continue 'dispatch;
	}
	// 830EAE80: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAE84: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830EAE88: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830EAE8C: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EAE90: 55652834  slwi r5, r11, 5
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830EAE94: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830EAE98: 4BC6A431  bl 0x82d552c8
	ctx.lr = 0x830EAE9C;
	sub_82D552C8(ctx, base);
	pc = 0x830EAE9C; continue 'dispatch;
            }
            0x830EAE9C => {
    //   block [0x830EAE9C..0x830EAEB4)
	// 830EAE9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EAEA0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830EAEA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EAEA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EAEAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EAEB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EAEB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EAEB8 size=1208
    let mut pc: u32 = 0x830EAEB8;
    'dispatch: loop {
        match pc {
            0x830EAEB8 => {
    //   block [0x830EAEB8..0x830EAF20)
	// 830EAEB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EAEBC: 4BBBE531  bl 0x82ca93ec
	ctx.lr = 0x830EAEC0;
	sub_82CA93D0(ctx, base);
	// 830EAEC0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EAEC4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830EAEC8: 82CD0000  lwz r22, 0(r13)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAECC: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 830EAED0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830EAED4: 3AE00004  li r23, 4
	ctx.r[23].s64 = 4;
	// 830EAED8: 3FE08000  lis r31, -0x8000
	ctx.r[31].s64 = -2147483648;
	// 830EAEDC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830EAEE0: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 830EAEE4: 939A0008  stw r28, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 830EAEE8: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 830EAEEC: 83DB0008  lwz r30, 8(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EAEF0: 7C77B02E  lwzx r3, r23, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 830EAEF4: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 830EAEF8: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 830EAEFC: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 830EAF00: 55640836  rlwinm r4, r11, 1, 0, 0x1b
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 830EAF04: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 830EAF08: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 830EAF0C: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 830EAF10: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830EAF14: 4199000C  bgt cr6, 0x830eaf20
	if ctx.cr[6].gt {
	pc = 0x830EAF20; continue 'dispatch;
	}
	// 830EAF18: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830EAF1C: 48000018  b 0x830eaf34
	pc = 0x830EAF34; continue 'dispatch;
            }
            0x830EAF20 => {
    //   block [0x830EAF20..0x830EAF34)
	// 830EAF20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAF24: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EAF28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EAF2C: 4E800421  bctrl
	ctx.lr = 0x830EAF30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830EAF30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
            }
            0x830EAF34 => {
    //   block [0x830EAF34..0x830EAF9C)
	// 830EAF34: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830EAF38: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 830EAF3C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830EAF40: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830EAF44: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 830EAF48: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830EAF4C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830EAF50: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 830EAF54: 7FC9FB78  or r9, r30, r31
	ctx.r[9].u64 = ctx.r[30].u64 | ctx.r[31].u64;
	// 830EAF58: 888A0000  lbz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAF5C: 91210078  stw r9, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 830EAF60: 4BFFF359  bl 0x830ea2b8
	ctx.lr = 0x830EAF64;
	sub_830EA2B8(ctx, base);
	// 830EAF64: 7C77B02E  lwzx r3, r23, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 830EAF68: 83DD0008  lwz r30, 8(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EAF6C: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 830EAF70: 395E0008  addi r10, r30, 8
	ctx.r[10].s64 = ctx.r[30].s64 + 8;
	// 830EAF74: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 830EAF78: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 830EAF7C: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 830EAF80: 55440836  rlwinm r4, r10, 1, 0, 0x1b
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x7FFFFFFFu64;
	// 830EAF84: 8123002C  lwz r9, 0x2c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 830EAF88: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 830EAF8C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830EAF90: 4199000C  bgt cr6, 0x830eaf9c
	if ctx.cr[6].gt {
	pc = 0x830EAF9C; continue 'dispatch;
	}
	// 830EAF94: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830EAF98: 48000018  b 0x830eafb0
	pc = 0x830EAFB0; continue 'dispatch;
            }
            0x830EAF9C => {
    //   block [0x830EAF9C..0x830EAFB0)
	// 830EAF9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAFA0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EAFA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EAFA8: 4E800421  bctrl
	ctx.lr = 0x830EAFAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830EAFAC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
            }
            0x830EAFB0 => {
    //   block [0x830EAFB0..0x830EB010)
	// 830EAFB0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 830EAFB4: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 830EAFB8: 7FC9FB78  or r9, r30, r31
	ctx.r[9].u64 = ctx.r[30].u64 | ctx.r[31].u64;
	// 830EAFBC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 830EAFC0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 830EAFC4: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 830EAFC8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 830EAFCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EAFD0: 888A0000  lbz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EAFD4: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 830EAFD8: 4BFFF2E1  bl 0x830ea2b8
	ctx.lr = 0x830EAFDC;
	sub_830EA2B8(ctx, base);
	// 830EAFDC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EAFE0: 3BFA0004  addi r31, r26, 4
	ctx.r[31].s64 = ctx.r[26].s64 + 4;
	// 830EAFE4: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EAFE8: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830EAFEC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830EAFF0: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830EAFF4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EAFF8: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830EAFFC: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 830EB000: 40980010  bge cr6, 0x830eb010
	if !ctx.cr[6].lt {
	pc = 0x830EB010; continue 'dispatch;
	}
	// 830EB004: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 830EB008: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EB00C: 4BC6BF05  bl 0x82d56f10
	ctx.lr = 0x830EB010;
	sub_82D56F10(ctx, base);
	pc = 0x830EB010; continue 'dispatch;
            }
            0x830EB010 => {
    //   block [0x830EB010..0x830EB024)
	// 830EB010: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB014: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830EB018: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EB01C: 409900C0  ble cr6, 0x830eb0dc
	if !ctx.cr[6].gt {
	pc = 0x830EB0DC; continue 'dispatch;
	}
	// 830EB020: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x830EB024; continue 'dispatch;
            }
            0x830EB024 => {
    //   block [0x830EB024..0x830EB08C)
	// 830EB024: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB028: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 830EB02C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB030: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB034: A10A0000  lhz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB038: B10B0008  sth r8, 8(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u16 ) };
	// 830EB03C: A10A0004  lhz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB040: 80BB0004  lwz r5, 4(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB044: 5508183E  rotlwi r8, r8, 3
	ctx.r[8].u64 = ((ctx.r[8].u32).rotate_left(3)) as u64;
	// 830EB048: 7D082A2E  lhzx r8, r8, r5
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 830EB04C: B10B000C  sth r8, 0xc(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u16 ) };
	// 830EB050: A1090000  lhz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB054: B10B000E  sth r8, 0xe(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(14 as u32), ctx.r[8].u16 ) };
	// 830EB058: A1290002  lhz r9, 2(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 830EB05C: 811B0004  lwz r8, 4(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB060: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 830EB064: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 830EB068: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 830EB06C: 81210070  lwz r9, 0x70(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830EB070: 7D4A1E70  srawi r10, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 830EB074: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EB078: 7D4A4A2E  lhzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 830EB07C: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 830EB080: 409A000C  bne cr6, 0x830eb08c
	if !ctx.cr[6].eq {
	pc = 0x830EB08C; continue 'dispatch;
	}
	// 830EB084: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 830EB088: 48000010  b 0x830eb098
	pc = 0x830EB098; continue 'dispatch;
            }
            0x830EB08C => {
    //   block [0x830EB08C..0x830EB098)
	// 830EB08C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB090: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EB094: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	pc = 0x830EB098; continue 'dispatch;
            }
            0x830EB098 => {
    //   block [0x830EB098..0x830EB0B8)
	// 830EB098: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830EB09C: 5509083C  slwi r9, r8, 1
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 830EB0A0: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830EB0A4: 7D49522E  lhzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830EB0A8: 2B0AFFFF  cmplwi cr6, r10, 0xffff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 65535 as u32, &mut ctx.xer);
	// 830EB0AC: 409A000C  bne cr6, 0x830eb0b8
	if !ctx.cr[6].eq {
	pc = 0x830EB0B8; continue 'dispatch;
	}
	// 830EB0B0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 830EB0B4: 48000010  b 0x830eb0c4
	pc = 0x830EB0C4; continue 'dispatch;
            }
            0x830EB0B8 => {
    //   block [0x830EB0B8..0x830EB0C4)
	// 830EB0B8: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB0BC: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EB0C0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	pc = 0x830EB0C4; continue 'dispatch;
            }
            0x830EB0C4 => {
    //   block [0x830EB0C4..0x830EB0DC)
	// 830EB0C4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830EB0C8: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 830EB0CC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB0D0: 38E70010  addi r7, r7, 0x10
	ctx.r[7].s64 = ctx.r[7].s64 + 16;
	// 830EB0D4: 7F065800  cmpw cr6, r6, r11
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EB0D8: 4198FF4C  blt cr6, 0x830eb024
	if ctx.cr[6].lt {
	pc = 0x830EB024; continue 'dispatch;
	}
	pc = 0x830EB0DC; continue 'dispatch;
            }
            0x830EB0DC => {
    //   block [0x830EB0DC..0x830EB104)
	// 830EB0DC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB0E0: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 830EB0E4: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB0E8: 3B6BFFFF  addi r27, r11, -1
	ctx.r[27].s64 = ctx.r[11].s64 + -1;
	// 830EB0EC: 81190000  lwz r8, 0(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB0F0: 831A0008  lwz r24, 8(r26)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EB0F4: 6063FFFF  ori r3, r3, 0xffff
	ctx.r[3].u64 = ctx.r[3].u64 | 65535;
	// 830EB0F8: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830EB0FC: 419801C4  blt cr6, 0x830eb2c0
	if ctx.cr[6].lt {
	pc = 0x830EB2C0; continue 'dispatch;
	}
	// 830EB100: 577E2036  slwi r30, r27, 4
	ctx.r[30].u32 = ctx.r[27].u32.wrapping_shl(4);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	pc = 0x830EB104; continue 'dispatch;
            }
            0x830EB104 => {
    //   block [0x830EB104..0x830EB174)
	// 830EB104: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB108: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB10C: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 830EB110: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB114: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EB118: 80BA0008  lwz r5, 8(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EB11C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 830EB120: 7CEA4A14  add r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830EB124: 54CA003E  slwi r10, r6, 0
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EB128: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 830EB12C: 3AAA0001  addi r21, r10, 1
	ctx.r[21].s64 = ctx.r[10].s64 + 1;
	// 830EB130: 809A0008  lwz r4, 8(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EB134: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EB138: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830EB13C: 92BF0004  stw r21, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[21].u32 ) };
	// 830EB140: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB144: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB148: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830EB14C: 409A00B0  bne cr6, 0x830eb1fc
	if !ctx.cr[6].eq {
	pc = 0x830EB1FC; continue 'dispatch;
	}
	// 830EB150: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB154: A12A0006  lhz r9, 6(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 830EB158: 3929FFFE  addi r9, r9, -2
	ctx.r[9].s64 = ctx.r[9].s64 + -2;
	// 830EB15C: 7D290034  cntlzw r9, r9
	ctx.r[9].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 830EB160: 5529DFFE  rlwinm r9, r9, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 830EB164: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EB168: 419A000C  beq cr6, 0x830eb174
	if ctx.cr[6].eq {
	pc = 0x830EB174; continue 'dispatch;
	}
	// 830EB16C: A10A0002  lhz r8, 2(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 830EB170: 48000008  b 0x830eb178
	pc = 0x830EB178; continue 'dispatch;
            }
            0x830EB174 => {
    //   block [0x830EB174..0x830EB178)
	// 830EB174: 811A0008  lwz r8, 8(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x830EB178; continue 'dispatch;
            }
            0x830EB178 => {
    //   block [0x830EB178..0x830EB190)
	// 830EB178: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EB17C: 419A0014  beq cr6, 0x830eb190
	if ctx.cr[6].eq {
	pc = 0x830EB190; continue 'dispatch;
	}
	// 830EB180: A14A0002  lhz r10, 2(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 830EB184: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 830EB188: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 830EB18C: 4800001C  b 0x830eb1a8
	pc = 0x830EB1A8; continue 'dispatch;
            }
            0x830EB190 => {
    //   block [0x830EB190..0x830EB1A8)
	// 830EB190: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB194: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB198: 3AAA0001  addi r21, r10, 1
	ctx.r[21].s64 = ctx.r[10].s64 + 1;
	// 830EB19C: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EB1A0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830EB1A4: 92BF0004  stw r21, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[21].u32 ) };
	pc = 0x830EB1A8; continue 'dispatch;
            }
            0x830EB1A8 => {
    //   block [0x830EB1A8..0x830EB1C8)
	// 830EB1A8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB1AC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830EB1B0: A1290000  lhz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB1B4: B0870004  sth r4, 4(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[4].u16 ) };
	// 830EB1B8: B0670002  sth r3, 2(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(2 as u32), ctx.r[3].u16 ) };
	// 830EB1BC: B1270000  sth r9, 0(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 830EB1C0: 419A0008  beq cr6, 0x830eb1c8
	if ctx.cr[6].eq {
	pc = 0x830EB1C8; continue 'dispatch;
	}
	// 830EB1C4: B0BC0002  sth r5, 2(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(2 as u32), ctx.r[5].u16 ) };
	pc = 0x830EB1C8; continue 'dispatch;
            }
            0x830EB1C8 => {
    //   block [0x830EB1C8..0x830EB1FC)
	// 830EB1C8: 5509043E  clrlwi r9, r8, 0x10
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x0000FFFFu64;
	// 830EB1CC: A10B000E  lhz r8, 0xe(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(14 as u32) ) } as u64;
	// 830EB1D0: B0AA0004  sth r5, 4(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[5].u16 ) };
	// 830EB1D4: B10A0000  sth r8, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 830EB1D8: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB1DC: 7D1D4050  subf r8, r29, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[29].s64;
	// 830EB1E0: 7D081E70  srawi r8, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 830EB1E4: B10A0002  sth r8, 2(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(2 as u32), ctx.r[8].u16 ) };
	// 830EB1E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB1EC: B12A0002  sth r9, 2(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(2 as u32), ctx.r[9].u16 ) };
	// 830EB1F0: A14B0008  lhz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EB1F4: B1260004  sth r9, 4(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 830EB1F8: 480000A8  b 0x830eb2a0
	pc = 0x830EB2A0; continue 'dispatch;
            }
            0x830EB1FC => {
    //   block [0x830EB1FC..0x830EB21C)
	// 830EB1FC: A12A0006  lhz r9, 6(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 830EB200: 3929FFFE  addi r9, r9, -2
	ctx.r[9].s64 = ctx.r[9].s64 + -2;
	// 830EB204: 7D290034  cntlzw r9, r9
	ctx.r[9].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 830EB208: 5529DFFE  rlwinm r9, r9, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 830EB20C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EB210: 419A000C  beq cr6, 0x830eb21c
	if ctx.cr[6].eq {
	pc = 0x830EB21C; continue 'dispatch;
	}
	// 830EB214: A10A0002  lhz r8, 2(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 830EB218: 48000008  b 0x830eb220
	pc = 0x830EB220; continue 'dispatch;
            }
            0x830EB21C => {
    //   block [0x830EB21C..0x830EB220)
	// 830EB21C: 811A0008  lwz r8, 8(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x830EB220; continue 'dispatch;
            }
            0x830EB220 => {
    //   block [0x830EB220..0x830EB238)
	// 830EB220: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EB224: 419A0014  beq cr6, 0x830eb238
	if ctx.cr[6].eq {
	pc = 0x830EB238; continue 'dispatch;
	}
	// 830EB228: A14A0002  lhz r10, 2(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 830EB22C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 830EB230: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 830EB234: 4800001C  b 0x830eb250
	pc = 0x830EB250; continue 'dispatch;
            }
            0x830EB238 => {
    //   block [0x830EB238..0x830EB250)
	// 830EB238: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB23C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB240: 3AAA0001  addi r21, r10, 1
	ctx.r[21].s64 = ctx.r[10].s64 + 1;
	// 830EB244: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EB248: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830EB24C: 92BF0004  stw r21, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[21].u32 ) };
	pc = 0x830EB250; continue 'dispatch;
            }
            0x830EB250 => {
    //   block [0x830EB250..0x830EB270)
	// 830EB250: 5509043E  clrlwi r9, r8, 0x10
	ctx.r[9].u64 = ctx.r[8].u32 as u64 & 0x0000FFFFu64;
	// 830EB254: A10B000E  lhz r8, 0xe(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(14 as u32) ) } as u64;
	// 830EB258: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830EB25C: B0670002  sth r3, 2(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(2 as u32), ctx.r[3].u16 ) };
	// 830EB260: B1070000  sth r8, 0(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 830EB264: B1270004  sth r9, 4(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[9].u16 ) };
	// 830EB268: 419A0008  beq cr6, 0x830eb270
	if ctx.cr[6].eq {
	pc = 0x830EB270; continue 'dispatch;
	}
	// 830EB26C: B0BC0002  sth r5, 2(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(2 as u32), ctx.r[5].u16 ) };
	pc = 0x830EB270; continue 'dispatch;
            }
            0x830EB270 => {
    //   block [0x830EB270..0x830EB2A0)
	// 830EB270: A10B000C  lhz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EB274: B08A0004  sth r4, 4(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u16 ) };
	// 830EB278: B10A0000  sth r8, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u16 ) };
	// 830EB27C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB280: 7D1D4050  subf r8, r29, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[29].s64;
	// 830EB284: 7D081E70  srawi r8, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 830EB288: B10A0002  sth r8, 2(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(2 as u32), ctx.r[8].u16 ) };
	// 830EB28C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB290: B12A0002  sth r9, 2(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(2 as u32), ctx.r[9].u16 ) };
	// 830EB294: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB298: A14A0000  lhz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB29C: B0A60004  sth r5, 4(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[5].u16 ) };
	pc = 0x830EB2A0; continue 'dispatch;
            }
            0x830EB2A0 => {
    //   block [0x830EB2A0..0x830EB2C0)
	// 830EB2A0: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 830EB2A4: B1460000  sth r10, 0(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 830EB2A8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 830EB2AC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830EB2B0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 830EB2B4: 3BDEFFF0  addi r30, r30, -0x10
	ctx.r[30].s64 = ctx.r[30].s64 + -16;
	// 830EB2B8: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 830EB2BC: 4098FE48  bge cr6, 0x830eb104
	if !ctx.cr[6].lt {
	pc = 0x830EB104; continue 'dispatch;
	}
	pc = 0x830EB2C0; continue 'dispatch;
            }
            0x830EB2C0 => {
    //   block [0x830EB2C0..0x830EB2F8)
	// 830EB2C0: 570B1838  slwi r11, r24, 3
	ctx.r[11].u32 = ctx.r[24].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EB2C4: B31C0002  sth r24, 2(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(2 as u32), ctx.r[24].u16 ) };
	// 830EB2C8: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830EB2CC: B06B0002  sth r3, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[3].u16 ) };
	// 830EB2D0: 7C77B02E  lwzx r3, r23, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 830EB2D4: 8081006C  lwz r4, 0x6c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 830EB2D8: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830EB2DC: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 830EB2E0: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830EB2E4: 409A0014  bne cr6, 0x830eb2f8
	if !ctx.cr[6].eq {
	pc = 0x830EB2F8; continue 'dispatch;
	}
	// 830EB2E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB2EC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EB2F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EB2F4: 4E800421  bctrl
	ctx.lr = 0x830EB2F8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830EB2F8 => {
    //   block [0x830EB2F8..0x830EB31C)
	// 830EB2F8: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830EB2FC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EB300: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EB304: 409A0018  bne cr6, 0x830eb31c
	if !ctx.cr[6].eq {
	pc = 0x830EB31C; continue 'dispatch;
	}
	// 830EB308: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830EB30C: 7C77B02E  lwzx r3, r23, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 830EB310: 5565087C  rlwinm r5, r11, 1, 1, 0x1e
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 830EB314: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830EB318: 4BC69FB1  bl 0x82d552c8
	ctx.lr = 0x830EB31C;
	sub_82D552C8(ctx, base);
	pc = 0x830EB31C; continue 'dispatch;
            }
            0x830EB31C => {
    //   block [0x830EB31C..0x830EB344)
	// 830EB31C: 7C77B02E  lwzx r3, r23, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 830EB320: 8081007C  lwz r4, 0x7c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 830EB324: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 830EB328: 90830020  stw r4, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 830EB32C: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830EB330: 409A0014  bne cr6, 0x830eb344
	if !ctx.cr[6].eq {
	pc = 0x830EB344; continue 'dispatch;
	}
	// 830EB334: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB338: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EB33C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EB340: 4E800421  bctrl
	ctx.lr = 0x830EB344;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830EB344 => {
    //   block [0x830EB344..0x830EB368)
	// 830EB344: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830EB348: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EB34C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EB350: 409A0018  bne cr6, 0x830eb368
	if !ctx.cr[6].eq {
	pc = 0x830EB368; continue 'dispatch;
	}
	// 830EB354: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830EB358: 7C77B02E  lwzx r3, r23, r22
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 830EB35C: 5565087C  rlwinm r5, r11, 1, 1, 0x1e
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	// 830EB360: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830EB364: 4BC69F65  bl 0x82d552c8
	ctx.lr = 0x830EB368;
	sub_82D552C8(ctx, base);
	pc = 0x830EB368; continue 'dispatch;
            }
            0x830EB368 => {
    //   block [0x830EB368..0x830EB370)
	// 830EB368: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830EB36C: 4BBBE0D0  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EB370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EB370 size=344
    let mut pc: u32 = 0x830EB370;
    'dispatch: loop {
        match pc {
            0x830EB370 => {
    //   block [0x830EB370..0x830EB3D0)
	// 830EB370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EB374: 4BBBE06D  bl 0x82ca93e0
	ctx.lr = 0x830EB378;
	sub_82CA93D0(ctx, base);
	// 830EB378: DBC1FF78  stfd f30, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 830EB37C: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 830EB380: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EB384: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 830EB388: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 830EB38C: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 830EB390: 7CF23B78  mr r18, r7
	ctx.r[18].u64 = ctx.r[7].u64;
	// 830EB394: 7D144378  mr r20, r8
	ctx.r[20].u64 = ctx.r[8].u64;
	// 830EB398: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EB39C: 7D334B78  mr r19, r9
	ctx.r[19].u64 = ctx.r[9].u64;
	// 830EB3A0: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 830EB3A4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830EB3A8: 419A0110  beq cr6, 0x830eb4b8
	if ctx.cr[6].eq {
	pc = 0x830EB4B8; continue 'dispatch;
	}
	// 830EB3AC: A1720002  lhz r11, 2(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[18].u32.wrapping_add(2 as u32) ) } as u64;
	// 830EB3B0: 54D8043E  clrlwi r24, r6, 0x10
	ctx.r[24].u64 = ctx.r[6].u32 as u64 & 0x0000FFFFu64;
	// 830EB3B4: 83790004  lwz r27, 4(r25)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB3B8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830EB3BC: 82F90000  lwz r23, 0(r25)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB3C0: 7F4BDA14  add r26, r11, r27
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830EB3C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830EB3C8: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 830EB3CC: C3CB0A4C  lfs f30, 0xa4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2636 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x830EB3D0; continue 'dispatch;
            }
            0x830EB3D0 => {
    //   block [0x830EB3D0..0x830EB3EC)
	// 830EB3D0: A17F0000  lhz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB3D4: 556A203E  rotlwi r10, r11, 4
	ctx.r[10].u64 = ((ctx.r[11].u32).rotate_left(4)) as u64;
	// 830EB3D8: 7F0BC040  cmplw cr6, r11, r24
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[24].u32, &mut ctx.xer);
	// 830EB3DC: 7C8ABA14  add r4, r10, r23
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[23].u64;
	// 830EB3E0: 409A000C  bne cr6, 0x830eb3ec
	if !ctx.cr[6].eq {
	pc = 0x830EB3EC; continue 'dispatch;
	}
	// 830EB3E4: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	// 830EB3E8: 4800001C  b 0x830eb404
	pc = 0x830EB404; continue 'dispatch;
            }
            0x830EB3EC => {
    //   block [0x830EB3EC..0x830EB404)
	// 830EB3EC: 7E679B78  mr r7, r19
	ctx.r[7].u64 = ctx.r[19].u64;
	// 830EB3F0: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 830EB3F4: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 830EB3F8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830EB3FC: 4BFFB05D  bl 0x830e6458
	ctx.lr = 0x830EB400;
	sub_830E6458(ctx, base);
	// 830EB400: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	pc = 0x830EB404; continue 'dispatch;
            }
            0x830EB404 => {
    //   block [0x830EB404..0x830EB42C)
	// 830EB404: 839D0004  lwz r28, 4(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB408: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EB40C: 3BDC0001  addi r30, r28, 1
	ctx.r[30].s64 = ctx.r[28].s64 + 1;
	// 830EB410: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830EB414: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830EB418: 40980024  bge cr6, 0x830eb43c
	if !ctx.cr[6].lt {
	pc = 0x830EB43C; continue 'dispatch;
	}
	// 830EB41C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EB420: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EB424: 41980008  blt cr6, 0x830eb42c
	if ctx.cr[6].lt {
	pc = 0x830EB42C; continue 'dispatch;
	}
	// 830EB428: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x830EB42C; continue 'dispatch;
            }
            0x830EB42C => {
    //   block [0x830EB42C..0x830EB43C)
	// 830EB42C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 830EB430: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830EB434: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EB438: 4BC6BAD9  bl 0x82d56f10
	ctx.lr = 0x830EB43C;
	sub_82D56F10(ctx, base);
	pc = 0x830EB43C; continue 'dispatch;
            }
            0x830EB43C => {
    //   block [0x830EB43C..0x830EB498)
	// 830EB43C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB440: 578B1838  slwi r11, r28, 3
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EB444: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830EB448: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830EB44C: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 830EB450: D3EB0004  stfs f31, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EB454: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB458: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830EB45C: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830EB460: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 830EB464: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830EB468: 7FEBDA14  add r31, r11, r27
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830EB46C: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 830EB470: 409AFF60  bne cr6, 0x830eb3d0
	if !ctx.cr[6].eq {
	pc = 0x830EB3D0; continue 'dispatch;
	}
	// 830EB474: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB478: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830EB47C: 4099001C  ble cr6, 0x830eb498
	if !ctx.cr[6].gt {
	pc = 0x830EB498; continue 'dispatch;
	}
	// 830EB480: 3D40830E  lis r10, -0x7cf2
	ctx.r[10].s64 = -2096234496;
	// 830EB484: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB488: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 830EB48C: 38CA6A88  addi r6, r10, 0x6a88
	ctx.r[6].s64 = ctx.r[10].s64 + 27272;
	// 830EB490: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EB494: 480014F5  bl 0x830ec988
	ctx.lr = 0x830EB498;
	sub_830EC988(ctx, base);
	pc = 0x830EB498; continue 'dispatch;
            }
            0x830EB498 => {
    //   block [0x830EB498..0x830EB4B8)
	// 830EB498: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 830EB49C: 7E689B78  mr r8, r19
	ctx.r[8].u64 = ctx.r[19].u64;
	// 830EB4A0: 7E87A378  mr r7, r20
	ctx.r[7].u64 = ctx.r[20].u64;
	// 830EB4A4: 7E469378  mr r6, r18
	ctx.r[6].u64 = ctx.r[18].u64;
	// 830EB4A8: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 830EB4AC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830EB4B0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830EB4B4: 4BFFEF85  bl 0x830ea438
	ctx.lr = 0x830EB4B8;
	sub_830EA438(ctx, base);
	pc = 0x830EB4B8; continue 'dispatch;
            }
            0x830EB4B8 => {
    //   block [0x830EB4B8..0x830EB4C8)
	// 830EB4B8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830EB4BC: CBC1FF78  lfd f30, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 830EB4C0: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 830EB4C4: 4BBBDF6C  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EB4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EB4C8 size=436
    let mut pc: u32 = 0x830EB4C8;
    'dispatch: loop {
        match pc {
            0x830EB4C8 => {
    //   block [0x830EB4C8..0x830EB500)
	// 830EB4C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EB4CC: 4BBBDF1D  bl 0x82ca93e8
	ctx.lr = 0x830EB4D0;
	sub_82CA93D0(ctx, base);
	// 830EB4D0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EB4D4: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 830EB4D8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830EB4DC: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 830EB4E0: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 830EB4E4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 830EB4E8: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB4EC: 7F54D378  mr r20, r26
	ctx.r[20].u64 = ctx.r[26].u64;
	// 830EB4F0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EB4F4: 4099017C  ble cr6, 0x830eb670
	if !ctx.cr[6].gt {
	pc = 0x830EB670; continue 'dispatch;
	}
	// 830EB4F8: 7F55D378  mr r21, r26
	ctx.r[21].u64 = ctx.r[26].u64;
	// 830EB4FC: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	pc = 0x830EB500; continue 'dispatch;
            }
            0x830EB500 => {
    //   block [0x830EB500..0x830EB52C)
	// 830EB500: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EB504: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 830EB508: 81560000  lwz r10, 0(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB50C: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830EB510: 7F755214  add r27, r21, r10
	ctx.r[27].u64 = ctx.r[21].u64 + ctx.r[10].u64;
	// 830EB514: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830EB518: 40980020  bge cr6, 0x830eb538
	if !ctx.cr[6].lt {
	pc = 0x830EB538; continue 'dispatch;
	}
	// 830EB51C: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830EB520: 2F040001  cmpwi cr6, r4, 1
	ctx.cr[6].compare_i32(ctx.r[4].s32, 1, &mut ctx.xer);
	// 830EB524: 41990008  bgt cr6, 0x830eb52c
	if ctx.cr[6].gt {
	pc = 0x830EB52C; continue 'dispatch;
	}
	// 830EB528: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	pc = 0x830EB52C; continue 'dispatch;
            }
            0x830EB52C => {
    //   block [0x830EB52C..0x830EB538)
	// 830EB52C: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830EB530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EB534: 4BC6B9DD  bl 0x82d56f10
	ctx.lr = 0x830EB538;
	sub_82D56F10(ctx, base);
	pc = 0x830EB538; continue 'dispatch;
            }
            0x830EB538 => {
    //   block [0x830EB538..0x830EB55C)
	// 830EB538: 933F0004  stw r25, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 830EB53C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB540: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB544: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830EB548: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB54C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830EB550: 83DB0008  lwz r30, 8(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EB554: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830EB558: 419A0104  beq cr6, 0x830eb65c
	if ctx.cr[6].eq {
	pc = 0x830EB65C; continue 'dispatch;
	}
	pc = 0x830EB55C; continue 'dispatch;
            }
            0x830EB55C => {
    //   block [0x830EB55C..0x830EB590)
	// 830EB55C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB560: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB564: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830EB568: 409A0028  bne cr6, 0x830eb590
	if !ctx.cr[6].eq {
	pc = 0x830EB590; continue 'dispatch;
	}
	// 830EB56C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB570: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB574: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830EB578: 409A0018  bne cr6, 0x830eb590
	if !ctx.cr[6].eq {
	pc = 0x830EB590; continue 'dispatch;
	}
	// 830EB57C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EB580: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EB584: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830EB588: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 830EB58C: 419A0008  beq cr6, 0x830eb594
	if ctx.cr[6].eq {
	pc = 0x830EB594; continue 'dispatch;
	}
	pc = 0x830EB590; continue 'dispatch;
            }
            0x830EB590 => {
    //   block [0x830EB590..0x830EB594)
	// 830EB590: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x830EB594; continue 'dispatch;
            }
            0x830EB594 => {
    //   block [0x830EB594..0x830EB5F8)
	// 830EB594: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830EB598: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EB59C: 419A005C  beq cr6, 0x830eb5f8
	if ctx.cr[6].eq {
	pc = 0x830EB5F8; continue 'dispatch;
	}
	// 830EB5A0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830EB5A4: 9B210050  stb r25, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u8 ) };
	// 830EB5A8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 830EB5AC: 80B70004  lwz r5, 4(r23)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB5B0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 830EB5B4: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 830EB5B8: 88CB0000  lbz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB5BC: 4BFFF2D5  bl 0x830ea890
	ctx.lr = 0x830EB5C0;
	sub_830EA890(ctx, base);
	// 830EB5C0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 830EB5C4: 9B410050  stb r26, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u8 ) };
	// 830EB5C8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 830EB5CC: 80B80004  lwz r5, 4(r24)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB5D0: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 830EB5D4: 38610052  addi r3, r1, 0x52
	ctx.r[3].s64 = ctx.r[1].s64 + 82;
	// 830EB5D8: 88CB0000  lbz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB5DC: 4BFFF2B5  bl 0x830ea890
	ctx.lr = 0x830EB5E0;
	sub_830EA890(ctx, base);
	// 830EB5E0: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 830EB5E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EB5E8: 419A0010  beq cr6, 0x830eb5f8
	if ctx.cr[6].eq {
	pc = 0x830EB5F8; continue 'dispatch;
	}
	// 830EB5EC: 89610052  lbz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 830EB5F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EB5F4: 409A0080  bne cr6, 0x830eb674
	if !ctx.cr[6].eq {
	pc = 0x830EB674; continue 'dispatch;
	}
	pc = 0x830EB5F8; continue 'dispatch;
            }
            0x830EB5F8 => {
    //   block [0x830EB5F8..0x830EB620)
	// 830EB5F8: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB5FC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EB600: 3BBC0001  addi r29, r28, 1
	ctx.r[29].s64 = ctx.r[28].s64 + 1;
	// 830EB604: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830EB608: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830EB60C: 40980024  bge cr6, 0x830eb630
	if !ctx.cr[6].lt {
	pc = 0x830EB630; continue 'dispatch;
	}
	// 830EB610: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EB614: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EB618: 41980008  blt cr6, 0x830eb620
	if ctx.cr[6].lt {
	pc = 0x830EB620; continue 'dispatch;
	}
	// 830EB61C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x830EB620; continue 'dispatch;
            }
            0x830EB620 => {
    //   block [0x830EB620..0x830EB630)
	// 830EB620: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 830EB624: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 830EB628: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EB62C: 4BC6B8E5  bl 0x82d56f10
	ctx.lr = 0x830EB630;
	sub_82D56F10(ctx, base);
	pc = 0x830EB630; continue 'dispatch;
            }
            0x830EB630 => {
    //   block [0x830EB630..0x830EB65C)
	// 830EB630: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB634: 578B2036  slwi r11, r28, 4
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EB638: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830EB63C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830EB640: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EB644: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830EB648: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB64C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830EB650: 83DE0008  lwz r30, 8(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EB654: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830EB658: 409AFF04  bne cr6, 0x830eb55c
	if !ctx.cr[6].eq {
	pc = 0x830EB55C; continue 'dispatch;
	}
	pc = 0x830EB65C; continue 'dispatch;
            }
            0x830EB65C => {
    //   block [0x830EB65C..0x830EB670)
	// 830EB65C: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EB660: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 830EB664: 3AB50014  addi r21, r21, 0x14
	ctx.r[21].s64 = ctx.r[21].s64 + 20;
	// 830EB668: 7F145800  cmpw cr6, r20, r11
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EB66C: 4198FE94  blt cr6, 0x830eb500
	if ctx.cr[6].lt {
	pc = 0x830EB500; continue 'dispatch;
	}
	pc = 0x830EB670; continue 'dispatch;
            }
            0x830EB670 => {
    //   block [0x830EB670..0x830EB674)
	// 830EB670: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	pc = 0x830EB674; continue 'dispatch;
            }
            0x830EB674 => {
    //   block [0x830EB674..0x830EB67C)
	// 830EB674: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830EB678: 4BBBDDC0  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EB680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EB680 size=2048
    let mut pc: u32 = 0x830EB680;
    'dispatch: loop {
        match pc {
            0x830EB680 => {
    //   block [0x830EB680..0x830EBE80)
	// 830EB680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EB684: 4BBBDD4D  bl 0x82ca93d0
	ctx.lr = 0x830EB688;
	sub_82CA93D0(ctx, base);
	// 830EB688: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 830EB68C: 4BBC264D  bl 0x82cadcd8
	ctx.lr = 0x830EB690;
	sub_82CADCA0(ctx, base);
	// 830EB690: 3980FF20  li r12, -0xe0
	ctx.r[12].s64 = -224;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EBE80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EBE80 size=1296
    let mut pc: u32 = 0x830EBE80;
    'dispatch: loop {
        match pc {
            0x830EBE80 => {
    //   block [0x830EBE80..0x830EBEF4)
	// 830EBE80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EBE84: 4BBBD56D  bl 0x82ca93f0
	ctx.lr = 0x830EBE88;
	sub_82CA93D0(ctx, base);
	// 830EBE88: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 830EBE8C: 9421F700  stwu r1, -0x900(r1)
	ea = ctx.r[1].u32.wrapping_add(-2304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EBE90: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 830EBE94: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 830EBE98: 3B170001  addi r24, r23, 1
	ctx.r[24].s64 = ctx.r[23].s64 + 1;
	// 830EBE9C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830EBEA0: 7D7FC050  subf r11, r31, r24
	ctx.r[11].s64 = ctx.r[24].s64 - ctx.r[31].s64;
	// 830EBEA4: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 830EBEA8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 830EBEAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830EBEB0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830EBEB4: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 830EBEB8: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	// 830EBEBC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 830EBEC0: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830EBEC4: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 830EBEC8: 4198009C  blt cr6, 0x830ebf64
	if ctx.cr[6].lt {
	pc = 0x830EBF64; continue 'dispatch;
	}
	// 830EBECC: 7D3FC050  subf r9, r31, r24
	ctx.r[9].s64 = ctx.r[24].s64 - ctx.r[31].s64;
	// 830EBED0: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EBED4: 57EB2036  slwi r11, r31, 4
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EBED8: 3929FFFC  addi r9, r9, -4
	ctx.r[9].s64 = ctx.r[9].s64 + -4;
	// 830EBEDC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830EBEE0: 552AF0BE  srwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EBEE4: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 830EBEE8: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 830EBEEC: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EBEF0: 7CEAFA14  add r7, r10, r31
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	pc = 0x830EBEF4; continue 'dispatch;
            }
            0x830EBEF4 => {
    //   block [0x830EBEF4..0x830EBF08)
	// 830EBEF4: C00BFFF0  lfs f0, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EBEF8: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 830EBEFC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830EBF00: 419A0008  beq cr6, 0x830ebf08
	if ctx.cr[6].eq {
	pc = 0x830EBF08; continue 'dispatch;
	}
	// 830EBF04: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x830EBF08; continue 'dispatch;
            }
            0x830EBF08 => {
    //   block [0x830EBF08..0x830EBF20)
	// 830EBF08: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EBF0C: 7D2ADA14  add r9, r10, r27
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 830EBF10: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830EBF14: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 830EBF18: 419A0008  beq cr6, 0x830ebf20
	if ctx.cr[6].eq {
	pc = 0x830EBF20; continue 'dispatch;
	}
	// 830EBF1C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x830EBF20; continue 'dispatch;
            }
            0x830EBF20 => {
    //   block [0x830EBF20..0x830EBF38)
	// 830EBF20: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EBF24: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830EBF28: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830EBF2C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 830EBF30: 419A0008  beq cr6, 0x830ebf38
	if ctx.cr[6].eq {
	pc = 0x830EBF38; continue 'dispatch;
	}
	// 830EBF34: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x830EBF38; continue 'dispatch;
            }
            0x830EBF38 => {
    //   block [0x830EBF38..0x830EBF50)
	// 830EBF38: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EBF3C: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830EBF40: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830EBF44: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 830EBF48: 419A0008  beq cr6, 0x830ebf50
	if ctx.cr[6].eq {
	pc = 0x830EBF50; continue 'dispatch;
	}
	// 830EBF4C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x830EBF50; continue 'dispatch;
            }
            0x830EBF50 => {
    //   block [0x830EBF50..0x830EBF64)
	// 830EBF50: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 830EBF54: 7F6A4A14  add r27, r10, r9
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830EBF58: 396B0040  addi r11, r11, 0x40
	ctx.r[11].s64 = ctx.r[11].s64 + 64;
	// 830EBF5C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 830EBF60: 409AFF94  bne cr6, 0x830ebef4
	if !ctx.cr[6].eq {
	pc = 0x830EBEF4; continue 'dispatch;
	}
	pc = 0x830EBF64; continue 'dispatch;
            }
            0x830EBF64 => {
    //   block [0x830EBF64..0x830EBF80)
	// 830EBF64: 7F07C000  cmpw cr6, r7, r24
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[24].s32, &mut ctx.xer);
	// 830EBF68: 40980040  bge cr6, 0x830ebfa8
	if !ctx.cr[6].lt {
	pc = 0x830EBFA8; continue 'dispatch;
	}
	// 830EBF6C: 81390000  lwz r9, 0(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EBF70: 54EA2036  slwi r10, r7, 4
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EBF74: 7D67C050  subf r11, r7, r24
	ctx.r[11].s64 = ctx.r[24].s64 - ctx.r[7].s64;
	// 830EBF78: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830EBF7C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	pc = 0x830EBF80; continue 'dispatch;
            }
            0x830EBF80 => {
    //   block [0x830EBF80..0x830EBF94)
	// 830EBF80: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EBF84: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 830EBF88: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830EBF8C: 419A0008  beq cr6, 0x830ebf94
	if ctx.cr[6].eq {
	pc = 0x830EBF94; continue 'dispatch;
	}
	// 830EBF90: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	pc = 0x830EBF94; continue 'dispatch;
            }
            0x830EBF94 => {
    //   block [0x830EBF94..0x830EBFA8)
	// 830EBF94: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 830EBF98: 7F69DA14  add r27, r9, r27
	ctx.r[27].u64 = ctx.r[9].u64 + ctx.r[27].u64;
	// 830EBF9C: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 830EBFA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EBFA4: 409AFFDC  bne cr6, 0x830ebf80
	if !ctx.cr[6].eq {
	pc = 0x830EBF80; continue 'dispatch;
	}
	pc = 0x830EBFA8; continue 'dispatch;
            }
            0x830EBFA8 => {
    //   block [0x830EBFA8..0x830EBFE8)
	// 830EBFA8: 2F1B0003  cmpwi cr6, r27, 3
	ctx.cr[6].compare_i32(ctx.r[27].s32, 3, &mut ctx.xer);
	// 830EBFAC: 409902DC  ble cr6, 0x830ec288
	if !ctx.cr[6].gt {
	pc = 0x830EC288; continue 'dispatch;
	}
	// 830EBFB0: 7D7FBA14  add r11, r31, r23
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[23].u64;
	// 830EBFB4: 38610490  addi r3, r1, 0x490
	ctx.r[3].s64 = ctx.r[1].s64 + 1168;
	// 830EBFB8: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 830EBFBC: 7FCB0194  addze r30, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[30].s64 = tmp.s64;
	// 830EBFC0: 48001119  bl 0x830ed0d8
	ctx.lr = 0x830EBFC4;
	sub_830ED0D8(ctx, base);
	// 830EBFC4: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EBFC8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830EBFCC: 91610490  stw r11, 0x490(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1168 as u32), ctx.r[11].u32 ) };
	// 830EBFD0: 48001109  bl 0x830ed0d8
	ctx.lr = 0x830EBFD4;
	sub_830ED0D8(ctx, base);
	// 830EBFD4: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EBFD8: 3B7E0001  addi r27, r30, 1
	ctx.r[27].s64 = ctx.r[30].s64 + 1;
	// 830EBFDC: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 830EBFE0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 830EBFE4: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	pc = 0x830EBFE8; continue 'dispatch;
            }
            0x830EBFE8 => {
    //   block [0x830EBFE8..0x830EBFF4)
	// 830EBFE8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830EBFEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EBFF0: 419A0044  beq cr6, 0x830ec034
	if ctx.cr[6].eq {
	pc = 0x830EC034; continue 'dispatch;
	}
	pc = 0x830EBFF4; continue 'dispatch;
            }
            0x830EBFF4 => {
    //   block [0x830EBFF4..0x830EC034)
	// 830EBFF4: 38E10490  addi r7, r1, 0x490
	ctx.r[7].s64 = ctx.r[1].s64 + 1168;
	// 830EBFF8: 93A10498  stw r29, 0x498(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1176 as u32), ctx.r[29].u32 ) };
	// 830EBFFC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 830EC000: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830EC004: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830EC008: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830EC00C: 4BFFFE75  bl 0x830ebe80
	ctx.lr = 0x830EC010;
	sub_830EBE80(ctx, base);
	// 830EC010: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 830EC014: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 830EC018: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830EC01C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EC020: 38610490  addi r3, r1, 0x490
	ctx.r[3].s64 = ctx.r[1].s64 + 1168;
	// 830EC024: 4BFFB63D  bl 0x830e7660
	ctx.lr = 0x830EC028;
	sub_830E7660(ctx, base);
	// 830EC028: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EC02C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EC030: 409AFFC4  bne cr6, 0x830ebff4
	if !ctx.cr[6].eq {
	pc = 0x830EBFF4; continue 'dispatch;
	}
	pc = 0x830EC034; continue 'dispatch;
            }
            0x830EC034 => {
    //   block [0x830EC034..0x830EC038)
	// 830EC034: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	pc = 0x830EC038; continue 'dispatch;
            }
            0x830EC038 => {
    //   block [0x830EC038..0x830EC0CC)
	// 830EC038: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 830EC03C: 93A10088  stw r29, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[29].u32 ) };
	// 830EC040: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 830EC044: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 830EC048: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830EC04C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830EC050: 4BFFFE31  bl 0x830ebe80
	ctx.lr = 0x830EC054;
	sub_830EBE80(ctx, base);
	// 830EC054: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 830EC058: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 830EC05C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 830EC060: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830EC064: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830EC068: 4BFFB5F9  bl 0x830e7660
	ctx.lr = 0x830EC06C;
	sub_830E7660(ctx, base);
	// 830EC06C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EC070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EC074: 409AFFC4  bne cr6, 0x830ec038
	if !ctx.cr[6].eq {
	pc = 0x830EC038; continue 'dispatch;
	}
	// 830EC078: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 830EC07C: 9B810050  stb r28, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u8 ) };
	// 830EC080: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 830EC084: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 830EC088: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EC08C: 38610490  addi r3, r1, 0x490
	ctx.r[3].s64 = ctx.r[1].s64 + 1168;
	// 830EC090: 4BFFB5D1  bl 0x830e7660
	ctx.lr = 0x830EC094;
	sub_830E7660(ctx, base);
	// 830EC094: 38E10051  addi r7, r1, 0x51
	ctx.r[7].s64 = ctx.r[1].s64 + 81;
	// 830EC098: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 830EC09C: 9B810051  stb r28, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[28].u8 ) };
	// 830EC0A0: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 830EC0A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EC0A8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 830EC0AC: 4BFFB5B5  bl 0x830e7660
	ctx.lr = 0x830EC0B0;
	sub_830E7660(ctx, base);
	// 830EC0B0: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EC0B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EC0B8: 409A0014  bne cr6, 0x830ec0cc
	if !ctx.cr[6].eq {
	pc = 0x830EC0CC; continue 'dispatch;
	}
	// 830EC0BC: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 830EC0C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EC0C4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 830EC0C8: 419A0008  beq cr6, 0x830ec0d0
	if ctx.cr[6].eq {
	pc = 0x830EC0D0; continue 'dispatch;
	}
	pc = 0x830EC0CC; continue 'dispatch;
            }
            0x830EC0CC => {
    //   block [0x830EC0CC..0x830EC0D0)
	// 830EC0CC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x830EC0D0; continue 'dispatch;
            }
            0x830EC0D0 => {
    //   block [0x830EC0D0..0x830EC100)
	// 830EC0D0: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 830EC0D4: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 830EC0D8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EC0DC: 409AFF0C  bne cr6, 0x830ebfe8
	if !ctx.cr[6].eq {
	pc = 0x830EBFE8; continue 'dispatch;
	}
	// 830EC0E0: 81610498  lwz r11, 0x498(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1176 as u32) ) } as u64;
	// 830EC0E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EC0E8: 409A0094  bne cr6, 0x830ec17c
	if !ctx.cr[6].eq {
	pc = 0x830EC17C; continue 'dispatch;
	}
	// 830EC0EC: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830EC0F0: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 830EC0F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EC0F8: 40990130  ble cr6, 0x830ec228
	if !ctx.cr[6].gt {
	pc = 0x830EC228; continue 'dispatch;
	}
	// 830EC0FC: 3BF60004  addi r31, r22, 4
	ctx.r[31].s64 = ctx.r[22].s64 + 4;
	pc = 0x830EC100; continue 'dispatch;
            }
            0x830EC100 => {
    //   block [0x830EC100..0x830EC128)
	// 830EC100: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 830EC104: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EC108: 7FDD5A14  add r30, r29, r11
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 830EC10C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC110: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 830EC114: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830EC118: 409A0010  bne cr6, 0x830ec128
	if !ctx.cr[6].eq {
	pc = 0x830EC128; continue 'dispatch;
	}
	// 830EC11C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 830EC120: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EC124: 4BC6AE75  bl 0x82d56f98
	ctx.lr = 0x830EC128;
	sub_82D56F98(ctx, base);
	pc = 0x830EC128; continue 'dispatch;
            }
            0x830EC128 => {
    //   block [0x830EC128..0x830EC17C)
	// 830EC128: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC12C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830EC130: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC134: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 830EC138: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EC13C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830EC140: A15E0000  lhz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC144: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 830EC148: A15E0002  lhz r10, 2(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 830EC14C: B14B0002  sth r10, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[10].u16 ) };
	// 830EC150: A15E0004  lhz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC154: B14B0004  sth r10, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 830EC158: A15E0006  lhz r10, 6(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 830EC15C: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 830EC160: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830EC164: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EC168: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC16C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830EC170: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EC174: 4198FF8C  blt cr6, 0x830ec100
	if ctx.cr[6].lt {
	pc = 0x830EC100; continue 'dispatch;
	}
	// 830EC178: 480000B0  b 0x830ec228
	pc = 0x830EC228; continue 'dispatch;
            }
            0x830EC17C => {
    //   block [0x830EC17C..0x830EC198)
	// 830EC17C: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 830EC180: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EC184: 409A0090  bne cr6, 0x830ec214
	if !ctx.cr[6].eq {
	pc = 0x830EC214; continue 'dispatch;
	}
	// 830EC188: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 830EC18C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EC190: 40990098  ble cr6, 0x830ec228
	if !ctx.cr[6].gt {
	pc = 0x830EC228; continue 'dispatch;
	}
	// 830EC194: 3BF60004  addi r31, r22, 4
	ctx.r[31].s64 = ctx.r[22].s64 + 4;
	pc = 0x830EC198; continue 'dispatch;
            }
            0x830EC198 => {
    //   block [0x830EC198..0x830EC1C0)
	// 830EC198: 81610494  lwz r11, 0x494(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1172 as u32) ) } as u64;
	// 830EC19C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EC1A0: 7FDD5A14  add r30, r29, r11
	ctx.r[30].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 830EC1A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC1A8: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 830EC1AC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830EC1B0: 409A0010  bne cr6, 0x830ec1c0
	if !ctx.cr[6].eq {
	pc = 0x830EC1C0; continue 'dispatch;
	}
	// 830EC1B4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 830EC1B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EC1BC: 4BC6ADDD  bl 0x82d56f98
	ctx.lr = 0x830EC1C0;
	sub_82D56F98(ctx, base);
	pc = 0x830EC1C0; continue 'dispatch;
            }
            0x830EC1C0 => {
    //   block [0x830EC1C0..0x830EC214)
	// 830EC1C0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC1C4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830EC1C8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC1CC: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 830EC1D0: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EC1D4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830EC1D8: A15E0000  lhz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC1DC: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 830EC1E0: A15E0002  lhz r10, 2(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 830EC1E4: B14B0002  sth r10, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[10].u16 ) };
	// 830EC1E8: A15E0004  lhz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC1EC: B14B0004  sth r10, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u16 ) };
	// 830EC1F0: A15E0006  lhz r10, 6(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 830EC1F4: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 830EC1F8: 81610498  lwz r11, 0x498(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1176 as u32) ) } as u64;
	// 830EC1FC: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EC200: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC204: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830EC208: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EC20C: 4198FF8C  blt cr6, 0x830ec198
	if ctx.cr[6].lt {
	pc = 0x830EC198; continue 'dispatch;
	}
	// 830EC210: 48000018  b 0x830ec228
	pc = 0x830EC228; continue 'dispatch;
            }
            0x830EC214 => {
    //   block [0x830EC214..0x830EC228)
	// 830EC214: 7EC6B378  mr r6, r22
	ctx.r[6].u64 = ctx.r[22].u64;
	// 830EC218: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 830EC21C: 38810490  addi r4, r1, 0x490
	ctx.r[4].s64 = ctx.r[1].s64 + 1168;
	// 830EC220: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830EC224: 4BFFF45D  bl 0x830eb680
	ctx.lr = 0x830EC228;
	sub_830EB680(ctx, base);
	pc = 0x830EC228; continue 'dispatch;
            }
            0x830EC228 => {
    //   block [0x830EC228..0x830EC240)
	// 830EC228: 81760008  lwz r11, 8(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EC22C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EC230: 409A0010  bne cr6, 0x830ec240
	if !ctx.cr[6].eq {
	pc = 0x830EC240; continue 'dispatch;
	}
	// 830EC234: 38810494  addi r4, r1, 0x494
	ctx.r[4].s64 = ctx.r[1].s64 + 1172;
	// 830EC238: 38760004  addi r3, r22, 4
	ctx.r[3].s64 = ctx.r[22].s64 + 4;
	// 830EC23C: 4800089D  bl 0x830ecad8
	ctx.lr = 0x830EC240;
	sub_830ECAD8(ctx, base);
	pc = 0x830EC240; continue 'dispatch;
            }
            0x830EC240 => {
    //   block [0x830EC240..0x830EC26C)
	// 830EC240: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 830EC244: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EC248: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EC24C: 409A0020  bne cr6, 0x830ec26c
	if !ctx.cr[6].eq {
	pc = 0x830EC26C; continue 'dispatch;
	}
	// 830EC250: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC254: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830EC258: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830EC25C: 80810084  lwz r4, 0x84(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 830EC260: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830EC264: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830EC268: 4BC69061  bl 0x82d552c8
	ctx.lr = 0x830EC26C;
	sub_82D552C8(ctx, base);
	pc = 0x830EC26C; continue 'dispatch;
            }
            0x830EC26C => {
    //   block [0x830EC26C..0x830EC288)
	// 830EC26C: 8161049C  lwz r11, 0x49c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1180 as u32) ) } as u64;
	// 830EC270: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EC274: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EC278: 409A010C  bne cr6, 0x830ec384
	if !ctx.cr[6].eq {
	pc = 0x830EC384; continue 'dispatch;
	}
	// 830EC27C: 80810494  lwz r4, 0x494(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1172 as u32) ) } as u64;
	// 830EC280: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830EC284: 480000EC  b 0x830ec370
	pc = 0x830EC370; continue 'dispatch;
            }
            0x830EC288 => {
    //   block [0x830EC288..0x830EC2B8)
	// 830EC288: 3D208000  lis r9, -0x8000
	ctx.r[9].s64 = -2147483648;
	// 830EC28C: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC290: 3881006C  addi r4, r1, 0x6c
	ctx.r[4].s64 = ctx.r[1].s64 + 108;
	// 830EC294: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 830EC298: 61290003  ori r9, r9, 3
	ctx.r[9].u64 = ctx.r[9].u64 | 3;
	// 830EC29C: 7F1FC000  cmpw cr6, r31, r24
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[24].s32, &mut ctx.xer);
	// 830EC2A0: 91560000  stw r10, 0(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830EC2A4: 90810060  stw r4, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[4].u32 ) };
	// 830EC2A8: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 830EC2AC: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 830EC2B0: 40980068  bge cr6, 0x830ec318
	if !ctx.cr[6].lt {
	pc = 0x830EC318; continue 'dispatch;
	}
	// 830EC2B4: 57FE2036  slwi r30, r31, 4
	ctx.r[30].u32 = ctx.r[31].u32.wrapping_shl(4);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	pc = 0x830EC2B8; continue 'dispatch;
            }
            0x830EC2B8 => {
    //   block [0x830EC2B8..0x830EC2F0)
	// 830EC2B8: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC2BC: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 830EC2C0: C00A000C  lfs f0, 0xc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EC2C4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 830EC2C8: 409A0040  bne cr6, 0x830ec308
	if !ctx.cr[6].eq {
	pc = 0x830EC308; continue 'dispatch;
	}
	// 830EC2CC: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830EC2D0: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 830EC2D4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830EC2D8: 409A0018  bne cr6, 0x830ec2f0
	if !ctx.cr[6].eq {
	pc = 0x830EC2F0; continue 'dispatch;
	}
	// 830EC2DC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 830EC2E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EC2E4: 4BC6ACB5  bl 0x82d56f98
	ctx.lr = 0x830EC2E8;
	sub_82D56F98(ctx, base);
	// 830EC2E8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830EC2EC: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	pc = 0x830EC2F0; continue 'dispatch;
            }
            0x830EC2F0 => {
    //   block [0x830EC2F0..0x830EC308)
	// 830EC2F0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EC2F4: 7FEB212E  stwx r31, r11, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), ctx.r[31].u32) };
	// 830EC2F8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 830EC2FC: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830EC300: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830EC304: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	pc = 0x830EC308; continue 'dispatch;
            }
            0x830EC308 => {
    //   block [0x830EC308..0x830EC318)
	// 830EC308: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830EC30C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 830EC310: 7F1FC000  cmpw cr6, r31, r24
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[24].s32, &mut ctx.xer);
	// 830EC314: 4198FFA4  blt cr6, 0x830ec2b8
	if ctx.cr[6].lt {
	pc = 0x830EC2B8; continue 'dispatch;
	}
	pc = 0x830EC318; continue 'dispatch;
            }
            0x830EC318 => {
    //   block [0x830EC318..0x830EC344)
	// 830EC318: 2B1B0001  cmplwi cr6, r27, 1
	ctx.cr[6].compare_u32(ctx.r[27].u32, 1 as u32, &mut ctx.xer);
	// 830EC31C: 41980040  blt cr6, 0x830ec35c
	if ctx.cr[6].lt {
	pc = 0x830EC35C; continue 'dispatch;
	}
	// 830EC320: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 830EC324: 419A002C  beq cr6, 0x830ec350
	if ctx.cr[6].eq {
	pc = 0x830EC350; continue 'dispatch;
	}
	// 830EC328: 80A40004  lwz r5, 4(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC32C: 2B1B0003  cmplwi cr6, r27, 3
	ctx.cr[6].compare_u32(ctx.r[27].u32, 3 as u32, &mut ctx.xer);
	// 830EC330: 41980014  blt cr6, 0x830ec344
	if ctx.cr[6].lt {
	pc = 0x830EC344; continue 'dispatch;
	}
	// 830EC334: 80C40008  lwz r6, 8(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EC338: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC33C: 480009ED  bl 0x830ecd28
	ctx.lr = 0x830EC340;
	sub_830ECD28(ctx, base);
	// 830EC340: 48000018  b 0x830ec358
	pc = 0x830EC358; continue 'dispatch;
            }
            0x830EC344 => {
    //   block [0x830EC344..0x830EC350)
	// 830EC344: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC348: 48000911  bl 0x830ecc58
	ctx.lr = 0x830EC34C;
	sub_830ECC58(ctx, base);
	// 830EC34C: 4800000C  b 0x830ec358
	pc = 0x830EC358; continue 'dispatch;
            }
            0x830EC350 => {
    //   block [0x830EC350..0x830EC358)
	// 830EC350: 80840000  lwz r4, 0(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC354: 48000885  bl 0x830ecbd8
	ctx.lr = 0x830EC358;
	sub_830ECBD8(ctx, base);
	pc = 0x830EC358; continue 'dispatch;
            }
            0x830EC358 => {
    //   block [0x830EC358..0x830EC35C)
	// 830EC358: 80810060  lwz r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	pc = 0x830EC35C; continue 'dispatch;
            }
            0x830EC35C => {
    //   block [0x830EC35C..0x830EC370)
	// 830EC35C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830EC360: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EC364: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EC368: 409A001C  bne cr6, 0x830ec384
	if !ctx.cr[6].eq {
	pc = 0x830EC384; continue 'dispatch;
	}
	// 830EC36C: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	pc = 0x830EC370; continue 'dispatch;
            }
            0x830EC370 => {
    //   block [0x830EC370..0x830EC384)
	// 830EC370: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC374: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830EC378: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830EC37C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830EC380: 4BC68F49  bl 0x82d552c8
	ctx.lr = 0x830EC384;
	sub_82D552C8(ctx, base);
	pc = 0x830EC384; continue 'dispatch;
            }
            0x830EC384 => {
    //   block [0x830EC384..0x830EC390)
	// 830EC384: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 830EC388: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 830EC38C: 4BBBD0B4  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EC390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EC390 size=496
    let mut pc: u32 = 0x830EC390;
    'dispatch: loop {
        match pc {
            0x830EC390 => {
    //   block [0x830EC390..0x830EC3E4)
	// 830EC390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EC394: 4BBBD06D  bl 0x82ca9400
	ctx.lr = 0x830EC398;
	sub_82CA93D0(ctx, base);
	// 830EC398: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 830EC39C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EC3A0: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 830EC3A4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830EC3A8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830EC3AC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 830EC3B0: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830EC3B4: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 830EC3B8: 4099005C  ble cr6, 0x830ec414
	if !ctx.cr[6].gt {
	pc = 0x830EC414; continue 'dispatch;
	}
	// 830EC3BC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830EC3C0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830EC3C4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EC3C8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC3CC: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830EC3D0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830EC3D4: 409A0010  bne cr6, 0x830ec3e4
	if !ctx.cr[6].eq {
	pc = 0x830EC3E4; continue 'dispatch;
	}
	// 830EC3D8: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 830EC3DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EC3E0: 4BC6ABB9  bl 0x82d56f98
	ctx.lr = 0x830EC3E4;
	sub_82D56F98(ctx, base);
	pc = 0x830EC3E4; continue 'dispatch;
            }
            0x830EC3E4 => {
    //   block [0x830EC3E4..0x830EC414)
	// 830EC3E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC3E8: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 830EC3EC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC3F0: 556A2036  slwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EC3F4: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 830EC3F8: 7D6A4A14  add r11, r10, r9
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830EC3FC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830EC400: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x830EC414; continue 'dispatch;
            }
            0x830EC414 => {
    //   block [0x830EC414..0x830EC580)
	// 830EC414: 897B0001  lbz r11, 1(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(1 as u32) ) } as u64;
	// 830EC418: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EC41C: 419A0014  beq cr6, 0x830ec430
	if ctx.cr[6].eq {
	pc = 0x830EC430; continue 'dispatch;
	}
	// 830EC420: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830EC424: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830EC428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EC42C: 4BFFA79D  bl 0x830e6bc8
	ctx.lr = 0x830EC430;
	sub_830E6BC8(ctx, base);
	// 830EC430: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC434: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 830EC438: 4099001C  ble cr6, 0x830ec454
	if !ctx.cr[6].gt {
	pc = 0x830EC454; continue 'dispatch;
	}
	// 830EC43C: 3D40830E  lis r10, -0x7cf2
	ctx.r[10].s64 = -2096234496;
	// 830EC440: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC444: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 830EC448: 38CA6A18  addi r6, r10, 0x6a18
	ctx.r[6].s64 = ctx.r[10].s64 + 27160;
	// 830EC44C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EC450: 4BFF9CB9  bl 0x830e6108
	ctx.lr = 0x830EC454;
	sub_830E6108(ctx, base);
	// 830EC454: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 830EC458: C03B0004  lfs f1, 4(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830EC45C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EC460: 4BFFB0A1  bl 0x830e7500
	ctx.lr = 0x830EC464;
	sub_830E7500(ctx, base);
	// 830EC464: 897B0002  lbz r11, 2(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(2 as u32) ) } as u64;
	// 830EC468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EC46C: 419A0020  beq cr6, 0x830ec48c
	if ctx.cr[6].eq {
	pc = 0x830EC48C; continue 'dispatch;
	}
	// 830EC470: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830EC474: 2F0B012C  cmpwi cr6, r11, 0x12c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 300, &mut ctx.xer);
	// 830EC478: 40980014  bge cr6, 0x830ec48c
	if !ctx.cr[6].lt {
	pc = 0x830EC48C; continue 'dispatch;
	}
	// 830EC47C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830EC480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EC484: C02BBE14  lfs f1, -0x41ec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16876 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830EC488: 4BFFCDA9  bl 0x830e9230
	ctx.lr = 0x830EC48C;
	sub_830E9230(ctx, base);
	// 830EC48C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EC490: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830EC494: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 830EC498: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 830EC49C: C3EA0C18  lfs f31, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830EC4A0: 7FCA0774  extsb r10, r30
	ctx.r[10].s64 = ctx.r[30].s8 as i64;
	// 830EC4A4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EC4A8: 419A0010  beq cr6, 0x830ec4b8
	if ctx.cr[6].eq {
	pc = 0x830EC4B8; continue 'dispatch;
	}
	// 830EC4AC: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 830EC4B0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EC4B4: 419A00A4  beq cr6, 0x830ec558
	if ctx.cr[6].eq {
	pc = 0x830EC558; continue 'dispatch;
	}
	// 830EC4B8: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 830EC4BC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC4C0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 830EC4C4: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 830EC4C8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EC4CC: 555EDFFE  rlwinm r30, r10, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 830EC4D0: 40990028  ble cr6, 0x830ec4f8
	if !ctx.cr[6].gt {
	pc = 0x830EC4F8; continue 'dispatch;
	}
	// 830EC4D4: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 830EC4D8: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC4DC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830EC4E0: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 830EC4E4: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 830EC4E8: D3E9000C  stfs f31, 0xc(r9)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 830EC4EC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC4F0: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830EC4F4: 4198FFE4  blt cr6, 0x830ec4d8
	if ctx.cr[6].lt {
	pc = 0x830EC4D8; continue 'dispatch;
	}
	// 830EC4F8: 935C0008  stw r26, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 830EC4FC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 830EC500: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC504: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830EC508: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EC50C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830EC510: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 830EC514: 4BFFF96D  bl 0x830ebe80
	ctx.lr = 0x830EC518;
	sub_830EBE80(ctx, base);
	// 830EC518: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EC51C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830EC520: 4BFFDB69  bl 0x830ea088
	ctx.lr = 0x830EC524;
	sub_830EA088(ctx, base);
	// 830EC524: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EC528: 4BFFB981  bl 0x830e7ea8
	ctx.lr = 0x830EC52C;
	sub_830E7EA8(ctx, base);
	// 830EC52C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EC530: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 830EC534: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 830EC538: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 830EC53C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 830EC540: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830EC544: 4BFFB11D  bl 0x830e7660
	ctx.lr = 0x830EC548;
	sub_830E7660(ctx, base);
	// 830EC548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EC54C: 4BFFB95D  bl 0x830e7ea8
	ctx.lr = 0x830EC550;
	sub_830E7EA8(ctx, base);
	// 830EC550: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EC554: 4BFFFF4C  b 0x830ec4a0
	pc = 0x830EC4A0; continue 'dispatch;
	// 830EC558: 897B0001  lbz r11, 1(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(1 as u32) ) } as u64;
	// 830EC55C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EC560: 419A0014  beq cr6, 0x830ec574
	if ctx.cr[6].eq {
	pc = 0x830EC574; continue 'dispatch;
	}
	// 830EC564: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830EC568: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 830EC56C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EC570: 4BFFA841  bl 0x830e6db0
	ctx.lr = 0x830EC574;
	sub_830E6DB0(ctx, base);
	// 830EC574: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 830EC578: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 830EC57C: 4BBBCED4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EC580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EC580 size=1028
    let mut pc: u32 = 0x830EC580;
    'dispatch: loop {
        match pc {
            0x830EC580 => {
    //   block [0x830EC580..0x830EC65C)
	// 830EC580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EC584: 4BBBCE75  bl 0x82ca93f8
	ctx.lr = 0x830EC588;
	sub_82CA93D0(ctx, base);
	// 830EC588: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 830EC58C: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 830EC590: 9421EAC0  stwu r1, -0x1540(r1)
	ea = ctx.r[1].u32.wrapping_add(-5440 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EC594: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830EC598: 3947FFFE  addi r10, r7, -2
	ctx.r[10].s64 = ctx.r[7].s64 + -2;
	// 830EC59C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830EC5A0: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 830EC5A4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 830EC5A8: C00BA5E4  lfs f0, -0x5a1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EC5AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830EC5B0: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830EC5B4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 830EC5B8: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 830EC5BC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830EC5C0: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 830EC5C4: 9BC10060  stb r30, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u8 ) };
	// 830EC5C8: 9BC10061  stb r30, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[30].u8 ) };
	// 830EC5CC: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 830EC5D0: C3EB0DB0  lfs f31, 0xdb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3504 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830EC5D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830EC5D8: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830EC5DC: D3E10078  stfs f31, 0x78(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830EC5E0: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 830EC5E4: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 830EC5E8: C1AB0AC4  lfs f13, 0xac4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2756 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EC5EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830EC5F0: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830EC5F4: D1A1008C  stfs f13, 0x8c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 830EC5F8: C18B0AB4  lfs f12, 0xab4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2740 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830EC5FC: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 830EC600: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 830EC604: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 830EC608: 61590040  ori r25, r10, 0x40
	ctx.r[25].u64 = ctx.r[10].u64 | 64;
	// 830EC60C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830EC610: 99610062  stb r11, 0x62(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[11].u8 ) };
	// 830EC614: 396100C0  addi r11, r1, 0xc0
	ctx.r[11].s64 = ctx.r[1].s64 + 192;
	// 830EC618: 932100B8  stw r25, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[25].u32 ) };
	// 830EC61C: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 830EC620: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 830EC624: C18B1448  lfs f12, 0x1448(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5192 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830EC628: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 830EC62C: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 830EC630: C18A0AD4  lfs f12, 0xad4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2772 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830EC634: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830EC638: D1810088  stfs f12, 0x88(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 830EC63C: 916100B4  stw r11, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 830EC640: C00AA5E0  lfs f0, -0x5a20(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-23072 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EC644: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830EC648: 40990084  ble cr6, 0x830ec6cc
	if !ctx.cr[6].gt {
	pc = 0x830EC6CC; continue 'dispatch;
	}
	// 830EC64C: 7F1AC378  mr r26, r24
	ctx.r[26].u64 = ctx.r[24].u64;
	// 830EC650: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 830EC654: 48000008  b 0x830ec65c
	pc = 0x830EC65C; continue 'dispatch;
	// 830EC658: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
            }
            0x830EC65C => {
    //   block [0x830EC65C..0x830EC67C)
	// 830EC65C: 814100B8  lwz r10, 0xb8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 830EC660: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 830EC664: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830EC668: 409A0014  bne cr6, 0x830ec67c
	if !ctx.cr[6].eq {
	pc = 0x830EC67C; continue 'dispatch;
	}
	// 830EC66C: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 830EC670: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 830EC674: 4BC6A925  bl 0x82d56f98
	ctx.lr = 0x830EC678;
	sub_82D56F98(ctx, base);
	// 830EC678: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	pc = 0x830EC67C; continue 'dispatch;
            }
            0x830EC67C => {
    //   block [0x830EC67C..0x830EC6CC)
	// 830EC67C: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 830EC680: 556A2036  slwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EC684: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	pc = 0x830EC6CC; continue 'dispatch;
            }
            0x830EC6CC => {
    //   block [0x830EC6CC..0x830EC984)
	// 830EC6CC: 38A10094  addi r5, r1, 0x94
	ctx.r[5].s64 = ctx.r[1].s64 + 148;
	// 830EC6D0: C0210064  lfs f1, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830EC6D4: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 830EC6D8: 4BFFAE29  bl 0x830e7500
	ctx.lr = 0x830EC6DC;
	sub_830E7500(ctx, base);
	// 830EC6DC: 396104D0  addi r11, r1, 0x4d0
	ctx.r[11].s64 = ctx.r[1].s64 + 1232;
	// 830EC6E0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 830EC6E4: 80A100B4  lwz r5, 0xb4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 830EC6E8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830EC6EC: 808100B0  lwz r4, 0xb0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 830EC6F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EC6F4: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830EC6F8: 93C104C4  stw r30, 0x4c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1220 as u32), ctx.r[30].u32 ) };
	// 830EC6FC: 916104C0  stw r11, 0x4c0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1216 as u32), ctx.r[11].u32 ) };
	// 830EC700: 932104C8  stw r25, 0x4c8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1224 as u32), ctx.r[25].u32 ) };
	// 830EC704: 4BFFFC8D  bl 0x830ec390
	ctx.lr = 0x830EC708;
	sub_830EC390(ctx, base);
	// 830EC708: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 830EC70C: 80C100B4  lwz r6, 0xb4(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 830EC710: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830EC714: 80A100B0  lwz r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 830EC718: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EC71C: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 830EC720: 48001351  bl 0x830eda70
	ctx.lr = 0x830EC724;
	sub_830EDA70(ctx, base);
	// 830EC724: 8B630000  lbz r27, 0(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC728: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 830EC72C: 409A010C  bne cr6, 0x830ec838
	if !ctx.cr[6].eq {
	pc = 0x830EC838; continue 'dispatch;
	}
	// 830EC730: 89610062  lbz r11, 0x62(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(98 as u32) ) } as u64;
	// 830EC734: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EC738: 419A0100  beq cr6, 0x830ec838
	if ctx.cr[6].eq {
	pc = 0x830EC838; continue 'dispatch;
	}
	// 830EC73C: 39610CF0  addi r11, r1, 0xcf0
	ctx.r[11].s64 = ctx.r[1].s64 + 3312;
	// 830EC740: 93C104C4  stw r30, 0x4c4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(1220 as u32), ctx.r[30].u32 ) };
	// 830EC744: 39410CE0  addi r10, r1, 0xce0
	ctx.r[10].s64 = ctx.r[1].s64 + 3296;
	// 830EC748: 9BC10051  stb r30, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[30].u8 ) };
	// 830EC74C: 392104C0  addi r9, r1, 0x4c0
	ctx.r[9].s64 = ctx.r[1].s64 + 1216;
	// 830EC750: 93C10CE4  stw r30, 0xce4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(3300 as u32), ctx.r[30].u32 ) };
	// 830EC754: 39010051  addi r8, r1, 0x51
	ctx.r[8].s64 = ctx.r[1].s64 + 81;
	// 830EC758: 93210CE8  stw r25, 0xce8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(3304 as u32), ctx.r[25].u32 ) };
	// 830EC75C: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 830EC760: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 830EC764: 91610CE0  stw r11, 0xce0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(3296 as u32), ctx.r[11].u32 ) };
	// 830EC768: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830EC76C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EC770: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EC774: 4BFFCDA5  bl 0x830e9518
	ctx.lr = 0x830EC778;
	sub_830E9518(ctx, base);
	// 830EC778: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 830EC77C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EC780: 419A008C  beq cr6, 0x830ec80c
	if ctx.cr[6].eq {
	pc = 0x830EC80C; continue 'dispatch;
	}
	// 830EC784: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830EC788: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830EC78C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 830EC790: C02BBE14  lfs f1, -0x41ec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16876 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 830EC794: 4BFFCA9D  bl 0x830e9230
	ctx.lr = 0x830EC798;
	sub_830E9230(ctx, base);
	// 830EC798: 396108E0  addi r11, r1, 0x8e0
	ctx.r[11].s64 = ctx.r[1].s64 + 2272;
	// 830EC79C: 80A100B4  lwz r5, 0xb4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 830EC7A0: 38E108D0  addi r7, r1, 0x8d0
	ctx.r[7].s64 = ctx.r[1].s64 + 2256;
	// 830EC7A4: 808100B0  lwz r4, 0xb0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 830EC7A8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 830EC7AC: 93C108D4  stw r30, 0x8d4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2260 as u32), ctx.r[30].u32 ) };
	// 830EC7B0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 830EC7B4: 932108D8  stw r25, 0x8d8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2264 as u32), ctx.r[25].u32 ) };
	// 830EC7B8: 916108D0  stw r11, 0x8d0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(2256 as u32), ctx.r[11].u32 ) };
	// 830EC7BC: 4BFFBDD5  bl 0x830e8590
	ctx.lr = 0x830EC7C0;
	sub_830E8590(ctx, base);
	// 830EC7C0: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 830EC7C4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830EC7C8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830EC7CC: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 830EC7D0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EC7D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EC7D8: 48001299  bl 0x830eda70
	ctx.lr = 0x830EC7DC;
	sub_830EDA70(ctx, base);
	// 830EC7DC: 816108D8  lwz r11, 0x8d8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(2264 as u32) ) } as u64;
	// 830EC7E0: 8B630000  lbz r27, 0(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC7E4: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EC7E8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EC7EC: 409A0020  bne cr6, 0x830ec80c
	if !ctx.cr[6].eq {
	pc = 0x830EC80C; continue 'dispatch;
	}
	// 830EC7F0: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC7F4: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830EC7F8: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830EC7FC: 808108D0  lwz r4, 0x8d0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(2256 as u32) ) } as u64;
	// 830EC800: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830EC804: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830EC808: 4BC68AC1  bl 0x82d552c8
	ctx.lr = 0x830EC80C;
	sub_82D552C8(ctx, base);
	// 830EC80C: 81610CE8  lwz r11, 0xce8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(3304 as u32) ) } as u64;
	// 830EC810: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EC814: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EC818: 409A0020  bne cr6, 0x830ec838
	if !ctx.cr[6].eq {
	pc = 0x830EC838; continue 'dispatch;
	}
	// 830EC81C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC820: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830EC824: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830EC828: 80810CE0  lwz r4, 0xce0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(3296 as u32) ) } as u64;
	// 830EC82C: 55652834  slwi r5, r11, 5
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830EC830: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830EC834: 4BC68A95  bl 0x82d552c8
	ctx.lr = 0x830EC838;
	sub_82D552C8(ctx, base);
	// 830EC838: 89610062  lbz r11, 0x62(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(98 as u32) ) } as u64;
	// 830EC83C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EC840: 409A00E0  bne cr6, 0x830ec920
	if !ctx.cr[6].eq {
	pc = 0x830EC920; continue 'dispatch;
	}
	// 830EC844: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EC848: 7F6A0774  extsb r10, r27
	ctx.r[10].s64 = ctx.r[27].s8 as i64;
	// 830EC84C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EC850: 99610061  stb r11, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[11].u8 ) };
	// 830EC854: 409A00CC  bne cr6, 0x830ec920
	if !ctx.cr[6].eq {
	pc = 0x830EC920; continue 'dispatch;
	}
	// 830EC858: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 830EC85C: 99610060  stb r11, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 830EC860: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830EC864: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830EC868: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 830EC86C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EC870: 4BFFFB21  bl 0x830ec390
	ctx.lr = 0x830EC874;
	sub_830EC390(ctx, base);
	// 830EC874: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 830EC878: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830EC87C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830EC880: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 830EC884: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EC888: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EC88C: 480011E5  bl 0x830eda70
	ctx.lr = 0x830EC890;
	sub_830EDA70(ctx, base);
	// 830EC890: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EC898: 409A0088  bne cr6, 0x830ec920
	if !ctx.cr[6].eq {
	pc = 0x830EC920; continue 'dispatch;
	}
	// 830EC89C: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830EC8A0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 830EC8A4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830EC8A8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830EC8AC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 830EC8B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EC8B4: C00BA63C  lfs f0, -0x59c4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22980 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EC8B8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830EC8BC: 4BFFFAD5  bl 0x830ec390
	ctx.lr = 0x830EC8C0;
	sub_830EC390(ctx, base);
	// 830EC8C0: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 830EC8C4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830EC8C8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830EC8CC: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 830EC8D0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EC8D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EC8D8: 48001199  bl 0x830eda70
	ctx.lr = 0x830EC8DC;
	sub_830EDA70(ctx, base);
	// 830EC8DC: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC8E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EC8E4: 409A003C  bne cr6, 0x830ec920
	if !ctx.cr[6].eq {
	pc = 0x830EC920; continue 'dispatch;
	}
	// 830EC8E8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 830EC8EC: D3E10090  stfs f31, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 830EC8F0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830EC8F4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830EC8F8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 830EC8FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EC900: 4BFFFA91  bl 0x830ec390
	ctx.lr = 0x830EC904;
	sub_830EC390(ctx, base);
	// 830EC904: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 830EC908: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 830EC90C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830EC910: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 830EC914: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 830EC918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EC91C: 48001155  bl 0x830eda70
	ctx.lr = 0x830EC920;
	sub_830EDA70(ctx, base);
	// 830EC920: 816104C8  lwz r11, 0x4c8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1224 as u32) ) } as u64;
	// 830EC924: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EC928: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EC92C: 409A0020  bne cr6, 0x830ec94c
	if !ctx.cr[6].eq {
	pc = 0x830EC94C; continue 'dispatch;
	}
	// 830EC930: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC934: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830EC938: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830EC93C: 808104C0  lwz r4, 0x4c0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1216 as u32) ) } as u64;
	// 830EC940: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830EC944: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830EC948: 4BC68981  bl 0x82d552c8
	ctx.lr = 0x830EC94C;
	sub_82D552C8(ctx, base);
	// 830EC94C: 816100B8  lwz r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 830EC950: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EC954: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EC958: 409A0020  bne cr6, 0x830ec978
	if !ctx.cr[6].eq {
	pc = 0x830EC978; continue 'dispatch;
	}
	// 830EC95C: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC960: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830EC964: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830EC968: 808100B0  lwz r4, 0xb0(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 830EC96C: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830EC970: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830EC974: 4BC68955  bl 0x82d552c8
	ctx.lr = 0x830EC978;
	sub_82D552C8(ctx, base);
	// 830EC978: 38211540  addi r1, r1, 0x1540
	ctx.r[1].s64 = ctx.r[1].s64 + 5440;
	// 830EC97C: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 830EC980: 4BBBCAC8  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EC988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EC988 size=336
    let mut pc: u32 = 0x830EC988;
    'dispatch: loop {
        match pc {
            0x830EC988 => {
    //   block [0x830EC988..0x830EC9A4)
	// 830EC988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EC98C: 4BBBCA71  bl 0x82ca93fc
	ctx.lr = 0x830EC990;
	sub_82CA93D0(ctx, base);
	// 830EC990: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EC994: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830EC998: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 830EC99C: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 830EC9A0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	pc = 0x830EC9A4; continue 'dispatch;
            }
            0x830EC9A4 => {
    //   block [0x830EC9A4..0x830EC9C0)
	// 830EC9A4: 7D7ACA14  add r11, r26, r25
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[25].u64;
	// 830EC9A8: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 830EC9AC: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 830EC9B0: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 830EC9B4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EC9B8: 7D6BD82A  ldx r11, r11, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) };
	// 830EC9BC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	pc = 0x830EC9C0; continue 'dispatch;
            }
            0x830EC9C0 => {
    //   block [0x830EC9C0..0x830EC9E8)
	// 830EC9C0: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EC9C4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830EC9C8: 7FCBDA14  add r30, r11, r27
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830EC9CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EC9D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EC9D4: 7F8903A6  mtctr r28
	ctx.ctr.u64 = ctx.r[28].u64;
	// 830EC9D8: 4E800421  bctrl
	ctx.lr = 0x830EC9DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830EC9DC: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EC9E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EC9E4: 419A002C  beq cr6, 0x830eca10
	if ctx.cr[6].eq {
	pc = 0x830ECA10; continue 'dispatch;
	}
            }
            0x830EC9E8 => {
    //   block [0x830EC9E8..0x830ECA10)
	// 830EC9E8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 830EC9EC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830EC9F0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 830EC9F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830EC9F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EC9FC: 7F8903A6  mtctr r28
	ctx.ctr.u64 = ctx.r[28].u64;
	// 830ECA00: 4E800421  bctrl
	ctx.lr = 0x830ECA04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830ECA04: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ECA08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830ECA0C: 409AFFDC  bne cr6, 0x830ec9e8
	if !ctx.cr[6].eq {
	pc = 0x830EC9E8; continue 'dispatch;
	}
            }
            0x830ECA10 => {
    //   block [0x830ECA10..0x830ECA38)
	// 830ECA10: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830ECA14: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830ECA18: 7FCBDA14  add r30, r11, r27
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830ECA1C: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 830ECA20: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830ECA24: 7F8903A6  mtctr r28
	ctx.ctr.u64 = ctx.r[28].u64;
	// 830ECA28: 4E800421  bctrl
	ctx.lr = 0x830ECA2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830ECA2C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ECA30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830ECA34: 419A002C  beq cr6, 0x830eca60
	if ctx.cr[6].eq {
	pc = 0x830ECA60; continue 'dispatch;
	}
            }
            0x830ECA38 => {
    //   block [0x830ECA38..0x830ECA60)
	// 830ECA38: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 830ECA3C: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 830ECA40: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830ECA44: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 830ECA48: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830ECA4C: 7F8903A6  mtctr r28
	ctx.ctr.u64 = ctx.r[28].u64;
	// 830ECA50: 4E800421  bctrl
	ctx.lr = 0x830ECA54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 830ECA54: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ECA58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830ECA5C: 409AFFDC  bne cr6, 0x830eca38
	if !ctx.cr[6].eq {
	pc = 0x830ECA38; continue 'dispatch;
	}
            }
            0x830ECA60 => {
    //   block [0x830ECA60..0x830ECA94)
	// 830ECA60: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830ECA64: 41980040  blt cr6, 0x830ecaa4
	if ctx.cr[6].lt {
	pc = 0x830ECAA4; continue 'dispatch;
	}
	// 830ECA68: 419A002C  beq cr6, 0x830eca94
	if ctx.cr[6].eq {
	pc = 0x830ECA94; continue 'dispatch;
	}
	// 830ECA6C: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830ECA70: 57EA1838  slwi r10, r31, 3
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830ECA74: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 830ECA78: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 830ECA7C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ECA80: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 830ECA84: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 830ECA88: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ECA8C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 830ECA90: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	pc = 0x830ECA94; continue 'dispatch;
            }
            0x830ECA94 => {
    //   block [0x830ECA94..0x830ECAA4)
	// 830ECA94: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 830ECA98: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 830ECA9C: 7F1DF800  cmpw cr6, r29, r31
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830ECAA0: 4099FF20  ble cr6, 0x830ec9c0
	if !ctx.cr[6].gt {
	pc = 0x830EC9C0; continue 'dispatch;
	}
	pc = 0x830ECAA4; continue 'dispatch;
            }
            0x830ECAA4 => {
    //   block [0x830ECAA4..0x830ECAC0)
	// 830ECAA4: 7F1AF800  cmpw cr6, r26, r31
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830ECAA8: 40980018  bge cr6, 0x830ecac0
	if !ctx.cr[6].lt {
	pc = 0x830ECAC0; continue 'dispatch;
	}
	// 830ECAAC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 830ECAB0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830ECAB4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 830ECAB8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830ECABC: 4BFFFECD  bl 0x830ec988
	ctx.lr = 0x830ECAC0;
	sub_830EC988(ctx, base);
	pc = 0x830ECAC0; continue 'dispatch;
            }
            0x830ECAC0 => {
    //   block [0x830ECAC0..0x830ECAD0)
	// 830ECAC0: 7F1DC800  cmpw cr6, r29, r25
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[25].s32, &mut ctx.xer);
	// 830ECAC4: 4098000C  bge cr6, 0x830ecad0
	if !ctx.cr[6].lt {
	pc = 0x830ECAD0; continue 'dispatch;
	}
	// 830ECAC8: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 830ECACC: 4BFFFED8  b 0x830ec9a4
	pc = 0x830EC9A4; continue 'dispatch;
            }
            0x830ECAD0 => {
    //   block [0x830ECAD0..0x830ECAD8)
	// 830ECAD0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830ECAD4: 4BBBC978  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ECAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830ECAD8 size=252
    let mut pc: u32 = 0x830ECAD8;
    'dispatch: loop {
        match pc {
            0x830ECAD8 => {
    //   block [0x830ECAD8..0x830ECB30)
	// 830ECAD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ECADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830ECAE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830ECAE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830ECAE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830ECAEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830ECAF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830ECAF4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830ECAF8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ECAFC: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830ECB00: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830ECB04: 40980060  bge cr6, 0x830ecb64
	if !ctx.cr[6].lt {
	pc = 0x830ECB64; continue 'dispatch;
	}
	// 830ECB08: 556B0000  rlwinm r11, r11, 0, 0, 0
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830ECB0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ECB10: 409A0020  bne cr6, 0x830ecb30
	if !ctx.cr[6].eq {
	pc = 0x830ECB30; continue 'dispatch;
	}
	// 830ECB14: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ECB18: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830ECB1C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830ECB20: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ECB24: 55451838  slwi r5, r10, 3
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830ECB28: 7C69582E  lwzx r3, r9, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830ECB2C: 4BC6879D  bl 0x82d552c8
	ctx.lr = 0x830ECB30;
	sub_82D552C8(ctx, base);
	pc = 0x830ECB30; continue 'dispatch;
            }
            0x830ECB30 => {
    //   block [0x830ECB30..0x830ECB64)
	// 830ECB30: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ECB34: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 830ECB38: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ECB3C: 38A00016  li r5, 0x16
	ctx.r[5].s64 = 22;
	// 830ECB40: 55241838  slwi r4, r9, 3
	ctx.r[4].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830ECB44: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 830ECB48: 4BC68701  bl 0x82d55248
	ctx.lr = 0x830ECB4C;
	sub_82D55248(ctx, base);
	// 830ECB4C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830ECB50: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 830ECB54: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ECB58: 556B0042  rlwinm r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830ECB5C: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 830ECB60: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x830ECB64; continue 'dispatch;
            }
            0x830ECB64 => {
    //   block [0x830ECB64..0x830ECB80)
	// 830ECB64: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ECB68: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ECB6C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830ECB70: 911E0004  stw r8, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 830ECB74: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ECB78: 40990040  ble cr6, 0x830ecbb8
	if !ctx.cr[6].gt {
	pc = 0x830ECBB8; continue 'dispatch;
	}
	// 830ECB7C: 7CE95850  subf r7, r9, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	pc = 0x830ECB80; continue 'dispatch;
            }
            0x830ECB80 => {
    //   block [0x830ECB80..0x830ECBB8)
	// 830ECB80: 7D474A14  add r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 830ECB84: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 830ECB88: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 830ECB8C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 830ECB90: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 830ECB94: A0CA0000  lhz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ECB98: B0CB0000  sth r6, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u16 ) };
	// 830ECB9C: A0CA0002  lhz r6, 2(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 830ECBA0: B0CB0002  sth r6, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[6].u16 ) };
	// 830ECBA4: A0CA0004  lhz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ECBA8: B0CB0004  sth r6, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u16 ) };
	// 830ECBAC: A14A0006  lhz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 830ECBB0: B14B0006  sth r10, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[10].u16 ) };
	// 830ECBB4: 409AFFCC  bne cr6, 0x830ecb80
	if !ctx.cr[6].eq {
	pc = 0x830ECB80; continue 'dispatch;
	}
	pc = 0x830ECBB8; continue 'dispatch;
            }
            0x830ECBB8 => {
    //   block [0x830ECBB8..0x830ECBD4)
	// 830ECBB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830ECBBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830ECBC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830ECBC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830ECBC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830ECBCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830ECBD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ECBD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830ECBD8 size=124
    let mut pc: u32 = 0x830ECBD8;
    'dispatch: loop {
        match pc {
            0x830ECBD8 => {
    //   block [0x830ECBD8..0x830ECC20)
	// 830ECBD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ECBDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830ECBE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830ECBE4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830ECBE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830ECBEC: B0810050  sth r4, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u16 ) };
	// 830ECBF0: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 830ECBF4: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830ECBF8: B1610052  sth r11, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u16 ) };
	// 830ECBFC: B1610054  sth r11, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u16 ) };
	// 830ECC00: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830ECC04: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ECC08: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830ECC0C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830ECC10: 409A0010  bne cr6, 0x830ecc20
	if !ctx.cr[6].eq {
	pc = 0x830ECC20; continue 'dispatch;
	}
	// 830ECC14: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 830ECC18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830ECC1C: 4BC6A37D  bl 0x82d56f98
	ctx.lr = 0x830ECC20;
	sub_82D56F98(ctx, base);
	pc = 0x830ECC20; continue 'dispatch;
            }
            0x830ECC20 => {
    //   block [0x830ECC20..0x830ECC54)
	// 830ECC20: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ECC24: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830ECC28: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ECC2C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830ECC30: 7D4B492A  stdx r10, r11, r9
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u64) };
	// 830ECC34: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ECC38: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830ECC3C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830ECC40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830ECC44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830ECC48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830ECC4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830ECC50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ECC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830ECC58 size=204
    let mut pc: u32 = 0x830ECC58;
    'dispatch: loop {
        match pc {
            0x830ECC58 => {
    //   block [0x830ECC58..0x830ECCB0)
	// 830ECC58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ECC5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830ECC60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830ECC64: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830ECC68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830ECC6C: B0810050  sth r4, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u16 ) };
	// 830ECC70: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 830ECC74: B0A10058  sth r5, 0x58(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u16 ) };
	// 830ECC78: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830ECC7C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830ECC80: B161005A  sth r11, 0x5a(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[11].u16 ) };
	// 830ECC84: B161005C  sth r11, 0x5c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u16 ) };
	// 830ECC88: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830ECC8C: B1410052  sth r10, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u16 ) };
	// 830ECC90: B1410054  sth r10, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u16 ) };
	// 830ECC94: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830ECC98: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ECC9C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830ECCA0: 409A0010  bne cr6, 0x830eccb0
	if !ctx.cr[6].eq {
	pc = 0x830ECCB0; continue 'dispatch;
	}
	// 830ECCA4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 830ECCA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830ECCAC: 4BC6A2ED  bl 0x82d56f98
	ctx.lr = 0x830ECCB0;
	sub_82D56F98(ctx, base);
	pc = 0x830ECCB0; continue 'dispatch;
            }
            0x830ECCB0 => {
    //   block [0x830ECCB0..0x830ECCF0)
	// 830ECCB0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ECCB4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ECCB8: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 830ECCBC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830ECCC0: 7D2B512A  stdx r9, r11, r10
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u64) };
	// 830ECCC4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ECCC8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830ECCCC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830ECCD0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830ECCD4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ECCD8: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830ECCDC: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830ECCE0: 409A0010  bne cr6, 0x830eccf0
	if !ctx.cr[6].eq {
	pc = 0x830ECCF0; continue 'dispatch;
	}
	// 830ECCE4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 830ECCE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830ECCEC: 4BC6A2AD  bl 0x82d56f98
	ctx.lr = 0x830ECCF0;
	sub_82D56F98(ctx, base);
	pc = 0x830ECCF0; continue 'dispatch;
            }
            0x830ECCF0 => {
    //   block [0x830ECCF0..0x830ECD24)
	// 830ECCF0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ECCF4: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 830ECCF8: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ECCFC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830ECD00: 7D4B492A  stdx r10, r11, r9
	unsafe { crate::rt::store_u64(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u64) };
	// 830ECD04: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ECD08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830ECD0C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830ECD10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830ECD14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830ECD18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830ECD1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830ECD20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ECD28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830ECD28 size=944
    let mut pc: u32 = 0x830ECD28;
    'dispatch: loop {
        match pc {
            0x830ECD28 => {
    //   block [0x830ECD28..0x830ED0D8)
	// 830ECD28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ECD2C: 4BBBC6CD  bl 0x82ca93f8
	ctx.lr = 0x830ECD30;
	sub_82CA93D0(ctx, base);
	// 830ECD30: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830ECD34: 7CA82B78  mr r8, r5
	ctx.r[8].u64 = ctx.r[5].u64;
	// 830ECD38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ECD3C: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 830ECD40: 550A2036  slwi r10, r8, 4
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830ECD44: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830ECD48: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 830ECD4C: 54DF2036  slwi r31, r6, 4
	ctx.r[31].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 830ECD50: 553D2036  slwi r29, r9, 4
	ctx.r[29].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 830ECD54: 7FFF5A14  add r31, r31, r11
	ctx.r[31].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 830ECD58: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830ECD5C: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 830ECD60: EBAA0000  ld r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 830ECD64: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 830ECD68: EB0A0008  ld r24, 8(r10)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 830ECD6C: 3B810068  addi r28, r1, 0x68
	ctx.r[28].s64 = ctx.r[1].s64 + 104;
	// 830ECD70: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 830ECD74: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ED0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830ED0D8 size=112
    let mut pc: u32 = 0x830ED0D8;
    'dispatch: loop {
        match pc {
            0x830ED0D8 => {
    //   block [0x830ED0D8..0x830ED12C)
	// 830ED0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ED0DC: 4BBBC331  bl 0x82ca940c
	ctx.lr = 0x830ED0E0;
	sub_82CA93D0(ctx, base);
	// 830ED0E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830ED0E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830ED0E8: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 830ED0EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830ED0F0: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 830ED0F4: 616B0080  ori r11, r11, 0x80
	ctx.r[11].u64 = ctx.r[11].u64 | 128;
	// 830ED0F8: 395F000C  addi r10, r31, 0xc
	ctx.r[10].s64 = ctx.r[31].s64 + 12;
	// 830ED0FC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830ED100: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830ED104: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830ED108: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830ED10C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830ED110: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830ED114: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ED118: 40980020  bge cr6, 0x830ed138
	if !ctx.cr[6].lt {
	pc = 0x830ED138; continue 'dispatch;
	}
	// 830ED11C: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 830ED120: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 830ED124: 41990008  bgt cr6, 0x830ed12c
	if ctx.cr[6].gt {
	pc = 0x830ED12C; continue 'dispatch;
	}
	// 830ED128: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x830ED12C; continue 'dispatch;
            }
            0x830ED12C => {
    //   block [0x830ED12C..0x830ED138)
	// 830ED12C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 830ED130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830ED134: 4BC69DDD  bl 0x82d56f10
	ctx.lr = 0x830ED138;
	sub_82D56F10(ctx, base);
	pc = 0x830ED138; continue 'dispatch;
            }
            0x830ED138 => {
    //   block [0x830ED138..0x830ED148)
	// 830ED138: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830ED13C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830ED140: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830ED144: 4BBBC318  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ED148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830ED148 size=276
    let mut pc: u32 = 0x830ED148;
    'dispatch: loop {
        match pc {
            0x830ED148 => {
    //   block [0x830ED148..0x830ED180)
	// 830ED148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ED14C: 4BBBC2B9  bl 0x82ca9404
	ctx.lr = 0x830ED150;
	sub_82CA93D0(ctx, base);
	// 830ED150: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 830ED154: 9421EF70  stwu r1, -0x1090(r1)
	ea = ctx.r[1].u32.wrapping_add(-4240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830ED158: 3961005C  addi r11, r1, 0x5c
	ctx.r[11].s64 = ctx.r[1].s64 + 92;
	// 830ED15C: 83A30004  lwz r29, 4(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED160: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 830ED164: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 830ED168: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 830ED16C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830ED170: 3D608000  lis r11, -0x8000
	ctx.r[11].s64 = -2147483648;
	// 830ED174: 616B0400  ori r11, r11, 0x400
	ctx.r[11].u64 = ctx.r[11].u64 | 1024;
	// 830ED178: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 830ED17C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	pc = 0x830ED180; continue 'dispatch;
            }
            0x830ED180 => {
    //   block [0x830ED180..0x830ED19C)
	// 830ED180: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830ED184: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830ED188: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830ED18C: 838BFFFC  lwz r28, -4(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830ED190: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 830ED194: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 830ED198: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x830ED19C; continue 'dispatch;
            }
            0x830ED19C => {
    //   block [0x830ED19C..0x830ED1BC)
	// 830ED19C: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED1A0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830ED1A4: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830ED1A8: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830ED1AC: B36B0006  sth r27, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[27].u16 ) };
	// 830ED1B0: 409AFFEC  bne cr6, 0x830ed19c
	if !ctx.cr[6].eq {
	pc = 0x830ED19C; continue 'dispatch;
	}
	// 830ED1B4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830ED1B8: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	pc = 0x830ED1BC; continue 'dispatch;
            }
            0x830ED1BC => {
    //   block [0x830ED1BC..0x830ED200)
	// 830ED1BC: A17F0004  lhz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED1C0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830ED1C4: 7FEBEA14  add r31, r11, r29
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830ED1C8: A17F0002  lhz r11, 2(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(2 as u32) ) } as u64;
	// 830ED1CC: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 830ED1D0: 7FCBEA14  add r30, r11, r29
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 830ED1D4: A17E0006  lhz r11, 6(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 830ED1D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830ED1DC: 409A003C  bne cr6, 0x830ed218
	if !ctx.cr[6].eq {
	pc = 0x830ED218; continue 'dispatch;
	}
	// 830ED1E0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830ED1E4: 556B00BE  clrlwi r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 830ED1E8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 830ED1EC: 409A0014  bne cr6, 0x830ed200
	if !ctx.cr[6].eq {
	pc = 0x830ED200; continue 'dispatch;
	}
	// 830ED1F0: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 830ED1F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 830ED1F8: 4BC69DA1  bl 0x82d56f98
	ctx.lr = 0x830ED1FC;
	sub_82D56F98(ctx, base);
	// 830ED1FC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x830ED200; continue 'dispatch;
            }
            0x830ED200 => {
    //   block [0x830ED200..0x830ED218)
	// 830ED200: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830ED204: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830ED208: 7FCB512E  stwx r30, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[30].u32) };
	// 830ED20C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 830ED210: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 830ED214: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x830ED218; continue 'dispatch;
            }
            0x830ED218 => {
    //   block [0x830ED218..0x830ED254)
	// 830ED218: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830ED21C: 409AFFA0  bne cr6, 0x830ed1bc
	if !ctx.cr[6].eq {
	pc = 0x830ED1BC; continue 'dispatch;
	}
	// 830ED220: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830ED224: 409AFF5C  bne cr6, 0x830ed180
	if !ctx.cr[6].eq {
	pc = 0x830ED180; continue 'dispatch;
	}
	// 830ED228: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830ED22C: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830ED230: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830ED234: 409A0020  bne cr6, 0x830ed254
	if !ctx.cr[6].eq {
	pc = 0x830ED254; continue 'dispatch;
	}
	// 830ED238: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED23C: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830ED240: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830ED244: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830ED248: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830ED24C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830ED250: 4BC68079  bl 0x82d552c8
	ctx.lr = 0x830ED254;
	sub_82D552C8(ctx, base);
	pc = 0x830ED254; continue 'dispatch;
            }
            0x830ED254 => {
    //   block [0x830ED254..0x830ED25C)
	// 830ED254: 38211090  addi r1, r1, 0x1090
	ctx.r[1].s64 = ctx.r[1].s64 + 4240;
	// 830ED258: 4BBBC1FC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ED260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830ED260 size=536
    let mut pc: u32 = 0x830ED260;
    'dispatch: loop {
        match pc {
            0x830ED260 => {
    //   block [0x830ED260..0x830ED29C)
	// 830ED260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ED264: 4BBBC1A9  bl 0x82ca940c
	ctx.lr = 0x830ED268;
	sub_82CA93D0(ctx, base);
	// 830ED268: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830ED26C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830ED270: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830ED274: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830ED278: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830ED27C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830ED280: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 830ED284: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED288: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830ED28C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830ED290: 409900E8  ble cr6, 0x830ed378
	if !ctx.cr[6].gt {
	pc = 0x830ED378; continue 'dispatch;
	}
	// 830ED294: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830ED298: 38E60002  addi r7, r6, 2
	ctx.r[7].s64 = ctx.r[6].s64 + 2;
	pc = 0x830ED29C; continue 'dispatch;
            }
            0x830ED29C => {
    //   block [0x830ED29C..0x830ED2B4)
	// 830ED29C: A1070000  lhz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED2A0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830ED2A4: 41980010  blt cr6, 0x830ed2b4
	if ctx.cr[6].lt {
	pc = 0x830ED2B4; continue 'dispatch;
	}
	// 830ED2A8: 7F082800  cmpw cr6, r8, r5
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[5].s32, &mut ctx.xer);
	// 830ED2AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830ED2B0: 41980008  blt cr6, 0x830ed2b8
	if ctx.cr[6].lt {
	pc = 0x830ED2B8; continue 'dispatch;
	}
	pc = 0x830ED2B4; continue 'dispatch;
            }
            0x830ED2B4 => {
    //   block [0x830ED2B4..0x830ED2B8)
	// 830ED2B4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x830ED2B8; continue 'dispatch;
            }
            0x830ED2B8 => {
    //   block [0x830ED2B8..0x830ED2D4)
	// 830ED2B8: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 830ED2BC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830ED2C0: 419A0014  beq cr6, 0x830ed2d4
	if ctx.cr[6].eq {
	pc = 0x830ED2D4; continue 'dispatch;
	}
	// 830ED2C4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830ED2C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ED2CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830ED2D0: 409A0008  bne cr6, 0x830ed2d8
	if !ctx.cr[6].eq {
	pc = 0x830ED2D8; continue 'dispatch;
	}
	pc = 0x830ED2D4; continue 'dispatch;
            }
            0x830ED2D4 => {
    //   block [0x830ED2D4..0x830ED2D8)
	// 830ED2D4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x830ED2D8; continue 'dispatch;
            }
            0x830ED2D8 => {
    //   block [0x830ED2D8..0x830ED2FC)
	// 830ED2D8: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830ED2DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830ED2E0: 419A001C  beq cr6, 0x830ed2fc
	if ctx.cr[6].eq {
	pc = 0x830ED2FC; continue 'dispatch;
	}
	// 830ED2E4: 550B1838  slwi r11, r8, 3
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830ED2E8: 7D6B3214  add r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 830ED2EC: A16B0002  lhz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 830ED2F0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830ED2F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830ED2F8: 419A0008  beq cr6, 0x830ed300
	if ctx.cr[6].eq {
	pc = 0x830ED300; continue 'dispatch;
	}
	pc = 0x830ED2FC; continue 'dispatch;
            }
            0x830ED2FC => {
    //   block [0x830ED2FC..0x830ED300)
	// 830ED2FC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x830ED300; continue 'dispatch;
            }
            0x830ED300 => {
    //   block [0x830ED300..0x830ED32C)
	// 830ED300: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830ED304: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 830ED308: 38E70008  addi r7, r7, 8
	ctx.r[7].s64 = ctx.r[7].s64 + 8;
	// 830ED30C: 7F0A2800  cmpw cr6, r10, r5
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[5].s32, &mut ctx.xer);
	// 830ED310: 4198FF8C  blt cr6, 0x830ed29c
	if ctx.cr[6].lt {
	pc = 0x830ED29C; continue 'dispatch;
	}
	// 830ED314: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830ED318: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830ED31C: 4099005C  ble cr6, 0x830ed378
	if !ctx.cr[6].gt {
	pc = 0x830ED378; continue 'dispatch;
	}
	// 830ED320: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830ED324: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 830ED328: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	pc = 0x830ED32C; continue 'dispatch;
            }
            0x830ED32C => {
    //   block [0x830ED32C..0x830ED360)
	// 830ED32C: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 830ED330: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830ED334: 419A002C  beq cr6, 0x830ed360
	if ctx.cr[6].eq {
	pc = 0x830ED360; continue 'dispatch;
	}
	// 830ED338: A14B0002  lhz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 830ED33C: A10B0000  lhz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED340: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 830ED344: 7D4A3214  add r10, r10, r6
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 830ED348: A14A0004  lhz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED34C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 830ED350: 7D4A322E  lhzx r10, r10, r6
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 830ED354: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830ED358: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830ED35C: 419A0008  beq cr6, 0x830ed364
	if ctx.cr[6].eq {
	pc = 0x830ED364; continue 'dispatch;
	}
	pc = 0x830ED360; continue 'dispatch;
            }
            0x830ED360 => {
    //   block [0x830ED360..0x830ED364)
	// 830ED360: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x830ED364; continue 'dispatch;
            }
            0x830ED364 => {
    //   block [0x830ED364..0x830ED378)
	// 830ED364: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 830ED368: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 830ED36C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830ED370: 409AFFBC  bne cr6, 0x830ed32c
	if !ctx.cr[6].eq {
	pc = 0x830ED32C; continue 'dispatch;
	}
	// 830ED374: 995E0000  stb r10, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	pc = 0x830ED378; continue 'dispatch;
            }
            0x830ED378 => {
    //   block [0x830ED378..0x830ED394)
	// 830ED378: 2F050002  cmpwi cr6, r5, 2
	ctx.cr[6].compare_i32(ctx.r[5].s32, 2, &mut ctx.xer);
	// 830ED37C: 40990064  ble cr6, 0x830ed3e0
	if !ctx.cr[6].gt {
	pc = 0x830ED3E0; continue 'dispatch;
	}
	// 830ED380: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 830ED384: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830ED388: 40990058  ble cr6, 0x830ed3e0
	if !ctx.cr[6].gt {
	pc = 0x830ED3E0; continue 'dispatch;
	}
	// 830ED38C: 893E0000  lbz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED390: 39460004  addi r10, r6, 4
	ctx.r[10].s64 = ctx.r[6].s64 + 4;
	pc = 0x830ED394; continue 'dispatch;
            }
            0x830ED394 => {
    //   block [0x830ED394..0x830ED3C8)
	// 830ED394: 7D290774  extsb r9, r9
	ctx.r[9].s64 = ctx.r[9].s8 as i64;
	// 830ED398: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830ED39C: 419A002C  beq cr6, 0x830ed3c8
	if ctx.cr[6].eq {
	pc = 0x830ED3C8; continue 'dispatch;
	}
	// 830ED3A0: A12A0000  lhz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED3A4: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 830ED3A8: 7D293214  add r9, r9, r6
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[6].u64;
	// 830ED3AC: A1290004  lhz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED3B0: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 830ED3B4: 7D293214  add r9, r9, r6
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[6].u64;
	// 830ED3B8: A1290004  lhz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED3BC: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830ED3C0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 830ED3C4: 419A0008  beq cr6, 0x830ed3cc
	if ctx.cr[6].eq {
	pc = 0x830ED3CC; continue 'dispatch;
	}
	pc = 0x830ED3C8; continue 'dispatch;
            }
            0x830ED3C8 => {
    //   block [0x830ED3C8..0x830ED3CC)
	// 830ED3C8: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	pc = 0x830ED3CC; continue 'dispatch;
            }
            0x830ED3CC => {
    //   block [0x830ED3CC..0x830ED3E0)
	// 830ED3CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 830ED3D0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 830ED3D4: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 830ED3D8: 4198FFBC  blt cr6, 0x830ed394
	if ctx.cr[6].lt {
	pc = 0x830ED394; continue 'dispatch;
	}
	// 830ED3DC: 993E0000  stb r9, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	pc = 0x830ED3E0; continue 'dispatch;
            }
            0x830ED3E0 => {
    //   block [0x830ED3E0..0x830ED3F0)
	// 830ED3E0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 830ED3E4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 830ED3E8: 40990028  ble cr6, 0x830ed410
	if !ctx.cr[6].gt {
	pc = 0x830ED410; continue 'dispatch;
	}
	// 830ED3EC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x830ED3F0; continue 'dispatch;
            }
            0x830ED3F0 => {
    //   block [0x830ED3F0..0x830ED410)
	// 830ED3F0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED3F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830ED3F8: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830ED3FC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 830ED400: B3A90006  sth r29, 6(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(6 as u32), ctx.r[29].u16 ) };
	// 830ED404: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830ED408: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 830ED40C: 4198FFE4  blt cr6, 0x830ed3f0
	if ctx.cr[6].lt {
	pc = 0x830ED3F0; continue 'dispatch;
	}
	pc = 0x830ED410; continue 'dispatch;
            }
            0x830ED410 => {
    //   block [0x830ED410..0x830ED430)
	// 830ED410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830ED414: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED418: 4BFFFD31  bl 0x830ed148
	ctx.lr = 0x830ED41C;
	sub_830ED148(ctx, base);
	// 830ED41C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830ED420: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830ED424: 40990048  ble cr6, 0x830ed46c
	if !ctx.cr[6].gt {
	pc = 0x830ED46C; continue 'dispatch;
	}
	// 830ED428: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED42C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x830ED430; continue 'dispatch;
            }
            0x830ED430 => {
    //   block [0x830ED430..0x830ED454)
	// 830ED430: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 830ED434: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830ED438: 419A001C  beq cr6, 0x830ed454
	if ctx.cr[6].eq {
	pc = 0x830ED454; continue 'dispatch;
	}
	// 830ED43C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED440: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830ED444: A14A0006  lhz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 830ED448: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 830ED44C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830ED450: 419A0008  beq cr6, 0x830ed458
	if ctx.cr[6].eq {
	pc = 0x830ED458; continue 'dispatch;
	}
	pc = 0x830ED454; continue 'dispatch;
            }
            0x830ED454 => {
    //   block [0x830ED454..0x830ED458)
	// 830ED454: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x830ED458; continue 'dispatch;
            }
            0x830ED458 => {
    //   block [0x830ED458..0x830ED46C)
	// 830ED458: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 830ED45C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 830ED460: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 830ED464: 409AFFCC  bne cr6, 0x830ed430
	if !ctx.cr[6].eq {
	pc = 0x830ED430; continue 'dispatch;
	}
	// 830ED468: 995E0000  stb r10, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	pc = 0x830ED46C; continue 'dispatch;
            }
            0x830ED46C => {
    //   block [0x830ED46C..0x830ED478)
	// 830ED46C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830ED470: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830ED474: 4BBBBFE8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ED478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830ED478 size=276
    let mut pc: u32 = 0x830ED478;
    'dispatch: loop {
        match pc {
            0x830ED478 => {
    //   block [0x830ED478..0x830ED4D4)
	// 830ED478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ED47C: 4BBBBF8D  bl 0x82ca9408
	ctx.lr = 0x830ED480;
	sub_82CA93D0(ctx, base);
	// 830ED480: 81450010  lwz r10, 0x10(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 830ED484: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 830ED488: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 830ED48C: 81240014  lwz r9, 0x14(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 830ED490: 83E40018  lwz r31, 0x18(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 830ED494: 83A50014  lwz r29, 0x14(r5)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 830ED498: 80A50018  lwz r5, 0x18(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) } as u64;
	// 830ED49C: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED4A0: A14A0000  lhz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED4A4: A0890000  lhz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED4A8: A13F0000  lhz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED4AC: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830ED4B0: A3FD0000  lhz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED4B4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 830ED4B8: A0A50000  lhz r5, 0(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED4BC: 9BC30000  stb r30, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 830ED4C0: 409A004C  bne cr6, 0x830ed50c
	if !ctx.cr[6].eq {
	pc = 0x830ED50C; continue 'dispatch;
	}
	// 830ED4C4: 7F04F800  cmpw cr6, r4, r31
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830ED4C8: 419A000C  beq cr6, 0x830ed4d4
	if ctx.cr[6].eq {
	pc = 0x830ED4D4; continue 'dispatch;
	}
	// 830ED4CC: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 830ED4D0: 409A0018  bne cr6, 0x830ed4e8
	if !ctx.cr[6].eq {
	pc = 0x830ED4E8; continue 'dispatch;
	}
	pc = 0x830ED4D4; continue 'dispatch;
            }
            0x830ED4D4 => {
    //   block [0x830ED4D4..0x830ED4E4)
	// 830ED4D4: 8B860000  lbz r28, 0(r6)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED4D8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830ED4DC: 419A0008  beq cr6, 0x830ed4e4
	if ctx.cr[6].eq {
	pc = 0x830ED4E4; continue 'dispatch;
	}
	// 830ED4E0: 9BA30000  stb r29, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	pc = 0x830ED4E4; continue 'dispatch;
            }
            0x830ED4E4 => {
    //   block [0x830ED4E4..0x830ED4E8)
	// 830ED4E4: 9BC60000  stb r30, 0(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	pc = 0x830ED4E8; continue 'dispatch;
            }
            0x830ED4E8 => {
    //   block [0x830ED4E8..0x830ED4F8)
	// 830ED4E8: 7F09F800  cmpw cr6, r9, r31
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830ED4EC: 419A000C  beq cr6, 0x830ed4f8
	if ctx.cr[6].eq {
	pc = 0x830ED4F8; continue 'dispatch;
	}
	// 830ED4F0: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 830ED4F4: 409A0018  bne cr6, 0x830ed50c
	if !ctx.cr[6].eq {
	pc = 0x830ED50C; continue 'dispatch;
	}
	pc = 0x830ED4F8; continue 'dispatch;
            }
            0x830ED4F8 => {
    //   block [0x830ED4F8..0x830ED508)
	// 830ED4F8: 8B870000  lbz r28, 0(r7)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED4FC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830ED500: 419A0008  beq cr6, 0x830ed508
	if ctx.cr[6].eq {
	pc = 0x830ED508; continue 'dispatch;
	}
	// 830ED504: 9BA30000  stb r29, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	pc = 0x830ED508; continue 'dispatch;
            }
            0x830ED508 => {
    //   block [0x830ED508..0x830ED50C)
	// 830ED508: 9BC70000  stb r30, 0(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	pc = 0x830ED50C; continue 'dispatch;
            }
            0x830ED50C => {
    //   block [0x830ED50C..0x830ED52C)
	// 830ED50C: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830ED510: 409A003C  bne cr6, 0x830ed54c
	if !ctx.cr[6].eq {
	pc = 0x830ED54C; continue 'dispatch;
	}
	// 830ED514: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 830ED518: 409A0018  bne cr6, 0x830ed530
	if !ctx.cr[6].eq {
	pc = 0x830ED530; continue 'dispatch;
	}
	// 830ED51C: 89660000  lbz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED520: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830ED524: 419A0008  beq cr6, 0x830ed52c
	if ctx.cr[6].eq {
	pc = 0x830ED52C; continue 'dispatch;
	}
	// 830ED528: 9BA30000  stb r29, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	pc = 0x830ED52C; continue 'dispatch;
            }
            0x830ED52C => {
    //   block [0x830ED52C..0x830ED530)
	// 830ED52C: 9BC60000  stb r30, 0(r6)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	pc = 0x830ED530; continue 'dispatch;
            }
            0x830ED530 => {
    //   block [0x830ED530..0x830ED548)
	// 830ED530: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 830ED534: 409A0018  bne cr6, 0x830ed54c
	if !ctx.cr[6].eq {
	pc = 0x830ED54C; continue 'dispatch;
	}
	// 830ED538: 89670000  lbz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED53C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830ED540: 419A0008  beq cr6, 0x830ed548
	if ctx.cr[6].eq {
	pc = 0x830ED548; continue 'dispatch;
	}
	// 830ED544: 9BA30000  stb r29, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	pc = 0x830ED548; continue 'dispatch;
            }
            0x830ED548 => {
    //   block [0x830ED548..0x830ED54C)
	// 830ED548: 9BC70000  stb r30, 0(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	pc = 0x830ED54C; continue 'dispatch;
            }
            0x830ED54C => {
    //   block [0x830ED54C..0x830ED564)
	// 830ED54C: 7F045000  cmpw cr6, r4, r10
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830ED550: 409A0014  bne cr6, 0x830ed564
	if !ctx.cr[6].eq {
	pc = 0x830ED564; continue 'dispatch;
	}
	// 830ED554: 7F09F800  cmpw cr6, r9, r31
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830ED558: 419A001C  beq cr6, 0x830ed574
	if ctx.cr[6].eq {
	pc = 0x830ED574; continue 'dispatch;
	}
	// 830ED55C: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 830ED560: 419A0014  beq cr6, 0x830ed574
	if ctx.cr[6].eq {
	pc = 0x830ED574; continue 'dispatch;
	}
	pc = 0x830ED564; continue 'dispatch;
            }
            0x830ED564 => {
    //   block [0x830ED564..0x830ED574)
	// 830ED564: 7F04F800  cmpw cr6, r4, r31
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[31].s32, &mut ctx.xer);
	// 830ED568: 409A0020  bne cr6, 0x830ed588
	if !ctx.cr[6].eq {
	pc = 0x830ED588; continue 'dispatch;
	}
	// 830ED56C: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 830ED570: 409A0018  bne cr6, 0x830ed588
	if !ctx.cr[6].eq {
	pc = 0x830ED588; continue 'dispatch;
	}
	pc = 0x830ED574; continue 'dispatch;
            }
            0x830ED574 => {
    //   block [0x830ED574..0x830ED584)
	// 830ED574: 89680000  lbz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED578: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830ED57C: 419A0008  beq cr6, 0x830ed584
	if ctx.cr[6].eq {
	pc = 0x830ED584; continue 'dispatch;
	}
	// 830ED580: 9BA30000  stb r29, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	pc = 0x830ED584; continue 'dispatch;
            }
            0x830ED584 => {
    //   block [0x830ED584..0x830ED588)
	// 830ED584: 9BC80000  stb r30, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	pc = 0x830ED588; continue 'dispatch;
            }
            0x830ED588 => {
    //   block [0x830ED588..0x830ED58C)
	// 830ED588: 4BBBBED0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ED590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830ED590 size=316
    let mut pc: u32 = 0x830ED590;
    'dispatch: loop {
        match pc {
            0x830ED590 => {
    //   block [0x830ED590..0x830ED634)
	// 830ED590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ED594: 4BBBBE75  bl 0x82ca9408
	ctx.lr = 0x830ED598;
	sub_82CA93D0(ctx, base);
	// 830ED598: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830ED59C: 83C60004  lwz r30, 4(r6)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED5A0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 830ED5A4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830ED5A8: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830ED5AC: 7F1FF000  cmpw cr6, r31, r30
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[30].s32, &mut ctx.xer);
	// 830ED5B0: 40980118  bge cr6, 0x830ed6c8
	if !ctx.cr[6].lt {
	pc = 0x830ED6C8; continue 'dispatch;
	}
	// 830ED5B4: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED5B8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830ED5BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830ED5C0: 419A0074  beq cr6, 0x830ed634
	if ctx.cr[6].eq {
	pc = 0x830ED634; continue 'dispatch;
	}
	// 830ED5C4: 80E40004  lwz r7, 4(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED5C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830ED5CC: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 830ED5D0: 40980064  bge cr6, 0x830ed634
	if !ctx.cr[6].lt {
	pc = 0x830ED634; continue 'dispatch;
	}
	// 830ED5D4: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED5D8: 3B81FFD0  addi r28, r1, -0x30
	ctx.r[28].s64 = ctx.r[1].s64 + -48;
	// 830ED5DC: 83A40000  lwz r29, 0(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED5E0: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	pc = 0x830ED634; continue 'dispatch;
            }
            0x830ED634 => {
    //   block [0x830ED634..0x830ED6C8)
	// 830ED634: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED638: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830ED63C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830ED640: 419A0074  beq cr6, 0x830ed6b4
	if ctx.cr[6].eq {
	pc = 0x830ED6B4; continue 'dispatch;
	}
	// 830ED644: 80E50004  lwz r7, 4(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED648: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830ED64C: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 830ED650: 40980064  bge cr6, 0x830ed6b4
	if !ctx.cr[6].lt {
	pc = 0x830ED6B4; continue 'dispatch;
	}
	// 830ED654: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830ED65C: 419A003C  beq cr6, 0x830ed698
	if ctx.cr[6].eq {
	pc = 0x830ED698; continue 'dispatch;
	}
	// 830ED660: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED664: 3B81FFD4  addi r28, r1, -0x2c
	ctx.r[28].s64 = ctx.r[1].s64 + -44;
	// 830ED668: 83A50000  lwz r29, 0(r5)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED66C: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	pc = 0x830ED6C8; continue 'dispatch;
            }
            0x830ED6C8 => {
    //   block [0x830ED6C8..0x830ED6CC)
	// 830ED6C8: 4BBBBD90  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ED6D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830ED6D0 size=264
    let mut pc: u32 = 0x830ED6D0;
    'dispatch: loop {
        match pc {
            0x830ED6D0 => {
    //   block [0x830ED6D0..0x830ED72C)
	// 830ED6D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ED6D4: 4BBBBD25  bl 0x82ca93f8
	ctx.lr = 0x830ED6D8;
	sub_82CA93D0(ctx, base);
	// 830ED6D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830ED6DC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830ED6E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830ED6E4: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 830ED6E8: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 830ED6EC: 38610052  addi r3, r1, 0x52
	ctx.r[3].s64 = ctx.r[1].s64 + 82;
	// 830ED6F0: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	// 830ED6F4: 997A0000  stb r11, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830ED6F8: 4BFFFE99  bl 0x830ed590
	ctx.lr = 0x830ED6FC;
	sub_830ED590(ctx, base);
	// 830ED6FC: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED700: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 830ED704: 83B90004  lwz r29, 4(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED708: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830ED70C: 7F1CC378  mr r28, r24
	ctx.r[28].u64 = ctx.r[24].u64;
	// 830ED710: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830ED714: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830ED718: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830ED71C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 830ED720: 997A0000  stb r11, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830ED724: 409900A8  ble cr6, 0x830ed7cc
	if !ctx.cr[6].gt {
	pc = 0x830ED7CC; continue 'dispatch;
	}
	// 830ED728: 7F1BC378  mr r27, r24
	ctx.r[27].u64 = ctx.r[24].u64;
	pc = 0x830ED72C; continue 'dispatch;
            }
            0x830ED72C => {
    //   block [0x830ED72C..0x830ED748)
	// 830ED72C: 9B010050  stb r24, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u8 ) };
	// 830ED730: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 830ED734: 9B010051  stb r24, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[24].u8 ) };
	// 830ED738: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 830ED73C: 9B010052  stb r24, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[24].u8 ) };
	// 830ED740: 40990040  ble cr6, 0x830ed780
	if !ctx.cr[6].gt {
	pc = 0x830ED780; continue 'dispatch;
	}
	// 830ED744: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	pc = 0x830ED748; continue 'dispatch;
            }
            0x830ED748 => {
    //   block [0x830ED748..0x830ED770)
	// 830ED748: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 830ED74C: 419A0024  beq cr6, 0x830ed770
	if ctx.cr[6].eq {
	pc = 0x830ED770; continue 'dispatch;
	}
	// 830ED750: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED754: 39010052  addi r8, r1, 0x52
	ctx.r[8].s64 = ctx.r[1].s64 + 82;
	// 830ED758: 38E10051  addi r7, r1, 0x51
	ctx.r[7].s64 = ctx.r[1].s64 + 81;
	// 830ED75C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830ED760: 38610053  addi r3, r1, 0x53
	ctx.r[3].s64 = ctx.r[1].s64 + 83;
	// 830ED764: 7CBE5A14  add r5, r30, r11
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 830ED768: 7C9B5A14  add r4, r27, r11
	ctx.r[4].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 830ED76C: 4BFFFD0D  bl 0x830ed478
	ctx.lr = 0x830ED770;
	sub_830ED478(ctx, base);
	pc = 0x830ED770; continue 'dispatch;
            }
            0x830ED770 => {
    //   block [0x830ED770..0x830ED780)
	// 830ED770: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 830ED774: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 830ED778: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830ED77C: 4198FFCC  blt cr6, 0x830ed748
	if ctx.cr[6].lt {
	pc = 0x830ED748; continue 'dispatch;
	}
	pc = 0x830ED780; continue 'dispatch;
            }
            0x830ED780 => {
    //   block [0x830ED780..0x830ED7B4)
	// 830ED780: 897A0000  lbz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830ED788: 419A002C  beq cr6, 0x830ed7b4
	if ctx.cr[6].eq {
	pc = 0x830ED7B4; continue 'dispatch;
	}
	// 830ED78C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830ED790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830ED794: 419A0020  beq cr6, 0x830ed7b4
	if ctx.cr[6].eq {
	pc = 0x830ED7B4; continue 'dispatch;
	}
	// 830ED798: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 830ED79C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830ED7A0: 419A0014  beq cr6, 0x830ed7b4
	if ctx.cr[6].eq {
	pc = 0x830ED7B4; continue 'dispatch;
	}
	// 830ED7A4: 89610052  lbz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 830ED7A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830ED7AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830ED7B0: 409A0008  bne cr6, 0x830ed7b8
	if !ctx.cr[6].eq {
	pc = 0x830ED7B8; continue 'dispatch;
	}
	pc = 0x830ED7B4; continue 'dispatch;
            }
            0x830ED7B4 => {
    //   block [0x830ED7B4..0x830ED7B8)
	// 830ED7B4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x830ED7B8; continue 'dispatch;
            }
            0x830ED7B8 => {
    //   block [0x830ED7B8..0x830ED7CC)
	// 830ED7B8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 830ED7BC: 997A0000  stb r11, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830ED7C0: 3B7B0020  addi r27, r27, 0x20
	ctx.r[27].s64 = ctx.r[27].s64 + 32;
	// 830ED7C4: 7F1CE800  cmpw cr6, r28, r29
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[29].s32, &mut ctx.xer);
	// 830ED7C8: 4198FF64  blt cr6, 0x830ed72c
	if ctx.cr[6].lt {
	pc = 0x830ED72C; continue 'dispatch;
	}
	pc = 0x830ED7CC; continue 'dispatch;
            }
            0x830ED7CC => {
    //   block [0x830ED7CC..0x830ED7D8)
	// 830ED7CC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830ED7D0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830ED7D4: 4BBBBC74  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830ED7D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830ED7D8 size=664
    let mut pc: u32 = 0x830ED7D8;
    'dispatch: loop {
        match pc {
            0x830ED7D8 => {
    //   block [0x830ED7D8..0x830EDA24)
	// 830ED7D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830ED7DC: 4BBBBC15  bl 0x82ca93f0
	ctx.lr = 0x830ED7E0;
	sub_82CA93D0(ctx, base);
	// 830ED7E0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830ED7E4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 830ED7E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830ED7EC: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 830ED7F0: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 830ED7F4: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 830ED7F8: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 830ED7FC: 38610052  addi r3, r1, 0x52
	ctx.r[3].s64 = ctx.r[1].s64 + 82;
	// 830ED800: 997C0000  stb r11, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830ED804: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 830ED808: 4BFFFD89  bl 0x830ed590
	ctx.lr = 0x830ED80C;
	sub_830ED590(ctx, base);
	// 830ED80C: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830ED810: 835B0004  lwz r26, 4(r27)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830ED814: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 830ED818: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 830ED81C: 7ED9B378  mr r25, r22
	ctx.r[25].u64 = ctx.r[22].u64;
	// 830ED820: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 830ED824: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 830ED828: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 830ED82C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 830ED830: 997C0000  stb r11, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830ED834: 409901F0  ble cr6, 0x830eda24
	if !ctx.cr[6].gt {
	pc = 0x830EDA24; continue 'dispatch;
	}
	// 830ED838: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830ED83C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 830ED840: 394A14A0  addi r10, r10, 0x14a0
	ctx.r[10].s64 = ctx.r[10].s64 + 5280;
	// 830ED844: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 830ED848: 396B7530  addi r11, r11, 0x7530
	ctx.r[11].s64 = ctx.r[11].s64 + 30000;
	// 830ED84C: 7EDDB378  mr r29, r22
	ctx.r[29].u64 = ctx.r[22].u64;
	pc = 0x830EDA24; continue 'dispatch;
            }
            0x830EDA24 => {
    //   block [0x830EDA24..0x830EDA70)
	// 830EDA24: 81580004  lwz r10, 4(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EDA28: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 830EDA2C: 40990038  ble cr6, 0x830eda64
	if !ctx.cr[6].gt {
	pc = 0x830EDA64; continue 'dispatch;
	}
	// 830EDA30: 897C0000  lbz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EDA34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EDA38: 419A0024  beq cr6, 0x830eda5c
	if ctx.cr[6].eq {
	pc = 0x830EDA5C; continue 'dispatch;
	}
	// 830EDA3C: 81770008  lwz r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EDA40: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 830EDA44: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 830EDA48: 7D6BD050  subf r11, r11, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[11].s64;
	// 830EDA4C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830EDA50: 356BFFFE  addic. r11, r11, -2
	ctx.xer.ca = (ctx.r[11].u32 > (!(-2 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EDA54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EDA58: 41820008  beq 0x830eda60
	if ctx.cr[0].eq {
	pc = 0x830EDA60; continue 'dispatch;
	}
	// 830EDA5C: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 830EDA60: 997C0000  stb r11, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830EDA64: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830EDA68: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 830EDA6C: 4BBBB9D4  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDA70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EDA70 size=524
    let mut pc: u32 = 0x830EDA70;
    'dispatch: loop {
        match pc {
            0x830EDA70 => {
    //   block [0x830EDA70..0x830EDADC)
	// 830EDA70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EDA74: 4BBBB98D  bl 0x82ca9400
	ctx.lr = 0x830EDA78;
	sub_82CA93D0(ctx, base);
	// 830EDA78: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 830EDA7C: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EDA80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EDA84: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 830EDA88: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 830EDA8C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 830EDA90: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 830EDA94: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 830EDA98: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 830EDA9C: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 830EDAA0: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 830EDAA4: C3FB0014  lfs f31, 0x14(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830EDAA8: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 830EDAAC: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 830EDAB0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 830EDAB4: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 830EDAB8: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 830EDABC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 830EDAC0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 830EDAC4: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 830EDAC8: 40990060  ble cr6, 0x830edb28
	if !ctx.cr[6].gt {
	pc = 0x830EDB28; continue 'dispatch;
	}
	// 830EDACC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830EDAD0: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 830EDAD4: 48000008  b 0x830edadc
	pc = 0x830EDADC; continue 'dispatch;
	// 830EDAD8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
            }
            0x830EDADC => {
    //   block [0x830EDADC..0x830EDAFC)
	// 830EDADC: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830EDAE0: 554A00BE  clrlwi r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 830EDAE4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 830EDAE8: 409A0014  bne cr6, 0x830edafc
	if !ctx.cr[6].eq {
	pc = 0x830EDAFC; continue 'dispatch;
	}
	// 830EDAEC: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 830EDAF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830EDAF4: 4BC694A5  bl 0x82d56f98
	ctx.lr = 0x830EDAF8;
	sub_82D56F98(ctx, base);
	// 830EDAF8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x830EDAFC; continue 'dispatch;
            }
            0x830EDAFC => {
    //   block [0x830EDAFC..0x830EDB28)
	// 830EDAFC: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EDB00: 556A2036  slwi r10, r11, 4
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EDB04: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	pc = 0x830EDB28; continue 'dispatch;
            }
            0x830EDB28 => {
    //   block [0x830EDB28..0x830EDC7C)
	// 830EDB28: 897B0001  lbz r11, 1(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(1 as u32) ) } as u64;
	// 830EDB2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EDB30: 419A0024  beq cr6, 0x830edb54
	if ctx.cr[6].eq {
	pc = 0x830EDB54; continue 'dispatch;
	}
	// 830EDB34: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 830EDB38: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 830EDB3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EDB40: 4BFF9089  bl 0x830e6bc8
	ctx.lr = 0x830EDB44;
	sub_830E6BC8(ctx, base);
	// 830EDB44: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 830EDB48: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 830EDB4C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830EDB50: 4BFF9079  bl 0x830e6bc8
	ctx.lr = 0x830EDB54;
	sub_830E6BC8(ctx, base);
	// 830EDB54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EDB58: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 830EDB5C: 39210068  addi r9, r1, 0x68
	ctx.r[9].s64 = ctx.r[1].s64 + 104;
	// 830EDB60: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 830EDB64: 38E100D0  addi r7, r1, 0xd0
	ctx.r[7].s64 = ctx.r[1].s64 + 208;
	// 830EDB68: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830EDB6C: 997A0000  stb r11, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830EDB70: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830EDB74: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 830EDB78: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 830EDB7C: 4BFFB99D  bl 0x830e9518
	ctx.lr = 0x830EDB80;
	sub_830E9518(ctx, base);
	// 830EDB80: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EDB84: 39010078  addi r8, r1, 0x78
	ctx.r[8].s64 = ctx.r[1].s64 + 120;
	// 830EDB88: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830EDB8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EDB90: 38E10068  addi r7, r1, 0x68
	ctx.r[7].s64 = ctx.r[1].s64 + 104;
	// 830EDB94: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 830EDB98: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830EDB9C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 830EDBA0: 38610051  addi r3, r1, 0x51
	ctx.r[3].s64 = ctx.r[1].s64 + 81;
	// 830EDBA4: 419A000C  beq cr6, 0x830edbb0
	if ctx.cr[6].eq {
	pc = 0x830EDBB0; continue 'dispatch;
	}
	// 830EDBA8: 4BFFFB29  bl 0x830ed6d0
	ctx.lr = 0x830EDBAC;
	sub_830ED6D0(ctx, base);
	// 830EDBAC: 48000008  b 0x830edbb4
	pc = 0x830EDBB4; continue 'dispatch;
	// 830EDBB0: 4BFFFC29  bl 0x830ed7d8
	ctx.lr = 0x830EDBB4;
	sub_830ED7D8(ctx, base);
	// 830EDBB4: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EDBB8: 997A0000  stb r11, 0(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 830EDBBC: 897B0001  lbz r11, 1(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(1 as u32) ) } as u64;
	// 830EDBC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EDBC4: 419A0024  beq cr6, 0x830edbe8
	if ctx.cr[6].eq {
	pc = 0x830EDBE8; continue 'dispatch;
	}
	// 830EDBC8: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 830EDBCC: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 830EDBD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EDBD4: 4BFF91DD  bl 0x830e6db0
	ctx.lr = 0x830EDBD8;
	sub_830E6DB0(ctx, base);
	// 830EDBD8: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 830EDBDC: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 830EDBE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830EDBE4: 4BFF91CD  bl 0x830e6db0
	ctx.lr = 0x830EDBE8;
	sub_830E6DB0(ctx, base);
	// 830EDBE8: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 830EDBEC: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EDBF0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EDBF4: 409A0020  bne cr6, 0x830edc14
	if !ctx.cr[6].eq {
	pc = 0x830EDC14; continue 'dispatch;
	}
	// 830EDBF8: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EDBFC: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830EDC00: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830EDC04: 80810058  lwz r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 830EDC08: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830EDC0C: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830EDC10: 4BC676B9  bl 0x82d552c8
	ctx.lr = 0x830EDC14;
	sub_82D552C8(ctx, base);
	// 830EDC14: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 830EDC18: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EDC1C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EDC20: 409A0020  bne cr6, 0x830edc40
	if !ctx.cr[6].eq {
	pc = 0x830EDC40; continue 'dispatch;
	}
	// 830EDC24: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EDC28: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830EDC2C: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830EDC30: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 830EDC34: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830EDC38: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830EDC3C: 4BC6768D  bl 0x82d552c8
	ctx.lr = 0x830EDC40;
	sub_82D552C8(ctx, base);
	// 830EDC40: 81610080  lwz r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 830EDC44: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 830EDC48: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EDC4C: 409A0020  bne cr6, 0x830edc6c
	if !ctx.cr[6].eq {
	pc = 0x830EDC6C; continue 'dispatch;
	}
	// 830EDC50: 814D0000  lwz r10, 0(r13)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EDC54: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 830EDC58: 38C00016  li r6, 0x16
	ctx.r[6].s64 = 22;
	// 830EDC5C: 80810078  lwz r4, 0x78(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830EDC60: 55652834  slwi r5, r11, 5
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 830EDC64: 7C69502E  lwzx r3, r9, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 830EDC68: 4BC67661  bl 0x82d552c8
	ctx.lr = 0x830EDC6C;
	sub_82D552C8(ctx, base);
	// 830EDC6C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 830EDC70: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 830EDC74: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 830EDC78: 4BBBB7D8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EDC80 size=40
    let mut pc: u32 = 0x830EDC80;
    'dispatch: loop {
        match pc {
            0x830EDC80 => {
    //   block [0x830EDC80..0x830EDCA8)
	// 830EDC80: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830EDC84: 54CB442E  rlwinm r11, r6, 8, 0x10, 0x17
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x00FFFFFFu64;
	// 830EDC88: 5489063E  clrlwi r9, r4, 0x18
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 830EDC8C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830EDC90: 54AA063E  clrlwi r10, r5, 0x18
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 830EDC94: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EDC98: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830EDC9C: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EDCA0: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830EDCA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDCA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EDCA8 size=136
    let mut pc: u32 = 0x830EDCA8;
    'dispatch: loop {
        match pc {
            0x830EDCA8 => {
    //   block [0x830EDCA8..0x830EDD30)
	// 830EDCA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EDCAC: 4BBBB761  bl 0x82ca940c
	ctx.lr = 0x830EDCB0;
	sub_82CA93D0(ctx, base);
	// 830EDCB0: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 830EDCB4: 4BBC0025  bl 0x82cadcd8
	ctx.lr = 0x830EDCB8;
	sub_82CADCA0(ctx, base);
	// 830EDCB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EDCBC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830EDCC0: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 830EDCC4: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 830EDCC8: FF801890  fmr f28, f3
	ctx.f[28].f64 = ctx.f[3].f64;
	// 830EDCCC: C3EB0AE4  lfs f31, 0xae4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2788 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830EDCD0: EC2407F2  fmuls f1, f4, f31
	ctx.f[1].f64 = (((ctx.f[4].f64 * ctx.f[31].f64) as f32) as f64);
	// 830EDCD4: 4BC69975  bl 0x82d57648
	ctx.lr = 0x830EDCD8;
	sub_82D57648(ctx, base);
	// 830EDCD8: EC3E07F2  fmuls f1, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[31].f64) as f32) as f64);
	// 830EDCDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EDCE0: 4BC69969  bl 0x82d57648
	ctx.lr = 0x830EDCE4;
	sub_82D57648(ctx, base);
	// 830EDCE4: EC3D07F2  fmuls f1, f29, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[29].f64 * ctx.f[31].f64) as f32) as f64);
	// 830EDCE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 830EDCEC: 4BC6995D  bl 0x82d57648
	ctx.lr = 0x830EDCF0;
	sub_82D57648(ctx, base);
	// 830EDCF0: EC3C07F2  fmuls f1, f28, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[28].f64 * ctx.f[31].f64) as f32) as f64);
	// 830EDCF4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 830EDCF8: 4BC69951  bl 0x82d57648
	ctx.lr = 0x830EDCFC;
	sub_82D57648(ctx, base);
	// 830EDCFC: 57CA063E  clrlwi r10, r30, 0x18
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 830EDD00: 57EB442E  rlwinm r11, r31, 8, 0x10, 0x17
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x00FFFFFFu64;
	// 830EDD04: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830EDD08: 57AA063E  clrlwi r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 830EDD0C: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EDD10: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830EDD14: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830EDD18: 554A402E  slwi r10, r10, 8
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EDD1C: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830EDD20: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 830EDD24: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 830EDD28: 4BBBFFFD  bl 0x82cadd24
	ctx.lr = 0x830EDD2C;
	sub_82CADCEC(ctx, base);
	// 830EDD2C: 4BBBB730  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EDD30 size=88
    let mut pc: u32 = 0x830EDD30;
    'dispatch: loop {
        match pc {
            0x830EDD30 => {
    //   block [0x830EDD30..0x830EDD88)
	// 830EDD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EDD34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EDD38: DBC1FFE8  stfd f30, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[30].u64 ) };
	// 830EDD3C: DBE1FFF0  stfd f31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 830EDD40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EDD44: 4BC69785  bl 0x82d574c8
	ctx.lr = 0x830EDD48;
	sub_82D574C8(ctx, base);
	// 830EDD48: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830EDD4C: 4BC6977D  bl 0x82d574c8
	ctx.lr = 0x830EDD50;
	sub_82D574C8(ctx, base);
	// 830EDD50: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 830EDD54: 4BC69775  bl 0x82d574c8
	ctx.lr = 0x830EDD58;
	sub_82D574C8(ctx, base);
	// 830EDD58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830EDD5C: FC600890  fmr f3, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[1].f64;
	// 830EDD60: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 830EDD64: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830EDD68: C08B0C14  lfs f4, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 830EDD6C: 4BFFFF3D  bl 0x830edca8
	ctx.lr = 0x830EDD70;
	sub_830EDCA8(ctx, base);
	// 830EDD70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830EDD74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EDD78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EDD7C: CBC1FFE8  lfd f30, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830EDD80: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EDD84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDD88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EDD88 size=440
    let mut pc: u32 = 0x830EDD88;
    'dispatch: loop {
        match pc {
            0x830EDD88 => {
    //   block [0x830EDD88..0x830EDE6C)
	// 830EDD88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EDD8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EDD90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830EDD94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EDD98: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 830EDD9C: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 830EDDA0: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 830EDDA4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EDDA8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830EDDAC: C1450008  lfs f10, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830EDDB0: C1650000  lfs f11, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830EDDB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830EDDB8: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 830EDDBC: C3BF0008  lfs f29, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830EDDC0: EC0AE828  fsubs f0, f10, f29
	ctx.f[0].f64 = (((ctx.f[10].f64 - ctx.f[29].f64) as f32) as f64);
	// 830EDDC4: C3FF0000  lfs f31, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830EDDC8: EDABF828  fsubs f13, f11, f31
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[31].f64) as f32) as f64);
	// 830EDDCC: C06B0C18  lfs f3, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 830EDDD0: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 830EDDD4: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 830EDDD8: ECA0002C  fsqrts f5, f0
	ctx.f[5].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 830EDDDC: FF051800  fcmpu cr6, f5, f3
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[3].f64);
	// 830EDDE0: 419A0138  beq cr6, 0x830edf18
	if ctx.cr[6].eq {
	pc = 0x830EDF18; continue 'dispatch;
	}
	// 830EDDE4: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 830EDDE8: C0DF0004  lfs f6, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 830EDDEC: C0E50004  lfs f7, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 830EDDF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830EDDF4: ECE73028  fsubs f7, f7, f6
	ctx.f[7].f64 = (((ctx.f[7].f64 - ctx.f[6].f64) as f32) as f64);
	// 830EDDF8: C1830008  lfs f12, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830EDDFC: D0E10054  stfs f7, 0x54(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 830EDE00: ED0BF828  fsubs f8, f11, f31
	ctx.f[8].f64 = (((ctx.f[11].f64 - ctx.f[31].f64) as f32) as f64);
	// 830EDE04: D1010050  stfs f8, 0x50(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 830EDE08: EC810072  fmuls f4, f1, f1
	ctx.f[4].f64 = (((ctx.f[1].f64 * ctx.f[1].f64) as f32) as f64);
	// 830EDE0C: C1AB0C14  lfs f13, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EDE10: ED2D2824  fdivs f9, f13, f5
	ctx.f[9].f64 = ((ctx.f[13].f64 / ctx.f[5].f64) as f32) as f64;
	// 830EDE14: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EDE18: ECCDF828  fsubs f6, f13, f31
	ctx.f[6].f64 = (((ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 830EDE1C: ECEA0028  fsubs f7, f10, f0
	ctx.f[7].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 830EDE20: D0E10058  stfs f7, 0x58(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 830EDE24: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 830EDE28: EC4001F2  fmuls f2, f0, f7
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[7].f64) as f32) as f64);
	// 830EDE2C: EC46123A  fmadds f2, f6, f8, f2
	ctx.f[2].f64 = (((ctx.f[6].f64 * ctx.f[8].f64 + ctx.f[2].f64) as f32) as f64);
	// 830EDE30: EFC20272  fmuls f30, f2, f9
	ctx.f[30].f64 = (((ctx.f[2].f64 * ctx.f[9].f64) as f32) as f64);
	// 830EDE34: FF1E1800  fcmpu cr6, f30, f3
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[3].f64);
	// 830EDE38: 4098003C  bge cr6, 0x830ede74
	if !ctx.cr[6].lt {
	pc = 0x830EDE74; continue 'dispatch;
	}
	// 830EDE3C: EC1F6828  fsubs f0, f31, f13
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[13].f64) as f32) as f64);
	// 830EDE40: EDBD6028  fsubs f13, f29, f12
	ctx.f[13].f64 = (((ctx.f[29].f64 - ctx.f[12].f64) as f32) as f64);
	// 830EDE44: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 830EDE48: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 830EDE4C: FF002000  fcmpu cr6, f0, f4
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[4].f64);
	// 830EDE50: 409800C8  bge cr6, 0x830edf18
	if !ctx.cr[6].lt {
	pc = 0x830EDF18; continue 'dispatch;
	}
	// 830EDE54: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830EDE58: 419A00B8  beq cr6, 0x830edf10
	if ctx.cr[6].eq {
	pc = 0x830EDF10; continue 'dispatch;
	}
	// 830EDE5C: D3FE0000  stfs f31, 0(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EDE60: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EDE64: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EDE68: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x830EDE6C; continue 'dispatch;
            }
            0x830EDE6C => {
    //   block [0x830EDE6C..0x830EDE74)
	// 830EDE6C: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830EDE70: 480000A0  b 0x830edf10
	pc = 0x830EDF10; continue 'dispatch;
            }
            0x830EDE74 => {
    //   block [0x830EDE74..0x830EDEB0)
	// 830EDE74: FF1E2800  fcmpu cr6, f30, f5
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[5].f64);
	// 830EDE78: 40990038  ble cr6, 0x830edeb0
	if !ctx.cr[6].gt {
	pc = 0x830EDEB0; continue 'dispatch;
	}
	// 830EDE7C: EC0B6828  fsubs f0, f11, f13
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 830EDE80: EDAA6028  fsubs f13, f10, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 830EDE84: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 830EDE88: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 830EDE8C: FF002000  fcmpu cr6, f0, f4
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[4].f64);
	// 830EDE90: 40980088  bge cr6, 0x830edf18
	if !ctx.cr[6].lt {
	pc = 0x830EDF18; continue 'dispatch;
	}
	// 830EDE94: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830EDE98: 419A0078  beq cr6, 0x830edf10
	if ctx.cr[6].eq {
	pc = 0x830EDF10; continue 'dispatch;
	}
	// 830EDE9C: D17E0000  stfs f11, 0(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EDEA0: C0050004  lfs f0, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EDEA4: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EDEA8: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EDEAC: 4BFFFFC0  b 0x830ede6c
	pc = 0x830EDE6C; continue 'dispatch;
            }
            0x830EDEB0 => {
    //   block [0x830EDEB0..0x830EDF10)
	// 830EDEB0: EC000232  fmuls f0, f0, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[8].f64) as f32) as f64);
	// 830EDEB4: EC0601F8  fmsubs f0, f6, f7, f0
	ctx.f[0].f64 = (((ctx.f[6].f64 * ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 830EDEB8: EC000272  fmuls f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 830EDEBC: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 830EDEC0: FF002000  fcmpu cr6, f0, f4
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[4].f64);
	// 830EDEC4: 40980054  bge cr6, 0x830edf18
	if !ctx.cr[6].lt {
	pc = 0x830EDF18; continue 'dispatch;
	}
	// 830EDEC8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830EDECC: 419A0044  beq cr6, 0x830edf10
	if ctx.cr[6].eq {
	pc = 0x830EDF10; continue 'dispatch;
	}
	// 830EDED0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EDED4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EDED8: 4B191391  bl 0x8227f268
	ctx.lr = 0x830EDEDC;
	sub_8227F268(ctx, base);
	// 830EDEDC: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EDEE0: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EDEE4: EC1E0032  fmuls f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 830EDEE8: C1830008  lfs f12, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830EDEEC: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 830EDEF0: ED8C07B2  fmuls f12, f12, f30
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 830EDEF4: C17F0004  lfs f11, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830EDEF8: EC1F002A  fadds f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 830EDEFC: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EDF00: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 830EDF04: D1BE0004  stfs f13, 4(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EDF08: ED9D602A  fadds f12, f29, f12
	ctx.f[12].f64 = ((ctx.f[29].f64 + ctx.f[12].f64) as f32) as f64;
	// 830EDF0C: D19E0008  stfs f12, 8(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x830EDF10; continue 'dispatch;
            }
            0x830EDF10 => {
    //   block [0x830EDF10..0x830EDF18)
	// 830EDF10: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830EDF14: 48000008  b 0x830edf1c
	pc = 0x830EDF1C; continue 'dispatch;
            }
            0x830EDF18 => {
    //   block [0x830EDF18..0x830EDF1C)
	// 830EDF18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830EDF1C; continue 'dispatch;
            }
            0x830EDF1C => {
    //   block [0x830EDF1C..0x830EDF40)
	// 830EDF1C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 830EDF20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EDF24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EDF28: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 830EDF2C: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 830EDF30: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 830EDF34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830EDF38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EDF3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EDF40 size=20
    let mut pc: u32 = 0x830EDF40;
    'dispatch: loop {
        match pc {
            0x830EDF40 => {
    //   block [0x830EDF40..0x830EDF54)
	// 830EDF40: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830EDF44: 396BDAC0  addi r11, r11, -0x2540
	ctx.r[11].s64 = ctx.r[11].s64 + -9536;
	// 830EDF48: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 830EDF4C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EDF50: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EDF58 size=20
    let mut pc: u32 = 0x830EDF58;
    'dispatch: loop {
        match pc {
            0x830EDF58 => {
    //   block [0x830EDF58..0x830EDF6C)
	// 830EDF58: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830EDF5C: 396BDAC0  addi r11, r11, -0x2540
	ctx.r[11].s64 = ctx.r[11].s64 + -9536;
	// 830EDF60: 816B0074  lwz r11, 0x74(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 830EDF64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EDF68: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDF70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EDF70 size=20
    let mut pc: u32 = 0x830EDF70;
    'dispatch: loop {
        match pc {
            0x830EDF70 => {
    //   block [0x830EDF70..0x830EDF84)
	// 830EDF70: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830EDF74: 396BDAC0  addi r11, r11, -0x2540
	ctx.r[11].s64 = ctx.r[11].s64 + -9536;
	// 830EDF78: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 830EDF7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EDF80: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDF88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EDF88 size=32
    let mut pc: u32 = 0x830EDF88;
    'dispatch: loop {
        match pc {
            0x830EDF88 => {
    //   block [0x830EDF88..0x830EDFA8)
	// 830EDF88: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830EDF8C: 394BA64C  addi r10, r11, -0x59b4
	ctx.r[10].s64 = ctx.r[11].s64 + -22964;
	// 830EDF90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 830EDF94: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830EDF98: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EDF9C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EDFA0: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830EDFA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EDFA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EDFA8 size=128
    let mut pc: u32 = 0x830EDFA8;
    'dispatch: loop {
        match pc {
            0x830EDFA8 => {
    //   block [0x830EDFA8..0x830EDFE8)
	// 830EDFA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EDFAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EDFB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EDFB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EDFB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EDFBC: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830EDFC0: 396BA64C  addi r11, r11, -0x59b4
	ctx.r[11].s64 = ctx.r[11].s64 + -22964;
	// 830EDFC4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EDFC8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EDFCC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EDFD0: 41820018  beq 0x830edfe8
	if ctx.cr[0].eq {
	pc = 0x830EDFE8; continue 'dispatch;
	}
	// 830EDFD4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EDFD8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830EDFDC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EDFE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EDFE4: 4E800421  bctrl
	ctx.lr = 0x830EDFE8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830EDFE8 => {
    //   block [0x830EDFE8..0x830EE008)
	// 830EDFE8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EDFEC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EDFF0: 41820018  beq 0x830ee008
	if ctx.cr[0].eq {
	pc = 0x830EE008; continue 'dispatch;
	}
	// 830EDFF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EDFF8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830EDFFC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EE000: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EE004: 4E800421  bctrl
	ctx.lr = 0x830EE008;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830EE008 => {
    //   block [0x830EE008..0x830EE028)
	// 830EE008: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 830EE00C: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 830EE010: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EE014: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830EE018: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EE01C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EE020: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EE024: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EE028 size=120
    let mut pc: u32 = 0x830EE028;
    'dispatch: loop {
        match pc {
            0x830EE028 => {
    //   block [0x830EE028..0x830EE048)
	// 830EE028: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EE02C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830EE030: 994B0024  stb r10, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[10].u8 ) };
	// 830EE034: 81430284  lwz r10, 0x284(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(644 as u32) ) } as u64;
	// 830EE038: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830EE03C: 409A000C  bne cr6, 0x830ee048
	if !ctx.cr[6].eq {
	pc = 0x830EE048; continue 'dispatch;
	}
	// 830EE040: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830EE044: 91430284  stw r10, 0x284(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(644 as u32), ctx.r[10].u32 ) };
	pc = 0x830EE048; continue 'dispatch;
            }
            0x830EE048 => {
    //   block [0x830EE048..0x830EE05C)
	// 830EE048: 81430288  lwz r10, 0x288(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(648 as u32) ) } as u64;
	// 830EE04C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830EE050: 409A000C  bne cr6, 0x830ee05c
	if !ctx.cr[6].eq {
	pc = 0x830EE05C; continue 'dispatch;
	}
	// 830EE054: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830EE058: 91430288  stw r10, 0x288(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(648 as u32), ctx.r[10].u32 ) };
	pc = 0x830EE05C; continue 'dispatch;
            }
            0x830EE05C => {
    //   block [0x830EE05C..0x830EE070)
	// 830EE05C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830EE060: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE064: 4182000C  beq 0x830ee070
	if ctx.cr[0].eq {
	pc = 0x830EE070; continue 'dispatch;
	}
	// 830EE068: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830EE06C: 912A0020  stw r9, 0x20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	pc = 0x830EE070; continue 'dispatch;
            }
            0x830EE070 => {
    //   block [0x830EE070..0x830EE084)
	// 830EE070: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830EE074: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE078: 4182000C  beq 0x830ee084
	if ctx.cr[0].eq {
	pc = 0x830EE084; continue 'dispatch;
	}
	// 830EE07C: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 830EE080: 912A001C  stw r9, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	pc = 0x830EE084; continue 'dispatch;
            }
            0x830EE084 => {
    //   block [0x830EE084..0x830EE0A0)
	// 830EE084: 8143028C  lwz r10, 0x28c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(652 as u32) ) } as u64;
	// 830EE088: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830EE08C: 81430290  lwz r10, 0x290(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(656 as u32) ) } as u64;
	// 830EE090: 9163028C  stw r11, 0x28c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(652 as u32), ctx.r[11].u32 ) };
	// 830EE094: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 830EE098: 91630290  stw r11, 0x290(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(656 as u32), ctx.r[11].u32 ) };
	// 830EE09C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE0A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EE0A0 size=88
    let mut pc: u32 = 0x830EE0A0;
    'dispatch: loop {
        match pc {
            0x830EE0A0 => {
    //   block [0x830EE0A0..0x830EE0DC)
	// 830EE0A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EE0A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EE0A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830EE0AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EE0B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EE0B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EE0B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830EE0BC: 4BFFFEED  bl 0x830edfa8
	ctx.lr = 0x830EE0C0;
	sub_830EDFA8(ctx, base);
	// 830EE0C0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EE0C4: 41820018  beq 0x830ee0dc
	if ctx.cr[0].eq {
	pc = 0x830EE0DC; continue 'dispatch;
	}
	// 830EE0C8: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830EE0CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EE0D0: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 830EE0D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EE0D8: 4E800421  bctrl
	ctx.lr = 0x830EE0DC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830EE0DC => {
    //   block [0x830EE0DC..0x830EE0F8)
	// 830EE0DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EE0E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830EE0E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EE0E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EE0EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830EE0F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EE0F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EE0F8 size=344
    let mut pc: u32 = 0x830EE0F8;
    'dispatch: loop {
        match pc {
            0x830EE0F8 => {
    //   block [0x830EE0F8..0x830EE158)
	// 830EE0F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EE0FC: 4BBBB30D  bl 0x82ca9408
	ctx.lr = 0x830EE100;
	sub_82CA93D0(ctx, base);
	// 830EE100: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EE104: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830EE108: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EE10C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 830EE110: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 830EE114: 396BA2F0  addi r11, r11, -0x5d10
	ctx.r[11].s64 = ctx.r[11].s64 + -23824;
	// 830EE118: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830EE11C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830EE120: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 830EE124: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EE128: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 830EE12C: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 830EE130: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 830EE134: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 830EE138: 419A010C  beq cr6, 0x830ee244
	if ctx.cr[6].eq {
	pc = 0x830EE244; continue 'dispatch;
	}
	// 830EE13C: 3D6007FF  lis r11, 0x7ff
	ctx.r[11].s64 = 134152192;
	// 830EE140: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 830EE144: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 830EE148: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830EE14C: 57AB2834  slwi r11, r29, 5
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EE150: 40990008  ble cr6, 0x830ee158
	if !ctx.cr[6].gt {
	pc = 0x830EE158; continue 'dispatch;
	}
	// 830EE154: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x830EE158; continue 'dispatch;
            }
            0x830EE158 => {
    //   block [0x830EE158..0x830EE16C)
	// 830EE158: 3940FFFB  li r10, -5
	ctx.r[10].s64 = -5;
	// 830EE15C: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 830EE160: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830EE164: 40990008  ble cr6, 0x830ee16c
	if !ctx.cr[6].gt {
	pc = 0x830EE16C; continue 'dispatch;
	}
	// 830EE168: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	pc = 0x830EE16C; continue 'dispatch;
            }
            0x830EE16C => {
    //   block [0x830EE16C..0x830EE1A0)
	// 830EE16C: 4B5287BD  bl 0x82616928
	ctx.lr = 0x830EE170;
	sub_82616928(ctx, base);
	// 830EE170: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE174: 41820064  beq 0x830ee1d8
	if ctx.cr[0].eq {
	pc = 0x830EE1D8; continue 'dispatch;
	}
	// 830EE178: 38C30004  addi r6, r3, 4
	ctx.r[6].s64 = ctx.r[3].s64 + 4;
	// 830EE17C: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 830EE180: 355DFFFF  addic. r10, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EE184: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 830EE188: 41800048  blt 0x830ee1d0
	if ctx.cr[0].lt {
	pc = 0x830EE1D0; continue 'dispatch;
	}
	// 830EE18C: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 830EE190: 3CE08208  lis r7, -0x7df8
	ctx.r[7].s64 = -2113404928;
	// 830EE194: 3969000C  addi r11, r9, 0xc
	ctx.r[11].s64 = ctx.r[9].s64 + 12;
	// 830EE198: 3908AFB4  addi r8, r8, -0x504c
	ctx.r[8].s64 = ctx.r[8].s64 + -20556;
	// 830EE19C: 38E7A654  addi r7, r7, -0x59ac
	ctx.r[7].s64 = ctx.r[7].s64 + -22956;
	pc = 0x830EE1A0; continue 'dispatch;
            }
            0x830EE1A0 => {
    //   block [0x830EE1A0..0x830EE1D0)
	// 830EE1A0: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 830EE1A4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EE1A8: 910BFFF8  stw r8, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[8].u32 ) };
	// 830EE1AC: 39290020  addi r9, r9, 0x20
	ctx.r[9].s64 = ctx.r[9].s64 + 32;
	// 830EE1B0: 93CBFFFC  stw r30, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[30].u32 ) };
	// 830EE1B4: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 830EE1B8: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 830EE1BC: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 830EE1C0: 93CB000C  stw r30, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 830EE1C4: 9BCB0010  stb r30, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	// 830EE1C8: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 830EE1CC: 4080FFD4  bge 0x830ee1a0
	if !ctx.cr[0].lt {
	pc = 0x830EE1A0; continue 'dispatch;
	}
	pc = 0x830EE1D0; continue 'dispatch;
            }
            0x830EE1D0 => {
    //   block [0x830EE1D0..0x830EE1D8)
	// 830EE1D0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 830EE1D4: 48000008  b 0x830ee1dc
	pc = 0x830EE1DC; continue 'dispatch;
            }
            0x830EE1D8 => {
    //   block [0x830EE1D8..0x830EE1DC)
	// 830EE1D8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x830EE1DC; continue 'dispatch;
            }
            0x830EE1DC => {
    //   block [0x830EE1DC..0x830EE1FC)
	// 830EE1DC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EE1E0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 830EE1E4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830EE1E8: 93CB0014  stw r30, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 830EE1EC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EE1F0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830EE1F4: 4099003C  ble cr6, 0x830ee230
	if !ctx.cr[6].gt {
	pc = 0x830EE230; continue 'dispatch;
	}
	// 830EE1F8: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	pc = 0x830EE1FC; continue 'dispatch;
            }
            0x830EE1FC => {
    //   block [0x830EE1FC..0x830EE230)
	// 830EE1FC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EE200: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830EE204: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 830EE208: 3909FFE0  addi r8, r9, -0x20
	ctx.r[8].s64 = ctx.r[9].s64 + -32;
	// 830EE20C: 91090014  stw r8, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 830EE210: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EE214: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 830EE218: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 830EE21C: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EE220: 91280018  stw r9, 0x18(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 830EE224: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EE228: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830EE22C: 4198FFD0  blt cr6, 0x830ee1fc
	if ctx.cr[6].lt {
	pc = 0x830EE1FC; continue 'dispatch;
	}
	pc = 0x830EE230; continue 'dispatch;
            }
            0x830EE230 => {
    //   block [0x830EE230..0x830EE244)
	// 830EE230: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EE234: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EE238: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 830EE23C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 830EE240: 93CBFFF8  stw r30, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[30].u32 ) };
	pc = 0x830EE244; continue 'dispatch;
            }
            0x830EE244 => {
    //   block [0x830EE244..0x830EE250)
	// 830EE244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EE248: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 830EE24C: 4BBBB20C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EE250 size=124
    let mut pc: u32 = 0x830EE250;
    'dispatch: loop {
        match pc {
            0x830EE250 => {
    //   block [0x830EE250..0x830EE274)
	// 830EE250: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830EE254: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 830EE258: 396BA660  addi r11, r11, -0x59a0
	ctx.r[11].s64 = ctx.r[11].s64 + -22944;
	// 830EE25C: 39000007  li r8, 7
	ctx.r[8].s64 = 7;
	// 830EE260: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 830EE264: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EE268: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830EE26C: 38EBAFB4  addi r7, r11, -0x504c
	ctx.r[7].s64 = ctx.r[11].s64 + -20556;
	// 830EE270: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x830EE274; continue 'dispatch;
            }
            0x830EE274 => {
    //   block [0x830EE274..0x830EE2AC)
	// 830EE274: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EE278: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830EE27C: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 830EE280: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830EE284: 996A0010  stb r11, 0x10(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 830EE288: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 830EE28C: 4080FFE8  bge 0x830ee274
	if !ctx.cr[0].lt {
	pc = 0x830EE274; continue 'dispatch;
	}
	// 830EE290: 916300A4  stw r11, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 830EE294: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 830EE298: 916300A8  stw r11, 0xa8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 830EE29C: 39000007  li r8, 7
	ctx.r[8].s64 = 7;
	// 830EE2A0: 912300AC  stw r9, 0xac(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), ctx.r[9].u32 ) };
	// 830EE2A4: 916300B0  stw r11, 0xb0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 830EE2A8: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x830EE2AC; continue 'dispatch;
            }
            0x830EE2AC => {
    //   block [0x830EE2AC..0x830EE2CC)
	// 830EE2AC: 392A0014  addi r9, r10, 0x14
	ctx.r[9].s64 = ctx.r[10].s64 + 20;
	// 830EE2B0: 914A001C  stw r10, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 830EE2B4: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830EE2B8: 912A000C  stw r9, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 830EE2BC: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 830EE2C0: 4082FFEC  bne 0x830ee2ac
	if !ctx.cr[0].eq {
	pc = 0x830EE2AC; continue 'dispatch;
	}
	// 830EE2C4: 9163009C  stw r11, 0x9c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 830EE2C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EE2D0 size=52
    let mut pc: u32 = 0x830EE2D0;
    'dispatch: loop {
        match pc {
            0x830EE2D0 => {
    //   block [0x830EE2D0..0x830EE304)
	// 830EE2D0: 816400AC  lwz r11, 0xac(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(172 as u32) ) } as u64;
	// 830EE2D4: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EE2D8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE2DC: 40820028  bne 0x830ee304
	if !ctx.cr[0].eq {
		sub_830EE304(ctx, base);
		return;
	}
	// 830EE2E0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830EE2E4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 830EE2E8: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 830EE2EC: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 830EE2F0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830EE2F4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EE2F8: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830EE2FC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830EE300: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE304(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EE304 size=192
    let mut pc: u32 = 0x830EE304;
    'dispatch: loop {
        match pc {
            0x830EE304 => {
    //   block [0x830EE304..0x830EE364)
	// 830EE304: 812400B0  lwz r9, 0xb0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(176 as u32) ) } as u64;
	// 830EE308: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830EE30C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830EE310: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830EE314: 912400B0  stw r9, 0xb0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(176 as u32), ctx.r[9].u32 ) };
	// 830EE318: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EE31C: 912400AC  stw r9, 0xac(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(172 as u32), ctx.r[9].u32 ) };
	// 830EE320: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EE324: 990B0010  stb r8, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[8].u8 ) };
	// 830EE328: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830EE32C: 409A0054  bne cr6, 0x830ee380
	if !ctx.cr[6].eq {
	pc = 0x830EE380; continue 'dispatch;
	}
	// 830EE330: 814400A8  lwz r10, 0xa8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(168 as u32) ) } as u64;
	// 830EE334: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE338: 4082002C  bne 0x830ee364
	if !ctx.cr[0].eq {
	pc = 0x830EE364; continue 'dispatch;
	}
	// 830EE33C: 916400A8  stw r11, 0xa8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 830EE340: 916400A4  stw r11, 0xa4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 830EE344: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830EE348: 812400A4  lwz r9, 0xa4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(164 as u32) ) } as u64;
	// 830EE34C: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830EE350: 812400A8  lwz r9, 0xa8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(168 as u32) ) } as u64;
	// 830EE354: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830EE358: 812400A8  lwz r9, 0xa8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(168 as u32) ) } as u64;
	// 830EE35C: 9149000C  stw r10, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830EE360: 48000044  b 0x830ee3a4
	pc = 0x830EE3A4; continue 'dispatch;
            }
            0x830EE364 => {
    //   block [0x830EE364..0x830EE380)
	// 830EE364: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830EE368: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830EE36C: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 830EE370: 814400A8  lwz r10, 0xa8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(168 as u32) ) } as u64;
	// 830EE374: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830EE378: 916400A8  stw r11, 0xa8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 830EE37C: 48000028  b 0x830ee3a4
	pc = 0x830EE3A4; continue 'dispatch;
            }
            0x830EE380 => {
    //   block [0x830EE380..0x830EE3A0)
	// 830EE380: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE384: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830EE388: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EE38C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE390: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830EE394: 4182000C  beq 0x830ee3a0
	if ctx.cr[0].eq {
	pc = 0x830EE3A0; continue 'dispatch;
	}
	// 830EE398: 9169000C  stw r11, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830EE39C: 48000008  b 0x830ee3a4
	pc = 0x830EE3A4; continue 'dispatch;
            }
            0x830EE3A0 => {
    //   block [0x830EE3A0..0x830EE3A4)
	// 830EE3A0: 916400A4  stw r11, 0xa4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	pc = 0x830EE3A4; continue 'dispatch;
            }
            0x830EE3A4 => {
    //   block [0x830EE3A4..0x830EE3C4)
	// 830EE3A4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 830EE3A8: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EE3AC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 830EE3B0: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 830EE3B4: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 830EE3B8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830EE3BC: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830EE3C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE3C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EE3C8 size=168
    let mut pc: u32 = 0x830EE3C8;
    'dispatch: loop {
        match pc {
            0x830EE3C8 => {
    //   block [0x830EE3C8..0x830EE3FC)
	// 830EE3C8: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830EE3CC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 830EE3D0: 396BA664  addi r11, r11, -0x599c
	ctx.r[11].s64 = ctx.r[11].s64 + -22940;
	// 830EE3D4: 38C30004  addi r6, r3, 4
	ctx.r[6].s64 = ctx.r[3].s64 + 4;
	// 830EE3D8: 38AAAFB4  addi r5, r10, -0x504c
	ctx.r[5].s64 = ctx.r[10].s64 + -20556;
	// 830EE3DC: 3D408208  lis r10, -0x7df8
	ctx.r[10].s64 = -2113404928;
	// 830EE3E0: 7CC93378  mr r9, r6
	ctx.r[9].u64 = ctx.r[6].u64;
	// 830EE3E4: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EE3E8: 388AA650  addi r4, r10, -0x59b0
	ctx.r[4].s64 = ctx.r[10].s64 + -22960;
	// 830EE3EC: 38E0000F  li r7, 0xf
	ctx.r[7].s64 = 15;
	// 830EE3F0: 3969000C  addi r11, r9, 0xc
	ctx.r[11].s64 = ctx.r[9].s64 + 12;
	// 830EE3F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 830EE3F8: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	pc = 0x830EE3FC; continue 'dispatch;
            }
            0x830EE3FC => {
    //   block [0x830EE3FC..0x830EE450)
	// 830EE3FC: 90890000  stw r4, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 830EE400: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 830EE404: 90ABFFF8  stw r5, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[5].u32 ) };
	// 830EE408: 39290028  addi r9, r9, 0x28
	ctx.r[9].s64 = ctx.r[9].s64 + 40;
	// 830EE40C: 914BFFFC  stw r10, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	// 830EE410: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830EE414: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830EE418: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 830EE41C: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 830EE420: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 830EE424: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 830EE428: 994B0018  stb r10, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 830EE42C: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 830EE430: 4080FFCC  bge 0x830ee3fc
	if !ctx.cr[0].lt {
	pc = 0x830EE3FC; continue 'dispatch;
	}
	// 830EE434: 91430284  stw r10, 0x284(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(644 as u32), ctx.r[10].u32 ) };
	// 830EE438: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 830EE43C: 91430288  stw r10, 0x288(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(648 as u32), ctx.r[10].u32 ) };
	// 830EE440: 3920000F  li r9, 0xf
	ctx.r[9].s64 = 15;
	// 830EE444: 90C3028C  stw r6, 0x28c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(652 as u32), ctx.r[6].u32 ) };
	// 830EE448: 91430290  stw r10, 0x290(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(656 as u32), ctx.r[10].u32 ) };
	// 830EE44C: 91430020  stw r10, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	pc = 0x830EE450; continue 'dispatch;
            }
            0x830EE450 => {
    //   block [0x830EE450..0x830EE470)
	// 830EE450: 390B0028  addi r8, r11, 0x28
	ctx.r[8].s64 = ctx.r[11].s64 + 40;
	// 830EE454: 916B0044  stw r11, 0x44(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 830EE458: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EE45C: 910B0020  stw r8, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[8].u32 ) };
	// 830EE460: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 830EE464: 4082FFEC  bne 0x830ee450
	if !ctx.cr[0].eq {
	pc = 0x830EE450; continue 'dispatch;
	}
	// 830EE468: 9143027C  stw r10, 0x27c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(636 as u32), ctx.r[10].u32 ) };
	// 830EE46C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EE470 size=52
    let mut pc: u32 = 0x830EE470;
    'dispatch: loop {
        match pc {
            0x830EE470 => {
    //   block [0x830EE470..0x830EE4A4)
	// 830EE470: 8164028C  lwz r11, 0x28c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(652 as u32) ) } as u64;
	// 830EE474: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EE478: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE47C: 40820028  bne 0x830ee4a4
	if !ctx.cr[0].eq {
		sub_830EE4A4(ctx, base);
		return;
	}
	// 830EE480: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830EE484: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 830EE488: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 830EE48C: 394A9128  addi r10, r10, -0x6ed8
	ctx.r[10].s64 = ctx.r[10].s64 + -28376;
	// 830EE490: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830EE494: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EE498: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830EE49C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830EE4A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE4A4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EE4A4 size=224
    let mut pc: u32 = 0x830EE4A4;
    'dispatch: loop {
        match pc {
            0x830EE4A4 => {
    //   block [0x830EE4A4..0x830EE524)
	// 830EE4A4: 81240290  lwz r9, 0x290(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(656 as u32) ) } as u64;
	// 830EE4A8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 830EE4AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830EE4B0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 830EE4B4: 91240290  stw r9, 0x290(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(656 as u32), ctx.r[9].u32 ) };
	// 830EE4B8: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830EE4BC: 9124028C  stw r9, 0x28c(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(652 as u32), ctx.r[9].u32 ) };
	// 830EE4C0: 81250004  lwz r9, 4(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EE4C4: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 830EE4C8: 81250008  lwz r9, 8(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE4CC: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 830EE4D0: 81250010  lwz r9, 0x10(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EE4D4: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 830EE4D8: 8125000C  lwz r9, 0xc(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EE4DC: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 830EE4E0: 81250014  lwz r9, 0x14(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EE4E4: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 830EE4E8: 990B0024  stb r8, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[8].u8 ) };
	// 830EE4EC: 409A0054  bne cr6, 0x830ee540
	if !ctx.cr[6].eq {
	pc = 0x830EE540; continue 'dispatch;
	}
	// 830EE4F0: 81440288  lwz r10, 0x288(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(648 as u32) ) } as u64;
	// 830EE4F4: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE4F8: 4082002C  bne 0x830ee524
	if !ctx.cr[0].eq {
	pc = 0x830EE524; continue 'dispatch;
	}
	// 830EE4FC: 91640288  stw r11, 0x288(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(648 as u32), ctx.r[11].u32 ) };
	// 830EE500: 91640284  stw r11, 0x284(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(644 as u32), ctx.r[11].u32 ) };
	// 830EE504: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830EE508: 81240284  lwz r9, 0x284(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(644 as u32) ) } as u64;
	// 830EE50C: 9149001C  stw r10, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 830EE510: 81240288  lwz r9, 0x288(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(648 as u32) ) } as u64;
	// 830EE514: 9149001C  stw r10, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 830EE518: 81240288  lwz r9, 0x288(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(648 as u32) ) } as u64;
	// 830EE51C: 91490020  stw r10, 0x20(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830EE520: 48000044  b 0x830ee564
	pc = 0x830EE564; continue 'dispatch;
            }
            0x830EE524 => {
    //   block [0x830EE524..0x830EE540)
	// 830EE524: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 830EE528: 914B001C  stw r10, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 830EE52C: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 830EE530: 81440288  lwz r10, 0x288(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(648 as u32) ) } as u64;
	// 830EE534: 916A0020  stw r11, 0x20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830EE538: 91640288  stw r11, 0x288(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(648 as u32), ctx.r[11].u32 ) };
	// 830EE53C: 48000028  b 0x830ee564
	pc = 0x830EE564; continue 'dispatch;
            }
            0x830EE540 => {
    //   block [0x830EE540..0x830EE560)
	// 830EE540: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 830EE544: 914B0020  stw r10, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 830EE548: 916A001C  stw r11, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 830EE54C: 28090000  cmplwi r9, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE550: 912B001C  stw r9, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 830EE554: 4182000C  beq 0x830ee560
	if ctx.cr[0].eq {
	pc = 0x830EE560; continue 'dispatch;
	}
	// 830EE558: 91690020  stw r11, 0x20(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 830EE55C: 48000008  b 0x830ee564
	pc = 0x830EE564; continue 'dispatch;
            }
            0x830EE560 => {
    //   block [0x830EE560..0x830EE564)
	// 830EE560: 91640284  stw r11, 0x284(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(644 as u32), ctx.r[11].u32 ) };
	pc = 0x830EE564; continue 'dispatch;
            }
            0x830EE564 => {
    //   block [0x830EE564..0x830EE584)
	// 830EE564: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 830EE568: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EE56C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 830EE570: 394AAFB4  addi r10, r10, -0x504c
	ctx.r[10].s64 = ctx.r[10].s64 + -20556;
	// 830EE574: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	// 830EE578: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 830EE57C: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830EE580: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EE588 size=192
    let mut pc: u32 = 0x830EE588;
    'dispatch: loop {
        match pc {
            0x830EE588 => {
    //   block [0x830EE588..0x830EE5C8)
	// 830EE588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EE58C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EE590: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 830EE594: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EE598: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EE59C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EE5A0: 548B07BD  rlwinm. r11, r4, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EE5A4: 4182005C  beq 0x830ee600
	if ctx.cr[0].eq {
	pc = 0x830EE600; continue 'dispatch;
	}
	// 830EE5A8: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 830EE5AC: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 830EE5B0: 556A2834  slwi r10, r11, 5
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 830EE5B4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EE5B8: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 830EE5BC: 41800020  blt 0x830ee5dc
	if ctx.cr[0].lt {
	pc = 0x830EE5DC; continue 'dispatch;
	}
	// 830EE5C0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 830EE5C4: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	pc = 0x830EE5C8; continue 'dispatch;
            }
            0x830EE5C8 => {
    //   block [0x830EE5C8..0x830EE5DC)
	// 830EE5C8: 394AFFE0  addi r10, r10, -0x20
	ctx.r[10].s64 = ctx.r[10].s64 + -32;
	// 830EE5CC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EE5D0: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830EE5D4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830EE5D8: 4080FFF0  bge 0x830ee5c8
	if !ctx.cr[0].lt {
	pc = 0x830EE5C8; continue 'dispatch;
	}
	pc = 0x830EE5DC; continue 'dispatch;
            }
            0x830EE5DC => {
    //   block [0x830EE5DC..0x830EE5F8)
	// 830EE5DC: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EE5E0: 41820018  beq 0x830ee5f8
	if ctx.cr[0].eq {
	pc = 0x830EE5F8; continue 'dispatch;
	}
	// 830EE5E4: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830EE5E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EE5EC: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 830EE5F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EE5F4: 4E800421  bctrl
	ctx.lr = 0x830EE5F8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830EE5F8 => {
    //   block [0x830EE5F8..0x830EE600)
	// 830EE5F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 830EE5FC: 48000034  b 0x830ee630
	pc = 0x830EE630; continue 'dispatch;
            }
            0x830EE600 => {
    //   block [0x830EE600..0x830EE62C)
	// 830EE600: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 830EE604: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EE608: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 830EE60C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EE610: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 830EE614: 41820018  beq 0x830ee62c
	if ctx.cr[0].eq {
	pc = 0x830EE62C; continue 'dispatch;
	}
	// 830EE618: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830EE61C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EE620: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 830EE624: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EE628: 4E800421  bctrl
	ctx.lr = 0x830EE62C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830EE62C => {
    //   block [0x830EE62C..0x830EE630)
	// 830EE62C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x830EE630; continue 'dispatch;
            }
            0x830EE630 => {
    //   block [0x830EE630..0x830EE648)
	// 830EE630: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830EE634: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EE638: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EE63C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 830EE640: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EE644: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EE648 size=108
    let mut pc: u32 = 0x830EE648;
    'dispatch: loop {
        match pc {
            0x830EE648 => {
    //   block [0x830EE648..0x830EE66C)
	// 830EE648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EE64C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EE650: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EE654: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EE658: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EE65C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 830EE660: 397F00A4  addi r11, r31, 0xa4
	ctx.r[11].s64 = ctx.r[31].s64 + 164;
	// 830EE664: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 830EE668: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	pc = 0x830EE66C; continue 'dispatch;
            }
            0x830EE66C => {
    //   block [0x830EE66C..0x830EE69C)
	// 830EE66C: 396BFFEC  addi r11, r11, -0x14
	ctx.r[11].s64 = ctx.r[11].s64 + -20;
	// 830EE670: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EE674: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830EE678: 4080FFF4  bge 0x830ee66c
	if !ctx.cr[0].lt {
	pc = 0x830EE66C; continue 'dispatch;
	}
	// 830EE67C: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EE680: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830EE684: 41820018  beq 0x830ee69c
	if ctx.cr[0].eq {
	pc = 0x830EE69C; continue 'dispatch;
	}
	// 830EE688: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830EE68C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EE690: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 830EE694: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EE698: 4E800421  bctrl
	ctx.lr = 0x830EE69C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830EE69C => {
    //   block [0x830EE69C..0x830EE6B4)
	// 830EE69C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EE6A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830EE6A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EE6A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EE6AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EE6B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EE6B8 size=112
    let mut pc: u32 = 0x830EE6B8;
    'dispatch: loop {
        match pc {
            0x830EE6B8 => {
    //   block [0x830EE6B8..0x830EE6DC)
	// 830EE6B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EE6BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 830EE6C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 830EE6C4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EE6C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EE6CC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 830EE6D0: 397F0284  addi r11, r31, 0x284
	ctx.r[11].s64 = ctx.r[31].s64 + 644;
	// 830EE6D4: 3940000F  li r10, 0xf
	ctx.r[10].s64 = 15;
	// 830EE6D8: 39299128  addi r9, r9, -0x6ed8
	ctx.r[9].s64 = ctx.r[9].s64 + -28376;
	pc = 0x830EE6DC; continue 'dispatch;
            }
            0x830EE6DC => {
    //   block [0x830EE6DC..0x830EE710)
	// 830EE6DC: 396BFFD8  addi r11, r11, -0x28
	ctx.r[11].s64 = ctx.r[11].s64 + -40;
	// 830EE6E0: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EE6E4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 830EE6E8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830EE6EC: 4080FFF0  bge 0x830ee6dc
	if !ctx.cr[0].lt {
	pc = 0x830EE6DC; continue 'dispatch;
	}
	// 830EE6F0: 548B07FF  clrlwi. r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EE6F4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 830EE6F8: 41820018  beq 0x830ee710
	if ctx.cr[0].eq {
	pc = 0x830EE710; continue 'dispatch;
	}
	// 830EE6FC: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830EE700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EE704: 816BDAB4  lwz r11, -0x254c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9548 as u32) ) } as u64;
	// 830EE708: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EE70C: 4E800421  bctrl
	ctx.lr = 0x830EE710;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830EE710 => {
    //   block [0x830EE710..0x830EE728)
	// 830EE710: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EE714: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 830EE718: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 830EE71C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 830EE720: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 830EE724: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EE728 size=60
    let mut pc: u32 = 0x830EE728;
    'dispatch: loop {
        match pc {
            0x830EE728 => {
    //   block [0x830EE728..0x830EE740)
	// 830EE728: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EE72C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EE730: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE734: 41820028  beq 0x830ee75c
	if ctx.cr[0].eq {
	pc = 0x830EE75C; continue 'dispatch;
	}
	// 830EE738: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE73C: 48000018  b 0x830ee754
	pc = 0x830EE754; continue 'dispatch;
            }
            0x830EE740 => {
    //   block [0x830EE740..0x830EE754)
	// 830EE740: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE744: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EE748: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 830EE74C: 419A0018  beq cr6, 0x830ee764
	if ctx.cr[6].eq {
		sub_830EE764(ctx, base);
		return;
	}
	// 830EE750: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	pc = 0x830EE754; continue 'dispatch;
            }
            0x830EE754 => {
    //   block [0x830EE754..0x830EE75C)
	// 830EE754: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE758: 4082FFE8  bne 0x830ee740
	if !ctx.cr[0].eq {
	pc = 0x830EE740; continue 'dispatch;
	}
	pc = 0x830EE75C; continue 'dispatch;
            }
            0x830EE75C => {
    //   block [0x830EE75C..0x830EE764)
	// 830EE75C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EE760: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE764(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x830EE764 size=8
    let mut pc: u32 = 0x830EE764;
    'dispatch: loop {
        match pc {
            0x830EE764 => {
    //   block [0x830EE764..0x830EE76C)
	// 830EE764: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 830EE768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EE770 size=136
    let mut pc: u32 = 0x830EE770;
    'dispatch: loop {
        match pc {
            0x830EE770 => {
    //   block [0x830EE770..0x830EE7A8)
	// 830EE770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EE774: 4BBBAC99  bl 0x82ca940c
	ctx.lr = 0x830EE778;
	sub_82CA93D0(ctx, base);
	// 830EE778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EE77C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 830EE780: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830EE784: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 830EE788: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EE78C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE790: 41820018  beq 0x830ee7a8
	if ctx.cr[0].eq {
	pc = 0x830EE7A8; continue 'dispatch;
	}
	// 830EE794: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EE798: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830EE79C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EE7A0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 830EE7A4: 4E800421  bctrl
	ctx.lr = 0x830EE7A8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x830EE7A8 => {
    //   block [0x830EE7A8..0x830EE7CC)
	// 830EE7A8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 830EE7AC: 419A0020  beq cr6, 0x830ee7cc
	if ctx.cr[6].eq {
	pc = 0x830EE7CC; continue 'dispatch;
	}
	// 830EE7B0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 830EE7B4: 4B528175  bl 0x82616928
	ctx.lr = 0x830EE7B8;
	sub_82616928(ctx, base);
	// 830EE7B8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE7BC: 41820010  beq 0x830ee7cc
	if ctx.cr[0].eq {
	pc = 0x830EE7CC; continue 'dispatch;
	}
	// 830EE7C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EE7C4: 4BFFF935  bl 0x830ee0f8
	ctx.lr = 0x830EE7C8;
	sub_830EE0F8(ctx, base);
	// 830EE7C8: 48000008  b 0x830ee7d0
	pc = 0x830EE7D0; continue 'dispatch;
            }
            0x830EE7CC => {
    //   block [0x830EE7CC..0x830EE7D0)
	// 830EE7CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x830EE7D0; continue 'dispatch;
            }
            0x830EE7D0 => {
    //   block [0x830EE7D0..0x830EE7F8)
	// 830EE7D0: 3D608208  lis r11, -0x7df8
	ctx.r[11].s64 = -2113404928;
	// 830EE7D4: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 830EE7D8: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 830EE7DC: 3BCBA668  addi r30, r11, -0x5998
	ctx.r[30].s64 = ctx.r[11].s64 + -22936;
	// 830EE7E0: 4B1721D9  bl 0x822609b8
	ctx.lr = 0x830EE7E4;
	sub_822609B8(ctx, base);
	// 830EE7E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EE7E8: 4BD92A51  bl 0x82e81238
	ctx.lr = 0x830EE7EC;
	sub_82E81238(ctx, base);
	// 830EE7EC: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 830EE7F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 830EE7F4: 4BBBAC68  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EE7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x830EE7F8 size=644
    let mut pc: u32 = 0x830EE7F8;
    'dispatch: loop {
        match pc {
            0x830EE7F8 => {
    //   block [0x830EE7F8..0x830EE828)
	// 830EE7F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EE7FC: 4BBBABF1  bl 0x82ca93ec
	ctx.lr = 0x830EE800;
	sub_82CA93D0(ctx, base);
	// 830EE800: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EE804: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 830EE808: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 830EE80C: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 830EE810: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EE814: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EE818: 409A007C  bne cr6, 0x830ee894
	if !ctx.cr[6].eq {
	pc = 0x830EE894; continue 'dispatch;
	}
	// 830EE81C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EE820: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE824: 48000044  b 0x830ee868
	pc = 0x830EE868; continue 'dispatch;
            }
            0x830EE828 => {
    //   block [0x830EE828..0x830EE868)
	// 830EE828: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE82C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EE830: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE834: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830EE838: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 830EE83C: 83CB003C  lwz r30, 0x3c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 830EE840: 914B003C  stw r10, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 830EE844: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE848: 4B179739  bl 0x82267f80
	ctx.lr = 0x830EE84C;
	sub_82267F80(ctx, base);
	// 830EE84C: 90760008  stw r3, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 830EE850: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE854: 93CB003C  stw r30, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 830EE858: 81760008  lwz r11, 8(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE85C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EE860: 409A0018  bne cr6, 0x830ee878
	if !ctx.cr[6].eq {
	pc = 0x830EE878; continue 'dispatch;
	}
	// 830EE864: 83FF0018  lwz r31, 0x18(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	pc = 0x830EE868; continue 'dispatch;
            }
            0x830EE868 => {
    //   block [0x830EE868..0x830EE870)
	// 830EE868: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE86C: 4082FFBC  bne 0x830ee828
	if !ctx.cr[0].eq {
	pc = 0x830EE828; continue 'dispatch;
	}
	pc = 0x830EE870; continue 'dispatch;
            }
            0x830EE870 => {
    //   block [0x830EE870..0x830EE878)
	// 830EE870: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EE874: 48000200  b 0x830eea74
	pc = 0x830EEA74; continue 'dispatch;
            }
            0x830EE878 => {
    //   block [0x830EE878..0x830EE894)
	// 830EE878: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE87C: 91760004  stw r11, 4(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EE880: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EE884: 9336000C  stw r25, 0xc(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 830EE888: 91760010  stw r11, 0x10(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830EE88C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EE890: 480001DC  b 0x830eea6c
	pc = 0x830EEA6C; continue 'dispatch;
            }
            0x830EE894 => {
    //   block [0x830EE894..0x830EE8C8)
	// 830EE894: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 830EE898: 816AB734  lwz r11, -0x48cc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18636 as u32) ) } as u64;
	// 830EE89C: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EE8A0: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 830EE8A4: 3BE9B4A0  addi r31, r9, -0x4b60
	ctx.r[31].s64 = ctx.r[9].s64 + -19296;
	// 830EE8A8: 40820020  bne 0x830ee8c8
	if !ctx.cr[0].eq {
	pc = 0x830EE8C8; continue 'dispatch;
	}
	// 830EE8AC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830EE8B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EE8B4: 916AB734  stw r11, -0x48cc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-18636 as u32), ctx.r[11].u32 ) };
	// 830EE8B8: 4BFFFB11  bl 0x830ee3c8
	ctx.lr = 0x830EE8BC;
	sub_830EE3C8(ctx, base);
	// 830EE8BC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 830EE8C0: 386B97F8  addi r3, r11, -0x6808
	ctx.r[3].s64 = ctx.r[11].s64 + -26632;
	// 830EE8C4: 4BBBB65D  bl 0x82ca9f20
	ctx.lr = 0x830EE8C8;
	sub_82CA9F20(ctx, base);
	pc = 0x830EE8C8; continue 'dispatch;
            }
            0x830EE8C8 => {
    //   block [0x830EE8C8..0x830EE8D8)
	// 830EE8C8: 817F0284  lwz r11, 0x284(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 830EE8CC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 830EE8D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EE8D4: 419A002C  beq cr6, 0x830ee900
	if ctx.cr[6].eq {
	pc = 0x830EE900; continue 'dispatch;
	}
	pc = 0x830EE8D8; continue 'dispatch;
            }
            0x830EE8D8 => {
    //   block [0x830EE8D8..0x830EE900)
	// 830EE8D8: 9B8B0024  stb r28, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[28].u8 ) };
	// 830EE8DC: 815F0284  lwz r10, 0x284(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 830EE8E0: 813F028C  lwz r9, 0x28c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(652 as u32) ) } as u64;
	// 830EE8E4: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 830EE8E8: 912A0020  stw r9, 0x20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 830EE8EC: 815F0284  lwz r10, 0x284(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 830EE8F0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE8F4: 915F028C  stw r10, 0x28c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(652 as u32), ctx.r[10].u32 ) };
	// 830EE8F8: 917F0284  stw r11, 0x284(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[11].u32 ) };
	// 830EE8FC: 4082FFDC  bne 0x830ee8d8
	if !ctx.cr[0].eq {
	pc = 0x830EE8D8; continue 'dispatch;
	}
	pc = 0x830EE900; continue 'dispatch;
            }
            0x830EE900 => {
    //   block [0x830EE900..0x830EE938)
	// 830EE900: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 830EE904: 917F0288  stw r11, 0x288(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(648 as u32), ctx.r[11].u32 ) };
	// 830EE908: 917F0290  stw r11, 0x290(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(656 as u32), ctx.r[11].u32 ) };
	// 830EE90C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EE910: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE914: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE918: 4182FF58  beq 0x830ee870
	if ctx.cr[0].eq {
	pc = 0x830EE870; continue 'dispatch;
	}
	// 830EE91C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830EE920: 3BA0FFFF  li r29, -1
	ctx.r[29].s64 = -1;
	// 830EE924: 3B0BAFB4  addi r24, r11, -0x504c
	ctx.r[24].s64 = ctx.r[11].s64 + -20556;
	// 830EE928: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830EE92C: 3B4BAFB4  addi r26, r11, -0x504c
	ctx.r[26].s64 = ctx.r[11].s64 + -20556;
	// 830EE930: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 830EE934: 3AEB9128  addi r23, r11, -0x6ed8
	ctx.r[23].s64 = ctx.r[11].s64 + -28376;
	pc = 0x830EE938; continue 'dispatch;
            }
            0x830EE938 => {
    //   block [0x830EE938..0x830EE9BC)
	// 830EE938: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE93C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EE940: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE944: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830EE948: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 830EE94C: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 830EE950: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 830EE954: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 830EE958: 836B003C  lwz r27, 0x3c(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 830EE95C: 914B003C  stw r10, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 830EE960: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE964: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 830EE968: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 830EE96C: 4B179615  bl 0x82267f80
	ctx.lr = 0x830EE970;
	sub_82267F80(ctx, base);
	// 830EE970: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE974: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE978: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 830EE97C: 936B003C  stw r27, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[27].u32 ) };
	// 830EE980: 4182003C  beq 0x830ee9bc
	if ctx.cr[0].eq {
	pc = 0x830EE9BC; continue 'dispatch;
	}
	// 830EE984: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE988: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830EE98C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830EE990: 9321006C  stw r25, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[25].u32 ) };
	// 830EE994: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EE998: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 830EE99C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830EE9A0: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 830EE9A4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 830EE9A8: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EE9AC: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 830EE9B0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EE9B4: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 830EE9B8: 4BFFFAB9  bl 0x830ee470
	ctx.lr = 0x830EE9BC;
	sub_830EE470(ctx, base);
	pc = 0x830EE9BC; continue 'dispatch;
            }
            0x830EE9BC => {
    //   block [0x830EE9BC..0x830EE9E0)
	// 830EE9BC: 83DE0018  lwz r30, 0x18(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EE9C0: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 830EE9C4: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EE9C8: 4082FF70  bne 0x830ee938
	if !ctx.cr[0].eq {
	pc = 0x830EE938; continue 'dispatch;
	}
	// 830EE9CC: 817F0290  lwz r11, 0x290(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(656 as u32) ) } as u64;
	// 830EE9D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EE9D4: 419AFE9C  beq cr6, 0x830ee870
	if ctx.cr[6].eq {
	pc = 0x830EE870; continue 'dispatch;
	}
	// 830EE9D8: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 830EE9DC: 48000064  b 0x830eea40
	pc = 0x830EEA40; continue 'dispatch;
            }
            0x830EE9E0 => {
    //   block [0x830EE9E0..0x830EEA30)
	// 830EE9E0: 83CB0020  lwz r30, 0x20(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830EE9E4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 830EE9E8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE9EC: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EE9F0: 8079000C  lwz r3, 0xc(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EE9F4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EE9F8: 83AA0004  lwz r29, 4(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EE9FC: 811E000C  lwz r8, 0xc(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EEA00: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830EEA04: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 830EEA08: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EEA0C: 4800165D  bl 0x830f0068
	ctx.lr = 0x830EEA10;
	sub_830F0068(ctx, base);
	// 830EEA10: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830EEA14: 419A001C  beq cr6, 0x830eea30
	if ctx.cr[6].eq {
	pc = 0x830EEA30; continue 'dispatch;
	}
	// 830EEA18: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EEA1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EEA20: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830EEA24: 409A000C  bne cr6, 0x830eea30
	if !ctx.cr[6].eq {
	pc = 0x830EEA30; continue 'dispatch;
	}
	// 830EEA28: 817F0284  lwz r11, 0x284(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 830EEA2C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x830EEA30; continue 'dispatch;
            }
            0x830EEA30 => {
    //   block [0x830EEA30..0x830EEA40)
	// 830EEA30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EEA34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EEA38: 4BFFF5F1  bl 0x830ee028
	ctx.lr = 0x830EEA3C;
	sub_830EE028(ctx, base);
	// 830EEA3C: 817F0290  lwz r11, 0x290(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(656 as u32) ) } as u64;
	pc = 0x830EEA40; continue 'dispatch;
            }
            0x830EEA40 => {
    //   block [0x830EEA40..0x830EEA6C)
	// 830EEA40: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830EEA44: 817F0284  lwz r11, 0x284(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 830EEA48: 4199FF98  bgt cr6, 0x830ee9e0
	if ctx.cr[6].gt {
	pc = 0x830EE9E0; continue 'dispatch;
	}
	// 830EEA4C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EEA50: 91560008  stw r10, 8(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830EEA54: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EEA58: 91560004  stw r10, 4(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830EEA5C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EEA60: 9336000C  stw r25, 0xc(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 830EEA64: 91560010  stw r10, 0x10(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 830EEA68: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	pc = 0x830EEA6C; continue 'dispatch;
            }
            0x830EEA6C => {
    //   block [0x830EEA6C..0x830EEA74)
	// 830EEA6C: 91760014  stw r11, 0x14(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830EEA70: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x830EEA74; continue 'dispatch;
            }
            0x830EEA74 => {
    //   block [0x830EEA74..0x830EEA7C)
	// 830EEA74: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830EEA78: 4BBBA9C4  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EEA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EEA80 size=720
    let mut pc: u32 = 0x830EEA80;
    'dispatch: loop {
        match pc {
            0x830EEA80 => {
    //   block [0x830EEA80..0x830EEAD8)
	// 830EEA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EEA84: 4BBBA961  bl 0x82ca93e4
	ctx.lr = 0x830EEA88;
	sub_82CA93D0(ctx, base);
	// 830EEA88: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 830EEA8C: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EEA90: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 830EEA94: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 830EEA98: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 830EEA9C: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 830EEAA0: 7CD53378  mr r21, r6
	ctx.r[21].u64 = ctx.r[6].u64;
	// 830EEAA4: 816AB9CC  lwz r11, -0x4634(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17972 as u32) ) } as u64;
	// 830EEAA8: 7CF33B78  mr r19, r7
	ctx.r[19].u64 = ctx.r[7].u64;
	// 830EEAAC: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EEAB0: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 830EEAB4: 3BE9B738  addi r31, r9, -0x48c8
	ctx.r[31].s64 = ctx.r[9].s64 + -18632;
	// 830EEAB8: 40820020  bne 0x830eead8
	if !ctx.cr[0].eq {
	pc = 0x830EEAD8; continue 'dispatch;
	}
	// 830EEABC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830EEAC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EEAC4: 916AB9CC  stw r11, -0x4634(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17972 as u32), ctx.r[11].u32 ) };
	// 830EEAC8: 4BFFF901  bl 0x830ee3c8
	ctx.lr = 0x830EEACC;
	sub_830EE3C8(ctx, base);
	// 830EEACC: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 830EEAD0: 386B9848  addi r3, r11, -0x67b8
	ctx.r[3].s64 = ctx.r[11].s64 + -26552;
	// 830EEAD4: 4BBBB44D  bl 0x82ca9f20
	ctx.lr = 0x830EEAD8;
	sub_82CA9F20(ctx, base);
	pc = 0x830EEAD8; continue 'dispatch;
            }
            0x830EEAD8 => {
    //   block [0x830EEAD8..0x830EEAE8)
	// 830EEAD8: 817F0284  lwz r11, 0x284(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 830EEADC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830EEAE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EEAE4: 419A002C  beq cr6, 0x830eeb10
	if ctx.cr[6].eq {
	pc = 0x830EEB10; continue 'dispatch;
	}
	pc = 0x830EEAE8; continue 'dispatch;
            }
            0x830EEAE8 => {
    //   block [0x830EEAE8..0x830EEB10)
	// 830EEAE8: 9B4B0024  stb r26, 0x24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[26].u8 ) };
	// 830EEAEC: 815F0284  lwz r10, 0x284(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 830EEAF0: 813F028C  lwz r9, 0x28c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(652 as u32) ) } as u64;
	// 830EEAF4: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 830EEAF8: 912A0020  stw r9, 0x20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 830EEAFC: 815F0284  lwz r10, 0x284(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 830EEB00: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EEB04: 915F028C  stw r10, 0x28c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(652 as u32), ctx.r[10].u32 ) };
	// 830EEB08: 917F0284  stw r11, 0x284(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(644 as u32), ctx.r[11].u32 ) };
	// 830EEB0C: 4082FFDC  bne 0x830eeae8
	if !ctx.cr[0].eq {
	pc = 0x830EEAE8; continue 'dispatch;
	}
	pc = 0x830EEB10; continue 'dispatch;
            }
            0x830EEB10 => {
    //   block [0x830EEB10..0x830EEB50)
	// 830EEB10: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 830EEB14: 917F0288  stw r11, 0x288(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(648 as u32), ctx.r[11].u32 ) };
	// 830EEB18: 917F0290  stw r11, 0x290(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(656 as u32), ctx.r[11].u32 ) };
	// 830EEB1C: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EEB20: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EEB24: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EEB28: 41820138  beq 0x830eec60
	if ctx.cr[0].eq {
	pc = 0x830EEC60; continue 'dispatch;
	}
	// 830EEB2C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830EEB30: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 830EEB34: 3B2BAFB4  addi r25, r11, -0x504c
	ctx.r[25].s64 = ctx.r[11].s64 + -20556;
	// 830EEB38: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830EEB3C: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	// 830EEB40: 3B6BAFB4  addi r27, r11, -0x504c
	ctx.r[27].s64 = ctx.r[11].s64 + -20556;
	// 830EEB44: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 830EEB48: C3EA0BFC  lfs f31, 0xbfc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 830EEB4C: 3AEB9128  addi r23, r11, -0x6ed8
	ctx.r[23].s64 = ctx.r[11].s64 + -28376;
	pc = 0x830EEB50; continue 'dispatch;
            }
            0x830EEB50 => {
    //   block [0x830EEB50..0x830EEB6C)
	// 830EEB50: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 830EEB54: 419A0040  beq cr6, 0x830eeb94
	if ctx.cr[6].eq {
	pc = 0x830EEB94; continue 'dispatch;
	}
	// 830EEB58: 817300A4  lwz r11, 0xa4(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(164 as u32) ) } as u64;
	// 830EEB5C: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 830EEB60: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EEB64: 41820028  beq 0x830eeb8c
	if ctx.cr[0].eq {
	pc = 0x830EEB8C; continue 'dispatch;
	}
	// 830EEB68: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x830EEB6C; continue 'dispatch;
            }
            0x830EEB6C => {
    //   block [0x830EEB6C..0x830EEB88)
	// 830EEB6C: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EEB70: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830EEB74: 419A0014  beq cr6, 0x830eeb88
	if ctx.cr[6].eq {
	pc = 0x830EEB88; continue 'dispatch;
	}
	// 830EEB78: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EEB7C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EEB80: 4082FFEC  bne 0x830eeb6c
	if !ctx.cr[0].eq {
	pc = 0x830EEB6C; continue 'dispatch;
	}
	// 830EEB84: 48000008  b 0x830eeb8c
	pc = 0x830EEB8C; continue 'dispatch;
            }
            0x830EEB88 => {
    //   block [0x830EEB88..0x830EEB8C)
	// 830EEB88: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x830EEB8C; continue 'dispatch;
            }
            0x830EEB8C => {
    //   block [0x830EEB8C..0x830EEB94)
	// 830EEB8C: 552B063F  clrlwi. r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EEB90: 408200B8  bne 0x830eec48
	if !ctx.cr[0].eq {
	pc = 0x830EEC48; continue 'dispatch;
	}
	pc = 0x830EEB94; continue 'dispatch;
            }
            0x830EEB94 => {
    //   block [0x830EEB94..0x830EEC18)
	// 830EEB94: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EEB98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EEB9C: 81560008  lwz r10, 8(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EEBA0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830EEBA4: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 830EEBA8: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 830EEBAC: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 830EEBB0: 9341006C  stw r26, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[26].u32 ) };
	// 830EEBB4: 83AB003C  lwz r29, 0x3c(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 830EEBB8: 914B003C  stw r10, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 830EEBBC: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EEBC0: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 830EEBC4: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 830EEBC8: 4B1793B9  bl 0x82267f80
	ctx.lr = 0x830EEBCC;
	sub_82267F80(ctx, base);
	// 830EEBCC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EEBD0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EEBD4: 90610068  stw r3, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u32 ) };
	// 830EEBD8: 93AB003C  stw r29, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[29].u32 ) };
	// 830EEBDC: 41820068  beq 0x830eec44
	if ctx.cr[0].eq {
	pc = 0x830EEC44; continue 'dispatch;
	}
	// 830EEBE0: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EEBE4: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 830EEBE8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EEBEC: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 830EEBF0: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EEBF4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 830EEBF8: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 830EEBFC: 419A0020  beq cr6, 0x830eec1c
	if ctx.cr[6].eq {
	pc = 0x830EEC1C; continue 'dispatch;
	}
	// 830EEC00: C1AB000C  lfs f13, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EEC04: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 830EEC08: C0150000  lfs f0, 0(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EEC0C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830EEC10: 41990008  bgt cr6, 0x830eec18
	if ctx.cr[6].gt {
	pc = 0x830EEC18; continue 'dispatch;
	}
	// 830EEC14: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x830EEC18; continue 'dispatch;
            }
            0x830EEC18 => {
    //   block [0x830EEC18..0x830EEC1C)
	// 830EEC18: D0150000  stfs f0, 0(r21)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x830EEC1C; continue 'dispatch;
            }
            0x830EEC1C => {
    //   block [0x830EEC1C..0x830EEC44)
	// 830EEC1C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830EEC20: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 830EEC24: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 830EEC28: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 830EEC2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EEC30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830EEC34: 4BFFF83D  bl 0x830ee470
	ctx.lr = 0x830EEC38;
	sub_830EE470(ctx, base);
	// 830EEC38: 8176000C  lwz r11, 0xc(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EEC3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EEC40: 419A0014  beq cr6, 0x830eec54
	if ctx.cr[6].eq {
	pc = 0x830EEC54; continue 'dispatch;
	}
	pc = 0x830EEC44; continue 'dispatch;
            }
            0x830EEC44 => {
    //   block [0x830EEC44..0x830EEC48)
	// 830EEC44: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	pc = 0x830EEC48; continue 'dispatch;
            }
            0x830EEC48 => {
    //   block [0x830EEC48..0x830EEC54)
	// 830EEC48: 83DE0018  lwz r30, 0x18(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EEC4C: 281E0000  cmplwi r30, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EEC50: 4082FF00  bne 0x830eeb50
	if !ctx.cr[0].eq {
	pc = 0x830EEB50; continue 'dispatch;
	}
	pc = 0x830EEC54; continue 'dispatch;
            }
            0x830EEC54 => {
    //   block [0x830EEC54..0x830EEC60)
	// 830EEC54: 817F0290  lwz r11, 0x290(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(656 as u32) ) } as u64;
	// 830EEC58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EEC5C: 409A000C  bne cr6, 0x830eec68
	if !ctx.cr[6].eq {
	pc = 0x830EEC68; continue 'dispatch;
	}
	pc = 0x830EEC60; continue 'dispatch;
            }
            0x830EEC60 => {
    //   block [0x830EEC60..0x830EEC68)
	// 830EEC60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EEC64: 480000E0  b 0x830eed44
	pc = 0x830EED44; continue 'dispatch;
            }
            0x830EEC68 => {
    //   block [0x830EEC68..0x830EEC7C)
	// 830EEC68: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830EEC6C: 419A007C  beq cr6, 0x830eece8
	if ctx.cr[6].eq {
	pc = 0x830EECE8; continue 'dispatch;
	}
	// 830EEC70: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 830EEC74: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 830EEC78: 40990070  ble cr6, 0x830eece8
	if !ctx.cr[6].gt {
	pc = 0x830EECE8; continue 'dispatch;
	}
	pc = 0x830EEC7C; continue 'dispatch;
            }
            0x830EEC7C => {
    //   block [0x830EEC7C..0x830EECD0)
	// 830EEC7C: 817F0284  lwz r11, 0x284(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 830EEC80: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 830EEC84: 8076000C  lwz r3, 0xc(r22)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EEC88: 83CB0020  lwz r30, 0x20(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 830EEC8C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EEC90: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EEC94: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EEC98: 83AA0004  lwz r29, 4(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EEC9C: 811E000C  lwz r8, 0xc(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EECA0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 830EECA4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 830EECA8: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EECAC: 480013BD  bl 0x830f0068
	ctx.lr = 0x830EECB0;
	sub_830F0068(ctx, base);
	// 830EECB0: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 830EECB4: 419A001C  beq cr6, 0x830eecd0
	if ctx.cr[6].eq {
	pc = 0x830EECD0; continue 'dispatch;
	}
	// 830EECB8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EECBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EECC0: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830EECC4: 409A000C  bne cr6, 0x830eecd0
	if !ctx.cr[6].eq {
	pc = 0x830EECD0; continue 'dispatch;
	}
	// 830EECC8: 817F0284  lwz r11, 0x284(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 830EECCC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x830EECD0; continue 'dispatch;
            }
            0x830EECD0 => {
    //   block [0x830EECD0..0x830EECE8)
	// 830EECD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 830EECD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EECD8: 4BFFF351  bl 0x830ee028
	ctx.lr = 0x830EECDC;
	sub_830EE028(ctx, base);
	// 830EECDC: 817F0290  lwz r11, 0x290(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(656 as u32) ) } as u64;
	// 830EECE0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830EECE4: 4199FF98  bgt cr6, 0x830eec7c
	if ctx.cr[6].gt {
	pc = 0x830EEC7C; continue 'dispatch;
	}
	pc = 0x830EECE8; continue 'dispatch;
            }
            0x830EECE8 => {
    //   block [0x830EECE8..0x830EED40)
	// 830EECE8: 817F0284  lwz r11, 0x284(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(644 as u32) ) } as u64;
	// 830EECEC: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 830EECF0: 38B80004  addi r5, r24, 4
	ctx.r[5].s64 = ctx.r[24].s64 + 4;
	// 830EECF4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EECF8: 91580004  stw r10, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 830EECFC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EED00: 91580008  stw r10, 8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830EED04: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EED08: 91580010  stw r10, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 830EED0C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EED10: 9158000C  stw r10, 0xc(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 830EED14: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EED18: 91780014  stw r11, 0x14(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830EED1C: 419A0024  beq cr6, 0x830eed40
	if ctx.cr[6].eq {
	pc = 0x830EED40; continue 'dispatch;
	}
	// 830EED20: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830EED24: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 830EED28: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 830EED2C: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 830EED30: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 830EED34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 830EED38: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 830EED3C: 4BFFF595  bl 0x830ee2d0
	ctx.lr = 0x830EED40;
	sub_830EE2D0(ctx, base);
	pc = 0x830EED40; continue 'dispatch;
            }
            0x830EED40 => {
    //   block [0x830EED40..0x830EED44)
	// 830EED40: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x830EED44; continue 'dispatch;
            }
            0x830EED44 => {
    //   block [0x830EED44..0x830EED50)
	// 830EED44: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 830EED48: CBE1FF88  lfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 830EED4C: 4BBBA6E8  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EED50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EED50 size=1532
    let mut pc: u32 = 0x830EED50;
    'dispatch: loop {
        match pc {
            0x830EED50 => {
    //   block [0x830EED50..0x830EEE0C)
	// 830EED50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EED54: 4BBBA67D  bl 0x82ca93d0
	ctx.lr = 0x830EED58;
	sub_82CA93D0(ctx, base);
	// 830EED58: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 830EED5C: 4BBBEF59  bl 0x82cadcb4
	ctx.lr = 0x830EED60;
	sub_82CADCA0(ctx, base);
	// 830EED60: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EED64: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 830EED68: FE600890  fmr f19, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[19].f64 = ctx.f[1].f64;
	// 830EED6C: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 830EED70: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 830EED74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 830EED78: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 830EED7C: 814BB388  lwz r10, -0x4c78(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-19576 as u32) ) } as u64;
	// 830EED80: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 830EED84: 7CEE3B78  mr r14, r7
	ctx.r[14].u64 = ctx.r[7].u64;
	// 830EED88: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 830EED8C: 80730010  lwz r3, 0x10(r19)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EED90: 7D1F4378  mr r31, r8
	ctx.r[31].u64 = ctx.r[8].u64;
	// 830EED94: 914BB388  stw r10, -0x4c78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-19576 as u32), ctx.r[10].u32 ) };
	// 830EED98: 4BD9CF41  bl 0x82e8bcd8
	ctx.lr = 0x830EED9C;
	sub_82E8BCD8(ctx, base);
	// 830EED9C: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EEDA0: C1BA0000  lfs f13, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EEDA4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830EEDA8: 409A0064  bne cr6, 0x830eee0c
	if !ctx.cr[6].eq {
	pc = 0x830EEE0C; continue 'dispatch;
	}
	// 830EEDAC: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EEDB0: C19A0008  lfs f12, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830EEDB4: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 830EEDB8: 409A0054  bne cr6, 0x830eee0c
	if !ctx.cr[6].eq {
	pc = 0x830EEE0C; continue 'dispatch;
	}
	// 830EEDBC: D00E0000  stfs f0, 0(r14)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EEDC0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 830EEDC4: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EEDC8: D00E0004  stfs f0, 4(r14)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EEDCC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EEDD0: D00E0008  stfs f0, 8(r14)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830EEDD4: 419A0568  beq cr6, 0x830ef33c
	if ctx.cr[6].eq {
	pc = 0x830EF33C; continue 'dispatch;
	}
	// 830EEDD8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830EEDDC: 419A0560  beq cr6, 0x830ef33c
	if ctx.cr[6].eq {
	pc = 0x830EF33C; continue 'dispatch;
	}
	// 830EEDE0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EEDE4: 917B0004  stw r11, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EEDE8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EEDEC: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EEDF0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EEDF4: 917B0010  stw r11, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 830EEDF8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EEDFC: 917B000C  stw r11, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 830EEE00: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EEE04: 917B0014  stw r11, 0x14(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 830EEE08: 48000534  b 0x830ef33c
	pc = 0x830EF33C; continue 'dispatch;
            }
            0x830EEE0C => {
    //   block [0x830EEE0C..0x830EEE80)
	// 830EEE0C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830EEE10: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EEE14: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 830EEE18: D1A1007C  stfs f13, 0x7c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 830EEE1C: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 830EEE20: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EEE24: D1A10080  stfs f13, 0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 830EEE28: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 830EEE2C: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830EEE30: 92C10094  stw r22, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[22].u32 ) };
	// 830EEE34: 91610090  stw r11, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 830EEE38: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830EEE3C: 92C10098  stw r22, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[22].u32 ) };
	// 830EEE40: 92C1009C  stw r22, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[22].u32 ) };
	// 830EEE44: 916100A0  stw r11, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 830EEE48: 916100A4  stw r11, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 830EEE4C: 419A0034  beq cr6, 0x830eee80
	if ctx.cr[6].eq {
	pc = 0x830EEE80; continue 'dispatch;
	}
	// 830EEE50: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EEE54: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EEE58: 821F0010  lwz r16, 0x10(r31)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EEE5C: 81FF0014  lwz r15, 0x14(r31)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EEE60: 281D0000  cmplwi r29, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EEE64: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 830EEE68: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EEE6C: 93A10094  stw r29, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[29].u32 ) };
	// 830EEE70: 920100A0  stw r16, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[16].u32 ) };
	// 830EEE74: 91E100A4  stw r15, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[15].u32 ) };
	// 830EEE78: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 830EEE7C: 4082007C  bne 0x830eeef8
	if !ctx.cr[0].eq {
	pc = 0x830EEEF8; continue 'dispatch;
	}
	pc = 0x830EEE80; continue 'dispatch;
            }
            0x830EEE80 => {
    //   block [0x830EEE80..0x830EEEEC)
	// 830EEE80: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830EEE84: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EEE88: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 830EEE8C: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 830EEE90: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 830EEE94: 4BFFFBED  bl 0x830eea80
	ctx.lr = 0x830EEE98;
	sub_830EEA80(ctx, base);
	// 830EEE98: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EEE9C: 40820050  bne 0x830eeeec
	if !ctx.cr[0].eq {
	pc = 0x830EEEEC; continue 'dispatch;
	}
	// 830EEEA0: C0010078  lfs f0, 0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EEEA4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 830EEEA8: D00E0000  stfs f0, 0(r14)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EEEAC: C1A1007C  lfs f13, 0x7c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EEEB0: C0010080  lfs f0, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EEEB4: D1AE0004  stfs f13, 4(r14)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EEEB8: D00E0008  stfs f0, 8(r14)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830EEEBC: 419A0480  beq cr6, 0x830ef33c
	if ctx.cr[6].eq {
	pc = 0x830EF33C; continue 'dispatch;
	}
	// 830EEEC0: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 830EEEC4: 81410098  lwz r10, 0x98(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 830EEEC8: 812100A0  lwz r9, 0xa0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 830EEECC: 8101009C  lwz r8, 0x9c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 830EEED0: 80E100A4  lwz r7, 0xa4(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 830EEED4: 917B0004  stw r11, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 830EEED8: 915B0008  stw r10, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 830EEEDC: 913B0010  stw r9, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 830EEEE0: 911B000C  stw r8, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 830EEEE4: 90FB0014  stw r7, 0x14(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[7].u32 ) };
	// 830EEEE8: 48000454  b 0x830ef33c
	pc = 0x830EF33C; continue 'dispatch;
            }
            0x830EEEEC => {
    //   block [0x830EEEEC..0x830EEEF8)
	// 830EEEEC: 81E100A4  lwz r15, 0xa4(r1)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 830EEEF0: 820100A0  lwz r16, 0xa0(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 830EEEF4: 83A10094  lwz r29, 0x94(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	pc = 0x830EEEF8; continue 'dispatch;
            }
            0x830EEEF8 => {
    //   block [0x830EEEF8..0x830EEF2C)
	// 830EEEF8: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 830EEEFC: 816ABA84  lwz r11, -0x457c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17788 as u32) ) } as u64;
	// 830EEF00: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 830EEF04: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 830EEF08: 3BE9B9D0  addi r31, r9, -0x4630
	ctx.r[31].s64 = ctx.r[9].s64 + -17968;
	// 830EEF0C: 40820020  bne 0x830eef2c
	if !ctx.cr[0].eq {
	pc = 0x830EEF2C; continue 'dispatch;
	}
	// 830EEF10: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 830EEF14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 830EEF18: 916ABA84  stw r11, -0x457c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17788 as u32), ctx.r[11].u32 ) };
	// 830EEF1C: 4BFFF335  bl 0x830ee250
	ctx.lr = 0x830EEF20;
	sub_830EE250(ctx, base);
	// 830EEF20: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 830EEF24: 386B9880  addi r3, r11, -0x6780
	ctx.r[3].s64 = ctx.r[11].s64 + -26496;
	// 830EEF28: 4BBBAFF9  bl 0x82ca9f20
	ctx.lr = 0x830EEF2C;
	sub_82CA9F20(ctx, base);
	pc = 0x830EEF2C; continue 'dispatch;
            }
            0x830EEF2C => {
    //   block [0x830EEF2C..0x830EEF38)
	// 830EEF2C: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 830EEF30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EEF34: 419A002C  beq cr6, 0x830eef60
	if ctx.cr[6].eq {
	pc = 0x830EEF60; continue 'dispatch;
	}
	pc = 0x830EEF38; continue 'dispatch;
            }
            0x830EEF38 => {
    //   block [0x830EEF38..0x830EEF60)
	// 830EEF38: 9ACB0010  stb r22, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[22].u8 ) };
	// 830EEF3C: 815F00A4  lwz r10, 0xa4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 830EEF40: 813F00AC  lwz r9, 0xac(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830EEF44: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EEF48: 912A000C  stw r9, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 830EEF4C: 815F00A4  lwz r10, 0xa4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 830EEF50: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EEF54: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 830EEF58: 917F00A4  stw r11, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 830EEF5C: 4082FFDC  bne 0x830eef38
	if !ctx.cr[0].eq {
	pc = 0x830EEF38; continue 'dispatch;
	}
	pc = 0x830EEF60; continue 'dispatch;
            }
            0x830EEF60 => {
    //   block [0x830EEF60..0x830EF01C)
	// 830EEF60: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 830EEF64: 7ED8B378  mr r24, r22
	ctx.r[24].u64 = ctx.r[22].u64;
	// 830EEF68: 917F00A8  stw r11, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 830EEF6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830EEF70: C3CB0BEC  lfs f30, 0xbec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3052 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 830EEF74: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 830EEF78: FFA0F090  fmr f29, f30
	ctx.f[29].f64 = ctx.f[30].f64;
	// 830EEF7C: FF20F090  fmr f25, f30
	ctx.f[25].f64 = ctx.f[30].f64;
	// 830EEF80: 917F00B0  stw r11, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 830EEF84: C01A0000  lfs f0, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EEF88: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EEF8C: 81730004  lwz r11, 4(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EEF90: ED006828  fsubs f8, f0, f13
	ctx.f[8].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830EEF94: C17E0004  lfs f11, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830EEF98: C19A0004  lfs f12, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830EEF9C: ECE06828  fsubs f7, f0, f13
	ctx.f[7].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 830EEFA0: C15A0008  lfs f10, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830EEFA4: EC0C5828  fsubs f0, f12, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 830EEFA8: C13E0008  lfs f9, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830EEFAC: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 830EEFB0: EDAA4828  fsubs f13, f10, f9
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 830EEFB4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 830EEFB8: ED6A4828  fsubs f11, f10, f9
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 830EEFBC: 1E8B000A  mulli r20, r11, 0xa
	ctx.r[20].s32 = ((ctx.r[11].s32 as i64 * 10 as i64) as i32);
	ctx.r[20].s64 = ctx.r[20].s32 as i64;
	// 830EEFC0: ED480232  fmuls f10, f8, f8
	ctx.f[10].f64 = (((ctx.f[8].f64 * ctx.f[8].f64) as f32) as f64);
	// 830EEFC4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 830EEFC8: 28140000  cmplwi r20, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EEFCC: C2EB0C14  lfs f23, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 830EEFD0: EC00503A  fmadds f0, f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 830EEFD4: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 830EEFD8: EF40002C  fsqrts f26, f0
	ctx.f[26].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 830EEFDC: EC17D024  fdivs f0, f23, f26
	ctx.f[0].f64 = ((ctx.f[23].f64 / ctx.f[26].f64) as f32) as f64;
	// 830EEFE0: EF8001F2  fmuls f28, f0, f7
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[7].f64) as f32) as f64);
	// 830EEFE4: EF000332  fmuls f24, f0, f12
	ctx.f[24].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 830EEFE8: EF6002F2  fmuls f27, f0, f11
	ctx.f[27].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 830EEFEC: 41820350  beq 0x830ef33c
	if ctx.cr[0].eq {
	pc = 0x830EF33C; continue 'dispatch;
	}
	// 830EEFF0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830EEFF4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 830EEFF8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 830EEFFC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 830EF000: 3A4BAFB4  addi r18, r11, -0x504c
	ctx.r[18].s64 = ctx.r[11].s64 + -20556;
	// 830EF004: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 830EF008: C2880BFC  lfs f20, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 830EF00C: 3E208334  lis r17, -0x7ccc
	ctx.r[17].s64 = -2093744128;
	// 830EF010: C2C90A4C  lfs f22, 0xa4c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2636 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 830EF014: 3AAB1F68  addi r21, r11, 0x1f68
	ctx.r[21].s64 = ctx.r[11].s64 + 8040;
	// 830EF018: C2AABE14  lfs f21, -0x41ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16876 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	pc = 0x830EF01C; continue 'dispatch;
            }
            0x830EF01C => {
    //   block [0x830EF01C..0x830EF0D0)
	// 830EF01C: C01A0000  lfs f0, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF020: 81730008  lwz r11, 8(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF024: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830EF028: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 830EF02C: C01A0004  lfs f0, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF030: 39210068  addi r9, r1, 0x68
	ctx.r[9].s64 = ctx.r[1].s64 + 104;
	// 830EF034: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 830EF038: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 830EF03C: C01A0008  lfs f0, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF040: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 830EF044: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 830EF048: 83DD003C  lwz r30, 0x3c(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 830EF04C: 917D003C  stw r11, 0x3c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 830EF050: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 830EF054: 839D0064  lwz r28, 0x64(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 830EF058: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 830EF05C: 92BD0064  stw r21, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[21].u32 ) };
	// 830EF060: FC209890  fmr f1, f19
	ctx.f[1].f64 = ctx.f[19].f64;
	// 830EF064: 81410204  lwz r10, 0x204(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(516 as u32) ) } as u64;
	// 830EF068: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 830EF06C: 80810098  lwz r4, 0x98(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 830EF070: 92750004  stw r19, 4(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(4 as u32), ctx.r[19].u32 ) };
	// 830EF074: 4B095365  bl 0x821843d8
	ctx.lr = 0x830EF078;
	sub_821843D8(ctx, base);
	// 830EF078: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 830EF07C: 93DD003C  stw r30, 0x3c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 830EF080: 939D0064  stw r28, 0x64(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 830EF084: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 830EF088: 419A0250  beq cr6, 0x830ef2d8
	if ctx.cr[6].eq {
	pc = 0x830EF2D8; continue 'dispatch;
	}
	// 830EF08C: 397D0040  addi r11, r29, 0x40
	ctx.r[11].s64 = ctx.r[29].s64 + 64;
	// 830EF090: 895D0060  lbz r10, 0x60(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 830EF094: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF098: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 830EF09C: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF0A0: 838B0004  lwz r28, 4(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF0A4: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EF0A8: 832B0008  lwz r25, 8(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF0AC: C18B0018  lfs f12, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830EF0B0: 82EB000C  lwz r23, 0xc(r11)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EF0B4: 4182024C  beq 0x830ef300
	if ctx.cr[0].eq {
	pc = 0x830EF300; continue 'dispatch;
	}
	// 830EF0B8: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 830EF0BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EF0C0: EC0C06FA  fmadds f0, f12, f27, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[27].f64 + ctx.f[0].f64) as f32) as f64);
	// 830EF0C4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830EF0C8: 41990008  bgt cr6, 0x830ef0d0
	if ctx.cr[6].gt {
	pc = 0x830EF0D0; continue 'dispatch;
	}
	// 830EF0CC: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x830EF0D0; continue 'dispatch;
            }
            0x830EF0D0 => {
    //   block [0x830EF0D0..0x830EF0EC)
	// 830EF0D0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EF0D4: 4182022C  beq 0x830ef300
	if ctx.cr[0].eq {
	pc = 0x830EF300; continue 'dispatch;
	}
	// 830EF0D8: 81710718  lwz r11, 0x718(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(1816 as u32) ) } as u64;
	// 830EF0DC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF0E0: 4182000C  beq 0x830ef0ec
	if ctx.cr[0].eq {
	pc = 0x830EF0EC; continue 'dispatch;
	}
	// 830EF0E4: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF0E8: 48000008  b 0x830ef0f0
	pc = 0x830EF0F0; continue 'dispatch;
            }
            0x830EF0EC => {
    //   block [0x830EF0EC..0x830EF0F0)
	// 830EF0EC: FC00B890  fmr f0, f23
	ctx.f[0].f64 = ctx.f[23].f64;
	pc = 0x830EF0F0; continue 'dispatch;
            }
            0x830EF0F0 => {
    //   block [0x830EF0F0..0x830EF124)
	// 830EF0F0: EFE00572  fmuls f31, f0, f21
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[21].f64) as f32) as f64);
	// 830EF0F4: FF1DF000  fcmpu cr6, f29, f30
	ctx.cr[6].compare_f64(ctx.f[29].f64, ctx.f[30].f64);
	// 830EF0F8: 419A002C  beq cr6, 0x830ef124
	if ctx.cr[6].eq {
	pc = 0x830EF124; continue 'dispatch;
	}
	// 830EF0FC: C1A10070  lfs f13, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EF100: ED9F07F2  fmuls f12, f31, f31
	ctx.f[12].f64 = (((ctx.f[31].f64 * ctx.f[31].f64) as f32) as f64);
	// 830EF104: EDB96828  fsubs f13, f25, f13
	ctx.f[13].f64 = (((ctx.f[25].f64 - ctx.f[13].f64) as f32) as f64);
	// 830EF108: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF10C: EC1D0028  fsubs f0, f29, f0
	ctx.f[0].f64 = (((ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 830EF110: ED8C05B2  fmuls f12, f12, f22
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[22].f64) as f32) as f64);
	// 830EF114: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 830EF118: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 830EF11C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 830EF120: 4099004C  ble cr6, 0x830ef16c
	if !ctx.cr[6].gt {
	pc = 0x830EF16C; continue 'dispatch;
	}
	pc = 0x830EF124; continue 'dispatch;
            }
            0x830EF124 => {
    //   block [0x830EF124..0x830EF130)
	// 830EF124: 817F00A4  lwz r11, 0xa4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 830EF128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EF12C: 419A002C  beq cr6, 0x830ef158
	if ctx.cr[6].eq {
	pc = 0x830EF158; continue 'dispatch;
	}
	pc = 0x830EF130; continue 'dispatch;
            }
            0x830EF130 => {
    //   block [0x830EF130..0x830EF158)
	// 830EF130: 9ACB0010  stb r22, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[22].u8 ) };
	// 830EF134: 815F00A4  lwz r10, 0xa4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 830EF138: 813F00AC  lwz r9, 0xac(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 830EF13C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EF140: 912A000C  stw r9, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 830EF144: 815F00A4  lwz r10, 0xa4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 830EF148: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF14C: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 830EF150: 917F00A4  stw r11, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 830EF154: 4082FFDC  bne 0x830ef130
	if !ctx.cr[0].eq {
	pc = 0x830EF130; continue 'dispatch;
	}
	pc = 0x830EF158; continue 'dispatch;
            }
            0x830EF158 => {
    //   block [0x830EF158..0x830EF16C)
	// 830EF158: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	// 830EF15C: C3A10068  lfs f29, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 830EF160: C3210070  lfs f25, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 830EF164: 917F00A8  stw r11, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 830EF168: 917F00B0  stw r11, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	pc = 0x830EF16C; continue 'dispatch;
            }
            0x830EF16C => {
    //   block [0x830EF16C..0x830EF198)
	// 830EF16C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 830EF170: 92410058  stw r18, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[18].u32 ) };
	// 830EF174: 38A10094  addi r5, r1, 0x94
	ctx.r[5].s64 = ctx.r[1].s64 + 148;
	// 830EF178: 92C1005C  stw r22, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[22].u32 ) };
	// 830EF17C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EF180: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 830EF184: 4BFFF14D  bl 0x830ee2d0
	ctx.lr = 0x830EF188;
	sub_830EE2D0(ctx, base);
	// 830EF188: 81730004  lwz r11, 4(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF18C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF190: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF194: 4182016C  beq 0x830ef300
	if ctx.cr[0].eq {
	pc = 0x830EF300; continue 'dispatch;
	}
	pc = 0x830EF198; continue 'dispatch;
            }
            0x830EF198 => {
    //   block [0x830EF198..0x830EF1B4)
	// 830EF198: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF19C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF1A0: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 830EF1A4: 419A0010  beq cr6, 0x830ef1b4
	if ctx.cr[6].eq {
	pc = 0x830EF1B4; continue 'dispatch;
	}
	// 830EF1A8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 830EF1AC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF1B0: 4082FFE8  bne 0x830ef198
	if !ctx.cr[0].eq {
	pc = 0x830EF198; continue 'dispatch;
	}
	pc = 0x830EF1B4; continue 'dispatch;
            }
            0x830EF1B4 => {
    //   block [0x830EF1B4..0x830EF1CC)
	// 830EF1B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EF1B8: 419A0148  beq cr6, 0x830ef300
	if ctx.cr[6].eq {
	pc = 0x830EF300; continue 'dispatch;
	}
	// 830EF1BC: 815F00A4  lwz r10, 0xa4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(164 as u32) ) } as u64;
	// 830EF1C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 830EF1C4: 419A0028  beq cr6, 0x830ef1ec
	if ctx.cr[6].eq {
	pc = 0x830EF1EC; continue 'dispatch;
	}
	// 830EF1C8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x830EF1CC; continue 'dispatch;
            }
            0x830EF1CC => {
    //   block [0x830EF1CC..0x830EF1E8)
	// 830EF1CC: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF1D0: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 830EF1D4: 419A0014  beq cr6, 0x830ef1e8
	if ctx.cr[6].eq {
	pc = 0x830EF1E8; continue 'dispatch;
	}
	// 830EF1D8: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EF1DC: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF1E0: 4082FFEC  bne 0x830ef1cc
	if !ctx.cr[0].eq {
	pc = 0x830EF1CC; continue 'dispatch;
	}
	// 830EF1E4: 48000008  b 0x830ef1ec
	pc = 0x830EF1EC; continue 'dispatch;
            }
            0x830EF1E8 => {
    //   block [0x830EF1E8..0x830EF1EC)
	// 830EF1E8: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x830EF1EC; continue 'dispatch;
            }
            0x830EF1EC => {
    //   block [0x830EF1EC..0x830EF204)
	// 830EF1EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EF1F0: 419A0110  beq cr6, 0x830ef300
	if ctx.cr[6].eq {
	pc = 0x830EF300; continue 'dispatch;
	}
	// 830EF1F4: FF1FD000  fcmpu cr6, f31, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[26].f64);
	// 830EF1F8: 4098000C  bge cr6, 0x830ef204
	if !ctx.cr[6].lt {
	pc = 0x830EF204; continue 'dispatch;
	}
	// 830EF1FC: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 830EF200: 48000008  b 0x830ef208
	pc = 0x830EF208; continue 'dispatch;
            }
            0x830EF204 => {
    //   block [0x830EF204..0x830EF208)
	// 830EF204: EC1A0532  fmuls f0, f26, f20
	ctx.f[0].f64 = (((ctx.f[26].f64 * ctx.f[20].f64) as f32) as f64);
	pc = 0x830EF208; continue 'dispatch;
            }
            0x830EF208 => {
    //   block [0x830EF208..0x830EF250)
	// 830EF208: EDBC0032  fmuls f13, f28, f0
	ctx.f[13].f64 = (((ctx.f[28].f64 * ctx.f[0].f64) as f32) as f64);
	// 830EF20C: C1610068  lfs f11, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830EF210: ED980032  fmuls f12, f24, f0
	ctx.f[12].f64 = (((ctx.f[24].f64 * ctx.f[0].f64) as f32) as f64);
	// 830EF214: C141006C  lfs f10, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 830EF218: EC1B0032  fmuls f0, f27, f0
	ctx.f[0].f64 = (((ctx.f[27].f64 * ctx.f[0].f64) as f32) as f64);
	// 830EF21C: C1210070  lfs f9, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 830EF220: 7EC9B378  mr r9, r22
	ctx.r[9].u64 = ctx.r[22].u64;
	// 830EF224: EDAB6828  fsubs f13, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 830EF228: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 830EF22C: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 830EF230: D181007C  stfs f12, 0x7c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 830EF234: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 830EF238: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 830EF23C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF240: 810A0020  lwz r8, 0x20(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 830EF244: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830EF248: 41980008  blt cr6, 0x830ef250
	if ctx.cr[6].lt {
	pc = 0x830EF250; continue 'dispatch;
	}
	// 830EF24C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x830EF250; continue 'dispatch;
            }
            0x830EF250 => {
    //   block [0x830EF250..0x830EF260)
	// 830EF250: 810A0024  lwz r8, 0x24(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 830EF254: 7F194040  cmplw cr6, r25, r8
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[8].u32, &mut ctx.xer);
	// 830EF258: 41980008  blt cr6, 0x830ef260
	if ctx.cr[6].lt {
	pc = 0x830EF260; continue 'dispatch;
	}
	// 830EF25C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x830EF260; continue 'dispatch;
            }
            0x830EF260 => {
    //   block [0x830EF260..0x830EF288)
	// 830EF260: 5528063F  clrlwi. r8, r9, 0x18
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830EF264: 40820024  bne 0x830ef288
	if !ctx.cr[0].eq {
	pc = 0x830EF288; continue 'dispatch;
	}
	// 830EF268: 814A002C  lwz r10, 0x2c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 830EF26C: 5788103A  slwi r8, r28, 2
	ctx.r[8].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 830EF270: 5727103A  slwi r7, r25, 2
	ctx.r[7].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 830EF274: 7D4A402E  lwzx r10, r10, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830EF278: 7D4A382E  lwzx r10, r10, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 830EF27C: 7F175040  cmplw cr6, r23, r10
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[10].u32, &mut ctx.xer);
	// 830EF280: 41980008  blt cr6, 0x830ef288
	if ctx.cr[6].lt {
	pc = 0x830EF288; continue 'dispatch;
	}
	// 830EF284: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x830EF288; continue 'dispatch;
            }
            0x830EF288 => {
    //   block [0x830EF288..0x830EF2D8)
	// 830EF288: 552A063F  clrlwi. r10, r9, 0x18
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 830EF28C: 40820064  bne 0x830ef2f0
	if !ctx.cr[0].eq {
	pc = 0x830EF2F0; continue 'dispatch;
	}
	// 830EF290: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF294: 5788103A  slwi r8, r28, 2
	ctx.r[8].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 830EF298: 820B000C  lwz r16, 0xc(r11)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EF29C: 5727103A  slwi r7, r25, 2
	ctx.r[7].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 830EF2A0: 81EB0010  lwz r15, 0x10(r11)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 830EF2A4: 1D370064  mulli r9, r23, 0x64
	ctx.r[9].s32 = ((ctx.r[23].s32 as i64 * 100 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 830EF2A8: 816A0028  lwz r11, 0x28(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 830EF2AC: 920100A0  stw r16, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[16].u32 ) };
	// 830EF2B0: 91E100A4  stw r15, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[15].u32 ) };
	// 830EF2B4: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 830EF2B8: 7D6B402E  lwzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 830EF2BC: 7F18A040  cmplw cr6, r24, r20
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[20].u32, &mut ctx.xer);
	// 830EF2C0: 7D6B382E  lwzx r11, r11, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 830EF2C4: 93A10094  stw r29, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[29].u32 ) };
	// 830EF2C8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 830EF2CC: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 830EF2D0: 4198FD4C  blt cr6, 0x830ef01c
	if ctx.cr[6].lt {
	pc = 0x830EF01C; continue 'dispatch;
	}
	// 830EF2D4: 48000068  b 0x830ef33c
	pc = 0x830EF33C; continue 'dispatch;
            }
            0x830EF2D8 => {
    //   block [0x830EF2D8..0x830EF2F0)
	// 830EF2D8: C01A0000  lfs f0, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF2DC: D00E0000  stfs f0, 0(r14)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EF2E0: C01A0004  lfs f0, 4(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF2E4: D00E0004  stfs f0, 4(r14)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EF2E8: C01A0008  lfs f0, 8(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF2EC: 48000028  b 0x830ef314
	pc = 0x830EF314; continue 'dispatch;
            }
            0x830EF2F0 => {
    //   block [0x830EF2F0..0x830EF300)
	// 830EF2F0: D16E0000  stfs f11, 0(r14)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EF2F4: D14E0004  stfs f10, 4(r14)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 830EF2F8: D12E0008  stfs f9, 8(r14)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 830EF2FC: 4800001C  b 0x830ef318
	pc = 0x830EF318; continue 'dispatch;
            }
            0x830EF300 => {
    //   block [0x830EF300..0x830EF314)
	// 830EF300: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF304: C1A1006C  lfs f13, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EF308: D00E0000  stfs f0, 0(r14)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 830EF30C: C0010070  lfs f0, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF310: D1AE0004  stfs f13, 4(r14)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x830EF314; continue 'dispatch;
            }
            0x830EF314 => {
    //   block [0x830EF314..0x830EF318)
	// 830EF314: D00E0008  stfs f0, 8(r14)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x830EF318; continue 'dispatch;
            }
            0x830EF318 => {
    //   block [0x830EF318..0x830EF33C)
	// 830EF318: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 830EF31C: 419A0020  beq cr6, 0x830ef33c
	if ctx.cr[6].eq {
	pc = 0x830EF33C; continue 'dispatch;
	}
	// 830EF320: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 830EF324: 8141009C  lwz r10, 0x9c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 830EF328: 91FB0014  stw r15, 0x14(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[15].u32 ) };
	// 830EF32C: 921B0010  stw r16, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[16].u32 ) };
	// 830EF330: 93BB0004  stw r29, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 830EF334: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 830EF338: 915B000C  stw r10, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x830EF33C; continue 'dispatch;
            }
            0x830EF33C => {
    //   block [0x830EF33C..0x830EF34C)
	// 830EF33C: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 830EF340: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 830EF344: 4BBBE9BD  bl 0x82cadd00
	ctx.lr = 0x830EF348;
	sub_82CADCEC(ctx, base);
	// 830EF348: 4BBBA0D8  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_830EF350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x830EF350 size=696
    let mut pc: u32 = 0x830EF350;
    'dispatch: loop {
        match pc {
            0x830EF350 => {
    //   block [0x830EF350..0x830EF408)
	// 830EF350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 830EF354: 4BBBA0A5  bl 0x82ca93f8
	ctx.lr = 0x830EF358;
	sub_82CA93D0(ctx, base);
	// 830EF358: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 830EF35C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 830EF360: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 830EF364: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 830EF368: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 830EF36C: 396BAFB4  addi r11, r11, -0x504c
	ctx.r[11].s64 = ctx.r[11].s64 + -20556;
	// 830EF370: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 830EF374: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 830EF378: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 830EF37C: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF380: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 830EF384: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 830EF388: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 830EF38C: C19F0000  lfs f12, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 830EF390: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	// 830EF394: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EF398: 93410074  stw r26, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[26].u32 ) };
	// 830EF39C: C17E0004  lfs f11, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 830EF3A0: 93410078  stw r26, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[26].u32 ) };
	// 830EF3A4: D1610064  stfs f11, 0x64(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 830EF3A8: 9341007C  stw r26, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[26].u32 ) };
	// 830EF3AC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 830EF3B0: 91610080  stw r11, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 830EF3B4: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 830EF3B8: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 830EF3BC: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 830EF3C0: 409A00BC  bne cr6, 0x830ef47c
	if !ctx.cr[6].eq {
	pc = 0x830EF47C; continue 'dispatch;
	}
	// 830EF3C4: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF3C8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830EF3CC: 409A00B0  bne cr6, 0x830ef47c
	if !ctx.cr[6].eq {
	pc = 0x830EF47C; continue 'dispatch;
	}
	// 830EF3D0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 830EF3D4: 419A0048  beq cr6, 0x830ef41c
	if ctx.cr[6].eq {
	pc = 0x830EF41C; continue 'dispatch;
	}
	// 830EF3D8: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF3DC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF3E0: 4182003C  beq 0x830ef41c
	if ctx.cr[0].eq {
	pc = 0x830EF41C; continue 'dispatch;
	}
	// 830EF3E4: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF3E8: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF3EC: 41820030  beq 0x830ef41c
	if ctx.cr[0].eq {
	pc = 0x830EF41C; continue 'dispatch;
	}
	// 830EF3F0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830EF3F4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 830EF3F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830EF3FC: 4B19971D  bl 0x82288b18
	ctx.lr = 0x830EF400;
	sub_82288B18(ctx, base);
	// 830EF400: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF404: 4082000C  bne 0x830ef410
	if !ctx.cr[0].eq {
	pc = 0x830EF410; continue 'dispatch;
	}
	pc = 0x830EF408; continue 'dispatch;
            }
            0x830EF408 => {
    //   block [0x830EF408..0x830EF410)
	// 830EF408: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 830EF40C: 480001F0  b 0x830ef5fc
	pc = 0x830EF5FC; continue 'dispatch;
            }
            0x830EF410 => {
    //   block [0x830EF410..0x830EF41C)
	// 830EF410: 839D0004  lwz r28, 4(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF414: 833D0008  lwz r25, 8(r29)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF418: 48000094  b 0x830ef4ac
	pc = 0x830EF4AC; continue 'dispatch;
            }
            0x830EF41C => {
    //   block [0x830EF41C..0x830EF47C)
	// 830EF41C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 830EF420: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EF424: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 830EF428: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EF42C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830EF430: 4BFFF651  bl 0x830eea80
	ctx.lr = 0x830EF434;
	sub_830EEA80(ctx, base);
	// 830EF434: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EF438: 4182FFD0  beq 0x830ef408
	if ctx.cr[0].eq {
	pc = 0x830EF408; continue 'dispatch;
	}
	// 830EF43C: 83810074  lwz r28, 0x74(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 830EF440: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 830EF444: 419AFFC4  beq cr6, 0x830ef408
	if ctx.cr[6].eq {
	pc = 0x830EF408; continue 'dispatch;
	}
	// 830EF448: 83210078  lwz r25, 0x78(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830EF44C: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 830EF450: 419AFFB8  beq cr6, 0x830ef408
	if ctx.cr[6].eq {
	pc = 0x830EF408; continue 'dispatch;
	}
	// 830EF454: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 830EF458: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830EF45C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 830EF460: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 830EF464: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 830EF468: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830EF46C: 4B1996AD  bl 0x82288b18
	ctx.lr = 0x830EF470;
	sub_82288B18(ctx, base);
	// 830EF470: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF474: 40820038  bne 0x830ef4ac
	if !ctx.cr[0].eq {
	pc = 0x830EF4AC; continue 'dispatch;
	}
	// 830EF478: 4BFFFF90  b 0x830ef408
	pc = 0x830EF408; continue 'dispatch;
            }
            0x830EF47C => {
    //   block [0x830EF47C..0x830EF4AC)
	// 830EF47C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 830EF480: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 830EF484: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 830EF488: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 830EF48C: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 830EF490: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 830EF494: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 830EF498: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 830EF49C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 830EF4A0: 4BFFF8B1  bl 0x830eed50
	ctx.lr = 0x830EF4A4;
	sub_830EED50(ctx, base);
	// 830EF4A4: 83210078  lwz r25, 0x78(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 830EF4A8: 83810074  lwz r28, 0x74(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	pc = 0x830EF4AC; continue 'dispatch;
            }
            0x830EF4AC => {
    //   block [0x830EF4AC..0x830EF4E0)
	// 830EF4AC: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF4B0: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EF4B4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830EF4B8: 409A0028  bne cr6, 0x830ef4e0
	if !ctx.cr[6].eq {
	pc = 0x830EF4E0; continue 'dispatch;
	}
	// 830EF4BC: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF4C0: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EF4C4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830EF4C8: 409A0018  bne cr6, 0x830ef4e0
	if !ctx.cr[6].eq {
	pc = 0x830EF4E0; continue 'dispatch;
	}
	// 830EF4CC: C01E0008  lfs f0, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF4D0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 830EF4D4: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EF4D8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 830EF4DC: 419A0008  beq cr6, 0x830ef4e4
	if ctx.cr[6].eq {
	pc = 0x830EF4E4; continue 'dispatch;
	}
	pc = 0x830EF4E0; continue 'dispatch;
            }
            0x830EF4E0 => {
    //   block [0x830EF4E0..0x830EF4E4)
	// 830EF4E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x830EF4E4; continue 'dispatch;
            }
            0x830EF4E4 => {
    //   block [0x830EF4E4..0x830EF4FC)
	// 830EF4E4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 830EF4E8: 4082FF20  bne 0x830ef408
	if !ctx.cr[0].eq {
	pc = 0x830EF408; continue 'dispatch;
	}
	// 830EF4EC: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 830EF4F0: 419A000C  beq cr6, 0x830ef4fc
	if ctx.cr[6].eq {
	pc = 0x830EF4FC; continue 'dispatch;
	}
	// 830EF4F4: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF4F8: 48000008  b 0x830ef500
	pc = 0x830EF500; continue 'dispatch;
            }
            0x830EF4FC => {
    //   block [0x830EF4FC..0x830EF500)
	// 830EF4FC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x830EF500; continue 'dispatch;
            }
            0x830EF500 => {
    //   block [0x830EF500..0x830EF534)
	// 830EF500: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 830EF504: 419A00F4  beq cr6, 0x830ef5f8
	if ctx.cr[6].eq {
	pc = 0x830EF5F8; continue 'dispatch;
	}
	// 830EF508: 817B000C  lwz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EF50C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 830EF510: 409A0030  bne cr6, 0x830ef540
	if !ctx.cr[6].eq {
	pc = 0x830EF540; continue 'dispatch;
	}
	// 830EF514: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 830EF518: C1B90010  lfs f13, 0x10(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EF51C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830EF520: 41990014  bgt cr6, 0x830ef534
	if ctx.cr[6].gt {
	pc = 0x830EF534; continue 'dispatch;
	}
	// 830EF524: C1B90014  lfs f13, 0x14(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 830EF528: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 830EF52C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 830EF530: 40980008  bge cr6, 0x830ef538
	if !ctx.cr[6].lt {
	pc = 0x830EF538; continue 'dispatch;
	}
	pc = 0x830EF534; continue 'dispatch;
            }
            0x830EF534 => {
    //   block [0x830EF534..0x830EF538)
	// 830EF534: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x830EF538; continue 'dispatch;
            }
            0x830EF538 => {
    //   block [0x830EF538..0x830EF540)
	// 830EF538: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 830EF53C: 480000C0  b 0x830ef5fc
	pc = 0x830EF5FC; continue 'dispatch;
            }
            0x830EF540 => {
    //   block [0x830EF540..0x830EF57C)
	// 830EF540: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF544: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EF548: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830EF54C: 83FC003C  lwz r31, 0x3c(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) } as u64;
	// 830EF550: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EF554: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 830EF558: 917C003C  stw r11, 0x3c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 830EF55C: 4B178A25  bl 0x82267f80
	ctx.lr = 0x830EF560;
	sub_82267F80(ctx, base);
	// 830EF560: 93FC003C  stw r31, 0x3c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), ctx.r[31].u32 ) };
	// 830EF564: 7F03C840  cmplw cr6, r3, r25
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[25].u32, &mut ctx.xer);
	// 830EF568: 409AFEA0  bne cr6, 0x830ef408
	if !ctx.cr[6].eq {
	pc = 0x830EF408; continue 'dispatch;
	}
	// 830EF56C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF570: 839C0004  lwz r28, 4(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF574: 83EB0008  lwz r31, 8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF578: 48000078  b 0x830ef5f0
	pc = 0x830EF5F0; continue 'dispatch;
            }
            0x830EF57C => {
    //   block [0x830EF57C..0x830EF5EC)
	// 830EF57C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF580: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF584: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 830EF588: 419A0064  beq cr6, 0x830ef5ec
	if ctx.cr[6].eq {
	pc = 0x830EF5EC; continue 'dispatch;
	}
	// 830EF58C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF590: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 830EF594: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF598: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 830EF59C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EF5A0: 83AB003C  lwz r29, 0x3c(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 830EF5A4: 914B003C  stw r10, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 830EF5A8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF5AC: 4B1789D5  bl 0x82267f80
	ctx.lr = 0x830EF5B0;
	sub_82267F80(ctx, base);
	// 830EF5B0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF5B4: 93AB003C  stw r29, 0x3c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(60 as u32), ctx.r[29].u32 ) };
	// 830EF5B8: 7C681B79  or. r8, r3, r3
	ctx.r[8].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 830EF5BC: 41820030  beq 0x830ef5ec
	if ctx.cr[0].eq {
	pc = 0x830EF5EC; continue 'dispatch;
	}
	// 830EF5C0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF5C4: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 830EF5C8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 830EF5CC: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 830EF5D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 830EF5D4: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF5D8: 48000A91  bl 0x830f0068
	ctx.lr = 0x830EF5DC;
	sub_830F0068(ctx, base);
	// 830EF5DC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 830EF5E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 830EF5E4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 830EF5E8: 419AFE20  beq cr6, 0x830ef408
	if ctx.cr[6].eq {
	pc = 0x830EF408; continue 'dispatch;
	}
	pc = 0x830EF5EC; continue 'dispatch;
            }
            0x830EF5EC => {
    //   block [0x830EF5EC..0x830EF5F0)
	// 830EF5EC: 83FF0018  lwz r31, 0x18(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	pc = 0x830EF5F0; continue 'dispatch;
            }
            0x830EF5F0 => {
    //   block [0x830EF5F0..0x830EF5F8)
	// 830EF5F0: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 830EF5F4: 4082FF88  bne 0x830ef57c
	if !ctx.cr[0].eq {
	pc = 0x830EF57C; continue 'dispatch;
	}
	pc = 0x830EF5F8; continue 'dispatch;
            }
            0x830EF5F8 => {
    //   block [0x830EF5F8..0x830EF5FC)
	// 830EF5F8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x830EF5FC; continue 'dispatch;
            }
            0x830EF5FC => {
    //   block [0x830EF5FC..0x830EF608)
	// 830EF5FC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 830EF600: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 830EF604: 4BBB9E44  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


