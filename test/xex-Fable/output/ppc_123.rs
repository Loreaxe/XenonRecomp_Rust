pub fn sub_82C643D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C643D0 size=12
    let mut pc: u32 = 0x82C643D0;
    'dispatch: loop {
        match pc {
            0x82C643D0 => {
    //   block [0x82C643D0..0x82C643DC)
	// 82C643D0: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82C643D4: 419A0008  beq cr6, 0x82c643dc
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C643DC);
		return;
	}
	// 82C643D8: 4BFFFF98  b 0x82c64370
	sub_82C64370(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C643E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C643E0 size=88
    let mut pc: u32 = 0x82C643E0;
    'dispatch: loop {
        match pc {
            0x82C643E0 => {
    //   block [0x82C643E0..0x82C64438)
	// 82C643E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C643E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C643E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C643EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C643F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C643F4: 4BFFEF2D  bl 0x82c63320
	ctx.lr = 0x82C643F8;
	sub_82C63320(ctx, base);
	// 82C643F8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C643FC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C64400: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C64404: 3909DCE8  addi r8, r9, -0x2318
	ctx.r[8].s64 = ctx.r[9].s64 + -8984;
	// 82C64408: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82C6440C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C64410: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C64414: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C64418: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82C6441C: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82C64420: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82C64424: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C64428: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6442C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C64430: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C64434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C64438 size=16
    let mut pc: u32 = 0x82C64438;
    'dispatch: loop {
        match pc {
            0x82C64438 => {
    //   block [0x82C64438..0x82C64448)
	// 82C64438: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C6443C: 394BDCE8  addi r10, r11, -0x2318
	ctx.r[10].s64 = ctx.r[11].s64 + -8984;
	// 82C64440: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C64444: 4BFFF004  b 0x82c63448
	crate::recompiler::externs::call(ctx, base, 0x82C63448);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C64448 size=424
    let mut pc: u32 = 0x82C64448;
    'dispatch: loop {
        match pc {
            0x82C64448 => {
    //   block [0x82C64448..0x82C64498)
	// 82C64448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6444C: 48044FB5  bl 0x82ca9400
	ctx.lr = 0x82C64450;
	sub_82CA93D0(ctx, base);
	// 82C64450: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C64454: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C64458: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82C6445C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C64460: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C64464: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C64468: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82C6446C: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C64470: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 82C64474: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C64478: 7D0B5215  add. r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82C6447C: 4081001C  ble 0x82c64498
	if !ctx.cr[0].gt {
	pc = 0x82C64498; continue 'dispatch;
	}
	// 82C64480: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C64484: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C64488: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82C6448C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C64490: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82C64494: 48045475  bl 0x82ca9908
	ctx.lr = 0x82C64498;
	sub_82CA9908(ctx, base);
	pc = 0x82C64498; continue 'dispatch;
            }
            0x82C64498 => {
    //   block [0x82C64498..0x82C644B8)
	// 82C64498: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C6449C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C644A0: 40990018  ble cr6, 0x82c644b8
	if !ctx.cr[6].gt {
	pc = 0x82C644B8; continue 'dispatch;
	}
	// 82C644A4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C644A8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C644AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C644B0: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82C644B4: 48045455  bl 0x82ca9908
	ctx.lr = 0x82C644B8;
	sub_82CA9908(ctx, base);
	pc = 0x82C644B8; continue 'dispatch;
            }
            0x82C644B8 => {
    //   block [0x82C644B8..0x82C644C0)
	// 82C644B8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82C644BC: 40990104  ble cr6, 0x82c645c0
	if !ctx.cr[6].gt {
	pc = 0x82C645C0; continue 'dispatch;
	}
	pc = 0x82C644C0; continue 'dispatch;
            }
            0x82C644C0 => {
    //   block [0x82C644C0..0x82C644D8)
	// 82C644C0: 83DF0088  lwz r30, 0x88(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82C644C4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C644C8: 409900D0  ble cr6, 0x82c64598
	if !ctx.cr[6].gt {
	pc = 0x82C64598; continue 'dispatch;
	}
	// 82C644CC: 7F1EE800  cmpw cr6, r30, r29
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82C644D0: 41980008  blt cr6, 0x82c644d8
	if ctx.cr[6].lt {
	pc = 0x82C644D8; continue 'dispatch;
	}
	// 82C644D4: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x82C644D8; continue 'dispatch;
            }
            0x82C644D8 => {
    //   block [0x82C644D8..0x82C6451C)
	// 82C644D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C644DC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C644E0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82C644E4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82C644E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C644EC: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C644F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C644F4: 4E800421  bctrl
	ctx.lr = 0x82C644F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C644F8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C644FC: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C64500: 7D2B5215  add. r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C64504: 40810030  ble 0x82c64534
	if !ctx.cr[0].gt {
	pc = 0x82C64534; continue 'dispatch;
	}
	// 82C64508: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C6450C: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C64510: 57C8103A  slwi r8, r30, 2
	ctx.r[8].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C64514: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82C64518: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
            }
            0x82C6451C => {
    //   block [0x82C6451C..0x82C64534)
	// 82C6451C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C64520: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C64524: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82C64528: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C6452C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C64530: 4082FFEC  bne 0x82c6451c
	if !ctx.cr[0].eq {
	pc = 0x82C6451C; continue 'dispatch;
	}
	pc = 0x82C64534; continue 'dispatch;
            }
            0x82C64534 => {
    //   block [0x82C64534..0x82C6454C)
	// 82C64534: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C64538: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C6453C: 40990028  ble cr6, 0x82c64564
	if !ctx.cr[6].gt {
	pc = 0x82C64564; continue 'dispatch;
	}
	// 82C64540: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C64544: 57C8103A  slwi r8, r30, 2
	ctx.r[8].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C64548: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	pc = 0x82C6454C; continue 'dispatch;
            }
            0x82C6454C => {
    //   block [0x82C6454C..0x82C64564)
	// 82C6454C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C64550: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C64554: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82C64558: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C6455C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C64560: 4082FFEC  bne 0x82c6454c
	if !ctx.cr[0].eq {
	pc = 0x82C6454C; continue 'dispatch;
	}
	pc = 0x82C64564; continue 'dispatch;
            }
            0x82C64564 => {
    //   block [0x82C64564..0x82C6458C)
	// 82C64564: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82C64568: 7FBEE850  subf r29, r30, r29
	ctx.r[29].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82C6456C: 7D5E5851  subf. r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C64570: 915F0088  stw r10, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 82C64574: 40820018  bne 0x82c6458c
	if !ctx.cr[0].eq {
	pc = 0x82C6458C; continue 'dispatch;
	}
	// 82C64578: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6457C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C64580: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C64584: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C64588: 4E800421  bctrl
	ctx.lr = 0x82C6458C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6458C => {
    //   block [0x82C6458C..0x82C64598)
	// 82C6458C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82C64590: 4199FF30  bgt cr6, 0x82c644c0
	if ctx.cr[6].gt {
	pc = 0x82C644C0; continue 'dispatch;
	}
	// 82C64594: 4800002C  b 0x82c645c0
	pc = 0x82C645C0; continue 'dispatch;
            }
            0x82C64598 => {
    //   block [0x82C64598..0x82C645C0)
	// 82C64598: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6459C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82C645A0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82C645A4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82C645A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C645AC: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C645B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C645B4: 4E800421  bctrl
	ctx.lr = 0x82C645B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C645B8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82C645BC: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
            }
            0x82C645C0 => {
    //   block [0x82C645C0..0x82C645F0)
	// 82C645C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C645C4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82C645C8: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82C645CC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82C645D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C645D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C645D8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C645DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C645E0: 4E800421  bctrl
	ctx.lr = 0x82C645E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C645E4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C645E8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82C645EC: 48044E64  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C645F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C645F0 size=8
    let mut pc: u32 = 0x82C645F0;
    'dispatch: loop {
        match pc {
            0x82C645F0 => {
    //   block [0x82C645F0..0x82C645F8)
	// 82C645F0: 9083008C  stw r4, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 82C645F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C64600 size=128
    let mut pc: u32 = 0x82C64600;
    'dispatch: loop {
        match pc {
            0x82C64600 => {
    //   block [0x82C64600..0x82C64680)
	// 82C64600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C64604: 48044E09  bl 0x82ca940c
	ctx.lr = 0x82C64608;
	sub_82CA93D0(ctx, base);
	// 82C64608: 3BE1FF90  addi r31, r1, -0x70
	ctx.r[31].s64 = ctx.r[1].s64 + -112;
	// 82C6460C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C64610: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C64614: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 82C64618: 93DF0084  stw r30, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82C6461C: 4BFFFDC5  bl 0x82c643e0
	ctx.lr = 0x82C64620;
	sub_82C643E0(ctx, base);
	// 82C64620: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C64624: 387E009C  addi r3, r30, 0x9c
	ctx.r[3].s64 = ctx.r[30].s64 + 156;
	// 82C64628: 394BDD10  addi r10, r11, -0x22f0
	ctx.r[10].s64 = ctx.r[11].s64 + -8944;
	// 82C6462C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82C64630: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C64634: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C64638: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6463C: 48002FAD  bl 0x82c675e8
	ctx.lr = 0x82C64640;
	sub_82C675E8(ctx, base);
	// 82C64640: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C64644: 913E0098  stw r9, 0x98(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(152 as u32), ctx.r[9].u32 ) };
	// 82C64648: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6464C: 383F0070  addi r1, r31, 0x70
	ctx.r[1].s64 = ctx.r[31].s64 + 112;
	// 82C64650: 48044E0C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 82C64654: 3BECFF90  addi r31, r12, -0x70
	ctx.r[31].s64 = ctx.r[12].s64 + -112;
	// 82C64658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6465C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C64660: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C64664: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82C64668: 4BFFFDD1  bl 0x82c64438
	ctx.lr = 0x82C6466C;
	sub_82C64438(ctx, base);
	// 82C6466C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C64670: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C64674: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C64678: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C64688 size=124
    let mut pc: u32 = 0x82C64688;
    'dispatch: loop {
        match pc {
            0x82C64688 => {
    //   block [0x82C64688..0x82C64704)
	// 82C64688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6468C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C64690: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C64694: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C64698: 3BE1FF90  addi r31, r1, -0x70
	ctx.r[31].s64 = ctx.r[1].s64 + -112;
	// 82C6469C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C646A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C646A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C646A8: 93DF0084  stw r30, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82C646AC: 394BDD10  addi r10, r11, -0x22f0
	ctx.r[10].s64 = ctx.r[11].s64 + -8944;
	// 82C646B0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C646B4: 387E009C  addi r3, r30, 0x9c
	ctx.r[3].s64 = ctx.r[30].s64 + 156;
	// 82C646B8: 48002F99  bl 0x82c67650
	ctx.lr = 0x82C646BC;
	sub_82C67650(ctx, base);
	// 82C646BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C646C0: 4BFFFD79  bl 0x82c64438
	ctx.lr = 0x82C646C4;
	sub_82C64438(ctx, base);
	// 82C646C4: 383F0070  addi r1, r31, 0x70
	ctx.r[1].s64 = ctx.r[31].s64 + 112;
	// 82C646C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C646CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C646D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C646D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C646D8: 4E800020  blr
	return;
	// 82C646DC: 3BECFF90  addi r31, r12, -0x70
	ctx.r[31].s64 = ctx.r[12].s64 + -112;
	// 82C646E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C646E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C646E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C646EC: 807F0084  lwz r3, 0x84(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 82C646F0: 4BFFFD49  bl 0x82c64438
	ctx.lr = 0x82C646F4;
	sub_82C64438(ctx, base);
	// 82C646F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C646F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C646FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C64700: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C64708 size=64
    let mut pc: u32 = 0x82C64708;
    'dispatch: loop {
        match pc {
            0x82C64708 => {
    //   block [0x82C64708..0x82C64748)
	// 82C64708: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6470C: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C64710: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C64714: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C64718: 7C8B07B4  extsw r11, r4
	ctx.r[11].s64 = ctx.r[4].s32 as i64;
	// 82C6471C: 90830098  stw r4, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[4].u32 ) };
	// 82C64720: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C64724: 90830090  stw r4, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[4].u32 ) };
	// 82C64728: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82C6472C: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C64730: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82C64734: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82C64738: C00A0C14  lfs f0, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C6473C: ED606024  fdivs f11, f0, f12
	ctx.f[11].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 82C64740: D1630094  stfs f11, 0x94(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82C64744: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C64748 size=8
    let mut pc: u32 = 0x82C64748;
    'dispatch: loop {
        match pc {
            0x82C64748 => {
    //   block [0x82C64748..0x82C64750)
	// 82C64748: 8083008C  lwz r4, 0x8c(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 82C6474C: 4BFFFFBC  b 0x82c64708
	sub_82C64708(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C64750 size=560
    let mut pc: u32 = 0x82C64750;
    'dispatch: loop {
        match pc {
            0x82C64750 => {
    //   block [0x82C64750..0x82C647A0)
	// 82C64750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C64754: 48044CA5  bl 0x82ca93f8
	ctx.lr = 0x82C64758;
	sub_82CA93D0(ctx, base);
	// 82C64758: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6475C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C64760: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82C64764: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82C64768: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C6476C: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82C64770: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82C64774: 83BF0024  lwz r29, 0x24(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C64778: 7F98E378  mr r24, r28
	ctx.r[24].u64 = ctx.r[28].u64;
	// 82C6477C: 83DF001C  lwz r30, 0x1c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C64780: 7D7EEA15  add. r11, r30, r29
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C64784: 4081001C  ble 0x82c647a0
	if !ctx.cr[0].gt {
	pc = 0x82C647A0; continue 'dispatch;
	}
	// 82C64788: 57AA003E  slwi r10, r29, 0
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6478C: 57CB003E  slwi r11, r30, 0
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C64790: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82C64794: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C64798: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82C6479C: 4804516D  bl 0x82ca9908
	ctx.lr = 0x82C647A0;
	sub_82CA9908(ctx, base);
	pc = 0x82C647A0; continue 'dispatch;
            }
            0x82C647A0 => {
    //   block [0x82C647A0..0x82C647C0)
	// 82C647A0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C647A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C647A8: 40990018  ble cr6, 0x82c647c0
	if !ctx.cr[6].gt {
	pc = 0x82C647C0; continue 'dispatch;
	}
	// 82C647AC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C647B0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82C647B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C647B8: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82C647BC: 4804514D  bl 0x82ca9908
	ctx.lr = 0x82C647C0;
	sub_82CA9908(ctx, base);
	pc = 0x82C647C0; continue 'dispatch;
            }
            0x82C647C0 => {
    //   block [0x82C647C0..0x82C647E0)
	// 82C647C0: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82C647C4: 40990030  ble cr6, 0x82c647f4
	if !ctx.cr[6].gt {
	pc = 0x82C647F4; continue 'dispatch;
	}
	// 82C647C8: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82C647CC: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C647D0: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C647D4: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82C647D8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82C647DC: 7D28D850  subf r9, r8, r27
	ctx.r[9].s64 = ctx.r[27].s64 - ctx.r[8].s64;
	pc = 0x82C647E0; continue 'dispatch;
            }
            0x82C647E0 => {
    //   block [0x82C647E0..0x82C647F4)
	// 82C647E0: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C647E4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C647E8: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C647EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C647F0: 4082FFF0  bne 0x82c647e0
	if !ctx.cr[0].eq {
	pc = 0x82C647E0; continue 'dispatch;
	}
	pc = 0x82C647F4; continue 'dispatch;
            }
            0x82C647F4 => {
    //   block [0x82C647F4..0x82C647FC)
	// 82C647F4: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82C647F8: 40990158  ble cr6, 0x82c64950
	if !ctx.cr[6].gt {
	pc = 0x82C64950; continue 'dispatch;
	}
	pc = 0x82C647FC; continue 'dispatch;
            }
            0x82C647FC => {
    //   block [0x82C647FC..0x82C64814)
	// 82C647FC: 83DF0088  lwz r30, 0x88(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82C64800: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C64804: 409900CC  ble cr6, 0x82c648d0
	if !ctx.cr[6].gt {
	pc = 0x82C648D0; continue 'dispatch;
	}
	// 82C64808: 7F1EE000  cmpw cr6, r30, r28
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82C6480C: 41980008  blt cr6, 0x82c64814
	if ctx.cr[6].lt {
	pc = 0x82C64814; continue 'dispatch;
	}
	// 82C64810: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82C64814; continue 'dispatch;
            }
            0x82C64814 => {
    //   block [0x82C64814..0x82C64858)
	// 82C64814: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C64818: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C6481C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82C64820: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82C64824: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C64828: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6482C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C64830: 4E800421  bctrl
	ctx.lr = 0x82C64834;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C64834: 80FF0024  lwz r7, 0x24(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C64838: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6483C: 7D275A15  add. r9, r7, r11
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C64840: 40810030  ble 0x82c64870
	if !ctx.cr[0].gt {
	pc = 0x82C64870; continue 'dispatch;
	}
	// 82C64844: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C64848: 54E9003E  slwi r9, r7, 0
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C6484C: 57C8103A  slwi r8, r30, 2
	ctx.r[8].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C64850: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82C64854: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
            }
            0x82C64858 => {
    //   block [0x82C64858..0x82C64870)
	// 82C64858: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6485C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C64860: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82C64864: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C64868: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C6486C: 4082FFEC  bne 0x82c64858
	if !ctx.cr[0].eq {
	pc = 0x82C64858; continue 'dispatch;
	}
	pc = 0x82C64870; continue 'dispatch;
            }
            0x82C64870 => {
    //   block [0x82C64870..0x82C64890)
	// 82C64870: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C64874: 7D675A15  add. r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C64878: 40810030  ble 0x82c648a8
	if !ctx.cr[0].gt {
	pc = 0x82C648A8; continue 'dispatch;
	}
	// 82C6487C: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C64880: 57C8103A  slwi r8, r30, 2
	ctx.r[8].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C64884: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C64888: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82C6488C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	pc = 0x82C64890; continue 'dispatch;
            }
            0x82C64890 => {
    //   block [0x82C64890..0x82C648A8)
	// 82C64890: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C64894: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C64898: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82C6489C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C648A0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C648A4: 4082FFEC  bne 0x82c64890
	if !ctx.cr[0].eq {
	pc = 0x82C64890; continue 'dispatch;
	}
	pc = 0x82C648A8; continue 'dispatch;
            }
            0x82C648A8 => {
    //   block [0x82C648A8..0x82C648D0)
	// 82C648A8: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82C648AC: 7F9EE050  subf r28, r30, r28
	ctx.r[28].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	// 82C648B0: 7D5E5851  subf. r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C648B4: 915F0088  stw r10, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 82C648B8: 40820064  bne 0x82c6491c
	if !ctx.cr[0].eq {
	pc = 0x82C6491C; continue 'dispatch;
	}
	// 82C648BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C648C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C648C4: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C648C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C648CC: 4800004C  b 0x82c64918
	pc = 0x82C64918; continue 'dispatch;
            }
            0x82C648D0 => {
    //   block [0x82C648D0..0x82C648F8)
	// 82C648D0: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82C648D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C648D8: 40990020  ble cr6, 0x82c648f8
	if !ctx.cr[6].gt {
	pc = 0x82C648F8; continue 'dispatch;
	}
	// 82C648DC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C648E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C648E4: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82C648E8: 935F0098  stw r26, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[26].u32 ) };
	// 82C648EC: 812A0028  lwz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C648F0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C648F4: 48000024  b 0x82c64918
	pc = 0x82C64918; continue 'dispatch;
            }
            0x82C648F8 => {
    //   block [0x82C648F8..0x82C64918)
	// 82C648F8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82C648FC: 387F009C  addi r3, r31, 0x9c
	ctx.r[3].s64 = ctx.r[31].s64 + 156;
	// 82C64900: 48002E29  bl 0x82c67728
	ctx.lr = 0x82C64904;
	sub_82C67728(ctx, base);
	// 82C64904: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C64908: 419A0020  beq cr6, 0x82c64928
	if ctx.cr[6].eq {
	pc = 0x82C64928; continue 'dispatch;
	}
	// 82C6490C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C64910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C64914: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x82C64918; continue 'dispatch;
            }
            0x82C64918 => {
    //   block [0x82C64918..0x82C6491C)
	// 82C64918: 4E800421  bctrl
	ctx.lr = 0x82C6491C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6491C => {
    //   block [0x82C6491C..0x82C64928)
	// 82C6491C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82C64920: 4199FEDC  bgt cr6, 0x82c647fc
	if ctx.cr[6].gt {
	pc = 0x82C647FC; continue 'dispatch;
	}
	// 82C64924: 4800002C  b 0x82c64950
	pc = 0x82C64950; continue 'dispatch;
            }
            0x82C64928 => {
    //   block [0x82C64928..0x82C64950)
	// 82C64928: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6492C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82C64930: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82C64934: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82C64938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6493C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C64940: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C64944: 4E800421  bctrl
	ctx.lr = 0x82C64948;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C64948: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82C6494C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
            }
            0x82C64950 => {
    //   block [0x82C64950..0x82C64980)
	// 82C64950: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C64954: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82C64958: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82C6495C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82C64960: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C64964: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C64968: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C6496C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C64970: 4E800421  bctrl
	ctx.lr = 0x82C64974;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C64974: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C64978: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82C6497C: 48044ACC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C64980 size=84
    let mut pc: u32 = 0x82C64980;
    'dispatch: loop {
        match pc {
            0x82C64980 => {
    //   block [0x82C64980..0x82C649BC)
	// 82C64980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C64984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C64988: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6498C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C64990: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	// 82C64994: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C64998: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C6499C: 419A0020  beq cr6, 0x82c649bc
	if ctx.cr[6].eq {
	pc = 0x82C649BC; continue 'dispatch;
	}
	// 82C649A0: 3881007C  addi r4, r1, 0x7c
	ctx.r[4].s64 = ctx.r[1].s64 + 124;
	// 82C649A4: 3863009C  addi r3, r3, 0x9c
	ctx.r[3].s64 = ctx.r[3].s64 + 156;
	// 82C649A8: 48002CC1  bl 0x82c67668
	ctx.lr = 0x82C649AC;
	sub_82C67668(ctx, base);
	// 82C649AC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C649B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C649B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C649B8: 4E800020  blr
	return;
            }
            0x82C649BC => {
    //   block [0x82C649BC..0x82C649D4)
	// 82C649BC: 7C8903A6  mtctr r4
	ctx.ctr.u64 = ctx.r[4].u64;
	// 82C649C0: 4E800421  bctrl
	ctx.lr = 0x82C649C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C649C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C649C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C649CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C649D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C649D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C649D8 size=80
    let mut pc: u32 = 0x82C649D8;
    'dispatch: loop {
        match pc {
            0x82C649D8 => {
    //   block [0x82C649D8..0x82C64A10)
	// 82C649D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C649DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C649E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C649E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C649E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C649EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C649F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C649F4: 4BFFFA45  bl 0x82c64438
	ctx.lr = 0x82C649F8;
	sub_82C64438(ctx, base);
	// 82C649F8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C649FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C64A00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C64A04: 419A000C  beq cr6, 0x82c64a10
	if ctx.cr[6].eq {
	pc = 0x82C64A10; continue 'dispatch;
	}
	// 82C64A08: 4BBE0DA9  bl 0x828457b0
	ctx.lr = 0x82C64A0C;
	sub_828457B0(ctx, base);
	// 82C64A0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C64A10; continue 'dispatch;
            }
            0x82C64A10 => {
    //   block [0x82C64A10..0x82C64A28)
	// 82C64A10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C64A14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C64A18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C64A1C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C64A20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C64A24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C64A28 size=80
    let mut pc: u32 = 0x82C64A28;
    'dispatch: loop {
        match pc {
            0x82C64A28 => {
    //   block [0x82C64A28..0x82C64A60)
	// 82C64A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C64A2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C64A30: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C64A34: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C64A38: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C64A3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C64A40: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C64A44: 4BFFFC45  bl 0x82c64688
	ctx.lr = 0x82C64A48;
	sub_82C64688(ctx, base);
	// 82C64A48: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C64A4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C64A50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C64A54: 419A000C  beq cr6, 0x82c64a60
	if ctx.cr[6].eq {
	pc = 0x82C64A60; continue 'dispatch;
	}
	// 82C64A58: 4BBE0D59  bl 0x828457b0
	ctx.lr = 0x82C64A5C;
	sub_828457B0(ctx, base);
	// 82C64A5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C64A60; continue 'dispatch;
            }
            0x82C64A60 => {
    //   block [0x82C64A60..0x82C64A78)
	// 82C64A60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C64A64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C64A68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C64A6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C64A70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C64A74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C64A78 size=148
    let mut pc: u32 = 0x82C64A78;
    'dispatch: loop {
        match pc {
            0x82C64A78 => {
    //   block [0x82C64A78..0x82C64B0C)
	// 82C64A78: 7CAA07B4  extsw r10, r5
	ctx.r[10].s64 = ctx.r[5].s32 as i64;
	// 82C64A7C: C123000C  lfs f9, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C64A80: 7C8B07B4  extsw r11, r4
	ctx.r[11].s64 = ctx.r[4].s32 as i64;
	// 82C64A84: C1030004  lfs f8, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82C64A88: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82C64A8C: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C64A90: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82C64A94: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C64A98: FD60069C  fcfid f11, f0
	ctx.f[11].f64 = (ctx.f[0].s64 as f64);
	// 82C64A9C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82C64AA0: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82C64AA4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C64AA8: FCA05818  frsp f5, f11
	ctx.f[5].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82C64AAC: C1A9BDF4  lfs f13, -0x420c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16908 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C64AB0: C0E30008  lfs f7, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C64AB4: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82C64AB8: C0C30000  lfs f6, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82C64ABC: C0080C4C  lfs f0, 0xc4c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C64AC0: FD406018  frsp f10, f12
	ctx.f[10].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82C64AC4: C1870C14  lfs f12, 0xc14(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C64AC8: EC8A2824  fdivs f4, f10, f5
	ctx.f[4].f64 = ((ctx.f[10].f64 / ctx.f[5].f64) as f32) as f64;
	// 82C64ACC: EC640132  fmuls f3, f4, f4
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[4].f64) as f32) as f64);
	// 82C64AD0: EC430132  fmuls f2, f3, f4
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[4].f64) as f32) as f64);
	// 82C64AD4: EC230372  fmuls f1, f3, f13
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C64AD8: EDA20032  fmuls f13, f2, f0
	ctx.f[13].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C64ADC: ED63103C  fnmsubs f11, f3, f0, f2
	ctx.f[11].f64 = -(((ctx.f[3].f64 * ctx.f[0].f64 - ctx.f[2].f64) as f32) as f64);
	// 82C64AE0: ED421828  fsubs f10, f2, f3
	ctx.f[10].f64 = (((ctx.f[2].f64 - ctx.f[3].f64) as f32) as f64);
	// 82C64AE4: EC616828  fsubs f3, f1, f13
	ctx.f[3].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 82C64AE8: EC4B202A  fadds f2, f11, f4
	ctx.f[2].f64 = ((ctx.f[11].f64 + ctx.f[4].f64) as f32) as f64;
	// 82C64AEC: EC0A0272  fmuls f0, f10, f9
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[9].f64) as f32) as f64);
	// 82C64AF0: EDAD0828  fsubs f13, f13, f1
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[1].f64) as f32) as f64);
	// 82C64AF4: ED6301F2  fmuls f11, f3, f7
	ctx.f[11].f64 = (((ctx.f[3].f64 * ctx.f[7].f64) as f32) as f64);
	// 82C64AF8: ED42023A  fmadds f10, f2, f8, f0
	ctx.f[10].f64 = (((ctx.f[2].f64 * ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C64AFC: ED2D602A  fadds f9, f13, f12
	ctx.f[9].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82C64B00: ED0A597A  fmadds f8, f10, f5, f11
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[5].f64 + ctx.f[11].f64) as f32) as f64);
	// 82C64B04: EC2941BA  fmadds f1, f9, f6, f8
	ctx.f[1].f64 = (((ctx.f[9].f64 * ctx.f[6].f64 + ctx.f[8].f64) as f32) as f64);
	// 82C64B08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C64B10 size=164
    let mut pc: u32 = 0x82C64B10;
    'dispatch: loop {
        match pc {
            0x82C64B10 => {
    //   block [0x82C64B10..0x82C64BB4)
	// 82C64B10: 7CAA07B4  extsw r10, r5
	ctx.r[10].s64 = ctx.r[5].s32 as i64;
	// 82C64B14: C0E3000C  lfs f7, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C64B18: 7C8B07B4  extsw r11, r4
	ctx.r[11].s64 = ctx.r[4].s32 as i64;
	// 82C64B1C: C0C30004  lfs f6, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82C64B20: F941FFF0  std r10, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u64 ) };
	// 82C64B24: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C64B28: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82C64B2C: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C64B30: FD20069C  fcfid f9, f0
	ctx.f[9].f64 = (ctx.f[0].s64 as f64);
	// 82C64B34: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82C64B38: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82C64B3C: C1A9BDF4  lfs f13, -0x420c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16908 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C64B40: FC604818  frsp f3, f9
	ctx.f[3].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82C64B44: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C64B48: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82C64B4C: C0A30008  lfs f5, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C64B50: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82C64B54: C0830000  lfs f4, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82C64B58: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82C64B5C: C0080B88  lfs f0, 0xb88(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(2952 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C64B60: C1660C4C  lfs f11, 0xc4c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C64B64: C1450C14  lfs f10, 0xc14(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3092 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C64B68: FD006018  frsp f8, f12
	ctx.f[8].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82C64B6C: C1870A4C  lfs f12, 0xa4c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(2636 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C64B70: EC481824  fdivs f2, f8, f3
	ctx.f[2].f64 = ((ctx.f[8].f64 / ctx.f[3].f64) as f32) as f64;
	// 82C64B74: EC2200B2  fmuls f1, f2, f2
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[2].f64) as f32) as f64);
	// 82C64B78: ED220032  fmuls f9, f2, f0
	ctx.f[9].f64 = (((ctx.f[2].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C64B7C: ED010372  fmuls f8, f1, f13
	ctx.f[8].f64 = (((ctx.f[1].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C64B80: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C64B84: EC02433C  fnmsubs f0, f2, f12, f8
	ctx.f[0].f64 = -(((ctx.f[2].f64 * ctx.f[12].f64 - ctx.f[8].f64) as f32) as f64);
	// 82C64B88: EDA242FC  fnmsubs f13, f2, f11, f8
	ctx.f[13].f64 = -(((ctx.f[2].f64 * ctx.f[11].f64 - ctx.f[8].f64) as f32) as f64);
	// 82C64B8C: ED890828  fsubs f12, f9, f1
	ctx.f[12].f64 = (((ctx.f[9].f64 - ctx.f[1].f64) as f32) as f64);
	// 82C64B90: ED614828  fsubs f11, f1, f9
	ctx.f[11].f64 = (((ctx.f[1].f64 - ctx.f[9].f64) as f32) as f64);
	// 82C64B94: ED40502A  fadds f10, f0, f10
	ctx.f[10].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 82C64B98: ED2D01F2  fmuls f9, f13, f7
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[7].f64) as f32) as f64);
	// 82C64B9C: ED0C0172  fmuls f8, f12, f5
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[5].f64) as f32) as f64);
	// 82C64BA0: ECEA49BA  fmadds f7, f10, f6, f9
	ctx.f[7].f64 = (((ctx.f[10].f64 * ctx.f[6].f64 + ctx.f[9].f64) as f32) as f64);
	// 82C64BA4: ECC740FA  fmadds f6, f7, f3, f8
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[3].f64 + ctx.f[8].f64) as f32) as f64);
	// 82C64BA8: ECAB313A  fmadds f5, f11, f4, f6
	ctx.f[5].f64 = (((ctx.f[11].f64 * ctx.f[4].f64 + ctx.f[6].f64) as f32) as f64);
	// 82C64BAC: EC251824  fdivs f1, f5, f3
	ctx.f[1].f64 = ((ctx.f[5].f64 / ctx.f[3].f64) as f32) as f64;
	// 82C64BB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C64BB8 size=832
    let mut pc: u32 = 0x82C64BB8;
    'dispatch: loop {
        match pc {
            0x82C64BB8 => {
    //   block [0x82C64BB8..0x82C64C04)
	// 82C64BB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C64BBC: 48044839  bl 0x82ca93f4
	ctx.lr = 0x82C64BC0;
	sub_82CA93D0(ctx, base);
	// 82C64BC0: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82C64BC4: 48049111  bl 0x82cadcd4
	ctx.lr = 0x82C64BC8;
	sub_82CADCA0(ctx, base);
	// 82C64BC8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C64BCC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C64BD0: F9010130  std r8, 0x130(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[8].u64 ) };
	// 82C64BD4: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82C64BD8: F9210138  std r9, 0x138(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[9].u64 ) };
	// 82C64BDC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82C64BE0: 7F9BB850  subf r28, r27, r23
	ctx.r[28].s64 = ctx.r[23].s64 - ctx.r[27].s64;
	// 82C64BE4: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82C64BE8: 7CF83B78  mr r24, r7
	ctx.r[24].u64 = ctx.r[7].u64;
	// 82C64BEC: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 82C64BF0: 419A028C  beq cr6, 0x82c64e7c
	if ctx.cr[6].eq {
	pc = 0x82C64E7C; continue 'dispatch;
	}
	// 82C64BF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C64BF8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C64BFC: C36B0C18  lfs f27, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82C64C00: C38A0C14  lfs f28, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	pc = 0x82C64C04; continue 'dispatch;
            }
            0x82C64C04 => {
    //   block [0x82C64C04..0x82C64C24)
	// 82C64C04: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C64C08: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82C64C0C: 41980064  blt cr6, 0x82c64c70
	if ctx.cr[6].lt {
	pc = 0x82C64C70; continue 'dispatch;
	}
	// 82C64C10: 576B2036  slwi r11, r27, 4
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C64C14: 7FBCC1D6  mullw r29, r28, r24
	ctx.r[29].s32 = ((ctx.r[28].s32 as i64 * ctx.r[24].s32 as i64) as i32);
	ctx.r[29].s64 = ctx.r[29].s32 as i64;
	// 82C64C18: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82C64C1C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C64C20: 3BCBFFF8  addi r30, r11, -8
	ctx.r[30].s64 = ctx.r[11].s64 + -8;
	pc = 0x82C64C24; continue 'dispatch;
            }
            0x82C64C24 => {
    //   block [0x82C64C24..0x82C64C4C)
	// 82C64C24: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C64C28: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82C64C2C: 4BFFFE4D  bl 0x82c64a78
	ctx.lr = 0x82C64C30;
	sub_82C64A78(ctx, base);
	// 82C64C30: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82C64C34: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C64C38: 4BFFFED9  bl 0x82c64b10
	ctx.lr = 0x82C64C3C;
	sub_82C64B10(ctx, base);
	// 82C64C3C: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82C64C40: 4098000C  bge cr6, 0x82c64c4c
	if !ctx.cr[6].lt {
	pc = 0x82C64C4C; continue 'dispatch;
	}
	// 82C64C44: D3FE0008  stfs f31, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C64C48: D03E000C  stfs f1, 0xc(r30)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x82C64C4C; continue 'dispatch;
            }
            0x82C64C4C => {
    //   block [0x82C64C4C..0x82C64C5C)
	// 82C64C4C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82C64C50: 4099000C  ble cr6, 0x82c64c5c
	if !ctx.cr[6].gt {
	pc = 0x82C64C5C; continue 'dispatch;
	}
	// 82C64C54: D3FE0000  stfs f31, 0(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C64C58: D03E0004  stfs f1, 4(r30)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x82C64C5C; continue 'dispatch;
            }
            0x82C64C5C => {
    //   block [0x82C64C5C..0x82C64C70)
	// 82C64C5C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82C64C60: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82C64C64: 7C84C214  add r4, r4, r24
	ctx.r[4].u64 = ctx.r[4].u64 + ctx.r[24].u64;
	// 82C64C68: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82C64C6C: 4099FFB8  ble cr6, 0x82c64c24
	if !ctx.cr[6].gt {
	pc = 0x82C64C24; continue 'dispatch;
	}
	pc = 0x82C64C70; continue 'dispatch;
            }
            0x82C64C70 => {
    //   block [0x82C64C70..0x82C64C9C)
	// 82C64C70: FC00E090  fmr f0, f28
	ctx.f[0].f64 = ctx.f[28].f64;
	// 82C64C74: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82C64C78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C64C7C: 2F1C0004  cmpwi cr6, r28, 4
	ctx.cr[6].compare_i32(ctx.r[28].s32, 4, &mut ctx.xer);
	// 82C64C80: 419800A0  blt cr6, 0x82c64d20
	if ctx.cr[6].lt {
	pc = 0x82C64D20; continue 'dispatch;
	}
	// 82C64C84: 576A2036  slwi r10, r27, 4
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C64C88: 5768103A  slwi r8, r27, 2
	ctx.r[8].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C64C8C: 7D2AD214  add r9, r10, r26
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 82C64C90: 38FCFFFD  addi r7, r28, -3
	ctx.r[7].s64 = ctx.r[28].s64 + -3;
	// 82C64C94: 7D48CA14  add r10, r8, r25
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[25].u64;
	// 82C64C98: 39290018  addi r9, r9, 0x18
	ctx.r[9].s64 = ctx.r[9].s64 + 24;
	pc = 0x82C64C9C; continue 'dispatch;
            }
            0x82C64C9C => {
    //   block [0x82C64C9C..0x82C64CB8)
	// 82C64C9C: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C64CA0: C189FFF0  lfs f12, -0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C64CA4: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82C64CA8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C64CAC: 4098000C  bge cr6, 0x82c64cb8
	if !ctx.cr[6].lt {
	pc = 0x82C64CB8; continue 'dispatch;
	}
	// 82C64CB0: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82C64CB4: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82C64CB8; continue 'dispatch;
            }
            0x82C64CB8 => {
    //   block [0x82C64CB8..0x82C64CD4)
	// 82C64CB8: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C64CBC: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C64CC0: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82C64CC4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C64CC8: 4098000C  bge cr6, 0x82c64cd4
	if !ctx.cr[6].lt {
	pc = 0x82C64CD4; continue 'dispatch;
	}
	// 82C64CCC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82C64CD0: 38CB0001  addi r6, r11, 1
	ctx.r[6].s64 = ctx.r[11].s64 + 1;
	pc = 0x82C64CD4; continue 'dispatch;
            }
            0x82C64CD4 => {
    //   block [0x82C64CD4..0x82C64CF0)
	// 82C64CD4: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C64CD8: C1890010  lfs f12, 0x10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C64CDC: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82C64CE0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C64CE4: 4098000C  bge cr6, 0x82c64cf0
	if !ctx.cr[6].lt {
	pc = 0x82C64CF0; continue 'dispatch;
	}
	// 82C64CE8: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82C64CEC: 38CB0002  addi r6, r11, 2
	ctx.r[6].s64 = ctx.r[11].s64 + 2;
	pc = 0x82C64CF0; continue 'dispatch;
            }
            0x82C64CF0 => {
    //   block [0x82C64CF0..0x82C64D0C)
	// 82C64CF0: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C64CF4: C1890020  lfs f12, 0x20(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C64CF8: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82C64CFC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C64D00: 4098000C  bge cr6, 0x82c64d0c
	if !ctx.cr[6].lt {
	pc = 0x82C64D0C; continue 'dispatch;
	}
	// 82C64D04: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82C64D08: 38CB0003  addi r6, r11, 3
	ctx.r[6].s64 = ctx.r[11].s64 + 3;
	pc = 0x82C64D0C; continue 'dispatch;
            }
            0x82C64D0C => {
    //   block [0x82C64D0C..0x82C64D20)
	// 82C64D0C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C64D10: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82C64D14: 39290040  addi r9, r9, 0x40
	ctx.r[9].s64 = ctx.r[9].s64 + 64;
	// 82C64D18: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82C64D1C: 4198FF80  blt cr6, 0x82c64c9c
	if ctx.cr[6].lt {
	pc = 0x82C64C9C; continue 'dispatch;
	}
	pc = 0x82C64D20; continue 'dispatch;
            }
            0x82C64D20 => {
    //   block [0x82C64D20..0x82C64D40)
	// 82C64D20: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82C64D24: 4098004C  bge cr6, 0x82c64d70
	if !ctx.cr[6].lt {
	pc = 0x82C64D70; continue 'dispatch;
	}
	// 82C64D28: 7D4BDA14  add r10, r11, r27
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82C64D2C: 55492036  slwi r9, r10, 4
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C64D30: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C64D34: 7D29D214  add r9, r9, r26
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[26].u64;
	// 82C64D38: 7D4ACA14  add r10, r10, r25
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[25].u64;
	// 82C64D3C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	pc = 0x82C64D40; continue 'dispatch;
            }
            0x82C64D40 => {
    //   block [0x82C64D40..0x82C64D5C)
	// 82C64D40: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C64D44: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C64D48: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82C64D4C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C64D50: 4098000C  bge cr6, 0x82c64d5c
	if !ctx.cr[6].lt {
	pc = 0x82C64D5C; continue 'dispatch;
	}
	// 82C64D54: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	// 82C64D58: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	pc = 0x82C64D5C; continue 'dispatch;
            }
            0x82C64D5C => {
    //   block [0x82C64D5C..0x82C64D70)
	// 82C64D5C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C64D60: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82C64D64: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 82C64D68: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82C64D6C: 4198FFD4  blt cr6, 0x82c64d40
	if ctx.cr[6].lt {
	pc = 0x82C64D40; continue 'dispatch;
	}
	pc = 0x82C64D70; continue 'dispatch;
            }
            0x82C64D70 => {
    //   block [0x82C64D70..0x82C64E04)
	// 82C64D70: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82C64D74: 40980174  bge cr6, 0x82c64ee8
	if !ctx.cr[6].lt {
	pc = 0x82C64EE8; continue 'dispatch;
	}
	// 82C64D78: 7FE6DA14  add r31, r6, r27
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[27].u64;
	// 82C64D7C: C0010130  lfs f0, 0x130(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(304 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C64D80: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82C64D84: 7D7FB850  subf r11, r31, r23
	ctx.r[11].s64 = ctx.r[23].s64 - ctx.r[31].s64;
	// 82C64D88: C3E10138  lfs f31, 0x138(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(312 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C64D8C: 57EA103A  slwi r10, r31, 2
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C64D90: C1A10134  lfs f13, 0x134(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C64D94: 7D2BC1D6  mullw r9, r11, r24
	ctx.r[9].s32 = ((ctx.r[11].s32 as i64 * ctx.r[24].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82C64D98: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82C64D9C: 7C0ACC2E  lfsx f0, r10, r25
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[25].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C64DA0: ED9F0028  fsubs f12, f31, f0
	ctx.f[12].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82C64DA4: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	// 82C64DA8: D3C10068  stfs f30, 0x68(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82C64DAC: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 82C64DB0: 7F1FD800  cmpw cr6, r31, r27
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82C64DB4: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82C64DB8: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C64DBC: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82C64DC0: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82C64DC4: EFAC4824  fdivs f29, f12, f9
	ctx.f[29].f64 = ((ctx.f[12].f64 / ctx.f[9].f64) as f32) as f64;
	// 82C64DC8: D3A1006C  stfs f29, 0x6c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82C64DCC: 409A0038  bne cr6, 0x82c64e04
	if !ctx.cr[6].eq {
	pc = 0x82C64E04; continue 'dispatch;
	}
	// 82C64DD0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82C64DD4: 576B2036  slwi r11, r27, 4
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C64DD8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82C64DDC: 7D2BD214  add r9, r11, r26
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82C64DE0: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C64DE4: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C64DE8: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C64DEC: 80AA000C  lwz r5, 0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C64DF0: 7D0BD12E  stwx r8, r11, r26
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32), ctx.r[8].u32) };
	// 82C64DF4: 90E90004  stw r7, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82C64DF8: 90C90008  stw r6, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82C64DFC: 90A9000C  stw r5, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 82C64E00: 48000024  b 0x82c64e24
	pc = 0x82C64E24; continue 'dispatch;
            }
            0x82C64E04 => {
    //   block [0x82C64E04..0x82C64E24)
	// 82C64E04: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 82C64E08: E9010060  ld r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82C64E0C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C64E10: E9210068  ld r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82C64E14: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82C64E18: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82C64E1C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82C64E20: 4BFFFD99  bl 0x82c64bb8
	ctx.lr = 0x82C64E24;
	sub_82C64BB8(ctx, base);
	pc = 0x82C64E24; continue 'dispatch;
            }
            0x82C64E24 => {
    //   block [0x82C64E24..0x82C64E7C)
	// 82C64E24: 3977FFFF  addi r11, r23, -1
	ctx.r[11].s64 = ctx.r[23].s64 + -1;
	// 82C64E28: C001013C  lfs f0, 0x13c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C64E2C: D3C10060  stfs f30, 0x60(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82C64E30: D3A10064  stfs f29, 0x64(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82C64E34: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C64E38: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82C64E3C: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82C64E40: 419A0078  beq cr6, 0x82c64eb8
	if ctx.cr[6].eq {
	pc = 0x82C64EB8; continue 'dispatch;
	}
	// 82C64E44: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82C64E48: 39410130  addi r10, r1, 0x130
	ctx.r[10].s64 = ctx.r[1].s64 + 304;
	// 82C64E4C: 7F9FB850  subf r28, r31, r23
	ctx.r[28].s64 = ctx.r[23].s64 - ctx.r[31].s64;
	// 82C64E50: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 82C64E54: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 82C64E58: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C64E5C: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C64E60: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C64E64: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C64E68: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C64E6C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82C64E70: 90EA0008  stw r7, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82C64E74: 90CA000C  stw r6, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 82C64E78: 409AFD8C  bne cr6, 0x82c64c04
	if !ctx.cr[6].eq {
	pc = 0x82C64C04; continue 'dispatch;
	}
	pc = 0x82C64E7C; continue 'dispatch;
            }
            0x82C64E7C => {
    //   block [0x82C64E7C..0x82C64EB8)
	// 82C64E7C: 39410130  addi r10, r1, 0x130
	ctx.r[10].s64 = ctx.r[1].s64 + 304;
	// 82C64E80: 576B2036  slwi r11, r27, 4
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C64E84: 7D2BD214  add r9, r11, r26
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82C64E88: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C64E8C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C64E90: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C64E94: 80AA000C  lwz r5, 0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C64E98: 7D0BD12E  stwx r8, r11, r26
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[26].u32), ctx.r[8].u32) };
	// 82C64E9C: 90E90004  stw r7, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82C64EA0: 90C90008  stw r6, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82C64EA4: 90A9000C  stw r5, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 82C64EA8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82C64EAC: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82C64EB0: 48048E71  bl 0x82cadd20
	ctx.lr = 0x82C64EB4;
	sub_82CADCEC(ctx, base);
	// 82C64EB4: 48044590  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C64EB8 => {
    //   block [0x82C64EB8..0x82C64EE8)
	// 82C64EB8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82C64EBC: 56EB2036  slwi r11, r23, 4
	ctx.r[11].u32 = ctx.r[23].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C64EC0: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82C64EC4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C64EC8: 390BFFF0  addi r8, r11, -0x10
	ctx.r[8].s64 = ctx.r[11].s64 + -16;
	// 82C64ECC: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C64ED0: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C64ED4: 80AA000C  lwz r5, 0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C64ED8: 912BFFF0  stw r9, -0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16 as u32), ctx.r[9].u32 ) };
	// 82C64EDC: 90EBFFF4  stw r7, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[7].u32 ) };
	// 82C64EE0: 90CBFFF8  stw r6, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[6].u32 ) };
	// 82C64EE4: 90ABFFFC  stw r5, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[5].u32 ) };
	pc = 0x82C64EE8; continue 'dispatch;
            }
            0x82C64EE8 => {
    //   block [0x82C64EE8..0x82C64EF8)
	// 82C64EE8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82C64EEC: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82C64EF0: 48048E31  bl 0x82cadd20
	ctx.lr = 0x82C64EF4;
	sub_82CADCEC(ctx, base);
	// 82C64EF4: 48044550  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64EF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C64EF8 size=92
    let mut pc: u32 = 0x82C64EF8;
    'dispatch: loop {
        match pc {
            0x82C64EF8 => {
    //   block [0x82C64EF8..0x82C64F54)
	// 82C64EF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C64EFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C64F00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C64F04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C64F08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C64F0C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C64F10: 38800060  li r4, 0x60
	ctx.r[4].s64 = 96;
	// 82C64F14: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C64F18: 4BFFF021  bl 0x82c63f38
	ctx.lr = 0x82C64F1C;
	sub_82C63F38(ctx, base);
	// 82C64F1C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C64F20: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C64F24: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 82C64F28: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C64F2C: C00B0C14  lfs f0, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C64F30: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C64F34: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C64F38: D01F005C  stfs f0, 0x5c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82C64F3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C64F40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C64F44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C64F48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C64F4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C64F50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C64F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C64F58 size=192
    let mut pc: u32 = 0x82C64F58;
    'dispatch: loop {
        match pc {
            0x82C64F58 => {
    //   block [0x82C64F58..0x82C64FAC)
	// 82C64F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C64F5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C64F60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C64F64: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82C64F68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C64F6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C64F70: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C64F74: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82C64F78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C64F7C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82C64F80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C64F84: 396B0C18  addi r11, r11, 0xc18
	ctx.r[11].s64 = ctx.r[11].s64 + 3096;
	// 82C64F88: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C64F8C: 409A0020  bne cr6, 0x82c64fac
	if !ctx.cr[6].eq {
	pc = 0x82C64FAC; continue 'dispatch;
	}
	// 82C64F90: 815F0040  lwz r10, 0x40(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C64F94: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C64F98: 7D2AFA14  add r9, r10, r31
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 82C64F9C: C1A90014  lfs f13, 0x14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C64FA0: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82C64FA4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C64FA8: 40990008  ble cr6, 0x82c64fb0
	if !ctx.cr[6].gt {
	pc = 0x82C64FB0; continue 'dispatch;
	}
	pc = 0x82C64FAC; continue 'dispatch;
            }
            0x82C64FAC => {
    //   block [0x82C64FAC..0x82C64FB0)
	// 82C64FAC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	pc = 0x82C64FB0; continue 'dispatch;
            }
            0x82C64FB0 => {
    //   block [0x82C64FB0..0x82C65018)
	// 82C64FB0: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C64FB4: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82C64FB8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C64FBC: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82C64FC0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82C64FC4: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C64FC8: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82C64FCC: 80FF0048  lwz r7, 0x48(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82C64FD0: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C64FD4: E9210058  ld r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82C64FD8: 4BFFFBE1  bl 0x82c64bb8
	ctx.lr = 0x82C64FDC;
	sub_82C64BB8(ctx, base);
	// 82C64FDC: 813F0048  lwz r9, 0x48(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82C64FE0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82C64FE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C64FE8: D3FF0044  stfs f31, 0x44(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82C64FEC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C64FF0: 915F004C  stw r10, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 82C64FF4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C64FF8: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82C64FFC: 913F0050  stw r9, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82C65000: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C65004: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C65008: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6500C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C65010: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C65014: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C65018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C65018 size=28
    let mut pc: u32 = 0x82C65018;
    'dispatch: loop {
        match pc {
            0x82C65018 => {
    //   block [0x82C65018..0x82C65034)
	// 82C65018: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6501C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82C65020: 409A0014  bne cr6, 0x82c65034
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C65034);
		return;
	}
	// 82C65024: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C65028: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82C6502C: 9163004C  stw r11, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82C65030: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C65050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C65050 size=112
    let mut pc: u32 = 0x82C65050;
    'dispatch: loop {
        match pc {
            0x82C65050 => {
    //   block [0x82C65050..0x82C65074)
	// 82C65050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C65054: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C65058: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6505C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C65060: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82C65064: 409A0028  bne cr6, 0x82c6508c
	if !ctx.cr[6].eq {
	pc = 0x82C6508C; continue 'dispatch;
	}
	// 82C65068: C0030044  lfs f0, 0x44(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C6506C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C65070: 4198001C  blt cr6, 0x82c6508c
	if ctx.cr[6].lt {
	pc = 0x82C6508C; continue 'dispatch;
	}
	pc = 0x82C65074; continue 'dispatch;
            }
            0x82C65074 => {
    //   block [0x82C65074..0x82C6508C)
	// 82C65074: 4BFFFFA5  bl 0x82c65018
	ctx.lr = 0x82C65078;
	sub_82C65018(ctx, base);
	// 82C65078: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C6507C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C65080: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C65084: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C65088: 4E800020  blr
	return;
            }
            0x82C6508C => {
    //   block [0x82C6508C..0x82C6509C)
	// 82C6508C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82C65090: 419A000C  beq cr6, 0x82c6509c
	if ctx.cr[6].eq {
	pc = 0x82C6509C; continue 'dispatch;
	}
	// 82C65094: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82C65098: 409A0010  bne cr6, 0x82c650a8
	if !ctx.cr[6].eq {
	pc = 0x82C650A8; continue 'dispatch;
	}
	pc = 0x82C6509C; continue 'dispatch;
            }
            0x82C6509C => {
    //   block [0x82C6509C..0x82C650A8)
	// 82C6509C: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C650A0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C650A4: 4098FFD0  bge cr6, 0x82c65074
	if !ctx.cr[6].lt {
	pc = 0x82C65074; continue 'dispatch;
	}
	pc = 0x82C650A8; continue 'dispatch;
            }
            0x82C650A8 => {
    //   block [0x82C650A8..0x82C650C0)
	// 82C650A8: 4BFFFEB1  bl 0x82c64f58
	ctx.lr = 0x82C650AC;
	sub_82C64F58(ctx, base);
	// 82C650AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C650B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C650B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C650B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C650BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C650C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C650C0 size=964
    let mut pc: u32 = 0x82C650C0;
    'dispatch: loop {
        match pc {
            0x82C650C0 => {
    //   block [0x82C650C0..0x82C6510C)
	// 82C650C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C650C4: 48044349  bl 0x82ca940c
	ctx.lr = 0x82C650C8;
	sub_82CA93D0(ctx, base);
	// 82C650C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C650CC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82C650D0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C650D4: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C650D8: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82C650DC: 419902E8  bgt cr6, 0x82c653c4
	if ctx.cr[6].gt {
	pc = 0x82C653C4; continue 'dispatch;
	}
	// 82C650E0: 3D8082C6  lis r12, -0x7d3a
	ctx.r[12].s64 = -2100953088;
	// 82C650E4: 398C50F8  addi r12, r12, 0x50f8
	ctx.r[12].s64 = ctx.r[12].s64 + 20728;
	// 82C650E8: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82C650EC: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82C650F0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82C650F4: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x82C6510C; continue 'dispatch;
		},
		1 => {
	pc = 0x82C65184; continue 'dispatch;
		},
		2 => {
	pc = 0x82C651E0; continue 'dispatch;
		},
		3 => {
	pc = 0x82C65258; continue 'dispatch;
		},
		4 => {
	pc = 0x82C65258; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82C650F8: 82C6510C  lwz r22, 0x510c(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20748 as u32) ) } as u64;
	// 82C650FC: 82C65184  lwz r22, 0x5184(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20868 as u32) ) } as u64;
	// 82C65100: 82C651E0  lwz r22, 0x51e0(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20960 as u32) ) } as u64;
	// 82C65104: 82C65258  lwz r22, 0x5258(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(21080 as u32) ) } as u64;
	// 82C65108: 82C65258  lwz r22, 0x5258(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(21080 as u32) ) } as u64;
            }
            0x82C6510C => {
    //   block [0x82C6510C..0x82C6512C)
	// 82C6510C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C65110: 2F1D0004  cmpwi cr6, r29, 4
	ctx.cr[6].compare_i32(ctx.r[29].s32, 4, &mut ctx.xer);
	// 82C65114: 41980044  blt cr6, 0x82c65158
	if ctx.cr[6].lt {
	pc = 0x82C65158; continue 'dispatch;
	}
	// 82C65118: 395DFFFC  addi r10, r29, -4
	ctx.r[10].s64 = ctx.r[29].s64 + -4;
	// 82C6511C: 39640008  addi r11, r4, 8
	ctx.r[11].s64 = ctx.r[4].s64 + 8;
	// 82C65120: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C65124: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C65128: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	pc = 0x82C6512C; continue 'dispatch;
            }
            0x82C6512C => {
    //   block [0x82C6512C..0x82C65158)
	// 82C6512C: C0060004  lfs f0, 4(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65130: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C65134: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82C65138: C1A60004  lfs f13, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C6513C: D1ABFFFC  stfs f13, -4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82C65140: C1860004  lfs f12, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C65144: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C65148: C1660004  lfs f11, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C6514C: D16B0004  stfs f11, 4(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C65150: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82C65154: 4082FFD8  bne 0x82c6512c
	if !ctx.cr[0].eq {
	pc = 0x82C6512C; continue 'dispatch;
	}
	pc = 0x82C65158; continue 'dispatch;
            }
            0x82C65158 => {
    //   block [0x82C65158..0x82C6516C)
	// 82C65158: 7F09E800  cmpw cr6, r9, r29
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82C6515C: 40980268  bge cr6, 0x82c653c4
	if !ctx.cr[6].lt {
	pc = 0x82C653C4; continue 'dispatch;
	}
	// 82C65160: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C65164: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82C65168: 7D69E850  subf r11, r9, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[9].s64;
	pc = 0x82C6516C; continue 'dispatch;
            }
            0x82C6516C => {
    //   block [0x82C6516C..0x82C65184)
	// 82C6516C: C0060004  lfs f0, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65170: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C65174: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C65178: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82C6517C: 4082FFF0  bne 0x82c6516c
	if !ctx.cr[0].eq {
	pc = 0x82C6516C; continue 'dispatch;
	}
	// 82C65180: 48000244  b 0x82c653c4
	pc = 0x82C653C4; continue 'dispatch;
            }
            0x82C65184 => {
    //   block [0x82C65184..0x82C651A4)
	// 82C65184: 81660040  lwz r11, 0x40(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C65188: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C6518C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82C65190: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C65194: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C65198: 7C6B3214  add r3, r11, r6
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 82C6519C: 40990034  ble cr6, 0x82c651d0
	if !ctx.cr[6].gt {
	pc = 0x82C651D0; continue 'dispatch;
	}
	// 82C651A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	pc = 0x82C651A4; continue 'dispatch;
            }
            0x82C651A4 => {
    //   block [0x82C651A4..0x82C651D0)
	// 82C651A4: 8166000C  lwz r11, 0xc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C651A8: 80A60048  lwz r5, 0x48(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82C651AC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82C651B0: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82C651B4: 4BFFF8C5  bl 0x82c64a78
	ctx.lr = 0x82C651B8;
	sub_82C64A78(ctx, base);
	// 82C651B8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82C651BC: D0260004  stfs f1, 4(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C651C0: D03E0000  stfs f1, 0(r30)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C651C4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C651C8: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82C651CC: 4198FFD8  blt cr6, 0x82c651a4
	if ctx.cr[6].lt {
	pc = 0x82C651A4; continue 'dispatch;
	}
	pc = 0x82C651D0; continue 'dispatch;
            }
            0x82C651D0 => {
    //   block [0x82C651D0..0x82C651E0)
	// 82C651D0: 8166000C  lwz r11, 0xc(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C651D4: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82C651D8: 9166000C  stw r11, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C651DC: 480001E8  b 0x82c653c4
	pc = 0x82C653C4; continue 'dispatch;
            }
            0x82C651E0 => {
    //   block [0x82C651E0..0x82C65200)
	// 82C651E0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C651E4: 2F1D0004  cmpwi cr6, r29, 4
	ctx.cr[6].compare_i32(ctx.r[29].s32, 4, &mut ctx.xer);
	// 82C651E8: 41980044  blt cr6, 0x82c6522c
	if ctx.cr[6].lt {
	pc = 0x82C6522C; continue 'dispatch;
	}
	// 82C651EC: 395DFFFC  addi r10, r29, -4
	ctx.r[10].s64 = ctx.r[29].s64 + -4;
	// 82C651F0: 39640008  addi r11, r4, 8
	ctx.r[11].s64 = ctx.r[4].s64 + 8;
	// 82C651F4: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C651F8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C651FC: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	pc = 0x82C65200; continue 'dispatch;
            }
            0x82C65200 => {
    //   block [0x82C65200..0x82C6522C)
	// 82C65200: C0060004  lfs f0, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65204: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C65208: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82C6520C: C1A60004  lfs f13, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C65210: D1ABFFFC  stfs f13, -4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82C65214: C1860004  lfs f12, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C65218: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C6521C: C1660004  lfs f11, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C65220: D16B0004  stfs f11, 4(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C65224: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82C65228: 4082FFD8  bne 0x82c65200
	if !ctx.cr[0].eq {
	pc = 0x82C65200; continue 'dispatch;
	}
	pc = 0x82C6522C; continue 'dispatch;
            }
            0x82C6522C => {
    //   block [0x82C6522C..0x82C65240)
	// 82C6522C: 7F09E800  cmpw cr6, r9, r29
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82C65230: 40980194  bge cr6, 0x82c653c4
	if !ctx.cr[6].lt {
	pc = 0x82C653C4; continue 'dispatch;
	}
	// 82C65234: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C65238: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82C6523C: 7D69E850  subf r11, r9, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[9].s64;
	pc = 0x82C65240; continue 'dispatch;
            }
            0x82C65240 => {
    //   block [0x82C65240..0x82C65258)
	// 82C65240: C0060004  lfs f0, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65244: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C65248: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C6524C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82C65250: 4082FFF0  bne 0x82c65240
	if !ctx.cr[0].eq {
	pc = 0x82C65240; continue 'dispatch;
	}
	// 82C65254: 48000170  b 0x82c653c4
	pc = 0x82C653C4; continue 'dispatch;
            }
            0x82C65258 => {
    //   block [0x82C65258..0x82C65280)
	// 82C65258: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C6525C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C65260: 2F1D0004  cmpwi cr6, r29, 4
	ctx.cr[6].compare_i32(ctx.r[29].s32, 4, &mut ctx.xer);
	// 82C65264: C80B0CB8  lfd f0, 0xcb8(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3256 as u32) ) };
	// 82C65268: 41980104  blt cr6, 0x82c6536c
	if ctx.cr[6].lt {
	pc = 0x82C6536C; continue 'dispatch;
	}
	// 82C6526C: 397DFFFC  addi r11, r29, -4
	ctx.r[11].s64 = ctx.r[29].s64 + -4;
	// 82C65270: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C65274: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82C65278: 39640008  addi r11, r4, 8
	ctx.r[11].s64 = ctx.r[4].s64 + 8;
	// 82C6527C: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	pc = 0x82C65280; continue 'dispatch;
            }
            0x82C65280 => {
    //   block [0x82C65280..0x82C6536C)
	// 82C65280: C1A60008  lfs f13, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C65284: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C65288: FD806828  fsub f12, f0, f13
	ctx.f[12].f64 = ctx.f[0].f64 - ctx.f[13].f64;
	// 82C6528C: C146005C  lfs f10, 0x5c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(92 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C65290: FD606890  fmr f11, f13
	ctx.f[11].f64 = ctx.f[13].f64;
	// 82C65294: C1260004  lfs f9, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C65298: FD004890  fmr f8, f9
	ctx.f[8].f64 = ctx.f[9].f64;
	// 82C6529C: C0E60054  lfs f7, 0x54(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(84 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C652A0: FCCC5ABA  fmadd f6, f12, f10, f11
	ctx.f[6].f64 = ctx.f[12].f64 * ctx.f[10].f64 + ctx.f[11].f64;
	// 82C652A4: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82C652A8: D0A60008  stfs f5, 8(r6)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C652AC: EC854828  fsubs f4, f5, f9
	ctx.f[4].f64 = (((ctx.f[5].f64 - ctx.f[9].f64) as f32) as f64);
	// 82C652B0: EC6441FA  fmadds f3, f4, f7, f8
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[7].f64 + ctx.f[8].f64) as f32) as f64);
	// 82C652B4: D0660004  stfs f3, 4(r6)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C652B8: D06BFFF8  stfs f3, -8(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82C652BC: C026005C  lfs f1, 0x5c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(92 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C652C0: C0460008  lfs f2, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C652C4: FD801090  fmr f12, f2
	ctx.f[12].f64 = ctx.f[2].f64;
	// 82C652C8: FD606028  fsub f11, f0, f12
	ctx.f[11].f64 = ctx.f[0].f64 - ctx.f[12].f64;
	// 82C652CC: C1060054  lfs f8, 0x54(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(84 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82C652D0: C1A60004  lfs f13, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C652D4: FD206890  fmr f9, f13
	ctx.f[9].f64 = ctx.f[13].f64;
	// 82C652D8: FD4B107A  fmadd f10, f11, f1, f2
	ctx.f[10].f64 = ctx.f[11].f64 * ctx.f[1].f64 + ctx.f[2].f64;
	// 82C652DC: FCE05018  frsp f7, f10
	ctx.f[7].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82C652E0: D0E60008  stfs f7, 8(r6)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C652E4: ECC76828  fsubs f6, f7, f13
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[13].f64) as f32) as f64);
	// 82C652E8: ECA64A3A  fmadds f5, f6, f8, f9
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[8].f64 + ctx.f[9].f64) as f32) as f64);
	// 82C652EC: D0A60004  stfs f5, 4(r6)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C652F0: D0ABFFFC  stfs f5, -4(r11)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82C652F4: C066005C  lfs f3, 0x5c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(92 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82C652F8: C0860008  lfs f4, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82C652FC: FC202090  fmr f1, f4
	ctx.f[1].f64 = ctx.f[4].f64;
	// 82C65300: FDA00828  fsub f13, f0, f1
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[1].f64;
	// 82C65304: C1460054  lfs f10, 0x54(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(84 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C65308: C0460004  lfs f2, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C6530C: FD601090  fmr f11, f2
	ctx.f[11].f64 = ctx.f[2].f64;
	// 82C65310: FD8D20FA  fmadd f12, f13, f3, f4
	ctx.f[12].f64 = ctx.f[13].f64 * ctx.f[3].f64 + ctx.f[4].f64;
	// 82C65314: FD206018  frsp f9, f12
	ctx.f[9].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82C65318: D1260008  stfs f9, 8(r6)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C6531C: ED091028  fsubs f8, f9, f2
	ctx.f[8].f64 = (((ctx.f[9].f64 - ctx.f[2].f64) as f32) as f64);
	// 82C65320: ECE85ABA  fmadds f7, f8, f10, f11
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64);
	// 82C65324: D0E60004  stfs f7, 4(r6)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C65328: D0EB0000  stfs f7, 0(r11)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C6532C: C0A6005C  lfs f5, 0x5c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(92 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C65330: C0C60008  lfs f6, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82C65334: FC603090  fmr f3, f6
	ctx.f[3].f64 = ctx.f[6].f64;
	// 82C65338: FC401828  fsub f2, f0, f3
	ctx.f[2].f64 = ctx.f[0].f64 - ctx.f[3].f64;
	// 82C6533C: C1860054  lfs f12, 0x54(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C65340: C0860004  lfs f4, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82C65344: FDA02090  fmr f13, f4
	ctx.f[13].f64 = ctx.f[4].f64;
	// 82C65348: FC22317A  fmadd f1, f2, f5, f6
	ctx.f[1].f64 = ctx.f[2].f64 * ctx.f[5].f64 + ctx.f[6].f64;
	// 82C6534C: FD600818  frsp f11, f1
	ctx.f[11].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C65350: D1660008  stfs f11, 8(r6)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C65354: ED4B2028  fsubs f10, f11, f4
	ctx.f[10].f64 = (((ctx.f[11].f64 - ctx.f[4].f64) as f32) as f64);
	// 82C65358: ED2A6B3A  fmadds f9, f10, f12, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82C6535C: D1260004  stfs f9, 4(r6)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C65360: D12B0004  stfs f9, 4(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C65364: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82C65368: 4082FF18  bne 0x82c65280
	if !ctx.cr[0].eq {
	pc = 0x82C65280; continue 'dispatch;
	}
	pc = 0x82C6536C; continue 'dispatch;
            }
            0x82C6536C => {
    //   block [0x82C6536C..0x82C65380)
	// 82C6536C: 7F09E800  cmpw cr6, r9, r29
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82C65370: 40980054  bge cr6, 0x82c653c4
	if !ctx.cr[6].lt {
	pc = 0x82C653C4; continue 'dispatch;
	}
	// 82C65374: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C65378: 7D4B2214  add r10, r11, r4
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82C6537C: 7D69E850  subf r11, r9, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[9].s64;
	pc = 0x82C65380; continue 'dispatch;
            }
            0x82C65380 => {
    //   block [0x82C65380..0x82C653C4)
	// 82C65380: C1A60008  lfs f13, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C65384: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C65388: FD806828  fsub f12, f0, f13
	ctx.f[12].f64 = ctx.f[0].f64 - ctx.f[13].f64;
	// 82C6538C: C146005C  lfs f10, 0x5c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(92 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C65390: FD606890  fmr f11, f13
	ctx.f[11].f64 = ctx.f[13].f64;
	// 82C65394: C1260004  lfs f9, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C65398: FD004890  fmr f8, f9
	ctx.f[8].f64 = ctx.f[9].f64;
	// 82C6539C: C0E60054  lfs f7, 0x54(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(84 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C653A0: FCCC5ABA  fmadd f6, f12, f10, f11
	ctx.f[6].f64 = ctx.f[12].f64 * ctx.f[10].f64 + ctx.f[11].f64;
	// 82C653A4: FCA03018  frsp f5, f6
	ctx.f[5].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82C653A8: D0A60008  stfs f5, 8(r6)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C653AC: EC854828  fsubs f4, f5, f9
	ctx.f[4].f64 = (((ctx.f[5].f64 - ctx.f[9].f64) as f32) as f64);
	// 82C653B0: EC6441FA  fmadds f3, f4, f7, f8
	ctx.f[3].f64 = (((ctx.f[4].f64 * ctx.f[7].f64 + ctx.f[8].f64) as f32) as f64);
	// 82C653B4: D0660004  stfs f3, 4(r6)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C653B8: D06A0000  stfs f3, 0(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C653BC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82C653C0: 4082FFC0  bne 0x82c65380
	if !ctx.cr[0].eq {
	pc = 0x82C65380; continue 'dispatch;
	}
	pc = 0x82C653C4; continue 'dispatch;
            }
            0x82C653C4 => {
    //   block [0x82C653C4..0x82C6540C)
	// 82C653C4: 81660050  lwz r11, 0x50(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C653C8: 7D5D5851  subf. r10, r29, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C653CC: 91460050  stw r10, 0x50(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82C653D0: 408200AC  bne 0x82c6547c
	if !ctx.cr[0].eq {
	pc = 0x82C6547C; continue 'dispatch;
	}
	// 82C653D4: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C653D8: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82C653DC: 419900A0  bgt cr6, 0x82c6547c
	if ctx.cr[6].gt {
	pc = 0x82C6547C; continue 'dispatch;
	}
	// 82C653E0: 3D8082C6  lis r12, -0x7d3a
	ctx.r[12].s64 = -2100953088;
	// 82C653E4: 398C53F8  addi r12, r12, 0x53f8
	ctx.r[12].s64 = ctx.r[12].s64 + 21496;
	// 82C653E8: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82C653EC: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82C653F0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82C653F4: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x82C65474; continue 'dispatch;
		},
		1 => {
	pc = 0x82C6540C; continue 'dispatch;
		},
		2 => {
	pc = 0x82C65458; continue 'dispatch;
		},
		3 => {
	pc = 0x82C65474; continue 'dispatch;
		},
		4 => {
	pc = 0x82C65464; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82C653F8: 82C65474  lwz r22, 0x5474(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(21620 as u32) ) } as u64;
	// 82C653FC: 82C6540C  lwz r22, 0x540c(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(21516 as u32) ) } as u64;
	// 82C65400: 82C65458  lwz r22, 0x5458(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(21592 as u32) ) } as u64;
	// 82C65404: 82C65474  lwz r22, 0x5474(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(21620 as u32) ) } as u64;
	// 82C65408: 82C65464  lwz r22, 0x5464(r6)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(21604 as u32) ) } as u64;
            }
            0x82C6540C => {
    //   block [0x82C6540C..0x82C65440)
	// 82C6540C: 81660040  lwz r11, 0x40(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C65410: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82C65414: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82C65418: 91460040  stw r10, 0x40(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 82C6541C: 409A0024  bne cr6, 0x82c65440
	if !ctx.cr[6].eq {
	pc = 0x82C65440; continue 'dispatch;
	}
	// 82C65420: 8166004C  lwz r11, 0x4c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 82C65424: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82C65428: 81260048  lwz r9, 0x48(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82C6542C: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C65430: 7D0B49D6  mullw r8, r11, r9
	ctx.r[8].s32 = ((ctx.r[11].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82C65434: 91060050  stw r8, 0x50(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C65438: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6543C: 48044020  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C65440 => {
    //   block [0x82C65440..0x82C65458)
	// 82C65440: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82C65444: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C65448: 9146000C  stw r10, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82C6544C: 91660050  stw r11, 0x50(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C65450: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C65454: 48044008  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C65458 => {
    //   block [0x82C65458..0x82C65464)
	// 82C65458: C0060004  lfs f0, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C6545C: D0060008  stfs f0, 8(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C65460: 4800000C  b 0x82c6546c
	pc = 0x82C6546C; continue 'dispatch;
            }
            0x82C65464 => {
    //   block [0x82C65464..0x82C6546C)
	// 82C65464: C0060058  lfs f0, 0x58(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65468: D0060054  stfs f0, 0x54(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(84 as u32), tmp.u32 ) };
	pc = 0x82C6546C; continue 'dispatch;
            }
            0x82C6546C => {
    //   block [0x82C6546C..0x82C65474)
	// 82C6546C: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82C65470: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82C65474; continue 'dispatch;
            }
            0x82C65474 => {
    //   block [0x82C65474..0x82C6547C)
	// 82C65474: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 82C65478: 91660050  stw r11, 0x50(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82C6547C; continue 'dispatch;
            }
            0x82C6547C => {
    //   block [0x82C6547C..0x82C65484)
	// 82C6547C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C65480: 48043FDC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C65488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C65488 size=36
    let mut pc: u32 = 0x82C65488;
    'dispatch: loop {
        match pc {
            0x82C65488 => {
    //   block [0x82C65488..0x82C65490)
	// 82C65488: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82C6548C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x82C65490; continue 'dispatch;
            }
            0x82C65490 => {
    //   block [0x82C65490..0x82C654AC)
	// 82C65490: 89640000  lbz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C65494: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82C65498: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82C6549C: 99630000  stb r11, 0(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82C654A0: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 82C654A4: 4082FFEC  bne 0x82c65490
	if !ctx.cr[0].eq {
	pc = 0x82C65490; continue 'dispatch;
	}
	// 82C654A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C654B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C654B0 size=20
    let mut pc: u32 = 0x82C654B0;
    'dispatch: loop {
        match pc {
            0x82C654B0 => {
    //   block [0x82C654B0..0x82C654C4)
	// 82C654B0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82C654B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C654B8: 38A00060  li r5, 0x60
	ctx.r[5].s64 = 96;
	// 82C654BC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C654C0: 4BFFFFC8  b 0x82c65488
	sub_82C65488(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C654C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C654C8 size=8
    let mut pc: u32 = 0x82C654C8;
    'dispatch: loop {
        match pc {
            0x82C654C8 => {
    //   block [0x82C654C8..0x82C654D0)
	// 82C654C8: D0230054  stfs f1, 0x54(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82C654CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C654D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C654D0 size=8
    let mut pc: u32 = 0x82C654D0;
    'dispatch: loop {
        match pc {
            0x82C654D0 => {
    //   block [0x82C654D0..0x82C654D8)
	// 82C654D0: D023005C  stfs f1, 0x5c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82C654D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C654D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C654D8 size=28
    let mut pc: u32 = 0x82C654D8;
    'dispatch: loop {
        match pc {
            0x82C654D8 => {
    //   block [0x82C654D8..0x82C654F4)
	// 82C654D8: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 82C654DC: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82C654E0: D0230058  stfs f1, 0x58(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82C654E4: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C654E8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C654EC: 91230050  stw r9, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82C654F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C654F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C654F8 size=104
    let mut pc: u32 = 0x82C654F8;
    'dispatch: loop {
        match pc {
            0x82C654F8 => {
    //   block [0x82C654F8..0x82C65524)
	// 82C654F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C654FC: 48043F11  bl 0x82ca940c
	ctx.lr = 0x82C65500;
	sub_82CA93D0(ctx, base);
	// 82C65500: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C65504: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C65508: 807D009C  lwz r3, 0x9c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) } as u64;
	// 82C6550C: 4800132D  bl 0x82c66838
	ctx.lr = 0x82C65510;
	sub_82C66838(ctx, base);
	// 82C65510: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C65514: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C65518: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C6551C: 40990024  ble cr6, 0x82c65540
	if !ctx.cr[6].gt {
	pc = 0x82C65540; continue 'dispatch;
	}
	// 82C65520: 3BFD0044  addi r31, r29, 0x44
	ctx.r[31].s64 = ctx.r[29].s64 + 68;
	pc = 0x82C65524; continue 'dispatch;
            }
            0x82C65524 => {
    //   block [0x82C65524..0x82C65540)
	// 82C65524: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C65528: 48002709  bl 0x82c67c30
	ctx.lr = 0x82C6552C;
	sub_82C67C30(ctx, base);
	// 82C6552C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C65530: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C65534: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82C65538: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C6553C: 4198FFE8  blt cr6, 0x82c65524
	if ctx.cr[6].lt {
	pc = 0x82C65524; continue 'dispatch;
	}
	pc = 0x82C65540; continue 'dispatch;
            }
            0x82C65540 => {
    //   block [0x82C65540..0x82C65560)
	// 82C65540: 807D0094  lwz r3, 0x94(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 82C65544: 480012F5  bl 0x82c66838
	ctx.lr = 0x82C65548;
	sub_82C66838(ctx, base);
	// 82C65548: 807D0098  lwz r3, 0x98(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(152 as u32) ) } as u64;
	// 82C6554C: 480012ED  bl 0x82c66838
	ctx.lr = 0x82C65550;
	sub_82C66838(ctx, base);
	// 82C65550: 807D0040  lwz r3, 0x40(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C65554: 4BFFEA25  bl 0x82c63f78
	ctx.lr = 0x82C65558;
	sub_82C63F78(ctx, base);
	// 82C65558: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6555C: 48043F00  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C65560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C65560 size=52
    let mut pc: u32 = 0x82C65560;
    'dispatch: loop {
        match pc {
            0x82C65560 => {
    //   block [0x82C65560..0x82C65594)
	// 82C65560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C65564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C65568: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6556C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C65570: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C65574: 4BFFFF85  bl 0x82c654f8
	ctx.lr = 0x82C65578;
	sub_82C654F8(ctx, base);
	// 82C65578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6557C: 4BFFE9FD  bl 0x82c63f78
	ctx.lr = 0x82C65580;
	sub_82C63F78(ctx, base);
	// 82C65580: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C65584: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C65588: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6558C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C65590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C65598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C65598 size=288
    let mut pc: u32 = 0x82C65598;
    'dispatch: loop {
        match pc {
            0x82C65598 => {
    //   block [0x82C65598..0x82C655B4)
	// 82C65598: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82C6559C: C1A60000  lfs f13, 0(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C655A0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82C655A4: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C655A8: 40990100  ble cr6, 0x82c656a8
	if !ctx.cr[6].gt {
	pc = 0x82C656A8; continue 'dispatch;
	}
	// 82C655AC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C655B0: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82C655B4; continue 'dispatch;
            }
            0x82C655B4 => {
    //   block [0x82C655B4..0x82C655CC)
	// 82C655B4: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C655B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C655BC: 2F050004  cmpwi cr6, r5, 4
	ctx.cr[6].compare_i32(ctx.r[5].s32, 4, &mut ctx.xer);
	// 82C655C0: 4198009C  blt cr6, 0x82c6565c
	if ctx.cr[6].lt {
	pc = 0x82C6565C; continue 'dispatch;
	}
	// 82C655C4: 3925FFFD  addi r9, r5, -3
	ctx.r[9].s64 = ctx.r[5].s64 + -3;
	// 82C655C8: 395F0008  addi r10, r31, 8
	ctx.r[10].s64 = ctx.r[31].s64 + 8;
	pc = 0x82C655CC; continue 'dispatch;
            }
            0x82C655CC => {
    //   block [0x82C655CC..0x82C655DC)
	// 82C655CC: C00AFFF8  lfs f0, -8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C655D0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82C655D4: 40980008  bge cr6, 0x82c655dc
	if !ctx.cr[6].lt {
	pc = 0x82C655DC; continue 'dispatch;
	}
	// 82C655D8: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82C655DC; continue 'dispatch;
            }
            0x82C655DC => {
    //   block [0x82C655DC..0x82C655EC)
	// 82C655DC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C655E0: 4099000C  ble cr6, 0x82c655ec
	if !ctx.cr[6].gt {
	pc = 0x82C655EC; continue 'dispatch;
	}
	// 82C655E4: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82C655E8: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	pc = 0x82C655EC; continue 'dispatch;
            }
            0x82C655EC => {
    //   block [0x82C655EC..0x82C655FC)
	// 82C655EC: C00AFFFC  lfs f0, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C655F0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82C655F4: 40980008  bge cr6, 0x82c655fc
	if !ctx.cr[6].lt {
	pc = 0x82C655FC; continue 'dispatch;
	}
	// 82C655F8: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82C655FC; continue 'dispatch;
            }
            0x82C655FC => {
    //   block [0x82C655FC..0x82C6560C)
	// 82C655FC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C65600: 4099000C  ble cr6, 0x82c6560c
	if !ctx.cr[6].gt {
	pc = 0x82C6560C; continue 'dispatch;
	}
	// 82C65604: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82C65608: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	pc = 0x82C6560C; continue 'dispatch;
            }
            0x82C6560C => {
    //   block [0x82C6560C..0x82C6561C)
	// 82C6560C: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65610: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82C65614: 40980008  bge cr6, 0x82c6561c
	if !ctx.cr[6].lt {
	pc = 0x82C6561C; continue 'dispatch;
	}
	// 82C65618: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82C6561C; continue 'dispatch;
            }
            0x82C6561C => {
    //   block [0x82C6561C..0x82C6562C)
	// 82C6561C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C65620: 4099000C  ble cr6, 0x82c6562c
	if !ctx.cr[6].gt {
	pc = 0x82C6562C; continue 'dispatch;
	}
	// 82C65624: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82C65628: 390B0002  addi r8, r11, 2
	ctx.r[8].s64 = ctx.r[11].s64 + 2;
	pc = 0x82C6562C; continue 'dispatch;
            }
            0x82C6562C => {
    //   block [0x82C6562C..0x82C6563C)
	// 82C6562C: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65630: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82C65634: 40980008  bge cr6, 0x82c6563c
	if !ctx.cr[6].lt {
	pc = 0x82C6563C; continue 'dispatch;
	}
	// 82C65638: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82C6563C; continue 'dispatch;
            }
            0x82C6563C => {
    //   block [0x82C6563C..0x82C6564C)
	// 82C6563C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C65640: 4099000C  ble cr6, 0x82c6564c
	if !ctx.cr[6].gt {
	pc = 0x82C6564C; continue 'dispatch;
	}
	// 82C65644: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82C65648: 390B0003  addi r8, r11, 3
	ctx.r[8].s64 = ctx.r[11].s64 + 3;
	pc = 0x82C6564C; continue 'dispatch;
            }
            0x82C6564C => {
    //   block [0x82C6564C..0x82C6565C)
	// 82C6564C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C65650: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82C65654: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82C65658: 4198FF74  blt cr6, 0x82c655cc
	if ctx.cr[6].lt {
	pc = 0x82C655CC; continue 'dispatch;
	}
	pc = 0x82C6565C; continue 'dispatch;
            }
            0x82C6565C => {
    //   block [0x82C6565C..0x82C6566C)
	// 82C6565C: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82C65660: 4098003C  bge cr6, 0x82c6569c
	if !ctx.cr[6].lt {
	pc = 0x82C6569C; continue 'dispatch;
	}
	// 82C65664: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C65668: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	pc = 0x82C6566C; continue 'dispatch;
            }
            0x82C6566C => {
    //   block [0x82C6566C..0x82C6567C)
	// 82C6566C: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65670: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82C65674: 40980008  bge cr6, 0x82c6567c
	if !ctx.cr[6].lt {
	pc = 0x82C6567C; continue 'dispatch;
	}
	// 82C65678: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82C6567C; continue 'dispatch;
            }
            0x82C6567C => {
    //   block [0x82C6567C..0x82C6568C)
	// 82C6567C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C65680: 4099000C  ble cr6, 0x82c6568c
	if !ctx.cr[6].gt {
	pc = 0x82C6568C; continue 'dispatch;
	}
	// 82C65684: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82C65688: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	pc = 0x82C6568C; continue 'dispatch;
            }
            0x82C6568C => {
    //   block [0x82C6568C..0x82C6569C)
	// 82C6568C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C65690: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82C65694: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82C65698: 4198FFD4  blt cr6, 0x82c6566c
	if ctx.cr[6].lt {
	pc = 0x82C6566C; continue 'dispatch;
	}
	pc = 0x82C6569C; continue 'dispatch;
            }
            0x82C6569C => {
    //   block [0x82C6569C..0x82C656A8)
	// 82C6569C: 3484FFFF  addic. r4, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C656A0: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82C656A4: 4082FF10  bne 0x82c655b4
	if !ctx.cr[0].eq {
	pc = 0x82C655B4; continue 'dispatch;
	}
	pc = 0x82C656A8; continue 'dispatch;
            }
            0x82C656A8 => {
    //   block [0x82C656A8..0x82C656B8)
	// 82C656A8: D1A60000  stfs f13, 0(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C656AC: 91070000  stw r8, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C656B0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82C656B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C656B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C656B8 size=88
    let mut pc: u32 = 0x82C656B8;
    'dispatch: loop {
        match pc {
            0x82C656B8 => {
    //   block [0x82C656B8..0x82C656C0)
	// 82C656B8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C656BC: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82C656C0; continue 'dispatch;
            }
            0x82C656C0 => {
    //   block [0x82C656C0..0x82C656D4)
	// 82C656C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C656C4: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82C656C8: 40990038  ble cr6, 0x82c65700
	if !ctx.cr[6].gt {
	pc = 0x82C65700; continue 'dispatch;
	}
	// 82C656CC: FDA00850  fneg f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[1].u64 ^ 0x8000_0000_0000_0000u64;
	// 82C656D0: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	pc = 0x82C656D4; continue 'dispatch;
            }
            0x82C656D4 => {
    //   block [0x82C656D4..0x82C656E8)
	// 82C656D4: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C656D8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C656DC: 4098000C  bge cr6, 0x82c656e8
	if !ctx.cr[6].lt {
	pc = 0x82C656E8; continue 'dispatch;
	}
	// 82C656E0: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C656E4: 48000010  b 0x82c656f4
	pc = 0x82C656F4; continue 'dispatch;
            }
            0x82C656E8 => {
    //   block [0x82C656E8..0x82C656F4)
	// 82C656E8: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82C656EC: 40990008  ble cr6, 0x82c656f4
	if !ctx.cr[6].gt {
	pc = 0x82C656F4; continue 'dispatch;
	}
	// 82C656F0: D02B0000  stfs f1, 0(r11)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82C656F4; continue 'dispatch;
            }
            0x82C656F4 => {
    //   block [0x82C656F4..0x82C65700)
	// 82C656F4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C656F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C656FC: 4082FFD8  bne 0x82c656d4
	if !ctx.cr[0].eq {
	pc = 0x82C656D4; continue 'dispatch;
	}
	pc = 0x82C65700; continue 'dispatch;
            }
            0x82C65700 => {
    //   block [0x82C65700..0x82C65710)
	// 82C65700: 3484FFFF  addic. r4, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C65704: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82C65708: 4082FFB8  bne 0x82c656c0
	if !ctx.cr[0].eq {
	pc = 0x82C656C0; continue 'dispatch;
	}
	// 82C6570C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C65710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C65710 size=268
    let mut pc: u32 = 0x82C65710;
    'dispatch: loop {
        match pc {
            0x82C65710 => {
    //   block [0x82C65710..0x82C65734)
	// 82C65710: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82C65714: 2F040004  cmpwi cr6, r4, 4
	ctx.cr[6].compare_i32(ctx.r[4].s32, 4, &mut ctx.xer);
	// 82C65718: 419800B8  blt cr6, 0x82c657d0
	if ctx.cr[6].lt {
	pc = 0x82C657D0; continue 'dispatch;
	}
	// 82C6571C: 3964FFFC  addi r11, r4, -4
	ctx.r[11].s64 = ctx.r[4].s64 + -4;
	// 82C65720: 81430040  lwz r10, 0x40(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C65724: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C65728: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82C6572C: 396A0008  addi r11, r10, 8
	ctx.r[11].s64 = ctx.r[10].s64 + 8;
	// 82C65730: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	pc = 0x82C65734; continue 'dispatch;
            }
            0x82C65734 => {
    //   block [0x82C65734..0x82C65748)
	// 82C65734: C00BFFF8  lfs f0, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65738: C1A30160  lfs f13, 0x160(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(352 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C6573C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C65740: 40980008  bge cr6, 0x82c65748
	if !ctx.cr[6].lt {
	pc = 0x82C65748; continue 'dispatch;
	}
	// 82C65744: D0030160  stfs f0, 0x160(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(352 as u32), tmp.u32 ) };
	pc = 0x82C65748; continue 'dispatch;
            }
            0x82C65748 => {
    //   block [0x82C65748..0x82C65758)
	// 82C65748: C1A30164  lfs f13, 0x164(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C6574C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C65750: 40990008  ble cr6, 0x82c65758
	if !ctx.cr[6].gt {
	pc = 0x82C65758; continue 'dispatch;
	}
	// 82C65754: D0030164  stfs f0, 0x164(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(356 as u32), tmp.u32 ) };
	pc = 0x82C65758; continue 'dispatch;
            }
            0x82C65758 => {
    //   block [0x82C65758..0x82C6576C)
	// 82C65758: C00BFFFC  lfs f0, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C6575C: C1A30160  lfs f13, 0x160(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(352 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C65760: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C65764: 40980008  bge cr6, 0x82c6576c
	if !ctx.cr[6].lt {
	pc = 0x82C6576C; continue 'dispatch;
	}
	// 82C65768: D0030160  stfs f0, 0x160(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(352 as u32), tmp.u32 ) };
	pc = 0x82C6576C; continue 'dispatch;
            }
            0x82C6576C => {
    //   block [0x82C6576C..0x82C6577C)
	// 82C6576C: C1A30164  lfs f13, 0x164(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C65770: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C65774: 40990008  ble cr6, 0x82c6577c
	if !ctx.cr[6].gt {
	pc = 0x82C6577C; continue 'dispatch;
	}
	// 82C65778: D0030164  stfs f0, 0x164(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(356 as u32), tmp.u32 ) };
	pc = 0x82C6577C; continue 'dispatch;
            }
            0x82C6577C => {
    //   block [0x82C6577C..0x82C65790)
	// 82C6577C: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65780: C1A30160  lfs f13, 0x160(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(352 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C65784: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C65788: 40980008  bge cr6, 0x82c65790
	if !ctx.cr[6].lt {
	pc = 0x82C65790; continue 'dispatch;
	}
	// 82C6578C: D0030160  stfs f0, 0x160(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(352 as u32), tmp.u32 ) };
	pc = 0x82C65790; continue 'dispatch;
            }
            0x82C65790 => {
    //   block [0x82C65790..0x82C657A0)
	// 82C65790: C1A30164  lfs f13, 0x164(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C65794: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C65798: 40990008  ble cr6, 0x82c657a0
	if !ctx.cr[6].gt {
	pc = 0x82C657A0; continue 'dispatch;
	}
	// 82C6579C: D0030164  stfs f0, 0x164(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(356 as u32), tmp.u32 ) };
	pc = 0x82C657A0; continue 'dispatch;
            }
            0x82C657A0 => {
    //   block [0x82C657A0..0x82C657B4)
	// 82C657A0: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C657A4: C1A30160  lfs f13, 0x160(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(352 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C657A8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C657AC: 40980008  bge cr6, 0x82c657b4
	if !ctx.cr[6].lt {
	pc = 0x82C657B4; continue 'dispatch;
	}
	// 82C657B0: D0030160  stfs f0, 0x160(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(352 as u32), tmp.u32 ) };
	pc = 0x82C657B4; continue 'dispatch;
            }
            0x82C657B4 => {
    //   block [0x82C657B4..0x82C657C4)
	// 82C657B4: C1A30164  lfs f13, 0x164(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C657B8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C657BC: 40990008  ble cr6, 0x82c657c4
	if !ctx.cr[6].gt {
	pc = 0x82C657C4; continue 'dispatch;
	}
	// 82C657C0: D0030164  stfs f0, 0x164(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(356 as u32), tmp.u32 ) };
	pc = 0x82C657C4; continue 'dispatch;
            }
            0x82C657C4 => {
    //   block [0x82C657C4..0x82C657D0)
	// 82C657C4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C657C8: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82C657CC: 4082FF68  bne 0x82c65734
	if !ctx.cr[0].eq {
	pc = 0x82C65734; continue 'dispatch;
	}
	pc = 0x82C657D0; continue 'dispatch;
            }
            0x82C657D0 => {
    //   block [0x82C657D0..0x82C657E8)
	// 82C657D0: 7F082000  cmpw cr6, r8, r4
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82C657D4: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82C657D8: 81630040  lwz r11, 0x40(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C657DC: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C657E0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C657E4: 7D482050  subf r10, r8, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	pc = 0x82C657E8; continue 'dispatch;
            }
            0x82C657E8 => {
    //   block [0x82C657E8..0x82C657FC)
	// 82C657E8: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C657EC: C1A30160  lfs f13, 0x160(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(352 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C657F0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C657F4: 40980008  bge cr6, 0x82c657fc
	if !ctx.cr[6].lt {
	pc = 0x82C657FC; continue 'dispatch;
	}
	// 82C657F8: D0030160  stfs f0, 0x160(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(352 as u32), tmp.u32 ) };
	pc = 0x82C657FC; continue 'dispatch;
            }
            0x82C657FC => {
    //   block [0x82C657FC..0x82C6580C)
	// 82C657FC: C1A30164  lfs f13, 0x164(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(356 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C65800: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C65804: 40990008  ble cr6, 0x82c6580c
	if !ctx.cr[6].gt {
	pc = 0x82C6580C; continue 'dispatch;
	}
	// 82C65808: D0030164  stfs f0, 0x164(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(356 as u32), tmp.u32 ) };
	pc = 0x82C6580C; continue 'dispatch;
            }
            0x82C6580C => {
    //   block [0x82C6580C..0x82C6581C)
	// 82C6580C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C65810: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C65814: 4082FFD4  bne 0x82c657e8
	if !ctx.cr[0].eq {
	pc = 0x82C657E8; continue 'dispatch;
	}
	// 82C65818: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C65820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C65820 size=40
    let mut pc: u32 = 0x82C65820;
    'dispatch: loop {
        match pc {
            0x82C65820 => {
    //   block [0x82C65820..0x82C65848)
	// 82C65820: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C65824: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82C65828: C00B0C14  lfs f0, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C6582C: C1AABE14  lfs f13, -0x41ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16876 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C65830: EC000824  fdivs f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 82C65834: EDA20372  fmuls f13, f2, f13
	ctx.f[13].f64 = (((ctx.f[2].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C65838: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C6583C: 4098000C  bge cr6, 0x82c65848
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82C65848);
		return;
	}
	// 82C65840: EC200024  fdivs f1, f0, f0
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[0].f64) as f32) as f64;
	// 82C65844: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C65850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C65850 size=60
    let mut pc: u32 = 0x82C65850;
    'dispatch: loop {
        match pc {
            0x82C65850 => {
    //   block [0x82C65850..0x82C6588C)
	// 82C65850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C65854: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C65858: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6585C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82C65860: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 82C65864: D0290034  stfs f1, 0x34(r9)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82C65868: C0290000  lfs f1, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C6586C: 4BFFFFB5  bl 0x82c65820
	ctx.lr = 0x82C65870;
	sub_82C65820(ctx, base);
	// 82C65870: 386900A0  addi r3, r9, 0xa0
	ctx.r[3].s64 = ctx.r[9].s64 + 160;
	// 82C65874: D0290038  stfs f1, 0x38(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82C65878: 4BFFFC51  bl 0x82c654c8
	ctx.lr = 0x82C6587C;
	sub_82C654C8(ctx, base);
	// 82C6587C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C65880: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C65884: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C65888: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C65898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C65898 size=136
    let mut pc: u32 = 0x82C65898;
    'dispatch: loop {
        match pc {
            0x82C65898 => {
    //   block [0x82C65898..0x82C658F8)
	// 82C65898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6589C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C658A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C658A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C658A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C658AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C658B0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C658B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C658B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C658BC: C01F0018  lfs f0, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C658C0: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C658C4: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82C658C8: D19F0028  stfs f12, 0x28(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82C658CC: C00A0AB4  lfs f0, 0xab4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2740 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C658D0: C82B0D40  lfd f1, 0xd40(r11)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3392 as u32) ) };
	// 82C658D4: EC4C0032  fmuls f2, f12, f0
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C658D8: 4B598BD1  bl 0x821fe4a8
	ctx.lr = 0x82C658DC;
	sub_821FE4A8(ctx, base);
	// 82C658DC: 813F0030  lwz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C658E0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C658E4: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82C658E8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C658EC: 419A000C  beq cr6, 0x82c658f8
	if ctx.cr[6].eq {
	pc = 0x82C658F8; continue 'dispatch;
	}
	// 82C658F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C658F4: C80B0CB8  lfd f0, 0xcb8(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3256 as u32) ) };
	pc = 0x82C658F8; continue 'dispatch;
            }
            0x82C658F8 => {
    //   block [0x82C658F8..0x82C65920)
	// 82C658F8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C658FC: 807F009C  lwz r3, 0x9c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82C65900: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82C65904: 4BFFEACD  bl 0x82c643d0
	ctx.lr = 0x82C65908;
	sub_82C643D0(ctx, base);
	// 82C65908: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6590C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C65910: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C65914: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C65918: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6591C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C65920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C65920 size=104
    let mut pc: u32 = 0x82C65920;
    'dispatch: loop {
        match pc {
            0x82C65920 => {
    //   block [0x82C65920..0x82C65988)
	// 82C65920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C65924: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C65928: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6592C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C65930: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C65934: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C65938: FDA00890  fmr f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ctx.f[1].f64;
	// 82C6593C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C65940: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C65944: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C65948: D1BF0018  stfs f13, 0x18(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82C6594C: C00B0AB4  lfs f0, 0xab4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2740 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65950: C82A0D40  lfd f1, 0xd40(r10)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3392 as u32) ) };
	// 82C65954: EC4D0032  fmuls f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C65958: 4B598B51  bl 0x821fe4a8
	ctx.lr = 0x82C6595C;
	sub_821FE4A8(ctx, base);
	// 82C6595C: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C65960: D19F001C  stfs f12, 0x1c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82C65964: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C65968: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6596C: 4BFFFF2D  bl 0x82c65898
	ctx.lr = 0x82C65970;
	sub_82C65898(ctx, base);
	// 82C65970: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C65974: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C65978: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6597C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C65980: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C65984: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C65988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C65988 size=104
    let mut pc: u32 = 0x82C65988;
    'dispatch: loop {
        match pc {
            0x82C65988 => {
    //   block [0x82C65988..0x82C659F0)
	// 82C65988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6598C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C65990: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C65994: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C65998: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6599C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C659A0: FDA00890  fmr f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ctx.f[1].f64;
	// 82C659A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C659A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C659AC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C659B0: D1BF0020  stfs f13, 0x20(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C659B4: C00B0AB4  lfs f0, 0xab4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2740 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C659B8: C82A0D40  lfd f1, 0xd40(r10)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3392 as u32) ) };
	// 82C659BC: EC4D0032  fmuls f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C659C0: 4B598AE9  bl 0x821fe4a8
	ctx.lr = 0x82C659C4;
	sub_821FE4A8(ctx, base);
	// 82C659C4: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C659C8: D19F0024  stfs f12, 0x24(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82C659CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C659D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C659D4: 4BFFFEC5  bl 0x82c65898
	ctx.lr = 0x82C659D8;
	sub_82C65898(ctx, base);
	// 82C659D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C659DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C659E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C659E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C659E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C659EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C659F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C659F0 size=248
    let mut pc: u32 = 0x82C659F0;
    'dispatch: loop {
        match pc {
            0x82C659F0 => {
    //   block [0x82C659F0..0x82C65A5C)
	// 82C659F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C659F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C659F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C659FC: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82C65A00: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82C65A04: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 82C65A08: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82C65A0C: 4BFFFAA5  bl 0x82c654b0
	ctx.lr = 0x82C65A10;
	sub_82C654B0(ctx, base);
	// 82C65A10: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C65A14: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82C65A18: 409A0074  bne cr6, 0x82c65a8c
	if !ctx.cr[6].eq {
	pc = 0x82C65A8C; continue 'dispatch;
	}
	// 82C65A1C: 816A004C  lwz r11, 0x4c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) } as u64;
	// 82C65A20: 810A0040  lwz r8, 0x40(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C65A24: 7CE85850  subf r7, r8, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82C65A28: 3567FFFF  addic. r11, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C65A2C: 40810030  ble 0x82c65a5c
	if !ctx.cr[0].gt {
	pc = 0x82C65A5C; continue 'dispatch;
	}
	// 82C65A30: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 82C65A34: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C65A38: 80EA0048  lwz r7, 0x48(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 82C65A3C: 7CC759D6  mullw r6, r7, r11
	ctx.r[6].s32 = ((ctx.r[7].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 82C65A40: 90C90050  stw r6, 0x50(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 82C65A44: C00A0044  lfs f0, 0x44(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65A48: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C65A4C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C65A50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C65A54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C65A58: 4E800020  blr
	return;
            }
            0x82C65A5C => {
    //   block [0x82C65A5C..0x82C65A74)
	// 82C65A5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C65A60: 409A0014  bne cr6, 0x82c65a74
	if !ctx.cr[6].eq {
	pc = 0x82C65A74; continue 'dispatch;
	}
	// 82C65A64: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82C65A68: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C65A6C: 810A0048  lwz r8, 0x48(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 82C65A70: 91090050  stw r8, 0x50(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	pc = 0x82C65A74; continue 'dispatch;
            }
            0x82C65A74 => {
    //   block [0x82C65A74..0x82C65A8C)
	// 82C65A74: C00A0044  lfs f0, 0x44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65A78: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C65A7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C65A80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C65A84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C65A88: 4E800020  blr
	return;
            }
            0x82C65A8C => {
    //   block [0x82C65A8C..0x82C65AB8)
	// 82C65A8C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82C65A90: 409A0048  bne cr6, 0x82c65ad8
	if !ctx.cr[6].eq {
	pc = 0x82C65AD8; continue 'dispatch;
	}
	// 82C65A94: 816A0048  lwz r11, 0x48(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 82C65A98: 810A0050  lwz r8, 0x50(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C65A9C: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C65AA0: 7D674051  subf. r11, r7, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C65AA4: 40810014  ble 0x82c65ab8
	if !ctx.cr[0].gt {
	pc = 0x82C65AB8; continue 'dispatch;
	}
	// 82C65AA8: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 82C65AAC: 91690050  stw r11, 0x50(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C65AB0: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C65AB4: 4800001C  b 0x82c65ad0
	pc = 0x82C65AD0; continue 'dispatch;
            }
            0x82C65AB8 => {
    //   block [0x82C65AB8..0x82C65AD0)
	// 82C65AB8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C65ABC: 409A0014  bne cr6, 0x82c65ad0
	if !ctx.cr[6].eq {
	pc = 0x82C65AD0; continue 'dispatch;
	}
	// 82C65AC0: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82C65AC4: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C65AC8: 810A0048  lwz r8, 0x48(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 82C65ACC: 91090050  stw r8, 0x50(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	pc = 0x82C65AD0; continue 'dispatch;
            }
            0x82C65AD0 => {
    //   block [0x82C65AD0..0x82C65AD8)
	// 82C65AD0: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65AD4: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x82C65AD8; continue 'dispatch;
            }
            0x82C65AD8 => {
    //   block [0x82C65AD8..0x82C65AE8)
	// 82C65AD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C65ADC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C65AE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C65AE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C65AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C65AE8 size=92
    let mut pc: u32 = 0x82C65AE8;
    'dispatch: loop {
        match pc {
            0x82C65AE8 => {
    //   block [0x82C65AE8..0x82C65B44)
	// 82C65AE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C65AEC: 48043921  bl 0x82ca940c
	ctx.lr = 0x82C65AF0;
	sub_82CA93D0(ctx, base);
	// 82C65AF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C65AF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C65AF8: 3BDF00A0  addi r30, r31, 0xa0
	ctx.r[30].s64 = ctx.r[31].s64 + 160;
	// 82C65AFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C65B00: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C65B04: 4BFFF3F5  bl 0x82c64ef8
	ctx.lr = 0x82C65B08;
	sub_82C64EF8(ctx, base);
	// 82C65B08: 3BBF0100  addi r29, r31, 0x100
	ctx.r[29].s64 = ctx.r[31].s64 + 256;
	// 82C65B0C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C65B10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C65B14: 4BFFF3E5  bl 0x82c64ef8
	ctx.lr = 0x82C65B18;
	sub_82C64EF8(ctx, base);
	// 82C65B18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C65B1C: C03F0000  lfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C65B20: C04B0C14  lfs f2, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C65B24: 4BFFFCFD  bl 0x82c65820
	ctx.lr = 0x82C65B28;
	sub_82C65820(ctx, base);
	// 82C65B28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C65B2C: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82C65B30: 4BFFF9A1  bl 0x82c654d0
	ctx.lr = 0x82C65B34;
	sub_82C654D0(ctx, base);
	// 82C65B34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C65B38: 4BFFF999  bl 0x82c654d0
	ctx.lr = 0x82C65B3C;
	sub_82C654D0(ctx, base);
	// 82C65B3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C65B40: 4804391C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C65B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C65B48 size=164
    let mut pc: u32 = 0x82C65B48;
    'dispatch: loop {
        match pc {
            0x82C65B48 => {
    //   block [0x82C65B48..0x82C65B78)
	// 82C65B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C65B4C: 480438C1  bl 0x82ca940c
	ctx.lr = 0x82C65B50;
	sub_82CA93D0(ctx, base);
	// 82C65B50: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82C65B54: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C65B58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C65B5C: 807F009C  lwz r3, 0x9c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82C65B60: 482954D9  bl 0x82efb038
	ctx.lr = 0x82C65B64;
	sub_82EFB038(ctx, base);
	// 82C65B64: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C65B68: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C65B6C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C65B70: 40990024  ble cr6, 0x82c65b94
	if !ctx.cr[6].gt {
	pc = 0x82C65B94; continue 'dispatch;
	}
	// 82C65B74: 3BDF0044  addi r30, r31, 0x44
	ctx.r[30].s64 = ctx.r[31].s64 + 68;
	pc = 0x82C65B78; continue 'dispatch;
            }
            0x82C65B78 => {
    //   block [0x82C65B78..0x82C65B94)
	// 82C65B78: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C65B7C: 480020ED  bl 0x82c67c68
	ctx.lr = 0x82C65B80;
	sub_82C67C68(ctx, base);
	// 82C65B80: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C65B84: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C65B88: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C65B8C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C65B90: 4198FFE8  blt cr6, 0x82c65b78
	if ctx.cr[6].lt {
	pc = 0x82C65B78; continue 'dispatch;
	}
	pc = 0x82C65B94; continue 'dispatch;
            }
            0x82C65B94 => {
    //   block [0x82C65B94..0x82C65BCC)
	// 82C65B94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C65B98: 4BFFFF51  bl 0x82c65ae8
	ctx.lr = 0x82C65B9C;
	sub_82C65AE8(ctx, base);
	// 82C65B9C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C65BA0: 807F0094  lwz r3, 0x94(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82C65BA4: C3EB0C18  lfs f31, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C65BA8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C65BAC: 48001EC5  bl 0x82c67a70
	ctx.lr = 0x82C65BB0;
	sub_82C67A70(ctx, base);
	// 82C65BB0: 807F0098  lwz r3, 0x98(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82C65BB4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C65BB8: 48001EB9  bl 0x82c67a70
	ctx.lr = 0x82C65BBC;
	sub_82C67A70(ctx, base);
	// 82C65BBC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C65BC0: 397F0074  addi r11, r31, 0x74
	ctx.r[11].s64 = ctx.r[31].s64 + 116;
	// 82C65BC4: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82C65BC8: C0090BD0  lfs f0, 0xbd0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3024 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82C65BCC; continue 'dispatch;
            }
            0x82C65BCC => {
    //   block [0x82C65BCC..0x82C65BEC)
	// 82C65BCC: D3EBFFF0  stfs f31, -0x10(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 82C65BD0: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C65BD4: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C65BD8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C65BDC: 4082FFF0  bne 0x82c65bcc
	if !ctx.cr[0].eq {
	pc = 0x82C65BCC; continue 'dispatch;
	}
	// 82C65BE0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C65BE4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82C65BE8: 48043874  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C65BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C65BF0 size=952
    let mut pc: u32 = 0x82C65BF0;
    'dispatch: loop {
        match pc {
            0x82C65BF0 => {
    //   block [0x82C65BF0..0x82C65C34)
	// 82C65BF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C65BF4: 480437ED  bl 0x82ca93e0
	ctx.lr = 0x82C65BF8;
	sub_82CA93D0(ctx, base);
	// 82C65BF8: 3981FF88  addi r12, r1, -0x78
	ctx.r[12].s64 = ctx.r[1].s64 + -120;
	// 82C65BFC: 480480D1  bl 0x82cadccc
	ctx.lr = 0x82C65C00;
	sub_82CADCA0(ctx, base);
	// 82C65C00: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C65C04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C65C08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C65C0C: 7CB42B78  mr r20, r5
	ctx.r[20].u64 = ctx.r[5].u64;
	// 82C65C10: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82C65C14: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C65C18: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C65C1C: 40990018  ble cr6, 0x82c65c34
	if !ctx.cr[6].gt {
	pc = 0x82C65C34; continue 'dispatch;
	}
	// 82C65C20: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C65C24: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82C65C28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C65C2C: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82C65C30: 48043CD9  bl 0x82ca9908
	ctx.lr = 0x82C65C34;
	sub_82CA9908(ctx, base);
	pc = 0x82C65C34; continue 'dispatch;
            }
            0x82C65C34 => {
    //   block [0x82C65C34..0x82C65CA0)
	// 82C65C34: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82C65C38: 807F009C  lwz r3, 0x9c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 82C65C3C: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 82C65C40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C65C44: 4BFFE605  bl 0x82c64248
	ctx.lr = 0x82C65C48;
	sub_82C64248(ctx, base);
	// 82C65C48: 7F12C378  mr r18, r24
	ctx.r[18].u64 = ctx.r[24].u64;
	// 82C65C4C: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82C65C50: 40990334  ble cr6, 0x82c65f84
	if !ctx.cr[6].gt {
	pc = 0x82C65F84; continue 'dispatch;
	}
	// 82C65C54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C65C58: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C65C5C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C65C60: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C65C64: 3CE08210  lis r7, -0x7df0
	ctx.r[7].s64 = -2112880640;
	// 82C65C68: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82C65C6C: C34B0A54  lfs f26, 0xa54(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82C65C70: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82C65C74: C36A0AC8  lfs f27, 0xac8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2760 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82C65C78: C3A90B10  lfs f29, 0xb10(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2832 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82C65C7C: 3B3F00A0  addi r25, r31, 0xa0
	ctx.r[25].s64 = ctx.r[31].s64 + 160;
	// 82C65C80: C3280C14  lfs f25, 0xc14(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3092 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82C65C84: 3ADF0100  addi r22, r31, 0x100
	ctx.r[22].s64 = ctx.r[31].s64 + 256;
	// 82C65C88: CB8713F0  lfd f28, 0x13f0(r7)
	ctx.f[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(5104 as u32) ) };
	// 82C65C8C: 3AFF0084  addi r23, r31, 0x84
	ctx.r[23].s64 = ctx.r[31].s64 + 132;
	// 82C65C90: C3E60AA4  lfs f31, 0xaa4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(2724 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C65C94: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 82C65C98: C3C50C18  lfs f30, 0xc18(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82C65C9C: 3A600001  li r19, 1
	ctx.r[19].s64 = 1;
	pc = 0x82C65CA0; continue 'dispatch;
            }
            0x82C65CA0 => {
    //   block [0x82C65CA0..0x82C65CB0)
	// 82C65CA0: 83DF0010  lwz r30, 0x10(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C65CA4: 7F1EC000  cmpw cr6, r30, r24
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[24].s32, &mut ctx.xer);
	// 82C65CA8: 41980008  blt cr6, 0x82c65cb0
	if ctx.cr[6].lt {
	pc = 0x82C65CB0; continue 'dispatch;
	}
	// 82C65CAC: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	pc = 0x82C65CB0; continue 'dispatch;
            }
            0x82C65CB0 => {
    //   block [0x82C65CB0..0x82C65D28)
	// 82C65CB0: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82C65CB4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C65CB8: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 82C65CBC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C65CC0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C65CC4: 4BFFF8D5  bl 0x82c65598
	ctx.lr = 0x82C65CC8;
	sub_82C65598(ctx, base);
	// 82C65CC8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C65CCC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C65CD0: 807F0094  lwz r3, 0x94(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82C65CD4: 80BF0040  lwz r5, 0x40(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C65CD8: 48001AD9  bl 0x82c677b0
	ctx.lr = 0x82C65CDC;
	sub_82C677B0(ctx, base);
	// 82C65CDC: 80BF0040  lwz r5, 0x40(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C65CE0: 57DA103A  slwi r26, r30, 2
	ctx.r[26].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 82C65CE4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C65CE8: 807F0098  lwz r3, 0x98(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82C65CEC: 7D7A2A14  add r11, r26, r5
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[5].u64;
	// 82C65CF0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C65CF4: C00BFFFC  lfs f0, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65CF8: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82C65CFC: 48001AB5  bl 0x82c677b0
	ctx.lr = 0x82C65D00;
	sub_82C677B0(ctx, base);
	// 82C65D00: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C65D04: C1BF0088  lfs f13, 0x88(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C65D08: 7D4BD214  add r10, r11, r26
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82C65D0C: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 82C65D10: C00AFFFC  lfs f0, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65D14: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82C65D18: 40990010  ble cr6, 0x82c65d28
	if !ctx.cr[6].gt {
	pc = 0x82C65D28; continue 'dispatch;
	}
	// 82C65D1C: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C65D20: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82C65D24: 48000008  b 0x82c65d2c
	pc = 0x82C65D2C; continue 'dispatch;
            }
            0x82C65D28 => {
    //   block [0x82C65D28..0x82C65D2C)
	// 82C65D28: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	pc = 0x82C65D2C; continue 'dispatch;
            }
            0x82C65D2C => {
    //   block [0x82C65D2C..0x82C65D48)
	// 82C65D2C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C65D30: D01F0090  stfs f0, 0x90(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82C65D34: 7EBBAB78  mr r27, r21
	ctx.r[27].u64 = ctx.r[21].u64;
	// 82C65D38: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C65D3C: 40990038  ble cr6, 0x82c65d74
	if !ctx.cr[6].gt {
	pc = 0x82C65D74; continue 'dispatch;
	}
	// 82C65D40: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82C65D44: 3B9F0044  addi r28, r31, 0x44
	ctx.r[28].s64 = ctx.r[31].s64 + 68;
	pc = 0x82C65D48; continue 'dispatch;
            }
            0x82C65D48 => {
    //   block [0x82C65D48..0x82C65D74)
	// 82C65D48: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C65D4C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C65D50: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C65D54: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82C65D58: 48002899  bl 0x82c685f0
	ctx.lr = 0x82C65D5C;
	sub_82C685F0(ctx, base);
	// 82C65D5C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C65D60: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82C65D64: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82C65D68: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82C65D6C: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C65D70: 4198FFD8  blt cr6, 0x82c65d48
	if ctx.cr[6].lt {
	pc = 0x82C65D48; continue 'dispatch;
	}
	pc = 0x82C65D74; continue 'dispatch;
            }
            0x82C65D74 => {
    //   block [0x82C65D74..0x82C65DCC)
	// 82C65D74: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C65D78: 809F0040  lwz r4, 0x40(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C65D7C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C65D80: 4BFFF341  bl 0x82c650c0
	ctx.lr = 0x82C65D84;
	sub_82C650C0(ctx, base);
	// 82C65D84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C65D88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C65D8C: 4BFFF985  bl 0x82c65710
	ctx.lr = 0x82C65D90;
	sub_82C65710(ctx, base);
	// 82C65D90: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C65D94: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C65D98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C65D9C: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C65DA0: 80BF0040  lwz r5, 0x40(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C65DA4: 48000D2D  bl 0x82c66ad0
	ctx.lr = 0x82C65DA8;
	sub_82C66AD0(ctx, base);
	// 82C65DA8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C65DAC: 809F0040  lwz r4, 0x40(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C65DB0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82C65DB4: 4BFFF30D  bl 0x82c650c0
	ctx.lr = 0x82C65DB8;
	sub_82C650C0(ctx, base);
	// 82C65DB8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C65DBC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C65DC0: 40990024  ble cr6, 0x82c65de4
	if !ctx.cr[6].gt {
	pc = 0x82C65DE4; continue 'dispatch;
	}
	// 82C65DC4: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C65DC8: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	pc = 0x82C65DCC; continue 'dispatch;
            }
            0x82C65DCC => {
    //   block [0x82C65DCC..0x82C65DE4)
	// 82C65DCC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C65DD0: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C65DD4: 7D29D214  add r9, r9, r26
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[26].u64;
	// 82C65DD8: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C65DDC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C65DE0: 4082FFEC  bne 0x82c65dcc
	if !ctx.cr[0].eq {
	pc = 0x82C65DCC; continue 'dispatch;
	}
	pc = 0x82C65DE4; continue 'dispatch;
            }
            0x82C65DE4 => {
    //   block [0x82C65DE4..0x82C65E50)
	// 82C65DE4: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C65DE8: 7F1EC050  subf r24, r30, r24
	ctx.r[24].s64 = ctx.r[24].s64 - ctx.r[30].s64;
	// 82C65DEC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C65DF0: 7D3E5051  subf. r9, r30, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[30].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C65DF4: 7D0BF214  add r8, r11, r30
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C65DF8: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82C65DFC: 911F0014  stw r8, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82C65E00: 4082017C  bne 0x82c65f7c
	if !ctx.cr[0].eq {
	pc = 0x82C65F7C; continue 'dispatch;
	}
	// 82C65E04: C01F0068  lfs f0, 0x68(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65E08: 38BF0078  addi r5, r31, 0x78
	ctx.r[5].s64 = ctx.r[31].s64 + 120;
	// 82C65E0C: C1BF007C  lfs f13, 0x7c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C65E10: C19F006C  lfs f12, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C65E14: C17F0078  lfs f11, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C65E18: C15F0070  lfs f10, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C65E1C: C13F0080  lfs f9, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C65E20: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82C65E24: D17F0074  stfs f11, 0x74(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82C65E28: D1BF0078  stfs f13, 0x78(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82C65E2C: D19F0068  stfs f12, 0x68(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82C65E30: D13F007C  stfs f9, 0x7c(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82C65E34: D15F006C  stfs f10, 0x6c(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82C65E38: C0170000  lfs f0, 0(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65E3C: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82C65E40: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82C65E44: 409A000C  bne cr6, 0x82c65e50
	if !ctx.cr[6].eq {
	pc = 0x82C65E50; continue 'dispatch;
	}
	// 82C65E48: FC00E090  fmr f0, f28
	ctx.f[0].f64 = ctx.f[28].f64;
	// 82C65E4C: 4800000C  b 0x82c65e58
	pc = 0x82C65E58; continue 'dispatch;
            }
            0x82C65E50 => {
    //   block [0x82C65E50..0x82C65E58)
	// 82C65E50: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C65E54: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	pc = 0x82C65E58; continue 'dispatch;
            }
            0x82C65E58 => {
    //   block [0x82C65E58..0x82C65EA8)
	// 82C65E58: 817F0168  lwz r11, 0x168(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(360 as u32) ) } as u64;
	// 82C65E5C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82C65E60: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82C65E64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C65E68: 409A006C  bne cr6, 0x82c65ed4
	if !ctx.cr[6].eq {
	pc = 0x82C65ED4; continue 'dispatch;
	}
	// 82C65E6C: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82C65E70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C65E74: 419A0060  beq cr6, 0x82c65ed4
	if ctx.cr[6].eq {
	pc = 0x82C65ED4; continue 'dispatch;
	}
	// 82C65E78: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65E7C: FF00C800  fcmpu cr6, f0, f25
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[25].f64);
	// 82C65E80: 40980054  bge cr6, 0x82c65ed4
	if !ctx.cr[6].lt {
	pc = 0x82C65ED4; continue 'dispatch;
	}
	// 82C65E84: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C65E88: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82C65E8C: 409A0048  bne cr6, 0x82c65ed4
	if !ctx.cr[6].eq {
	pc = 0x82C65ED4; continue 'dispatch;
	}
	// 82C65E90: C01F016C  lfs f0, 0x16c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65E94: 927F0168  stw r19, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[19].u32 ) };
	// 82C65E98: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82C65E9C: 409A000C  bne cr6, 0x82c65ea8
	if !ctx.cr[6].eq {
	pc = 0x82C65EA8; continue 'dispatch;
	}
	// 82C65EA0: D3FF016C  stfs f31, 0x16c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 82C65EA4: 48000010  b 0x82c65eb4
	pc = 0x82C65EB4; continue 'dispatch;
            }
            0x82C65EA8 => {
    //   block [0x82C65EA8..0x82C65EB4)
	// 82C65EA8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82C65EAC: 409A0008  bne cr6, 0x82c65eb4
	if !ctx.cr[6].eq {
	pc = 0x82C65EB4; continue 'dispatch;
	}
	// 82C65EB0: D37F016C  stfs f27, 0x16c(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	pc = 0x82C65EB4; continue 'dispatch;
            }
            0x82C65EB4 => {
    //   block [0x82C65EB4..0x82C65ED4)
	// 82C65EB4: C05F016C  lfs f2, 0x16c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C65EB8: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C65EBC: 4BFFF965  bl 0x82c65820
	ctx.lr = 0x82C65EC0;
	sub_82C65820(ctx, base);
	// 82C65EC0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C65EC4: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82C65EC8: 4BFFF611  bl 0x82c654d8
	ctx.lr = 0x82C65ECC;
	sub_82C654D8(ctx, base);
	// 82C65ECC: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82C65ED0: 4BFFF5F9  bl 0x82c654c8
	ctx.lr = 0x82C65ED4;
	sub_82C654C8(ctx, base);
	pc = 0x82C65ED4; continue 'dispatch;
            }
            0x82C65ED4 => {
    //   block [0x82C65ED4..0x82C65F28)
	// 82C65ED4: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C65ED8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C65EDC: 409A0094  bne cr6, 0x82c65f70
	if !ctx.cr[6].eq {
	pc = 0x82C65F70; continue 'dispatch;
	}
	// 82C65EE0: C03F0080  lfs f1, 0x80(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C65EE4: C01F0104  lfs f0, 0x104(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65EE8: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82C65EEC: 40990084  ble cr6, 0x82c65f70
	if !ctx.cr[6].gt {
	pc = 0x82C65F70; continue 'dispatch;
	}
	// 82C65EF0: 92BF0168  stw r21, 0x168(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(360 as u32), ctx.r[21].u32 ) };
	// 82C65EF4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C65EF8: 4BFFF159  bl 0x82c65050
	ctx.lr = 0x82C65EFC;
	sub_82C65050(ctx, base);
	// 82C65EFC: 817F003C  lwz r11, 0x3c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82C65F00: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C65F04: 419A0054  beq cr6, 0x82c65f58
	if ctx.cr[6].eq {
	pc = 0x82C65F58; continue 'dispatch;
	}
	// 82C65F08: C01F0090  lfs f0, 0x90(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C65F0C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82C65F10: 40990018  ble cr6, 0x82c65f28
	if !ctx.cr[6].gt {
	pc = 0x82C65F28; continue 'dispatch;
	}
	// 82C65F14: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C65F18: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 82C65F1C: D37F016C  stfs f27, 0x16c(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 82C65F20: 4BFFF901  bl 0x82c65820
	ctx.lr = 0x82C65F24;
	sub_82C65820(ctx, base);
	// 82C65F24: 48000038  b 0x82c65f5c
	pc = 0x82C65F5C; continue 'dispatch;
            }
            0x82C65F28 => {
    //   block [0x82C65F28..0x82C65F44)
	// 82C65F28: FF00D000  fcmpu cr6, f0, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82C65F2C: 40990018  ble cr6, 0x82c65f44
	if !ctx.cr[6].gt {
	pc = 0x82C65F44; continue 'dispatch;
	}
	// 82C65F30: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C65F34: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82C65F38: D3FF016C  stfs f31, 0x16c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 82C65F3C: 4BFFF8E5  bl 0x82c65820
	ctx.lr = 0x82C65F40;
	sub_82C65820(ctx, base);
	// 82C65F40: 4800001C  b 0x82c65f5c
	pc = 0x82C65F5C; continue 'dispatch;
            }
            0x82C65F44 => {
    //   block [0x82C65F44..0x82C65F58)
	// 82C65F44: C03F0000  lfs f1, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C65F48: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 82C65F4C: D3BF016C  stfs f29, 0x16c(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(364 as u32), tmp.u32 ) };
	// 82C65F50: 4BFFF8D1  bl 0x82c65820
	ctx.lr = 0x82C65F54;
	sub_82C65820(ctx, base);
	// 82C65F54: 48000008  b 0x82c65f5c
	pc = 0x82C65F5C; continue 'dispatch;
            }
            0x82C65F58 => {
    //   block [0x82C65F58..0x82C65F5C)
	// 82C65F58: C03F0038  lfs f1, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x82C65F5C; continue 'dispatch;
            }
            0x82C65F5C => {
    //   block [0x82C65F5C..0x82C65F70)
	// 82C65F5C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C65F60: 4BFFF569  bl 0x82c654c8
	ctx.lr = 0x82C65F64;
	sub_82C654C8(ctx, base);
	// 82C65F64: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82C65F68: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82C65F6C: 4BFFFA85  bl 0x82c659f0
	ctx.lr = 0x82C65F70;
	sub_82C659F0(ctx, base);
	pc = 0x82C65F70; continue 'dispatch;
            }
            0x82C65F70 => {
    //   block [0x82C65F70..0x82C65F7C)
	// 82C65F70: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C65F74: D3D70000  stfs f30, 0(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C65F78: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x82C65F7C; continue 'dispatch;
            }
            0x82C65F7C => {
    //   block [0x82C65F7C..0x82C65F84)
	// 82C65F7C: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82C65F80: 4199FD20  bgt cr6, 0x82c65ca0
	if ctx.cr[6].gt {
	pc = 0x82C65CA0; continue 'dispatch;
	}
	pc = 0x82C65F84; continue 'dispatch;
            }
            0x82C65F84 => {
    //   block [0x82C65F84..0x82C65FA8)
	// 82C65F84: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 82C65F88: C03F001C  lfs f1, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C65F8C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82C65F90: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C65F94: 4BFFF725  bl 0x82c656b8
	ctx.lr = 0x82C65F98;
	sub_82C656B8(ctx, base);
	// 82C65F98: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82C65F9C: 3981FF88  addi r12, r1, -0x78
	ctx.r[12].s64 = ctx.r[1].s64 + -120;
	// 82C65FA0: 48047D79  bl 0x82cadd18
	ctx.lr = 0x82C65FA4;
	sub_82CADCEC(ctx, base);
	// 82C65FA4: 4804348C  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C65FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C65FA8 size=412
    let mut pc: u32 = 0x82C65FA8;
    'dispatch: loop {
        match pc {
            0x82C65FA8 => {
    //   block [0x82C65FA8..0x82C66038)
	// 82C65FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C65FAC: 4804345D  bl 0x82ca9408
	ctx.lr = 0x82C65FB0;
	sub_82CA93D0(ctx, base);
	// 82C65FB0: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82C65FB4: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82C65FB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C65FBC: 38800170  li r4, 0x170
	ctx.r[4].s64 = 368;
	// 82C65FC0: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82C65FC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C65FC8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C65FCC: 4BFFDF6D  bl 0x82c63f38
	ctx.lr = 0x82C65FD0;
	sub_82C63F38(ctx, base);
	// 82C65FD0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C65FD4: D3DF0000  stfs f30, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C65FD8: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82C65FDC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C65FE0: C80BD6F0  lfd f0, -0x2910(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-10512 as u32) ) };
	// 82C65FE4: FC1E0032  fmul f0, f30, f0
	ctx.f[0].f64 = ctx.f[30].f64 * ctx.f[0].f64;
	// 82C65FE8: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82C65FEC: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 82C65FF0: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C65FF4: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C65FF8: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82C65FFC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C66000: 4BFFDFE1  bl 0x82c63fe0
	ctx.lr = 0x82C66004;
	sub_82C63FE0(ctx, base);
	// 82C66004: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C66008: 907F009C  stw r3, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[3].u32 ) };
	// 82C6600C: C19F0000  lfs f12, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C66010: C0080BE8  lfs f0, 0xbe8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3048 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C66014: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C66018: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82C6601C: D9410050  stfd f10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[10].u64 ) };
	// 82C66020: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C66024: 4BFFE345  bl 0x82c64368
	ctx.lr = 0x82C66028;
	sub_82C64368(ctx, base);
	// 82C66028: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82C6602C: 40990028  ble cr6, 0x82c66054
	if !ctx.cr[6].gt {
	pc = 0x82C66054; continue 'dispatch;
	}
	// 82C66030: 3BBF0044  addi r29, r31, 0x44
	ctx.r[29].s64 = ctx.r[31].s64 + 68;
	// 82C66034: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82C66038; continue 'dispatch;
            }
            0x82C66038 => {
    //   block [0x82C66038..0x82C66054)
	// 82C66038: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6603C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C66040: 48001BA1  bl 0x82c67be0
	ctx.lr = 0x82C66044;
	sub_82C67BE0(ctx, base);
	// 82C66044: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C66048: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C6604C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82C66050: 4082FFE8  bne 0x82c66038
	if !ctx.cr[0].eq {
	pc = 0x82C66038; continue 'dispatch;
	}
	pc = 0x82C66054; continue 'dispatch;
            }
            0x82C66054 => {
    //   block [0x82C66054..0x82C66144)
	// 82C66054: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C66058: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C6605C: 4BFFDF0D  bl 0x82c63f68
	ctx.lr = 0x82C66060;
	sub_82C63F68(ctx, base);
	// 82C66060: 907F0040  stw r3, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[3].u32 ) };
	// 82C66064: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C66068: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C6606C: 48001A85  bl 0x82c67af0
	ctx.lr = 0x82C66070;
	sub_82C67AF0(ctx, base);
	// 82C66070: 907F0094  stw r3, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[3].u32 ) };
	// 82C66074: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C66078: 480019E9  bl 0x82c67a60
	ctx.lr = 0x82C6607C;
	sub_82C67A60(ctx, base);
	// 82C6607C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C66080: 807F0094  lwz r3, 0x94(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82C66084: C3EA0AA4  lfs f31, 0xaa4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2724 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C66088: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C6608C: 4800194D  bl 0x82c679d8
	ctx.lr = 0x82C66090;
	sub_82C679D8(ctx, base);
	// 82C66090: 807F0094  lwz r3, 0x94(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 82C66094: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C66098: 48001981  bl 0x82c67a18
	ctx.lr = 0x82C6609C;
	sub_82C67A18(ctx, base);
	// 82C6609C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C660A0: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C660A4: 48001A4D  bl 0x82c67af0
	ctx.lr = 0x82C660A8;
	sub_82C67AF0(ctx, base);
	// 82C660A8: 907F0098  stw r3, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[3].u32 ) };
	// 82C660AC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C660B0: 480019B1  bl 0x82c67a60
	ctx.lr = 0x82C660B4;
	sub_82C67A60(ctx, base);
	// 82C660B4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C660B8: 807F0098  lwz r3, 0x98(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82C660BC: C3C90C18  lfs f30, 0xc18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82C660C0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C660C4: 48001915  bl 0x82c679d8
	ctx.lr = 0x82C660C8;
	sub_82C679D8(ctx, base);
	// 82C660C8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C660CC: 807F0098  lwz r3, 0x98(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 82C660D0: C0280C4C  lfs f1, 0xc4c(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3148 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C660D4: 48001945  bl 0x82c67a18
	ctx.lr = 0x82C660D8;
	sub_82C67A18(ctx, base);
	// 82C660D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C660DC: 4BFFFA0D  bl 0x82c65ae8
	ctx.lr = 0x82C660E0;
	sub_82C65AE8(ctx, base);
	// 82C660E0: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82C660E4: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82C660E8: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C660EC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C660F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C660F4: C0070C14  lfs f0, 0xc14(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C660F8: C1A60DB0  lfs f13, 0xdb0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C660FC: D01F0160  stfs f0, 0x160(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(352 as u32), tmp.u32 ) };
	// 82C66100: D1BF0164  stfs f13, 0x164(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(356 as u32), tmp.u32 ) };
	// 82C66104: 4BFFF81D  bl 0x82c65920
	ctx.lr = 0x82C66108;
	sub_82C65920(ctx, base);
	// 82C66108: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6610C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C66110: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C66114: 4BFFF875  bl 0x82c65988
	ctx.lr = 0x82C66118;
	sub_82C65988(ctx, base);
	// 82C66118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6611C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C66120: 4BFFF731  bl 0x82c65850
	ctx.lr = 0x82C66124;
	sub_82C65850(ctx, base);
	// 82C66124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C66128: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6612C: 90BF0010  stw r5, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	// 82C66130: 4BFFFA19  bl 0x82c65b48
	ctx.lr = 0x82C66134;
	sub_82C65B48(ctx, base);
	// 82C66134: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C66138: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82C6613C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82C66140: 48043318  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C66148 size=88
    let mut pc: u32 = 0x82C66148;
    'dispatch: loop {
        match pc {
            0x82C66148 => {
    //   block [0x82C66148..0x82C661A0)
	// 82C66148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6614C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C66150: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C66154: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C66158: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82C6615C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C66160: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 82C66164: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C66168: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C6616C: 4BFFDDFD  bl 0x82c63f68
	ctx.lr = 0x82C66170;
	sub_82C63F68(ctx, base);
	// 82C66170: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C66174: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C66178: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C6617C: 4BFFFE2D  bl 0x82c65fa8
	ctx.lr = 0x82C66180;
	sub_82C65FA8(ctx, base);
	// 82C66180: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C66184: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C66188: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6618C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C66190: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82C66194: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C66198: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6619C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C661A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C661A0 size=88
    let mut pc: u32 = 0x82C661A0;
    'dispatch: loop {
        match pc {
            0x82C661A0 => {
    //   block [0x82C661A0..0x82C661C8)
	// 82C661A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C661A4: 48043265  bl 0x82ca9408
	ctx.lr = 0x82C661A8;
	sub_82CA93D0(ctx, base);
	// 82C661A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C661AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C661B0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82C661B4: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82C661B8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C661BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C661C0: 40990030  ble cr6, 0x82c661f0
	if !ctx.cr[6].gt {
	pc = 0x82C661F0; continue 'dispatch;
	}
	// 82C661C4: 3BFD0008  addi r31, r29, 8
	ctx.r[31].s64 = ctx.r[29].s64 + 8;
	pc = 0x82C661C8; continue 'dispatch;
            }
            0x82C661C8 => {
    //   block [0x82C661C8..0x82C661DC)
	// 82C661C8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C661CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C661D0: 419A000C  beq cr6, 0x82c661dc
	if ctx.cr[6].eq {
	pc = 0x82C661DC; continue 'dispatch;
	}
	// 82C661D4: 48002645  bl 0x82c68818
	ctx.lr = 0x82C661D8;
	sub_82C68818(ctx, base);
	// 82C661D8: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82C661DC; continue 'dispatch;
            }
            0x82C661DC => {
    //   block [0x82C661DC..0x82C661F0)
	// 82C661DC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C661E0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C661E4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82C661E8: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C661EC: 4198FFDC  blt cr6, 0x82c661c8
	if ctx.cr[6].lt {
	pc = 0x82C661C8; continue 'dispatch;
	}
	pc = 0x82C661F0; continue 'dispatch;
            }
            0x82C661F0 => {
    //   block [0x82C661F0..0x82C661F8)
	// 82C661F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C661F4: 48043264  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C661F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C661F8 size=56
    let mut pc: u32 = 0x82C661F8;
    'dispatch: loop {
        match pc {
            0x82C661F8 => {
    //   block [0x82C661F8..0x82C66230)
	// 82C661F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C661FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C66200: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C66204: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C66208: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6620C: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 82C66210: 48294E29  bl 0x82efb038
	ctx.lr = 0x82C66214;
	sub_82EFB038(ctx, base);
	// 82C66214: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C66218: 4BFFFF89  bl 0x82c661a0
	ctx.lr = 0x82C6621C;
	sub_82C661A0(ctx, base);
	// 82C6621C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C66220: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C66224: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C66228: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6622C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C66230 size=52
    let mut pc: u32 = 0x82C66230;
    'dispatch: loop {
        match pc {
            0x82C66230 => {
    //   block [0x82C66230..0x82C66264)
	// 82C66230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C66234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C66238: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6623C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C66240: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C66244: 4BFFFFB5  bl 0x82c661f8
	ctx.lr = 0x82C66248;
	sub_82C661F8(ctx, base);
	// 82C66248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6624C: 4BFFDD2D  bl 0x82c63f78
	ctx.lr = 0x82C66250;
	sub_82C63F78(ctx, base);
	// 82C66250: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C66254: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C66258: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6625C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C66260: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C66268 size=144
    let mut pc: u32 = 0x82C66268;
    'dispatch: loop {
        match pc {
            0x82C66268 => {
    //   block [0x82C66268..0x82C662A0)
	// 82C66268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6626C: 480431A1  bl 0x82ca940c
	ctx.lr = 0x82C66270;
	sub_82CA93D0(ctx, base);
	// 82C66270: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C66274: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C66278: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 82C6627C: 48002925  bl 0x82c68ba0
	ctx.lr = 0x82C66280;
	sub_82C68BA0(ctx, base);
	// 82C66280: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C66284: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C66288: 419A0034  beq cr6, 0x82c662bc
	if ctx.cr[6].eq {
	pc = 0x82C662BC; continue 'dispatch;
	}
	// 82C6628C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66290: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C66294: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C66298: 40990024  ble cr6, 0x82c662bc
	if !ctx.cr[6].gt {
	pc = 0x82C662BC; continue 'dispatch;
	}
	// 82C6629C: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	pc = 0x82C662A0; continue 'dispatch;
            }
            0x82C662A0 => {
    //   block [0x82C662A0..0x82C662BC)
	// 82C662A0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C662A4: 480025AD  bl 0x82c68850
	ctx.lr = 0x82C662A8;
	sub_82C68850(ctx, base);
	// 82C662A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C662AC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C662B0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C662B4: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C662B8: 4198FFE8  blt cr6, 0x82c662a0
	if ctx.cr[6].lt {
	pc = 0x82C662A0; continue 'dispatch;
	}
	pc = 0x82C662BC; continue 'dispatch;
            }
            0x82C662BC => {
    //   block [0x82C662BC..0x82C662D8)
	// 82C662BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C662C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C662C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C662C8: 40990028  ble cr6, 0x82c662f0
	if !ctx.cr[6].gt {
	pc = 0x82C662F0; continue 'dispatch;
	}
	// 82C662CC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C662D0: 397F0058  addi r11, r31, 0x58
	ctx.r[11].s64 = ctx.r[31].s64 + 88;
	// 82C662D4: C8090D38  lfd f0, 0xd38(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(3384 as u32) ) };
	pc = 0x82C662D8; continue 'dispatch;
            }
            0x82C662D8 => {
    //   block [0x82C662D8..0x82C662F0)
	// 82C662D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C662DC: D80B0000  stfd f0, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.f[0].u64 ) };
	// 82C662E0: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C662E4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82C662E8: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82C662EC: 4198FFEC  blt cr6, 0x82c662d8
	if ctx.cr[6].lt {
	pc = 0x82C662D8; continue 'dispatch;
	}
	pc = 0x82C662F0; continue 'dispatch;
            }
            0x82C662F0 => {
    //   block [0x82C662F0..0x82C662F8)
	// 82C662F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C662F4: 48043168  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C662F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C662F8 size=72
    let mut pc: u32 = 0x82C662F8;
    'dispatch: loop {
        match pc {
            0x82C662F8 => {
    //   block [0x82C662F8..0x82C66340)
	// 82C662F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C662FC: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82C66300: 3944FFFF  addi r10, r4, -1
	ctx.r[10].s64 = ctx.r[4].s64 + -1;
	// 82C66304: 7D692030  slw r9, r11, r4
	if (ctx.r[4].u8 & 0x20) != 0 {
		ctx.r[9].u64 = 0;
	} else {
		ctx.r[9].u64 = ((ctx.r[11].u32) << ((ctx.r[4].u8 & 0x1F) as u32)) as u64;
	}
	// 82C66308: 7D685030  slw r8, r11, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[11].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 82C6630C: 7D0707B4  extsw r7, r8
	ctx.r[7].s64 = ctx.r[8].s32 as i64;
	// 82C66310: 7D2607B4  extsw r6, r9
	ctx.r[6].s64 = ctx.r[9].s32 as i64;
	// 82C66314: F8E1FFF0  std r7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[7].u64 ) };
	// 82C66318: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6631C: F8C1FFF0  std r6, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u64 ) };
	// 82C66320: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C66324: FD60069C  fcfid f11, f0
	ctx.f[11].f64 = (ctx.f[0].s64 as f64);
	// 82C66328: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82C6632C: FD205818  frsp f9, f11
	ctx.f[9].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82C66330: D9230050  stfd f9, 0x50(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.f[9].u64 ) };
	// 82C66334: FD406018  frsp f10, f12
	ctx.f[10].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82C66338: D9430048  stfd f10, 0x48(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.f[10].u64 ) };
	// 82C6633C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C66340 size=52
    let mut pc: u32 = 0x82C66340;
    'dispatch: loop {
        match pc {
            0x82C66340 => {
    //   block [0x82C66340..0x82C6634C)
	// 82C66340: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C66344: 40980008  bge cr6, 0x82c6634c
	if !ctx.cr[6].lt {
	pc = 0x82C6634C; continue 'dispatch;
	}
	// 82C66348: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82C6634C; continue 'dispatch;
            }
            0x82C6634C => {
    //   block [0x82C6634C..0x82C66360)
	// 82C6634C: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82C66350: 816BA878  lwz r11, -0x5788(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22408 as u32) ) } as u64;
	// 82C66354: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C66358: 41980008  blt cr6, 0x82c66360
	if ctx.cr[6].lt {
	pc = 0x82C66360; continue 'dispatch;
	}
	// 82C6635C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	pc = 0x82C66360; continue 'dispatch;
            }
            0x82C66360 => {
    //   block [0x82C66360..0x82C66374)
	// 82C66360: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82C66364: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C66368: 392BA848  addi r9, r11, -0x57b8
	ctx.r[9].s64 = ctx.r[11].s64 + -22456;
	// 82C6636C: 7C6A482E  lwzx r3, r10, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82C66370: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C66378 size=88
    let mut pc: u32 = 0x82C66378;
    'dispatch: loop {
        match pc {
            0x82C66378 => {
    //   block [0x82C66378..0x82C66390)
	// 82C66378: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82C6637C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C66380: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C66384: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C66388: 40990040  ble cr6, 0x82c663c8
	if !ctx.cr[6].gt {
	pc = 0x82C663C8; continue 'dispatch;
	}
	// 82C6638C: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82C66390; continue 'dispatch;
            }
            0x82C66390 => {
    //   block [0x82C66390..0x82C663C8)
	// 82C66390: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66394: 7D0707B4  extsw r7, r8
	ctx.r[7].s64 = ctx.r[8].s32 as i64;
	// 82C66398: F8E1FFF0  std r7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[7].u64 ) };
	// 82C6639C: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C663A0: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82C663A4: FC006818  frsp f0, f13
	ctx.f[0].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82C663A8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C663AC: 419A0020  beq cr6, 0x82c663cc
	if ctx.cr[6].eq {
	pc = 0x82C663CC; continue 'dispatch;
	}
	// 82C663B0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C663B4: 4198001C  blt cr6, 0x82c663d0
	if ctx.cr[6].lt {
		sub_82C663D0(ctx, base);
		return;
	}
	// 82C663B8: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 82C663BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C663C0: 7F035000  cmpw cr6, r3, r10
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82C663C4: 4198FFCC  blt cr6, 0x82c66390
	if ctx.cr[6].lt {
	pc = 0x82C66390; continue 'dispatch;
	}
	pc = 0x82C663C8; continue 'dispatch;
            }
            0x82C663C8 => {
    //   block [0x82C663C8..0x82C663CC)
	// 82C663C8: 386AFFFF  addi r3, r10, -1
	ctx.r[3].s64 = ctx.r[10].s64 + -1;
	pc = 0x82C663CC; continue 'dispatch;
            }
            0x82C663CC => {
    //   block [0x82C663CC..0x82C663D0)
	// 82C663CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C663D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C663D0 size=92
    let mut pc: u32 = 0x82C663D0;
    'dispatch: loop {
        match pc {
            0x82C663D0 => {
    //   block [0x82C663D0..0x82C6642C)
	// 82C663D0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C663D4: 40990058  ble cr6, 0x82c6642c
	if !ctx.cr[6].gt {
		sub_82C6642C(ctx, base);
		return;
	}
	// 82C663D8: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C663DC: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C663E0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82C663E4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C663E8: 812BFFFC  lwz r9, -4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82C663EC: 7D4807B4  extsw r8, r10
	ctx.r[8].s64 = ctx.r[10].s32 as i64;
	// 82C663F0: 7D2707B4  extsw r7, r9
	ctx.r[7].s64 = ctx.r[9].s32 as i64;
	// 82C663F4: F901FFF0  std r8, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u64 ) };
	// 82C663F8: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C663FC: F8E1FFF0  std r7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[7].u64 ) };
	// 82C66400: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C66404: FD60069C  fcfid f11, f0
	ctx.f[11].f64 = (ctx.f[0].s64 as f64);
	// 82C66408: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82C6640C: FD205818  frsp f9, f11
	ctx.f[9].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82C66410: FD406018  frsp f10, f12
	ctx.f[10].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82C66414: ECE90828  fsubs f7, f9, f1
	ctx.f[7].f64 = (((ctx.f[9].f64 - ctx.f[1].f64) as f32) as f64);
	// 82C66418: ED015028  fsubs f8, f1, f10
	ctx.f[8].f64 = (((ctx.f[1].f64 - ctx.f[10].f64) as f32) as f64);
	// 82C6641C: FF083800  fcmpu cr6, f8, f7
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[7].f64);
	// 82C66420: 4098FFAC  bge cr6, 0x82c663cc
	if !ctx.cr[6].lt {
		sub_82C66378(ctx, base);
		return;
	}
	// 82C66424: 3863FFFF  addi r3, r3, -1
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	// 82C66428: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6642C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C6642C size=8
    let mut pc: u32 = 0x82C6642C;
    'dispatch: loop {
        match pc {
            0x82C6642C => {
    //   block [0x82C6642C..0x82C66434)
	// 82C6642C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C66430: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C66438 size=168
    let mut pc: u32 = 0x82C66438;
    'dispatch: loop {
        match pc {
            0x82C66438 => {
    //   block [0x82C66438..0x82C66478)
	// 82C66438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6643C: 48042FD1  bl 0x82ca940c
	ctx.lr = 0x82C66440;
	sub_82CA93D0(ctx, base);
	// 82C66440: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C66444: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C66448: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C6644C: 909F0030  stw r4, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[4].u32 ) };
	// 82C66450: 419A0080  beq cr6, 0x82c664d0
	if ctx.cr[6].eq {
	pc = 0x82C664D0; continue 'dispatch;
	}
	// 82C66454: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C66458: C03F0028  lfs f1, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C6645C: 4BFFFF1D  bl 0x82c66378
	ctx.lr = 0x82C66460;
	sub_82C66378(ctx, base);
	// 82C66460: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66464: 907F002C  stw r3, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[3].u32 ) };
	// 82C66468: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C6646C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C66470: 40990068  ble cr6, 0x82c664d8
	if !ctx.cr[6].gt {
	pc = 0x82C664D8; continue 'dispatch;
	}
	// 82C66474: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	pc = 0x82C66478; continue 'dispatch;
            }
            0x82C66478 => {
    //   block [0x82C66478..0x82C664D0)
	// 82C66478: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C6647C: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C66480: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66484: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C66488: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6648C: 7D69402E  lwzx r11, r9, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82C66490: 388BFFFF  addi r4, r11, -1
	ctx.r[4].s64 = ctx.r[11].s64 + -1;
	// 82C66494: 4800245D  bl 0x82c688f0
	ctx.lr = 0x82C66498;
	sub_82C688F0(ctx, base);
	// 82C66498: 80FF0030  lwz r7, 0x30(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C6649C: 80DF002C  lwz r6, 0x2c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C664A0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C664A4: 54C5103A  slwi r5, r6, 2
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82C664A8: 80870010  lwz r4, 0x10(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C664AC: 7C85202E  lwzx r4, r5, r4
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82C664B0: 480023E9  bl 0x82c68898
	ctx.lr = 0x82C664B4;
	sub_82C68898(ctx, base);
	// 82C664B4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C664B8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C664BC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C664C0: 7F1D1800  cmpw cr6, r29, r3
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[3].s32, &mut ctx.xer);
	// 82C664C4: 4198FFB4  blt cr6, 0x82c66478
	if ctx.cr[6].lt {
	pc = 0x82C66478; continue 'dispatch;
	}
	// 82C664C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C664CC: 48042F90  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C664D0 => {
    //   block [0x82C664D0..0x82C664D8)
	// 82C664D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C664D4: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	pc = 0x82C664D8; continue 'dispatch;
            }
            0x82C664D8 => {
    //   block [0x82C664D8..0x82C664E0)
	// 82C664D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C664DC: 48042F80  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C664E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C664E0 size=52
    let mut pc: u32 = 0x82C664E0;
    'dispatch: loop {
        match pc {
            0x82C664E0 => {
    //   block [0x82C664E0..0x82C66514)
	// 82C664E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C664E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C664E8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C664EC: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82C664F0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C664F4: 4BFFFE4D  bl 0x82c66340
	ctx.lr = 0x82C664F8;
	sub_82C66340(ctx, base);
	// 82C664F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C664FC: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 82C66500: 4BFFFF39  bl 0x82c66438
	ctx.lr = 0x82C66504;
	sub_82C66438(ctx, base);
	// 82C66504: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C66508: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6650C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C66510: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C66520 size=44
    let mut pc: u32 = 0x82C66520;
    'dispatch: loop {
        match pc {
            0x82C66520 => {
    //   block [0x82C66520..0x82C6654C)
	// 82C66520: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C66524: C80B0D38  lfd f0, 0xd38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3384 as u32) ) };
	// 82C66528: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C6652C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C66530: C80B0D30  lfd f0, 0xd30(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3376 as u32) ) };
	// 82C66534: 40990018  ble cr6, 0x82c6654c
	if !ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x82C6654C);
		return;
	}
	// 82C66538: FC01002A  fadd f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 + ctx.f[0].f64;
	// 82C6653C: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82C66540: D801FFF0  stfd f0, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[0].u64 ) };
	// 82C66544: 8061FFF4  lwz r3, -0xc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82C66548: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C66560 size=504
    let mut pc: u32 = 0x82C66560;
    'dispatch: loop {
        match pc {
            0x82C66560 => {
    //   block [0x82C66560..0x82C665DC)
	// 82C66560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C66564: 48042E85  bl 0x82ca93e8
	ctx.lr = 0x82C66568;
	sub_82CA93D0(ctx, base);
	// 82C66568: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 82C6656C: 48047759  bl 0x82cadcc4
	ctx.lr = 0x82C66570;
	sub_82CADCA0(ctx, base);
	// 82C66570: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C66574: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C66578: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C6657C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C66580: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82C66584: C9BF0048  lfd f13, 0x48(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	// 82C66588: 813F0034  lwz r9, 0x34(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C6658C: C80B0DE8  lfd f0, 0xde8(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3560 as u32) ) };
	// 82C66590: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66594: FFA06824  fdiv f29, f0, f13
	ctx.f[29].f64 = ctx.f[0].f64 / ctx.f[13].f64;
	// 82C66598: CB6A0CB8  lfd f27, 0xcb8(r10)
	ctx.f[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3256 as u32) ) };
	// 82C6659C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C665A0: FEFBE828  fsub f23, f27, f29
	ctx.f[23].f64 = ctx.f[27].f64 - ctx.f[29].f64;
	// 82C665A4: 419A016C  beq cr6, 0x82c66710
	if ctx.cr[6].eq {
	pc = 0x82C66710; continue 'dispatch;
	}
	// 82C665A8: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 82C665AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C665B0: 40990198  ble cr6, 0x82c66748
	if !ctx.cr[6].gt {
	pc = 0x82C66748; continue 'dispatch;
	}
	// 82C665B4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C665B8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C665BC: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C665C0: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82C665C4: 3B3F0058  addi r25, r31, 0x58
	ctx.r[25].s64 = ctx.r[31].s64 + 88;
	// 82C665C8: CB0B0CB0  lfd f24, 0xcb0(r11)
	ctx.f[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(3248 as u32) ) };
	// 82C665CC: 3B1F0008  addi r24, r31, 8
	ctx.r[24].s64 = ctx.r[31].s64 + 8;
	// 82C665D0: CB2A0D38  lfd f25, 0xd38(r10)
	ctx.f[25].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3384 as u32) ) };
	// 82C665D4: 7EA52050  subf r21, r5, r4
	ctx.r[21].s64 = ctx.r[4].s64 - ctx.r[5].s64;
	// 82C665D8: CB89DDB8  lfd f28, -0x2248(r9)
	ctx.f[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(-8776 as u32) ) };
	pc = 0x82C665DC; continue 'dispatch;
            }
            0x82C665DC => {
    //   block [0x82C665DC..0x82C66608)
	// 82C665DC: 7D55D02E  lwzx r10, r21, r26
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82C665E0: C8390000  lfd f1, 0(r25)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	// 82C665E4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C665E8: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 82C665EC: 82D80000  lwz r22, 0(r24)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C665F0: 409900F0  ble cr6, 0x82c666e0
	if !ctx.cr[6].gt {
	pc = 0x82C666E0; continue 'dispatch;
	}
	// 82C665F4: 3BBF003C  addi r29, r31, 0x3c
	ctx.r[29].s64 = ctx.r[31].s64 + 60;
	// 82C665F8: FF5BE824  fdiv f26, f27, f29
	ctx.f[26].f64 = ctx.f[27].f64 / ctx.f[29].f64;
	// 82C665FC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82C66600: 7F6B5050  subf r27, r11, r10
	ctx.r[27].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C66604: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	pc = 0x82C66608; continue 'dispatch;
            }
            0x82C66608 => {
    //   block [0x82C66608..0x82C66660)
	// 82C66608: 7C1BF42E  lfsx f0, r27, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C6660C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C66610: FFC00828  fsub f30, f0, f1
	ctx.f[30].f64 = ctx.f[0].f64 - ctx.f[1].f64;
	// 82C66614: 480025AD  bl 0x82c68bc0
	ctx.lr = 0x82C66618;
	sub_82C68BC0(ctx, base);
	// 82C66618: 786B0020  clrldi r11, r3, 0x20
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 82C6661C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C66620: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82C66624: C9A10050  lfd f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C66628: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82C6662C: FFEC0732  fmul f31, f12, f28
	ctx.f[31].f64 = ctx.f[12].f64 * ctx.f[28].f64;
	// 82C66630: 48002591  bl 0x82c68bc0
	ctx.lr = 0x82C66634;
	sub_82C68BC0(ctx, base);
	// 82C66634: 786A0020  clrldi r10, r3, 0x20
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 82C66638: 813F0038  lwz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82C6663C: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82C66640: C9610058  lfd f11, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82C66644: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82C66648: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C6664C: FD2AFF3A  fmadd f9, f10, f28, f31
	ctx.f[9].f64 = ctx.f[10].f64 * ctx.f[28].f64 + ctx.f[31].f64;
	// 82C66650: FD09D828  fsub f8, f9, f27
	ctx.f[8].f64 = ctx.f[9].f64 - ctx.f[27].f64;
	// 82C66654: FC080772  fmul f0, f8, f29
	ctx.f[0].f64 = ctx.f[8].f64 * ctx.f[29].f64;
	// 82C66658: 419A0008  beq cr6, 0x82c66660
	if ctx.cr[6].eq {
	pc = 0x82C66660; continue 'dispatch;
	}
	// 82C6665C: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	pc = 0x82C66660; continue 'dispatch;
            }
            0x82C66660 => {
    //   block [0x82C66660..0x82C6669C)
	// 82C66660: FC00F02A  fadd f0, f0, f30
	ctx.f[0].f64 = ctx.f[0].f64 + ctx.f[30].f64;
	// 82C66664: FC2006B2  fmul f1, f0, f26
	ctx.f[1].f64 = ctx.f[0].f64 * ctx.f[26].f64;
	// 82C66668: 4BFFFEB9  bl 0x82c66520
	ctx.lr = 0x82C6666C;
	sub_82C66520(ctx, base);
	// 82C6666C: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82C66670: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 82C66674: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82C66678: C9A10060  lfd f13, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82C6667C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82C66680: FFEC0772  fmul f31, f12, f29
	ctx.f[31].f64 = ctx.f[12].f64 * ctx.f[29].f64;
	// 82C66684: 419A0018  beq cr6, 0x82c6669c
	if ctx.cr[6].eq {
	pc = 0x82C6669C; continue 'dispatch;
	}
	// 82C66688: FC1FF028  fsub f0, f31, f30
	ctx.f[0].f64 = ctx.f[31].f64 - ctx.f[30].f64;
	// 82C6668C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82C66690: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82C66694: 48002295  bl 0x82c68928
	ctx.lr = 0x82C66698;
	sub_82C68928(ctx, base);
	// 82C66698: 48000008  b 0x82c666a0
	pc = 0x82C666A0; continue 'dispatch;
            }
            0x82C6669C => {
    //   block [0x82C6669C..0x82C666A0)
	// 82C6669C: FC20C890  fmr f1, f25
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[25].f64;
	pc = 0x82C666A0; continue 'dispatch;
            }
            0x82C666A0 => {
    //   block [0x82C666A0..0x82C666B0)
	// 82C666A0: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82C666A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C666A8: 419A0008  beq cr6, 0x82c666b0
	if ctx.cr[6].eq {
	pc = 0x82C666B0; continue 'dispatch;
	}
	// 82C666AC: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	pc = 0x82C666B0; continue 'dispatch;
            }
            0x82C666B0 => {
    //   block [0x82C666B0..0x82C666C0)
	// 82C666B0: FF1FB800  fcmpu cr6, f31, f23
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[23].f64);
	// 82C666B4: 4099000C  ble cr6, 0x82c666c0
	if !ctx.cr[6].gt {
	pc = 0x82C666C0; continue 'dispatch;
	}
	// 82C666B8: FFE0B890  fmr f31, f23
	ctx.f[31].f64 = ctx.f[23].f64;
	// 82C666BC: 48000010  b 0x82c666cc
	pc = 0x82C666CC; continue 'dispatch;
            }
            0x82C666C0 => {
    //   block [0x82C666C0..0x82C666CC)
	// 82C666C0: FF1FC000  fcmpu cr6, f31, f24
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[24].f64);
	// 82C666C4: 40980008  bge cr6, 0x82c666cc
	if !ctx.cr[6].lt {
	pc = 0x82C666CC; continue 'dispatch;
	}
	// 82C666C8: FFE0C090  fmr f31, f24
	ctx.f[31].f64 = ctx.f[24].f64;
	pc = 0x82C666CC; continue 'dispatch;
            }
            0x82C666CC => {
    //   block [0x82C666CC..0x82C666E0)
	// 82C666CC: FC00F818  frsp f0, f31
	ctx.f[0].f64 = (ctx.f[31].f64 as f32) as f64;
	// 82C666D0: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C666D4: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82C666D8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C666DC: 4082FF2C  bne 0x82c66608
	if !ctx.cr[0].eq {
	pc = 0x82C66608; continue 'dispatch;
	}
	pc = 0x82C666E0; continue 'dispatch;
            }
            0x82C666E0 => {
    //   block [0x82C666E0..0x82C66710)
	// 82C666E0: 3A940001  addi r20, r20, 1
	ctx.r[20].s64 = ctx.r[20].s64 + 1;
	// 82C666E4: D8390000  stfd f1, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.f[1].u64 ) };
	// 82C666E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C666EC: 3B390008  addi r25, r25, 8
	ctx.r[25].s64 = ctx.r[25].s64 + 8;
	// 82C666F0: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 82C666F4: 3B180004  addi r24, r24, 4
	ctx.r[24].s64 = ctx.r[24].s64 + 4;
	// 82C666F8: 7F145800  cmpw cr6, r20, r11
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C666FC: 4198FEE0  blt cr6, 0x82c665dc
	if ctx.cr[6].lt {
	pc = 0x82C665DC; continue 'dispatch;
	}
	// 82C66700: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82C66704: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 82C66708: 48047609  bl 0x82cadd10
	ctx.lr = 0x82C6670C;
	sub_82CADCEC(ctx, base);
	// 82C6670C: 48042D2C  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C66710 => {
    //   block [0x82C66710..0x82C66724)
	// 82C66710: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C66714: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C66718: 40990030  ble cr6, 0x82c66748
	if !ctx.cr[6].gt {
	pc = 0x82C66748; continue 'dispatch;
	}
	// 82C6671C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C66720: 7F852050  subf r28, r5, r4
	ctx.r[28].s64 = ctx.r[4].s64 - ctx.r[5].s64;
	pc = 0x82C66724; continue 'dispatch;
            }
            0x82C66724 => {
    //   block [0x82C66724..0x82C66748)
	// 82C66724: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 82C66728: 7C9EE02E  lwzx r4, r30, r28
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82C6672C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66730: 48000291  bl 0x82c669c0
	ctx.lr = 0x82C66734;
	sub_82C669C0(ctx, base);
	// 82C66734: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66738: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C6673C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C66740: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C66744: 4198FFE0  blt cr6, 0x82c66724
	if ctx.cr[6].lt {
	pc = 0x82C66724; continue 'dispatch;
	}
	pc = 0x82C66748; continue 'dispatch;
            }
            0x82C66748 => {
    //   block [0x82C66748..0x82C66758)
	// 82C66748: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82C6674C: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 82C66750: 480475C1  bl 0x82cadd10
	ctx.lr = 0x82C66754;
	sub_82CADCEC(ctx, base);
	// 82C66754: 48042CE4  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C66758 size=132
    let mut pc: u32 = 0x82C66758;
    'dispatch: loop {
        match pc {
            0x82C66758 => {
    //   block [0x82C66758..0x82C667AC)
	// 82C66758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6675C: 48042CB1  bl 0x82ca940c
	ctx.lr = 0x82C66760;
	sub_82CA93D0(ctx, base);
	// 82C66760: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82C66764: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C66768: 38800098  li r4, 0x98
	ctx.r[4].s64 = 152;
	// 82C6676C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C66770: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C66774: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C66778: 4BFFD7C1  bl 0x82c63f38
	ctx.lr = 0x82C6677C;
	sub_82C63F38(ctx, base);
	// 82C6677C: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 82C66780: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82C66784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C66788: 4BFFFB71  bl 0x82c662f8
	ctx.lr = 0x82C6678C;
	sub_82C662F8(ctx, base);
	// 82C6678C: D3FF0028  stfs f31, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82C66790: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 82C66794: 4800244D  bl 0x82c68be0
	ctx.lr = 0x82C66798;
	sub_82C68BE0(ctx, base);
	// 82C66798: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6679C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C667A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C667A4: 4099002C  ble cr6, 0x82c667d0
	if !ctx.cr[6].gt {
	pc = 0x82C667D0; continue 'dispatch;
	}
	// 82C667A8: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	pc = 0x82C667AC; continue 'dispatch;
            }
            0x82C667AC => {
    //   block [0x82C667AC..0x82C667D0)
	// 82C667AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C667B0: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 82C667B4: 4800235D  bl 0x82c68b10
	ctx.lr = 0x82C667B8;
	sub_82C68B10(ctx, base);
	// 82C667B8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C667BC: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C667C0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C667C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C667C8: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C667CC: 4198FFE0  blt cr6, 0x82c667ac
	if ctx.cr[6].lt {
	pc = 0x82C667AC; continue 'dispatch;
	}
	pc = 0x82C667D0; continue 'dispatch;
            }
            0x82C667D0 => {
    //   block [0x82C667D0..0x82C667DC)
	// 82C667D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C667D4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82C667D8: 48042C84  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C667E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C667E0 size=88
    let mut pc: u32 = 0x82C667E0;
    'dispatch: loop {
        match pc {
            0x82C667E0 => {
    //   block [0x82C667E0..0x82C66838)
	// 82C667E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C667E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C667E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C667EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C667F0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82C667F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C667F8: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 82C667FC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C66800: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C66804: 4BFFD765  bl 0x82c63f68
	ctx.lr = 0x82C66808;
	sub_82C63F68(ctx, base);
	// 82C66808: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C6680C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C66810: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C66814: 4BFFFF45  bl 0x82c66758
	ctx.lr = 0x82C66818;
	sub_82C66758(ctx, base);
	// 82C66818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6681C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C66820: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C66824: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C66828: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82C6682C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C66830: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C66834: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C66838 size=4
    let mut pc: u32 = 0x82C66838;
    'dispatch: loop {
        match pc {
            0x82C66838 => {
    //   block [0x82C66838..0x82C6683C)
	// 82C66838: 4BFFD740  b 0x82c63f78
	sub_82C63F78(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C66840 size=156
    let mut pc: u32 = 0x82C66840;
    'dispatch: loop {
        match pc {
            0x82C66840 => {
    //   block [0x82C66840..0x82C66868)
	// 82C66840: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C66844: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82C66848: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C6684C: 40990080  ble cr6, 0x82c668cc
	if !ctx.cr[6].gt {
	pc = 0x82C668CC; continue 'dispatch;
	}
	// 82C66850: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82C66854: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C66858: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82C6685C: 7CE32050  subf r7, r3, r4
	ctx.r[7].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 82C66860: C96B13F8  lfd f11, 0x13f8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(5112 as u32) ) };
	// 82C66864: C18A0C18  lfs f12, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82C66868; continue 'dispatch;
            }
            0x82C66868 => {
    //   block [0x82C66868..0x82C6687C)
	// 82C66868: 7D67482E  lwzx r11, r7, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82C6686C: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C66870: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 82C66874: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82C66878: 4099003C  ble cr6, 0x82c668b4
	if !ctx.cr[6].gt {
	pc = 0x82C668B4; continue 'dispatch;
	}
	pc = 0x82C6687C; continue 'dispatch;
            }
            0x82C6687C => {
    //   block [0x82C6687C..0x82C66890)
	// 82C6687C: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C66880: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82C66884: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82C66888: 40980008  bge cr6, 0x82c66890
	if !ctx.cr[6].lt {
	pc = 0x82C66890; continue 'dispatch;
	}
	// 82C6688C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82C66890; continue 'dispatch;
            }
            0x82C66890 => {
    //   block [0x82C66890..0x82C6689C)
	// 82C66890: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C66894: 40990008  ble cr6, 0x82c6689c
	if !ctx.cr[6].gt {
	pc = 0x82C6689C; continue 'dispatch;
	}
	// 82C66898: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82C6689C; continue 'dispatch;
            }
            0x82C6689C => {
    //   block [0x82C6689C..0x82C668A8)
	// 82C6689C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82C668A0: 40980008  bge cr6, 0x82c668a8
	if !ctx.cr[6].lt {
	pc = 0x82C668A8; continue 'dispatch;
	}
	// 82C668A4: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82C668A8; continue 'dispatch;
            }
            0x82C668A8 => {
    //   block [0x82C668A8..0x82C668B4)
	// 82C668A8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C668AC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C668B0: 4199FFCC  bgt cr6, 0x82c6687c
	if ctx.cr[6].gt {
	pc = 0x82C6687C; continue 'dispatch;
	}
	pc = 0x82C668B4; continue 'dispatch;
            }
            0x82C668B4 => {
    //   block [0x82C668B4..0x82C668CC)
	// 82C668B4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82C668B8: D1A90000  stfs f13, 0(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C668BC: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C668C0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82C668C4: 7F085800  cmpw cr6, r8, r11
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C668C8: 4198FFA0  blt cr6, 0x82c66868
	if ctx.cr[6].lt {
	pc = 0x82C66868; continue 'dispatch;
	}
	pc = 0x82C668CC; continue 'dispatch;
            }
            0x82C668CC => {
    //   block [0x82C668CC..0x82C668DC)
	// 82C668CC: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C668D0: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82C668D4: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82C668D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C668E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C668E0 size=56
    let mut pc: u32 = 0x82C668E0;
    'dispatch: loop {
        match pc {
            0x82C668E0 => {
    //   block [0x82C668E0..0x82C668FC)
	// 82C668E0: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C668E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C668E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C668EC: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 82C668F0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C668F4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C668F8: C0090C18  lfs f0, 0xc18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82C668FC; continue 'dispatch;
            }
            0x82C668FC => {
    //   block [0x82C668FC..0x82C66918)
	// 82C668FC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C66900: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C66904: 81230024  lwz r9, 0x24(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C66908: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C6690C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82C66910: 4198FFEC  blt cr6, 0x82c668fc
	if ctx.cr[6].lt {
	pc = 0x82C668FC; continue 'dispatch;
	}
	// 82C66914: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C66918 size=92
    let mut pc: u32 = 0x82C66918;
    'dispatch: loop {
        match pc {
            0x82C66918 => {
    //   block [0x82C66918..0x82C66948)
	// 82C66918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6691C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C66920: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C66924: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C66928: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6692C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C66930: 38800028  li r4, 0x28
	ctx.r[4].s64 = 40;
	// 82C66934: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C66938: 4BFFD601  bl 0x82c63f38
	ctx.lr = 0x82C6693C;
	sub_82C63F38(ctx, base);
	// 82C6693C: 2F1E0008  cmpwi cr6, r30, 8
	ctx.cr[6].compare_i32(ctx.r[30].s32, 8, &mut ctx.xer);
	// 82C66940: 40990008  ble cr6, 0x82c66948
	if !ctx.cr[6].gt {
	pc = 0x82C66948; continue 'dispatch;
	}
	// 82C66944: 3BC00008  li r30, 8
	ctx.r[30].s64 = 8;
	pc = 0x82C66948; continue 'dispatch;
            }
            0x82C66948 => {
    //   block [0x82C66948..0x82C66974)
	// 82C66948: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6694C: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82C66950: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C66954: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82C66958: 4BFFFF89  bl 0x82c668e0
	ctx.lr = 0x82C6695C;
	sub_82C668E0(ctx, base);
	// 82C6695C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C66960: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C66964: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C66968: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6696C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C66970: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C66978 size=72
    let mut pc: u32 = 0x82C66978;
    'dispatch: loop {
        match pc {
            0x82C66978 => {
    //   block [0x82C66978..0x82C669C0)
	// 82C66978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6697C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C66980: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C66984: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C66988: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6698C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C66990: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82C66994: 4BFFD5D5  bl 0x82c63f68
	ctx.lr = 0x82C66998;
	sub_82C63F68(ctx, base);
	// 82C66998: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C6699C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C669A0: 4BFFFF79  bl 0x82c66918
	ctx.lr = 0x82C669A4;
	sub_82C66918(ctx, base);
	// 82C669A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C669A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C669AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C669B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C669B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C669B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C669BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C669C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C669C0 size=56
    let mut pc: u32 = 0x82C669C0;
    'dispatch: loop {
        match pc {
            0x82C669C0 => {
    //   block [0x82C669C0..0x82C669DC)
	// 82C669C0: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82C669C4: 40990034  ble cr6, 0x82c669f8
	if !ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x82C669F8);
		return;
	}
	// 82C669C8: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C669CC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82C669D0: 7D4B1A14  add r10, r11, r3
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82C669D4: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82C669D8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x82C669DC; continue 'dispatch;
            }
            0x82C669DC => {
    //   block [0x82C669DC..0x82C669F8)
	// 82C669DC: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 82C669E0: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 82C669E4: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82C669E8: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C669EC: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C669F0: 4082FFEC  bne 0x82c669dc
	if !ctx.cr[0].eq {
	pc = 0x82C669DC; continue 'dispatch;
	}
	// 82C669F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C66A20 size=176
    let mut pc: u32 = 0x82C66A20;
    'dispatch: loop {
        match pc {
            0x82C66A20 => {
    //   block [0x82C66A20..0x82C66A48)
	// 82C66A20: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82C66A24: 2F050004  cmpwi cr6, r5, 4
	ctx.cr[6].compare_i32(ctx.r[5].s32, 4, &mut ctx.xer);
	// 82C66A28: 41980070  blt cr6, 0x82c66a98
	if ctx.cr[6].lt {
	pc = 0x82C66A98; continue 'dispatch;
	}
	// 82C66A2C: 3965FFFC  addi r11, r5, -4
	ctx.r[11].s64 = ctx.r[5].s64 + -4;
	// 82C66A30: 3944000C  addi r10, r4, 0xc
	ctx.r[10].s64 = ctx.r[4].s64 + 12;
	// 82C66A34: 5569F0BE  srwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C66A38: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 82C66A3C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82C66A40: 7CE32050  subf r7, r3, r4
	ctx.r[7].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 82C66A44: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	pc = 0x82C66A48; continue 'dispatch;
            }
            0x82C66A48 => {
    //   block [0x82C66A48..0x82C66A98)
	// 82C66A48: C00AFFF4  lfs f0, -0xc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C66A4C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C66A50: C1ABFFFC  lfs f13, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C66A54: ED80682A  fadds f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82C66A58: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C66A5C: D18BFFFC  stfs f12, -4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82C66A60: 7D475C2E  lfsx f10, r7, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C66A64: ED2A582A  fadds f9, f10, f11
	ctx.f[9].f64 = ((ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64;
	// 82C66A68: C10B0004  lfs f8, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82C66A6C: D12B0000  stfs f9, 0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C66A70: C0EAFFFC  lfs f7, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C66A74: ECC7402A  fadds f6, f7, f8
	ctx.f[6].f64 = ((ctx.f[7].f64 + ctx.f[8].f64) as f32) as f64;
	// 82C66A78: C0AB0008  lfs f5, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C66A7C: D0CB0004  stfs f6, 4(r11)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C66A80: C08A0000  lfs f4, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82C66A84: EC65202A  fadds f3, f5, f4
	ctx.f[3].f64 = ((ctx.f[5].f64 + ctx.f[4].f64) as f32) as f64;
	// 82C66A88: D06B0008  stfs f3, 8(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C66A8C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82C66A90: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82C66A94: 4082FFB4  bne 0x82c66a48
	if !ctx.cr[0].eq {
	pc = 0x82C66A48; continue 'dispatch;
	}
	pc = 0x82C66A98; continue 'dispatch;
            }
            0x82C66A98 => {
    //   block [0x82C66A98..0x82C66AB0)
	// 82C66A98: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C66A9C: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82C66AA0: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C66AA4: 7D232050  subf r9, r3, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 82C66AA8: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82C66AAC: 7D482850  subf r10, r8, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[8].s64;
	pc = 0x82C66AB0; continue 'dispatch;
            }
            0x82C66AB0 => {
    //   block [0x82C66AB0..0x82C66AD0)
	// 82C66AB0: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C66AB4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C66AB8: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C66ABC: ED80682A  fadds f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82C66AC0: D18B0000  stfs f12, 0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C66AC4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C66AC8: 4082FFE8  bne 0x82c66ab0
	if !ctx.cr[0].eq {
	pc = 0x82C66AB0; continue 'dispatch;
	}
	// 82C66ACC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C66AD0 size=244
    let mut pc: u32 = 0x82C66AD0;
    'dispatch: loop {
        match pc {
            0x82C66AD0 => {
    //   block [0x82C66AD0..0x82C66AE8)
	// 82C66AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C66AD4: 48042935  bl 0x82ca9408
	ctx.lr = 0x82C66AD8;
	sub_82CA93D0(ctx, base);
	// 82C66AD8: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82C66ADC: 409900E4  ble cr6, 0x82c66bc0
	if !ctx.cr[6].gt {
	pc = 0x82C66BC0; continue 'dispatch;
	}
	// 82C66AE0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82C66AE4: 7FA41850  subf r29, r4, r3
	ctx.r[29].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	pc = 0x82C66AE8; continue 'dispatch;
            }
            0x82C66AE8 => {
    //   block [0x82C66AE8..0x82C66B20)
	// 82C66AE8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C66AEC: 2F060004  cmpwi cr6, r6, 4
	ctx.cr[6].compare_i32(ctx.r[6].s32, 4, &mut ctx.xer);
	// 82C66AF0: 41980084  blt cr6, 0x82c66b74
	if ctx.cr[6].lt {
	pc = 0x82C66B74; continue 'dispatch;
	}
	// 82C66AF4: 3946FFFC  addi r10, r6, -4
	ctx.r[10].s64 = ctx.r[6].s64 + -4;
	// 82C66AF8: 80E40000  lwz r7, 0(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66AFC: 7D1D202E  lwzx r8, r29, r4
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82C66B00: 39650004  addi r11, r5, 4
	ctx.r[11].s64 = ctx.r[5].s64 + 4;
	// 82C66B04: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C66B08: 7FE53850  subf r31, r5, r7
	ctx.r[31].s64 = ctx.r[7].s64 - ctx.r[5].s64;
	// 82C66B0C: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 82C66B10: 39470008  addi r10, r7, 8
	ctx.r[10].s64 = ctx.r[7].s64 + 8;
	// 82C66B14: 7C654050  subf r3, r5, r8
	ctx.r[3].s64 = ctx.r[8].s64 - ctx.r[5].s64;
	// 82C66B18: 7CE74050  subf r7, r7, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82C66B1C: 553E103A  slwi r30, r9, 2
	ctx.r[30].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	pc = 0x82C66B20; continue 'dispatch;
            }
            0x82C66B20 => {
    //   block [0x82C66B20..0x82C66B74)
	// 82C66B20: C00BFFFC  lfs f0, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C66B24: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C66B28: C1A80000  lfs f13, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C66B2C: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C66B30: D18AFFF8  stfs f12, -8(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82C66B34: 7D635C2E  lfsx f11, r3, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C66B38: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C66B3C: ED2B02B2  fmuls f9, f11, f10
	ctx.f[9].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82C66B40: 7D3F5D2E  stfsx f9, r31, r11
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82C66B44: 7D07542E  lfsx f8, r7, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82C66B48: C0EB0004  lfs f7, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C66B4C: ECC801F2  fmuls f6, f8, f7
	ctx.f[6].f64 = (((ctx.f[8].f64 * ctx.f[7].f64) as f32) as f64);
	// 82C66B50: D0CA0000  stfs f6, 0(r10)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C66B54: C0AB0008  lfs f5, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C66B58: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82C66B5C: C088000C  lfs f4, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82C66B60: EC650132  fmuls f3, f5, f4
	ctx.f[3].f64 = (((ctx.f[5].f64 * ctx.f[4].f64) as f32) as f64);
	// 82C66B64: D06A0004  stfs f3, 4(r10)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C66B68: 39080010  addi r8, r8, 0x10
	ctx.r[8].s64 = ctx.r[8].s64 + 16;
	// 82C66B6C: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82C66B70: 4082FFB0  bne 0x82c66b20
	if !ctx.cr[0].eq {
	pc = 0x82C66B20; continue 'dispatch;
	}
	pc = 0x82C66B74; continue 'dispatch;
            }
            0x82C66B74 => {
    //   block [0x82C66B74..0x82C66B98)
	// 82C66B74: 7F1E3040  cmplw cr6, r30, r6
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82C66B78: 4098003C  bge cr6, 0x82c66bb4
	if !ctx.cr[6].lt {
	pc = 0x82C66BB4; continue 'dispatch;
	}
	// 82C66B7C: 7D3D202E  lwzx r9, r29, r4
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82C66B80: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C66B84: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66B88: 7D5E3050  subf r10, r30, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[30].s64;
	// 82C66B8C: 7D254850  subf r9, r5, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[5].s64;
	// 82C66B90: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82C66B94: 7D054050  subf r8, r5, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[5].s64;
	pc = 0x82C66B98; continue 'dispatch;
            }
            0x82C66B98 => {
    //   block [0x82C66B98..0x82C66BB4)
	// 82C66B98: 7C095C2E  lfsx f0, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C66B9C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C66BA0: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C66BA4: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C66BA8: 7D885D2E  stfsx f12, r8, r11
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82C66BAC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C66BB0: 4082FFE8  bne 0x82c66b98
	if !ctx.cr[0].eq {
	pc = 0x82C66B98; continue 'dispatch;
	}
	pc = 0x82C66BB4; continue 'dispatch;
            }
            0x82C66BB4 => {
    //   block [0x82C66BB4..0x82C66BC0)
	// 82C66BB4: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82C66BB8: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82C66BBC: 4082FF2C  bne 0x82c66ae8
	if !ctx.cr[0].eq {
	pc = 0x82C66AE8; continue 'dispatch;
	}
	pc = 0x82C66BC0; continue 'dispatch;
            }
            0x82C66BC0 => {
    //   block [0x82C66BC0..0x82C66BC4)
	// 82C66BC0: 48042898  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C66BC8 size=44
    let mut pc: u32 = 0x82C66BC8;
    'dispatch: loop {
        match pc {
            0x82C66BC8 => {
    //   block [0x82C66BC8..0x82C66BF4)
	// 82C66BC8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C66BCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C66BD0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C66BD4: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C66BD8: C0230000  lfs f1, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C66BDC: 554907BC  rlwinm r9, r10, 0, 0x1e, 0x1e
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82C66BE0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C66BE4: 419A0010  beq cr6, 0x82c66bf4
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C66BF4);
		return;
	}
	// 82C66BE8: 80A3001C  lwz r5, 0x1c(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C66BEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82C66BF0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C66C08 size=76
    let mut pc: u32 = 0x82C66C08;
    'dispatch: loop {
        match pc {
            0x82C66C08 => {
    //   block [0x82C66C08..0x82C66C20)
	// 82C66C08: C003000C  lfs f0, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C66C0C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C66C10: 41980010  blt cr6, 0x82c66c20
	if ctx.cr[6].lt {
	pc = 0x82C66C20; continue 'dispatch;
	}
	// 82C66C14: C0030010  lfs f0, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C66C18: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C66C1C: 40990008  ble cr6, 0x82c66c24
	if !ctx.cr[6].gt {
	pc = 0x82C66C24; continue 'dispatch;
	}
	pc = 0x82C66C20; continue 'dispatch;
            }
            0x82C66C20 => {
    //   block [0x82C66C20..0x82C66C24)
	// 82C66C20: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	pc = 0x82C66C24; continue 'dispatch;
            }
            0x82C66C24 => {
    //   block [0x82C66C24..0x82C66C4C)
	// 82C66C24: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C66C28: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 82C66C2C: 409A0020  bne cr6, 0x82c66c4c
	if !ctx.cr[6].eq {
	pc = 0x82C66C4C; continue 'dispatch;
	}
	// 82C66C30: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C66C34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C66C38: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C66C3C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C66C40: 556A0738  rlwinm r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82C66C44: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C66C48: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x82C66C4C; continue 'dispatch;
            }
            0x82C66C4C => {
    //   block [0x82C66C4C..0x82C66C54)
	// 82C66C4C: D0230000  stfs f1, 0(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C66C50: 4BFFFF78  b 0x82c66bc8
	sub_82C66BC8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C66C68 size=88
    let mut pc: u32 = 0x82C66C68;
    'dispatch: loop {
        match pc {
            0x82C66C68 => {
    //   block [0x82C66C68..0x82C66C8C)
	// 82C66C68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C66C6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C66C70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C66C74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C66C78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C66C7C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C66C80: 409A000C  bne cr6, 0x82c66c8c
	if !ctx.cr[6].eq {
	pc = 0x82C66C8C; continue 'dispatch;
	}
	// 82C66C84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C66C88: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	pc = 0x82C66C8C; continue 'dispatch;
            }
            0x82C66C8C => {
    //   block [0x82C66C8C..0x82C66CC0)
	// 82C66C8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C66C90: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82C66C94: 90BF0004  stw r5, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82C66C98: 54A3103A  slwi r3, r5, 2
	ctx.r[3].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C66C9C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C66CA0: 4BFF92C9  bl 0x82c5ff68
	ctx.lr = 0x82C66CA4;
	sub_82C5FF68(ctx, base);
	// 82C66CA4: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82C66CA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C66CAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C66CB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C66CB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C66CB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C66CBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C66CC0 size=8
    let mut pc: u32 = 0x82C66CC0;
    'dispatch: loop {
        match pc {
            0x82C66CC0 => {
    //   block [0x82C66CC0..0x82C66CC8)
	// 82C66CC0: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C66CC4: 4BFF9394  b 0x82c60058
	sub_82C60058(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C66CC8 size=32
    let mut pc: u32 = 0x82C66CC8;
    'dispatch: loop {
        match pc {
            0x82C66CC8 => {
    //   block [0x82C66CC8..0x82C66CE8)
	// 82C66CC8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C66CCC: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C66CD0: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C66CD4: 7C8A492E  stwx r4, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[4].u32) };
	// 82C66CD8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C66CDC: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82C66CE0: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82C66CE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C66CE8 size=32
    let mut pc: u32 = 0x82C66CE8;
    'dispatch: loop {
        match pc {
            0x82C66CE8 => {
    //   block [0x82C66CE8..0x82C66CF8)
	// 82C66CE8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C66CEC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C66CF0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82C66CF4: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82C66CF8; continue 'dispatch;
            }
            0x82C66CF8 => {
    //   block [0x82C66CF8..0x82C66D08)
	// 82C66CF8: 5463083C  slwi r3, r3, 1
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C66CFC: 7F0B1800  cmpw cr6, r11, r3
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[3].s32, &mut ctx.xer);
	// 82C66D00: 4199FFF8  bgt cr6, 0x82c66cf8
	if ctx.cr[6].gt {
	pc = 0x82C66CF8; continue 'dispatch;
	}
	// 82C66D04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C66D08 size=36
    let mut pc: u32 = 0x82C66D08;
    'dispatch: loop {
        match pc {
            0x82C66D08 => {
    //   block [0x82C66D08..0x82C66D18)
	// 82C66D08: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C66D0C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C66D10: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82C66D14: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82C66D18; continue 'dispatch;
            }
            0x82C66D18 => {
    //   block [0x82C66D18..0x82C66D2C)
	// 82C66D18: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82C66D1C: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 82C66D20: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82C66D24: 4199FFF4  bgt cr6, 0x82c66d18
	if ctx.cr[6].gt {
	pc = 0x82C66D18; continue 'dispatch;
	}
	// 82C66D28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C66D30 size=8
    let mut pc: u32 = 0x82C66D30;
    'dispatch: loop {
        match pc {
            0x82C66D30 => {
    //   block [0x82C66D30..0x82C66D38)
	// 82C66D30: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66D34: 4BFF9324  b 0x82c60058
	sub_82C60058(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C66D38 size=164
    let mut pc: u32 = 0x82C66D38;
    'dispatch: loop {
        match pc {
            0x82C66D38 => {
    //   block [0x82C66D38..0x82C66D6C)
	// 82C66D38: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C66D3C: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66D40: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C66D44: 7D075E30  sraw r7, r8, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> tmp.u32) as i64;
	// 82C66D48: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66D4C: 7CEB5038  and r11, r7, r10
	ctx.r[11].u64 = ctx.r[7].u64 & ctx.r[10].u64;
	// 82C66D50: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C66D54: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C66D58: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C66D5C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82C66D60: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66D64: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82C66D68: 419A004C  beq cr6, 0x82c66db4
	if ctx.cr[6].eq {
	pc = 0x82C66DB4; continue 'dispatch;
	}
	pc = 0x82C66D6C; continue 'dispatch;
            }
            0x82C66D6C => {
    //   block [0x82C66D6C..0x82C66D8C)
	// 82C66D6C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66D70: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C66D74: 419A0034  beq cr6, 0x82c66da8
	if ctx.cr[6].eq {
	pc = 0x82C66DA8; continue 'dispatch;
	}
	// 82C66D78: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C66D7C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C66D80: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82C66D84: 41980008  blt cr6, 0x82c66d8c
	if ctx.cr[6].lt {
	pc = 0x82C66D8C; continue 'dispatch;
	}
	// 82C66D88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82C66D8C; continue 'dispatch;
            }
            0x82C66D8C => {
    //   block [0x82C66D8C..0x82C66DA8)
	// 82C66D8C: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C66D90: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C66D94: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C66D98: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82C66D9C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66DA0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82C66DA4: 409AFFC8  bne cr6, 0x82c66d6c
	if !ctx.cr[6].eq {
	pc = 0x82C66D6C; continue 'dispatch;
	}
	pc = 0x82C66DA8; continue 'dispatch;
            }
            0x82C66DA8 => {
    //   block [0x82C66DA8..0x82C66DB4)
	// 82C66DA8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66DAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C66DB0: 409A0010  bne cr6, 0x82c66dc0
	if !ctx.cr[6].eq {
	pc = 0x82C66DC0; continue 'dispatch;
	}
	pc = 0x82C66DB4; continue 'dispatch;
            }
            0x82C66DB4 => {
    //   block [0x82C66DB4..0x82C66DC0)
	// 82C66DB4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C66DB8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C66DBC: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82C66DC0; continue 'dispatch;
            }
            0x82C66DC0 => {
    //   block [0x82C66DC0..0x82C66DDC)
	// 82C66DC0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66DC4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C66DC8: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C66DCC: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C66DD0: 81040008  lwz r8, 8(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C66DD4: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82C66DD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C66DE0 size=60
    let mut pc: u32 = 0x82C66DE0;
    'dispatch: loop {
        match pc {
            0x82C66DE0 => {
    //   block [0x82C66DE0..0x82C66DF8)
	// 82C66DE0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C66DE4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C66DE8: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82C66DEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C66DF0: 40990024  ble cr6, 0x82c66e14
	if !ctx.cr[6].gt {
	pc = 0x82C66E14; continue 'dispatch;
	}
	// 82C66DF4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82C66DF8; continue 'dispatch;
            }
            0x82C66DF8 => {
    //   block [0x82C66DF8..0x82C66E14)
	// 82C66DF8: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66DFC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C66E00: 7D2B412E  stwx r9, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[9].u32) };
	// 82C66E04: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82C66E08: 80E30008  lwz r7, 8(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C66E0C: 7F0A3800  cmpw cr6, r10, r7
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82C66E10: 4198FFE8  blt cr6, 0x82c66df8
	if ctx.cr[6].lt {
	pc = 0x82C66DF8; continue 'dispatch;
	}
	pc = 0x82C66E14; continue 'dispatch;
            }
            0x82C66E14 => {
    //   block [0x82C66E14..0x82C66E1C)
	// 82C66E14: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C66E18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C66E20 size=120
    let mut pc: u32 = 0x82C66E20;
    'dispatch: loop {
        match pc {
            0x82C66E20 => {
    //   block [0x82C66E20..0x82C66E50)
	// 82C66E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C66E24: 480425DD  bl 0x82ca9400
	ctx.lr = 0x82C66E28;
	sub_82CA93D0(ctx, base);
	// 82C66E28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C66E2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C66E30: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C66E34: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C66E38: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82C66E3C: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82C66E40: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C66E44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C66E48: 40990044  ble cr6, 0x82c66e8c
	if !ctx.cr[6].gt {
	pc = 0x82C66E8C; continue 'dispatch;
	}
	// 82C66E4C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x82C66E50; continue 'dispatch;
            }
            0x82C66E50 => {
    //   block [0x82C66E50..0x82C66E78)
	// 82C66E50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66E54: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82C66E58: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C66E5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C66E60: 419A0018  beq cr6, 0x82c66e78
	if ctx.cr[6].eq {
	pc = 0x82C66E78; continue 'dispatch;
	}
	// 82C66E64: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C66E68: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 82C66E6C: 4E800421  bctrl
	ctx.lr = 0x82C66E70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C66E70: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66E74: 7FBE592E  stwx r29, r30, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), ctx.r[29].u32) };
            }
            0x82C66E78 => {
    //   block [0x82C66E78..0x82C66E8C)
	// 82C66E78: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C66E7C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82C66E80: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82C66E84: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C66E88: 4198FFC8  blt cr6, 0x82c66e50
	if ctx.cr[6].lt {
	pc = 0x82C66E50; continue 'dispatch;
	}
	pc = 0x82C66E8C; continue 'dispatch;
            }
            0x82C66E8C => {
    //   block [0x82C66E8C..0x82C66E98)
	// 82C66E8C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82C66E90: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C66E94: 480425BC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C66E98 size=128
    let mut pc: u32 = 0x82C66E98;
    'dispatch: loop {
        match pc {
            0x82C66E98 => {
    //   block [0x82C66E98..0x82C66EC0)
	// 82C66E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C66E9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C66EA0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C66EA4: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82C66EA8: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82C66EAC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C66EB0: 91670004  stw r11, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C66EB4: 409A000C  bne cr6, 0x82c66ec0
	if !ctx.cr[6].eq {
	pc = 0x82C66EC0; continue 'dispatch;
	}
	// 82C66EB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C66EBC: 38CB0CA0  addi r6, r11, 0xca0
	ctx.r[6].s64 = ctx.r[11].s64 + 3232;
	pc = 0x82C66EC0; continue 'dispatch;
            }
            0x82C66EC0 => {
    //   block [0x82C66EC0..0x82C66EF0)
	// 82C66EC0: D027000C  stfs f1, 0xc(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C66EC4: 90C70008  stw r6, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82C66EC8: D0470010  stfs f2, 0x10(r7)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82C66ECC: 91470018  stw r10, 0x18(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C66ED0: D0670014  stfs f3, 0x14(r7)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82C66ED4: 9087001C  stw r4, 0x1c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 82C66ED8: D0670000  stfs f3, 0(r7)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C66EDC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82C66EE0: 419A0010  beq cr6, 0x82c66ef0
	if ctx.cr[6].eq {
	pc = 0x82C66EF0; continue 'dispatch;
	}
	// 82C66EE4: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82C66EE8: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82C66EEC: 4BFFFDDD  bl 0x82c66cc8
	ctx.lr = 0x82C66EF0;
	sub_82C66CC8(ctx, base);
	pc = 0x82C66EF0; continue 'dispatch;
            }
            0x82C66EF0 => {
    //   block [0x82C66EF0..0x82C66F08)
	// 82C66EF0: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C66EF4: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82C66EF8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C66EFC: 419A000C  beq cr6, 0x82c66f08
	if ctx.cr[6].eq {
	pc = 0x82C66F08; continue 'dispatch;
	}
	// 82C66F00: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82C66F04: 4BFFFCC5  bl 0x82c66bc8
	ctx.lr = 0x82C66F08;
	sub_82C66BC8(ctx, base);
	pc = 0x82C66F08; continue 'dispatch;
            }
            0x82C66F08 => {
    //   block [0x82C66F08..0x82C66F18)
	// 82C66F08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C66F0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C66F10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C66F14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C66F18 size=112
    let mut pc: u32 = 0x82C66F18;
    'dispatch: loop {
        match pc {
            0x82C66F18 => {
    //   block [0x82C66F18..0x82C66F88)
	// 82C66F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C66F1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C66F20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C66F24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C66F28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C66F2C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C66F30: 4BFFFDB9  bl 0x82c66ce8
	ctx.lr = 0x82C66F34;
	sub_82C66CE8(ctx, base);
	// 82C66F34: 546B083C  slwi r11, r3, 1
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C66F38: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C66F3C: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C66F40: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C66F44: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C66F48: 4BFF9021  bl 0x82c5ff68
	ctx.lr = 0x82C66F4C;
	sub_82C5FF68(ctx, base);
	// 82C66F4C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C66F50: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C66F54: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82C66F58: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 82C66F5C: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82C66F60: 4BFFFDA9  bl 0x82c66d08
	ctx.lr = 0x82C66F64;
	sub_82C66D08(ctx, base);
	// 82C66F64: 3923FFFF  addi r9, r3, -1
	ctx.r[9].s64 = ctx.r[3].s64 + -1;
	// 82C66F68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C66F6C: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82C66F70: 4BFFFE71  bl 0x82c66de0
	ctx.lr = 0x82C66F74;
	sub_82C66DE0(ctx, base);
	// 82C66F74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C66F78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C66F7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C66F80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C66F84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C66F88 size=56
    let mut pc: u32 = 0x82C66F88;
    'dispatch: loop {
        match pc {
            0x82C66F88 => {
    //   block [0x82C66F88..0x82C66FC0)
	// 82C66F88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C66F8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C66F90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C66F94: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C66F98: 816100C4  lwz r11, 0xc4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82C66F9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C66FA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C66FA4: 4BFFFEF5  bl 0x82c66e98
	ctx.lr = 0x82C66FA8;
	sub_82C66E98(ctx, base);
	// 82C66FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C66FAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C66FB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C66FB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C66FB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C66FBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C66FC0 size=8
    let mut pc: u32 = 0x82C66FC0;
    'dispatch: loop {
        match pc {
            0x82C66FC0 => {
    //   block [0x82C66FC0..0x82C66FC8)
	// 82C66FC0: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C66FC4: 4BBDE7EC  b 0x828457b0
	sub_828457B0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C66FC8 size=12
    let mut pc: u32 = 0x82C66FC8;
    'dispatch: loop {
        match pc {
            0x82C66FC8 => {
    //   block [0x82C66FC8..0x82C66FD4)
	// 82C66FC8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C66FCC: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C66FD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C66FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C66FD8 size=48
    let mut pc: u32 = 0x82C66FD8;
    'dispatch: loop {
        match pc {
            0x82C66FD8 => {
    //   block [0x82C66FD8..0x82C67008)
	// 82C66FD8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C66FDC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C66FE0: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C66FE4: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C66FE8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82C66FEC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C66FF0: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82C66FF4: 988B0000  stb r4, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u8 ) };
	// 82C66FF8: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C66FFC: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82C67000: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82C67004: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C67008 size=16
    let mut pc: u32 = 0x82C67008;
    'dispatch: loop {
        match pc {
            0x82C67008 => {
    //   block [0x82C67008..0x82C67018)
	// 82C67008: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6700C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C67010: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82C67014: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C67018 size=92
    let mut pc: u32 = 0x82C67018;
    'dispatch: loop {
        match pc {
            0x82C67018 => {
    //   block [0x82C67018..0x82C67050)
	// 82C67018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6701C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C67020: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C67024: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82C67028: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6702C: 806A000C  lwz r3, 0xc(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67030: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67034: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82C67038: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82C6703C: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 82C67040: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82C67044: 7F055800  cmpw cr6, r5, r11
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C67048: 41980008  blt cr6, 0x82c67050
	if ctx.cr[6].lt {
	pc = 0x82C67050; continue 'dispatch;
	}
	// 82C6704C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x82C67050; continue 'dispatch;
            }
            0x82C67050 => {
    //   block [0x82C67050..0x82C67074)
	// 82C67050: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 82C67054: 4BFFE435  bl 0x82c65488
	ctx.lr = 0x82C67058;
	sub_82C65488(ctx, base);
	// 82C67058: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6705C: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82C67060: 916A000C  stw r11, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C67064: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C67068: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6706C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C67070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C67078 size=52
    let mut pc: u32 = 0x82C67078;
    'dispatch: loop {
        match pc {
            0x82C67078 => {
    //   block [0x82C67078..0x82C67088)
	// 82C67078: 89650000  lbz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6707C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82C67080: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C67084: 419A0020  beq cr6, 0x82c670a4
	if ctx.cr[6].eq {
	pc = 0x82C670A4; continue 'dispatch;
	}
	pc = 0x82C67088; continue 'dispatch;
            }
            0x82C67088 => {
    //   block [0x82C67088..0x82C670A4)
	// 82C67088: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82C6708C: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82C67090: 419A001C  beq cr6, 0x82c670ac
	if ctx.cr[6].eq {
		sub_82C670AC(ctx, base);
		return;
	}
	// 82C67094: 89650000  lbz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67098: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82C6709C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C670A0: 409AFFE8  bne cr6, 0x82c67088
	if !ctx.cr[6].eq {
	pc = 0x82C67088; continue 'dispatch;
	}
	pc = 0x82C670A4; continue 'dispatch;
            }
            0x82C670A4 => {
    //   block [0x82C670A4..0x82C670AC)
	// 82C670A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C670A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C670AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C670AC size=8
    let mut pc: u32 = 0x82C670AC;
    'dispatch: loop {
        match pc {
            0x82C670AC => {
    //   block [0x82C670AC..0x82C670B4)
	// 82C670AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C670B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C670B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C670B8 size=12
    let mut pc: u32 = 0x82C670B8;
    'dispatch: loop {
        match pc {
            0x82C670B8 => {
    //   block [0x82C670B8..0x82C670C4)
	// 82C670B8: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82C670BC: 80ABA8A0  lwz r5, -0x5760(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22368 as u32) ) } as u64;
	// 82C670C0: 4BFFFFB8  b 0x82c67078
	sub_82C67078(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C670C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C670C8 size=172
    let mut pc: u32 = 0x82C670C8;
    'dispatch: loop {
        match pc {
            0x82C670C8 => {
    //   block [0x82C670C8..0x82C670EC)
	// 82C670C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C670CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C670D0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C670D4: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 82C670D8: 4BFFFEF1  bl 0x82c66fc8
	ctx.lr = 0x82C670DC;
	sub_82C66FC8(ctx, base);
	// 82C670DC: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C670E0: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C670E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C670E8: 419A0074  beq cr6, 0x82c6715c
	if ctx.cr[6].eq {
	pc = 0x82C6715C; continue 'dispatch;
	}
	pc = 0x82C670EC; continue 'dispatch;
            }
            0x82C670EC => {
    //   block [0x82C670EC..0x82C6710C)
	// 82C670EC: 89650000  lbz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C670F0: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 82C670F4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82C670F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C670FC: 419A002C  beq cr6, 0x82c67128
	if ctx.cr[6].eq {
	pc = 0x82C67128; continue 'dispatch;
	}
	// 82C67100: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67104: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67108: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	pc = 0x82C6710C; continue 'dispatch;
            }
            0x82C6710C => {
    //   block [0x82C6710C..0x82C67128)
	// 82C6710C: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C67110: 419A0018  beq cr6, 0x82c67128
	if ctx.cr[6].eq {
	pc = 0x82C67128; continue 'dispatch;
	}
	// 82C67114: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C67118: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6711C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82C67120: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C67124: 409AFFE8  bne cr6, 0x82c6710c
	if !ctx.cr[6].eq {
	pc = 0x82C6710C; continue 'dispatch;
	}
	pc = 0x82C67128; continue 'dispatch;
            }
            0x82C67128 => {
    //   block [0x82C67128..0x82C6715C)
	// 82C67128: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6712C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C67130: 419A002C  beq cr6, 0x82c6715c
	if ctx.cr[6].eq {
	pc = 0x82C6715C; continue 'dispatch;
	}
	// 82C67134: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67138: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82C6713C: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67140: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C67144: 7D240774  extsb r4, r9
	ctx.r[4].s64 = ctx.r[9].s8 as i64;
	// 82C67148: 4BFFFE91  bl 0x82c66fd8
	ctx.lr = 0x82C6714C;
	sub_82C66FD8(ctx, base);
	// 82C6714C: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67150: 88C70000  lbz r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67154: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C67158: 409AFF94  bne cr6, 0x82c670ec
	if !ctx.cr[6].eq {
	pc = 0x82C670EC; continue 'dispatch;
	}
	pc = 0x82C6715C; continue 'dispatch;
            }
            0x82C6715C => {
    //   block [0x82C6715C..0x82C67174)
	// 82C6715C: 4BFFFEAD  bl 0x82c67008
	ctx.lr = 0x82C67160;
	sub_82C67008(ctx, base);
	// 82C67160: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C67164: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C67168: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6716C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C67170: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C67178 size=132
    let mut pc: u32 = 0x82C67178;
    'dispatch: loop {
        match pc {
            0x82C67178 => {
    //   block [0x82C67178..0x82C671B0)
	// 82C67178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6717C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C67180: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C67184: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82C67188: 4BFFFE41  bl 0x82c66fc8
	ctx.lr = 0x82C6718C;
	sub_82C66FC8(ctx, base);
	// 82C6718C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67190: 89690000  lbz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67194: 7D640774  extsb r4, r11
	ctx.r[4].s64 = ctx.r[11].s8 as i64;
	// 82C67198: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C6719C: 419A0048  beq cr6, 0x82c671e4
	if ctx.cr[6].eq {
	pc = 0x82C671E4; continue 'dispatch;
	}
	// 82C671A0: 89650000  lbz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C671A4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82C671A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C671AC: 419A0020  beq cr6, 0x82c671cc
	if ctx.cr[6].eq {
	pc = 0x82C671CC; continue 'dispatch;
	}
	pc = 0x82C671B0; continue 'dispatch;
            }
            0x82C671B0 => {
    //   block [0x82C671B0..0x82C671CC)
	// 82C671B0: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C671B4: 419A0018  beq cr6, 0x82c671cc
	if ctx.cr[6].eq {
	pc = 0x82C671CC; continue 'dispatch;
	}
	// 82C671B8: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82C671BC: 89650000  lbz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C671C0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82C671C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C671C8: 409AFFE8  bne cr6, 0x82c671b0
	if !ctx.cr[6].eq {
	pc = 0x82C671B0; continue 'dispatch;
	}
	pc = 0x82C671CC; continue 'dispatch;
            }
            0x82C671CC => {
    //   block [0x82C671CC..0x82C671E4)
	// 82C671CC: 89650000  lbz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C671D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C671D4: 419A0010  beq cr6, 0x82c671e4
	if ctx.cr[6].eq {
	pc = 0x82C671E4; continue 'dispatch;
	}
	// 82C671D8: 39690001  addi r11, r9, 1
	ctx.r[11].s64 = ctx.r[9].s64 + 1;
	// 82C671DC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C671E0: 4BFFFDF9  bl 0x82c66fd8
	ctx.lr = 0x82C671E4;
	sub_82C66FD8(ctx, base);
	pc = 0x82C671E4; continue 'dispatch;
            }
            0x82C671E4 => {
    //   block [0x82C671E4..0x82C671FC)
	// 82C671E4: 4BFFFE25  bl 0x82c67008
	ctx.lr = 0x82C671E8;
	sub_82C67008(ctx, base);
	// 82C671E8: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C671EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C671F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C671F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C671F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C67200 size=172
    let mut pc: u32 = 0x82C67200;
    'dispatch: loop {
        match pc {
            0x82C67200 => {
    //   block [0x82C67200..0x82C67224)
	// 82C67200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C67204: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C67208: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6720C: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 82C67210: 4BFFFDB9  bl 0x82c66fc8
	ctx.lr = 0x82C67214;
	sub_82C66FC8(ctx, base);
	// 82C67214: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67218: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6721C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C67220: 419A0074  beq cr6, 0x82c67294
	if ctx.cr[6].eq {
	pc = 0x82C67294; continue 'dispatch;
	}
	pc = 0x82C67224; continue 'dispatch;
            }
            0x82C67224 => {
    //   block [0x82C67224..0x82C67244)
	// 82C67224: 89650000  lbz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67228: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 82C6722C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82C67230: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C67234: 419A002C  beq cr6, 0x82c67260
	if ctx.cr[6].eq {
	pc = 0x82C67260; continue 'dispatch;
	}
	// 82C67238: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6723C: 88E90000  lbz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67240: 7CE90774  extsb r9, r7
	ctx.r[9].s64 = ctx.r[7].s8 as i64;
	pc = 0x82C67244; continue 'dispatch;
            }
            0x82C67244 => {
    //   block [0x82C67244..0x82C67260)
	// 82C67244: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C67248: 419A0018  beq cr6, 0x82c67260
	if ctx.cr[6].eq {
	pc = 0x82C67260; continue 'dispatch;
	}
	// 82C6724C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C67250: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67254: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82C67258: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C6725C: 409AFFE8  bne cr6, 0x82c67244
	if !ctx.cr[6].eq {
	pc = 0x82C67244; continue 'dispatch;
	}
	pc = 0x82C67260; continue 'dispatch;
            }
            0x82C67260 => {
    //   block [0x82C67260..0x82C67294)
	// 82C67260: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67264: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C67268: 409A002C  bne cr6, 0x82c67294
	if !ctx.cr[6].eq {
	pc = 0x82C67294; continue 'dispatch;
	}
	// 82C6726C: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67270: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82C67274: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67278: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C6727C: 7D240774  extsb r4, r9
	ctx.r[4].s64 = ctx.r[9].s8 as i64;
	// 82C67280: 4BFFFD59  bl 0x82c66fd8
	ctx.lr = 0x82C67284;
	sub_82C66FD8(ctx, base);
	// 82C67284: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67288: 88C70000  lbz r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6728C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C67290: 409AFF94  bne cr6, 0x82c67224
	if !ctx.cr[6].eq {
	pc = 0x82C67224; continue 'dispatch;
	}
	pc = 0x82C67294; continue 'dispatch;
            }
            0x82C67294 => {
    //   block [0x82C67294..0x82C672AC)
	// 82C67294: 4BFFFD75  bl 0x82c67008
	ctx.lr = 0x82C67298;
	sub_82C67008(ctx, base);
	// 82C67298: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6729C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C672A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C672A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C672A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C672B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C672B0 size=12
    let mut pc: u32 = 0x82C672B0;
    'dispatch: loop {
        match pc {
            0x82C672B0 => {
    //   block [0x82C672B0..0x82C672BC)
	// 82C672B0: 3D60832F  lis r11, -0x7cd1
	ctx.r[11].s64 = -2094071808;
	// 82C672B4: 80ABA8A0  lwz r5, -0x5760(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-22368 as u32) ) } as u64;
	// 82C672B8: 4BFFFE10  b 0x82c670c8
	sub_82C670C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C672C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C672C0 size=292
    let mut pc: u32 = 0x82C672C0;
    'dispatch: loop {
        match pc {
            0x82C672C0 => {
    //   block [0x82C672C0..0x82C6734C)
	// 82C672C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C672C4: 4804213D  bl 0x82ca9400
	ctx.lr = 0x82C672C8;
	sub_82CA93D0(ctx, base);
	// 82C672C8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C672CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C672D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C672D4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C672D8: 4BFFFFD9  bl 0x82c672b0
	ctx.lr = 0x82C672DC;
	sub_82C672B0(ctx, base);
	// 82C672DC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82C672E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C672E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C672E8: 38AB9350  addi r5, r11, -0x6cb0
	ctx.r[5].s64 = ctx.r[11].s64 + -27824;
	// 82C672EC: 839E0000  lwz r28, 0(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C672F0: 4BFFFDD9  bl 0x82c670c8
	ctx.lr = 0x82C672F4;
	sub_82C670C8(ctx, base);
	// 82C672F4: 3FA0832F  lis r29, -0x7cd1
	ctx.r[29].s64 = -2094071808;
	// 82C672F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C672FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C67300: 80BDA8A4  lwz r5, -0x575c(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-22364 as u32) ) } as u64;
	// 82C67304: 4BFFFDC5  bl 0x82c670c8
	ctx.lr = 0x82C67308;
	sub_82C670C8(ctx, base);
	// 82C67308: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82C6730C: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82C67310: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C67314: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C67318: 38A9230C  addi r5, r9, 0x230c
	ctx.r[5].s64 = ctx.r[9].s64 + 8972;
	// 82C6731C: 8B4A0000  lbz r26, 0(r10)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67320: 4BFFFDA9  bl 0x82c670c8
	ctx.lr = 0x82C67324;
	sub_82C670C8(ctx, base);
	// 82C67324: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C67328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6732C: 80BDA8A4  lwz r5, -0x575c(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-22364 as u32) ) } as u64;
	// 82C67330: 4BFFFD99  bl 0x82c670c8
	ctx.lr = 0x82C67334;
	sub_82C670C8(ctx, base);
	// 82C67334: 88E30000  lbz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67338: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82C6733C: 7CEB0774  extsb r11, r7
	ctx.r[11].s64 = ctx.r[7].s8 as i64;
	// 82C67340: 409A000C  bne cr6, 0x82c6734c
	if !ctx.cr[6].eq {
	pc = 0x82C6734C; continue 'dispatch;
	}
	// 82C67344: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C67348: 419A0054  beq cr6, 0x82c6739c
	if ctx.cr[6].eq {
	pc = 0x82C6739C; continue 'dispatch;
	}
	pc = 0x82C6734C; continue 'dispatch;
            }
            0x82C6734C => {
    //   block [0x82C6734C..0x82C6739C)
	// 82C6734C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C67350: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C67354: 38ABDE30  addi r5, r11, -0x21d0
	ctx.r[5].s64 = ctx.r[11].s64 + -8656;
	// 82C67358: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6735C: 4BFFFE1D  bl 0x82c67178
	ctx.lr = 0x82C67360;
	sub_82C67178(ctx, base);
	// 82C67360: 89430000  lbz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67364: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C67368: 419A0040  beq cr6, 0x82c673a8
	if ctx.cr[6].eq {
	pc = 0x82C673A8; continue 'dispatch;
	}
	// 82C6736C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82C67370: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C67374: 38AB3F58  addi r5, r11, 0x3f58
	ctx.r[5].s64 = ctx.r[11].s64 + 16216;
	// 82C67378: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6737C: 4BFFFDFD  bl 0x82c67178
	ctx.lr = 0x82C67380;
	sub_82C67178(ctx, base);
	// 82C67380: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C67384: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C67388: 80BDA8A4  lwz r5, -0x575c(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-22364 as u32) ) } as u64;
	// 82C6738C: 4BFFFD3D  bl 0x82c670c8
	ctx.lr = 0x82C67390;
	sub_82C670C8(ctx, base);
	// 82C67390: 89430000  lbz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67394: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C67398: 409A0010  bne cr6, 0x82c673a8
	if !ctx.cr[6].eq {
	pc = 0x82C673A8; continue 'dispatch;
	}
	pc = 0x82C6739C; continue 'dispatch;
            }
            0x82C6739C => {
    //   block [0x82C6739C..0x82C673A8)
	// 82C6739C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C673A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C673A4: 480420AC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C673A8 => {
    //   block [0x82C673A8..0x82C673D8)
	// 82C673A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C673AC: 4BFFFC1D  bl 0x82c66fc8
	ctx.lr = 0x82C673B0;
	sub_82C66FC8(ctx, base);
	// 82C673B0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C673B4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C673B8: 7CBC5850  subf r5, r28, r11
	ctx.r[5].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82C673BC: 4BFFFC5D  bl 0x82c67018
	ctx.lr = 0x82C673C0;
	sub_82C67018(ctx, base);
	// 82C673C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C673C4: 4BFFFC45  bl 0x82c67008
	ctx.lr = 0x82C673C8;
	sub_82C67008(ctx, base);
	// 82C673C8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82C673CC: 419A000C  beq cr6, 0x82c673d8
	if ctx.cr[6].eq {
	pc = 0x82C673D8; continue 'dispatch;
	}
	// 82C673D0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C673D4: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82C673D8; continue 'dispatch;
            }
            0x82C673D8 => {
    //   block [0x82C673D8..0x82C673E4)
	// 82C673D8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C673DC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C673E0: 48042070  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C673E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C673E8 size=128
    let mut pc: u32 = 0x82C673E8;
    'dispatch: loop {
        match pc {
            0x82C673E8 => {
    //   block [0x82C673E8..0x82C67410)
	// 82C673E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C673EC: 48042021  bl 0x82ca940c
	ctx.lr = 0x82C673F0;
	sub_82CA93D0(ctx, base);
	// 82C673F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C673F4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C673F8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C673FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C67400: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C67404: 4BFFFEBD  bl 0x82c672c0
	ctx.lr = 0x82C67408;
	sub_82C672C0(ctx, base);
	// 82C67408: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C6740C: 409A0010  bne cr6, 0x82c6741c
	if !ctx.cr[6].eq {
	pc = 0x82C6741C; continue 'dispatch;
	}
	pc = 0x82C67410; continue 'dispatch;
            }
            0x82C67410 => {
    //   block [0x82C67410..0x82C6741C)
	// 82C67410: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C67414: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C67418: 48042044  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6741C => {
    //   block [0x82C6741C..0x82C67450)
	// 82C6741C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C67420: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82C67424: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C67428: 419A0028  beq cr6, 0x82c67450
	if ctx.cr[6].eq {
	pc = 0x82C67450; continue 'dispatch;
	}
	// 82C6742C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67430: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67434: 7D440774  extsb r4, r10
	ctx.r[4].s64 = ctx.r[10].s8 as i64;
	// 82C67438: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C6743C: 419A0014  beq cr6, 0x82c67450
	if ctx.cr[6].eq {
	pc = 0x82C67450; continue 'dispatch;
	}
	// 82C67440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C67444: 4BFFFC75  bl 0x82c670b8
	ctx.lr = 0x82C67448;
	sub_82C670B8(ctx, base);
	// 82C67448: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C6744C: 419AFFC4  beq cr6, 0x82c67410
	if ctx.cr[6].eq {
	pc = 0x82C67410; continue 'dispatch;
	}
	pc = 0x82C67450; continue 'dispatch;
            }
            0x82C67450 => {
    //   block [0x82C67450..0x82C67468)
	// 82C67450: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C67454: 4804475D  bl 0x82cabbb0
	ctx.lr = 0x82C67458;
	sub_82CABBB0(ctx, base);
	// 82C67458: D83D0000  stfd f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.f[1].u64 ) };
	// 82C6745C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C67460: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C67464: 48041FF8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C67468 size=96
    let mut pc: u32 = 0x82C67468;
    'dispatch: loop {
        match pc {
            0x82C67468 => {
    //   block [0x82C67468..0x82C674B0)
	// 82C67468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6746C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C67470: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C67474: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C67478: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C6747C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C67480: 4BFFFF69  bl 0x82c673e8
	ctx.lr = 0x82C67484;
	sub_82C673E8(ctx, base);
	// 82C67484: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C67488: 419A0028  beq cr6, 0x82c674b0
	if ctx.cr[6].eq {
	pc = 0x82C674B0; continue 'dispatch;
	}
	// 82C6748C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C67490: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C67494: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82C67498: D1BF0000  stfs f13, 0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C6749C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C674A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C674A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C674A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C674AC: 4E800020  blr
	return;
            }
            0x82C674B0 => {
    //   block [0x82C674B0..0x82C674C8)
	// 82C674B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C674B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C674B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C674BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C674C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C674C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C674C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C674C8 size=68
    let mut pc: u32 = 0x82C674C8;
    'dispatch: loop {
        match pc {
            0x82C674C8 => {
    //   block [0x82C674C8..0x82C6750C)
	// 82C674C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C674CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C674D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C674D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C674D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C674DC: 38640001  addi r3, r4, 1
	ctx.r[3].s64 = ctx.r[4].s64 + 1;
	// 82C674E0: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82C674E4: 90BF0004  stw r5, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82C674E8: 4B682CD1  bl 0x822ea1b8
	ctx.lr = 0x82C674EC;
	sub_822EA1B8(ctx, base);
	// 82C674EC: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82C674F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C674F4: 4BFFFAD5  bl 0x82c66fc8
	ctx.lr = 0x82C674F8;
	sub_82C66FC8(ctx, base);
	// 82C674F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C674FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C67500: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C67504: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C67508: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C67510 size=52
    let mut pc: u32 = 0x82C67510;
    'dispatch: loop {
        match pc {
            0x82C67510 => {
    //   block [0x82C67510..0x82C67544)
	// 82C67510: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82C67514: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82C67518: 7D601828  lwarx r11, 0, r3
	// lwarx
	let ea = ctx.r[3].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82C6751C: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82C67520: 409A0024  bne cr6, 0x82c67544
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C67544);
		return;
	}
	// 82C67524: 7CA0192D  stwcx. r5, 0, r3
	// stwcx.
	let addr = ctx.r[3].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82C67528: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82C6752C: 4082FFE4  bne 0x82c67510
	if !ctx.cr[0].eq {
	pc = 0x82C67510; continue 'dispatch;
	}
	// 82C67530: 7D6B5B78  mr r11, r11
	ctx.r[11].u64 = ctx.r[11].u64;
	// 82C67534: 7D245850  subf r9, r4, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 82C67538: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 82C6753C: 5503DFFE  rlwinm r3, r8, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82C67540: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C67560 size=28
    let mut pc: u32 = 0x82C67560;
    'dispatch: loop {
        match pc {
            0x82C67560 => {
    //   block [0x82C67560..0x82C6757C)
	// 82C67560: 3D60834F  lis r11, -0x7cb1
	ctx.r[11].s64 = -2091974656;
	// 82C67564: 814B7734  lwz r10, 0x7734(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30516 as u32) ) } as u64;
	// 82C67568: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C6756C: 419A0010  beq cr6, 0x82c6757c
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C6757C);
		return;
	}
	// 82C67570: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C67574: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82C67578: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C67588 size=28
    let mut pc: u32 = 0x82C67588;
    'dispatch: loop {
        match pc {
            0x82C67588 => {
    //   block [0x82C67588..0x82C675A4)
	// 82C67588: 3D60834F  lis r11, -0x7cb1
	ctx.r[11].s64 = -2091974656;
	// 82C6758C: 814B7738  lwz r10, 0x7738(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30520 as u32) ) } as u64;
	// 82C67590: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C67594: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C67598: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6759C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82C675A0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C675A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C675A8 size=28
    let mut pc: u32 = 0x82C675A8;
    'dispatch: loop {
        match pc {
            0x82C675A8 => {
    //   block [0x82C675A8..0x82C675C4)
	// 82C675A8: 3D60834F  lis r11, -0x7cb1
	ctx.r[11].s64 = -2091974656;
	// 82C675AC: 814B772C  lwz r10, 0x772c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30508 as u32) ) } as u64;
	// 82C675B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C675B4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C675B8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C675BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82C675C0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C675C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C675C8 size=28
    let mut pc: u32 = 0x82C675C8;
    'dispatch: loop {
        match pc {
            0x82C675C8 => {
    //   block [0x82C675C8..0x82C675E4)
	// 82C675C8: 3D60834F  lis r11, -0x7cb1
	ctx.r[11].s64 = -2091974656;
	// 82C675CC: 814B7730  lwz r10, 0x7730(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30512 as u32) ) } as u64;
	// 82C675D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C675D4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C675D8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C675DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82C675E0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C675E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C675E8 size=104
    let mut pc: u32 = 0x82C675E8;
    'dispatch: loop {
        match pc {
            0x82C675E8 => {
    //   block [0x82C675E8..0x82C67634)
	// 82C675E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C675EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C675F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C675F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C675F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C675FC: 7D4429D6  mullw r10, r4, r5
	ctx.r[10].s32 = ((ctx.r[4].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82C67600: 909F0010  stw r4, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 82C67604: 90BF000C  stw r5, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 82C67608: 90DF0014  stw r6, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 82C6760C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C67610: 5543103A  slwi r3, r10, 2
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C67614: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C67618: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C6761C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C67620: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C67624: 419A0010  beq cr6, 0x82c67634
	if ctx.cr[6].eq {
	pc = 0x82C67634; continue 'dispatch;
	}
	// 82C67628: 4BFF8941  bl 0x82c5ff68
	ctx.lr = 0x82C6762C;
	sub_82C5FF68(ctx, base);
	// 82C6762C: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 82C67630: 48000008  b 0x82c67638
	pc = 0x82C67638; continue 'dispatch;
            }
            0x82C67634 => {
    //   block [0x82C67634..0x82C67638)
	// 82C67634: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x82C67638; continue 'dispatch;
            }
            0x82C67638 => {
    //   block [0x82C67638..0x82C67650)
	// 82C67638: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6763C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C67640: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C67644: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C67648: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6764C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C67650 size=16
    let mut pc: u32 = 0x82C67650;
    'dispatch: loop {
        match pc {
            0x82C67650 => {
    //   block [0x82C67650..0x82C67660)
	// 82C67650: 80630018  lwz r3, 0x18(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C67654: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C67658: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C6765C: 4BFF89FC  b 0x82c60058
	sub_82C60058(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C67668 size=188
    let mut pc: u32 = 0x82C67668;
    'dispatch: loop {
        match pc {
            0x82C67668 => {
    //   block [0x82C67668..0x82C67684)
	// 82C67668: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C6766C: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82C67670: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C67674: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82C67678: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C6767C: 41980044  blt cr6, 0x82c676c0
	if ctx.cr[6].lt {
	pc = 0x82C676C0; continue 'dispatch;
	}
	// 82C67680: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	pc = 0x82C67684; continue 'dispatch;
            }
            0x82C67684 => {
    //   block [0x82C67684..0x82C676A4)
	// 82C67684: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82C67688: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 82C6768C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C67690: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C67694: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C67698: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C6769C: 41980008  blt cr6, 0x82c676a4
	if ctx.cr[6].lt {
	pc = 0x82C676A4; continue 'dispatch;
	}
	// 82C676A0: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	pc = 0x82C676A4; continue 'dispatch;
            }
            0x82C676A4 => {
    //   block [0x82C676A4..0x82C676C0)
	// 82C676A4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C676A8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82C676AC: 5566003E  slwi r6, r11, 0
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82C676B0: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C676B4: 80A30010  lwz r5, 0x10(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C676B8: 7F062840  cmplw cr6, r6, r5
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C676BC: 4098FFC8  bge cr6, 0x82c67684
	if !ctx.cr[6].lt {
	pc = 0x82C67684; continue 'dispatch;
	}
	pc = 0x82C676C0; continue 'dispatch;
            }
            0x82C676C0 => {
    //   block [0x82C676C0..0x82C676E0)
	// 82C676C0: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C676C4: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C676C8: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C676CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C676D0: 7CCB49D6  mullw r6, r11, r9
	ctx.r[6].s32 = ((ctx.r[11].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 82C676D4: 54C9103A  slwi r9, r6, 2
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C676D8: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82C676DC: 4099001C  ble cr6, 0x82c676f8
	if !ctx.cr[6].gt {
	pc = 0x82C676F8; continue 'dispatch;
	}
	pc = 0x82C676E0; continue 'dispatch;
            }
            0x82C676E0 => {
    //   block [0x82C676E0..0x82C676F8)
	// 82C676E0: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C676E4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C676E8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82C676EC: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C676F0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82C676F4: 4181FFEC  bgt 0x82c676e0
	if ctx.cr[0].gt {
	pc = 0x82C676E0; continue 'dispatch;
	}
	pc = 0x82C676F8; continue 'dispatch;
            }
            0x82C676F8 => {
    //   block [0x82C676F8..0x82C67714)
	// 82C676F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C676FC: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C67700: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C67704: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C67708: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6770C: 41980008  blt cr6, 0x82c67714
	if ctx.cr[6].lt {
	pc = 0x82C67714; continue 'dispatch;
	}
	// 82C67710: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	pc = 0x82C67714; continue 'dispatch;
            }
            0x82C67714 => {
    //   block [0x82C67714..0x82C67724)
	// 82C67714: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C67718: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C6771C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C67720: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C67728 size=128
    let mut pc: u32 = 0x82C67728;
    'dispatch: loop {
        match pc {
            0x82C67728 => {
    //   block [0x82C67728..0x82C6775C)
	// 82C67728: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C6772C: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 82C67730: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C67734: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C67738: 40990070  ble cr6, 0x82c677a8
	if !ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x82C677A8);
		return;
	}
	// 82C6773C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67740: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C67744: 80EB0018  lwz r7, 0x18(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C67748: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C6774C: 7CC951D6  mullw r6, r9, r10
	ctx.r[6].s32 = ((ctx.r[9].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 82C67750: 54C9103A  slwi r9, r6, 2
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C67754: 7D293A14  add r9, r9, r7
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 82C67758: 4099001C  ble cr6, 0x82c67774
	if !ctx.cr[6].gt {
	pc = 0x82C67774; continue 'dispatch;
	}
	pc = 0x82C6775C; continue 'dispatch;
            }
            0x82C6775C => {
    //   block [0x82C6775C..0x82C67774)
	// 82C6775C: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67760: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C67764: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82C67768: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82C6776C: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82C67770: 4181FFEC  bgt 0x82c6775c
	if ctx.cr[0].gt {
	pc = 0x82C6775C; continue 'dispatch;
	}
	pc = 0x82C67774; continue 'dispatch;
            }
            0x82C67774 => {
    //   block [0x82C67774..0x82C67794)
	// 82C67774: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C67778: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C6777C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C67780: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C67784: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C67788: 4198000C  blt cr6, 0x82c67794
	if ctx.cr[6].lt {
	pc = 0x82C67794; continue 'dispatch;
	}
	// 82C6778C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C67790: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x82C67794; continue 'dispatch;
            }
            0x82C67794 => {
    //   block [0x82C67794..0x82C677A8)
	// 82C67794: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C67798: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C6779C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82C677A0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C677A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C677B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C677B0 size=184
    let mut pc: u32 = 0x82C677B0;
    'dispatch: loop {
        match pc {
            0x82C677B0 => {
    //   block [0x82C677B0..0x82C677D8)
	// 82C677B0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C677B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C677B8: 409A00B0  bne cr6, 0x82c67868
	if !ctx.cr[6].eq {
		sub_82C67868(ctx, base);
		return;
	}
	// 82C677BC: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C677C0: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 82C677C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C677C8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C677CC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C677D0: C96BDE38  lfd f11, -0x21c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-8648 as u32) ) };
	// 82C677D4: C18A0C18  lfs f12, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82C677D8; continue 'dispatch;
            }
            0x82C677D8 => {
    //   block [0x82C677D8..0x82C677F0)
	// 82C677D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C677DC: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	// 82C677E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C677E4: 40990038  ble cr6, 0x82c6781c
	if !ctx.cr[6].gt {
	pc = 0x82C6781C; continue 'dispatch;
	}
	// 82C677E8: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C677EC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x82C677F0; continue 'dispatch;
            }
            0x82C677F0 => {
    //   block [0x82C677F0..0x82C67804)
	// 82C677F0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C677F4: 7C09442E  lfsx f0, r9, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C677F8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82C677FC: 40980008  bge cr6, 0x82c67804
	if !ctx.cr[6].lt {
	pc = 0x82C67804; continue 'dispatch;
	}
	// 82C67800: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82C67804; continue 'dispatch;
            }
            0x82C67804 => {
    //   block [0x82C67804..0x82C67810)
	// 82C67804: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C67808: 40990008  ble cr6, 0x82c67810
	if !ctx.cr[6].gt {
	pc = 0x82C67810; continue 'dispatch;
	}
	// 82C6780C: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	pc = 0x82C67810; continue 'dispatch;
            }
            0x82C67810 => {
    //   block [0x82C67810..0x82C6781C)
	// 82C67810: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C67814: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C67818: 4082FFD8  bne 0x82c677f0
	if !ctx.cr[0].eq {
	pc = 0x82C677F0; continue 'dispatch;
	}
	pc = 0x82C6781C; continue 'dispatch;
            }
            0x82C6781C => {
    //   block [0x82C6781C..0x82C67834)
	// 82C6781C: C003001C  lfs f0, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C67820: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C67824: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82C67828: 4099000C  ble cr6, 0x82c67834
	if !ctx.cr[6].gt {
	pc = 0x82C67834; continue 'dispatch;
	}
	// 82C6782C: C1430010  lfs f10, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C67830: 48000008  b 0x82c67838
	pc = 0x82C67838; continue 'dispatch;
            }
            0x82C67834 => {
    //   block [0x82C67834..0x82C67838)
	// 82C67834: C1430018  lfs f10, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	pc = 0x82C67838; continue 'dispatch;
            }
            0x82C67838 => {
    //   block [0x82C67838..0x82C67850)
	// 82C67838: ED2D02BA  fmadds f9, f13, f10, f0
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C6783C: D123001C  stfs f9, 0x1c(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82C67840: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 82C67844: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82C67848: 40980008  bge cr6, 0x82c67850
	if !ctx.cr[6].lt {
	pc = 0x82C67850; continue 'dispatch;
	}
	// 82C6784C: D183001C  stfs f12, 0x1c(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	pc = 0x82C67850; continue 'dispatch;
            }
            0x82C67850 => {
    //   block [0x82C67850..0x82C67868)
	// 82C67850: C003001C  lfs f0, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C67854: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C67858: 7C092D2E  stfsx f0, r9, r5
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 82C6785C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82C67860: 4082FF78  bne 0x82c677d8
	if !ctx.cr[0].eq {
	pc = 0x82C677D8; continue 'dispatch;
	}
	// 82C67864: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C67868 size=168
    let mut pc: u32 = 0x82C67868;
    'dispatch: loop {
        match pc {
            0x82C67868 => {
    //   block [0x82C67868..0x82C6788C)
	// 82C67868: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82C6786C: 409A00A4  bne cr6, 0x82c67910
	if !ctx.cr[6].eq {
		sub_82C67910(ctx, base);
		return;
	}
	// 82C67870: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C67874: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 82C67878: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C6787C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C67880: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C67884: C96BDE38  lfd f11, -0x21c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-8648 as u32) ) };
	// 82C67888: C18A0C18  lfs f12, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x82C6788C; continue 'dispatch;
            }
            0x82C6788C => {
    //   block [0x82C6788C..0x82C678A4)
	// 82C6788C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67890: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 82C67894: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C67898: 4099002C  ble cr6, 0x82c678c4
	if !ctx.cr[6].gt {
	pc = 0x82C678C4; continue 'dispatch;
	}
	// 82C6789C: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C678A0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x82C678A4; continue 'dispatch;
            }
            0x82C678A4 => {
    //   block [0x82C678A4..0x82C678B8)
	// 82C678A4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C678A8: 7DA9442E  lfsx f13, r9, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C678AC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C678B0: 40990008  ble cr6, 0x82c678b8
	if !ctx.cr[6].gt {
	pc = 0x82C678B8; continue 'dispatch;
	}
	// 82C678B4: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82C678B8; continue 'dispatch;
            }
            0x82C678B8 => {
    //   block [0x82C678B8..0x82C678C4)
	// 82C678B8: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C678BC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C678C0: 4082FFE4  bne 0x82c678a4
	if !ctx.cr[0].eq {
	pc = 0x82C678A4; continue 'dispatch;
	}
	pc = 0x82C678C4; continue 'dispatch;
            }
            0x82C678C4 => {
    //   block [0x82C678C4..0x82C678DC)
	// 82C678C4: C1A3001C  lfs f13, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C678C8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C678CC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82C678D0: 4099000C  ble cr6, 0x82c678dc
	if !ctx.cr[6].gt {
	pc = 0x82C678DC; continue 'dispatch;
	}
	// 82C678D4: C1430010  lfs f10, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C678D8: 48000008  b 0x82c678e0
	pc = 0x82C678E0; continue 'dispatch;
            }
            0x82C678DC => {
    //   block [0x82C678DC..0x82C678E0)
	// 82C678DC: C1430018  lfs f10, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	pc = 0x82C678E0; continue 'dispatch;
            }
            0x82C678E0 => {
    //   block [0x82C678E0..0x82C678F8)
	// 82C678E0: ED206ABA  fmadds f9, f0, f10, f13
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64);
	// 82C678E4: D123001C  stfs f9, 0x1c(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82C678E8: FC004890  fmr f0, f9
	ctx.f[0].f64 = ctx.f[9].f64;
	// 82C678EC: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82C678F0: 40980008  bge cr6, 0x82c678f8
	if !ctx.cr[6].lt {
	pc = 0x82C678F8; continue 'dispatch;
	}
	// 82C678F4: D183001C  stfs f12, 0x1c(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	pc = 0x82C678F8; continue 'dispatch;
            }
            0x82C678F8 => {
    //   block [0x82C678F8..0x82C67910)
	// 82C678F8: C003001C  lfs f0, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C678FC: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C67900: 7C092D2E  stfsx f0, r9, r5
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 82C67904: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82C67908: 4082FF84  bne 0x82c6788c
	if !ctx.cr[0].eq {
	pc = 0x82C6788C; continue 'dispatch;
	}
	// 82C6790C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C67910 size=200
    let mut pc: u32 = 0x82C67910;
    'dispatch: loop {
        match pc {
            0x82C67910 => {
    //   block [0x82C67910..0x82C67958)
	// 82C67910: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82C67914: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 82C67918: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6791C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C67920: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C67924: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82C67928: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 82C6792C: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C67930: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82C67934: C80A0CB8  lfd f0, 0xcb8(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(3256 as u32) ) };
	// 82C67938: FD806824  fdiv f12, f0, f13
	ctx.f[12].f64 = ctx.f[0].f64 / ctx.f[13].f64;
	// 82C6793C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82C67940: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 82C67944: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C67948: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C6794C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C67950: C94BDE38  lfd f10, -0x21c8(r11)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-8648 as u32) ) };
	// 82C67954: C16A0C18  lfs f11, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x82C67958; continue 'dispatch;
            }
            0x82C67958 => {
    //   block [0x82C67958..0x82C67970)
	// 82C67958: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6795C: FC005890  fmr f0, f11
	ctx.f[0].f64 = ctx.f[11].f64;
	// 82C67960: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C67964: 40990024  ble cr6, 0x82c67988
	if !ctx.cr[6].gt {
	pc = 0x82C67988; continue 'dispatch;
	}
	// 82C67968: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6796C: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	pc = 0x82C67970; continue 'dispatch;
            }
            0x82C67970 => {
    //   block [0x82C67970..0x82C67988)
	// 82C67970: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67974: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C67978: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82C6797C: 7DA84C2E  lfsx f13, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C67980: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C67984: 4082FFEC  bne 0x82c67970
	if !ctx.cr[0].eq {
	pc = 0x82C67970; continue 'dispatch;
	}
	pc = 0x82C67988; continue 'dispatch;
            }
            0x82C67988 => {
    //   block [0x82C67988..0x82C679A4)
	// 82C67988: EDAC0032  fmuls f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C6798C: C003001C  lfs f0, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C67990: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C67994: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82C67998: 4099000C  ble cr6, 0x82c679a4
	if !ctx.cr[6].gt {
	pc = 0x82C679A4; continue 'dispatch;
	}
	// 82C6799C: C1230010  lfs f9, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C679A0: 48000008  b 0x82c679a8
	pc = 0x82C679A8; continue 'dispatch;
            }
            0x82C679A4 => {
    //   block [0x82C679A4..0x82C679A8)
	// 82C679A4: C1230018  lfs f9, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	pc = 0x82C679A8; continue 'dispatch;
            }
            0x82C679A8 => {
    //   block [0x82C679A8..0x82C679C0)
	// 82C679A8: ED0D027A  fmadds f8, f13, f9, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C679AC: D103001C  stfs f8, 0x1c(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82C679B0: FC004090  fmr f0, f8
	ctx.f[0].f64 = ctx.f[8].f64;
	// 82C679B4: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82C679B8: 40980008  bge cr6, 0x82c679c0
	if !ctx.cr[6].lt {
	pc = 0x82C679C0; continue 'dispatch;
	}
	// 82C679BC: D163001C  stfs f11, 0x1c(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	pc = 0x82C679C0; continue 'dispatch;
            }
            0x82C679C0 => {
    //   block [0x82C679C0..0x82C679D8)
	// 82C679C0: C003001C  lfs f0, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C679C4: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C679C8: 7C092D2E  stfsx f0, r9, r5
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32), tmp.u32) };
	// 82C679CC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82C679D0: 4082FF88  bne 0x82c67958
	if !ctx.cr[0].eq {
	pc = 0x82C67958; continue 'dispatch;
	}
	// 82C679D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C679D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C679D8 size=52
    let mut pc: u32 = 0x82C679D8;
    'dispatch: loop {
        match pc {
            0x82C679D8 => {
    //   block [0x82C679D8..0x82C67A0C)
	// 82C679D8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82C679DC: C1630004  lfs f11, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C679E0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C679E4: D023000C  stfs f1, 0xc(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C679E8: C00BBE14  lfs f0, -0x41ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C679EC: C18A0C14  lfs f12, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C679F0: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C679F4: EC0C5824  fdivs f0, f12, f11
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[11].f64) as f32) as f64;
	// 82C679F8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C679FC: 40980010  bge cr6, 0x82c67a0c
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82C67A0C);
		return;
	}
	// 82C67A00: EC000024  fdivs f0, f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[0].f64) as f32) as f64;
	// 82C67A04: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82C67A08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C67A18 size=52
    let mut pc: u32 = 0x82C67A18;
    'dispatch: loop {
        match pc {
            0x82C67A18 => {
    //   block [0x82C67A18..0x82C67A4C)
	// 82C67A18: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82C67A1C: C1630004  lfs f11, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C67A20: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C67A24: D0230014  stfs f1, 0x14(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82C67A28: C00BBE14  lfs f0, -0x41ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C67A2C: C18A0C14  lfs f12, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C67A30: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C67A34: EC0C5824  fdivs f0, f12, f11
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[11].f64) as f32) as f64;
	// 82C67A38: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C67A3C: 40980010  bge cr6, 0x82c67a4c
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82C67A4C);
		return;
	}
	// 82C67A40: EC000024  fdivs f0, f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[0].f64) as f32) as f64;
	// 82C67A44: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82C67A48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C67A58 size=8
    let mut pc: u32 = 0x82C67A58;
    'dispatch: loop {
        match pc {
            0x82C67A58 => {
    //   block [0x82C67A58..0x82C67A60)
	// 82C67A58: 90830008  stw r4, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82C67A5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C67A60 size=12
    let mut pc: u32 = 0x82C67A60;
    'dispatch: loop {
        match pc {
            0x82C67A60 => {
    //   block [0x82C67A60..0x82C67A6C)
	// 82C67A60: 7C8B0034  cntlzw r11, r4
	ctx.r[11].u64 = if ctx.r[4].u32 == 0 { 32 } else { ctx.r[4].u32.leading_zeros() as u64 };
	// 82C67A64: 5564DFFE  rlwinm r4, r11, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82C67A68: 4BFFFFF0  b 0x82c67a58
	sub_82C67A58(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67A70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C67A70 size=8
    let mut pc: u32 = 0x82C67A70;
    'dispatch: loop {
        match pc {
            0x82C67A70 => {
    //   block [0x82C67A70..0x82C67A78)
	// 82C67A70: D023001C  stfs f1, 0x1c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82C67A74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C67A78 size=116
    let mut pc: u32 = 0x82C67A78;
    'dispatch: loop {
        match pc {
            0x82C67A78 => {
    //   block [0x82C67A78..0x82C67AEC)
	// 82C67A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C67A7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C67A80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C67A84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C67A88: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82C67A8C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C67A90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C67A94: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C67A98: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 82C67A9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C67AA0: 4BFFC499  bl 0x82c63f38
	ctx.lr = 0x82C67AA4;
	sub_82C63F38(ctx, base);
	// 82C67AA4: D3FF0004  stfs f31, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C67AA8: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82C67AAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C67AB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C67AB4: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C67AB8: ED40F824  fdivs f10, f0, f31
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	// 82C67ABC: FC205090  fmr f1, f10
	ctx.f[1].f64 = ctx.f[10].f64;
	// 82C67AC0: 4BFFFF19  bl 0x82c679d8
	ctx.lr = 0x82C67AC4;
	sub_82C679D8(ctx, base);
	// 82C67AC4: 4BFFFF55  bl 0x82c67a18
	ctx.lr = 0x82C67AC8;
	sub_82C67A18(ctx, base);
	// 82C67AC8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C67ACC: 4BFFFF8D  bl 0x82c67a58
	ctx.lr = 0x82C67AD0;
	sub_82C67A58(ctx, base);
	// 82C67AD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C67AD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C67AD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C67ADC: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82C67AE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C67AE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C67AE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C67AF0 size=88
    let mut pc: u32 = 0x82C67AF0;
    'dispatch: loop {
        match pc {
            0x82C67AF0 => {
    //   block [0x82C67AF0..0x82C67B48)
	// 82C67AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C67AF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C67AF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C67AFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C67B00: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82C67B04: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C67B08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C67B0C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C67B10: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82C67B14: 4BFFC455  bl 0x82c63f68
	ctx.lr = 0x82C67B18;
	sub_82C63F68(ctx, base);
	// 82C67B18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C67B1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C67B20: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C67B24: 4BFFFF55  bl 0x82c67a78
	ctx.lr = 0x82C67B28;
	sub_82C67A78(ctx, base);
	// 82C67B28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C67B2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C67B30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C67B34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C67B38: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82C67B3C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C67B40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C67B44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C67B48 size=32
    let mut pc: u32 = 0x82C67B48;
    'dispatch: loop {
        match pc {
            0x82C67B48 => {
    //   block [0x82C67B48..0x82C67B58)
	// 82C67B48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C67B4C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C67B50: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82C67B54: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82C67B58; continue 'dispatch;
            }
            0x82C67B58 => {
    //   block [0x82C67B58..0x82C67B68)
	// 82C67B58: 5463083C  slwi r3, r3, 1
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C67B5C: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C67B60: 4198FFF8  blt cr6, 0x82c67b58
	if ctx.cr[6].lt {
	pc = 0x82C67B58; continue 'dispatch;
	}
	// 82C67B64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C67B68 size=120
    let mut pc: u32 = 0x82C67B68;
    'dispatch: loop {
        match pc {
            0x82C67B68 => {
    //   block [0x82C67B68..0x82C67B94)
	// 82C67B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C67B6C: 480418A1  bl 0x82ca940c
	ctx.lr = 0x82C67B70;
	sub_82CA93D0(ctx, base);
	// 82C67B70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C67B74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C67B78: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 82C67B7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C67B80: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C67B84: 4BFFC3B5  bl 0x82c63f38
	ctx.lr = 0x82C67B88;
	sub_82C63F38(ctx, base);
	// 82C67B88: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 82C67B8C: 40980008  bge cr6, 0x82c67b94
	if !ctx.cr[6].lt {
	pc = 0x82C67B94; continue 'dispatch;
	}
	// 82C67B90: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x82C67B94; continue 'dispatch;
            }
            0x82C67B94 => {
    //   block [0x82C67B94..0x82C67BE0)
	// 82C67B94: 387E0001  addi r3, r30, 1
	ctx.r[3].s64 = ctx.r[30].s64 + 1;
	// 82C67B98: 4BFFFFB1  bl 0x82c67b48
	ctx.lr = 0x82C67B9C;
	sub_82C67B48(ctx, base);
	// 82C67B9C: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82C67BA0: 5463103A  slwi r3, r3, 2
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C67BA4: 4BFFC3C5  bl 0x82c63f68
	ctx.lr = 0x82C67BA8;
	sub_82C63F68(ctx, base);
	// 82C67BA8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C67BAC: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C67BB0: 39200100  li r9, 0x100
	ctx.r[9].s64 = 256;
	// 82C67BB4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82C67BB8: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82C67BBC: 7D1D5050  subf r8, r29, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[29].s64;
	// 82C67BC0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82C67BC4: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C67BC8: 7D075838  and r7, r8, r11
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[11].u64;
	// 82C67BCC: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82C67BD0: 913F0030  stw r9, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[9].u32 ) };
	// 82C67BD4: 90FF001C  stw r7, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 82C67BD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C67BDC: 48041880  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C67BE0 size=56
    let mut pc: u32 = 0x82C67BE0;
    'dispatch: loop {
        match pc {
            0x82C67BE0 => {
    //   block [0x82C67BE0..0x82C67C18)
	// 82C67BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C67BE4: 48041829  bl 0x82ca940c
	ctx.lr = 0x82C67BE8;
	sub_82CA93D0(ctx, base);
	// 82C67BE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C67BEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C67BF0: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 82C67BF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C67BF8: 4BFFC371  bl 0x82c63f68
	ctx.lr = 0x82C67BFC;
	sub_82C63F68(ctx, base);
	// 82C67BFC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C67C00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C67C04: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C67C08: 4BFFFF61  bl 0x82c67b68
	ctx.lr = 0x82C67C0C;
	sub_82C67B68(ctx, base);
	// 82C67C0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C67C10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C67C14: 48041848  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C67C18 size=16
    let mut pc: u32 = 0x82C67C18;
    'dispatch: loop {
        match pc {
            0x82C67C18 => {
    //   block [0x82C67C18..0x82C67C28)
	// 82C67C18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C67C1C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C67C20: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67C24: 4BFFC354  b 0x82c63f78
	sub_82C63F78(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C67C30 size=52
    let mut pc: u32 = 0x82C67C30;
    'dispatch: loop {
        match pc {
            0x82C67C30 => {
    //   block [0x82C67C30..0x82C67C64)
	// 82C67C30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C67C34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C67C38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C67C3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C67C40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C67C44: 4BFFFFD5  bl 0x82c67c18
	ctx.lr = 0x82C67C48;
	sub_82C67C18(ctx, base);
	// 82C67C48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C67C4C: 4BFFC32D  bl 0x82c63f78
	ctx.lr = 0x82C67C50;
	sub_82C63F78(ctx, base);
	// 82C67C50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C67C54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C67C58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C67C5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C67C60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67C68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C67C68 size=16
    let mut pc: u32 = 0x82C67C68;
    'dispatch: loop {
        match pc {
            0x82C67C68 => {
    //   block [0x82C67C68..0x82C67C78)
	// 82C67C68: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C67C6C: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67C70: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82C67C74: 4BFFC2C4  b 0x82c63f38
	sub_82C63F38(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C67C78 size=148
    let mut pc: u32 = 0x82C67C78;
    'dispatch: loop {
        match pc {
            0x82C67C78 => {
    //   block [0x82C67C78..0x82C67D0C)
	// 82C67C78: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C67C7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C67C80: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 82C67C84: 81630034  lwz r11, 0x34(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C67C88: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C67C8C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C67C90: 8143003C  lwz r10, 0x3c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 82C67C94: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C67C98: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82C67C9C: 419A0088  beq cr6, 0x82c67d24
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C67D24);
		return;
	}
	// 82C67CA0: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 82C67CA4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C67CA8: 419A0064  beq cr6, 0x82c67d0c
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C67D0C);
		return;
	}
	// 82C67CAC: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C67CB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C67CB4: 419A0058  beq cr6, 0x82c67d0c
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82C67D0C);
		return;
	}
	// 82C67CB8: 7D6807B4  extsw r8, r11
	ctx.r[8].s64 = ctx.r[11].s32 as i64;
	// 82C67CBC: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C67CC0: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82C67CC4: F901FFF0  std r8, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u64 ) };
	// 82C67CC8: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C67CCC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82C67CD0: 7D250034  cntlzw r5, r9
	ctx.r[5].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 82C67CD4: C8070CB8  lfd f0, 0xcb8(r7)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(3256 as u32) ) };
	// 82C67CD8: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82C67CDC: FD806824  fdiv f12, f0, f13
	ctx.f[12].f64 = ctx.f[0].f64 / ctx.f[13].f64;
	// 82C67CE0: 54ABDFFE  rlwinm r11, r5, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 82C67CE4: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82C67CE8: 9083002C  stw r4, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[4].u32 ) };
	// 82C67CEC: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82C67CF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C67CF4: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82C67CF8: C0060C14  lfs f0, 0xc14(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C67CFC: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C67D00: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82C67D04: D1630024  stfs f11, 0x24(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82C67D08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C67D30 size=472
    let mut pc: u32 = 0x82C67D30;
    'dispatch: loop {
        match pc {
            0x82C67D30 => {
    //   block [0x82C67D30..0x82C67D4C)
	// 82C67D30: 2F060004  cmpwi cr6, r6, 4
	ctx.cr[6].compare_i32(ctx.r[6].s32, 4, &mut ctx.xer);
	// 82C67D34: 41980168  blt cr6, 0x82c67e9c
	if ctx.cr[6].lt {
	pc = 0x82C67E9C; continue 'dispatch;
	}
	// 82C67D38: 3966FFFC  addi r11, r6, -4
	ctx.r[11].s64 = ctx.r[6].s64 + -4;
	// 82C67D3C: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C67D40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C67D44: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C67D48: 7CCA3050  subf r6, r10, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	pc = 0x82C67D4C; continue 'dispatch;
            }
            0x82C67D4C => {
    //   block [0x82C67D4C..0x82C67E9C)
	// 82C67D4C: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C67D50: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C67D54: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67D58: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C67D5C: 7C084D2E  stfsx f0, r8, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82C67D60: 80E3001C  lwz r7, 0x1c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C67D64: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C67D68: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67D6C: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C67D70: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C67D74: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C67D78: 7D4A4838  and r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82C67D7C: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C67D80: 7DA7442E  lfsx f13, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C67D84: D1A50000  stfs f13, 0(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C67D88: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C67D8C: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C67D90: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C67D94: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 82C67D98: 7CEA4838  and r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 & ctx.r[9].u64;
	// 82C67D9C: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67DA0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C67DA4: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82C67DA8: C1840004  lfs f12, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C67DAC: 7D884D2E  stfsx f12, r8, r9
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82C67DB0: 80E3001C  lwz r7, 0x1c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C67DB4: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C67DB8: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67DBC: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C67DC0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C67DC4: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C67DC8: 7D4A4838  and r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82C67DCC: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C67DD0: 7D67442E  lfsx f11, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C67DD4: D1650004  stfs f11, 4(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C67DD8: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C67DDC: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C67DE0: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C67DE4: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 82C67DE8: 7CEA4838  and r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 & ctx.r[9].u64;
	// 82C67DEC: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67DF0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C67DF4: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82C67DF8: C1440008  lfs f10, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C67DFC: 7D484D2E  stfsx f10, r8, r9
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82C67E00: 80E3001C  lwz r7, 0x1c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C67E04: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C67E08: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67E0C: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C67E10: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C67E14: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C67E18: 7D4A4838  and r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82C67E1C: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C67E20: 7D27442E  lfsx f9, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C67E24: D1250008  stfs f9, 8(r5)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C67E28: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C67E2C: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C67E30: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C67E34: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 82C67E38: 7CEA4838  and r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 & ctx.r[9].u64;
	// 82C67E3C: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67E40: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C67E44: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82C67E48: C104000C  lfs f8, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82C67E4C: 7D084D2E  stfsx f8, r8, r9
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82C67E50: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 82C67E54: 80E3001C  lwz r7, 0x1c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C67E58: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C67E5C: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67E60: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C67E64: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C67E68: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C67E6C: 7D4A4838  and r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82C67E70: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C67E74: 7CE7442E  lfsx f7, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C67E78: D0E5000C  stfs f7, 0xc(r5)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C67E7C: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C67E80: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C67E84: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 82C67E88: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 82C67E8C: 90E3001C  stw r7, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 82C67E90: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C67E94: 38A50010  addi r5, r5, 0x10
	ctx.r[5].s64 = ctx.r[5].s64 + 16;
	// 82C67E98: 4082FEB4  bne 0x82c67d4c
	if !ctx.cr[0].eq {
	pc = 0x82C67D4C; continue 'dispatch;
	}
	pc = 0x82C67E9C; continue 'dispatch;
            }
            0x82C67E9C => {
    //   block [0x82C67E9C..0x82C67EA4)
	// 82C67E9C: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C67EA0: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82C67EA4; continue 'dispatch;
            }
            0x82C67EA4 => {
    //   block [0x82C67EA4..0x82C67F08)
	// 82C67EA4: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C67EA8: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C67EAC: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67EB0: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C67EB4: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C67EB8: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82C67EBC: 7C09552E  stfsx f0, r9, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82C67EC0: 80E3000C  lwz r7, 0xc(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67EC4: 8123001C  lwz r9, 0x1c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C67EC8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C67ECC: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C67ED0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C67ED4: 7D6A4038  and r10, r11, r8
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[8].u64;
	// 82C67ED8: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C67EDC: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C67EE0: 7DA83C2E  lfsx f13, r8, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C67EE4: D1A50000  stfs f13, 0(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C67EE8: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C67EEC: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C67EF0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C67EF4: 7D6A3838  and r10, r11, r7
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[7].u64;
	// 82C67EF8: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 82C67EFC: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82C67F00: 4181FFA4  bgt 0x82c67ea4
	if ctx.cr[0].gt {
	pc = 0x82C67EA4; continue 'dispatch;
	}
	// 82C67F04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C67F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C67F08 size=592
    let mut pc: u32 = 0x82C67F08;
    'dispatch: loop {
        match pc {
            0x82C67F08 => {
    //   block [0x82C67F08..0x82C67F24)
	// 82C67F08: 2F060004  cmpwi cr6, r6, 4
	ctx.cr[6].compare_i32(ctx.r[6].s32, 4, &mut ctx.xer);
	// 82C67F0C: 419801C8  blt cr6, 0x82c680d4
	if ctx.cr[6].lt {
	pc = 0x82C680D4; continue 'dispatch;
	}
	// 82C67F10: 3966FFFC  addi r11, r6, -4
	ctx.r[11].s64 = ctx.r[6].s64 + -4;
	// 82C67F14: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C67F18: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C67F1C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C67F20: 7CCA3050  subf r6, r10, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	pc = 0x82C67F24; continue 'dispatch;
            }
            0x82C67F24 => {
    //   block [0x82C67F24..0x82C680D4)
	// 82C67F24: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C67F28: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C67F2C: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67F30: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C67F34: 7C084D2E  stfsx f0, r8, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82C67F38: 80E3001C  lwz r7, 0x1c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C67F3C: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C67F40: C1A30020  lfs f13, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C67F44: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67F48: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C67F4C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C67F50: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C67F54: 7D4A4838  and r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82C67F58: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C67F5C: 7D87442E  lfsx f12, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C67F60: ED6C0372  fmuls f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C67F64: D1650000  stfs f11, 0(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C67F68: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C67F6C: C1430020  lfs f10, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C67F70: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C67F74: C1230024  lfs f9, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C67F78: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C67F7C: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 82C67F80: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67F84: 7CE94838  and r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 & ctx.r[9].u64;
	// 82C67F88: ED0A4828  fsubs f8, f10, f9
	ctx.f[8].f64 = (((ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 82C67F8C: D1030020  stfs f8, 0x20(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C67F90: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C67F94: 9123001C  stw r9, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82C67F98: C0E40004  lfs f7, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C67F9C: 7CE8552E  stfsx f7, r8, r10
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82C67FA0: 80E3001C  lwz r7, 0x1c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C67FA4: C0C30020  lfs f6, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82C67FA8: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C67FAC: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67FB0: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C67FB4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C67FB8: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C67FBC: 7D4A4838  and r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82C67FC0: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C67FC4: 7CA7442E  lfsx f5, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C67FC8: EC8501B2  fmuls f4, f5, f6
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[6].f64) as f32) as f64);
	// 82C67FCC: D0850004  stfs f4, 4(r5)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C67FD0: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C67FD4: C0630020  lfs f3, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82C67FD8: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C67FDC: C0430024  lfs f2, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C67FE0: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C67FE4: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 82C67FE8: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C67FEC: 7CE94838  and r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 & ctx.r[9].u64;
	// 82C67FF0: EC231028  fsubs f1, f3, f2
	ctx.f[1].f64 = (((ctx.f[3].f64 - ctx.f[2].f64) as f32) as f64);
	// 82C67FF4: D0230020  stfs f1, 0x20(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C67FF8: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C67FFC: 9123001C  stw r9, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82C68000: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C68004: 7C08552E  stfsx f0, r8, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82C68008: 80E3001C  lwz r7, 0x1c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6800C: C1A30020  lfs f13, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C68010: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C68014: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C68018: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6801C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C68020: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C68024: 7D4A4838  and r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82C68028: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C6802C: 7D87442E  lfsx f12, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C68030: ED6C0372  fmuls f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C68034: D1650008  stfs f11, 8(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C68038: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6803C: C1430020  lfs f10, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C68040: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C68044: C1230024  lfs f9, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C68048: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6804C: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 82C68050: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C68054: 7CE94838  and r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 & ctx.r[9].u64;
	// 82C68058: ED0A4828  fsubs f8, f10, f9
	ctx.f[8].f64 = (((ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 82C6805C: D1030020  stfs f8, 0x20(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C68060: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C68064: 9123001C  stw r9, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82C68068: C0E4000C  lfs f7, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C6806C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C68070: 7CE8552E  stfsx f7, r8, r10
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82C68074: 80E3001C  lwz r7, 0x1c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C68078: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6807C: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 82C68080: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C68084: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C68088: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C6808C: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C68090: C0C30020  lfs f6, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82C68094: 7D484038  and r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[8].u64;
	// 82C68098: 91030018  stw r8, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82C6809C: 7CA74C2E  lfsx f5, r7, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C680A0: EC8501B2  fmuls f4, f5, f6
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[6].f64) as f32) as f64);
	// 82C680A4: D085000C  stfs f4, 0xc(r5)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C680A8: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C680AC: C0630020  lfs f3, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82C680B0: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C680B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C680B8: C0430024  lfs f2, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C680BC: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82C680C0: EC231028  fsubs f1, f3, f2
	ctx.f[1].f64 = (((ctx.f[3].f64 - ctx.f[2].f64) as f32) as f64);
	// 82C680C4: D0230020  stfs f1, 0x20(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C680C8: 38A50010  addi r5, r5, 0x10
	ctx.r[5].s64 = ctx.r[5].s64 + 16;
	// 82C680CC: 9103001C  stw r8, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 82C680D0: 4082FE54  bne 0x82c67f24
	if !ctx.cr[0].eq {
	pc = 0x82C67F24; continue 'dispatch;
	}
	pc = 0x82C680D4; continue 'dispatch;
            }
            0x82C680D4 => {
    //   block [0x82C680D4..0x82C680DC)
	// 82C680D4: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C680D8: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82C680DC; continue 'dispatch;
            }
            0x82C680DC => {
    //   block [0x82C680DC..0x82C68158)
	// 82C680DC: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C680E0: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C680E4: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C680E8: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C680EC: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C680F0: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82C680F4: 7C09552E  stfsx f0, r9, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82C680F8: 8103001C  lwz r8, 0x1c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C680FC: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C68100: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C68104: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C68108: 80E3000C  lwz r7, 0xc(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6810C: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C68110: 7D685038  and r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 82C68114: C1A30020  lfs f13, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C68118: 91030018  stw r8, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82C6811C: 7D893C2E  lfsx f12, r9, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C68120: ED6C0372  fmuls f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C68124: D1650000  stfs f11, 0(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C68128: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 82C6812C: C1230024  lfs f9, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C68130: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C68134: C1430020  lfs f10, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C68138: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6813C: ED0A4828  fsubs f8, f10, f9
	ctx.f[8].f64 = (((ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 82C68140: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C68144: D1030020  stfs f8, 0x20(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C68148: 7D6A3838  and r10, r11, r7
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[7].u64;
	// 82C6814C: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82C68150: 4181FF8C  bgt 0x82c680dc
	if ctx.cr[0].gt {
	pc = 0x82C680DC; continue 'dispatch;
	}
	// 82C68154: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C68158 size=592
    let mut pc: u32 = 0x82C68158;
    'dispatch: loop {
        match pc {
            0x82C68158 => {
    //   block [0x82C68158..0x82C68174)
	// 82C68158: 2F060004  cmpwi cr6, r6, 4
	ctx.cr[6].compare_i32(ctx.r[6].s32, 4, &mut ctx.xer);
	// 82C6815C: 419801C8  blt cr6, 0x82c68324
	if ctx.cr[6].lt {
	pc = 0x82C68324; continue 'dispatch;
	}
	// 82C68160: 3966FFFC  addi r11, r6, -4
	ctx.r[11].s64 = ctx.r[6].s64 + -4;
	// 82C68164: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C68168: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C6816C: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C68170: 7CCA3050  subf r6, r10, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	pc = 0x82C68174; continue 'dispatch;
            }
            0x82C68174 => {
    //   block [0x82C68174..0x82C68324)
	// 82C68174: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C68178: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C6817C: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C68180: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C68184: 7C084D2E  stfsx f0, r8, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82C68188: 80E3001C  lwz r7, 0x1c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6818C: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C68190: C1A30020  lfs f13, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C68194: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C68198: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6819C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C681A0: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C681A4: 7D4A4838  and r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82C681A8: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C681AC: 7D87442E  lfsx f12, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C681B0: ED6C0372  fmuls f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C681B4: D1650000  stfs f11, 0(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C681B8: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C681BC: C1430020  lfs f10, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C681C0: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C681C4: C1230024  lfs f9, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C681C8: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C681CC: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 82C681D0: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C681D4: 7CE94838  and r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 & ctx.r[9].u64;
	// 82C681D8: ED09502A  fadds f8, f9, f10
	ctx.f[8].f64 = ((ctx.f[9].f64 + ctx.f[10].f64) as f32) as f64;
	// 82C681DC: D1030020  stfs f8, 0x20(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C681E0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C681E4: 9123001C  stw r9, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82C681E8: C0E40004  lfs f7, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C681EC: 7CE8552E  stfsx f7, r8, r10
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82C681F0: 80E3001C  lwz r7, 0x1c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C681F4: C0C30020  lfs f6, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82C681F8: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C681FC: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C68200: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C68204: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C68208: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C6820C: 7D4A4838  and r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82C68210: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C68214: 7CA7442E  lfsx f5, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C68218: EC8501B2  fmuls f4, f5, f6
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[6].f64) as f32) as f64);
	// 82C6821C: D0850004  stfs f4, 4(r5)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C68220: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C68224: C0630020  lfs f3, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82C68228: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6822C: C0430024  lfs f2, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C68230: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C68234: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 82C68238: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6823C: 7CE94838  and r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 & ctx.r[9].u64;
	// 82C68240: EC22182A  fadds f1, f2, f3
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[3].f64) as f32) as f64;
	// 82C68244: D0230020  stfs f1, 0x20(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C68248: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C6824C: 9123001C  stw r9, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82C68250: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C68254: 7C08552E  stfsx f0, r8, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82C68258: 80E3001C  lwz r7, 0x1c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6825C: C1A30020  lfs f13, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C68260: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C68264: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C68268: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6826C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C68270: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C68274: 7D4A4838  and r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82C68278: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C6827C: 7D87442E  lfsx f12, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C68280: ED6C0372  fmuls f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C68284: D1650008  stfs f11, 8(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C68288: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6828C: C1430020  lfs f10, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C68290: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C68294: C1230024  lfs f9, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C68298: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6829C: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 82C682A0: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C682A4: 7CE94838  and r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 & ctx.r[9].u64;
	// 82C682A8: ED09502A  fadds f8, f9, f10
	ctx.f[8].f64 = ((ctx.f[9].f64 + ctx.f[10].f64) as f32) as f64;
	// 82C682AC: D1030020  stfs f8, 0x20(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C682B0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C682B4: 9123001C  stw r9, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82C682B8: C0E4000C  lfs f7, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C682BC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C682C0: 7CE8552E  stfsx f7, r8, r10
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82C682C4: 80E3001C  lwz r7, 0x1c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C682C8: 81030014  lwz r8, 0x14(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C682CC: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 82C682D0: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C682D4: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C682D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C682DC: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C682E0: C0C30020  lfs f6, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82C682E4: 7D484038  and r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[8].u64;
	// 82C682E8: 91030018  stw r8, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82C682EC: 7CA74C2E  lfsx f5, r7, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C682F0: EC8501B2  fmuls f4, f5, f6
	ctx.f[4].f64 = (((ctx.f[5].f64 * ctx.f[6].f64) as f32) as f64);
	// 82C682F4: D085000C  stfs f4, 0xc(r5)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C682F8: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C682FC: C0630020  lfs f3, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82C68300: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C68304: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C68308: C0430024  lfs f2, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C6830C: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82C68310: EC22182A  fadds f1, f2, f3
	ctx.f[1].f64 = ((ctx.f[2].f64 + ctx.f[3].f64) as f32) as f64;
	// 82C68314: D0230020  stfs f1, 0x20(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C68318: 38A50010  addi r5, r5, 0x10
	ctx.r[5].s64 = ctx.r[5].s64 + 16;
	// 82C6831C: 9103001C  stw r8, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 82C68320: 4082FE54  bne 0x82c68174
	if !ctx.cr[0].eq {
	pc = 0x82C68174; continue 'dispatch;
	}
	pc = 0x82C68324; continue 'dispatch;
            }
            0x82C68324 => {
    //   block [0x82C68324..0x82C6832C)
	// 82C68324: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C68328: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82C6832C; continue 'dispatch;
            }
            0x82C6832C => {
    //   block [0x82C6832C..0x82C683A8)
	// 82C6832C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C68330: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C68334: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C68338: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C6833C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C68340: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82C68344: 7C09552E  stfsx f0, r9, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82C68348: 8103001C  lwz r8, 0x1c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6834C: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C68350: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C68354: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C68358: 80E3000C  lwz r7, 0xc(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6835C: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C68360: 7D685038  and r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 82C68364: C1A30020  lfs f13, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C68368: 91030018  stw r8, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82C6836C: 7D893C2E  lfsx f12, r9, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C68370: ED6C0372  fmuls f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C68374: D1650000  stfs f11, 0(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C68378: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 82C6837C: C1230024  lfs f9, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C68380: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C68384: C1430020  lfs f10, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C68388: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6838C: ED09502A  fadds f8, f9, f10
	ctx.f[8].f64 = ((ctx.f[9].f64 + ctx.f[10].f64) as f32) as f64;
	// 82C68390: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C68394: D1030020  stfs f8, 0x20(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C68398: 7D6A3838  and r10, r11, r7
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[7].u64;
	// 82C6839C: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82C683A0: 4181FF8C  bgt 0x82c6832c
	if ctx.cr[0].gt {
	pc = 0x82C6832C; continue 'dispatch;
	}
	// 82C683A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C683A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C683A8 size=580
    let mut pc: u32 = 0x82C683A8;
    'dispatch: loop {
        match pc {
            0x82C683A8 => {
    //   block [0x82C683A8..0x82C683C4)
	// 82C683A8: 2F060004  cmpwi cr6, r6, 4
	ctx.cr[6].compare_i32(ctx.r[6].s32, 4, &mut ctx.xer);
	// 82C683AC: 419801BC  blt cr6, 0x82c68568
	if ctx.cr[6].lt {
	pc = 0x82C68568; continue 'dispatch;
	}
	// 82C683B0: 3966FFFC  addi r11, r6, -4
	ctx.r[11].s64 = ctx.r[6].s64 + -4;
	// 82C683B4: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C683B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C683BC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C683C0: 7CCA3050  subf r6, r10, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	pc = 0x82C683C4; continue 'dispatch;
            }
            0x82C683C4 => {
    //   block [0x82C683C4..0x82C68568)
	// 82C683C4: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C683C8: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C683CC: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C683D0: C1A30020  lfs f13, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C683D4: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C683D8: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C683DC: 7D884D2E  stfsx f12, r8, r9
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82C683E0: 80E3001C  lwz r7, 0x1c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C683E4: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C683E8: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C683EC: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C683F0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C683F4: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C683F8: 7D4A4838  and r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82C683FC: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C68400: 7D67442E  lfsx f11, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C68404: D1650000  stfs f11, 0(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C68408: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6840C: C1430020  lfs f10, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C68410: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C68414: C1230024  lfs f9, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C68418: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6841C: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 82C68420: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C68424: ED09502A  fadds f8, f9, f10
	ctx.f[8].f64 = ((ctx.f[9].f64 + ctx.f[10].f64) as f32) as f64;
	// 82C68428: 7CE94838  and r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 & ctx.r[9].u64;
	// 82C6842C: D1030020  stfs f8, 0x20(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C68430: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C68434: 9123001C  stw r9, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82C68438: C0E40004  lfs f7, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C6843C: ECC70232  fmuls f6, f7, f8
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[8].f64) as f32) as f64);
	// 82C68440: 7CC8552E  stfsx f6, r8, r10
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82C68444: 80E3001C  lwz r7, 0x1c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C68448: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6844C: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C68450: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C68454: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C68458: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C6845C: 7D4A4838  and r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82C68460: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C68464: 7CA7442E  lfsx f5, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C68468: D0A50004  stfs f5, 4(r5)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C6846C: C0830020  lfs f4, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82C68470: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C68474: C0630024  lfs f3, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82C68478: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6847C: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C68480: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 82C68484: EC43202A  fadds f2, f3, f4
	ctx.f[2].f64 = ((ctx.f[3].f64 + ctx.f[4].f64) as f32) as f64;
	// 82C68488: 7CEA4838  and r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 & ctx.r[9].u64;
	// 82C6848C: D0430020  stfs f2, 0x20(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C68490: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C68494: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82C68498: C0240008  lfs f1, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C6849C: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C684A0: EC0100B2  fmuls f0, f1, f2
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[2].f64) as f32) as f64);
	// 82C684A4: 7C084D2E  stfsx f0, r8, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82C684A8: 80E3001C  lwz r7, 0x1c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C684AC: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C684B0: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C684B4: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C684B8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C684BC: 54E7103A  slwi r7, r7, 2
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C684C0: 7D4A4838  and r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 82C684C4: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C684C8: 7DA7442E  lfsx f13, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C684CC: D1A50008  stfs f13, 8(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C684D0: C1830020  lfs f12, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C684D4: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C684D8: C1630024  lfs f11, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C684DC: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C684E0: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C684E4: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 82C684E8: ED4B602A  fadds f10, f11, f12
	ctx.f[10].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	// 82C684EC: 7CEA4838  and r10, r7, r9
	ctx.r[10].u64 = ctx.r[7].u64 & ctx.r[9].u64;
	// 82C684F0: D1430020  stfs f10, 0x20(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C684F4: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C684F8: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 82C684FC: C124000C  lfs f9, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C68500: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C68504: ED0902B2  fmuls f8, f9, f10
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82C68508: 7D084D2E  stfsx f8, r8, r9
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82C6850C: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C68510: 8123001C  lwz r9, 0x1c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C68514: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C68518: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6851C: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 82C68520: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C68524: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C68528: 7D473838  and r7, r10, r7
	ctx.r[7].u64 = ctx.r[10].u64 & ctx.r[7].u64;
	// 82C6852C: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C68530: 90E30018  stw r7, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[7].u32 ) };
	// 82C68534: 7CEA442E  lfsx f7, r10, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C68538: D0E5000C  stfs f7, 0xc(r5)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C6853C: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C68540: C0C30020  lfs f6, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82C68544: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C68548: C0A30024  lfs f5, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C6854C: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 82C68550: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 82C68554: EC85302A  fadds f4, f5, f6
	ctx.f[4].f64 = ((ctx.f[5].f64 + ctx.f[6].f64) as f32) as f64;
	// 82C68558: D0830020  stfs f4, 0x20(r3)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C6855C: 38A50010  addi r5, r5, 0x10
	ctx.r[5].s64 = ctx.r[5].s64 + 16;
	// 82C68560: 90E3001C  stw r7, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 82C68564: 4082FE60  bne 0x82c683c4
	if !ctx.cr[0].eq {
	pc = 0x82C683C4; continue 'dispatch;
	}
	pc = 0x82C68568; continue 'dispatch;
            }
            0x82C68568 => {
    //   block [0x82C68568..0x82C68570)
	// 82C68568: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C6856C: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82C68570; continue 'dispatch;
            }
            0x82C68570 => {
    //   block [0x82C68570..0x82C685EC)
	// 82C68570: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C68574: C0040000  lfs f0, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C68578: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6857C: C1A30020  lfs f13, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C68580: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C68584: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C68588: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C6858C: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82C68590: 7D89552E  stfsx f12, r9, r10
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82C68594: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C68598: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6859C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C685A0: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82C685A4: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C685A8: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C685AC: 7D2A3838  and r10, r9, r7
	ctx.r[10].u64 = ctx.r[9].u64 & ctx.r[7].u64;
	// 82C685B0: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C685B4: 7D6B442E  lfsx f11, r11, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C685B8: D1650000  stfs f11, 0(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C685BC: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 82C685C0: C1430020  lfs f10, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C685C4: C1230024  lfs f9, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C685C8: ED09502A  fadds f8, f9, f10
	ctx.f[8].f64 = ((ctx.f[9].f64 + ctx.f[10].f64) as f32) as f64;
	// 82C685CC: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C685D0: D1030020  stfs f8, 0x20(r3)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C685D4: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C685D8: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82C685DC: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 82C685E0: 90E3001C  stw r7, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 82C685E4: 4181FF8C  bgt 0x82c68570
	if ctx.cr[0].gt {
	pc = 0x82C68570; continue 'dispatch;
	}
	// 82C685E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C685F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C685F0 size=472
    let mut pc: u32 = 0x82C685F0;
    'dispatch: loop {
        match pc {
            0x82C685F0 => {
    //   block [0x82C685F0..0x82C68644)
	// 82C685F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C685F4: 48040E11  bl 0x82ca9404
	ctx.lr = 0x82C685F8;
	sub_82CA93D0(ctx, base);
	// 82C685F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C685FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C68600: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C68604: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C68608: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82C6860C: 4BFFF66D  bl 0x82c67c78
	ctx.lr = 0x82C68610;
	sub_82C67C78(ctx, base);
	// 82C68610: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C68614: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C68618: 40990168  ble cr6, 0x82c68780
	if !ctx.cr[6].gt {
	pc = 0x82C68780; continue 'dispatch;
	}
	// 82C6861C: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C68620: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C68624: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C68628: 409A009C  bne cr6, 0x82c686c4
	if !ctx.cr[6].eq {
	pc = 0x82C686C4; continue 'dispatch;
	}
	// 82C6862C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82C68630: 40990044  ble cr6, 0x82c68674
	if !ctx.cr[6].gt {
	pc = 0x82C68674; continue 'dispatch;
	}
	// 82C68634: 7F6A5850  subf r27, r10, r11
	ctx.r[27].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C68638: 7F1ED800  cmpw cr6, r30, r27
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82C6863C: 40980008  bge cr6, 0x82c68644
	if !ctx.cr[6].lt {
	pc = 0x82C68644; continue 'dispatch;
	}
	// 82C68640: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	pc = 0x82C68644; continue 'dispatch;
            }
            0x82C68644 => {
    //   block [0x82C68644..0x82C68674)
	// 82C68644: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82C68648: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C6864C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C68650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C68654: 4BFFF8B5  bl 0x82c67f08
	ctx.lr = 0x82C68658;
	sub_82C67F08(ctx, base);
	// 82C68658: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6865C: 7FDBF050  subf r30, r27, r30
	ctx.r[30].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 82C68660: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82C68664: 7F8BE214  add r28, r11, r28
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82C68668: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C6866C: 7D5B5850  subf r10, r27, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 82C68670: 915F002C  stw r10, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	pc = 0x82C68674; continue 'dispatch;
            }
            0x82C68674 => {
    //   block [0x82C68674..0x82C686A0)
	// 82C68674: 837F002C  lwz r27, 0x2c(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C68678: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C6867C: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82C68680: 409A0020  bne cr6, 0x82c686a0
	if !ctx.cr[6].eq {
	pc = 0x82C686A0; continue 'dispatch;
	}
	// 82C68684: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C68688: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6868C: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C68690: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C68694: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 82C68698: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C6869C: 90FF001C  stw r7, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	pc = 0x82C686A0; continue 'dispatch;
            }
            0x82C686A0 => {
    //   block [0x82C686A0..0x82C686AC)
	// 82C686A0: 7F1ED800  cmpw cr6, r30, r27
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82C686A4: 40980008  bge cr6, 0x82c686ac
	if !ctx.cr[6].lt {
	pc = 0x82C686AC; continue 'dispatch;
	}
	// 82C686A8: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	pc = 0x82C686AC; continue 'dispatch;
            }
            0x82C686AC => {
    //   block [0x82C686AC..0x82C686C4)
	// 82C686AC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82C686B0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C686B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C686B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C686BC: 4BFFFA9D  bl 0x82c68158
	ctx.lr = 0x82C686C0;
	sub_82C68158(ctx, base);
	// 82C686C0: 480000A4  b 0x82c68764
	pc = 0x82C68764; continue 'dispatch;
            }
            0x82C686C4 => {
    //   block [0x82C686C4..0x82C686DC)
	// 82C686C4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82C686C8: 40990044  ble cr6, 0x82c6870c
	if !ctx.cr[6].gt {
	pc = 0x82C6870C; continue 'dispatch;
	}
	// 82C686CC: 7F6A5850  subf r27, r10, r11
	ctx.r[27].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C686D0: 7F1ED800  cmpw cr6, r30, r27
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82C686D4: 40980008  bge cr6, 0x82c686dc
	if !ctx.cr[6].lt {
	pc = 0x82C686DC; continue 'dispatch;
	}
	// 82C686D8: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	pc = 0x82C686DC; continue 'dispatch;
            }
            0x82C686DC => {
    //   block [0x82C686DC..0x82C6870C)
	// 82C686DC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82C686E0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C686E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C686E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C686EC: 4BFFF81D  bl 0x82c67f08
	ctx.lr = 0x82C686F0;
	sub_82C67F08(ctx, base);
	// 82C686F0: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C686F4: 7FDBF050  subf r30, r27, r30
	ctx.r[30].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 82C686F8: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82C686FC: 7F8BE214  add r28, r11, r28
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82C68700: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C68704: 7D5B5850  subf r10, r27, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 82C68708: 915F002C  stw r10, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	pc = 0x82C6870C; continue 'dispatch;
            }
            0x82C6870C => {
    //   block [0x82C6870C..0x82C68740)
	// 82C6870C: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C68710: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C68714: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82C68718: 409A0028  bne cr6, 0x82c68740
	if !ctx.cr[6].eq {
	pc = 0x82C68740; continue 'dispatch;
	}
	// 82C6871C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C68720: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C68724: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C68728: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6872C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C68730: 7D074838  and r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 82C68734: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C68738: 90FF001C  stw r7, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 82C6873C: 4BFFF52D  bl 0x82c67c68
	ctx.lr = 0x82C68740;
	sub_82C67C68(ctx, base);
	pc = 0x82C68740; continue 'dispatch;
            }
            0x82C68740 => {
    //   block [0x82C68740..0x82C68750)
	// 82C68740: 837F002C  lwz r27, 0x2c(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C68744: 7F1ED800  cmpw cr6, r30, r27
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82C68748: 40980008  bge cr6, 0x82c68750
	if !ctx.cr[6].lt {
	pc = 0x82C68750; continue 'dispatch;
	}
	// 82C6874C: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	pc = 0x82C68750; continue 'dispatch;
            }
            0x82C68750 => {
    //   block [0x82C68750..0x82C68764)
	// 82C68750: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82C68754: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C68758: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6875C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C68760: 4BFFFC49  bl 0x82c683a8
	ctx.lr = 0x82C68764;
	sub_82C683A8(ctx, base);
	pc = 0x82C68764; continue 'dispatch;
            }
            0x82C68764 => {
    //   block [0x82C68764..0x82C68780)
	// 82C68764: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C68768: 7FDBF050  subf r30, r27, r30
	ctx.r[30].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 82C6876C: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82C68770: 7F8BE214  add r28, r11, r28
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82C68774: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C68778: 7D5B5850  subf r10, r27, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 82C6877C: 915F002C  stw r10, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	pc = 0x82C68780; continue 'dispatch;
            }
            0x82C68780 => {
    //   block [0x82C68780..0x82C687AC)
	// 82C68780: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C68784: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C68788: 409A0024  bne cr6, 0x82c687ac
	if !ctx.cr[6].eq {
	pc = 0x82C687AC; continue 'dispatch;
	}
	// 82C6878C: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C68790: 419A0030  beq cr6, 0x82c687c0
	if ctx.cr[6].eq {
	pc = 0x82C687C0; continue 'dispatch;
	}
	// 82C68794: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C68798: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6879C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C687A0: 4BFFE221  bl 0x82c669c0
	ctx.lr = 0x82C687A4;
	sub_82C669C0(ctx, base);
	// 82C687A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C687A8: 48040CAC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C687AC => {
    //   block [0x82C687AC..0x82C687C0)
	// 82C687AC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C687B0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C687B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C687B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C687BC: 4BFFF575  bl 0x82c67d30
	ctx.lr = 0x82C687C0;
	sub_82C67D30(ctx, base);
	pc = 0x82C687C0; continue 'dispatch;
            }
            0x82C687C0 => {
    //   block [0x82C687C0..0x82C687C8)
	// 82C687C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C687C4: 48040C90  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C687C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C687C8 size=80
    let mut pc: u32 = 0x82C687C8;
    'dispatch: loop {
        match pc {
            0x82C687C8 => {
    //   block [0x82C687C8..0x82C68804)
	// 82C687C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C687CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C687D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C687D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C687D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C687DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C687E0: 419A0024  beq cr6, 0x82c68804
	if ctx.cr[6].eq {
	pc = 0x82C68804; continue 'dispatch;
	}
	// 82C687E4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C687E8: 4BFFB791  bl 0x82c63f78
	ctx.lr = 0x82C687EC;
	sub_82C63F78(ctx, base);
	// 82C687EC: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C687F0: 4BFFB789  bl 0x82c63f78
	ctx.lr = 0x82C687F4;
	sub_82C63F78(ctx, base);
	// 82C687F4: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C687F8: 4BFFB781  bl 0x82c63f78
	ctx.lr = 0x82C687FC;
	sub_82C63F78(ctx, base);
	// 82C687FC: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C68800: 4BFFB779  bl 0x82c63f78
	ctx.lr = 0x82C68804;
	sub_82C63F78(ctx, base);
	pc = 0x82C68804; continue 'dispatch;
            }
            0x82C68804 => {
    //   block [0x82C68804..0x82C68818)
	// 82C68804: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C68808: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6880C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C68810: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C68814: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C68818 size=52
    let mut pc: u32 = 0x82C68818;
    'dispatch: loop {
        match pc {
            0x82C68818 => {
    //   block [0x82C68818..0x82C6884C)
	// 82C68818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6881C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C68820: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C68824: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C68828: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6882C: 4BFFFF9D  bl 0x82c687c8
	ctx.lr = 0x82C68830;
	sub_82C687C8(ctx, base);
	// 82C68830: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C68834: 4BFFB745  bl 0x82c63f78
	ctx.lr = 0x82C68838;
	sub_82C63F78(ctx, base);
	// 82C68838: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6883C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C68840: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C68844: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C68848: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C68850 size=68
    let mut pc: u32 = 0x82C68850;
    'dispatch: loop {
        match pc {
            0x82C68850 => {
    //   block [0x82C68850..0x82C68870)
	// 82C68850: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C68854: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C68858: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82C6885C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C68860: 4198002C  blt cr6, 0x82c6888c
	if ctx.cr[6].lt {
	pc = 0x82C6888C; continue 'dispatch;
	}
	// 82C68864: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C68868: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82C6886C: C0080C18  lfs f0, 0xc18(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82C68870; continue 'dispatch;
            }
            0x82C68870 => {
    //   block [0x82C68870..0x82C6888C)
	// 82C68870: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C68874: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C68878: 7C085D2E  stfsx f0, r8, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82C6887C: 80E30024  lwz r7, 0x24(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C68880: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C68884: 7F0A3800  cmpw cr6, r10, r7
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82C68888: 4099FFE8  ble cr6, 0x82c68870
	if !ctx.cr[6].gt {
	pc = 0x82C68870; continue 'dispatch;
	}
	pc = 0x82C6888C; continue 'dispatch;
            }
            0x82C6888C => {
    //   block [0x82C6888C..0x82C68894)
	// 82C6888C: 91230028  stw r9, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 82C68890: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C68898 size=56
    let mut pc: u32 = 0x82C68898;
    'dispatch: loop {
        match pc {
            0x82C68898 => {
    //   block [0x82C68898..0x82C688AC)
	// 82C68898: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C6889C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C688A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C688A4: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 82C688A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82C688AC; continue 'dispatch;
            }
            0x82C688AC => {
    //   block [0x82C688AC..0x82C688D0)
	// 82C688AC: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C688B0: 7C0B242E  lfsx f0, r11, r4
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C688B4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C688B8: 7C095D2E  stfsx f0, r9, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82C688BC: 81030024  lwz r8, 0x24(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C688C0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C688C4: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82C688C8: 4099FFE4  ble cr6, 0x82c688ac
	if !ctx.cr[6].gt {
	pc = 0x82C688AC; continue 'dispatch;
	}
	// 82C688CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C688D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C688D0 size=32
    let mut pc: u32 = 0x82C688D0;
    'dispatch: loop {
        match pc {
            0x82C688D0 => {
    //   block [0x82C688D0..0x82C688F0)
	// 82C688D0: 80630020  lwz r3, 0x20(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C688D4: 7F041800  cmpw cr6, r4, r3
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[3].s32, &mut ctx.xer);
	// 82C688D8: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
	// 82C688DC: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C688E0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C688E4: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 82C688E8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C688EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C688F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C688F0 size=52
    let mut pc: u32 = 0x82C688F0;
    'dispatch: loop {
        match pc {
            0x82C688F0 => {
    //   block [0x82C688F0..0x82C68924)
	// 82C688F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C688F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C688F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C688FC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82C68900: 4BFFFFD1  bl 0x82c688d0
	ctx.lr = 0x82C68904;
	sub_82C688D0(ctx, base);
	// 82C68904: 906A0024  stw r3, 0x24(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 82C68908: 906A001C  stw r3, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 82C6890C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82C68910: 4BFFFF41  bl 0x82c68850
	ctx.lr = 0x82C68914;
	sub_82C68850(ctx, base);
	// 82C68914: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C68918: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6891C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C68920: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C68928 size=292
    let mut pc: u32 = 0x82C68928;
    'dispatch: loop {
        match pc {
            0x82C68928 => {
    //   block [0x82C68928..0x82C68954)
	// 82C68928: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6892C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C68930: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C68934: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C68938: 40990114  ble cr6, 0x82c68a4c
	if !ctx.cr[6].gt {
		sub_82C68A4C(ctx, base);
		return;
	}
	// 82C6893C: 80E30024  lwz r7, 0x24(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C68940: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C68944: 7F0A3800  cmpw cr6, r10, r7
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82C68948: 40980050  bge cr6, 0x82c68998
	if !ctx.cr[6].lt {
	pc = 0x82C68998; continue 'dispatch;
	}
	// 82C6894C: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C68950: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	pc = 0x82C68954; continue 'dispatch;
            }
            0x82C68954 => {
    //   block [0x82C68954..0x82C68998)
	// 82C68954: 81030010  lwz r8, 0x10(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C68958: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C6895C: 80C30014  lwz r6, 0x14(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C68960: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 82C68964: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82C68968: 80A3000C  lwz r5, 0xc(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6896C: 7DA65C2E  lfsx f13, r6, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C68970: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 82C68974: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C68978: 7D654C2E  lfsx f11, r5, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C6897C: ED4D602A  fadds f10, f13, f12
	ctx.f[10].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82C68980: D1480000  stfs f10, 0(r8)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C68984: 80830024  lwz r4, 0x24(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C68988: EC0B033A  fmadds f0, f11, f12, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C6898C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82C68990: 7F0A2000  cmpw cr6, r10, r4
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82C68994: 4198FFC0  blt cr6, 0x82c68954
	if ctx.cr[6].lt {
	pc = 0x82C68954; continue 'dispatch;
	}
	pc = 0x82C68998; continue 'dispatch;
            }
            0x82C68998 => {
    //   block [0x82C68998..0x82C689B0)
	// 82C68998: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C6899C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82C689A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C689A4: 4099004C  ble cr6, 0x82c689f0
	if !ctx.cr[6].gt {
	pc = 0x82C689F0; continue 'dispatch;
	}
	// 82C689A8: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C689AC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82C689B0; continue 'dispatch;
            }
            0x82C689B0 => {
    //   block [0x82C689B0..0x82C689F0)
	// 82C689B0: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C689B4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82C689B8: 80E30014  lwz r7, 0x14(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C689BC: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82C689C0: 80C3000C  lwz r6, 0xc(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C689C4: 7DA75C2E  lfsx f13, r7, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C689C8: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 82C689CC: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C689D0: 7D66542E  lfsx f11, r6, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C689D4: ED4D602A  fadds f10, f13, f12
	ctx.f[10].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82C689D8: D1490000  stfs f10, 0(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C689DC: 80A30028  lwz r5, 0x28(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C689E0: EC0B033A  fmadds f0, f11, f12, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C689E4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82C689E8: 7F082800  cmpw cr6, r8, r5
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82C689EC: 4198FFC4  blt cr6, 0x82c689b0
	if ctx.cr[6].lt {
	pc = 0x82C689B0; continue 'dispatch;
	}
	pc = 0x82C689F0; continue 'dispatch;
            }
            0x82C689F0 => {
    //   block [0x82C689F0..0x82C68A20)
	// 82C689F0: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C689F4: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C689F8: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C689FC: 7C29552E  stfsx f1, r9, r10
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82C68A00: 81030024  lwz r8, 0x24(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C68A04: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C68A08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C68A0C: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82C68A10: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82C68A14: 4198000C  blt cr6, 0x82c68a20
	if ctx.cr[6].lt {
	pc = 0x82C68A20; continue 'dispatch;
	}
	// 82C68A18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C68A1C: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	pc = 0x82C68A20; continue 'dispatch;
            }
            0x82C68A20 => {
    //   block [0x82C68A20..0x82C68A4C)
	// 82C68A20: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C68A24: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C68A28: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C68A2C: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C68A30: EC2D007A  fmadds f1, f13, f1, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C68A34: ED6C682A  fadds f11, f12, f13
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 82C68A38: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C68A3C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C68A40: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 82C68A44: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C68A48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68A4C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C68A4C size=196
    let mut pc: u32 = 0x82C68A4C;
    'dispatch: loop {
        match pc {
            0x82C68A4C => {
    //   block [0x82C68A4C..0x82C68A80)
	// 82C68A4C: 81430024  lwz r10, 0x24(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C68A50: 80A30028  lwz r5, 0x28(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C68A54: 7F055000  cmpw cr6, r5, r10
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82C68A58: 40980044  bge cr6, 0x82c68a9c
	if !ctx.cr[6].lt {
	pc = 0x82C68A9C; continue 'dispatch;
	}
	// 82C68A5C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C68A60: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C68A64: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C68A68: 80E3000C  lwz r7, 0xc(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C68A6C: 54A6103A  slwi r6, r5, 2
	ctx.r[6].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82C68A70: 7D655850  subf r11, r5, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 82C68A74: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82C68A78: 7D063A14  add r8, r6, r7
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82C68A7C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	pc = 0x82C68A80; continue 'dispatch;
            }
            0x82C68A80 => {
    //   block [0x82C68A80..0x82C68A9C)
	// 82C68A80: C1A90000  lfs f13, 0(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C68A84: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C68A88: C1880000  lfs f12, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C68A8C: 3929FFFC  addi r9, r9, -4
	ctx.r[9].s64 = ctx.r[9].s64 + -4;
	// 82C68A90: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C68A94: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 82C68A98: 4082FFE8  bne 0x82c68a80
	if !ctx.cr[0].eq {
	pc = 0x82C68A80; continue 'dispatch;
	}
	pc = 0x82C68A9C; continue 'dispatch;
            }
            0x82C68A9C => {
    //   block [0x82C68A9C..0x82C68AB8)
	// 82C68A9C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82C68AA0: 40990034  ble cr6, 0x82c68ad4
	if !ctx.cr[6].gt {
	pc = 0x82C68AD4; continue 'dispatch;
	}
	// 82C68AA4: 81030010  lwz r8, 0x10(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C68AA8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C68AAC: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C68AB0: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C68AB4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	pc = 0x82C68AB8; continue 'dispatch;
            }
            0x82C68AB8 => {
    //   block [0x82C68AB8..0x82C68AD4)
	// 82C68AB8: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C68ABC: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C68AC0: C1890000  lfs f12, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C68AC4: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 82C68AC8: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C68ACC: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82C68AD0: 4082FFE8  bne 0x82c68ab8
	if !ctx.cr[0].eq {
	pc = 0x82C68AB8; continue 'dispatch;
	}
	pc = 0x82C68AD4; continue 'dispatch;
            }
            0x82C68AD4 => {
    //   block [0x82C68AD4..0x82C68B00)
	// 82C68AD4: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C68AD8: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C68ADC: 7C2A5D2E  stfsx f1, r10, r11
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82C68AE0: 81230024  lwz r9, 0x24(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C68AE4: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C68AE8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C68AEC: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82C68AF0: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82C68AF4: 4198000C  blt cr6, 0x82c68b00
	if ctx.cr[6].lt {
	pc = 0x82C68B00; continue 'dispatch;
	}
	// 82C68AF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C68AFC: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	pc = 0x82C68B00; continue 'dispatch;
            }
            0x82C68B00 => {
    //   block [0x82C68B00..0x82C68B10)
	// 82C68B00: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C68B04: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C68B08: EC2D007A  fmadds f1, f13, f1, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64);
	// 82C68B0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C68B10 size=144
    let mut pc: u32 = 0x82C68B10;
    'dispatch: loop {
        match pc {
            0x82C68B10 => {
    //   block [0x82C68B10..0x82C68B98)
	// 82C68B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C68B14: 480408F5  bl 0x82ca9408
	ctx.lr = 0x82C68B18;
	sub_82CA93D0(ctx, base);
	// 82C68B18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C68B1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C68B20: 3860002C  li r3, 0x2c
	ctx.r[3].s64 = 44;
	// 82C68B24: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C68B28: 4BFFB441  bl 0x82c63f68
	ctx.lr = 0x82C68B2C;
	sub_82C63F68(ctx, base);
	// 82C68B2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C68B30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C68B34: 395E0001  addi r10, r30, 1
	ctx.r[10].s64 = ctx.r[30].s64 + 1;
	// 82C68B38: 555C103A  slwi r28, r10, 2
	ctx.r[28].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82C68B3C: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82C68B40: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82C68B44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C68B48: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82C68B4C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C68B50: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C68B54: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82C68B58: 4BFFB411  bl 0x82c63f68
	ctx.lr = 0x82C68B5C;
	sub_82C63F68(ctx, base);
	// 82C68B5C: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82C68B60: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C68B64: 4BFFB405  bl 0x82c63f68
	ctx.lr = 0x82C68B68;
	sub_82C63F68(ctx, base);
	// 82C68B68: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 82C68B6C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C68B70: 4BFFB3F9  bl 0x82c63f68
	ctx.lr = 0x82C68B74;
	sub_82C63F68(ctx, base);
	// 82C68B74: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82C68B78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C68B7C: 4BFFB3ED  bl 0x82c63f68
	ctx.lr = 0x82C68B80;
	sub_82C63F68(ctx, base);
	// 82C68B80: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82C68B84: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C68B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C68B8C: 419A000C  beq cr6, 0x82c68b98
	if ctx.cr[6].eq {
	pc = 0x82C68B98; continue 'dispatch;
	}
	// 82C68B90: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C68B94: 4BFFFD05  bl 0x82c68898
	ctx.lr = 0x82C68B98;
	sub_82C68898(ctx, base);
	pc = 0x82C68B98; continue 'dispatch;
            }
            0x82C68B98 => {
    //   block [0x82C68B98..0x82C68BA0)
	// 82C68B98: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C68B9C: 480408BC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C68BA0 size=12
    let mut pc: u32 = 0x82C68BA0;
    'dispatch: loop {
        match pc {
            0x82C68BA0 => {
    //   block [0x82C68BA0..0x82C68BAC)
	// 82C68BA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C68BA4: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C68BA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C68BB0 size=12
    let mut pc: u32 = 0x82C68BB0;
    'dispatch: loop {
        match pc {
            0x82C68BB0 => {
    //   block [0x82C68BB0..0x82C68BBC)
	// 82C68BB0: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82C68BB4: 90A30004  stw r5, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82C68BB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C68BC0 size=32
    let mut pc: u32 = 0x82C68BC0;
    'dispatch: loop {
        match pc {
            0x82C68BC0 => {
    //   block [0x82C68BC0..0x82C68BE0)
	// 82C68BC0: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82C68BC4: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C68BC8: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C68BCC: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C68BD0: 7D6741D6  mullw r11, r7, r8
	ctx.r[11].s32 = ((ctx.r[7].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82C68BD4: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C68BD8: 90690008  stw r3, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82C68BDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C68BE0 size=72
    let mut pc: u32 = 0x82C68BE0;
    'dispatch: loop {
        match pc {
            0x82C68BE0 => {
    //   block [0x82C68BE0..0x82C68C28)
	// 82C68BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C68BE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C68BE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C68BEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C68BF0: 3880000C  li r4, 0xc
	ctx.r[4].s64 = 12;
	// 82C68BF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C68BF8: 4BFFB341  bl 0x82c63f38
	ctx.lr = 0x82C68BFC;
	sub_82C63F38(ctx, base);
	// 82C68BFC: 3CA0A625  lis r5, -0x59db
	ctx.r[5].s64 = -1507524608;
	// 82C68C00: 3C806F31  lis r4, 0x6f31
	ctx.r[4].s64 = 1865482240;
	// 82C68C04: 60A59467  ori r5, r5, 0x9467
	ctx.r[5].u64 = ctx.r[5].u64 | 37991;
	// 82C68C08: 6084BD35  ori r4, r4, 0xbd35
	ctx.r[4].u64 = ctx.r[4].u64 | 48437;
	// 82C68C0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C68C10: 4BFFFFA1  bl 0x82c68bb0
	ctx.lr = 0x82C68C14;
	sub_82C68BB0(ctx, base);
	// 82C68C14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C68C18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C68C1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C68C20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C68C24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C68C28 size=80
    let mut pc: u32 = 0x82C68C28;
    'dispatch: loop {
        match pc {
            0x82C68C28 => {
    //   block [0x82C68C28..0x82C68C60)
	// 82C68C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C68C2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C68C30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C68C34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C68C38: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C68C3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C68C40: 806B597C  lwz r3, 0x597c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22908 as u32) ) } as u64;
	// 82C68C44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C68C48: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C68C4C: 419A0014  beq cr6, 0x82c68c60
	if ctx.cr[6].eq {
	pc = 0x82C68C60; continue 'dispatch;
	}
	// 82C68C50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C68C54: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C68C58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C68C5C: 4E800421  bctrl
	ctx.lr = 0x82C68C60;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C68C60 => {
    //   block [0x82C68C60..0x82C68C78)
	// 82C68C60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C68C64: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C68C68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C68C6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C68C70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C68C74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C68C78 size=16
    let mut pc: u32 = 0x82C68C78;
    'dispatch: loop {
        match pc {
            0x82C68C78 => {
    //   block [0x82C68C78..0x82C68C88)
	// 82C68C78: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C68C7C: 816B597C  lwz r11, 0x597c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22908 as u32) ) } as u64;
	// 82C68C80: 806B0064  lwz r3, 0x64(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C68C84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C68C88 size=68
    let mut pc: u32 = 0x82C68C88;
    'dispatch: loop {
        match pc {
            0x82C68C88 => {
    //   block [0x82C68C88..0x82C68CCC)
	// 82C68C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C68C8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C68C90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C68C94: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C68C98: 816B597C  lwz r11, 0x597c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22908 as u32) ) } as u64;
	// 82C68C9C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82C68CA0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C68CA4: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82C68CA8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C68CAC: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C68CB0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C68CB4: 4E800421  bctrl
	ctx.lr = 0x82C68CB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C68CB8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C68CBC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C68CC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C68CC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C68CC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68CD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C68CD0 size=180
    let mut pc: u32 = 0x82C68CD0;
    'dispatch: loop {
        match pc {
            0x82C68CD0 => {
    //   block [0x82C68CD0..0x82C68D0C)
	// 82C68CD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C68CD4: 48040731  bl 0x82ca9404
	ctx.lr = 0x82C68CD8;
	sub_82CA93D0(ctx, base);
	// 82C68CD8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C68CDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C68CE0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C68CE4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82C68CE8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82C68CEC: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 82C68CF0: 2F05FFFF  cmpwi cr6, r5, -1
	ctx.cr[6].compare_i32(ctx.r[5].s32, -1, &mut ctx.xer);
	// 82C68CF4: 409A0018  bne cr6, 0x82c68d0c
	if !ctx.cr[6].eq {
	pc = 0x82C68D0C; continue 'dispatch;
	}
	// 82C68CF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C68CFC: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C68D00: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C68D04: 4E800421  bctrl
	ctx.lr = 0x82C68D08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C68D08: 5465003E  slwi r5, r3, 0
	ctx.r[5].u32 = ctx.r[3].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
            }
            0x82C68D0C => {
    //   block [0x82C68D0C..0x82C68D48)
	// 82C68D0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C68D10: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82C68D14: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C68D18: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82C68D1C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82C68D20: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82C68D24: 7FA507B4  extsw r5, r29
	ctx.r[5].s64 = ctx.r[29].s32 as i64;
	// 82C68D28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C68D2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C68D30: 4BEEB039  bl 0x82b53d68
	ctx.lr = 0x82C68D34;
	sub_82B53D68(ctx, base);
	// 82C68D34: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C68D38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C68D3C: 409A000C  bne cr6, 0x82c68d48
	if !ctx.cr[6].eq {
	pc = 0x82C68D48; continue 'dispatch;
	}
	// 82C68D40: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C68D44: 48040710  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C68D48 => {
    //   block [0x82C68D48..0x82C68D78)
	// 82C68D48: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C68D4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C68D50: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C68D54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C68D58: 4E800421  bctrl
	ctx.lr = 0x82C68D5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C68D5C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C68D60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C68D64: 419A0014  beq cr6, 0x82c68d78
	if ctx.cr[6].eq {
	pc = 0x82C68D78; continue 'dispatch;
	}
	// 82C68D68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C68D6C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C68D70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C68D74: 4E800421  bctrl
	ctx.lr = 0x82C68D78;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C68D78 => {
    //   block [0x82C68D78..0x82C68D84)
	// 82C68D78: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C68D7C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C68D80: 480406D4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C68D88 size=200
    let mut pc: u32 = 0x82C68D88;
    'dispatch: loop {
        match pc {
            0x82C68D88 => {
    //   block [0x82C68D88..0x82C68DEC)
	// 82C68D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C68D8C: 48040681  bl 0x82ca940c
	ctx.lr = 0x82C68D90;
	sub_82CA93D0(ctx, base);
	// 82C68D90: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C68D94: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C68D98: 9061007C  stw r3, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 82C68D9C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C68DA0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C68DA4: 3BC00007  li r30, 7
	ctx.r[30].s64 = 7;
	// 82C68DA8: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82C68DAC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82C68DB0: 808B597C  lwz r4, 0x597c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22908 as u32) ) } as u64;
	// 82C68DB4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82C68DB8: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 82C68DBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C68DC0: B3E10064  sth r31, 0x64(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u16 ) };
	// 82C68DC4: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82C68DC8: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C68DCC: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C68DD0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C68DD4: 4E800421  bctrl
	ctx.lr = 0x82C68DD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C68DD8: 81010078  lwz r8, 0x78(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C68DDC: 2B080008  cmplwi cr6, r8, 8
	ctx.cr[6].compare_u32(ctx.r[8].u32, 8 as u32, &mut ctx.xer);
	// 82C68DE0: 4198000C  blt cr6, 0x82c68dec
	if ctx.cr[6].lt {
	pc = 0x82C68DEC; continue 'dispatch;
	}
	// 82C68DE4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C68DE8: 4BBDC9C9  bl 0x828457b0
	ctx.lr = 0x82C68DEC;
	sub_828457B0(ctx, base);
            }
            0x82C68DEC => {
    //   block [0x82C68DEC..0x82C68E14)
	// 82C68DEC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C68DF0: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 82C68DF4: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82C68DF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C68DFC: B3E10064  sth r31, 0x64(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u16 ) };
	// 82C68E00: 409A0014  bne cr6, 0x82c68e14
	if !ctx.cr[6].eq {
	pc = 0x82C68E14; continue 'dispatch;
	}
	// 82C68E04: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C68E08: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C68E0C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C68E10: 4804064C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C68E14 => {
    //   block [0x82C68E14..0x82C68E44)
	// 82C68E14: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C68E18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C68E1C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C68E20: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C68E24: 4E800421  bctrl
	ctx.lr = 0x82C68E28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C68E28: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C68E2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C68E30: 419A0014  beq cr6, 0x82c68e44
	if ctx.cr[6].eq {
	pc = 0x82C68E44; continue 'dispatch;
	}
	// 82C68E34: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C68E38: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C68E3C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C68E40: 4E800421  bctrl
	ctx.lr = 0x82C68E44;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C68E44 => {
    //   block [0x82C68E44..0x82C68E50)
	// 82C68E44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C68E48: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C68E4C: 48040610  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C68E50 size=224
    let mut pc: u32 = 0x82C68E50;
    'dispatch: loop {
        match pc {
            0x82C68E50 => {
    //   block [0x82C68E50..0x82C68EC4)
	// 82C68E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C68E54: 480405A9  bl 0x82ca93fc
	ctx.lr = 0x82C68E58;
	sub_82CA93D0(ctx, base);
	// 82C68E58: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C68E5C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C68E60: 9061007C  stw r3, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 82C68E64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C68E68: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C68E6C: 3B200007  li r25, 7
	ctx.r[25].s64 = 7;
	// 82C68E70: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82C68E74: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C68E78: 808B597C  lwz r4, 0x597c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22908 as u32) ) } as u64;
	// 82C68E7C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82C68E80: 93210078  stw r25, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[25].u32 ) };
	// 82C68E84: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82C68E88: B3E10064  sth r31, 0x64(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u16 ) };
	// 82C68E8C: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82C68E90: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82C68E94: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82C68E98: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82C68E9C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C68EA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C68EA4: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C68EA8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C68EAC: 4E800421  bctrl
	ctx.lr = 0x82C68EB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C68EB0: 81010078  lwz r8, 0x78(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C68EB4: 2B080008  cmplwi cr6, r8, 8
	ctx.cr[6].compare_u32(ctx.r[8].u32, 8 as u32, &mut ctx.xer);
	// 82C68EB8: 4198000C  blt cr6, 0x82c68ec4
	if ctx.cr[6].lt {
	pc = 0x82C68EC4; continue 'dispatch;
	}
	// 82C68EBC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C68EC0: 4BBDC8F1  bl 0x828457b0
	ctx.lr = 0x82C68EC4;
	sub_828457B0(ctx, base);
            }
            0x82C68EC4 => {
    //   block [0x82C68EC4..0x82C68EE8)
	// 82C68EC4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C68EC8: 93210078  stw r25, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[25].u32 ) };
	// 82C68ECC: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82C68ED0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C68ED4: B3E10064  sth r31, 0x64(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u16 ) };
	// 82C68ED8: 409A0010  bne cr6, 0x82c68ee8
	if !ctx.cr[6].eq {
	pc = 0x82C68EE8; continue 'dispatch;
	}
	// 82C68EDC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C68EE0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82C68EE4: 48040568  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C68EE8 => {
    //   block [0x82C68EE8..0x82C68F24)
	// 82C68EE8: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82C68EEC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82C68EF0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C68EF4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C68EF8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C68EFC: 4BFFFDD5  bl 0x82c68cd0
	ctx.lr = 0x82C68F00;
	sub_82C68CD0(ctx, base);
	// 82C68F00: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C68F04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C68F08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C68F0C: 419A0018  beq cr6, 0x82c68f24
	if ctx.cr[6].eq {
	pc = 0x82C68F24; continue 'dispatch;
	}
	// 82C68F10: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C68F14: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C68F18: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C68F1C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C68F20: 4E800421  bctrl
	ctx.lr = 0x82C68F24;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C68F24 => {
    //   block [0x82C68F24..0x82C68F30)
	// 82C68F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C68F28: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82C68F2C: 48040520  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C68F30 size=120
    let mut pc: u32 = 0x82C68F30;
    'dispatch: loop {
        match pc {
            0x82C68F30 => {
    //   block [0x82C68F30..0x82C68F90)
	// 82C68F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C68F34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C68F38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C68F3C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C68F40: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C68F44: 9061006C  stw r3, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[3].u32 ) };
	// 82C68F48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C68F4C: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 82C68F50: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82C68F54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C68F58: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 82C68F5C: 806A597C  lwz r3, 0x597c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(22908 as u32) ) } as u64;
	// 82C68F60: B1610054  sth r11, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u16 ) };
	// 82C68F64: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82C68F68: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C68F6C: 80E8002C  lwz r7, 0x2c(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C68F70: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82C68F74: 4E800421  bctrl
	ctx.lr = 0x82C68F78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C68F78: 80C10068  lwz r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C68F7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C68F80: 2B060008  cmplwi cr6, r6, 8
	ctx.cr[6].compare_u32(ctx.r[6].u32, 8 as u32, &mut ctx.xer);
	// 82C68F84: 4198000C  blt cr6, 0x82c68f90
	if ctx.cr[6].lt {
	pc = 0x82C68F90; continue 'dispatch;
	}
	// 82C68F88: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C68F8C: 4BBDC825  bl 0x828457b0
	ctx.lr = 0x82C68F90;
	sub_828457B0(ctx, base);
            }
            0x82C68F90 => {
    //   block [0x82C68F90..0x82C68FA8)
	// 82C68F90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C68F94: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C68F98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C68F9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C68FA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C68FA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C68FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C68FA8 size=312
    let mut pc: u32 = 0x82C68FA8;
    'dispatch: loop {
        match pc {
            0x82C68FA8 => {
    //   block [0x82C68FA8..0x82C69010)
	// 82C68FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C68FAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C68FB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C68FB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C68FB8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C68FBC: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C68FC0: 9061007C  stw r3, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 82C68FC4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C68FC8: 3BC00007  li r30, 7
	ctx.r[30].s64 = 7;
	// 82C68FCC: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82C68FD0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82C68FD4: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 82C68FD8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82C68FDC: 808B597C  lwz r4, 0x597c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22908 as u32) ) } as u64;
	// 82C68FE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C68FE4: B3E10064  sth r31, 0x64(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u16 ) };
	// 82C68FE8: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82C68FEC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C68FF0: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C68FF4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C68FF8: 4E800421  bctrl
	ctx.lr = 0x82C68FFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C68FFC: 81010078  lwz r8, 0x78(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C69000: 2B080008  cmplwi cr6, r8, 8
	ctx.cr[6].compare_u32(ctx.r[8].u32, 8 as u32, &mut ctx.xer);
	// 82C69004: 4198000C  blt cr6, 0x82c69010
	if ctx.cr[6].lt {
	pc = 0x82C69010; continue 'dispatch;
	}
	// 82C69008: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C6900C: 4BBDC7A5  bl 0x828457b0
	ctx.lr = 0x82C69010;
	sub_828457B0(ctx, base);
            }
            0x82C69010 => {
    //   block [0x82C69010..0x82C69030)
	// 82C69010: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C69014: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 82C69018: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82C6901C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C69020: B3E10064  sth r31, 0x64(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u16 ) };
	// 82C69024: 409A000C  bne cr6, 0x82c69030
	if !ctx.cr[6].eq {
	pc = 0x82C69030; continue 'dispatch;
	}
	// 82C69028: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C6902C: 4800009C  b 0x82c690c8
	pc = 0x82C690C8; continue 'dispatch;
            }
            0x82C69030 => {
    //   block [0x82C69030..0x82C6908C)
	// 82C69030: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C69034: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82C69038: 4BEE9B81  bl 0x82b52bb8
	ctx.lr = 0x82C6903C;
	sub_82B52BB8(ctx, base);
	// 82C6903C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69040: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82C69044: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C69048: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C6904C: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C69050: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69054: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C69058: 4E800421  bctrl
	ctx.lr = 0x82C6905C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6905C: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69060: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C69064: 7CE8F850  subf r7, r8, r31
	ctx.r[7].s64 = ctx.r[31].s64 - ctx.r[8].s64;
	// 82C69068: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6906C: 7CE60034  cntlzw r6, r7
	ctx.r[6].u64 = if ctx.r[7].u32 == 0 { 32 } else { ctx.r[7].u32.leading_zeros() as u64 };
	// 82C69070: 54DFDFFE  rlwinm r31, r6, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[6].u32 as u64 & 0x0000001Fu64;
	// 82C69074: 419A0018  beq cr6, 0x82c6908c
	if ctx.cr[6].eq {
	pc = 0x82C6908C; continue 'dispatch;
	}
	// 82C69078: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6907C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C69080: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69084: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C69088: 4E800421  bctrl
	ctx.lr = 0x82C6908C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6908C => {
    //   block [0x82C6908C..0x82C690A8)
	// 82C6908C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C69090: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C69094: 419A0014  beq cr6, 0x82c690a8
	if ctx.cr[6].eq {
	pc = 0x82C690A8; continue 'dispatch;
	}
	// 82C69098: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6909C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C690A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C690A4: 4E800421  bctrl
	ctx.lr = 0x82C690A8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C690A8 => {
    //   block [0x82C690A8..0x82C690C4)
	// 82C690A8: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C690AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C690B0: 419A0014  beq cr6, 0x82c690c4
	if ctx.cr[6].eq {
	pc = 0x82C690C4; continue 'dispatch;
	}
	// 82C690B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C690B8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C690BC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C690C0: 4E800421  bctrl
	ctx.lr = 0x82C690C4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C690C4 => {
    //   block [0x82C690C4..0x82C690C8)
	// 82C690C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C690C8; continue 'dispatch;
            }
            0x82C690C8 => {
    //   block [0x82C690C8..0x82C690E0)
	// 82C690C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C690CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C690D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C690D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C690D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C690DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C690E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C690E0 size=112
    let mut pc: u32 = 0x82C690E0;
    'dispatch: loop {
        match pc {
            0x82C690E0 => {
    //   block [0x82C690E0..0x82C69104)
	// 82C690E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C690E4: 48040329  bl 0x82ca940c
	ctx.lr = 0x82C690E8;
	sub_82CA93D0(ctx, base);
	// 82C690E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C690EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C690F0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C690F4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82C690F8: 897E0019  lbz r11, 0x19(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C690FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C69100: 409A0048  bne cr6, 0x82c69148
	if !ctx.cr[6].eq {
	pc = 0x82C69148; continue 'dispatch;
	}
	pc = 0x82C69104; continue 'dispatch;
            }
            0x82C69104 => {
    //   block [0x82C69104..0x82C69130)
	// 82C69104: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C69108: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6910C: 4BFFFFD5  bl 0x82c690e0
	ctx.lr = 0x82C69110;
	sub_82C690E0(ctx, base);
	// 82C69110: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C69114: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C69118: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6911C: 419A0014  beq cr6, 0x82c69130
	if ctx.cr[6].eq {
	pc = 0x82C69130; continue 'dispatch;
	}
	// 82C69120: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69124: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69128: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6912C: 4E800421  bctrl
	ctx.lr = 0x82C69130;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C69130 => {
    //   block [0x82C69130..0x82C69148)
	// 82C69130: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C69134: 4BBDC67D  bl 0x828457b0
	ctx.lr = 0x82C69138;
	sub_828457B0(ctx, base);
	// 82C69138: 897F0019  lbz r11, 0x19(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C6913C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82C69140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C69144: 419AFFC0  beq cr6, 0x82c69104
	if ctx.cr[6].eq {
	pc = 0x82C69104; continue 'dispatch;
	}
	pc = 0x82C69148; continue 'dispatch;
            }
            0x82C69148 => {
    //   block [0x82C69148..0x82C69150)
	// 82C69148: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6914C: 48040310  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C69150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C69150 size=84
    let mut pc: u32 = 0x82C69150;
    'dispatch: loop {
        match pc {
            0x82C69150 => {
    //   block [0x82C69150..0x82C691A4)
	// 82C69150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C69154: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C69158: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6915C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C69160: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C69164: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69168: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6916C: 4BFFFF75  bl 0x82c690e0
	ctx.lr = 0x82C69170;
	sub_82C690E0(ctx, base);
	// 82C69170: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69174: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C69178: 91290004  stw r9, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C6917C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69180: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C69184: 91080000  stw r8, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C69188: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6918C: 90E70008  stw r7, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82C69190: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C69194: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C69198: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6919C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C691A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C691A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C691A8 size=1096
    let mut pc: u32 = 0x82C691A8;
    'dispatch: loop {
        match pc {
            0x82C691A8 => {
    //   block [0x82C691A8..0x82C6921C)
	// 82C691A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C691AC: 48040251  bl 0x82ca93fc
	ctx.lr = 0x82C691B0;
	sub_82CA93D0(ctx, base);
	// 82C691B0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C691B4: F8A10100  std r5, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[5].u64 ) };
	// 82C691B8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82C691BC: 83E10104  lwz r31, 0x104(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82C691C0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C691C4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82C691C8: 897F0019  lbz r11, 0x19(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C691CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C691D0: 419A005C  beq cr6, 0x82c6922c
	if ctx.cr[6].eq {
	pc = 0x82C6922C; continue 'dispatch;
	}
	// 82C691D4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82C691D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C691DC: 388B16C0  addi r4, r11, 0x16c0
	ctx.r[4].s64 = ctx.r[11].s64 + 5824;
	// 82C691E0: 4B688D61  bl 0x822f1f40
	ctx.lr = 0x82C691E4;
	sub_822F1F40(ctx, base);
	// 82C691E4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C691E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C691EC: 4B688B85  bl 0x822f1d70
	ctx.lr = 0x82C691F0;
	sub_822F1D70(ctx, base);
	// 82C691F0: 4B688C31  bl 0x822f1e20
	ctx.lr = 0x82C691F4;
	sub_822F1E20(ctx, base);
	// 82C691F4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82C691F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C691FC: 392A1720  addi r9, r10, 0x1720
	ctx.r[9].s64 = ctx.r[10].s64 + 5920;
	// 82C69200: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 82C69204: 4BA125DD  bl 0x8267b7e0
	ctx.lr = 0x82C69208;
	sub_8267B7E0(ctx, base);
	// 82C69208: 81010068  lwz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C6920C: 2B080010  cmplwi cr6, r8, 0x10
	ctx.cr[6].compare_u32(ctx.r[8].u32, 16 as u32, &mut ctx.xer);
	// 82C69210: 4198000C  blt cr6, 0x82c6921c
	if ctx.cr[6].lt {
	pc = 0x82C6921C; continue 'dispatch;
	}
	// 82C69214: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C69218: 4BBDC599  bl 0x828457b0
	ctx.lr = 0x82C6921C;
	sub_828457B0(ctx, base);
	pc = 0x82C6921C; continue 'dispatch;
            }
            0x82C6921C => {
    //   block [0x82C6921C..0x82C6922C)
	// 82C6921C: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 82C69220: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 82C69224: 9B610054  stb r27, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u8 ) };
	// 82C69228: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	pc = 0x82C6922C; continue 'dispatch;
            }
            0x82C6922C => {
    //   block [0x82C6922C..0x82C69250)
	// 82C6922C: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82C69230: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 82C69234: 4B7D3BBD  bl 0x8243cdf0
	ctx.lr = 0x82C69238;
	sub_8243CDF0(ctx, base);
	// 82C69238: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6923C: 896A0019  lbz r11, 0x19(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C69240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C69244: 419A000C  beq cr6, 0x82c69250
	if ctx.cr[6].eq {
	pc = 0x82C69250; continue 'dispatch;
	}
	// 82C69248: 83BA0008  lwz r29, 8(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6924C: 4800002C  b 0x82c69278
	pc = 0x82C69278; continue 'dispatch;
            }
            0x82C69250 => {
    //   block [0x82C69250..0x82C69268)
	// 82C69250: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69254: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C69258: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C6925C: 419A000C  beq cr6, 0x82c69268
	if ctx.cr[6].eq {
	pc = 0x82C69268; continue 'dispatch;
	}
	// 82C69260: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 82C69264: 48000014  b 0x82c69278
	pc = 0x82C69278; continue 'dispatch;
            }
            0x82C69268 => {
    //   block [0x82C69268..0x82C69278)
	// 82C69268: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82C6926C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C69270: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69274: 409A00F0  bne cr6, 0x82c69364
	if !ctx.cr[6].eq {
	pc = 0x82C69364; continue 'dispatch;
	}
	pc = 0x82C69278; continue 'dispatch;
            }
            0x82C69278 => {
    //   block [0x82C69278..0x82C6928C)
	// 82C69278: 897D0019  lbz r11, 0x19(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C6927C: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69280: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C69284: 409A0008  bne cr6, 0x82c6928c
	if !ctx.cr[6].eq {
	pc = 0x82C6928C; continue 'dispatch;
	}
	// 82C69288: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82C6928C; continue 'dispatch;
            }
            0x82C6928C => {
    //   block [0x82C6928C..0x82C692A4)
	// 82C6928C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69290: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69294: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C69298: 409A000C  bne cr6, 0x82c692a4
	if !ctx.cr[6].eq {
	pc = 0x82C692A4; continue 'dispatch;
	}
	// 82C6929C: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82C692A0: 4800001C  b 0x82c692bc
	pc = 0x82C692BC; continue 'dispatch;
            }
            0x82C692A4 => {
    //   block [0x82C692A4..0x82C692B8)
	// 82C692A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C692A8: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C692AC: 409A000C  bne cr6, 0x82c692b8
	if !ctx.cr[6].eq {
	pc = 0x82C692B8; continue 'dispatch;
	}
	// 82C692B0: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C692B4: 48000008  b 0x82c692bc
	pc = 0x82C692BC; continue 'dispatch;
            }
            0x82C692B8 => {
    //   block [0x82C692B8..0x82C692BC)
	// 82C692B8: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	pc = 0x82C692BC; continue 'dispatch;
            }
            0x82C692BC => {
    //   block [0x82C692BC..0x82C692E0)
	// 82C692BC: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C692C0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C692C4: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C692C8: 409A0044  bne cr6, 0x82c6930c
	if !ctx.cr[6].eq {
	pc = 0x82C6930C; continue 'dispatch;
	}
	// 82C692CC: 897D0019  lbz r11, 0x19(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C692D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C692D4: 419A000C  beq cr6, 0x82c692e0
	if ctx.cr[6].eq {
	pc = 0x82C692E0; continue 'dispatch;
	}
	// 82C692D8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82C692DC: 4800002C  b 0x82c69308
	pc = 0x82C69308; continue 'dispatch;
            }
            0x82C692E0 => {
    //   block [0x82C692E0..0x82C692F4)
	// 82C692E0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C692E4: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82C692E8: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C692EC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C692F0: 409A0018  bne cr6, 0x82c69308
	if !ctx.cr[6].eq {
	pc = 0x82C69308; continue 'dispatch;
	}
	pc = 0x82C692F4; continue 'dispatch;
            }
            0x82C692F4 => {
    //   block [0x82C692F4..0x82C69308)
	// 82C692F4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82C692F8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C692FC: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C69300: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C69304: 419AFFF0  beq cr6, 0x82c692f4
	if ctx.cr[6].eq {
	pc = 0x82C692F4; continue 'dispatch;
	}
	pc = 0x82C69308; continue 'dispatch;
            }
            0x82C69308 => {
    //   block [0x82C69308..0x82C6930C)
	// 82C69308: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82C6930C; continue 'dispatch;
            }
            0x82C6930C => {
    //   block [0x82C6930C..0x82C69334)
	// 82C6930C: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69310: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69314: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C69318: 409A00E0  bne cr6, 0x82c693f8
	if !ctx.cr[6].eq {
	pc = 0x82C693F8; continue 'dispatch;
	}
	// 82C6931C: 897D0019  lbz r11, 0x19(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C69320: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C69324: 419A0010  beq cr6, 0x82c69334
	if ctx.cr[6].eq {
	pc = 0x82C69334; continue 'dispatch;
	}
	// 82C69328: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82C6932C: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C69330: 480000C8  b 0x82c693f8
	pc = 0x82C693F8; continue 'dispatch;
            }
            0x82C69334 => {
    //   block [0x82C69334..0x82C69348)
	// 82C69334: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69338: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82C6933C: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C69340: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C69344: 409A0018  bne cr6, 0x82c6935c
	if !ctx.cr[6].eq {
	pc = 0x82C6935C; continue 'dispatch;
	}
	pc = 0x82C69348; continue 'dispatch;
            }
            0x82C69348 => {
    //   block [0x82C69348..0x82C6935C)
	// 82C69348: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82C6934C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69350: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C69354: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C69358: 419AFFF0  beq cr6, 0x82c69348
	if ctx.cr[6].eq {
	pc = 0x82C69348; continue 'dispatch;
	}
	pc = 0x82C6935C; continue 'dispatch;
            }
            0x82C6935C => {
    //   block [0x82C6935C..0x82C69364)
	// 82C6935C: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C69360: 48000098  b 0x82c693f8
	pc = 0x82C693F8; continue 'dispatch;
            }
            0x82C69364 => {
    //   block [0x82C69364..0x82C69384)
	// 82C69364: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C69368: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6936C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C69370: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69374: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C69378: 409A000C  bne cr6, 0x82c69384
	if !ctx.cr[6].eq {
	pc = 0x82C69384; continue 'dispatch;
	}
	// 82C6937C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82C69380: 4800002C  b 0x82c693ac
	pc = 0x82C693AC; continue 'dispatch;
            }
            0x82C69384 => {
    //   block [0x82C69384..0x82C69398)
	// 82C69384: 895D0019  lbz r10, 0x19(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C69388: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6938C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C69390: 409A0008  bne cr6, 0x82c69398
	if !ctx.cr[6].eq {
	pc = 0x82C69398; continue 'dispatch;
	}
	// 82C69394: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82C69398; continue 'dispatch;
            }
            0x82C69398 => {
    //   block [0x82C69398..0x82C693AC)
	// 82C69398: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C6939C: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C693A0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C693A4: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C693A8: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82C693AC; continue 'dispatch;
            }
            0x82C693AC => {
    //   block [0x82C693AC..0x82C693C4)
	// 82C693AC: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C693B0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C693B4: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C693B8: 409A000C  bne cr6, 0x82c693c4
	if !ctx.cr[6].eq {
	pc = 0x82C693C4; continue 'dispatch;
	}
	// 82C693BC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C693C0: 48000020  b 0x82c693e0
	pc = 0x82C693E0; continue 'dispatch;
            }
            0x82C693C4 => {
    //   block [0x82C693C4..0x82C693DC)
	// 82C693C4: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C693C8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C693CC: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C693D0: 409A000C  bne cr6, 0x82c693dc
	if !ctx.cr[6].eq {
	pc = 0x82C693DC; continue 'dispatch;
	}
	// 82C693D4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C693D8: 48000008  b 0x82c693e0
	pc = 0x82C693E0; continue 'dispatch;
            }
            0x82C693DC => {
    //   block [0x82C693DC..0x82C693E0)
	// 82C693DC: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82C693E0; continue 'dispatch;
            }
            0x82C693E0 => {
    //   block [0x82C693E0..0x82C693F8)
	// 82C693E0: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C693E4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C693E8: 890B0018  lbz r8, 0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C693EC: 893A0018  lbz r9, 0x18(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C693F0: 992B0018  stb r9, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u8 ) };
	// 82C693F4: 991A0018  stb r8, 0x18(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(24 as u32), ctx.r[8].u8 ) };
	pc = 0x82C693F8; continue 'dispatch;
            }
            0x82C693F8 => {
    //   block [0x82C693F8..0x82C69418)
	// 82C693F8: 897A0018  lbz r11, 0x18(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C693FC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C69400: 409A0194  bne cr6, 0x82c69594
	if !ctx.cr[6].eq {
	pc = 0x82C69594; continue 'dispatch;
	}
	// 82C69404: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69408: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82C6940C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69410: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C69414: 419A017C  beq cr6, 0x82c69590
	if ctx.cr[6].eq {
	pc = 0x82C69590; continue 'dispatch;
	}
	pc = 0x82C69418; continue 'dispatch;
            }
            0x82C69418 => {
    //   block [0x82C69418..0x82C69458)
	// 82C69418: 897D0018  lbz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6941C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C69420: 409A0170  bne cr6, 0x82c69590
	if !ctx.cr[6].eq {
	pc = 0x82C69590; continue 'dispatch;
	}
	// 82C69424: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69428: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6942C: 409A00A8  bne cr6, 0x82c694d4
	if !ctx.cr[6].eq {
	pc = 0x82C694D4; continue 'dispatch;
	}
	// 82C69430: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69434: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C69438: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C6943C: 409A001C  bne cr6, 0x82c69458
	if !ctx.cr[6].eq {
	pc = 0x82C69458; continue 'dispatch;
	}
	// 82C69440: 9BCB0018  stb r30, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82C69444: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C69448: 9B7F0018  stb r27, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[27].u8 ) };
	// 82C6944C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C69450: 4BFA1099  bl 0x82c0a4e8
	ctx.lr = 0x82C69454;
	sub_82C0A4E8(ctx, base);
	// 82C69454: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82C69458; continue 'dispatch;
            }
            0x82C69458 => {
    //   block [0x82C69458..0x82C69484)
	// 82C69458: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C6945C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C69460: 409A00C8  bne cr6, 0x82c69528
	if !ctx.cr[6].eq {
	pc = 0x82C69528; continue 'dispatch;
	}
	// 82C69464: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69468: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6946C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C69470: 409A0014  bne cr6, 0x82c69484
	if !ctx.cr[6].eq {
	pc = 0x82C69484; continue 'dispatch;
	}
	// 82C69474: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69478: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6947C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C69480: 419A00A4  beq cr6, 0x82c69524
	if ctx.cr[6].eq {
	pc = 0x82C69524; continue 'dispatch;
	}
	pc = 0x82C69484; continue 'dispatch;
            }
            0x82C69484 => {
    //   block [0x82C69484..0x82C694B0)
	// 82C69484: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69488: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6948C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C69490: 409A0020  bne cr6, 0x82c694b0
	if !ctx.cr[6].eq {
	pc = 0x82C694B0; continue 'dispatch;
	}
	// 82C69494: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69498: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82C6949C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C694A0: 9BCA0018  stb r30, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82C694A4: 9B6B0018  stb r27, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[27].u8 ) };
	// 82C694A8: 4BFA10B9  bl 0x82c0a560
	ctx.lr = 0x82C694AC;
	sub_82C0A560(ctx, base);
	// 82C694AC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82C694B0; continue 'dispatch;
            }
            0x82C694B0 => {
    //   block [0x82C694B0..0x82C694D4)
	// 82C694B0: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C694B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C694B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C694BC: 994B0018  stb r10, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 82C694C0: 9BDF0018  stb r30, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82C694C4: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C694C8: 9BC90018  stb r30, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82C694CC: 4BFA101D  bl 0x82c0a4e8
	ctx.lr = 0x82C694D0;
	sub_82C0A4E8(ctx, base);
	// 82C694D0: 480000C0  b 0x82c69590
	pc = 0x82C69590; continue 'dispatch;
            }
            0x82C694D4 => {
    //   block [0x82C694D4..0x82C694F8)
	// 82C694D4: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C694D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C694DC: 409A001C  bne cr6, 0x82c694f8
	if !ctx.cr[6].eq {
	pc = 0x82C694F8; continue 'dispatch;
	}
	// 82C694E0: 9BCB0018  stb r30, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82C694E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C694E8: 9B7F0018  stb r27, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[27].u8 ) };
	// 82C694EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C694F0: 4BFA1071  bl 0x82c0a560
	ctx.lr = 0x82C694F4;
	sub_82C0A560(ctx, base);
	// 82C694F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C694F8; continue 'dispatch;
            }
            0x82C694F8 => {
    //   block [0x82C694F8..0x82C69524)
	// 82C694F8: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C694FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C69500: 409A0028  bne cr6, 0x82c69528
	if !ctx.cr[6].eq {
	pc = 0x82C69528; continue 'dispatch;
	}
	// 82C69504: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69508: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6950C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C69510: 409A0034  bne cr6, 0x82c69544
	if !ctx.cr[6].eq {
	pc = 0x82C69544; continue 'dispatch;
	}
	// 82C69514: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69518: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6951C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C69520: 409A0024  bne cr6, 0x82c69544
	if !ctx.cr[6].eq {
	pc = 0x82C69544; continue 'dispatch;
	}
	pc = 0x82C69524; continue 'dispatch;
            }
            0x82C69524 => {
    //   block [0x82C69524..0x82C69528)
	// 82C69524: 9B6B0018  stb r27, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[27].u8 ) };
	pc = 0x82C69528; continue 'dispatch;
            }
            0x82C69528 => {
    //   block [0x82C69528..0x82C69544)
	// 82C69528: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6952C: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82C69530: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69534: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69538: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6953C: 409AFEDC  bne cr6, 0x82c69418
	if !ctx.cr[6].eq {
	pc = 0x82C69418; continue 'dispatch;
	}
	// 82C69540: 48000050  b 0x82c69590
	pc = 0x82C69590; continue 'dispatch;
            }
            0x82C69544 => {
    //   block [0x82C69544..0x82C69570)
	// 82C69544: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69548: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6954C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C69550: 409A0020  bne cr6, 0x82c69570
	if !ctx.cr[6].eq {
	pc = 0x82C69570; continue 'dispatch;
	}
	// 82C69554: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69558: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82C6955C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C69560: 9BCA0018  stb r30, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82C69564: 9B6B0018  stb r27, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[27].u8 ) };
	// 82C69568: 4BFA0F81  bl 0x82c0a4e8
	ctx.lr = 0x82C6956C;
	sub_82C0A4E8(ctx, base);
	// 82C6956C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C69570; continue 'dispatch;
            }
            0x82C69570 => {
    //   block [0x82C69570..0x82C69590)
	// 82C69570: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C69574: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C69578: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C6957C: 994B0018  stb r10, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 82C69580: 9BDF0018  stb r30, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82C69584: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69588: 9BC90018  stb r30, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82C6958C: 4BFA0FD5  bl 0x82c0a560
	ctx.lr = 0x82C69590;
	sub_82C0A560(ctx, base);
	pc = 0x82C69590; continue 'dispatch;
            }
            0x82C69590 => {
    //   block [0x82C69590..0x82C69594)
	// 82C69590: 9BDD0018  stb r30, 0x18(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	pc = 0x82C69594; continue 'dispatch;
            }
            0x82C69594 => {
    //   block [0x82C69594..0x82C695B0)
	// 82C69594: 807A0010  lwz r3, 0x10(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C69598: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6959C: 419A0014  beq cr6, 0x82c695b0
	if ctx.cr[6].eq {
	pc = 0x82C695B0; continue 'dispatch;
	}
	// 82C695A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C695A4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C695A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C695AC: 4E800421  bctrl
	ctx.lr = 0x82C695B0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C695B0 => {
    //   block [0x82C695B0..0x82C695E0)
	// 82C695B0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82C695B4: 4BBDC1FD  bl 0x828457b0
	ctx.lr = 0x82C695B8;
	sub_828457B0(ctx, base);
	// 82C695B8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C695BC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C695C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C695C4: 419A001C  beq cr6, 0x82c695e0
	if ctx.cr[6].eq {
	pc = 0x82C695E0; continue 'dispatch;
	}
	// 82C695C8: E9410100  ld r10, 0x100(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82C695CC: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 82C695D0: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C695D4: F9590000  std r10, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82C695D8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82C695DC: 4803FE70  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C695E0 => {
    //   block [0x82C695E0..0x82C695F0)
	// 82C695E0: E9610100  ld r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82C695E4: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82C695E8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82C695EC: 4803FE60  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C695F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C695F0 size=232
    let mut pc: u32 = 0x82C695F0;
    'dispatch: loop {
        match pc {
            0x82C695F0 => {
    //   block [0x82C695F0..0x82C69628)
	// 82C695F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C695F4: 4803FE11  bl 0x82ca9404
	ctx.lr = 0x82C695F8;
	sub_82CA93D0(ctx, base);
	// 82C695F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C695FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C69600: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 82C69604: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82C69608: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C6960C: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82C69610: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C69614: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69618: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6961C: 419A000C  beq cr6, 0x82c69628
	if ctx.cr[6].eq {
	pc = 0x82C69628; continue 'dispatch;
	}
	// 82C69620: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C69624: 419A0008  beq cr6, 0x82c6962c
	if ctx.cr[6].eq {
	pc = 0x82C6962C; continue 'dispatch;
	}
	pc = 0x82C69628; continue 'dispatch;
            }
            0x82C69628 => {
    //   block [0x82C69628..0x82C6962C)
	// 82C69628: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6962C; continue 'dispatch;
            }
            0x82C6962C => {
    //   block [0x82C6962C..0x82C69650)
	// 82C6962C: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82C69630: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82C69634: 83C100B8  lwz r30, 0xb8(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82C69638: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6963C: 409A0044  bne cr6, 0x82c69680
	if !ctx.cr[6].eq {
	pc = 0x82C69680; continue 'dispatch;
	}
	// 82C69640: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C69644: 419A000C  beq cr6, 0x82c69650
	if ctx.cr[6].eq {
	pc = 0x82C69650; continue 'dispatch;
	}
	// 82C69648: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C6964C: 419A0008  beq cr6, 0x82c69654
	if ctx.cr[6].eq {
	pc = 0x82C69654; continue 'dispatch;
	}
	pc = 0x82C69650; continue 'dispatch;
            }
            0x82C69650 => {
    //   block [0x82C69650..0x82C69654)
	// 82C69650: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C69654; continue 'dispatch;
            }
            0x82C69654 => {
    //   block [0x82C69654..0x82C69680)
	// 82C69654: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C69658: 409A0028  bne cr6, 0x82c69680
	if !ctx.cr[6].eq {
	pc = 0x82C69680; continue 'dispatch;
	}
	// 82C6965C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C69660: 4BFFFAF1  bl 0x82c69150
	ctx.lr = 0x82C69664;
	sub_82C69150(ctx, base);
	// 82C69664: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69668: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C6966C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C69670: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69674: 915C0004  stw r10, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C69678: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6967C: 4803FDD8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C69680 => {
    //   block [0x82C69680..0x82C69690)
	// 82C69680: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C69684: 419A000C  beq cr6, 0x82c69690
	if ctx.cr[6].eq {
	pc = 0x82C69690; continue 'dispatch;
	}
	// 82C69688: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C6968C: 419A0008  beq cr6, 0x82c69694
	if ctx.cr[6].eq {
	pc = 0x82C69694; continue 'dispatch;
	}
	pc = 0x82C69690; continue 'dispatch;
            }
            0x82C69690 => {
    //   block [0x82C69690..0x82C69694)
	// 82C69690: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C69694; continue 'dispatch;
            }
            0x82C69694 => {
    //   block [0x82C69694..0x82C696C8)
	// 82C69694: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82C69698: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C6969C: 419A002C  beq cr6, 0x82c696c8
	if ctx.cr[6].eq {
	pc = 0x82C696C8; continue 'dispatch;
	}
	// 82C696A0: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82C696A4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C696A8: 4B7D3749  bl 0x8243cdf0
	ctx.lr = 0x82C696AC;
	sub_8243CDF0(ctx, base);
	// 82C696AC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82C696B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C696B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C696B8: 4BFFFAF1  bl 0x82c691a8
	ctx.lr = 0x82C696BC;
	sub_82C691A8(ctx, base);
	// 82C696BC: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82C696C0: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82C696C4: 4BFFFFBC  b 0x82c69680
	pc = 0x82C69680; continue 'dispatch;
            }
            0x82C696C8 => {
    //   block [0x82C696C8..0x82C696D8)
	// 82C696C8: F8BC0000  std r5, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82C696CC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C696D0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C696D4: 4803FD80  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C696D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C696D8 size=384
    let mut pc: u32 = 0x82C696D8;
    'dispatch: loop {
        match pc {
            0x82C696D8 => {
    //   block [0x82C696D8..0x82C696FC)
	// 82C696D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C696DC: 4803FD15  bl 0x82ca93f0
	ctx.lr = 0x82C696E0;
	sub_82CA93D0(ctx, base);
	// 82C696E0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C696E4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82C696E8: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82C696EC: 81780068  lwz r11, 0x68(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C696F0: 7F165840  cmplw cr6, r22, r11
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C696F4: 4099015C  ble cr6, 0x82c69850
	if !ctx.cr[6].gt {
	pc = 0x82C69850; continue 'dispatch;
	}
	// 82C696F8: 3BB80058  addi r29, r24, 0x58
	ctx.r[29].s64 = ctx.r[24].s64 + 88;
	pc = 0x82C696FC; continue 'dispatch;
            }
            0x82C696FC => {
    //   block [0x82C696FC..0x82C69728)
	// 82C696FC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69700: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82C69704: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82C69708: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82C6970C: 7D775B78  mr r23, r11
	ctx.r[23].u64 = ctx.r[11].u64;
	// 82C69710: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69714: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82C69718: EB410050  ld r26, 0x50(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C6971C: FB410058  std r26, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u64 ) };
	// 82C69720: 8361005C  lwz r27, 0x5c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C69724: 83210058  lwz r25, 0x58(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x82C69728; continue 'dispatch;
            }
            0x82C69728 => {
    //   block [0x82C69728..0x82C69738)
	// 82C69728: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C6972C: 419A000C  beq cr6, 0x82c69738
	if ctx.cr[6].eq {
	pc = 0x82C69738; continue 'dispatch;
	}
	// 82C69730: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C69734: 419A0008  beq cr6, 0x82c6973c
	if ctx.cr[6].eq {
	pc = 0x82C6973C; continue 'dispatch;
	}
	pc = 0x82C69738; continue 'dispatch;
            }
            0x82C69738 => {
    //   block [0x82C69738..0x82C6973C)
	// 82C69738: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6973C; continue 'dispatch;
            }
            0x82C6973C => {
    //   block [0x82C6973C..0x82C69750)
	// 82C6973C: 7F1EB840  cmplw cr6, r30, r23
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82C69740: 419A009C  beq cr6, 0x82c697dc
	if ctx.cr[6].eq {
	pc = 0x82C697DC; continue 'dispatch;
	}
	// 82C69744: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C69748: 409A0008  bne cr6, 0x82c69750
	if !ctx.cr[6].eq {
	pc = 0x82C69750; continue 'dispatch;
	}
	// 82C6974C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C69750; continue 'dispatch;
            }
            0x82C69750 => {
    //   block [0x82C69750..0x82C69760)
	// 82C69750: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69754: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C69758: 409A0008  bne cr6, 0x82c69760
	if !ctx.cr[6].eq {
	pc = 0x82C69760; continue 'dispatch;
	}
	// 82C6975C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C69760; continue 'dispatch;
            }
            0x82C69760 => {
    //   block [0x82C69760..0x82C6978C)
	// 82C69760: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C69764: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69768: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6976C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C69770: 4E800421  bctrl
	ctx.lr = 0x82C69774;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C69774: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69778: 546B003E  slwi r11, r3, 0
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6977C: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C69780: 7F8BE214  add r28, r11, r28
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82C69784: 409A0008  bne cr6, 0x82c6978c
	if !ctx.cr[6].eq {
	pc = 0x82C6978C; continue 'dispatch;
	}
	// 82C69788: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x82C6978C => {
    //   block [0x82C6978C..0x82C69798)
	// 82C6978C: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82C69790: 409A0008  bne cr6, 0x82c69798
	if !ctx.cr[6].eq {
	pc = 0x82C69798; continue 'dispatch;
	}
	// 82C69794: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C69798; continue 'dispatch;
            }
            0x82C69798 => {
    //   block [0x82C69798..0x82C697A8)
	// 82C69798: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6979C: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C697A0: 409A0008  bne cr6, 0x82c697a8
	if !ctx.cr[6].eq {
	pc = 0x82C697A8; continue 'dispatch;
	}
	// 82C697A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C697A8; continue 'dispatch;
            }
            0x82C697A8 => {
    //   block [0x82C697A8..0x82C697C8)
	// 82C697A8: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C697AC: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C697B0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C697B4: 40980014  bge cr6, 0x82c697c8
	if !ctx.cr[6].lt {
	pc = 0x82C697C8; continue 'dispatch;
	}
	// 82C697B8: EB410050  ld r26, 0x50(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C697BC: FB410058  std r26, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u64 ) };
	// 82C697C0: 8361005C  lwz r27, 0x5c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C697C4: 83210058  lwz r25, 0x58(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	pc = 0x82C697C8; continue 'dispatch;
            }
            0x82C697C8 => {
    //   block [0x82C697C8..0x82C697DC)
	// 82C697C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C697CC: 4B7D3625  bl 0x8243cdf0
	ctx.lr = 0x82C697D0;
	sub_8243CDF0(ctx, base);
	// 82C697D0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C697D4: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C697D8: 4BFFFF50  b 0x82c69728
	pc = 0x82C69728; continue 'dispatch;
            }
            0x82C697DC => {
    //   block [0x82C697DC..0x82C697F4)
	// 82C697DC: 81780064  lwz r11, 0x64(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C697E0: 81580068  lwz r10, 0x68(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C697E4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C697E8: 7F09E040  cmplw cr6, r9, r28
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C697EC: 419A0008  beq cr6, 0x82c697f4
	if ctx.cr[6].eq {
	pc = 0x82C697F4; continue 'dispatch;
	}
	// 82C697F0: 4BEE6859  bl 0x82b50048
	ctx.lr = 0x82C697F4;
	sub_82B50048(ctx, base);
	pc = 0x82C697F4; continue 'dispatch;
            }
            0x82C697F4 => {
    //   block [0x82C697F4..0x82C69800)
	// 82C697F4: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82C697F8: 409A0008  bne cr6, 0x82c69800
	if !ctx.cr[6].eq {
	pc = 0x82C69800; continue 'dispatch;
	}
	// 82C697FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C69800; continue 'dispatch;
            }
            0x82C69800 => {
    //   block [0x82C69800..0x82C69810)
	// 82C69800: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69804: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C69808: 409A0008  bne cr6, 0x82c69810
	if !ctx.cr[6].eq {
	pc = 0x82C69810; continue 'dispatch;
	}
	// 82C6980C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C69810; continue 'dispatch;
            }
            0x82C69810 => {
    //   block [0x82C69810..0x82C69850)
	// 82C69810: 807B0010  lwz r3, 0x10(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C69814: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69818: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6981C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C69820: 4E800421  bctrl
	ctx.lr = 0x82C69824;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C69824: 81580068  lwz r10, 0x68(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C69828: 546B003E  slwi r11, r3, 0
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6982C: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82C69830: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C69834: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C69838: 91380068  stw r9, 0x68(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 82C6983C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C69840: 4BFFF969  bl 0x82c691a8
	ctx.lr = 0x82C69844;
	sub_82C691A8(ctx, base);
	// 82C69844: 81180068  lwz r8, 0x68(r24)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C69848: 7F164040  cmplw cr6, r22, r8
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C6984C: 4199FEB0  bgt cr6, 0x82c696fc
	if ctx.cr[6].gt {
	pc = 0x82C696FC; continue 'dispatch;
	}
            }
            0x82C69850 => {
    //   block [0x82C69850..0x82C69858)
	// 82C69850: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82C69854: 4803FBEC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C69858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C69858 size=148
    let mut pc: u32 = 0x82C69858;
    'dispatch: loop {
        match pc {
            0x82C69858 => {
    //   block [0x82C69858..0x82C69888)
	// 82C69858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6985C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C69860: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C69864: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C69868: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6986C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69870: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C69874: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C69878: 409A0010  bne cr6, 0x82c69888
	if !ctx.cr[6].eq {
	pc = 0x82C69888; continue 'dispatch;
	}
	// 82C6987C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82C69880: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 82C69884: 48000008  b 0x82c6988c
	pc = 0x82C6988C; continue 'dispatch;
            }
            0x82C69888 => {
    //   block [0x82C69888..0x82C6988C)
	// 82C69888: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C6988C; continue 'dispatch;
            }
            0x82C6988C => {
    //   block [0x82C6988C..0x82C698B4)
	// 82C6988C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C69890: 4B511819  bl 0x8217b0a8
	ctx.lr = 0x82C69894;
	sub_8217B0A8(ctx, base);
	// 82C69894: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C69898: 4B65F019  bl 0x822c88b0
	ctx.lr = 0x82C6989C;
	sub_822C88B0(ctx, base);
	// 82C6989C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C698A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C698A4: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82C698A8: 4198000C  blt cr6, 0x82c698b4
	if ctx.cr[6].lt {
	pc = 0x82C698B4; continue 'dispatch;
	}
	// 82C698AC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C698B0: 4BBDBF01  bl 0x828457b0
	ctx.lr = 0x82C698B4;
	sub_828457B0(ctx, base);
	pc = 0x82C698B4; continue 'dispatch;
            }
            0x82C698B4 => {
    //   block [0x82C698B4..0x82C698EC)
	// 82C698B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C698B8: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 82C698BC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82C698C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C698C4: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82C698C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C698CC: B1610054  sth r11, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u16 ) };
	// 82C698D0: 4BFFF4B9  bl 0x82c68d88
	ctx.lr = 0x82C698D4;
	sub_82C68D88(ctx, base);
	// 82C698D4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C698D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C698DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C698E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C698E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C698E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C698F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C698F0 size=156
    let mut pc: u32 = 0x82C698F0;
    'dispatch: loop {
        match pc {
            0x82C698F0 => {
    //   block [0x82C698F0..0x82C69928)
	// 82C698F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C698F4: 4803FB0D  bl 0x82ca9400
	ctx.lr = 0x82C698F8;
	sub_82CA93D0(ctx, base);
	// 82C698F8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C698FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69900: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C69904: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C69908: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82C6990C: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82C69910: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82C69914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C69918: 409A0010  bne cr6, 0x82c69928
	if !ctx.cr[6].eq {
	pc = 0x82C69928; continue 'dispatch;
	}
	// 82C6991C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82C69920: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 82C69924: 48000008  b 0x82c6992c
	pc = 0x82C6992C; continue 'dispatch;
            }
            0x82C69928 => {
    //   block [0x82C69928..0x82C6992C)
	// 82C69928: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C6992C; continue 'dispatch;
            }
            0x82C6992C => {
    //   block [0x82C6992C..0x82C69954)
	// 82C6992C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C69930: 4B511779  bl 0x8217b0a8
	ctx.lr = 0x82C69934;
	sub_8217B0A8(ctx, base);
	// 82C69934: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C69938: 4B65EF79  bl 0x822c88b0
	ctx.lr = 0x82C6993C;
	sub_822C88B0(ctx, base);
	// 82C6993C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C69940: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C69944: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82C69948: 4198000C  blt cr6, 0x82c69954
	if ctx.cr[6].lt {
	pc = 0x82C69954; continue 'dispatch;
	}
	// 82C6994C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C69950: 4BBDBE61  bl 0x828457b0
	ctx.lr = 0x82C69954;
	sub_828457B0(ctx, base);
	pc = 0x82C69954; continue 'dispatch;
            }
            0x82C69954 => {
    //   block [0x82C69954..0x82C6998C)
	// 82C69954: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C69958: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 82C6995C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82C69960: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82C69964: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82C69968: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82C6996C: B1610054  sth r11, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u16 ) };
	// 82C69970: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82C69974: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C69978: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C6997C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C69980: 4BFFF4D1  bl 0x82c68e50
	ctx.lr = 0x82C69984;
	sub_82C68E50(ctx, base);
	// 82C69984: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C69988: 4803FAC8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C69990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C69990 size=132
    let mut pc: u32 = 0x82C69990;
    'dispatch: loop {
        match pc {
            0x82C69990 => {
    //   block [0x82C69990..0x82C699B8)
	// 82C69990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C69994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C69998: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6999C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C699A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C699A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C699A8: 409A0010  bne cr6, 0x82c699b8
	if !ctx.cr[6].eq {
	pc = 0x82C699B8; continue 'dispatch;
	}
	// 82C699AC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82C699B0: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 82C699B4: 48000008  b 0x82c699bc
	pc = 0x82C699BC; continue 'dispatch;
            }
            0x82C699B8 => {
    //   block [0x82C699B8..0x82C699BC)
	// 82C699B8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C699BC; continue 'dispatch;
            }
            0x82C699BC => {
    //   block [0x82C699BC..0x82C699E4)
	// 82C699BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C699C0: 4B5116E9  bl 0x8217b0a8
	ctx.lr = 0x82C699C4;
	sub_8217B0A8(ctx, base);
	// 82C699C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C699C8: 4B65EEE9  bl 0x822c88b0
	ctx.lr = 0x82C699CC;
	sub_822C88B0(ctx, base);
	// 82C699CC: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C699D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C699D4: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82C699D8: 4198000C  blt cr6, 0x82c699e4
	if ctx.cr[6].lt {
	pc = 0x82C699E4; continue 'dispatch;
	}
	// 82C699DC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C699E0: 4BBDBDD1  bl 0x828457b0
	ctx.lr = 0x82C699E4;
	sub_828457B0(ctx, base);
	pc = 0x82C699E4; continue 'dispatch;
            }
            0x82C699E4 => {
    //   block [0x82C699E4..0x82C69A14)
	// 82C699E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C699E8: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 82C699EC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82C699F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C699F4: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82C699F8: B1610054  sth r11, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u16 ) };
	// 82C699FC: 4BFFF535  bl 0x82c68f30
	ctx.lr = 0x82C69A00;
	sub_82C68F30(ctx, base);
	// 82C69A00: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C69A04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C69A08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C69A0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C69A10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C69A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C69A18 size=128
    let mut pc: u32 = 0x82C69A18;
    'dispatch: loop {
        match pc {
            0x82C69A18 => {
    //   block [0x82C69A18..0x82C69A5C)
	// 82C69A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C69A1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C69A20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C69A24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C69A28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C69A2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C69A30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C69A34: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C69A38: 389F006C  addi r4, r31, 0x6c
	ctx.r[4].s64 = ctx.r[31].s64 + 108;
	// 82C69A3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C69A40: 4B596D31  bl 0x82200770
	ctx.lr = 0x82C69A44;
	sub_82200770(ctx, base);
	// 82C69A44: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C69A48: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C69A4C: 40980010  bge cr6, 0x82c69a5c
	if !ctx.cr[6].lt {
	pc = 0x82C69A5C; continue 'dispatch;
	}
	// 82C69A50: 7C9E5850  subf r4, r30, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82C69A54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C69A58: 4BFFFC81  bl 0x82c696d8
	ctx.lr = 0x82C69A5C;
	sub_82C696D8(ctx, base);
	pc = 0x82C69A5C; continue 'dispatch;
            }
            0x82C69A5C => {
    //   block [0x82C69A5C..0x82C69A98)
	// 82C69A5C: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C69A60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C69A64: 815F0064  lwz r10, 0x64(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C69A68: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82C69A6C: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C69A70: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C69A74: 913F0068  stw r9, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 82C69A78: 4B559B41  bl 0x821c35b8
	ctx.lr = 0x82C69A7C;
	sub_821C35B8(ctx, base);
	// 82C69A7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C69A80: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C69A84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C69A88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C69A8C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C69A90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C69A94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C69A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C69A98 size=16
    let mut pc: u32 = 0x82C69A98;
    'dispatch: loop {
        match pc {
            0x82C69A98 => {
    //   block [0x82C69A98..0x82C69AA8)
	// 82C69A98: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C69A9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C69AA0: 806B597C  lwz r3, 0x597c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22908 as u32) ) } as u64;
	// 82C69AA4: 4BFFFF74  b 0x82c69a18
	sub_82C69A18(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C69AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C69AA8 size=92
    let mut pc: u32 = 0x82C69AA8;
    'dispatch: loop {
        match pc {
            0x82C69AA8 => {
    //   block [0x82C69AA8..0x82C69B04)
	// 82C69AA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C69AAC: 4803F95D  bl 0x82ca9408
	ctx.lr = 0x82C69AB0;
	sub_82CA93D0(ctx, base);
	// 82C69AB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C69AB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C69AB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C69ABC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C69AC0: 389F006C  addi r4, r31, 0x6c
	ctx.r[4].s64 = ctx.r[31].s64 + 108;
	// 82C69AC4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C69AC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C69ACC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82C69AD0: 4B596CA1  bl 0x82200770
	ctx.lr = 0x82C69AD4;
	sub_82200770(ctx, base);
	// 82C69AD4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82C69AD8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82C69ADC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C69AE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C69AE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C69AE8: 4BEDC009  bl 0x82b45af0
	ctx.lr = 0x82C69AEC;
	sub_82B45AF0(ctx, base);
	// 82C69AEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C69AF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C69AF4: 4B559AC5  bl 0x821c35b8
	ctx.lr = 0x82C69AF8;
	sub_821C35B8(ctx, base);
	// 82C69AF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C69AFC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C69B00: 4803F958  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C69B08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C69B08 size=140
    let mut pc: u32 = 0x82C69B08;
    'dispatch: loop {
        match pc {
            0x82C69B08 => {
    //   block [0x82C69B08..0x82C69B74)
	// 82C69B08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C69B0C: 4803F8F5  bl 0x82ca9400
	ctx.lr = 0x82C69B10;
	sub_82CA93D0(ctx, base);
	// 82C69B10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C69B14: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82C69B18: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C69B1C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C69B20: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82C69B24: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82C69B28: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82C69B2C: 4B5B572D  bl 0x8221f258
	ctx.lr = 0x82C69B30;
	sub_8221F258(ctx, base);
	// 82C69B30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C69B34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C69B38: 419A0050  beq cr6, 0x82c69b88
	if ctx.cr[6].eq {
	pc = 0x82C69B88; continue 'dispatch;
	}
	// 82C69B3C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C69B40: 3BBF000C  addi r29, r31, 0xc
	ctx.r[29].s64 = ctx.r[31].s64 + 12;
	// 82C69B44: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82C69B48: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82C69B4C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69B50: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C69B54: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69B58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C69B5C: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82C69B60: 419A0014  beq cr6, 0x82c69b74
	if ctx.cr[6].eq {
	pc = 0x82C69B74; continue 'dispatch;
	}
	// 82C69B64: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69B68: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69B6C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C69B70: 4E800421  bctrl
	ctx.lr = 0x82C69B74;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C69B74 => {
    //   block [0x82C69B74..0x82C69B88)
	// 82C69B74: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69B78: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C69B7C: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C69B80: 9B5F0018  stb r26, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[26].u8 ) };
	// 82C69B84: 995F0019  stb r10, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	pc = 0x82C69B88; continue 'dispatch;
            }
            0x82C69B88 => {
    //   block [0x82C69B88..0x82C69B94)
	// 82C69B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C69B8C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C69B90: 4803F8C0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C69B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C69B98 size=804
    let mut pc: u32 = 0x82C69B98;
    'dispatch: loop {
        match pc {
            0x82C69B98 => {
    //   block [0x82C69B98..0x82C69C18)
	// 82C69B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C69B9C: 4803F861  bl 0x82ca93fc
	ctx.lr = 0x82C69BA0;
	sub_82CA93D0(ctx, base);
	// 82C69BA0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C69BA4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C69BA8: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 82C69BAC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82C69BB0: 61695554  ori r9, r11, 0x5554
	ctx.r[9].u64 = ctx.r[11].u64 | 21844;
	// 82C69BB4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C69BB8: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69BBC: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82C69BC0: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82C69BC4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82C69BC8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C69BCC: 4198005C  blt cr6, 0x82c69c28
	if ctx.cr[6].lt {
	pc = 0x82C69C28; continue 'dispatch;
	}
	// 82C69BD0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82C69BD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C69BD8: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 82C69BDC: 4B688365  bl 0x822f1f40
	ctx.lr = 0x82C69BE0;
	sub_822F1F40(ctx, base);
	// 82C69BE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C69BE4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C69BE8: 4B688189  bl 0x822f1d70
	ctx.lr = 0x82C69BEC;
	sub_822F1D70(ctx, base);
	// 82C69BEC: 4B688235  bl 0x822f1e20
	ctx.lr = 0x82C69BF0;
	sub_822F1E20(ctx, base);
	// 82C69BF0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82C69BF4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C69BF8: 392A1720  addi r9, r10, 0x1720
	ctx.r[9].s64 = ctx.r[10].s64 + 5920;
	// 82C69BFC: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 82C69C00: 4BA11BE1  bl 0x8267b7e0
	ctx.lr = 0x82C69C04;
	sub_8267B7E0(ctx, base);
	// 82C69C04: 81010068  lwz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C69C08: 2B080010  cmplwi cr6, r8, 0x10
	ctx.cr[6].compare_u32(ctx.r[8].u32, 16 as u32, &mut ctx.xer);
	// 82C69C0C: 4198000C  blt cr6, 0x82c69c18
	if ctx.cr[6].lt {
	pc = 0x82C69C18; continue 'dispatch;
	}
	// 82C69C10: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C69C14: 4BBDBB9D  bl 0x828457b0
	ctx.lr = 0x82C69C18;
	sub_828457B0(ctx, base);
	pc = 0x82C69C18; continue 'dispatch;
            }
            0x82C69C18 => {
    //   block [0x82C69C18..0x82C69C28)
	// 82C69C18: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 82C69C1C: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 82C69C20: 9B610054  stb r27, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u8 ) };
	// 82C69C24: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	pc = 0x82C69C28; continue 'dispatch;
            }
            0x82C69C28 => {
    //   block [0x82C69C28..0x82C69C78)
	// 82C69C28: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69C2C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82C69C30: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82C69C34: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82C69C38: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C69C3C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C69C40: 4BFFFEC9  bl 0x82c69b08
	ctx.lr = 0x82C69C44;
	sub_82C69B08(ctx, base);
	// 82C69C44: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69C48: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69C4C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82C69C50: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C69C54: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C69C58: 915C0008  stw r10, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C69C5C: 409A001C  bne cr6, 0x82c69c78
	if !ctx.cr[6].eq {
	pc = 0x82C69C78; continue 'dispatch;
	}
	// 82C69C60: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82C69C64: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69C68: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82C69C6C: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69C70: 934A0008  stw r26, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82C69C74: 48000044  b 0x82c69cb8
	pc = 0x82C69CB8; continue 'dispatch;
            }
            0x82C69C78 => {
    //   block [0x82C69C78..0x82C69CA0)
	// 82C69C78: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82C69C7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C69C80: 419A0020  beq cr6, 0x82c69ca0
	if ctx.cr[6].eq {
	pc = 0x82C69CA0; continue 'dispatch;
	}
	// 82C69C84: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82C69C88: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69C8C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69C90: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C69C94: 409A0024  bne cr6, 0x82c69cb8
	if !ctx.cr[6].eq {
	pc = 0x82C69CB8; continue 'dispatch;
	}
	// 82C69C98: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82C69C9C: 4800001C  b 0x82c69cb8
	pc = 0x82C69CB8; continue 'dispatch;
            }
            0x82C69CA0 => {
    //   block [0x82C69CA0..0x82C69CB8)
	// 82C69CA0: 935F0008  stw r26, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82C69CA4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69CA8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69CAC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C69CB0: 409A0008  bne cr6, 0x82c69cb8
	if !ctx.cr[6].eq {
	pc = 0x82C69CB8; continue 'dispatch;
	}
	// 82C69CB4: 934B0008  stw r26, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	pc = 0x82C69CB8; continue 'dispatch;
            }
            0x82C69CB8 => {
    //   block [0x82C69CB8..0x82C69CD4)
	// 82C69CB8: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69CBC: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 82C69CC0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82C69CC4: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 82C69CC8: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C69CCC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C69CD0: 409A01CC  bne cr6, 0x82c69e9c
	if !ctx.cr[6].eq {
	pc = 0x82C69E9C; continue 'dispatch;
	}
	pc = 0x82C69CD4; continue 'dispatch;
            }
            0x82C69CD4 => {
    //   block [0x82C69CD4..0x82C69D1C)
	// 82C69CD4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69CD8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69CDC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69CE0: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C69CE4: 409A00D8  bne cr6, 0x82c69dbc
	if !ctx.cr[6].eq {
	pc = 0x82C69DBC; continue 'dispatch;
	}
	// 82C69CE8: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69CEC: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C69CF0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C69CF4: 409A0028  bne cr6, 0x82c69d1c
	if !ctx.cr[6].eq {
	pc = 0x82C69D1C; continue 'dispatch;
	}
	// 82C69CF8: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C69CFC: 9BC90018  stb r30, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82C69D00: 9BCA0018  stb r30, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82C69D04: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69D08: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69D0C: 9B670018  stb r27, 0x18(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(24 as u32), ctx.r[27].u8 ) };
	// 82C69D10: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69D14: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69D18: 48000170  b 0x82c69e88
	pc = 0x82C69E88; continue 'dispatch;
            }
            0x82C69D1C => {
    //   block [0x82C69D1C..0x82C69D34)
	// 82C69D1C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69D20: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C69D24: 409A0010  bne cr6, 0x82c69d34
	if !ctx.cr[6].eq {
	pc = 0x82C69D34; continue 'dispatch;
	}
	// 82C69D28: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C69D2C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C69D30: 4BFA07B9  bl 0x82c0a4e8
	ctx.lr = 0x82C69D34;
	sub_82C0A4E8(ctx, base);
	pc = 0x82C69D34; continue 'dispatch;
            }
            0x82C69D34 => {
    //   block [0x82C69D34..0x82C69D70)
	// 82C69D34: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69D38: 9BCB0018  stb r30, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82C69D3C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69D40: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69D44: 9B690018  stb r27, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[27].u8 ) };
	// 82C69D48: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69D4C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69D50: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69D54: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69D58: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82C69D5C: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69D60: 88C90019  lbz r6, 0x19(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C69D64: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C69D68: 409A0008  bne cr6, 0x82c69d70
	if !ctx.cr[6].eq {
	pc = 0x82C69D70; continue 'dispatch;
	}
	// 82C69D6C: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82C69D70; continue 'dispatch;
            }
            0x82C69D70 => {
    //   block [0x82C69D70..0x82C69D94)
	// 82C69D70: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69D74: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C69D78: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69D7C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69D80: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C69D84: 409A0010  bne cr6, 0x82c69d94
	if !ctx.cr[6].eq {
	pc = 0x82C69D94; continue 'dispatch;
	}
	// 82C69D88: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C69D8C: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C69D90: 480000F4  b 0x82c69e84
	pc = 0x82C69E84; continue 'dispatch;
            }
            0x82C69D94 => {
    //   block [0x82C69D94..0x82C69DB0)
	// 82C69D94: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69D98: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69D9C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C69DA0: 409A0010  bne cr6, 0x82c69db0
	if !ctx.cr[6].eq {
	pc = 0x82C69DB0; continue 'dispatch;
	}
	// 82C69DA4: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C69DA8: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C69DAC: 480000D8  b 0x82c69e84
	pc = 0x82C69E84; continue 'dispatch;
            }
            0x82C69DB0 => {
    //   block [0x82C69DB0..0x82C69DBC)
	// 82C69DB0: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C69DB4: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C69DB8: 480000CC  b 0x82c69e84
	pc = 0x82C69E84; continue 'dispatch;
            }
            0x82C69DBC => {
    //   block [0x82C69DBC..0x82C69DF0)
	// 82C69DBC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69DC0: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C69DC4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C69DC8: 409A0028  bne cr6, 0x82c69df0
	if !ctx.cr[6].eq {
	pc = 0x82C69DF0; continue 'dispatch;
	}
	// 82C69DCC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69DD0: 9BC90018  stb r30, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82C69DD4: 9BCA0018  stb r30, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82C69DD8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69DDC: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69DE0: 9B670018  stb r27, 0x18(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(24 as u32), ctx.r[27].u8 ) };
	// 82C69DE4: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69DE8: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69DEC: 4800009C  b 0x82c69e88
	pc = 0x82C69E88; continue 'dispatch;
            }
            0x82C69DF0 => {
    //   block [0x82C69DF0..0x82C69E08)
	// 82C69DF0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69DF4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C69DF8: 409A0010  bne cr6, 0x82c69e08
	if !ctx.cr[6].eq {
	pc = 0x82C69E08; continue 'dispatch;
	}
	// 82C69DFC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C69E00: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C69E04: 4BFA075D  bl 0x82c0a560
	ctx.lr = 0x82C69E08;
	sub_82C0A560(ctx, base);
	pc = 0x82C69E08; continue 'dispatch;
            }
            0x82C69E08 => {
    //   block [0x82C69E08..0x82C69E44)
	// 82C69E08: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69E0C: 9BCB0018  stb r30, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82C69E10: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69E14: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69E18: 9B690018  stb r27, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[27].u8 ) };
	// 82C69E1C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69E20: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69E24: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C69E28: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69E2C: 90EB0008  stw r7, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82C69E30: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69E34: 88C90019  lbz r6, 0x19(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C69E38: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C69E3C: 409A0008  bne cr6, 0x82c69e44
	if !ctx.cr[6].eq {
	pc = 0x82C69E44; continue 'dispatch;
	}
	// 82C69E40: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82C69E44; continue 'dispatch;
            }
            0x82C69E44 => {
    //   block [0x82C69E44..0x82C69E64)
	// 82C69E44: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69E48: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C69E4C: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69E50: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69E54: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C69E58: 409A000C  bne cr6, 0x82c69e64
	if !ctx.cr[6].eq {
	pc = 0x82C69E64; continue 'dispatch;
	}
	// 82C69E5C: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C69E60: 48000020  b 0x82c69e80
	pc = 0x82C69E80; continue 'dispatch;
            }
            0x82C69E64 => {
    //   block [0x82C69E64..0x82C69E7C)
	// 82C69E64: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69E68: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69E6C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C69E70: 409A000C  bne cr6, 0x82c69e7c
	if !ctx.cr[6].eq {
	pc = 0x82C69E7C; continue 'dispatch;
	}
	// 82C69E74: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C69E78: 48000008  b 0x82c69e80
	pc = 0x82C69E80; continue 'dispatch;
            }
            0x82C69E7C => {
    //   block [0x82C69E7C..0x82C69E80)
	// 82C69E7C: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82C69E80; continue 'dispatch;
            }
            0x82C69E80 => {
    //   block [0x82C69E80..0x82C69E84)
	// 82C69E80: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82C69E84; continue 'dispatch;
            }
            0x82C69E84 => {
    //   block [0x82C69E84..0x82C69E88)
	// 82C69E84: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x82C69E88; continue 'dispatch;
            }
            0x82C69E88 => {
    //   block [0x82C69E88..0x82C69E9C)
	// 82C69E88: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69E8C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82C69E90: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C69E94: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C69E98: 419AFE3C  beq cr6, 0x82c69cd4
	if ctx.cr[6].eq {
	pc = 0x82C69CD4; continue 'dispatch;
	}
	pc = 0x82C69E9C; continue 'dispatch;
            }
            0x82C69E9C => {
    //   block [0x82C69E9C..0x82C69EBC)
	// 82C69E9C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69EA0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C69EA4: 93590004  stw r26, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82C69EA8: 93990000  stw r28, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82C69EAC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69EB0: 9BCA0018  stb r30, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 82C69EB4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82C69EB8: 4803F594  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C69EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C69EC0 size=316
    let mut pc: u32 = 0x82C69EC0;
    'dispatch: loop {
        match pc {
            0x82C69EC0 => {
    //   block [0x82C69EC0..0x82C69EF8)
	// 82C69EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C69EC4: 4803F53D  bl 0x82ca9400
	ctx.lr = 0x82C69EC8;
	sub_82CA93D0(ctx, base);
	// 82C69EC8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C69ECC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C69ED0: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82C69ED4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C69ED8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C69EDC: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82C69EE0: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69EE4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69EE8: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C69EEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C69EF0: 409A003C  bne cr6, 0x82c69f2c
	if !ctx.cr[6].eq {
	pc = 0x82C69F2C; continue 'dispatch;
	}
	// 82C69EF4: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C69EF8; continue 'dispatch;
            }
            0x82C69EF8 => {
    //   block [0x82C69EF8..0x82C69F1C)
	// 82C69EF8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C69EFC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82C69F00: 7D095010  subfc r8, r9, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[9].u32;
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82C69F04: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82C69F08: 54FD07FE  clrlwi r29, r7, 0x1f
	ctx.r[29].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 82C69F0C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C69F10: 419A000C  beq cr6, 0x82c69f1c
	if ctx.cr[6].eq {
	pc = 0x82C69F1C; continue 'dispatch;
	}
	// 82C69F14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69F18: 48000008  b 0x82c69f20
	pc = 0x82C69F20; continue 'dispatch;
            }
            0x82C69F1C => {
    //   block [0x82C69F1C..0x82C69F20)
	// 82C69F1C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82C69F20; continue 'dispatch;
            }
            0x82C69F20 => {
    //   block [0x82C69F20..0x82C69F2C)
	// 82C69F20: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C69F24: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C69F28: 419AFFD0  beq cr6, 0x82c69ef8
	if ctx.cr[6].eq {
	pc = 0x82C69EF8; continue 'dispatch;
	}
	pc = 0x82C69F2C; continue 'dispatch;
            }
            0x82C69F2C => {
    //   block [0x82C69F2C..0x82C69F8C)
	// 82C69F2C: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82C69F30: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82C69F34: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82C69F38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C69F3C: 419A0054  beq cr6, 0x82c69f90
	if ctx.cr[6].eq {
	pc = 0x82C69F90; continue 'dispatch;
	}
	// 82C69F40: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69F44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C69F48: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69F4C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C69F50: 409A003C  bne cr6, 0x82c69f8c
	if !ctx.cr[6].eq {
	pc = 0x82C69F8C; continue 'dispatch;
	}
	// 82C69F54: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82C69F58: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C69F5C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C69F60: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C69F64: 4BFFFC35  bl 0x82c69b98
	ctx.lr = 0x82C69F68;
	sub_82C69B98(ctx, base);
	// 82C69F68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C69F6C: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82C69F70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C69F74: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69F78: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69F7C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C69F80: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C69F84: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C69F88: 4803F4C8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C69F8C => {
    //   block [0x82C69F8C..0x82C69F90)
	// 82C69F8C: 4B9F65BD  bl 0x82660548
	ctx.lr = 0x82C69F90;
	sub_82660548(ctx, base);
	pc = 0x82C69F90; continue 'dispatch;
            }
            0x82C69F90 => {
    //   block [0x82C69F90..0x82C69FE0)
	// 82C69F90: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C69F94: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69F98: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C69F9C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C69FA0: 40980040  bge cr6, 0x82c69fe0
	if !ctx.cr[6].lt {
	pc = 0x82C69FE0; continue 'dispatch;
	}
	// 82C69FA4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82C69FA8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C69FAC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C69FB0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C69FB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C69FB8: 4BFFFBE1  bl 0x82c69b98
	ctx.lr = 0x82C69FBC;
	sub_82C69B98(ctx, base);
	// 82C69FBC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C69FC0: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82C69FC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C69FC8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C69FCC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C69FD0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C69FD4: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C69FD8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C69FDC: 4803F474  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C69FE0 => {
    //   block [0x82C69FE0..0x82C69FFC)
	// 82C69FE0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C69FE4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C69FE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C69FEC: 995E0008  stb r10, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82C69FF0: F97E0000  std r11, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82C69FF4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C69FF8: 4803F458  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6A000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6A000 size=524
    let mut pc: u32 = 0x82C6A000;
    'dispatch: loop {
        match pc {
            0x82C6A000 => {
    //   block [0x82C6A000..0x82C6A048)
	// 82C6A000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6A004: 4803F401  bl 0x82ca9404
	ctx.lr = 0x82C6A008;
	sub_82CA93D0(ctx, base);
	// 82C6A008: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6A00C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C6A010: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C6A014: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C6A018: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 82C6A01C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82C6A020: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6A024: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6A028: 409A0020  bne cr6, 0x82c6a048
	if !ctx.cr[6].eq {
	pc = 0x82C6A048; continue 'dispatch;
	}
	// 82C6A02C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C6A030: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6A034: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C6A038: 4BFFFB61  bl 0x82c69b98
	ctx.lr = 0x82C6A03C;
	sub_82C69B98(ctx, base);
	// 82C6A03C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6A040: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6A044: 4803F410  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6A048 => {
    //   block [0x82C6A048..0x82C6A064)
	// 82C6A048: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6A04C: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82C6A050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6A054: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A058: 419A000C  beq cr6, 0x82c6a064
	if ctx.cr[6].eq {
	pc = 0x82C6A064; continue 'dispatch;
	}
	// 82C6A05C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C6A060: 419A0008  beq cr6, 0x82c6a068
	if ctx.cr[6].eq {
	pc = 0x82C6A068; continue 'dispatch;
	}
	pc = 0x82C6A064; continue 'dispatch;
            }
            0x82C6A064 => {
    //   block [0x82C6A064..0x82C6A068)
	// 82C6A064: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6A068; continue 'dispatch;
            }
            0x82C6A068 => {
    //   block [0x82C6A068..0x82C6A0A8)
	// 82C6A068: 838100B4  lwz r28, 0xb4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82C6A06C: 7F1C4840  cmplw cr6, r28, r9
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C6A070: 409A0038  bne cr6, 0x82c6a0a8
	if !ctx.cr[6].eq {
	pc = 0x82C6A0A8; continue 'dispatch;
	}
	// 82C6A074: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A078: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6A07C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6A080: 4098015C  bge cr6, 0x82c6a1dc
	if !ctx.cr[6].lt {
	pc = 0x82C6A1DC; continue 'dispatch;
	}
	// 82C6A084: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C6A088: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82C6A08C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C6A090: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C6A094: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6A098: 4BFFFB01  bl 0x82c69b98
	ctx.lr = 0x82C6A09C;
	sub_82C69B98(ctx, base);
	// 82C6A09C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6A0A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6A0A4: 4803F3B0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6A0A8 => {
    //   block [0x82C6A0A8..0x82C6A0B8)
	// 82C6A0A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6A0AC: 419A000C  beq cr6, 0x82c6a0b8
	if ctx.cr[6].eq {
	pc = 0x82C6A0B8; continue 'dispatch;
	}
	// 82C6A0B0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C6A0B4: 419A0008  beq cr6, 0x82c6a0bc
	if ctx.cr[6].eq {
	pc = 0x82C6A0BC; continue 'dispatch;
	}
	pc = 0x82C6A0B8; continue 'dispatch;
            }
            0x82C6A0B8 => {
    //   block [0x82C6A0B8..0x82C6A0BC)
	// 82C6A0B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6A0BC; continue 'dispatch;
            }
            0x82C6A0BC => {
    //   block [0x82C6A0BC..0x82C6A0F8)
	// 82C6A0BC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A0C0: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6A0C4: 409A0034  bne cr6, 0x82c6a0f8
	if !ctx.cr[6].eq {
	pc = 0x82C6A0F8; continue 'dispatch;
	}
	// 82C6A0C8: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6A0CC: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6A0D0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6A0D4: 40980108  bge cr6, 0x82c6a1dc
	if !ctx.cr[6].lt {
	pc = 0x82C6A1DC; continue 'dispatch;
	}
	// 82C6A0D8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C6A0DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6A0E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C6A0E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6A0E8: 4BFFFAB1  bl 0x82c69b98
	ctx.lr = 0x82C6A0EC;
	sub_82C69B98(ctx, base);
	// 82C6A0EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6A0F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6A0F4: 4803F360  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6A0F8 => {
    //   block [0x82C6A0F8..0x82C6A144)
	// 82C6A0F8: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6A0FC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6A100: 40980058  bge cr6, 0x82c6a158
	if !ctx.cr[6].lt {
	pc = 0x82C6A158; continue 'dispatch;
	}
	// 82C6A104: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6A108: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 82C6A10C: 4B9F643D  bl 0x82660548
	ctx.lr = 0x82C6A110;
	sub_82660548(ctx, base);
	// 82C6A110: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C6A114: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A118: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6A11C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6A120: 40980038  bge cr6, 0x82c6a158
	if !ctx.cr[6].lt {
	pc = 0x82C6A158; continue 'dispatch;
	}
	// 82C6A124: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6A128: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C6A12C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C6A130: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6A134: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C6A138: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C6A13C: 409A008C  bne cr6, 0x82c6a1c8
	if !ctx.cr[6].eq {
	pc = 0x82C6A1C8; continue 'dispatch;
	}
	// 82C6A140: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	pc = 0x82C6A144; continue 'dispatch;
            }
            0x82C6A144 => {
    //   block [0x82C6A144..0x82C6A158)
	// 82C6A144: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C6A148: 4BFFFA51  bl 0x82c69b98
	ctx.lr = 0x82C6A14C;
	sub_82C69B98(ctx, base);
	// 82C6A14C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6A150: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6A154: 4803F300  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6A158 => {
    //   block [0x82C6A158..0x82C6A188)
	// 82C6A158: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6A15C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6A160: 4098007C  bge cr6, 0x82c6a1dc
	if !ctx.cr[6].lt {
	pc = 0x82C6A1DC; continue 'dispatch;
	}
	// 82C6A164: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6A168: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 82C6A16C: 837F0004  lwz r27, 4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6A170: 4B7D2C81  bl 0x8243cdf0
	ctx.lr = 0x82C6A174;
	sub_8243CDF0(ctx, base);
	// 82C6A174: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6A178: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6A17C: 419A000C  beq cr6, 0x82c6a188
	if ctx.cr[6].eq {
	pc = 0x82C6A188; continue 'dispatch;
	}
	// 82C6A180: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C6A184: 419A0008  beq cr6, 0x82c6a18c
	if ctx.cr[6].eq {
	pc = 0x82C6A18C; continue 'dispatch;
	}
	pc = 0x82C6A188; continue 'dispatch;
            }
            0x82C6A188 => {
    //   block [0x82C6A188..0x82C6A18C)
	// 82C6A188: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6A18C; continue 'dispatch;
            }
            0x82C6A18C => {
    //   block [0x82C6A18C..0x82C6A1A8)
	// 82C6A18C: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C6A190: 7F06D840  cmplw cr6, r6, r27
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C6A194: 419A0014  beq cr6, 0x82c6a1a8
	if ctx.cr[6].eq {
	pc = 0x82C6A1A8; continue 'dispatch;
	}
	// 82C6A198: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A19C: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6A1A0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6A1A4: 40980038  bge cr6, 0x82c6a1dc
	if !ctx.cr[6].lt {
	pc = 0x82C6A1DC; continue 'dispatch;
	}
	pc = 0x82C6A1A8; continue 'dispatch;
            }
            0x82C6A1A8 => {
    //   block [0x82C6A1A8..0x82C6A1C8)
	// 82C6A1A8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6A1AC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C6A1B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C6A1B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6A1B8: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C6A1BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C6A1C0: 419AFF84  beq cr6, 0x82c6a144
	if ctx.cr[6].eq {
	pc = 0x82C6A144; continue 'dispatch;
	}
	// 82C6A1C4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	pc = 0x82C6A1C8; continue 'dispatch;
            }
            0x82C6A1C8 => {
    //   block [0x82C6A1C8..0x82C6A1DC)
	// 82C6A1C8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6A1CC: 4BFFF9CD  bl 0x82c69b98
	ctx.lr = 0x82C6A1D0;
	sub_82C69B98(ctx, base);
	// 82C6A1D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6A1D4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6A1D8: 4803F27C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6A1DC => {
    //   block [0x82C6A1DC..0x82C6A20C)
	// 82C6A1DC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C6A1E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C6A1E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6A1E8: 4BFFFCD9  bl 0x82c69ec0
	ctx.lr = 0x82C6A1EC;
	sub_82C69EC0(ctx, base);
	// 82C6A1EC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C6A1F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6A1F4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A1F8: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C6A1FC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6A200: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C6A204: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6A208: 4803F24C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6A210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6A210 size=120
    let mut pc: u32 = 0x82C6A210;
    'dispatch: loop {
        match pc {
            0x82C6A210 => {
    //   block [0x82C6A210..0x82C6A288)
	// 82C6A210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6A214: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6A218: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6A21C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6A220: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6A224: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6A228: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C6A22C: 389F006C  addi r4, r31, 0x6c
	ctx.r[4].s64 = ctx.r[31].s64 + 108;
	// 82C6A230: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6A234: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6A238: 4B596539  bl 0x82200770
	ctx.lr = 0x82C6A23C;
	sub_82200770(ctx, base);
	// 82C6A23C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6A240: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C6A244: 4BEDBB65  bl 0x82b45da8
	ctx.lr = 0x82C6A248;
	sub_82B45DA8(ctx, base);
	// 82C6A248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6A24C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C6A250: 83DF0064  lwz r30, 0x64(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C6A254: 4BFFF7C5  bl 0x82c69a18
	ctx.lr = 0x82C6A258;
	sub_82C69A18(ctx, base);
	// 82C6A258: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C6A25C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6A260: 4BFFF7B9  bl 0x82c69a18
	ctx.lr = 0x82C6A264;
	sub_82C69A18(ctx, base);
	// 82C6A264: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6A268: 4B559351  bl 0x821c35b8
	ctx.lr = 0x82C6A26C;
	sub_821C35B8(ctx, base);
	// 82C6A26C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C6A270: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6A274: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6A278: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6A27C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6A280: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6A284: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6A288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6A288 size=120
    let mut pc: u32 = 0x82C6A288;
    'dispatch: loop {
        match pc {
            0x82C6A288 => {
    //   block [0x82C6A288..0x82C6A300)
	// 82C6A288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6A28C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6A290: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6A294: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6A298: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6A29C: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 82C6A2A0: 4BF2CBD9  bl 0x82b96e78
	ctx.lr = 0x82C6A2A4;
	sub_82B96E78(ctx, base);
	// 82C6A2A4: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C6A2A8: 389F0058  addi r4, r31, 0x58
	ctx.r[4].s64 = ctx.r[31].s64 + 88;
	// 82C6A2AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C6A2B0: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 82C6A2B4: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82C6A2B8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A2BC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C6A2C0: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C6A2C4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82C6A2C8: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82C6A2CC: 4BFFF325  bl 0x82c695f0
	ctx.lr = 0x82C6A2D0;
	sub_82C695F0(ctx, base);
	// 82C6A2D0: 807F005C  lwz r3, 0x5c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C6A2D4: 4BBDB4DD  bl 0x828457b0
	ctx.lr = 0x82C6A2D8;
	sub_828457B0(ctx, base);
	// 82C6A2D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6A2DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6A2E0: 917F005C  stw r11, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82C6A2E4: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82C6A2E8: 4BEDB091  bl 0x82b45378
	ctx.lr = 0x82C6A2EC;
	sub_82B45378(ctx, base);
	// 82C6A2EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6A2F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6A2F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6A2F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6A2FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6A300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6A300 size=252
    let mut pc: u32 = 0x82C6A300;
    'dispatch: loop {
        match pc {
            0x82C6A300 => {
    //   block [0x82C6A300..0x82C6A324)
	// 82C6A300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6A304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6A308: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6A30C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6A310: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6A314: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C6A318: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C6A31C: 409A0030  bne cr6, 0x82c6a34c
	if !ctx.cr[6].eq {
	pc = 0x82C6A34C; continue 'dispatch;
	}
	// 82C6A320: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C6A324; continue 'dispatch;
            }
            0x82C6A324 => {
    //   block [0x82C6A324..0x82C6A338)
	// 82C6A324: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6A328: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C6A32C: 4098000C  bge cr6, 0x82c6a338
	if !ctx.cr[6].lt {
	pc = 0x82C6A338; continue 'dispatch;
	}
	// 82C6A330: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6A334: 4800000C  b 0x82c6a340
	pc = 0x82C6A340; continue 'dispatch;
            }
            0x82C6A338 => {
    //   block [0x82C6A338..0x82C6A340)
	// 82C6A338: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82C6A33C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C6A340; continue 'dispatch;
            }
            0x82C6A340 => {
    //   block [0x82C6A340..0x82C6A34C)
	// 82C6A340: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82C6A344: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C6A348: 419AFFDC  beq cr6, 0x82c6a324
	if ctx.cr[6].eq {
	pc = 0x82C6A324; continue 'dispatch;
	}
	pc = 0x82C6A34C; continue 'dispatch;
            }
            0x82C6A34C => {
    //   block [0x82C6A34C..0x82C6A374)
	// 82C6A34C: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6A350: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82C6A354: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82C6A358: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C6A35C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C6A360: 419A0014  beq cr6, 0x82c6a374
	if ctx.cr[6].eq {
	pc = 0x82C6A374; continue 'dispatch;
	}
	// 82C6A364: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A368: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6A36C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C6A370: 40980058  bge cr6, 0x82c6a3c8
	if !ctx.cr[6].lt {
	pc = 0x82C6A3C8; continue 'dispatch;
	}
	pc = 0x82C6A374; continue 'dispatch;
            }
            0x82C6A374 => {
    //   block [0x82C6A374..0x82C6A3C4)
	// 82C6A374: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A378: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C6A37C: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C6A380: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6A384: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82C6A388: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82C6A38C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C6A390: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C6A394: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82C6A398: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 82C6A39C: 4BFFFC65  bl 0x82c6a000
	ctx.lr = 0x82C6A3A0;
	sub_82C6A000(ctx, base);
	// 82C6A3A0: E9030000  ld r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82C6A3A4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C6A3A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6A3AC: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82C6A3B0: 419A0014  beq cr6, 0x82c6a3c4
	if ctx.cr[6].eq {
	pc = 0x82C6A3C4; continue 'dispatch;
	}
	// 82C6A3B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A3B8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6A3BC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6A3C0: 4E800421  bctrl
	ctx.lr = 0x82C6A3C4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6A3C4 => {
    //   block [0x82C6A3C4..0x82C6A3C8)
	// 82C6A3C4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82C6A3C8; continue 'dispatch;
            }
            0x82C6A3C8 => {
    //   block [0x82C6A3C8..0x82C6A3D8)
	// 82C6A3C8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6A3CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C6A3D0: 409A0008  bne cr6, 0x82c6a3d8
	if !ctx.cr[6].eq {
	pc = 0x82C6A3D8; continue 'dispatch;
	}
	// 82C6A3D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6A3D8; continue 'dispatch;
            }
            0x82C6A3D8 => {
    //   block [0x82C6A3D8..0x82C6A3E8)
	// 82C6A3D8: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6A3DC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6A3E0: 409A0008  bne cr6, 0x82c6a3e8
	if !ctx.cr[6].eq {
	pc = 0x82C6A3E8; continue 'dispatch;
	}
	// 82C6A3E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6A3E8; continue 'dispatch;
            }
            0x82C6A3E8 => {
    //   block [0x82C6A3E8..0x82C6A3FC)
	// 82C6A3E8: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82C6A3EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6A3F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6A3F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6A3F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6A400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6A400 size=804
    let mut pc: u32 = 0x82C6A400;
    'dispatch: loop {
        match pc {
            0x82C6A400 => {
    //   block [0x82C6A400..0x82C6A460)
	// 82C6A400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6A404: 4803EFFD  bl 0x82ca9400
	ctx.lr = 0x82C6A408;
	sub_82CA93D0(ctx, base);
	// 82C6A408: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6A40C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C6A410: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82C6A414: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C6A418: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6A41C: 389F006C  addi r4, r31, 0x6c
	ctx.r[4].s64 = ctx.r[31].s64 + 108;
	// 82C6A420: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C6A424: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82C6A428: 4B596349  bl 0x82200770
	ctx.lr = 0x82C6A42C;
	sub_82200770(ctx, base);
	// 82C6A42C: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C6A430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6A434: 409A002C  bne cr6, 0x82c6a460
	if !ctx.cr[6].eq {
	pc = 0x82C6A460; continue 'dispatch;
	}
	// 82C6A438: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82C6A43C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C6A440: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C6A444: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82C6A448: 4BEDAFB1  bl 0x82b453f8
	ctx.lr = 0x82C6A44C;
	sub_82B453F8(ctx, base);
	// 82C6A44C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C6A450: 4B559169  bl 0x821c35b8
	ctx.lr = 0x82C6A454;
	sub_821C35B8(ctx, base);
	// 82C6A454: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82C6A458: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C6A45C: 4803EFF4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6A460 => {
    //   block [0x82C6A460..0x82C6A498)
	// 82C6A460: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C6A464: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C6A468: 3BCB5974  addi r30, r11, 0x5974
	ctx.r[30].s64 = ctx.r[11].s64 + 22900;
	// 82C6A46C: 816A5978  lwz r11, 0x5978(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(22904 as u32) ) } as u64;
	// 82C6A470: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82C6A474: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C6A478: 409A0020  bne cr6, 0x82c6a498
	if !ctx.cr[6].eq {
	pc = 0x82C6A498; continue 'dispatch;
	}
	// 82C6A47C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82C6A480: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6A484: 916A5978  stw r11, 0x5978(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(22904 as u32), ctx.r[11].u32 ) };
	// 82C6A488: 4BEE8731  bl 0x82b52bb8
	ctx.lr = 0x82C6A48C;
	sub_82B52BB8(ctx, base);
	// 82C6A48C: 3D60832B  lis r11, -0x7cd5
	ctx.r[11].s64 = -2094333952;
	// 82C6A490: 386B7BC8  addi r3, r11, 0x7bc8
	ctx.r[3].s64 = ctx.r[11].s64 + 31688;
	// 82C6A494: 4803FA8D  bl 0x82ca9f20
	ctx.lr = 0x82C6A498;
	sub_82CA9F20(ctx, base);
	pc = 0x82C6A498; continue 'dispatch;
            }
            0x82C6A498 => {
    //   block [0x82C6A498..0x82C6A4D0)
	// 82C6A498: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C6A49C: 4B687B0D  bl 0x822f1fa8
	ctx.lr = 0x82C6A4A0;
	sub_822F1FA8(ctx, base);
	// 82C6A4A0: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82C6A4A4: 3BBF0058  addi r29, r31, 0x58
	ctx.r[29].s64 = ctx.r[31].s64 + 88;
	// 82C6A4A8: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82C6A4AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6A4B0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82C6A4B4: 4B914755  bl 0x8257ec08
	ctx.lr = 0x82C6A4B8;
	sub_8257EC08(ctx, base);
	// 82C6A4B8: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C6A4BC: 813F005C  lwz r9, 0x5c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C6A4C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C6A4C4: 419A000C  beq cr6, 0x82c6a4d0
	if ctx.cr[6].eq {
	pc = 0x82C6A4D0; continue 'dispatch;
	}
	// 82C6A4C8: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C6A4CC: 419A0008  beq cr6, 0x82c6a4d4
	if ctx.cr[6].eq {
	pc = 0x82C6A4D4; continue 'dispatch;
	}
	pc = 0x82C6A4D0; continue 'dispatch;
            }
            0x82C6A4D0 => {
    //   block [0x82C6A4D0..0x82C6A4D4)
	// 82C6A4D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6A4D4; continue 'dispatch;
            }
            0x82C6A4D4 => {
    //   block [0x82C6A4D4..0x82C6A4EC)
	// 82C6A4D4: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C6A4D8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C6A4DC: 419A0054  beq cr6, 0x82c6a530
	if ctx.cr[6].eq {
	pc = 0x82C6A530; continue 'dispatch;
	}
	// 82C6A4E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C6A4E4: 409A0008  bne cr6, 0x82c6a4ec
	if !ctx.cr[6].eq {
	pc = 0x82C6A4EC; continue 'dispatch;
	}
	// 82C6A4E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6A4EC; continue 'dispatch;
            }
            0x82C6A4EC => {
    //   block [0x82C6A4EC..0x82C6A4FC)
	// 82C6A4EC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6A4F0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6A4F4: 409A0008  bne cr6, 0x82c6a4fc
	if !ctx.cr[6].eq {
	pc = 0x82C6A4FC; continue 'dispatch;
	}
	// 82C6A4F8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6A4FC; continue 'dispatch;
            }
            0x82C6A4FC => {
    //   block [0x82C6A4FC..0x82C6A530)
	// 82C6A4FC: 3D208333  lis r9, -0x7ccd
	ctx.r[9].s64 = -2093809664;
	// 82C6A500: 81495970  lwz r10, 0x5970(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(22896 as u32) ) } as u64;
	// 82C6A504: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82C6A508: 81495970  lwz r10, 0x5970(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(22896 as u32) ) } as u64;
	// 82C6A50C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C6A510: 91495970  stw r10, 0x5970(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(22896 as u32), ctx.r[10].u32 ) };
	// 82C6A514: 806B0010  lwz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C6A518: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6A51C: 907A0000  stw r3, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C6A520: 419A01F0  beq cr6, 0x82c6a710
	if ctx.cr[6].eq {
	pc = 0x82C6A710; continue 'dispatch;
	}
	// 82C6A524: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A528: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6A52C: 480001DC  b 0x82c6a708
	pc = 0x82C6A708; continue 'dispatch;
            }
            0x82C6A530 => {
    //   block [0x82C6A530..0x82C6A56C)
	// 82C6A530: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82C6A534: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C6A538: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C6A53C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6A540: 4BEDAEB9  bl 0x82b453f8
	ctx.lr = 0x82C6A544;
	sub_82B453F8(ctx, base);
	// 82C6A544: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6A548: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C6A54C: 409A0020  bne cr6, 0x82c6a56c
	if !ctx.cr[6].eq {
	pc = 0x82C6A56C; continue 'dispatch;
	}
	// 82C6A550: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6A554: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C6A558: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C6A55C: 4B55905D  bl 0x821c35b8
	ctx.lr = 0x82C6A560;
	sub_821C35B8(ctx, base);
	// 82C6A560: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82C6A564: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C6A568: 4803EEE8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6A56C => {
    //   block [0x82C6A56C..0x82C6A5B8)
	// 82C6A56C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A570: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C6A574: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A578: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C6A57C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6A580: 4E800421  bctrl
	ctx.lr = 0x82C6A584;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6A584: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A588: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C6A58C: 7D09F050  subf r8, r9, r30
	ctx.r[8].s64 = ctx.r[30].s64 - ctx.r[9].s64;
	// 82C6A590: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6A594: 7D070034  cntlzw r7, r8
	ctx.r[7].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 82C6A598: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 82C6A59C: 68DE0001  xori r30, r6, 1
	ctx.r[30].u64 = ctx.r[6].u64 ^ 1;
	// 82C6A5A0: 419A0018  beq cr6, 0x82c6a5b8
	if ctx.cr[6].eq {
	pc = 0x82C6A5B8; continue 'dispatch;
	}
	// 82C6A5A4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A5A8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C6A5AC: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6A5B0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C6A5B4: 4E800421  bctrl
	ctx.lr = 0x82C6A5B8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6A5B8 => {
    //   block [0x82C6A5B8..0x82C6A600)
	// 82C6A5B8: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82C6A5BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6A5C0: 419A0128  beq cr6, 0x82c6a6e8
	if ctx.cr[6].eq {
	pc = 0x82C6A6E8; continue 'dispatch;
	}
	// 82C6A5C4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6A5C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A5CC: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6A5D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6A5D4: 4E800421  bctrl
	ctx.lr = 0x82C6A5D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6A5D8: 813F0064  lwz r9, 0x64(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C6A5DC: 547E003E  slwi r30, r3, 0
	ctx.r[30].u32 = ctx.r[3].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82C6A5E0: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C6A5E4: 41990104  bgt cr6, 0x82c6a6e8
	if ctx.cr[6].gt {
	pc = 0x82C6A6E8; continue 'dispatch;
	}
	// 82C6A5E8: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C6A5EC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6A5F0: 40990010  ble cr6, 0x82c6a600
	if !ctx.cr[6].gt {
	pc = 0x82C6A600; continue 'dispatch;
	}
	// 82C6A5F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C6A5F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6A5FC: 4BFFF0DD  bl 0x82c696d8
	ctx.lr = 0x82C6A600;
	sub_82C696D8(ctx, base);
            }
            0x82C6A600 => {
    //   block [0x82C6A600..0x82C6A648)
	// 82C6A600: 817F0068  lwz r11, 0x68(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C6A604: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C6A608: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82C6A60C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6A610: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82C6A614: 915F0068  stw r10, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82C6A618: 4BEE07F9  bl 0x82b4ae10
	ctx.lr = 0x82C6A61C;
	sub_82B4AE10(ctx, base);
	// 82C6A61C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82C6A620: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C6A624: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A628: 480001D9  bl 0x82c6a800
	ctx.lr = 0x82C6A62C;
	sub_82C6A800(ctx, base);
	// 82C6A62C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C6A630: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6A634: 419A0014  beq cr6, 0x82c6a648
	if ctx.cr[6].eq {
	pc = 0x82C6A648; continue 'dispatch;
	}
	// 82C6A638: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A63C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6A640: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6A644: 4E800421  bctrl
	ctx.lr = 0x82C6A648;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6A648 => {
    //   block [0x82C6A648..0x82C6A6C8)
	// 82C6A648: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6A64C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C6A650: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82C6A654: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82C6A658: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C6A65C: 4BC00735  bl 0x8286ad90
	ctx.lr = 0x82C6A660;
	sub_8286AD90(ctx, base);
	// 82C6A660: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C6A664: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C6A668: 816A5970  lwz r11, 0x5970(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(22896 as u32) ) } as u64;
	// 82C6A66C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82C6A670: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C6A674: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82C6A678: 916A5970  stw r11, 0x5970(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(22896 as u32), ctx.r[11].u32 ) };
	// 82C6A67C: 4B68792D  bl 0x822f1fa8
	ctx.lr = 0x82C6A680;
	sub_822F1FA8(ctx, base);
	// 82C6A680: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82C6A684: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82C6A688: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6A68C: 4BFFFC75  bl 0x82c6a300
	ctx.lr = 0x82C6A690;
	sub_82C6A300(ctx, base);
	// 82C6A690: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82C6A694: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C6A698: 4B8C0381  bl 0x8252aa18
	ctx.lr = 0x82C6A69C;
	sub_8252AA18(ctx, base);
	// 82C6A69C: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C6A6A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C6A6A4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82C6A6A8: 4B68B251  bl 0x822f58f8
	ctx.lr = 0x82C6A6AC;
	sub_822F58F8(ctx, base);
	// 82C6A6AC: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C6A6B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6A6B4: 419A0014  beq cr6, 0x82c6a6c8
	if ctx.cr[6].eq {
	pc = 0x82C6A6C8; continue 'dispatch;
	}
	// 82C6A6B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A6BC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6A6C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6A6C4: 4E800421  bctrl
	ctx.lr = 0x82C6A6C8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6A6C8 => {
    //   block [0x82C6A6C8..0x82C6A6E8)
	// 82C6A6C8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C6A6CC: 419A0028  beq cr6, 0x82c6a6f4
	if ctx.cr[6].eq {
	pc = 0x82C6A6F4; continue 'dispatch;
	}
	// 82C6A6D0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A6D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6A6D8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6A6DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6A6E0: 4E800421  bctrl
	ctx.lr = 0x82C6A6E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6A6E4: 48000010  b 0x82c6a6f4
	pc = 0x82C6A6F4; continue 'dispatch;
            }
            0x82C6A6E8 => {
    //   block [0x82C6A6E8..0x82C6A6F4)
	// 82C6A6E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C6A6EC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82C6A6F0: 4B68B209  bl 0x822f58f8
	ctx.lr = 0x82C6A6F4;
	sub_822F58F8(ctx, base);
	pc = 0x82C6A6F4; continue 'dispatch;
            }
            0x82C6A6F4 => {
    //   block [0x82C6A6F4..0x82C6A708)
	// 82C6A6F4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6A6F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6A6FC: 419A0014  beq cr6, 0x82c6a710
	if ctx.cr[6].eq {
	pc = 0x82C6A710; continue 'dispatch;
	}
	// 82C6A700: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A704: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82C6A708; continue 'dispatch;
            }
            0x82C6A708 => {
    //   block [0x82C6A708..0x82C6A710)
	// 82C6A708: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6A70C: 4E800421  bctrl
	ctx.lr = 0x82C6A710;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6A710 => {
    //   block [0x82C6A710..0x82C6A724)
	// 82C6A710: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C6A714: 4B558EA5  bl 0x821c35b8
	ctx.lr = 0x82C6A718;
	sub_821C35B8(ctx, base);
	// 82C6A718: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82C6A71C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C6A720: 4803ED30  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6A728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6A728 size=80
    let mut pc: u32 = 0x82C6A728;
    'dispatch: loop {
        match pc {
            0x82C6A728 => {
    //   block [0x82C6A728..0x82C6A760)
	// 82C6A728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6A72C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6A730: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6A734: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6A738: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6A73C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6A740: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C6A744: 4BFFFB45  bl 0x82c6a288
	ctx.lr = 0x82C6A748;
	sub_82C6A288(ctx, base);
	// 82C6A748: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C6A74C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6A750: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6A754: 419A000C  beq cr6, 0x82c6a760
	if ctx.cr[6].eq {
	pc = 0x82C6A760; continue 'dispatch;
	}
	// 82C6A758: 4BBDB059  bl 0x828457b0
	ctx.lr = 0x82C6A75C;
	sub_828457B0(ctx, base);
	// 82C6A75C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C6A760; continue 'dispatch;
            }
            0x82C6A760 => {
    //   block [0x82C6A760..0x82C6A778)
	// 82C6A760: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6A764: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6A768: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6A76C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6A770: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6A774: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6A778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6A778 size=132
    let mut pc: u32 = 0x82C6A778;
    'dispatch: loop {
        match pc {
            0x82C6A778 => {
    //   block [0x82C6A778..0x82C6A7D0)
	// 82C6A778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6A77C: 4803EC91  bl 0x82ca940c
	ctx.lr = 0x82C6A780;
	sub_82CA93D0(ctx, base);
	// 82C6A780: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6A784: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C6A788: 38600088  li r3, 0x88
	ctx.r[3].s64 = 136;
	// 82C6A78C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C6A790: 4B5B4AC9  bl 0x8221f258
	ctx.lr = 0x82C6A794;
	sub_8221F258(ctx, base);
	// 82C6A794: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6A798: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C6A79C: 419A0034  beq cr6, 0x82c6a7d0
	if ctx.cr[6].eq {
	pc = 0x82C6A7D0; continue 'dispatch;
	}
	// 82C6A7A0: 4BEDAB09  bl 0x82b452a8
	ctx.lr = 0x82C6A7A4;
	sub_82B452A8(ctx, base);
	// 82C6A7A4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C6A7A8: 387F0058  addi r3, r31, 0x58
	ctx.r[3].s64 = ctx.r[31].s64 + 88;
	// 82C6A7AC: 394BDE40  addi r10, r11, -0x21c0
	ctx.r[10].s64 = ctx.r[11].s64 + -8640;
	// 82C6A7B0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C6A7B4: 4BDAD76D  bl 0x82a17f20
	ctx.lr = 0x82C6A7B8;
	sub_82A17F20(ctx, base);
	// 82C6A7B8: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82C6A7BC: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82C6A7C0: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 82C6A7C4: 4BED30ED  bl 0x82b3d8b0
	ctx.lr = 0x82C6A7C8;
	sub_82B3D8B0(ctx, base);
	// 82C6A7C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6A7CC: 48000008  b 0x82c6a7d4
	pc = 0x82C6A7D4; continue 'dispatch;
            }
            0x82C6A7D0 => {
    //   block [0x82C6A7D0..0x82C6A7D4)
	// 82C6A7D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82C6A7D4; continue 'dispatch;
            }
            0x82C6A7D4 => {
    //   block [0x82C6A7D4..0x82C6A7F0)
	// 82C6A7D4: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C6A7D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6A7DC: 419A0014  beq cr6, 0x82c6a7f0
	if ctx.cr[6].eq {
	pc = 0x82C6A7F0; continue 'dispatch;
	}
	// 82C6A7E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A7E4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6A7E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6A7EC: 4E800421  bctrl
	ctx.lr = 0x82C6A7F0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6A7F0 => {
    //   block [0x82C6A7F0..0x82C6A7FC)
	// 82C6A7F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6A7F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6A7F8: 4803EC64  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6A800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6A800 size=76
    let mut pc: u32 = 0x82C6A800;
    'dispatch: loop {
        match pc {
            0x82C6A800 => {
    //   block [0x82C6A800..0x82C6A834)
	// 82C6A800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6A804: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6A808: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6A80C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6A810: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6A814: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C6A818: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82C6A81C: 419A0018  beq cr6, 0x82c6a834
	if ctx.cr[6].eq {
	pc = 0x82C6A834; continue 'dispatch;
	}
	// 82C6A820: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A824: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C6A828: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6A82C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6A830: 4E800421  bctrl
	ctx.lr = 0x82C6A834;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6A834 => {
    //   block [0x82C6A834..0x82C6A84C)
	// 82C6A834: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6A838: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6A83C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6A840: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6A844: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6A848: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6A850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6A850 size=120
    let mut pc: u32 = 0x82C6A850;
    'dispatch: loop {
        match pc {
            0x82C6A850 => {
    //   block [0x82C6A850..0x82C6A8A4)
	// 82C6A850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6A854: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6A858: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6A85C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6A860: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6A864: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C6A868: 419A003C  beq cr6, 0x82c6a8a4
	if ctx.cr[6].eq {
	pc = 0x82C6A8A4; continue 'dispatch;
	}
	// 82C6A86C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82C6A870: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 82C6A874: 2B0A0014  cmplwi cr6, r10, 0x14
	ctx.cr[6].compare_u32(ctx.r[10].u32, 20 as u32, &mut ctx.xer);
	// 82C6A878: 4098002C  bge cr6, 0x82c6a8a4
	if !ctx.cr[6].lt {
	pc = 0x82C6A8A4; continue 'dispatch;
	}
	// 82C6A87C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82C6A880: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C6A884: 392B1714  addi r9, r11, 0x1714
	ctx.r[9].s64 = ctx.r[11].s64 + 5908;
	// 82C6A888: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82C6A88C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6A890: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82C6A894: 4B68758D  bl 0x822f1e20
	ctx.lr = 0x82C6A898;
	sub_822F1E20(ctx, base);
	// 82C6A898: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82C6A89C: 38E81708  addi r7, r8, 0x1708
	ctx.r[7].s64 = ctx.r[8].s64 + 5896;
	// 82C6A8A0: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	pc = 0x82C6A8A4; continue 'dispatch;
            }
            0x82C6A8A4 => {
    //   block [0x82C6A8A4..0x82C6A8C8)
	// 82C6A8A4: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6A8A8: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82C6A8AC: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C6A8B0: 4B5B49A9  bl 0x8221f258
	ctx.lr = 0x82C6A8B4;
	sub_8221F258(ctx, base);
	// 82C6A8B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6A8B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6A8BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6A8C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6A8C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6A8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6A8C8 size=312
    let mut pc: u32 = 0x82C6A8C8;
    'dispatch: loop {
        match pc {
            0x82C6A8C8 => {
    //   block [0x82C6A8C8..0x82C6A900)
	// 82C6A8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6A8CC: 4803EB35  bl 0x82ca9400
	ctx.lr = 0x82C6A8D0;
	sub_82CA93D0(ctx, base);
	// 82C6A8D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6A8D4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82C6A8D8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82C6A8DC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C6A8E0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C6A8E4: 409A001C  bne cr6, 0x82c6a900
	if !ctx.cr[6].eq {
	pc = 0x82C6A900; continue 'dispatch;
	}
	// 82C6A8E8: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6A8EC: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6A8F0: 41990010  bgt cr6, 0x82c6a900
	if ctx.cr[6].gt {
	pc = 0x82C6A900; continue 'dispatch;
	}
	// 82C6A8F4: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82C6A8F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6A8FC: 4803EB54  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6A900 => {
    //   block [0x82C6A900..0x82C6A938)
	// 82C6A900: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6A904: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6A908: 409800C0  bge cr6, 0x82c6a9c8
	if !ctx.cr[6].lt {
	pc = 0x82C6A9C8; continue 'dispatch;
	}
	// 82C6A90C: 7D655850  subf r11, r5, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 82C6A910: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6A914: 419900B4  bgt cr6, 0x82c6a9c8
	if ctx.cr[6].gt {
	pc = 0x82C6A9C8; continue 'dispatch;
	}
	// 82C6A918: 815B0018  lwz r10, 0x18(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6A91C: 7D7C5850  subf r11, r28, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82C6A920: 3B5B0004  addi r26, r27, 4
	ctx.r[26].s64 = ctx.r[27].s64 + 4;
	// 82C6A924: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 82C6A928: 2B0A0010  cmplwi cr6, r10, 0x10
	ctx.cr[6].compare_u32(ctx.r[10].u32, 16 as u32, &mut ctx.xer);
	// 82C6A92C: 4198000C  blt cr6, 0x82c6a938
	if ctx.cr[6].lt {
	pc = 0x82C6A938; continue 'dispatch;
	}
	// 82C6A930: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6A934: 48000008  b 0x82c6a93c
	pc = 0x82C6A93C; continue 'dispatch;
            }
            0x82C6A938 => {
    //   block [0x82C6A938..0x82C6A93C)
	// 82C6A938: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82C6A93C; continue 'dispatch;
            }
            0x82C6A93C => {
    //   block [0x82C6A93C..0x82C6A95C)
	// 82C6A93C: 895D0000  lbz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A940: 7FEB2A14  add r31, r11, r5
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82C6A944: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C6A948: 7D440774  extsb r4, r10
	ctx.r[4].s64 = ctx.r[10].s8 as i64;
	// 82C6A94C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6A950: 48041631  bl 0x82cabf80
	ctx.lr = 0x82C6A954;
	sub_82CABF80(ctx, base);
	// 82C6A954: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6A958: 419A0070  beq cr6, 0x82c6a9c8
	if ctx.cr[6].eq {
	pc = 0x82C6A9C8; continue 'dispatch;
	}
	pc = 0x82C6A95C; continue 'dispatch;
            }
            0x82C6A95C => {
    //   block [0x82C6A95C..0x82C6A974)
	// 82C6A95C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82C6A960: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C6A964: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C6A968: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C6A96C: 419A0028  beq cr6, 0x82c6a994
	if ctx.cr[6].eq {
	pc = 0x82C6A994; continue 'dispatch;
	}
	// 82C6A970: 7D0BE214  add r8, r11, r28
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x82C6A974; continue 'dispatch;
            }
            0x82C6A974 => {
    //   block [0x82C6A974..0x82C6A994)
	// 82C6A974: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A978: 88EA0000  lbz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A97C: 7D274851  subf. r9, r7, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C6A980: 40820014  bne 0x82c6a994
	if !ctx.cr[0].eq {
	pc = 0x82C6A994; continue 'dispatch;
	}
	// 82C6A984: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C6A988: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C6A98C: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82C6A990: 409AFFE4  bne cr6, 0x82c6a974
	if !ctx.cr[6].eq {
	pc = 0x82C6A974; continue 'dispatch;
	}
	pc = 0x82C6A994; continue 'dispatch;
            }
            0x82C6A994 => {
    //   block [0x82C6A994..0x82C6A9C8)
	// 82C6A994: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C6A998: 419A003C  beq cr6, 0x82c6a9d4
	if ctx.cr[6].eq {
	pc = 0x82C6A9D4; continue 'dispatch;
	}
	// 82C6A99C: 7D63F850  subf r11, r3, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[3].s64;
	// 82C6A9A0: 895D0000  lbz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A9A4: 3BE30001  addi r31, r3, 1
	ctx.r[31].s64 = ctx.r[3].s64 + 1;
	// 82C6A9A8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C6A9AC: 7D440774  extsb r4, r10
	ctx.r[4].s64 = ctx.r[10].s8 as i64;
	// 82C6A9B0: 3BCBFFFF  addi r30, r11, -1
	ctx.r[30].s64 = ctx.r[11].s64 + -1;
	// 82C6A9B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6A9B8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C6A9BC: 480415C5  bl 0x82cabf80
	ctx.lr = 0x82C6A9C0;
	sub_82CABF80(ctx, base);
	// 82C6A9C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6A9C4: 409AFF98  bne cr6, 0x82c6a95c
	if !ctx.cr[6].eq {
	pc = 0x82C6A95C; continue 'dispatch;
	}
	pc = 0x82C6A9C8; continue 'dispatch;
            }
            0x82C6A9C8 => {
    //   block [0x82C6A9C8..0x82C6A9D4)
	// 82C6A9C8: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	// 82C6A9CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6A9D0: 4803EA80  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6A9D4 => {
    //   block [0x82C6A9D4..0x82C6A9F0)
	// 82C6A9D4: 817B0018  lwz r11, 0x18(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6A9D8: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 82C6A9DC: 41980014  blt cr6, 0x82c6a9f0
	if ctx.cr[6].lt {
	pc = 0x82C6A9F0; continue 'dispatch;
	}
	// 82C6A9E0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6A9E4: 7C6B1850  subf r3, r11, r3
	ctx.r[3].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82C6A9E8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6A9EC: 4803EA64  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6A9F0 => {
    //   block [0x82C6A9F0..0x82C6AA00)
	// 82C6A9F0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82C6A9F4: 7C6B1850  subf r3, r11, r3
	ctx.r[3].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82C6A9F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6A9FC: 4803EA54  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6AA00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6AA00 size=184
    let mut pc: u32 = 0x82C6AA00;
    'dispatch: loop {
        match pc {
            0x82C6AA00 => {
    //   block [0x82C6AA00..0x82C6AA40)
	// 82C6AA00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6AA04: 4803EA05  bl 0x82ca9408
	ctx.lr = 0x82C6AA08;
	sub_82CA93D0(ctx, base);
	// 82C6AA08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6AA0C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C6AA10: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C6AA14: 897D0005  lbz r11, 5(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(5 as u32) ) } as u64;
	// 82C6AA18: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82C6AA1C: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82C6AA20: 69280001  xori r8, r9, 1
	ctx.r[8].u64 = ctx.r[9].u64 ^ 1;
	// 82C6AA24: 5507063E  clrlwi r7, r8, 0x18
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82C6AA28: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82C6AA2C: 419A0054  beq cr6, 0x82c6aa80
	if ctx.cr[6].eq {
	pc = 0x82C6AA80; continue 'dispatch;
	}
	// 82C6AA30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C6AA34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C6AA38: 419A003C  beq cr6, 0x82c6aa74
	if ctx.cr[6].eq {
	pc = 0x82C6AA74; continue 'dispatch;
	}
	// 82C6AA3C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82C6AA40; continue 'dispatch;
            }
            0x82C6AA40 => {
    //   block [0x82C6AA40..0x82C6AA74)
	// 82C6AA40: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AA44: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 82C6AA48: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82C6AA4C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C6AA50: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82C6AA54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C6AA58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AA5C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6AA60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6AA64: 4E800421  bctrl
	ctx.lr = 0x82C6AA68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6AA68: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C6AA6C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C6AA70: 409AFFD0  bne cr6, 0x82c6aa40
	if !ctx.cr[6].eq {
	pc = 0x82C6AA40; continue 'dispatch;
	}
            }
            0x82C6AA74 => {
    //   block [0x82C6AA74..0x82C6AA80)
	// 82C6AA74: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C6AA78: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6AA7C: 4803E9DC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6AA80 => {
    //   block [0x82C6AA80..0x82C6AAB8)
	// 82C6AA80: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 82C6AA84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6AA88: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AA8C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C6AA90: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82C6AA94: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82C6AA98: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AA9C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6AAA0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C6AAA4: 4E800421  bctrl
	ctx.lr = 0x82C6AAA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6AAA8: 7C680034  cntlzw r8, r3
	ctx.r[8].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82C6AAAC: 5503DFFE  rlwinm r3, r8, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82C6AAB0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6AAB4: 4803E9A4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6AAB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6AAB8 size=112
    let mut pc: u32 = 0x82C6AAB8;
    'dispatch: loop {
        match pc {
            0x82C6AAB8 => {
    //   block [0x82C6AAB8..0x82C6AB00)
	// 82C6AAB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6AABC: 4803E951  bl 0x82ca940c
	ctx.lr = 0x82C6AAC0;
	sub_82CA93D0(ctx, base);
	// 82C6AAC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6AAC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6AAC8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C6AACC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C6AAD0: 394BDE78  addi r10, r11, -0x2188
	ctx.r[10].s64 = ctx.r[11].s64 + -8584;
	// 82C6AAD4: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 82C6AAD8: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82C6AADC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C6AAE0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C6AAE4: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82C6AAE8: 419A0018  beq cr6, 0x82c6ab00
	if ctx.cr[6].eq {
	pc = 0x82C6AB00; continue 'dispatch;
	}
	// 82C6AAEC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AAF0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C6AAF4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6AAF8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6AAFC: 4E800421  bctrl
	ctx.lr = 0x82C6AB00;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6AB00 => {
    //   block [0x82C6AB00..0x82C6AB28)
	// 82C6AB00: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AB04: FBBF0010  std r29, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u64 ) };
	// 82C6AB08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AB0C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C6AB10: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6AB14: 4E800421  bctrl
	ctx.lr = 0x82C6AB18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6AB18: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 82C6AB1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6AB20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6AB24: 4803E938  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6AB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C6AB28 size=12
    let mut pc: u32 = 0x82C6AB28;
    'dispatch: loop {
        match pc {
            0x82C6AB28 => {
    //   block [0x82C6AB28..0x82C6AB34)
	// 82C6AB28: F8830010  std r4, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[4].u64 ) };
	// 82C6AB2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C6AB30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6AB38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C6AB38 size=8
    let mut pc: u32 = 0x82C6AB38;
    'dispatch: loop {
        match pc {
            0x82C6AB38 => {
    //   block [0x82C6AB38..0x82C6AB40)
	// 82C6AB38: E8630010  ld r3, 0x10(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 82C6AB3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6AB40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6AB40 size=124
    let mut pc: u32 = 0x82C6AB40;
    'dispatch: loop {
        match pc {
            0x82C6AB40 => {
    //   block [0x82C6AB40..0x82C6AB9C)
	// 82C6AB40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6AB44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6AB48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6AB4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6AB50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6AB54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6AB58: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C6AB5C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C6AB60: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6AB64: 80FF0018  lwz r7, 0x18(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6AB68: E8BF0010  ld r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 82C6AB6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AB70: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6AB74: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6AB78: 4E800421  bctrl
	ctx.lr = 0x82C6AB7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6AB7C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C6AB80: 4198001C  blt cr6, 0x82c6ab9c
	if ctx.cr[6].lt {
	pc = 0x82C6AB9C; continue 'dispatch;
	}
	// 82C6AB84: E97F0010  ld r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	// 82C6AB88: 7BCA0020  clrldi r10, r30, 0x20
	ctx.r[10].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 82C6AB8C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C6AB90: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82C6AB94: F97F0010  std r11, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 82C6AB98: 4800000C  b 0x82c6aba4
	pc = 0x82C6ABA4; continue 'dispatch;
            }
            0x82C6AB9C => {
    //   block [0x82C6AB9C..0x82C6ABA4)
	// 82C6AB9C: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82C6ABA0: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	pc = 0x82C6ABA4; continue 'dispatch;
            }
            0x82C6ABA4 => {
    //   block [0x82C6ABA4..0x82C6ABBC)
	// 82C6ABA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6ABA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6ABAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6ABB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6ABB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6ABB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6ABC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6ABC0 size=116
    let mut pc: u32 = 0x82C6ABC0;
    'dispatch: loop {
        match pc {
            0x82C6ABC0 => {
    //   block [0x82C6ABC0..0x82C6ABF8)
	// 82C6ABC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6ABC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6ABC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6ABCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6ABD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6ABD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6ABD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C6ABDC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6ABE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6ABE4: 419A0014  beq cr6, 0x82c6abf8
	if ctx.cr[6].eq {
	pc = 0x82C6ABF8; continue 'dispatch;
	}
	// 82C6ABE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6ABEC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6ABF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6ABF4: 4E800421  bctrl
	ctx.lr = 0x82C6ABF8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6ABF8 => {
    //   block [0x82C6ABF8..0x82C6AC1C)
	// 82C6ABF8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82C6ABFC: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C6AC00: 392B4B00  addi r9, r11, 0x4b00
	ctx.r[9].s64 = ctx.r[11].s64 + 19200;
	// 82C6AC04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C6AC08: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C6AC0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6AC10: 419A000C  beq cr6, 0x82c6ac1c
	if ctx.cr[6].eq {
	pc = 0x82C6AC1C; continue 'dispatch;
	}
	// 82C6AC14: 4BBDAB9D  bl 0x828457b0
	ctx.lr = 0x82C6AC18;
	sub_828457B0(ctx, base);
	// 82C6AC18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C6AC1C; continue 'dispatch;
            }
            0x82C6AC1C => {
    //   block [0x82C6AC1C..0x82C6AC34)
	// 82C6AC1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6AC20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6AC24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6AC28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6AC2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6AC30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6AC38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6AC38 size=700
    let mut pc: u32 = 0x82C6AC38;
    'dispatch: loop {
        match pc {
            0x82C6AC38 => {
    //   block [0x82C6AC38..0x82C6AC64)
	// 82C6AC38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6AC3C: 4803E7C5  bl 0x82ca9400
	ctx.lr = 0x82C6AC40;
	sub_82CA93D0(ctx, base);
	// 82C6AC40: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6AC44: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82C6AC48: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C6AC4C: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82C6AC50: 409A0014  bne cr6, 0x82c6ac64
	if !ctx.cr[6].eq {
	pc = 0x82C6AC64; continue 'dispatch;
	}
	// 82C6AC54: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6AC58: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C6AC5C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C6AC60: 4803E7F0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6AC64 => {
    //   block [0x82C6AC64..0x82C6AC8C)
	// 82C6AC64: 817D0044  lwz r11, 0x44(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(68 as u32) ) } as u64;
	// 82C6AC68: 3B85FFFF  addi r28, r5, -1
	ctx.r[28].s64 = ctx.r[5].s64 + -1;
	// 82C6AC6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6AC70: 419A001C  beq cr6, 0x82c6ac8c
	if ctx.cr[6].eq {
	pc = 0x82C6AC8C; continue 'dispatch;
	}
	// 82C6AC74: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 82C6AC78: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 82C6AC7C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6AC80: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 82C6AC84: 7F1C3840  cmplw cr6, r28, r7
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C6AC88: 41980008  blt cr6, 0x82c6ac90
	if ctx.cr[6].lt {
	pc = 0x82C6AC90; continue 'dispatch;
	}
	pc = 0x82C6AC8C; continue 'dispatch;
            }
            0x82C6AC8C => {
    //   block [0x82C6AC8C..0x82C6AC90)
	// 82C6AC8C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6AC90; continue 'dispatch;
            }
            0x82C6AC90 => {
    //   block [0x82C6AC90..0x82C6ACDC)
	// 82C6AC90: 809D003C  lwz r4, 0x3c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 82C6AC94: 578A083C  slwi r10, r28, 1
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6AC98: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C6AC9C: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 82C6ACA0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6ACA4: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6ACA8: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82C6ACAC: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C6ACB0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C6ACB4: 4E800421  bctrl
	ctx.lr = 0x82C6ACB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6ACB8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C6ACBC: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6ACC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6ACC4: 419A0018  beq cr6, 0x82c6acdc
	if ctx.cr[6].eq {
	pc = 0x82C6ACDC; continue 'dispatch;
	}
	// 82C6ACC8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6ACCC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C6ACD0: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6ACD4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C6ACD8: 4E800421  bctrl
	ctx.lr = 0x82C6ACDC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6ACDC => {
    //   block [0x82C6ACDC..0x82C6AD1C)
	// 82C6ACDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6ACE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C6ACE4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C6ACE8: 4BEE7ED1  bl 0x82b52bb8
	ctx.lr = 0x82C6ACEC;
	sub_82B52BB8(ctx, base);
	// 82C6ACEC: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6ACF0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C6ACF4: 7D3E5050  subf r9, r30, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[30].s64;
	// 82C6ACF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6ACFC: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 82C6AD00: 551EDFFE  rlwinm r30, r8, 0x1b, 0x1f, 0x1f
	ctx.r[30].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82C6AD04: 419A0018  beq cr6, 0x82c6ad1c
	if ctx.cr[6].eq {
	pc = 0x82C6AD1C; continue 'dispatch;
	}
	// 82C6AD08: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AD0C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C6AD10: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6AD14: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C6AD18: 4E800421  bctrl
	ctx.lr = 0x82C6AD1C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6AD1C => {
    //   block [0x82C6AD1C..0x82C6AD98)
	// 82C6AD1C: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82C6AD20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6AD24: 419A00E8  beq cr6, 0x82c6ae0c
	if ctx.cr[6].eq {
	pc = 0x82C6AE0C; continue 'dispatch;
	}
	// 82C6AD28: 835D003C  lwz r26, 0x3c(r29)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 82C6AD2C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82C6AD30: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6AD34: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C6AD38: 4BEE0931  bl 0x82b4b668
	ctx.lr = 0x82C6AD3C;
	sub_82B4B668(ctx, base);
	// 82C6AD3C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82C6AD40: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82C6AD44: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C6AD48: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82C6AD4C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AD50: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6AD54: 7D0BF214  add r8, r11, r30
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C6AD58: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 82C6AD5C: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82C6AD60: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AD64: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6AD68: 4BEE0129  bl 0x82b4ae90
	ctx.lr = 0x82C6AD6C;
	sub_82B4AE90(ctx, base);
	// 82C6AD6C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82C6AD70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6AD74: 80870000  lwz r4, 0(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AD78: 4BC00019  bl 0x8286ad90
	ctx.lr = 0x82C6AD7C;
	sub_8286AD90(ctx, base);
	// 82C6AD7C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C6AD80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6AD84: 419A0014  beq cr6, 0x82c6ad98
	if ctx.cr[6].eq {
	pc = 0x82C6AD98; continue 'dispatch;
	}
	// 82C6AD88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AD8C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6AD90: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6AD94: 4E800421  bctrl
	ctx.lr = 0x82C6AD98;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6AD98 => {
    //   block [0x82C6AD98..0x82C6AD9C)
	// 82C6AD98: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82C6AD9C; continue 'dispatch;
            }
            0x82C6AD9C => {
    //   block [0x82C6AD9C..0x82C6ADD4)
	// 82C6AD9C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C6ADA0: 419A0114  beq cr6, 0x82c6aeb4
	if ctx.cr[6].eq {
	pc = 0x82C6AEB4; continue 'dispatch;
	}
	// 82C6ADA4: 897D0034  lbz r11, 0x34(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C6ADA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6ADAC: 419A0108  beq cr6, 0x82c6aeb4
	if ctx.cr[6].eq {
	pc = 0x82C6AEB4; continue 'dispatch;
	}
	// 82C6ADB0: 817D0054  lwz r11, 0x54(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C6ADB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6ADB8: 419A001C  beq cr6, 0x82c6add4
	if ctx.cr[6].eq {
	pc = 0x82C6ADD4; continue 'dispatch;
	}
	// 82C6ADBC: 815D0058  lwz r10, 0x58(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C6ADC0: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 82C6ADC4: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6ADC8: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 82C6ADCC: 7F1C3840  cmplw cr6, r28, r7
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C6ADD0: 41980008  blt cr6, 0x82c6add8
	if ctx.cr[6].lt {
	pc = 0x82C6ADD8; continue 'dispatch;
	}
	pc = 0x82C6ADD4; continue 'dispatch;
            }
            0x82C6ADD4 => {
    //   block [0x82C6ADD4..0x82C6ADD8)
	// 82C6ADD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6ADD8; continue 'dispatch;
            }
            0x82C6ADD8 => {
    //   block [0x82C6ADD8..0x82C6AE0C)
	// 82C6ADD8: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6ADDC: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82C6ADE0: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 82C6ADE4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6ADE8: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82C6ADEC: 4B5B446D  bl 0x8221f258
	ctx.lr = 0x82C6ADF0;
	sub_8221F258(ctx, base);
	// 82C6ADF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6ADF4: 419A00B0  beq cr6, 0x82c6aea4
	if ctx.cr[6].eq {
	pc = 0x82C6AEA4; continue 'dispatch;
	}
	// 82C6ADF8: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82C6ADFC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C6AE00: 48008629  bl 0x82c73428
	ctx.lr = 0x82C6AE04;
	sub_82C73428(ctx, base);
	// 82C6AE04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6AE08: 480000A0  b 0x82c6aea8
	pc = 0x82C6AEA8; continue 'dispatch;
            }
            0x82C6AE0C => {
    //   block [0x82C6AE0C..0x82C6AE38)
	// 82C6AE0C: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82C6AE10: 4B5B4449  bl 0x8221f258
	ctx.lr = 0x82C6AE14;
	sub_8221F258(ctx, base);
	// 82C6AE14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6AE18: 419A0020  beq cr6, 0x82c6ae38
	if ctx.cr[6].eq {
	pc = 0x82C6AE38; continue 'dispatch;
	}
	// 82C6AE1C: 80DD003C  lwz r6, 0x3c(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 82C6AE20: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AE24: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6AE28: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6AE2C: 48008135  bl 0x82c72f60
	ctx.lr = 0x82C6AE30;
	sub_82C72F60(ctx, base);
	// 82C6AE30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6AE34: 48000008  b 0x82c6ae3c
	pc = 0x82C6AE3C; continue 'dispatch;
            }
            0x82C6AE38 => {
    //   block [0x82C6AE38..0x82C6AE3C)
	// 82C6AE38: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82C6AE3C; continue 'dispatch;
            }
            0x82C6AE3C => {
    //   block [0x82C6AE3C..0x82C6AE84)
	// 82C6AE3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6AE40: 4BBFFF51  bl 0x8286ad90
	ctx.lr = 0x82C6AE44;
	sub_8286AD90(ctx, base);
	// 82C6AE44: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C6AE48: 4BEDB7F9  bl 0x82b46640
	ctx.lr = 0x82C6AE4C;
	sub_82B46640(ctx, base);
	// 82C6AE4C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C6AE50: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6AE54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6AE58: 419AFF44  beq cr6, 0x82c6ad9c
	if ctx.cr[6].eq {
	pc = 0x82C6AD9C; continue 'dispatch;
	}
	// 82C6AE5C: 4BEDB7D5  bl 0x82b46630
	ctx.lr = 0x82C6AE60;
	sub_82B46630(ctx, base);
	// 82C6AE60: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82C6AE64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C6AE68: 419AFF34  beq cr6, 0x82c6ad9c
	if ctx.cr[6].eq {
	pc = 0x82C6AD9C; continue 'dispatch;
	}
	// 82C6AE6C: 813D0020  lwz r9, 0x20(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C6AE70: 397D0008  addi r11, r29, 8
	ctx.r[11].s64 = ctx.r[29].s64 + 8;
	// 82C6AE74: 2B090008  cmplwi cr6, r9, 8
	ctx.cr[6].compare_u32(ctx.r[9].u32, 8 as u32, &mut ctx.xer);
	// 82C6AE78: 4198000C  blt cr6, 0x82c6ae84
	if ctx.cr[6].lt {
	pc = 0x82C6AE84; continue 'dispatch;
	}
	// 82C6AE7C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6AE80: 48000008  b 0x82c6ae88
	pc = 0x82C6AE88; continue 'dispatch;
            }
            0x82C6AE84 => {
    //   block [0x82C6AE84..0x82C6AE88)
	// 82C6AE84: 38AB0004  addi r5, r11, 4
	ctx.r[5].s64 = ctx.r[11].s64 + 4;
	pc = 0x82C6AE88; continue 'dispatch;
            }
            0x82C6AE88 => {
    //   block [0x82C6AE88..0x82C6AEA4)
	// 82C6AE88: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82C6AE8C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AE90: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C6AE94: 386B9830  addi r3, r11, -0x67d0
	ctx.r[3].s64 = ctx.r[11].s64 + -26576;
	// 82C6AE98: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6AE9C: 4E800421  bctrl
	ctx.lr = 0x82C6AEA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6AEA0: 4BFFFEFC  b 0x82c6ad9c
	pc = 0x82C6AD9C; continue 'dispatch;
            }
            0x82C6AEA4 => {
    //   block [0x82C6AEA4..0x82C6AEA8)
	// 82C6AEA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x82C6AEA8; continue 'dispatch;
            }
            0x82C6AEA8 => {
    //   block [0x82C6AEA8..0x82C6AEB4)
	// 82C6AEA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6AEAC: 4BBFFEE5  bl 0x8286ad90
	ctx.lr = 0x82C6AEB0;
	sub_8286AD90(ctx, base);
	// 82C6AEB0: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82C6AEB4; continue 'dispatch;
            }
            0x82C6AEB4 => {
    //   block [0x82C6AEB4..0x82C6AEE8)
	// 82C6AEB4: 93DB0000  stw r30, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82C6AEB8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C6AEBC: 419A002C  beq cr6, 0x82c6aee8
	if ctx.cr[6].eq {
	pc = 0x82C6AEE8; continue 'dispatch;
	}
	// 82C6AEC0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AEC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6AEC8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6AECC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6AED0: 4E800421  bctrl
	ctx.lr = 0x82C6AED4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6AED4: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AED8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6AEDC: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6AEE0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C6AEE4: 4E800421  bctrl
	ctx.lr = 0x82C6AEE8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6AEE8 => {
    //   block [0x82C6AEE8..0x82C6AEF4)
	// 82C6AEE8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C6AEEC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C6AEF0: 4803E560  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6AEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6AEF8 size=136
    let mut pc: u32 = 0x82C6AEF8;
    'dispatch: loop {
        match pc {
            0x82C6AEF8 => {
    //   block [0x82C6AEF8..0x82C6AF28)
	// 82C6AEF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6AEFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6AF00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6AF04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6AF08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6AF0C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C6AF10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C6AF14: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C6AF18: 409A0010  bne cr6, 0x82c6af28
	if !ctx.cr[6].eq {
	pc = 0x82C6AF28; continue 'dispatch;
	}
	// 82C6AF1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6AF20: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C6AF24: 48000040  b 0x82c6af64
	pc = 0x82C6AF64; continue 'dispatch;
            }
            0x82C6AF28 => {
    //   block [0x82C6AF28..0x82C6AF44)
	// 82C6AF28: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82C6AF2C: 4B5B432D  bl 0x8221f258
	ctx.lr = 0x82C6AF30;
	sub_8221F258(ctx, base);
	// 82C6AF30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6AF34: 419A0010  beq cr6, 0x82c6af44
	if ctx.cr[6].eq {
	pc = 0x82C6AF44; continue 'dispatch;
	}
	// 82C6AF38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C6AF3C: 4BFFFB7D  bl 0x82c6aab8
	ctx.lr = 0x82C6AF40;
	sub_82C6AAB8(ctx, base);
	// 82C6AF40: 48000008  b 0x82c6af48
	pc = 0x82C6AF48; continue 'dispatch;
            }
            0x82C6AF44 => {
    //   block [0x82C6AF44..0x82C6AF48)
	// 82C6AF44: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82C6AF48; continue 'dispatch;
            }
            0x82C6AF48 => {
    //   block [0x82C6AF48..0x82C6AF64)
	// 82C6AF48: 907E0000  stw r3, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C6AF4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6AF50: 419A0014  beq cr6, 0x82c6af64
	if ctx.cr[6].eq {
	pc = 0x82C6AF64; continue 'dispatch;
	}
	// 82C6AF54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AF58: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6AF5C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6AF60: 4E800421  bctrl
	ctx.lr = 0x82C6AF64;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6AF64 => {
    //   block [0x82C6AF64..0x82C6AF80)
	// 82C6AF64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6AF68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6AF6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6AF70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6AF74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6AF78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6AF7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6AF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C6AF80 size=92
    let mut pc: u32 = 0x82C6AF80;
    'dispatch: loop {
        match pc {
            0x82C6AF80 => {
    //   block [0x82C6AF80..0x82C6AFB0)
	// 82C6AF80: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82C6AF84: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82C6AF88: 3900000C  li r8, 0xc
	ctx.r[8].s64 = 12;
	// 82C6AF8C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C6AF90: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6AF94: 7D2943D6  divw r9, r9, r8
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	// 82C6AF98: 5528083C  slwi r8, r9, 1
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C6AF9C: 7CE94214  add r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82C6AFA0: 54E6103A  slwi r6, r7, 2
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82C6AFA4: 7C662850  subf r3, r6, r5
	ctx.r[3].s64 = ctx.r[5].s64 - ctx.r[6].s64;
	// 82C6AFA8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C6AFAC: 7D2B2850  subf r9, r11, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	pc = 0x82C6AFB0; continue 'dispatch;
            }
            0x82C6AFB0 => {
    //   block [0x82C6AFB0..0x82C6AFDC)
	// 82C6AFB0: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 82C6AFB4: 7D095A14  add r8, r9, r11
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82C6AFB8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6AFBC: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6AFC0: 7CE9592E  stwx r7, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 82C6AFC4: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6AFC8: 90C80004  stw r6, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82C6AFCC: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6AFD0: 90A80008  stw r5, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82C6AFD4: 409AFFDC  bne cr6, 0x82c6afb0
	if !ctx.cr[6].eq {
	pc = 0x82C6AFB0; continue 'dispatch;
	}
	// 82C6AFD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6AFE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C6AFE0 size=88
    let mut pc: u32 = 0x82C6AFE0;
    'dispatch: loop {
        match pc {
            0x82C6AFE0 => {
    //   block [0x82C6AFE0..0x82C6B000)
	// 82C6AFE0: F8610010  std r3, 0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(16 as u32), ctx.r[3].u64 ) };
	// 82C6AFE4: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82C6AFE8: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 82C6AFEC: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6AFF0: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6AFF4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6AFF8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C6AFFC: 7D655850  subf r11, r5, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	pc = 0x82C6B000; continue 'dispatch;
            }
            0x82C6B000 => {
    //   block [0x82C6B000..0x82C6B024)
	// 82C6B000: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6B004: 419A0020  beq cr6, 0x82c6b024
	if ctx.cr[6].eq {
	pc = 0x82C6B024; continue 'dispatch;
	}
	// 82C6B008: 7D2B182E  lwzx r9, r11, r3
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82C6B00C: 7D0B1A14  add r8, r11, r3
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82C6B010: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C6B014: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B018: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82C6B01C: 80C80008  lwz r6, 8(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B020: 90C30008  stw r6, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x82C6B024; continue 'dispatch;
            }
            0x82C6B024 => {
    //   block [0x82C6B024..0x82C6B038)
	// 82C6B024: 3863000C  addi r3, r3, 0xc
	ctx.r[3].s64 = ctx.r[3].s64 + 12;
	// 82C6B028: 7D2B1A14  add r9, r11, r3
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82C6B02C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6B030: 409AFFD0  bne cr6, 0x82c6b000
	if !ctx.cr[6].eq {
	pc = 0x82C6B000; continue 'dispatch;
	}
	// 82C6B034: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6B038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6B038 size=80
    let mut pc: u32 = 0x82C6B038;
    'dispatch: loop {
        match pc {
            0x82C6B038 => {
    //   block [0x82C6B038..0x82C6B088)
	// 82C6B038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6B03C: 4803E3D1  bl 0x82ca940c
	ctx.lr = 0x82C6B040;
	sub_82CA93D0(ctx, base);
	// 82C6B040: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6B044: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6B048: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6B04C: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 82C6B050: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C6B054: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82C6B058: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82C6B05C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6B060: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C6B064: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C6B068: B17F0004  sth r11, 4(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 82C6B06C: 4B68B62D  bl 0x822f6698
	ctx.lr = 0x82C6B070;
	sub_822F6698(ctx, base);
	// 82C6B070: 813E001C  lwz r9, 0x1c(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6B074: 93BF0020  stw r29, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u32 ) };
	// 82C6B078: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6B07C: 913F001C  stw r9, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 82C6B080: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6B084: 4803E3D8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6B088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6B088 size=936
    let mut pc: u32 = 0x82C6B088;
    'dispatch: loop {
        match pc {
            0x82C6B088 => {
    //   block [0x82C6B088..0x82C6B0C4)
	// 82C6B088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6B08C: 4803E369  bl 0x82ca93f4
	ctx.lr = 0x82C6B090;
	sub_82CA93D0(ctx, base);
	// 82C6B090: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6B094: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C6B098: 83260000  lwz r25, 0(r6)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6B09C: 83060004  lwz r24, 4(r6)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B0A0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C6B0A4: 82E60008  lwz r23, 8(r6)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B0A8: 3B40000C  li r26, 0xc
	ctx.r[26].s64 = 12;
	// 82C6B0AC: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 82C6B0B0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B0B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6B0B8: 409A000C  bne cr6, 0x82c6b0c4
	if !ctx.cr[6].eq {
	pc = 0x82C6B0C4; continue 'dispatch;
	}
	// 82C6B0BC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82C6B0C0: 48000010  b 0x82c6b0d0
	pc = 0x82C6B0D0; continue 'dispatch;
            }
            0x82C6B0C4 => {
    //   block [0x82C6B0C4..0x82C6B0D0)
	// 82C6B0C4: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6B0C8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6B0CC: 7D09D3D6  divw r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	pc = 0x82C6B0D0; continue 'dispatch;
            }
            0x82C6B0D0 => {
    //   block [0x82C6B0D0..0x82C6B0E8)
	// 82C6B0D0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C6B0D4: 419A0354  beq cr6, 0x82c6b428
	if ctx.cr[6].eq {
	pc = 0x82C6B428; continue 'dispatch;
	}
	// 82C6B0D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6B0DC: 409A000C  bne cr6, 0x82c6b0e8
	if !ctx.cr[6].eq {
	pc = 0x82C6B0E8; continue 'dispatch;
	}
	// 82C6B0E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C6B0E4: 48000010  b 0x82c6b0f4
	pc = 0x82C6B0F4; continue 'dispatch;
            }
            0x82C6B0E8 => {
    //   block [0x82C6B0E8..0x82C6B0F4)
	// 82C6B0E8: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B0EC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6B0F0: 7D49D3D6  divw r10, r9, r26
	ctx.r[10].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	pc = 0x82C6B0F4; continue 'dispatch;
            }
            0x82C6B0F4 => {
    //   block [0x82C6B0F4..0x82C6B114)
	// 82C6B0F4: 3D201555  lis r9, 0x1555
	ctx.r[9].s64 = 357892096;
	// 82C6B0F8: 61295555  ori r9, r9, 0x5555
	ctx.r[9].u64 = ctx.r[9].u64 | 21845;
	// 82C6B0FC: 7CEA4850  subf r7, r10, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82C6B100: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C6B104: 40980010  bge cr6, 0x82c6b114
	if !ctx.cr[6].lt {
	pc = 0x82C6B114; continue 'dispatch;
	}
	// 82C6B108: 4BF94361  bl 0x82bff468
	ctx.lr = 0x82C6B10C;
	sub_82BFF468(ctx, base);
	// 82C6B10C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C6B110: 4803E334  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6B114 => {
    //   block [0x82C6B114..0x82C6B124)
	// 82C6B114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6B118: 409A000C  bne cr6, 0x82c6b124
	if !ctx.cr[6].eq {
	pc = 0x82C6B124; continue 'dispatch;
	}
	// 82C6B11C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C6B120: 48000010  b 0x82c6b130
	pc = 0x82C6B130; continue 'dispatch;
            }
            0x82C6B124 => {
    //   block [0x82C6B124..0x82C6B130)
	// 82C6B124: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B128: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6B12C: 7D47D3D6  divw r10, r7, r26
	ctx.r[10].s32 = ctx.r[7].s32 / ctx.r[26].s32;
	pc = 0x82C6B130; continue 'dispatch;
            }
            0x82C6B130 => {
    //   block [0x82C6B130..0x82C6B154)
	// 82C6B130: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82C6B134: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6B138: 4098019C  bge cr6, 0x82c6b2d4
	if !ctx.cr[6].lt {
	pc = 0x82C6B2D4; continue 'dispatch;
	}
	// 82C6B13C: 550AF87E  srwi r10, r8, 1
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6B140: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82C6B144: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82C6B148: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C6B14C: 41980008  blt cr6, 0x82c6b154
	if ctx.cr[6].lt {
	pc = 0x82C6B154; continue 'dispatch;
	}
	// 82C6B150: 7F6A4214  add r27, r10, r8
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	pc = 0x82C6B154; continue 'dispatch;
            }
            0x82C6B154 => {
    //   block [0x82C6B154..0x82C6B164)
	// 82C6B154: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6B158: 409A000C  bne cr6, 0x82c6b164
	if !ctx.cr[6].eq {
	pc = 0x82C6B164; continue 'dispatch;
	}
	// 82C6B15C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C6B160: 48000010  b 0x82c6b170
	pc = 0x82C6B170; continue 'dispatch;
            }
            0x82C6B164 => {
    //   block [0x82C6B164..0x82C6B170)
	// 82C6B164: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B168: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6B16C: 7D49D3D6  divw r10, r9, r26
	ctx.r[10].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	pc = 0x82C6B170; continue 'dispatch;
            }
            0x82C6B170 => {
    //   block [0x82C6B170..0x82C6B190)
	// 82C6B170: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82C6B174: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6B178: 4098001C  bge cr6, 0x82c6b194
	if !ctx.cr[6].lt {
	pc = 0x82C6B194; continue 'dispatch;
	}
	// 82C6B17C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6B180: 419A0010  beq cr6, 0x82c6b190
	if ctx.cr[6].eq {
	pc = 0x82C6B190; continue 'dispatch;
	}
	// 82C6B184: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B188: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6B18C: 7D69D3D6  divw r11, r9, r26
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	pc = 0x82C6B190; continue 'dispatch;
            }
            0x82C6B190 => {
    //   block [0x82C6B190..0x82C6B194)
	// 82C6B190: 7F6BF214  add r27, r11, r30
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	pc = 0x82C6B194; continue 'dispatch;
            }
            0x82C6B194 => {
    //   block [0x82C6B194..0x82C6B1B8)
	// 82C6B194: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C6B198: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C6B19C: 4BFD70E5  bl 0x82c42280
	ctx.lr = 0x82C6B1A0;
	sub_82C42280(ctx, base);
	// 82C6B1A0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B1A4: 80E100BC  lwz r7, 0xbc(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82C6B1A8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C6B1AC: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C6B1B0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82C6B1B4: 419A0034  beq cr6, 0x82c6b1e8
	if ctx.cr[6].eq {
	pc = 0x82C6B1E8; continue 'dispatch;
	}
	pc = 0x82C6B1B8; continue 'dispatch;
            }
            0x82C6B1B8 => {
    //   block [0x82C6B1B8..0x82C6B1D8)
	// 82C6B1B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C6B1BC: 419A001C  beq cr6, 0x82c6b1d8
	if ctx.cr[6].eq {
	pc = 0x82C6B1D8; continue 'dispatch;
	}
	// 82C6B1C0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6B1C4: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C6B1C8: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B1CC: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82C6B1D0: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B1D4: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x82C6B1D8; continue 'dispatch;
            }
            0x82C6B1D8 => {
    //   block [0x82C6B1D8..0x82C6B1E8)
	// 82C6B1D8: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82C6B1DC: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82C6B1E0: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C6B1E4: 409AFFD4  bne cr6, 0x82c6b1b8
	if !ctx.cr[6].eq {
	pc = 0x82C6B1B8; continue 'dispatch;
	}
	pc = 0x82C6B1E8; continue 'dispatch;
            }
            0x82C6B1E8 => {
    //   block [0x82C6B1E8..0x82C6B1F8)
	// 82C6B1E8: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82C6B1EC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82C6B1F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C6B1F4: 419A0024  beq cr6, 0x82c6b218
	if ctx.cr[6].eq {
	pc = 0x82C6B218; continue 'dispatch;
	}
	pc = 0x82C6B1F8; continue 'dispatch;
            }
            0x82C6B1F8 => {
    //   block [0x82C6B1F8..0x82C6B20C)
	// 82C6B1F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6B1FC: 419A0010  beq cr6, 0x82c6b20c
	if ctx.cr[6].eq {
	pc = 0x82C6B20C; continue 'dispatch;
	}
	// 82C6B200: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82C6B204: 930B0004  stw r24, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 82C6B208: 92EB0008  stw r23, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	pc = 0x82C6B20C; continue 'dispatch;
            }
            0x82C6B20C => {
    //   block [0x82C6B20C..0x82C6B218)
	// 82C6B20C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82C6B210: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82C6B214: 4082FFE4  bne 0x82c6b1f8
	if !ctx.cr[0].eq {
	pc = 0x82C6B1F8; continue 'dispatch;
	}
	pc = 0x82C6B218; continue 'dispatch;
            }
            0x82C6B218 => {
    //   block [0x82C6B218..0x82C6B240)
	// 82C6B218: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6B21C: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B220: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82C6B224: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C6B228: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C6B22C: 7D695214  add r11, r9, r10
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82C6B230: 419A0040  beq cr6, 0x82c6b270
	if ctx.cr[6].eq {
	pc = 0x82C6B270; continue 'dispatch;
	}
	// 82C6B234: 7D295850  subf r9, r9, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82C6B238: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82C6B23C: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	pc = 0x82C6B240; continue 'dispatch;
            }
            0x82C6B240 => {
    //   block [0x82C6B240..0x82C6B260)
	// 82C6B240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6B244: 419A001C  beq cr6, 0x82c6b260
	if ctx.cr[6].eq {
	pc = 0x82C6B260; continue 'dispatch;
	}
	// 82C6B248: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6B24C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C6B250: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B254: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82C6B258: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B25C: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x82C6B260; continue 'dispatch;
            }
            0x82C6B260 => {
    //   block [0x82C6B260..0x82C6B270)
	// 82C6B260: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82C6B264: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82C6B268: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C6B26C: 409AFFD4  bne cr6, 0x82c6b240
	if !ctx.cr[6].eq {
	pc = 0x82C6B240; continue 'dispatch;
	}
	pc = 0x82C6B270; continue 'dispatch;
            }
            0x82C6B270 => {
    //   block [0x82C6B270..0x82C6B284)
	// 82C6B270: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B274: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6B278: 409A000C  bne cr6, 0x82c6b284
	if !ctx.cr[6].eq {
	pc = 0x82C6B284; continue 'dispatch;
	}
	// 82C6B27C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6B280: 48000010  b 0x82c6b290
	pc = 0x82C6B290; continue 'dispatch;
            }
            0x82C6B284 => {
    //   block [0x82C6B284..0x82C6B290)
	// 82C6B284: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B288: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82C6B28C: 7D6AD3D6  divw r11, r10, r26
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	pc = 0x82C6B290; continue 'dispatch;
            }
            0x82C6B290 => {
    //   block [0x82C6B290..0x82C6B2A0)
	// 82C6B290: 7FEBF214  add r31, r11, r30
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C6B294: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6B298: 419A0008  beq cr6, 0x82c6b2a0
	if ctx.cr[6].eq {
	pc = 0x82C6B2A0; continue 'dispatch;
	}
	// 82C6B29C: 4BBDA515  bl 0x828457b0
	ctx.lr = 0x82C6B2A0;
	sub_828457B0(ctx, base);
	pc = 0x82C6B2A0; continue 'dispatch;
            }
            0x82C6B2A0 => {
    //   block [0x82C6B2A0..0x82C6B2D4)
	// 82C6B2A0: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6B2A4: 939D0004  stw r28, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82C6B2A8: 576A083C  slwi r10, r27, 1
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6B2AC: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82C6B2B0: 7D5B5214  add r10, r27, r10
	ctx.r[10].u64 = ctx.r[27].u64 + ctx.r[10].u64;
	// 82C6B2B4: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6B2B8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6B2BC: 7CEBE214  add r7, r11, r28
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82C6B2C0: 7D0AE214  add r8, r10, r28
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 82C6B2C4: 90FD0008  stw r7, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82C6B2C8: 911D000C  stw r8, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82C6B2CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C6B2D0: 4803E174  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6B2D4 => {
    //   block [0x82C6B2D4..0x82C6B308)
	// 82C6B2D4: 83E100BC  lwz r31, 0xbc(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82C6B2D8: 80BD0008  lwz r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B2DC: 7D7F2850  subf r11, r31, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[31].s64;
	// 82C6B2E0: 7D4BD3D6  divw r10, r11, r26
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 82C6B2E4: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6B2E8: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C6B2EC: 409800BC  bge cr6, 0x82c6b3a8
	if !ctx.cr[6].lt {
	pc = 0x82C6B3A8; continue 'dispatch;
	}
	// 82C6B2F0: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82C6B2F4: 7F1F2840  cmplw cr6, r31, r5
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C6B2F8: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C6B2FC: 7D68FA14  add r11, r8, r31
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[31].u64;
	// 82C6B300: 419A0038  beq cr6, 0x82c6b338
	if ctx.cr[6].eq {
	pc = 0x82C6B338; continue 'dispatch;
	}
	// 82C6B304: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	pc = 0x82C6B308; continue 'dispatch;
            }
            0x82C6B308 => {
    //   block [0x82C6B308..0x82C6B328)
	// 82C6B308: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6B30C: 419A001C  beq cr6, 0x82c6b328
	if ctx.cr[6].eq {
	pc = 0x82C6B328; continue 'dispatch;
	}
	// 82C6B310: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6B314: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C6B318: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B31C: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82C6B320: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B324: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x82C6B328; continue 'dispatch;
            }
            0x82C6B328 => {
    //   block [0x82C6B328..0x82C6B338)
	// 82C6B328: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82C6B32C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82C6B330: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C6B334: 409AFFD4  bne cr6, 0x82c6b308
	if !ctx.cr[6].eq {
	pc = 0x82C6B308; continue 'dispatch;
	}
	pc = 0x82C6B338; continue 'dispatch;
            }
            0x82C6B338 => {
    //   block [0x82C6B338..0x82C6B34C)
	// 82C6B338: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B33C: 7D5F5850  subf r10, r31, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 82C6B340: 7D2AD3D6  divw r9, r10, r26
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	// 82C6B344: 7D49F051  subf. r10, r9, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C6B348: 41820024  beq 0x82c6b36c
	if ctx.cr[0].eq {
	pc = 0x82C6B36C; continue 'dispatch;
	}
	pc = 0x82C6B34C; continue 'dispatch;
            }
            0x82C6B34C => {
    //   block [0x82C6B34C..0x82C6B360)
	// 82C6B34C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6B350: 419A0010  beq cr6, 0x82c6b360
	if ctx.cr[6].eq {
	pc = 0x82C6B360; continue 'dispatch;
	}
	// 82C6B354: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82C6B358: 930B0004  stw r24, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 82C6B35C: 92EB0008  stw r23, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	pc = 0x82C6B360; continue 'dispatch;
            }
            0x82C6B360 => {
    //   block [0x82C6B360..0x82C6B36C)
	// 82C6B360: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C6B364: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82C6B368: 4082FFE4  bne 0x82c6b34c
	if !ctx.cr[0].eq {
	pc = 0x82C6B34C; continue 'dispatch;
	}
	pc = 0x82C6B36C; continue 'dispatch;
            }
            0x82C6B36C => {
    //   block [0x82C6B36C..0x82C6B388)
	// 82C6B36C: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B370: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82C6B374: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82C6B378: 7D484850  subf r10, r8, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82C6B37C: 913D0008  stw r9, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C6B380: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6B384: 419A00A4  beq cr6, 0x82c6b428
	if ctx.cr[6].eq {
	pc = 0x82C6B428; continue 'dispatch;
	}
	pc = 0x82C6B388; continue 'dispatch;
            }
            0x82C6B388 => {
    //   block [0x82C6B388..0x82C6B3A8)
	// 82C6B388: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82C6B38C: 930B0004  stw r24, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 82C6B390: 92EB0008  stw r23, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 82C6B394: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82C6B398: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6B39C: 409AFFEC  bne cr6, 0x82c6b388
	if !ctx.cr[6].eq {
	pc = 0x82C6B388; continue 'dispatch;
	}
	// 82C6B3A0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C6B3A4: 4803E0A0  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6B3A8 => {
    //   block [0x82C6B3A8..0x82C6B3C4)
	// 82C6B3A8: 7D5E5A14  add r10, r30, r11
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82C6B3AC: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82C6B3B0: 555E103A  slwi r30, r10, 2
	ctx.r[30].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82C6B3B4: 7C9E2850  subf r4, r30, r5
	ctx.r[4].s64 = ctx.r[5].s64 - ctx.r[30].s64;
	// 82C6B3B8: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82C6B3BC: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C6B3C0: 419A0034  beq cr6, 0x82c6b3f4
	if ctx.cr[6].eq {
	pc = 0x82C6B3F4; continue 'dispatch;
	}
	pc = 0x82C6B3C4; continue 'dispatch;
            }
            0x82C6B3C4 => {
    //   block [0x82C6B3C4..0x82C6B3E4)
	// 82C6B3C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6B3C8: 419A001C  beq cr6, 0x82c6b3e4
	if ctx.cr[6].eq {
	pc = 0x82C6B3E4; continue 'dispatch;
	}
	// 82C6B3CC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6B3D0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C6B3D4: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B3D8: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82C6B3DC: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B3E0: 90EB0008  stw r7, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	pc = 0x82C6B3E4; continue 'dispatch;
            }
            0x82C6B3E4 => {
    //   block [0x82C6B3E4..0x82C6B3F4)
	// 82C6B3E4: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82C6B3E8: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82C6B3EC: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C6B3F0: 409AFFD4  bne cr6, 0x82c6b3c4
	if !ctx.cr[6].eq {
	pc = 0x82C6B3C4; continue 'dispatch;
	}
	pc = 0x82C6B3F4; continue 'dispatch;
            }
            0x82C6B3F4 => {
    //   block [0x82C6B3F4..0x82C6B410)
	// 82C6B3F4: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C6B3F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6B3FC: 4BFFFB85  bl 0x82c6af80
	ctx.lr = 0x82C6B400;
	sub_82C6AF80(ctx, base);
	// 82C6B400: 7D5EFA14  add r10, r30, r31
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 82C6B404: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82C6B408: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6B40C: 419A001C  beq cr6, 0x82c6b428
	if ctx.cr[6].eq {
	pc = 0x82C6B428; continue 'dispatch;
	}
	pc = 0x82C6B410; continue 'dispatch;
            }
            0x82C6B410 => {
    //   block [0x82C6B410..0x82C6B428)
	// 82C6B410: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82C6B414: 930B0004  stw r24, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 82C6B418: 92EB0008  stw r23, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 82C6B41C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82C6B420: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6B424: 409AFFEC  bne cr6, 0x82c6b410
	if !ctx.cr[6].eq {
	pc = 0x82C6B410; continue 'dispatch;
	}
	pc = 0x82C6B428; continue 'dispatch;
            }
            0x82C6B428 => {
    //   block [0x82C6B428..0x82C6B430)
	// 82C6B428: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C6B42C: 4803E018  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6B430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6B430 size=148
    let mut pc: u32 = 0x82C6B430;
    'dispatch: loop {
        match pc {
            0x82C6B430 => {
    //   block [0x82C6B430..0x82C6B460)
	// 82C6B430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6B434: 4803DFD9  bl 0x82ca940c
	ctx.lr = 0x82C6B438;
	sub_82CA93D0(ctx, base);
	// 82C6B438: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6B43C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C6B440: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C6B444: 897D0004  lbz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6B44C: 419A0014  beq cr6, 0x82c6b460
	if ctx.cr[6].eq {
	pc = 0x82C6B460; continue 'dispatch;
	}
	// 82C6B450: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C6B454: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6B458: 4801F689  bl 0x82c8aae0
	ctx.lr = 0x82C6B45C;
	sub_82C8AAE0(ctx, base);
	// 82C6B45C: 987D0004  stb r3, 4(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u8 ) };
	pc = 0x82C6B460; continue 'dispatch;
            }
            0x82C6B460 => {
    //   block [0x82C6B460..0x82C6B488)
	// 82C6B460: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6B464: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6B468: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6B46C: 388AFFFF  addi r4, r10, -1
	ctx.r[4].s64 = ctx.r[10].s64 + -1;
	// 82C6B470: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 82C6B474: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6B478: 41990010  bgt cr6, 0x82c6b488
	if ctx.cr[6].gt {
	pc = 0x82C6B488; continue 'dispatch;
	}
	// 82C6B47C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82C6B480: 4B686A01  bl 0x822f1e80
	ctx.lr = 0x82C6B484;
	sub_822F1E80(ctx, base);
	// 82C6B484: 48000010  b 0x82c6b494
	pc = 0x82C6B494; continue 'dispatch;
            }
            0x82C6B488 => {
    //   block [0x82C6B488..0x82C6B494)
	// 82C6B488: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6B48C: 7C8B2050  subf r4, r11, r4
	ctx.r[4].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 82C6B490: 4BA0F3B9  bl 0x8267a848
	ctx.lr = 0x82C6B494;
	sub_8267A848(ctx, base);
	pc = 0x82C6B494; continue 'dispatch;
            }
            0x82C6B494 => {
    //   block [0x82C6B494..0x82C6B4A8)
	// 82C6B494: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6B498: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 82C6B49C: 4198000C  blt cr6, 0x82c6b4a8
	if ctx.cr[6].lt {
	pc = 0x82C6B4A8; continue 'dispatch;
	}
	// 82C6B4A0: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B4A4: 48000008  b 0x82c6b4ac
	pc = 0x82C6B4AC; continue 'dispatch;
            }
            0x82C6B4A8 => {
    //   block [0x82C6B4A8..0x82C6B4AC)
	// 82C6B4A8: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	pc = 0x82C6B4AC; continue 'dispatch;
            }
            0x82C6B4AC => {
    //   block [0x82C6B4AC..0x82C6B4C4)
	// 82C6B4AC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C6B4B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6B4B4: 4BFFF54D  bl 0x82c6aa00
	ctx.lr = 0x82C6B4B8;
	sub_82C6AA00(ctx, base);
	// 82C6B4B8: 887D0004  lbz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B4BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6B4C0: 4803DF9C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6B4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6B4C8 size=88
    let mut pc: u32 = 0x82C6B4C8;
    'dispatch: loop {
        match pc {
            0x82C6B4C8 => {
    //   block [0x82C6B4C8..0x82C6B4EC)
	// 82C6B4C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6B4CC: 4803DF3D  bl 0x82ca9408
	ctx.lr = 0x82C6B4D0;
	sub_82CA93D0(ctx, base);
	// 82C6B4D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6B4D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6B4D8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C6B4DC: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C6B4E0: 419A0038  beq cr6, 0x82c6b518
	if ctx.cr[6].eq {
	pc = 0x82C6B518; continue 'dispatch;
	}
	// 82C6B4E4: 3B80000F  li r28, 0xf
	ctx.r[28].s64 = 15;
	// 82C6B4E8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82C6B4EC; continue 'dispatch;
            }
            0x82C6B4EC => {
    //   block [0x82C6B4EC..0x82C6B500)
	// 82C6B4EC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6B4F0: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 82C6B4F4: 4198000C  blt cr6, 0x82c6b500
	if ctx.cr[6].lt {
	pc = 0x82C6B500; continue 'dispatch;
	}
	// 82C6B4F8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B4FC: 4BBDA2B5  bl 0x828457b0
	ctx.lr = 0x82C6B500;
	sub_828457B0(ctx, base);
	pc = 0x82C6B500; continue 'dispatch;
            }
            0x82C6B500 => {
    //   block [0x82C6B500..0x82C6B518)
	// 82C6B500: 939F0018  stw r28, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[28].u32 ) };
	// 82C6B504: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82C6B508: 9BDF0004  stb r30, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82C6B50C: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82C6B510: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C6B514: 409AFFD8  bne cr6, 0x82c6b4ec
	if !ctx.cr[6].eq {
	pc = 0x82C6B4EC; continue 'dispatch;
	}
	pc = 0x82C6B518; continue 'dispatch;
            }
            0x82C6B518 => {
    //   block [0x82C6B518..0x82C6B520)
	// 82C6B518: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6B51C: 4803DF3C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6B520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6B520 size=124
    let mut pc: u32 = 0x82C6B520;
    'dispatch: loop {
        match pc {
            0x82C6B520 => {
    //   block [0x82C6B520..0x82C6B550)
	// 82C6B520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6B524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6B528: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6B52C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6B530: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6B534: 81440020  lwz r10, 0x20(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C6B538: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6B53C: 39640008  addi r11, r4, 8
	ctx.r[11].s64 = ctx.r[4].s64 + 8;
	// 82C6B540: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 82C6B544: 4198000C  blt cr6, 0x82c6b550
	if ctx.cr[6].lt {
	pc = 0x82C6B550; continue 'dispatch;
	}
	// 82C6B548: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B54C: 48000008  b 0x82c6b554
	pc = 0x82C6B554; continue 'dispatch;
            }
            0x82C6B550 => {
    //   block [0x82C6B550..0x82C6B554)
	// 82C6B550: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	pc = 0x82C6B554; continue 'dispatch;
            }
            0x82C6B554 => {
    //   block [0x82C6B554..0x82C6B59C)
	// 82C6B554: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6B558: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 82C6B55C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82C6B560: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6B564: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C6B568: B17F0004  sth r11, 4(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 82C6B56C: 4B50FB15  bl 0x8217b080
	ctx.lr = 0x82C6B570;
	sub_8217B080(ctx, base);
	// 82C6B570: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C6B574: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C6B578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6B57C: 4B50F695  bl 0x8217ac10
	ctx.lr = 0x82C6B580;
	sub_8217AC10(ctx, base);
	// 82C6B580: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6B584: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6B588: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6B58C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6B590: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6B594: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6B598: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6B5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6B5A0 size=264
    let mut pc: u32 = 0x82C6B5A0;
    'dispatch: loop {
        match pc {
            0x82C6B5A0 => {
    //   block [0x82C6B5A0..0x82C6B5D0)
	// 82C6B5A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6B5A4: 4803DE65  bl 0x82ca9408
	ctx.lr = 0x82C6B5A8;
	sub_82CA93D0(ctx, base);
	// 82C6B5A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6B5AC: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 82C6B5B0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C6B5B4: 616A5555  ori r10, r11, 0x5555
	ctx.r[10].u64 = ctx.r[11].u64 | 21845;
	// 82C6B5B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6B5BC: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6B5C0: 40990010  ble cr6, 0x82c6b5d0
	if !ctx.cr[6].gt {
	pc = 0x82C6B5D0; continue 'dispatch;
	}
	// 82C6B5C4: 4BF93EA5  bl 0x82bff468
	ctx.lr = 0x82C6B5C8;
	sub_82BFF468(ctx, base);
	// 82C6B5C8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6B5CC: 4803DE8C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6B5D0 => {
    //   block [0x82C6B5D0..0x82C6B5EC)
	// 82C6B5D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B5D4: 3BA0000C  li r29, 0xc
	ctx.r[29].s64 = 12;
	// 82C6B5D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6B5DC: 419A0010  beq cr6, 0x82c6b5ec
	if ctx.cr[6].eq {
	pc = 0x82C6B5EC; continue 'dispatch;
	}
	// 82C6B5E0: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6B5E4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6B5E8: 7D69EBD6  divw r11, r9, r29
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[29].s32;
	pc = 0x82C6B5EC; continue 'dispatch;
            }
            0x82C6B5EC => {
    //   block [0x82C6B5EC..0x82C6B618)
	// 82C6B5EC: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C6B5F0: 409800B0  bge cr6, 0x82c6b6a0
	if !ctx.cr[6].lt {
	pc = 0x82C6B6A0; continue 'dispatch;
	}
	// 82C6B5F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C6B5F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C6B5FC: 4BFD6C85  bl 0x82c42280
	ctx.lr = 0x82C6B600;
	sub_82C42280(ctx, base);
	// 82C6B600: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B604: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B608: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C6B60C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6B610: 40990008  ble cr6, 0x82c6b618
	if !ctx.cr[6].gt {
	pc = 0x82C6B618; continue 'dispatch;
	}
	// 82C6B614: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6B618; continue 'dispatch;
            }
            0x82C6B618 => {
    //   block [0x82C6B618..0x82C6B62C)
	// 82C6B618: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82C6B61C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6B620: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82C6B624: 40990008  ble cr6, 0x82c6b62c
	if !ctx.cr[6].gt {
	pc = 0x82C6B62C; continue 'dispatch;
	}
	// 82C6B628: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6B62C; continue 'dispatch;
            }
            0x82C6B62C => {
    //   block [0x82C6B62C..0x82C6B65C)
	// 82C6B62C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C6B630: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82C6B634: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C6B638: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82C6B63C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C6B640: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82C6B644: 4BFFF99D  bl 0x82c6afe0
	ctx.lr = 0x82C6B648;
	sub_82C6AFE0(ctx, base);
	// 82C6B648: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B64C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6B650: 409A000C  bne cr6, 0x82c6b65c
	if !ctx.cr[6].eq {
	pc = 0x82C6B65C; continue 'dispatch;
	}
	// 82C6B654: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C6B658: 48000010  b 0x82c6b668
	pc = 0x82C6B668; continue 'dispatch;
            }
            0x82C6B65C => {
    //   block [0x82C6B65C..0x82C6B668)
	// 82C6B65C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B660: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82C6B664: 7FAAEBD6  divw r29, r10, r29
	ctx.r[29].s32 = ctx.r[10].s32 / ctx.r[29].s32;
	pc = 0x82C6B668; continue 'dispatch;
            }
            0x82C6B668 => {
    //   block [0x82C6B668..0x82C6B674)
	// 82C6B668: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6B66C: 419A0008  beq cr6, 0x82c6b674
	if ctx.cr[6].eq {
	pc = 0x82C6B674; continue 'dispatch;
	}
	// 82C6B670: 4BBDA141  bl 0x828457b0
	ctx.lr = 0x82C6B674;
	sub_828457B0(ctx, base);
	pc = 0x82C6B674; continue 'dispatch;
            }
            0x82C6B674 => {
    //   block [0x82C6B674..0x82C6B6A0)
	// 82C6B674: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6B678: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C6B67C: 578A083C  slwi r10, r28, 1
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6B680: 7D3D5A14  add r9, r29, r11
	ctx.r[9].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82C6B684: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 82C6B688: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6B68C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6B690: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C6B694: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82C6B698: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82C6B69C: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	pc = 0x82C6B6A0; continue 'dispatch;
            }
            0x82C6B6A0 => {
    //   block [0x82C6B6A0..0x82C6B6A8)
	// 82C6B6A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6B6A4: 4803DDB4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6B6A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6B6A8 size=232
    let mut pc: u32 = 0x82C6B6A8;
    'dispatch: loop {
        match pc {
            0x82C6B6A8 => {
    //   block [0x82C6B6A8..0x82C6B6E4)
	// 82C6B6A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6B6AC: 4803DD61  bl 0x82ca940c
	ctx.lr = 0x82C6B6B0;
	sub_82CA93D0(ctx, base);
	// 82C6B6B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6B6B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C6B6B8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82C6B6BC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C6B6C0: F88100A0  std r4, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u64 ) };
	// 82C6B6C4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B6C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6B6CC: 419A0018  beq cr6, 0x82c6b6e4
	if ctx.cr[6].eq {
	pc = 0x82C6B6E4; continue 'dispatch;
	}
	// 82C6B6D0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B6D4: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 82C6B6D8: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6B6DC: 7CE84BD7  divw. r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82C6B6E0: 4082000C  bne 0x82c6b6ec
	if !ctx.cr[0].eq {
	pc = 0x82C6B6EC; continue 'dispatch;
	}
	pc = 0x82C6B6E4; continue 'dispatch;
            }
            0x82C6B6E4 => {
    //   block [0x82C6B6E4..0x82C6B6EC)
	// 82C6B6E4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C6B6E8: 48000034  b 0x82c6b71c
	pc = 0x82C6B71C; continue 'dispatch;
            }
            0x82C6B6EC => {
    //   block [0x82C6B6EC..0x82C6B6F8)
	// 82C6B6EC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6B6F0: 40990008  ble cr6, 0x82c6b6f8
	if !ctx.cr[6].gt {
	pc = 0x82C6B6F8; continue 'dispatch;
	}
	// 82C6B6F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6B6F8; continue 'dispatch;
            }
            0x82C6B6F8 => {
    //   block [0x82C6B6F8..0x82C6B70C)
	// 82C6B6F8: 814100A0  lwz r10, 0xa0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 82C6B6FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C6B700: 419A000C  beq cr6, 0x82c6b70c
	if ctx.cr[6].eq {
	pc = 0x82C6B70C; continue 'dispatch;
	}
	// 82C6B704: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C6B708: 419A0008  beq cr6, 0x82c6b710
	if ctx.cr[6].eq {
	pc = 0x82C6B710; continue 'dispatch;
	}
	pc = 0x82C6B70C; continue 'dispatch;
            }
            0x82C6B70C => {
    //   block [0x82C6B70C..0x82C6B710)
	// 82C6B70C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6B710; continue 'dispatch;
            }
            0x82C6B710 => {
    //   block [0x82C6B710..0x82C6B71C)
	// 82C6B710: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82C6B714: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6B718: 7FC84BD6  divw r30, r8, r9
	ctx.r[30].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x82C6B71C; continue 'dispatch;
            }
            0x82C6B71C => {
    //   block [0x82C6B71C..0x82C6B73C)
	// 82C6B71C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C6B720: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6B724: 4BFFF965  bl 0x82c6b088
	ctx.lr = 0x82C6B728;
	sub_82C6B088(ctx, base);
	// 82C6B728: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B72C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B730: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6B734: 40990008  ble cr6, 0x82c6b73c
	if !ctx.cr[6].gt {
	pc = 0x82C6B73C; continue 'dispatch;
	}
	// 82C6B738: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6B73C; continue 'dispatch;
            }
            0x82C6B73C => {
    //   block [0x82C6B73C..0x82C6B774)
	// 82C6B73C: 57CA083C  slwi r10, r30, 1
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6B740: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C6B744: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B748: 7D1E5214  add r8, r30, r10
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82C6B74C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82C6B750: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C6B754: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6B758: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 82C6B75C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82C6B760: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C6B764: 41990010  bgt cr6, 0x82c6b774
	if ctx.cr[6].gt {
	pc = 0x82C6B774; continue 'dispatch;
	}
	// 82C6B768: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B76C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6B770: 40980008  bge cr6, 0x82c6b778
	if !ctx.cr[6].lt {
	pc = 0x82C6B778; continue 'dispatch;
	}
	pc = 0x82C6B774; continue 'dispatch;
            }
            0x82C6B774 => {
    //   block [0x82C6B774..0x82C6B778)
	// 82C6B774: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6B778; continue 'dispatch;
            }
            0x82C6B778 => {
    //   block [0x82C6B778..0x82C6B790)
	// 82C6B778: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C6B77C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6B780: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C6B784: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82C6B788: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6B78C: 4803DCD0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6B790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6B790 size=104
    let mut pc: u32 = 0x82C6B790;
    'dispatch: loop {
        match pc {
            0x82C6B790 => {
    //   block [0x82C6B790..0x82C6B7BC)
	// 82C6B790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6B794: 4803DC6D  bl 0x82ca9400
	ctx.lr = 0x82C6B798;
	sub_82CA93D0(ctx, base);
	// 82C6B798: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6B79C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82C6B7A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6B7A4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C6B7A8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82C6B7AC: 419A0044  beq cr6, 0x82c6b7f0
	if ctx.cr[6].eq {
	pc = 0x82C6B7F0; continue 'dispatch;
	}
	// 82C6B7B0: 3B60000F  li r27, 0xf
	ctx.r[27].s64 = 15;
	// 82C6B7B4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C6B7B8: 3B80FFFF  li r28, -1
	ctx.r[28].s64 = -1;
	pc = 0x82C6B7BC; continue 'dispatch;
            }
            0x82C6B7BC => {
    //   block [0x82C6B7BC..0x82C6B7E4)
	// 82C6B7BC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C6B7C0: 419A0024  beq cr6, 0x82c6b7e4
	if ctx.cr[6].eq {
	pc = 0x82C6B7E4; continue 'dispatch;
	}
	// 82C6B7C4: 937F0018  stw r27, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[27].u32 ) };
	// 82C6B7C8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82C6B7CC: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82C6B7D0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6B7D4: 9BDF0004  stb r30, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u8 ) };
	// 82C6B7D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6B7DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6B7E0: 4B523221  bl 0x8218ea00
	ctx.lr = 0x82C6B7E4;
	sub_8218EA00(ctx, base);
	pc = 0x82C6B7E4; continue 'dispatch;
            }
            0x82C6B7E4 => {
    //   block [0x82C6B7E4..0x82C6B7F0)
	// 82C6B7E4: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82C6B7E8: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82C6B7EC: 4082FFD0  bne 0x82c6b7bc
	if !ctx.cr[0].eq {
	pc = 0x82C6B7BC; continue 'dispatch;
	}
	pc = 0x82C6B7F0; continue 'dispatch;
            }
            0x82C6B7F0 => {
    //   block [0x82C6B7F0..0x82C6B7F8)
	// 82C6B7F0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6B7F4: 4803DC5C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6B7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6B7F8 size=292
    let mut pc: u32 = 0x82C6B7F8;
    'dispatch: loop {
        match pc {
            0x82C6B7F8 => {
    //   block [0x82C6B7F8..0x82C6B834)
	// 82C6B7F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6B7FC: 4803DC01  bl 0x82ca93fc
	ctx.lr = 0x82C6B800;
	sub_82CA93D0(ctx, base);
	// 82C6B800: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6B804: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82C6B808: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C6B80C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C6B810: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 82C6B814: 3B40000F  li r26, 0xf
	ctx.r[26].s64 = 15;
	// 82C6B818: 9B810064  stb r28, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u8 ) };
	// 82C6B81C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C6B820: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C6B824: 93410078  stw r26, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[26].u32 ) };
	// 82C6B828: 419A00E8  beq cr6, 0x82c6b910
	if ctx.cr[6].eq {
	pc = 0x82C6B910; continue 'dispatch;
	}
	// 82C6B82C: 3BFD0004  addi r31, r29, 4
	ctx.r[31].s64 = ctx.r[29].s64 + 4;
	// 82C6B830: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	pc = 0x82C6B834; continue 'dispatch;
            }
            0x82C6B834 => {
    //   block [0x82C6B834..0x82C6B85C)
	// 82C6B834: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C6B838: 419A0024  beq cr6, 0x82c6b85c
	if ctx.cr[6].eq {
	pc = 0x82C6B85C; continue 'dispatch;
	}
	// 82C6B83C: 935F0014  stw r26, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[26].u32 ) };
	// 82C6B840: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82C6B844: 939F0010  stw r28, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[28].u32 ) };
	// 82C6B848: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6B84C: 9B9F0000  stb r28, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u8 ) };
	// 82C6B850: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C6B854: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6B858: 4B5231A9  bl 0x8218ea00
	ctx.lr = 0x82C6B85C;
	sub_8218EA00(ctx, base);
	pc = 0x82C6B85C; continue 'dispatch;
            }
            0x82C6B85C => {
    //   block [0x82C6B85C..0x82C6B910)
	// 82C6B85C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6B860: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82C6B864: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B868: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82C6B86C: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B870: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82C6B874: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6B878: 3BBD001C  addi r29, r29, 0x1c
	ctx.r[29].s64 = ctx.r[29].s64 + 28;
	// 82C6B87C: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B880: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C6B884: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82C6B888: 90C90008  stw r6, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82C6B88C: 90A9000C  stw r5, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 82C6B890: 80670000  lwz r3, 0(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6B894: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B898: 81470008  lwz r10, 8(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B89C: 8127000C  lwz r9, 0xc(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6B8A0: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82C6B8A4: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B8A8: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82C6B8AC: 80FE000C  lwz r7, 0xc(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6B8B0: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82C6B8B4: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C6B8B8: 90DF000C  stw r6, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 82C6B8BC: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C6B8C0: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82C6B8C4: 915E000C  stw r10, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82C6B8C8: 913E0010  stw r9, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82C6B8CC: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C6B8D0: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6B8D4: 909F0010  stw r4, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 82C6B8D8: 90BE0014  stw r5, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[5].u32 ) };
	// 82C6B8DC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6B8E0: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6B8E4: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82C6B8E8: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82C6B8EC: 907E0018  stw r3, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 82C6B8F0: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 82C6B8F4: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C6B8F8: 409AFF3C  bne cr6, 0x82c6b834
	if !ctx.cr[6].eq {
	pc = 0x82C6B834; continue 'dispatch;
	}
	// 82C6B8FC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C6B900: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 82C6B904: 4198000C  blt cr6, 0x82c6b910
	if ctx.cr[6].lt {
	pc = 0x82C6B910; continue 'dispatch;
	}
	// 82C6B908: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C6B90C: 4BBD9EA5  bl 0x828457b0
	ctx.lr = 0x82C6B910;
	sub_828457B0(ctx, base);
	pc = 0x82C6B910; continue 'dispatch;
            }
            0x82C6B910 => {
    //   block [0x82C6B910..0x82C6B91C)
	// 82C6B910: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6B914: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82C6B918: 4803DB34  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6B920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6B920 size=308
    let mut pc: u32 = 0x82C6B920;
    'dispatch: loop {
        match pc {
            0x82C6B920 => {
    //   block [0x82C6B920..0x82C6B95C)
	// 82C6B920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6B924: 4803DADD  bl 0x82ca9400
	ctx.lr = 0x82C6B928;
	sub_82CA93D0(ctx, base);
	// 82C6B928: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6B92C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82C6B930: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C6B934: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C6B938: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C6B93C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82C6B940: 419A0100  beq cr6, 0x82c6ba40
	if ctx.cr[6].eq {
	pc = 0x82C6BA40; continue 'dispatch;
	}
	// 82C6B944: 815B0044  lwz r10, 0x44(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(68 as u32) ) } as u64;
	// 82C6B948: 3BDB0040  addi r30, r27, 0x40
	ctx.r[30].s64 = ctx.r[27].s64 + 64;
	// 82C6B94C: 817B0048  lwz r11, 0x48(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(72 as u32) ) } as u64;
	// 82C6B950: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6B954: 40990008  ble cr6, 0x82c6b95c
	if !ctx.cr[6].gt {
	pc = 0x82C6B95C; continue 'dispatch;
	}
	// 82C6B958: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6B95C; continue 'dispatch;
            }
            0x82C6B95C => {
    //   block [0x82C6B95C..0x82C6B960)
	// 82C6B95C: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	pc = 0x82C6B960; continue 'dispatch;
            }
            0x82C6B960 => {
    //   block [0x82C6B960..0x82C6B974)
	// 82C6B960: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B964: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B968: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6B96C: 40990008  ble cr6, 0x82c6b974
	if !ctx.cr[6].gt {
	pc = 0x82C6B974; continue 'dispatch;
	}
	// 82C6B970: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6B974; continue 'dispatch;
            }
            0x82C6B974 => {
    //   block [0x82C6B974..0x82C6B980)
	// 82C6B974: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C6B978: 419A0008  beq cr6, 0x82c6b980
	if ctx.cr[6].eq {
	pc = 0x82C6B980; continue 'dispatch;
	}
	// 82C6B97C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6B980; continue 'dispatch;
            }
            0x82C6B980 => {
    //   block [0x82C6B980..0x82C6B994)
	// 82C6B980: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6B984: 419A00BC  beq cr6, 0x82c6ba40
	if ctx.cr[6].eq {
	pc = 0x82C6BA40; continue 'dispatch;
	}
	// 82C6B988: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6B98C: 41980008  blt cr6, 0x82c6b994
	if ctx.cr[6].lt {
	pc = 0x82C6B994; continue 'dispatch;
	}
	// 82C6B990: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6B994; continue 'dispatch;
            }
            0x82C6B994 => {
    //   block [0x82C6B994..0x82C6B9C0)
	// 82C6B994: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6B998: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6B99C: 409A0030  bne cr6, 0x82c6b9cc
	if !ctx.cr[6].eq {
	pc = 0x82C6B9CC; continue 'dispatch;
	}
	// 82C6B9A0: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6B9A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6B9A8: 419A0024  beq cr6, 0x82c6b9cc
	if ctx.cr[6].eq {
	pc = 0x82C6B9CC; continue 'dispatch;
	}
	// 82C6B9AC: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6B9B0: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82C6B9B4: 4198000C  blt cr6, 0x82c6b9c0
	if ctx.cr[6].lt {
	pc = 0x82C6B9C0; continue 'dispatch;
	}
	// 82C6B9B8: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B9BC: 48000008  b 0x82c6b9c4
	pc = 0x82C6B9C4; continue 'dispatch;
            }
            0x82C6B9C0 => {
    //   block [0x82C6B9C0..0x82C6B9C4)
	// 82C6B9C0: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	pc = 0x82C6B9C4; continue 'dispatch;
            }
            0x82C6B9C4 => {
    //   block [0x82C6B9C4..0x82C6B9CC)
	// 82C6B9C4: 4B65EBC5  bl 0x822ca588
	ctx.lr = 0x82C6B9C8;
	sub_822CA588(ctx, base);
	// 82C6B9C8: 907D001C  stw r3, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	pc = 0x82C6B9CC; continue 'dispatch;
            }
            0x82C6B9CC => {
    //   block [0x82C6B9CC..0x82C6B9EC)
	// 82C6B9CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6B9D0: 815D001C  lwz r10, 0x1c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6B9D4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6B9D8: 419A001C  beq cr6, 0x82c6b9f4
	if ctx.cr[6].eq {
	pc = 0x82C6B9F4; continue 'dispatch;
	}
	// 82C6B9DC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B9E0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6B9E4: 41980008  blt cr6, 0x82c6b9ec
	if ctx.cr[6].lt {
	pc = 0x82C6B9EC; continue 'dispatch;
	}
	// 82C6B9E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6B9EC; continue 'dispatch;
            }
            0x82C6B9EC => {
    //   block [0x82C6B9EC..0x82C6B9F4)
	// 82C6B9EC: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82C6B9F0: 4BFFFF70  b 0x82c6b960
	pc = 0x82C6B960; continue 'dispatch;
            }
            0x82C6B9F4 => {
    //   block [0x82C6B9F4..0x82C6BA08)
	// 82C6B9F4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6B9F8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6B9FC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6BA00: 40990008  ble cr6, 0x82c6ba08
	if !ctx.cr[6].gt {
	pc = 0x82C6BA08; continue 'dispatch;
	}
	// 82C6BA04: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6BA08; continue 'dispatch;
            }
            0x82C6BA08 => {
    //   block [0x82C6BA08..0x82C6BA14)
	// 82C6BA08: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C6BA0C: 419A0008  beq cr6, 0x82c6ba14
	if ctx.cr[6].eq {
	pc = 0x82C6BA14; continue 'dispatch;
	}
	// 82C6BA10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6BA14; continue 'dispatch;
            }
            0x82C6BA14 => {
    //   block [0x82C6BA14..0x82C6BA40)
	// 82C6BA14: 7D6BF850  subf r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82C6BA18: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 82C6BA1C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82C6BA20: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82C6BA24: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C6BA28: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 82C6BA2C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C6BA30: 4BFFF209  bl 0x82c6ac38
	ctx.lr = 0x82C6BA34;
	sub_82C6AC38(ctx, base);
	// 82C6BA34: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C6BA38: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6BA3C: 4803DA14  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6BA40 => {
    //   block [0x82C6BA40..0x82C6BA54)
	// 82C6BA40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6BA44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C6BA48: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C6BA4C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6BA50: 4803DA00  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6BA58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6BA58 size=196
    let mut pc: u32 = 0x82C6BA58;
    'dispatch: loop {
        match pc {
            0x82C6BA58 => {
    //   block [0x82C6BA58..0x82C6BA80)
	// 82C6BA58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6BA5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6BA60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6BA64: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6BA68: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82C6BA6C: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 82C6BA70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6BA74: 409A000C  bne cr6, 0x82c6ba80
	if !ctx.cr[6].eq {
	pc = 0x82C6BA80; continue 'dispatch;
	}
	// 82C6BA78: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C6BA7C: 48000010  b 0x82c6ba8c
	pc = 0x82C6BA8C; continue 'dispatch;
            }
            0x82C6BA80 => {
    //   block [0x82C6BA80..0x82C6BA8C)
	// 82C6BA80: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6BA84: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6BA88: 7D484BD6  divw r10, r8, r9
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x82C6BA8C; continue 'dispatch;
            }
            0x82C6BA8C => {
    //   block [0x82C6BA8C..0x82C6BACC)
	// 82C6BA8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6BA90: 419A0054  beq cr6, 0x82c6bae4
	if ctx.cr[6].eq {
	pc = 0x82C6BAE4; continue 'dispatch;
	}
	// 82C6BA94: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6BA98: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82C6BA9C: 7CA74BD6  divw r5, r7, r9
	ctx.r[5].s32 = ctx.r[7].s32 / ctx.r[9].s32;
	// 82C6BAA0: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C6BAA4: 40980040  bge cr6, 0x82c6bae4
	if !ctx.cr[6].lt {
	pc = 0x82C6BAE4; continue 'dispatch;
	}
	// 82C6BAA8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6BAAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6BAB0: 419A001C  beq cr6, 0x82c6bacc
	if ctx.cr[6].eq {
	pc = 0x82C6BACC; continue 'dispatch;
	}
	// 82C6BAB4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6BAB8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C6BABC: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6BAC0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C6BAC4: 81060008  lwz r8, 8(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6BAC8: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x82C6BACC; continue 'dispatch;
            }
            0x82C6BACC => {
    //   block [0x82C6BACC..0x82C6BAE4)
	// 82C6BACC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82C6BAD0: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C6BAD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6BAD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6BADC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6BAE0: 4E800020  blr
	return;
            }
            0x82C6BAE4 => {
    //   block [0x82C6BAE4..0x82C6BAF4)
	// 82C6BAE4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6BAE8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6BAEC: 40990008  ble cr6, 0x82c6baf4
	if !ctx.cr[6].gt {
	pc = 0x82C6BAF4; continue 'dispatch;
	}
	// 82C6BAF0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6BAF4; continue 'dispatch;
            }
            0x82C6BAF4 => {
    //   block [0x82C6BAF4..0x82C6BB1C)
	// 82C6BAF4: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82C6BAF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6BAFC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82C6BB00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C6BB04: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C6BB08: 4BFFFBA1  bl 0x82c6b6a8
	ctx.lr = 0x82C6BB0C;
	sub_82C6B6A8(ctx, base);
	// 82C6BB0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6BB10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6BB14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6BB18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6BB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6BB20 size=88
    let mut pc: u32 = 0x82C6BB20;
    'dispatch: loop {
        match pc {
            0x82C6BB20 => {
    //   block [0x82C6BB20..0x82C6BB44)
	// 82C6BB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6BB24: 4803D8E5  bl 0x82ca9408
	ctx.lr = 0x82C6BB28;
	sub_82CA93D0(ctx, base);
	// 82C6BB28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6BB2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C6BB30: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C6BB34: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C6BB38: 419A0038  beq cr6, 0x82c6bb70
	if ctx.cr[6].eq {
	pc = 0x82C6BB70; continue 'dispatch;
	}
	// 82C6BB3C: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 82C6BB40: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82C6BB44; continue 'dispatch;
            }
            0x82C6BB44 => {
    //   block [0x82C6BB44..0x82C6BB54)
	// 82C6BB44: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6BB48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6BB4C: 419A0008  beq cr6, 0x82c6bb54
	if ctx.cr[6].eq {
	pc = 0x82C6BB54; continue 'dispatch;
	}
	// 82C6BB50: 4BBD9C61  bl 0x828457b0
	ctx.lr = 0x82C6BB54;
	sub_828457B0(ctx, base);
	pc = 0x82C6BB54; continue 'dispatch;
            }
            0x82C6BB54 => {
    //   block [0x82C6BB54..0x82C6BB70)
	// 82C6BB54: 3BDE0014  addi r30, r30, 0x14
	ctx.r[30].s64 = ctx.r[30].s64 + 20;
	// 82C6BB58: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C6BB5C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82C6BB60: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C6BB64: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 82C6BB68: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C6BB6C: 409AFFD8  bne cr6, 0x82c6bb44
	if !ctx.cr[6].eq {
	pc = 0x82C6BB44; continue 'dispatch;
	}
	pc = 0x82C6BB70; continue 'dispatch;
            }
            0x82C6BB70 => {
    //   block [0x82C6BB70..0x82C6BB78)
	// 82C6BB70: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6BB74: 4803D8E4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6BB78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6BB78 size=100
    let mut pc: u32 = 0x82C6BB78;
    'dispatch: loop {
        match pc {
            0x82C6BB78 => {
    //   block [0x82C6BB78..0x82C6BBDC)
	// 82C6BB78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6BB7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6BB80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6BB84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6BB88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6BB8C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82C6BB90: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6BB94: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C6BB98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C6BB9C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C6BBA0: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82C6BBA4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82C6BBA8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82C6BBAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C6BBB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6BBB4: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6BBB8: 4BFFFBD9  bl 0x82c6b790
	ctx.lr = 0x82C6BBBC;
	sub_82C6B790(ctx, base);
	// 82C6BBBC: 1D7E001C  mulli r11, r30, 0x1c
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 28 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82C6BBC0: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82C6BBC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6BBC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6BBCC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6BBD0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6BBD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6BBD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6BBE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6BBE0 size=104
    let mut pc: u32 = 0x82C6BBE0;
    'dispatch: loop {
        match pc {
            0x82C6BBE0 => {
    //   block [0x82C6BBE0..0x82C6BC1C)
	// 82C6BBE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6BBE4: 4803D825  bl 0x82ca9408
	ctx.lr = 0x82C6BBE8;
	sub_82CA93D0(ctx, base);
	// 82C6BBE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6BBEC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C6BBF0: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82C6BBF4: 7D7E2050  subf r11, r30, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 82C6BBF8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C6BBFC: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82C6BC00: 7F1E2040  cmplw cr6, r30, r4
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82C6BC04: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6BC08: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C6BC0C: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82C6BC10: 7F882850  subf r28, r8, r5
	ctx.r[28].s64 = ctx.r[5].s64 - ctx.r[8].s64;
	// 82C6BC14: 419A0028  beq cr6, 0x82c6bc3c
	if ctx.cr[6].eq {
	pc = 0x82C6BC3C; continue 'dispatch;
	}
	// 82C6BC18: 7FA42850  subf r29, r4, r5
	ctx.r[29].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	pc = 0x82C6BC1C; continue 'dispatch;
            }
            0x82C6BC1C => {
    //   block [0x82C6BC1C..0x82C6BC3C)
	// 82C6BC1C: 3BFFFFEC  addi r31, r31, -0x14
	ctx.r[31].s64 = ctx.r[31].s64 + -20;
	// 82C6BC20: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82C6BC24: 7C7D2214  add r3, r29, r4
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[4].u64;
	// 82C6BC28: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6BC2C: 7D7DF92E  stwx r11, r29, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u32) };
	// 82C6BC30: 4B7103D1  bl 0x8237c000
	ctx.lr = 0x82C6BC34;
	sub_8237C000(ctx, base);
	// 82C6BC34: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C6BC38: 409AFFE4  bne cr6, 0x82c6bc1c
	if !ctx.cr[6].eq {
	pc = 0x82C6BC1C; continue 'dispatch;
	}
	pc = 0x82C6BC3C; continue 'dispatch;
            }
            0x82C6BC3C => {
    //   block [0x82C6BC3C..0x82C6BC48)
	// 82C6BC3C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C6BC40: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6BC44: 4803D814  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6BC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6BC48 size=252
    let mut pc: u32 = 0x82C6BC48;
    'dispatch: loop {
        match pc {
            0x82C6BC48 => {
    //   block [0x82C6BC48..0x82C6BC78)
	// 82C6BC48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6BC4C: 4803D7B9  bl 0x82ca9404
	ctx.lr = 0x82C6BC50;
	sub_82CA93D0(ctx, base);
	// 82C6BC50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6BC54: 3D600924  lis r11, 0x924
	ctx.r[11].s64 = 153354240;
	// 82C6BC58: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C6BC5C: 616A9249  ori r10, r11, 0x9249
	ctx.r[10].u64 = ctx.r[11].u64 | 37449;
	// 82C6BC60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6BC64: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6BC68: 40990010  ble cr6, 0x82c6bc78
	if !ctx.cr[6].gt {
	pc = 0x82C6BC78; continue 'dispatch;
	}
	// 82C6BC6C: 4BF937FD  bl 0x82bff468
	ctx.lr = 0x82C6BC70;
	sub_82BFF468(ctx, base);
	// 82C6BC70: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6BC74: 4803D7E0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6BC78 => {
    //   block [0x82C6BC78..0x82C6BC94)
	// 82C6BC78: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6BC7C: 3B80001C  li r28, 0x1c
	ctx.r[28].s64 = 28;
	// 82C6BC80: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C6BC84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6BC88: 409A000C  bne cr6, 0x82c6bc94
	if !ctx.cr[6].eq {
	pc = 0x82C6BC94; continue 'dispatch;
	}
	// 82C6BC8C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82C6BC90: 48000010  b 0x82c6bca0
	pc = 0x82C6BCA0; continue 'dispatch;
            }
            0x82C6BC94 => {
    //   block [0x82C6BC94..0x82C6BCA0)
	// 82C6BC94: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6BC98: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6BC9C: 7D69E3D6  divw r11, r9, r28
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[28].s32;
	pc = 0x82C6BCA0; continue 'dispatch;
            }
            0x82C6BCA0 => {
    //   block [0x82C6BCA0..0x82C6BCD0)
	// 82C6BCA0: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C6BCA4: 40980098  bge cr6, 0x82c6bd3c
	if !ctx.cr[6].lt {
	pc = 0x82C6BD3C; continue 'dispatch;
	}
	// 82C6BCA8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C6BCAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6BCB0: 4BFD68E1  bl 0x82c42590
	ctx.lr = 0x82C6BCB4;
	sub_82C42590(ctx, base);
	// 82C6BCB4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6BCB8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6BCBC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C6BCC0: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82C6BCC4: 4099000C  ble cr6, 0x82c6bcd0
	if !ctx.cr[6].gt {
	pc = 0x82C6BCD0; continue 'dispatch;
	}
	// 82C6BCC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82C6BCCC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6BCD0; continue 'dispatch;
            }
            0x82C6BCD0 => {
    //   block [0x82C6BCD0..0x82C6BD20)
	// 82C6BCD0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C6BCD4: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6BCD8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C6BCDC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C6BCE0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C6BCE4: 9BAA0000  stb r29, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82C6BCE8: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6BCEC: 4BFFFB0D  bl 0x82c6b7f8
	ctx.lr = 0x82C6BCF0;
	sub_82C6B7F8(ctx, base);
	// 82C6BCF0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6BCF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6BCF8: 419A0028  beq cr6, 0x82c6bd20
	if ctx.cr[6].eq {
	pc = 0x82C6BD20; continue 'dispatch;
	}
	// 82C6BCFC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6BD00: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C6BD04: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6BD08: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82C6BD0C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82C6BD10: 7FAAE3D6  divw r29, r10, r28
	ctx.r[29].s32 = ctx.r[10].s32 / ctx.r[28].s32;
	// 82C6BD14: 4BFFF7B5  bl 0x82c6b4c8
	ctx.lr = 0x82C6BD18;
	sub_82C6B4C8(ctx, base);
	// 82C6BD18: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6BD1C: 4BBD9A95  bl 0x828457b0
	ctx.lr = 0x82C6BD20;
	sub_828457B0(ctx, base);
	pc = 0x82C6BD20; continue 'dispatch;
            }
            0x82C6BD20 => {
    //   block [0x82C6BD20..0x82C6BD3C)
	// 82C6BD20: 1D5B001C  mulli r10, r27, 0x1c
	ctx.r[10].s32 = ((ctx.r[27].s32 as i64 * 28 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82C6BD24: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C6BD28: 1D7D001C  mulli r11, r29, 0x1c
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * 28 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82C6BD2C: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82C6BD30: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C6BD34: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82C6BD38: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82C6BD3C; continue 'dispatch;
            }
            0x82C6BD3C => {
    //   block [0x82C6BD3C..0x82C6BD44)
	// 82C6BD3C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C6BD40: 4803D714  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6BD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6BD48 size=788
    let mut pc: u32 = 0x82C6BD48;
    'dispatch: loop {
        match pc {
            0x82C6BD48 => {
    //   block [0x82C6BD48..0x82C6BDA4)
	// 82C6BD48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6BD4C: 4803D6AD  bl 0x82ca93f8
	ctx.lr = 0x82C6BD50;
	sub_82CA93D0(ctx, base);
	// 82C6BD50: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6BD54: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82C6BD58: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 82C6BD5C: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 82C6BD60: 93410074  stw r26, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[26].u32 ) };
	// 82C6BD64: 3B00FFFF  li r24, -1
	ctx.r[24].s64 = -1;
	// 82C6BD68: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82C6BD6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6BD70: 9B410064  stb r26, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u8 ) };
	// 82C6BD74: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C6BD78: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82C6BD7C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6BD80: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82C6BD84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C6BD88: 4B522C79  bl 0x8218ea00
	ctx.lr = 0x82C6BD8C;
	sub_8218EA00(ctx, base);
	// 82C6BD8C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6BD90: 3B20001C  li r25, 0x1c
	ctx.r[25].s64 = 28;
	// 82C6BD94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6BD98: 409A000C  bne cr6, 0x82c6bda4
	if !ctx.cr[6].eq {
	pc = 0x82C6BDA4; continue 'dispatch;
	}
	// 82C6BD9C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82C6BDA0: 48000010  b 0x82c6bdb0
	pc = 0x82C6BDB0; continue 'dispatch;
            }
            0x82C6BDA4 => {
    //   block [0x82C6BDA4..0x82C6BDB0)
	// 82C6BDA4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6BDA8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6BDAC: 7D09CBD6  divw r8, r9, r25
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[25].s32;
	pc = 0x82C6BDB0; continue 'dispatch;
            }
            0x82C6BDB0 => {
    //   block [0x82C6BDB0..0x82C6BDC8)
	// 82C6BDB0: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82C6BDB4: 419A028C  beq cr6, 0x82c6c040
	if ctx.cr[6].eq {
	pc = 0x82C6C040; continue 'dispatch;
	}
	// 82C6BDB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6BDBC: 409A000C  bne cr6, 0x82c6bdc8
	if !ctx.cr[6].eq {
	pc = 0x82C6BDC8; continue 'dispatch;
	}
	// 82C6BDC0: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82C6BDC4: 48000010  b 0x82c6bdd4
	pc = 0x82C6BDD4; continue 'dispatch;
            }
            0x82C6BDC8 => {
    //   block [0x82C6BDC8..0x82C6BDD4)
	// 82C6BDC8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6BDCC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6BDD0: 7D49CBD6  divw r10, r9, r25
	ctx.r[10].s32 = ctx.r[9].s32 / ctx.r[25].s32;
	pc = 0x82C6BDD4; continue 'dispatch;
            }
            0x82C6BDD4 => {
    //   block [0x82C6BDD4..0x82C6BDF0)
	// 82C6BDD4: 3D200924  lis r9, 0x924
	ctx.r[9].s64 = 153354240;
	// 82C6BDD8: 61299249  ori r9, r9, 0x9249
	ctx.r[9].u64 = ctx.r[9].u64 | 37449;
	// 82C6BDDC: 7CEA4850  subf r7, r10, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82C6BDE0: 7F07D840  cmplw cr6, r7, r27
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C6BDE4: 4098000C  bge cr6, 0x82c6bdf0
	if !ctx.cr[6].lt {
	pc = 0x82C6BDF0; continue 'dispatch;
	}
	// 82C6BDE8: 4BF93681  bl 0x82bff468
	ctx.lr = 0x82C6BDEC;
	sub_82BFF468(ctx, base);
	// 82C6BDEC: 48000254  b 0x82c6c040
	pc = 0x82C6C040; continue 'dispatch;
            }
            0x82C6BDF0 => {
    //   block [0x82C6BDF0..0x82C6BE00)
	// 82C6BDF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6BDF4: 409A000C  bne cr6, 0x82c6be00
	if !ctx.cr[6].eq {
	pc = 0x82C6BE00; continue 'dispatch;
	}
	// 82C6BDF8: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82C6BDFC: 48000010  b 0x82c6be0c
	pc = 0x82C6BE0C; continue 'dispatch;
            }
            0x82C6BE00 => {
    //   block [0x82C6BE00..0x82C6BE0C)
	// 82C6BE00: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6BE04: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6BE08: 7D47CBD6  divw r10, r7, r25
	ctx.r[10].s32 = ctx.r[7].s32 / ctx.r[25].s32;
	pc = 0x82C6BE0C; continue 'dispatch;
            }
            0x82C6BE0C => {
    //   block [0x82C6BE0C..0x82C6BE30)
	// 82C6BE0C: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82C6BE10: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6BE14: 4098013C  bge cr6, 0x82c6bf50
	if !ctx.cr[6].lt {
	pc = 0x82C6BF50; continue 'dispatch;
	}
	// 82C6BE18: 550AF87E  srwi r10, r8, 1
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6BE1C: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 82C6BE20: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82C6BE24: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C6BE28: 41980008  blt cr6, 0x82c6be30
	if ctx.cr[6].lt {
	pc = 0x82C6BE30; continue 'dispatch;
	}
	// 82C6BE2C: 7F8A4214  add r28, r10, r8
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	pc = 0x82C6BE30; continue 'dispatch;
            }
            0x82C6BE30 => {
    //   block [0x82C6BE30..0x82C6BE40)
	// 82C6BE30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6BE34: 409A000C  bne cr6, 0x82c6be40
	if !ctx.cr[6].eq {
	pc = 0x82C6BE40; continue 'dispatch;
	}
	// 82C6BE38: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82C6BE3C: 48000010  b 0x82c6be4c
	pc = 0x82C6BE4C; continue 'dispatch;
            }
            0x82C6BE40 => {
    //   block [0x82C6BE40..0x82C6BE4C)
	// 82C6BE40: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6BE44: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6BE48: 7D49CBD6  divw r10, r9, r25
	ctx.r[10].s32 = ctx.r[9].s32 / ctx.r[25].s32;
	pc = 0x82C6BE4C; continue 'dispatch;
            }
            0x82C6BE4C => {
    //   block [0x82C6BE4C..0x82C6BE68)
	// 82C6BE4C: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82C6BE50: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6BE54: 40980024  bge cr6, 0x82c6be78
	if !ctx.cr[6].lt {
	pc = 0x82C6BE78; continue 'dispatch;
	}
	// 82C6BE58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6BE5C: 409A000C  bne cr6, 0x82c6be68
	if !ctx.cr[6].eq {
	pc = 0x82C6BE68; continue 'dispatch;
	}
	// 82C6BE60: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82C6BE64: 48000010  b 0x82c6be74
	pc = 0x82C6BE74; continue 'dispatch;
            }
            0x82C6BE68 => {
    //   block [0x82C6BE68..0x82C6BE74)
	// 82C6BE68: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6BE6C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6BE70: 7D69CBD6  divw r11, r9, r25
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[25].s32;
	pc = 0x82C6BE74; continue 'dispatch;
            }
            0x82C6BE74 => {
    //   block [0x82C6BE74..0x82C6BE78)
	// 82C6BE74: 7F8BDA14  add r28, r11, r27
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	pc = 0x82C6BE78; continue 'dispatch;
            }
            0x82C6BE78 => {
    //   block [0x82C6BE78..0x82C6BF00)
	// 82C6BE78: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C6BE7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6BE80: 4BFD6711  bl 0x82c42590
	ctx.lr = 0x82C6BE84;
	sub_82C42590(ctx, base);
	// 82C6BE84: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82C6BE88: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6BE8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C6BE90: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6BE94: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C6BE98: 83A100EC  lwz r29, 0xec(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82C6BE9C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C6BEA0: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82C6BEA4: 9B4B0000  stb r26, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 82C6BEA8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6BEAC: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6BEB0: 4BFFF949  bl 0x82c6b7f8
	ctx.lr = 0x82C6BEB4;
	sub_82C6B7F8(ctx, base);
	// 82C6BEB4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6BEB8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82C6BEBC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82C6BEC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6BEC4: 4BFFFCB5  bl 0x82c6bb78
	ctx.lr = 0x82C6BEC8;
	sub_82C6BB78(ctx, base);
	// 82C6BEC8: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82C6BECC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6BED0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C6BED4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C6BED8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6BEDC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6BEE0: 9B490000  stb r26, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 82C6BEE4: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6BEE8: 4BFFF911  bl 0x82c6b7f8
	ctx.lr = 0x82C6BEEC;
	sub_82C6B7F8(ctx, base);
	// 82C6BEEC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6BEF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6BEF4: 409A000C  bne cr6, 0x82c6bf00
	if !ctx.cr[6].eq {
	pc = 0x82C6BF00; continue 'dispatch;
	}
	// 82C6BEF8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82C6BEFC: 48000010  b 0x82c6bf0c
	pc = 0x82C6BF0C; continue 'dispatch;
            }
            0x82C6BF00 => {
    //   block [0x82C6BF00..0x82C6BF0C)
	// 82C6BF00: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6BF04: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82C6BF08: 7D6ACBD6  divw r11, r10, r25
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[25].s32;
	pc = 0x82C6BF0C; continue 'dispatch;
            }
            0x82C6BF0C => {
    //   block [0x82C6BF0C..0x82C6BF30)
	// 82C6BF0C: 7FABDA14  add r29, r11, r27
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82C6BF10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6BF14: 419A001C  beq cr6, 0x82c6bf30
	if ctx.cr[6].eq {
	pc = 0x82C6BF30; continue 'dispatch;
	}
	// 82C6BF18: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C6BF1C: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6BF20: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6BF24: 4BFFF5A5  bl 0x82c6b4c8
	ctx.lr = 0x82C6BF28;
	sub_82C6B4C8(ctx, base);
	// 82C6BF28: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6BF2C: 4BBD9885  bl 0x828457b0
	ctx.lr = 0x82C6BF30;
	sub_828457B0(ctx, base);
	pc = 0x82C6BF30; continue 'dispatch;
            }
            0x82C6BF30 => {
    //   block [0x82C6BF30..0x82C6BF50)
	// 82C6BF30: 1D7C001C  mulli r11, r28, 0x1c
	ctx.r[11].s32 = ((ctx.r[28].s32 as i64 * 28 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82C6BF34: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C6BF38: 1D5D001C  mulli r10, r29, 0x1c
	ctx.r[10].s32 = ((ctx.r[29].s32 as i64 * 28 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82C6BF3C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C6BF40: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82C6BF44: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C6BF48: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C6BF4C: 480000F4  b 0x82c6c040
	pc = 0x82C6C040; continue 'dispatch;
            }
            0x82C6BF50 => {
    //   block [0x82C6BF50..0x82C6BFC4)
	// 82C6BF50: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6BF54: 1F9B001C  mulli r28, r27, 0x1c
	ctx.r[28].s32 = ((ctx.r[27].s32 as i64 * 28 as i64) as i32);
	ctx.r[28].s64 = ctx.r[28].s32 as i64;
	// 82C6BF58: 83C100EC  lwz r30, 0xec(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82C6BF5C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6BF60: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82C6BF64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6BF68: 7D4BCBD6  divw r10, r11, r25
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[25].s32;
	// 82C6BF6C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82C6BF70: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C6BF74: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C6BF78: 9B4B0000  stb r26, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 82C6BF7C: 4098006C  bge cr6, 0x82c6bfe8
	if !ctx.cr[6].lt {
	pc = 0x82C6BFE8; continue 'dispatch;
	}
	// 82C6BF80: 7CBCF214  add r5, r28, r30
	ctx.r[5].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 82C6BF84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6BF88: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6BF8C: 4BFFF86D  bl 0x82c6b7f8
	ctx.lr = 0x82C6BF90;
	sub_82C6B7F8(ctx, base);
	// 82C6BF90: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6BF94: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82C6BF98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6BF9C: 7D5E2050  subf r10, r30, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 82C6BFA0: 7D2ACBD6  divw r9, r10, r25
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[25].s32;
	// 82C6BFA4: 7CA9D850  subf r5, r9, r27
	ctx.r[5].s64 = ctx.r[27].s64 - ctx.r[9].s64;
	// 82C6BFA8: 4BFFFBD1  bl 0x82c6bb78
	ctx.lr = 0x82C6BFAC;
	sub_82C6BB78(ctx, base);
	// 82C6BFAC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6BFB0: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82C6BFB4: 7FBC5850  subf r29, r28, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82C6BFB8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C6BFBC: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C6BFC0: 419A0080  beq cr6, 0x82c6c040
	if ctx.cr[6].eq {
	pc = 0x82C6C040; continue 'dispatch;
	}
	pc = 0x82C6BFC4; continue 'dispatch;
            }
            0x82C6BFC4 => {
    //   block [0x82C6BFC4..0x82C6BFE8)
	// 82C6BFC4: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82C6BFC8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6BFCC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C6BFD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6BFD4: 4B522A2D  bl 0x8218ea00
	ctx.lr = 0x82C6BFD8;
	sub_8218EA00(ctx, base);
	// 82C6BFD8: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 82C6BFDC: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C6BFE0: 409AFFE4  bne cr6, 0x82c6bfc4
	if !ctx.cr[6].eq {
	pc = 0x82C6BFC4; continue 'dispatch;
	}
	// 82C6BFE4: 4800005C  b 0x82c6c040
	pc = 0x82C6C040; continue 'dispatch;
            }
            0x82C6BFE8 => {
    //   block [0x82C6BFE8..0x82C6C020)
	// 82C6BFE8: 7F7CE850  subf r27, r28, r29
	ctx.r[27].s64 = ctx.r[29].s64 - ctx.r[28].s64;
	// 82C6BFEC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C6BFF0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C6BFF4: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6BFF8: 4BFFF801  bl 0x82c6b7f8
	ctx.lr = 0x82C6BFFC;
	sub_82C6B7F8(ctx, base);
	// 82C6BFFC: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82C6C000: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C6C004: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C6C008: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6C00C: 4BED5B65  bl 0x82b41b70
	ctx.lr = 0x82C6C010;
	sub_82B41B70(ctx, base);
	// 82C6C010: 7FBCF214  add r29, r28, r30
	ctx.r[29].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 82C6C014: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82C6C018: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C6C01C: 419A0024  beq cr6, 0x82c6c040
	if ctx.cr[6].eq {
	pc = 0x82C6C040; continue 'dispatch;
	}
	pc = 0x82C6C020; continue 'dispatch;
            }
            0x82C6C020 => {
    //   block [0x82C6C020..0x82C6C040)
	// 82C6C020: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82C6C024: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6C028: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C6C02C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6C030: 4B5229D1  bl 0x8218ea00
	ctx.lr = 0x82C6C034;
	sub_8218EA00(ctx, base);
	// 82C6C034: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82C6C038: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C6C03C: 409AFFE4  bne cr6, 0x82c6c020
	if !ctx.cr[6].eq {
	pc = 0x82C6C020; continue 'dispatch;
	}
	pc = 0x82C6C040; continue 'dispatch;
            }
            0x82C6C040 => {
    //   block [0x82C6C040..0x82C6C054)
	// 82C6C040: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C6C044: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 82C6C048: 4198000C  blt cr6, 0x82c6c054
	if ctx.cr[6].lt {
	pc = 0x82C6C054; continue 'dispatch;
	}
	// 82C6C04C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C6C050: 4BBD9761  bl 0x828457b0
	ctx.lr = 0x82C6C054;
	sub_828457B0(ctx, base);
	pc = 0x82C6C054; continue 'dispatch;
            }
            0x82C6C054 => {
    //   block [0x82C6C054..0x82C6C05C)
	// 82C6C054: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82C6C058: 4803D3F0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6C060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6C060 size=88
    let mut pc: u32 = 0x82C6C060;
    'dispatch: loop {
        match pc {
            0x82C6C060 => {
    //   block [0x82C6C060..0x82C6C080)
	// 82C6C060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6C064: 4803D3A9  bl 0x82ca940c
	ctx.lr = 0x82C6C068;
	sub_82CA93D0(ctx, base);
	// 82C6C068: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6C06C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C6C070: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C6C074: 7F03E840  cmplw cr6, r3, r29
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C6C078: 419A0034  beq cr6, 0x82c6c0ac
	if ctx.cr[6].eq {
	pc = 0x82C6C0AC; continue 'dispatch;
	}
	// 82C6C07C: 7FDF1850  subf r30, r31, r3
	ctx.r[30].s64 = ctx.r[3].s64 - ctx.r[31].s64;
	pc = 0x82C6C080; continue 'dispatch;
            }
            0x82C6C080 => {
    //   block [0x82C6C080..0x82C6C09C)
	// 82C6C080: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C6C084: 419A0018  beq cr6, 0x82c6c09c
	if ctx.cr[6].eq {
	pc = 0x82C6C09C; continue 'dispatch;
	}
	// 82C6C088: 7D7EF82E  lwzx r11, r30, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82C6C08C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C6C090: 7C9E1A14  add r4, r30, r3
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[3].u64;
	// 82C6C094: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C6C098: 4B70FEB1  bl 0x8237bf48
	ctx.lr = 0x82C6C09C;
	sub_8237BF48(ctx, base);
	pc = 0x82C6C09C; continue 'dispatch;
            }
            0x82C6C09C => {
    //   block [0x82C6C09C..0x82C6C0AC)
	// 82C6C09C: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 82C6C0A0: 7D7EFA14  add r11, r30, r31
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	// 82C6C0A4: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C6C0A8: 409AFFD8  bne cr6, 0x82c6c080
	if !ctx.cr[6].eq {
	pc = 0x82C6C080; continue 'dispatch;
	}
	pc = 0x82C6C0AC; continue 'dispatch;
            }
            0x82C6C0AC => {
    //   block [0x82C6C0AC..0x82C6C0B8)
	// 82C6C0AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6C0B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6C0B4: 4803D3A8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6C0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6C0B8 size=224
    let mut pc: u32 = 0x82C6C0B8;
    'dispatch: loop {
        match pc {
            0x82C6C0B8 => {
    //   block [0x82C6C0B8..0x82C6C0F4)
	// 82C6C0B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6C0BC: 4803D351  bl 0x82ca940c
	ctx.lr = 0x82C6C0C0;
	sub_82CA93D0(ctx, base);
	// 82C6C0C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6C0C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C6C0C8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82C6C0CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C6C0D0: F88100A0  std r4, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u64 ) };
	// 82C6C0D4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C0D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6C0DC: 419A0018  beq cr6, 0x82c6c0f4
	if ctx.cr[6].eq {
	pc = 0x82C6C0F4; continue 'dispatch;
	}
	// 82C6C0E0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C0E4: 3920001C  li r9, 0x1c
	ctx.r[9].s64 = 28;
	// 82C6C0E8: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6C0EC: 7CE84BD7  divw. r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82C6C0F0: 4082000C  bne 0x82c6c0fc
	if !ctx.cr[0].eq {
	pc = 0x82C6C0FC; continue 'dispatch;
	}
	pc = 0x82C6C0F4; continue 'dispatch;
            }
            0x82C6C0F4 => {
    //   block [0x82C6C0F4..0x82C6C0FC)
	// 82C6C0F4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C6C0F8: 48000034  b 0x82c6c12c
	pc = 0x82C6C12C; continue 'dispatch;
            }
            0x82C6C0FC => {
    //   block [0x82C6C0FC..0x82C6C108)
	// 82C6C0FC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6C100: 40990008  ble cr6, 0x82c6c108
	if !ctx.cr[6].gt {
	pc = 0x82C6C108; continue 'dispatch;
	}
	// 82C6C104: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6C108; continue 'dispatch;
            }
            0x82C6C108 => {
    //   block [0x82C6C108..0x82C6C11C)
	// 82C6C108: 814100A0  lwz r10, 0xa0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 82C6C10C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C6C110: 419A000C  beq cr6, 0x82c6c11c
	if ctx.cr[6].eq {
	pc = 0x82C6C11C; continue 'dispatch;
	}
	// 82C6C114: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C6C118: 419A0008  beq cr6, 0x82c6c120
	if ctx.cr[6].eq {
	pc = 0x82C6C120; continue 'dispatch;
	}
	pc = 0x82C6C11C; continue 'dispatch;
            }
            0x82C6C11C => {
    //   block [0x82C6C11C..0x82C6C120)
	// 82C6C11C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6C120; continue 'dispatch;
            }
            0x82C6C120 => {
    //   block [0x82C6C120..0x82C6C12C)
	// 82C6C120: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82C6C124: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6C128: 7FC84BD6  divw r30, r8, r9
	ctx.r[30].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x82C6C12C; continue 'dispatch;
            }
            0x82C6C12C => {
    //   block [0x82C6C12C..0x82C6C14C)
	// 82C6C12C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C6C130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6C134: 4BFFFC15  bl 0x82c6bd48
	ctx.lr = 0x82C6C138;
	sub_82C6BD48(ctx, base);
	// 82C6C138: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C13C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C140: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6C144: 40990008  ble cr6, 0x82c6c14c
	if !ctx.cr[6].gt {
	pc = 0x82C6C14C; continue 'dispatch;
	}
	// 82C6C148: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6C14C; continue 'dispatch;
            }
            0x82C6C14C => {
    //   block [0x82C6C14C..0x82C6C17C)
	// 82C6C14C: 1D5E001C  mulli r10, r30, 0x1c
	ctx.r[10].s32 = ((ctx.r[30].s32 as i64 * 28 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82C6C150: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C6C154: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C158: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82C6C15C: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C6C160: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82C6C164: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82C6C168: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C6C16C: 41990010  bgt cr6, 0x82c6c17c
	if ctx.cr[6].gt {
	pc = 0x82C6C17C; continue 'dispatch;
	}
	// 82C6C170: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C174: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6C178: 40980008  bge cr6, 0x82c6c180
	if !ctx.cr[6].lt {
	pc = 0x82C6C180; continue 'dispatch;
	}
	pc = 0x82C6C17C; continue 'dispatch;
            }
            0x82C6C17C => {
    //   block [0x82C6C17C..0x82C6C180)
	// 82C6C17C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6C180; continue 'dispatch;
            }
            0x82C6C180 => {
    //   block [0x82C6C180..0x82C6C198)
	// 82C6C180: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C6C184: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6C188: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C6C18C: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82C6C190: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6C194: 4803D2C8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6C198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6C198 size=316
    let mut pc: u32 = 0x82C6C198;
    'dispatch: loop {
        match pc {
            0x82C6C198 => {
    //   block [0x82C6C198..0x82C6C1C8)
	// 82C6C198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6C19C: 4803D26D  bl 0x82ca9408
	ctx.lr = 0x82C6C1A0;
	sub_82CA93D0(ctx, base);
	// 82C6C1A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6C1A4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C6C1A8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C6C1AC: 3BDC0070  addi r30, r28, 0x70
	ctx.r[30].s64 = ctx.r[28].s64 + 112;
	// 82C6C1B0: 394BDEA0  addi r10, r11, -0x2160
	ctx.r[10].s64 = ctx.r[11].s64 + -8544;
	// 82C6C1B4: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C6C1B8: 807C0074  lwz r3, 0x74(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(116 as u32) ) } as u64;
	// 82C6C1BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6C1C0: 419A0008  beq cr6, 0x82c6c1c8
	if ctx.cr[6].eq {
	pc = 0x82C6C1C8; continue 'dispatch;
	}
	// 82C6C1C4: 4BBD95ED  bl 0x828457b0
	ctx.lr = 0x82C6C1C8;
	sub_828457B0(ctx, base);
	pc = 0x82C6C1C8; continue 'dispatch;
            }
            0x82C6C1C8 => {
    //   block [0x82C6C1C8..0x82C6C200)
	// 82C6C1C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C6C1CC: 3BBC0060  addi r29, r28, 0x60
	ctx.r[29].s64 = ctx.r[28].s64 + 96;
	// 82C6C1D0: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C6C1D4: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C6C1D8: 93FE000C  stw r31, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82C6C1DC: 807C0064  lwz r3, 0x64(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C6C1E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6C1E4: 419A001C  beq cr6, 0x82c6c200
	if ctx.cr[6].eq {
	pc = 0x82C6C200; continue 'dispatch;
	}
	// 82C6C1E8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C6C1EC: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6C1F0: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C1F4: 4BFFF2D5  bl 0x82c6b4c8
	ctx.lr = 0x82C6C1F8;
	sub_82C6B4C8(ctx, base);
	// 82C6C1F8: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C1FC: 4BBD95B5  bl 0x828457b0
	ctx.lr = 0x82C6C200;
	sub_828457B0(ctx, base);
	pc = 0x82C6C200; continue 'dispatch;
            }
            0x82C6C200 => {
    //   block [0x82C6C200..0x82C6C234)
	// 82C6C200: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C6C204: 3BDC0050  addi r30, r28, 0x50
	ctx.r[30].s64 = ctx.r[28].s64 + 80;
	// 82C6C208: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C6C20C: 93FD000C  stw r31, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82C6C210: 807C0054  lwz r3, 0x54(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C6C214: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6C218: 419A001C  beq cr6, 0x82c6c234
	if ctx.cr[6].eq {
	pc = 0x82C6C234; continue 'dispatch;
	}
	// 82C6C21C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C6C220: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6C224: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C228: 4BFFF8F9  bl 0x82c6bb20
	ctx.lr = 0x82C6C22C;
	sub_82C6BB20(ctx, base);
	// 82C6C22C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C230: 4BBD9581  bl 0x828457b0
	ctx.lr = 0x82C6C234;
	sub_828457B0(ctx, base);
	pc = 0x82C6C234; continue 'dispatch;
            }
            0x82C6C234 => {
    //   block [0x82C6C234..0x82C6C254)
	// 82C6C234: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C6C238: 3BBC0040  addi r29, r28, 0x40
	ctx.r[29].s64 = ctx.r[28].s64 + 64;
	// 82C6C23C: 93FE000C  stw r31, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82C6C240: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C6C244: 807C0044  lwz r3, 0x44(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 82C6C248: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6C24C: 419A0008  beq cr6, 0x82c6c254
	if ctx.cr[6].eq {
	pc = 0x82C6C254; continue 'dispatch;
	}
	// 82C6C250: 4BBD9561  bl 0x828457b0
	ctx.lr = 0x82C6C254;
	sub_828457B0(ctx, base);
	pc = 0x82C6C254; continue 'dispatch;
            }
            0x82C6C254 => {
    //   block [0x82C6C254..0x82C6C27C)
	// 82C6C254: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C6C258: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C6C25C: 93FD000C  stw r31, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82C6C260: 807C003C  lwz r3, 0x3c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) } as u64;
	// 82C6C264: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6C268: 419A0014  beq cr6, 0x82c6c27c
	if ctx.cr[6].eq {
	pc = 0x82C6C27C; continue 'dispatch;
	}
	// 82C6C26C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6C270: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C274: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6C278: 4E800421  bctrl
	ctx.lr = 0x82C6C27C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6C27C => {
    //   block [0x82C6C27C..0x82C6C298)
	// 82C6C27C: 807C0038  lwz r3, 0x38(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 82C6C280: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6C284: 419A0014  beq cr6, 0x82c6c298
	if ctx.cr[6].eq {
	pc = 0x82C6C298; continue 'dispatch;
	}
	// 82C6C288: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6C28C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C290: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6C294: 4E800421  bctrl
	ctx.lr = 0x82C6C298;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6C298 => {
    //   block [0x82C6C298..0x82C6C2B0)
	// 82C6C298: 817C0020  lwz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C6C29C: 3BDC0008  addi r30, r28, 8
	ctx.r[30].s64 = ctx.r[28].s64 + 8;
	// 82C6C2A0: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82C6C2A4: 4198000C  blt cr6, 0x82c6c2b0
	if ctx.cr[6].lt {
	pc = 0x82C6C2B0; continue 'dispatch;
	}
	// 82C6C2A8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C2AC: 4BBD9505  bl 0x828457b0
	ctx.lr = 0x82C6C2B0;
	sub_828457B0(ctx, base);
	pc = 0x82C6C2B0; continue 'dispatch;
            }
            0x82C6C2B0 => {
    //   block [0x82C6C2B0..0x82C6C2D4)
	// 82C6C2B0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82C6C2B4: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82C6C2B8: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 82C6C2BC: 392B8F38  addi r9, r11, -0x70c8
	ctx.r[9].s64 = ctx.r[11].s64 + -28872;
	// 82C6C2C0: 915E0018  stw r10, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C6C2C4: B3FE0004  sth r31, 4(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u16 ) };
	// 82C6C2C8: 913C0000  stw r9, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C6C2CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6C2D0: 4803D188  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6C2D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6C2D8 size=216
    let mut pc: u32 = 0x82C6C2D8;
    'dispatch: loop {
        match pc {
            0x82C6C2D8 => {
    //   block [0x82C6C2D8..0x82C6C30C)
	// 82C6C2D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6C2DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6C2E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6C2E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6C2E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6C2EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6C2F0: 3920001C  li r9, 0x1c
	ctx.r[9].s64 = 28;
	// 82C6C2F4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82C6C2F8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C2FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6C300: 409A000C  bne cr6, 0x82c6c30c
	if !ctx.cr[6].eq {
	pc = 0x82C6C30C; continue 'dispatch;
	}
	// 82C6C304: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82C6C308: 48000010  b 0x82c6c318
	pc = 0x82C6C318; continue 'dispatch;
            }
            0x82C6C30C => {
    //   block [0x82C6C30C..0x82C6C318)
	// 82C6C30C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C310: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6C314: 7D474BD6  divw r10, r7, r9
	ctx.r[10].s32 = ctx.r[7].s32 / ctx.r[9].s32;
	pc = 0x82C6C318; continue 'dispatch;
            }
            0x82C6C318 => {
    //   block [0x82C6C318..0x82C6C360)
	// 82C6C318: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6C31C: 419A0050  beq cr6, 0x82c6c36c
	if ctx.cr[6].eq {
	pc = 0x82C6C36C; continue 'dispatch;
	}
	// 82C6C320: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6C324: 7CCB3850  subf r6, r11, r7
	ctx.r[6].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82C6C328: 7CA64BD6  divw r5, r6, r9
	ctx.r[5].s32 = ctx.r[6].s32 / ctx.r[9].s32;
	// 82C6C32C: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C6C330: 4098003C  bge cr6, 0x82c6c36c
	if !ctx.cr[6].lt {
	pc = 0x82C6C36C; continue 'dispatch;
	}
	// 82C6C334: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C338: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C6C33C: 419A0024  beq cr6, 0x82c6c360
	if ctx.cr[6].eq {
	pc = 0x82C6C360; continue 'dispatch;
	}
	// 82C6C340: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 82C6C344: 911E0014  stw r8, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82C6C348: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82C6C34C: 917E0018  stw r11, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82C6C350: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6C354: 991E0004  stb r8, 4(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[8].u8 ) };
	// 82C6C358: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6C35C: 4B5226A5  bl 0x8218ea00
	ctx.lr = 0x82C6C360;
	sub_8218EA00(ctx, base);
	pc = 0x82C6C360; continue 'dispatch;
            }
            0x82C6C360 => {
    //   block [0x82C6C360..0x82C6C36C)
	// 82C6C360: 397E001C  addi r11, r30, 0x1c
	ctx.r[11].s64 = ctx.r[30].s64 + 28;
	// 82C6C364: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C6C368: 48000030  b 0x82c6c398
	pc = 0x82C6C398; continue 'dispatch;
            }
            0x82C6C36C => {
    //   block [0x82C6C36C..0x82C6C37C)
	// 82C6C36C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C370: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6C374: 40990008  ble cr6, 0x82c6c37c
	if !ctx.cr[6].gt {
	pc = 0x82C6C37C; continue 'dispatch;
	}
	// 82C6C378: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6C37C; continue 'dispatch;
            }
            0x82C6C37C => {
    //   block [0x82C6C37C..0x82C6C398)
	// 82C6C37C: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82C6C380: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82C6C384: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C6C388: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82C6C38C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C6C390: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C6C394: 4BFFFD25  bl 0x82c6c0b8
	ctx.lr = 0x82C6C398;
	sub_82C6C0B8(ctx, base);
	pc = 0x82C6C398; continue 'dispatch;
            }
            0x82C6C398 => {
    //   block [0x82C6C398..0x82C6C3B0)
	// 82C6C398: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6C39C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6C3A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6C3A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6C3A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6C3AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6C3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6C3B0 size=104
    let mut pc: u32 = 0x82C6C3B0;
    'dispatch: loop {
        match pc {
            0x82C6C3B0 => {
    //   block [0x82C6C3B0..0x82C6C3D8)
	// 82C6C3B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6C3B4: 4803D051  bl 0x82ca9404
	ctx.lr = 0x82C6C3B8;
	sub_82CA93D0(ctx, base);
	// 82C6C3B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6C3BC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C6C3C0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C6C3C4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82C6C3C8: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82C6C3CC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82C6C3D0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C6C3D4: 419A002C  beq cr6, 0x82c6c400
	if ctx.cr[6].eq {
	pc = 0x82C6C400; continue 'dispatch;
	}
	pc = 0x82C6C3D8; continue 'dispatch;
            }
            0x82C6C3D8 => {
    //   block [0x82C6C3D8..0x82C6C3F4)
	// 82C6C3D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C6C3DC: 419A0018  beq cr6, 0x82c6c3f4
	if ctx.cr[6].eq {
	pc = 0x82C6C3F4; continue 'dispatch;
	}
	// 82C6C3E0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6C3E4: 389C0004  addi r4, r28, 4
	ctx.r[4].s64 = ctx.r[28].s64 + 4;
	// 82C6C3E8: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C6C3EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C6C3F0: 4B70FB59  bl 0x8237bf48
	ctx.lr = 0x82C6C3F4;
	sub_8237BF48(ctx, base);
	pc = 0x82C6C3F4; continue 'dispatch;
            }
            0x82C6C3F4 => {
    //   block [0x82C6C3F4..0x82C6C400)
	// 82C6C3F4: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82C6C3F8: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 82C6C3FC: 4082FFDC  bne 0x82c6c3d8
	if !ctx.cr[0].eq {
	pc = 0x82C6C3D8; continue 'dispatch;
	}
	pc = 0x82C6C400; continue 'dispatch;
            }
            0x82C6C400 => {
    //   block [0x82C6C400..0x82C6C418)
	// 82C6C400: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6C404: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82C6C408: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6C40C: 7C6BDA14  add r3, r11, r27
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82C6C410: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6C414: 4803D040  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6C418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6C418 size=80
    let mut pc: u32 = 0x82C6C418;
    'dispatch: loop {
        match pc {
            0x82C6C418 => {
    //   block [0x82C6C418..0x82C6C450)
	// 82C6C418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6C41C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6C420: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6C424: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6C428: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6C42C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6C430: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C6C434: 4BFFFD65  bl 0x82c6c198
	ctx.lr = 0x82C6C438;
	sub_82C6C198(ctx, base);
	// 82C6C438: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C6C43C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6C440: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6C444: 419A000C  beq cr6, 0x82c6c450
	if ctx.cr[6].eq {
	pc = 0x82C6C450; continue 'dispatch;
	}
	// 82C6C448: 4BBD9369  bl 0x828457b0
	ctx.lr = 0x82C6C44C;
	sub_828457B0(ctx, base);
	// 82C6C44C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C6C450; continue 'dispatch;
            }
            0x82C6C450 => {
    //   block [0x82C6C450..0x82C6C468)
	// 82C6C450: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6C454: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6C458: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6C45C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6C460: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6C464: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6C468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6C468 size=256
    let mut pc: u32 = 0x82C6C468;
    'dispatch: loop {
        match pc {
            0x82C6C468 => {
    //   block [0x82C6C468..0x82C6C498)
	// 82C6C468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6C46C: 4803CF9D  bl 0x82ca9408
	ctx.lr = 0x82C6C470;
	sub_82CA93D0(ctx, base);
	// 82C6C470: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6C474: 3D600CCC  lis r11, 0xccc
	ctx.r[11].s64 = 214695936;
	// 82C6C478: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C6C47C: 616ACCCC  ori r10, r11, 0xcccc
	ctx.r[10].u64 = ctx.r[11].u64 | 52428;
	// 82C6C480: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6C484: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6C488: 40990010  ble cr6, 0x82c6c498
	if !ctx.cr[6].gt {
	pc = 0x82C6C498; continue 'dispatch;
	}
	// 82C6C48C: 4BF92FDD  bl 0x82bff468
	ctx.lr = 0x82C6C490;
	sub_82BFF468(ctx, base);
	// 82C6C490: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6C494: 4803CFC4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6C498 => {
    //   block [0x82C6C498..0x82C6C4B4)
	// 82C6C498: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C49C: 3BA00014  li r29, 0x14
	ctx.r[29].s64 = 20;
	// 82C6C4A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6C4A4: 419A0010  beq cr6, 0x82c6c4b4
	if ctx.cr[6].eq {
	pc = 0x82C6C4B4; continue 'dispatch;
	}
	// 82C6C4A8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6C4AC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6C4B0: 7D69EBD6  divw r11, r9, r29
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[29].s32;
	pc = 0x82C6C4B4; continue 'dispatch;
            }
            0x82C6C4B4 => {
    //   block [0x82C6C4B4..0x82C6C4E4)
	// 82C6C4B4: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C6C4B8: 409800A8  bge cr6, 0x82c6c560
	if !ctx.cr[6].lt {
	pc = 0x82C6C560; continue 'dispatch;
	}
	// 82C6C4BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C6C4C0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C6C4C4: 4BFFE38D  bl 0x82c6a850
	ctx.lr = 0x82C6C4C8;
	sub_82C6A850(ctx, base);
	// 82C6C4C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C4CC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C4D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C6C4D4: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82C6C4D8: 4099000C  ble cr6, 0x82c6c4e4
	if !ctx.cr[6].gt {
	pc = 0x82C6C4E4; continue 'dispatch;
	}
	// 82C6C4DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82C6C4E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6C4E4; continue 'dispatch;
            }
            0x82C6C4E4 => {
    //   block [0x82C6C4E4..0x82C6C508)
	// 82C6C4E4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C6C4E8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C6C4EC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C6C4F0: 4BFFFB71  bl 0x82c6c060
	ctx.lr = 0x82C6C4F4;
	sub_82C6C060(ctx, base);
	// 82C6C4F4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C4F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6C4FC: 409A000C  bne cr6, 0x82c6c508
	if !ctx.cr[6].eq {
	pc = 0x82C6C508; continue 'dispatch;
	}
	// 82C6C500: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C6C504: 48000010  b 0x82c6c514
	pc = 0x82C6C514; continue 'dispatch;
            }
            0x82C6C508 => {
    //   block [0x82C6C508..0x82C6C514)
	// 82C6C508: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C50C: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82C6C510: 7FAAEBD6  divw r29, r10, r29
	ctx.r[29].s32 = ctx.r[10].s32 / ctx.r[29].s32;
	pc = 0x82C6C514; continue 'dispatch;
            }
            0x82C6C514 => {
    //   block [0x82C6C514..0x82C6C534)
	// 82C6C514: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6C518: 419A001C  beq cr6, 0x82c6c534
	if ctx.cr[6].eq {
	pc = 0x82C6C534; continue 'dispatch;
	}
	// 82C6C51C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C6C520: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6C524: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C528: 4BFFF5F9  bl 0x82c6bb20
	ctx.lr = 0x82C6C52C;
	sub_82C6BB20(ctx, base);
	// 82C6C52C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C530: 4BBD9281  bl 0x828457b0
	ctx.lr = 0x82C6C534;
	sub_828457B0(ctx, base);
	pc = 0x82C6C534; continue 'dispatch;
            }
            0x82C6C534 => {
    //   block [0x82C6C534..0x82C6C560)
	// 82C6C534: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6C538: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C6C53C: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6C540: 7D3D5A14  add r9, r29, r11
	ctx.r[9].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82C6C544: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 82C6C548: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6C54C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6C550: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C6C554: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82C6C558: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82C6C55C: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	pc = 0x82C6C560; continue 'dispatch;
            }
            0x82C6C560 => {
    //   block [0x82C6C560..0x82C6C568)
	// 82C6C560: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6C564: 4803CEF4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6C568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6C568 size=752
    let mut pc: u32 = 0x82C6C568;
    'dispatch: loop {
        match pc {
            0x82C6C568 => {
    //   block [0x82C6C568..0x82C6C5AC)
	// 82C6C568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6C56C: 4803CE95  bl 0x82ca9400
	ctx.lr = 0x82C6C570;
	sub_82CA93D0(ctx, base);
	// 82C6C570: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6C574: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6C578: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6C57C: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 82C6C580: 38860004  addi r4, r6, 4
	ctx.r[4].s64 = ctx.r[6].s64 + 4;
	// 82C6C584: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82C6C588: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C6C58C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82C6C590: 4B70F9B9  bl 0x8237bf48
	ctx.lr = 0x82C6C594;
	sub_8237BF48(ctx, base);
	// 82C6C594: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C598: 3B400014  li r26, 0x14
	ctx.r[26].s64 = 20;
	// 82C6C59C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6C5A0: 409A000C  bne cr6, 0x82c6c5ac
	if !ctx.cr[6].eq {
	pc = 0x82C6C5AC; continue 'dispatch;
	}
	// 82C6C5A4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82C6C5A8: 48000010  b 0x82c6c5b8
	pc = 0x82C6C5B8; continue 'dispatch;
            }
            0x82C6C5AC => {
    //   block [0x82C6C5AC..0x82C6C5B8)
	// 82C6C5AC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6C5B0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6C5B4: 7D09D3D6  divw r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	pc = 0x82C6C5B8; continue 'dispatch;
            }
            0x82C6C5B8 => {
    //   block [0x82C6C5B8..0x82C6C5D0)
	// 82C6C5B8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C6C5BC: 419A0284  beq cr6, 0x82c6c840
	if ctx.cr[6].eq {
	pc = 0x82C6C840; continue 'dispatch;
	}
	// 82C6C5C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6C5C4: 409A000C  bne cr6, 0x82c6c5d0
	if !ctx.cr[6].eq {
	pc = 0x82C6C5D0; continue 'dispatch;
	}
	// 82C6C5C8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C6C5CC: 48000010  b 0x82c6c5dc
	pc = 0x82C6C5DC; continue 'dispatch;
            }
            0x82C6C5D0 => {
    //   block [0x82C6C5D0..0x82C6C5DC)
	// 82C6C5D0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C5D4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6C5D8: 7D49D3D6  divw r10, r9, r26
	ctx.r[10].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	pc = 0x82C6C5DC; continue 'dispatch;
            }
            0x82C6C5DC => {
    //   block [0x82C6C5DC..0x82C6C5F8)
	// 82C6C5DC: 3D200CCC  lis r9, 0xccc
	ctx.r[9].s64 = 214695936;
	// 82C6C5E0: 6129CCCC  ori r9, r9, 0xcccc
	ctx.r[9].u64 = ctx.r[9].u64 | 52428;
	// 82C6C5E4: 7CEA4850  subf r7, r10, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82C6C5E8: 7F07E040  cmplw cr6, r7, r28
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C6C5EC: 4098000C  bge cr6, 0x82c6c5f8
	if !ctx.cr[6].lt {
	pc = 0x82C6C5F8; continue 'dispatch;
	}
	// 82C6C5F0: 4BF92E79  bl 0x82bff468
	ctx.lr = 0x82C6C5F4;
	sub_82BFF468(ctx, base);
	// 82C6C5F4: 4800024C  b 0x82c6c840
	pc = 0x82C6C840; continue 'dispatch;
            }
            0x82C6C5F8 => {
    //   block [0x82C6C5F8..0x82C6C608)
	// 82C6C5F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6C5FC: 409A000C  bne cr6, 0x82c6c608
	if !ctx.cr[6].eq {
	pc = 0x82C6C608; continue 'dispatch;
	}
	// 82C6C600: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C6C604: 48000010  b 0x82c6c614
	pc = 0x82C6C614; continue 'dispatch;
            }
            0x82C6C608 => {
    //   block [0x82C6C608..0x82C6C614)
	// 82C6C608: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C60C: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6C610: 7D47D3D6  divw r10, r7, r26
	ctx.r[10].s32 = ctx.r[7].s32 / ctx.r[26].s32;
	pc = 0x82C6C614; continue 'dispatch;
            }
            0x82C6C614 => {
    //   block [0x82C6C614..0x82C6C638)
	// 82C6C614: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 82C6C618: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6C61C: 40980124  bge cr6, 0x82c6c740
	if !ctx.cr[6].lt {
	pc = 0x82C6C740; continue 'dispatch;
	}
	// 82C6C620: 550AF87E  srwi r10, r8, 1
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6C624: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82C6C628: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82C6C62C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C6C630: 41980008  blt cr6, 0x82c6c638
	if ctx.cr[6].lt {
	pc = 0x82C6C638; continue 'dispatch;
	}
	// 82C6C634: 7F6A4214  add r27, r10, r8
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	pc = 0x82C6C638; continue 'dispatch;
            }
            0x82C6C638 => {
    //   block [0x82C6C638..0x82C6C648)
	// 82C6C638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6C63C: 409A000C  bne cr6, 0x82c6c648
	if !ctx.cr[6].eq {
	pc = 0x82C6C648; continue 'dispatch;
	}
	// 82C6C640: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C6C644: 48000010  b 0x82c6c654
	pc = 0x82C6C654; continue 'dispatch;
            }
            0x82C6C648 => {
    //   block [0x82C6C648..0x82C6C654)
	// 82C6C648: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C64C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6C650: 7D49D3D6  divw r10, r9, r26
	ctx.r[10].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	pc = 0x82C6C654; continue 'dispatch;
            }
            0x82C6C654 => {
    //   block [0x82C6C654..0x82C6C674)
	// 82C6C654: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 82C6C658: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6C65C: 4098001C  bge cr6, 0x82c6c678
	if !ctx.cr[6].lt {
	pc = 0x82C6C678; continue 'dispatch;
	}
	// 82C6C660: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6C664: 419A0010  beq cr6, 0x82c6c674
	if ctx.cr[6].eq {
	pc = 0x82C6C674; continue 'dispatch;
	}
	// 82C6C668: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C66C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6C670: 7D69D3D6  divw r11, r9, r26
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	pc = 0x82C6C674; continue 'dispatch;
            }
            0x82C6C674 => {
    //   block [0x82C6C674..0x82C6C678)
	// 82C6C674: 7F6BE214  add r27, r11, r28
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x82C6C678; continue 'dispatch;
            }
            0x82C6C678 => {
    //   block [0x82C6C678..0x82C6C6E0)
	// 82C6C678: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C6C67C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C6C680: 4BFFE1D1  bl 0x82c6a850
	ctx.lr = 0x82C6C684;
	sub_82C6A850(ctx, base);
	// 82C6C684: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C688: 83A100CC  lwz r29, 0xcc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82C6C68C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C6C690: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C6C694: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C6C698: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6C69C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C6C6A0: 4BFFF9C1  bl 0x82c6c060
	ctx.lr = 0x82C6C6A4;
	sub_82C6C060(ctx, base);
	// 82C6C6A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6C6A8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82C6C6AC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C6C6B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6C6B4: 4BFFFCFD  bl 0x82c6c3b0
	ctx.lr = 0x82C6C6B8;
	sub_82C6C3B0(ctx, base);
	// 82C6C6B8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C6C6BC: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C6C6C0: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C6C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6C6C8: 4BFFF999  bl 0x82c6c060
	ctx.lr = 0x82C6C6CC;
	sub_82C6C060(ctx, base);
	// 82C6C6CC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C6D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6C6D4: 409A000C  bne cr6, 0x82c6c6e0
	if !ctx.cr[6].eq {
	pc = 0x82C6C6E0; continue 'dispatch;
	}
	// 82C6C6D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6C6DC: 48000010  b 0x82c6c6ec
	pc = 0x82C6C6EC; continue 'dispatch;
            }
            0x82C6C6E0 => {
    //   block [0x82C6C6E0..0x82C6C6EC)
	// 82C6C6E0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C6E4: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82C6C6E8: 7D6AD3D6  divw r11, r10, r26
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	pc = 0x82C6C6EC; continue 'dispatch;
            }
            0x82C6C6EC => {
    //   block [0x82C6C6EC..0x82C6C710)
	// 82C6C6EC: 7FABE214  add r29, r11, r28
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82C6C6F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6C6F4: 419A001C  beq cr6, 0x82c6c710
	if ctx.cr[6].eq {
	pc = 0x82C6C710; continue 'dispatch;
	}
	// 82C6C6F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C6C6FC: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6C700: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C704: 4BFFF41D  bl 0x82c6bb20
	ctx.lr = 0x82C6C708;
	sub_82C6BB20(ctx, base);
	// 82C6C708: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C70C: 4BBD90A5  bl 0x828457b0
	ctx.lr = 0x82C6C710;
	sub_828457B0(ctx, base);
	pc = 0x82C6C710; continue 'dispatch;
            }
            0x82C6C710 => {
    //   block [0x82C6C710..0x82C6C740)
	// 82C6C710: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6C714: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C6C718: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6C71C: 7D7B5A14  add r11, r27, r11
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 82C6C720: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 82C6C724: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6C728: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6C72C: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C6C730: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82C6C734: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82C6C738: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82C6C73C: 48000104  b 0x82c6c840
	pc = 0x82C6C840; continue 'dispatch;
            }
            0x82C6C740 => {
    //   block [0x82C6C740..0x82C6C7AC)
	// 82C6C740: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C744: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C6C748: 83C100CC  lwz r30, 0xcc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82C6C74C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6C750: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82C6C754: 7D4BD3D6  divw r10, r11, r26
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 82C6C758: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C6C75C: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C6C760: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82C6C764: 4098006C  bge cr6, 0x82c6c7d0
	if !ctx.cr[6].lt {
	pc = 0x82C6C7D0; continue 'dispatch;
	}
	// 82C6C768: 557D103A  slwi r29, r11, 2
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82C6C76C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6C770: 7CBDF214  add r5, r29, r30
	ctx.r[5].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 82C6C774: 4BFFF8ED  bl 0x82c6c060
	ctx.lr = 0x82C6C778;
	sub_82C6C060(ctx, base);
	// 82C6C778: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C77C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82C6C780: 7D5E2050  subf r10, r30, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 82C6C784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6C788: 7D2AD3D6  divw r9, r10, r26
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	// 82C6C78C: 7CA9E050  subf r5, r9, r28
	ctx.r[5].s64 = ctx.r[28].s64 - ctx.r[9].s64;
	// 82C6C790: 4BFFFC21  bl 0x82c6c3b0
	ctx.lr = 0x82C6C794;
	sub_82C6C3B0(ctx, base);
	// 82C6C794: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C798: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82C6C79C: 7FBD5850  subf r29, r29, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 82C6C7A0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C6C7A4: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C6C7A8: 419A0098  beq cr6, 0x82c6c840
	if ctx.cr[6].eq {
	pc = 0x82C6C840; continue 'dispatch;
	}
	pc = 0x82C6C7AC; continue 'dispatch;
            }
            0x82C6C7AC => {
    //   block [0x82C6C7AC..0x82C6C7D0)
	// 82C6C7AC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82C6C7B0: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C6C7B4: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82C6C7B8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C6C7BC: 4B70F845  bl 0x8237c000
	ctx.lr = 0x82C6C7C0;
	sub_8237C000(ctx, base);
	// 82C6C7C0: 3BDE0014  addi r30, r30, 0x14
	ctx.r[30].s64 = ctx.r[30].s64 + 20;
	// 82C6C7C4: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C6C7C8: 409AFFE4  bne cr6, 0x82c6c7ac
	if !ctx.cr[6].eq {
	pc = 0x82C6C7AC; continue 'dispatch;
	}
	// 82C6C7CC: 48000074  b 0x82c6c840
	pc = 0x82C6C840; continue 'dispatch;
            }
            0x82C6C7D0 => {
    //   block [0x82C6C7D0..0x82C6C820)
	// 82C6C7D0: 557C103A  slwi r28, r11, 2
	ctx.r[28].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82C6C7D4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C6C7D8: 7F7CE850  subf r27, r28, r29
	ctx.r[27].s64 = ctx.r[29].s64 - ctx.r[28].s64;
	// 82C6C7DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C6C7E0: 4BFFF881  bl 0x82c6c060
	ctx.lr = 0x82C6C7E4;
	sub_82C6C060(ctx, base);
	// 82C6C7E4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C6C7E8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C6C7EC: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6C7F0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6C7F4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C6C7F8: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82C6C7FC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C6C800: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6C804: 992A0000  stb r9, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 82C6C808: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6C80C: 4BFFF3D5  bl 0x82c6bbe0
	ctx.lr = 0x82C6C810;
	sub_82C6BBE0(ctx, base);
	// 82C6C810: 7FBCF214  add r29, r28, r30
	ctx.r[29].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 82C6C814: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82C6C818: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C6C81C: 419A0024  beq cr6, 0x82c6c840
	if ctx.cr[6].eq {
	pc = 0x82C6C840; continue 'dispatch;
	}
	pc = 0x82C6C820; continue 'dispatch;
            }
            0x82C6C820 => {
    //   block [0x82C6C820..0x82C6C840)
	// 82C6C820: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82C6C824: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C6C828: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C6C82C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C6C830: 4B70F7D1  bl 0x8237c000
	ctx.lr = 0x82C6C834;
	sub_8237C000(ctx, base);
	// 82C6C834: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 82C6C838: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C6C83C: 409AFFE4  bne cr6, 0x82c6c820
	if !ctx.cr[6].eq {
	pc = 0x82C6C820; continue 'dispatch;
	}
	pc = 0x82C6C840; continue 'dispatch;
            }
            0x82C6C840 => {
    //   block [0x82C6C840..0x82C6C850)
	// 82C6C840: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C6C844: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6C848: 419A0008  beq cr6, 0x82c6c850
	if ctx.cr[6].eq {
	pc = 0x82C6C850; continue 'dispatch;
	}
	// 82C6C84C: 4BBD8F65  bl 0x828457b0
	ctx.lr = 0x82C6C850;
	sub_828457B0(ctx, base);
	pc = 0x82C6C850; continue 'dispatch;
            }
            0x82C6C850 => {
    //   block [0x82C6C850..0x82C6C858)
	// 82C6C850: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C6C854: 4803CBFC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6C858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6C858 size=232
    let mut pc: u32 = 0x82C6C858;
    'dispatch: loop {
        match pc {
            0x82C6C858 => {
    //   block [0x82C6C858..0x82C6C894)
	// 82C6C858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6C85C: 4803CBB1  bl 0x82ca940c
	ctx.lr = 0x82C6C860;
	sub_82CA93D0(ctx, base);
	// 82C6C860: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6C864: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C6C868: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82C6C86C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C6C870: F88100A0  std r4, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u64 ) };
	// 82C6C874: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C878: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6C87C: 419A0018  beq cr6, 0x82c6c894
	if ctx.cr[6].eq {
	pc = 0x82C6C894; continue 'dispatch;
	}
	// 82C6C880: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C884: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 82C6C888: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6C88C: 7CE84BD7  divw. r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82C6C890: 4082000C  bne 0x82c6c89c
	if !ctx.cr[0].eq {
	pc = 0x82C6C89C; continue 'dispatch;
	}
	pc = 0x82C6C894; continue 'dispatch;
            }
            0x82C6C894 => {
    //   block [0x82C6C894..0x82C6C89C)
	// 82C6C894: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C6C898: 48000034  b 0x82c6c8cc
	pc = 0x82C6C8CC; continue 'dispatch;
            }
            0x82C6C89C => {
    //   block [0x82C6C89C..0x82C6C8A8)
	// 82C6C89C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6C8A0: 40990008  ble cr6, 0x82c6c8a8
	if !ctx.cr[6].gt {
	pc = 0x82C6C8A8; continue 'dispatch;
	}
	// 82C6C8A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6C8A8; continue 'dispatch;
            }
            0x82C6C8A8 => {
    //   block [0x82C6C8A8..0x82C6C8BC)
	// 82C6C8A8: 814100A0  lwz r10, 0xa0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 82C6C8AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C6C8B0: 419A000C  beq cr6, 0x82c6c8bc
	if ctx.cr[6].eq {
	pc = 0x82C6C8BC; continue 'dispatch;
	}
	// 82C6C8B4: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C6C8B8: 419A0008  beq cr6, 0x82c6c8c0
	if ctx.cr[6].eq {
	pc = 0x82C6C8C0; continue 'dispatch;
	}
	pc = 0x82C6C8BC; continue 'dispatch;
            }
            0x82C6C8BC => {
    //   block [0x82C6C8BC..0x82C6C8C0)
	// 82C6C8BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6C8C0; continue 'dispatch;
            }
            0x82C6C8C0 => {
    //   block [0x82C6C8C0..0x82C6C8CC)
	// 82C6C8C0: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82C6C8C4: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6C8C8: 7FC84BD6  divw r30, r8, r9
	ctx.r[30].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x82C6C8CC; continue 'dispatch;
            }
            0x82C6C8CC => {
    //   block [0x82C6C8CC..0x82C6C8EC)
	// 82C6C8CC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C6C8D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6C8D4: 4BFFFC95  bl 0x82c6c568
	ctx.lr = 0x82C6C8D8;
	sub_82C6C568(ctx, base);
	// 82C6C8D8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C8DC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C8E0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6C8E4: 40990008  ble cr6, 0x82c6c8ec
	if !ctx.cr[6].gt {
	pc = 0x82C6C8EC; continue 'dispatch;
	}
	// 82C6C8E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6C8EC; continue 'dispatch;
            }
            0x82C6C8EC => {
    //   block [0x82C6C8EC..0x82C6C924)
	// 82C6C8EC: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6C8F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C6C8F4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C8F8: 7D1E5214  add r8, r30, r10
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82C6C8FC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82C6C900: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C6C904: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C6C908: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 82C6C90C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82C6C910: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C6C914: 41990010  bgt cr6, 0x82c6c924
	if ctx.cr[6].gt {
	pc = 0x82C6C924; continue 'dispatch;
	}
	// 82C6C918: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C91C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6C920: 40980008  bge cr6, 0x82c6c928
	if !ctx.cr[6].lt {
	pc = 0x82C6C928; continue 'dispatch;
	}
	pc = 0x82C6C924; continue 'dispatch;
            }
            0x82C6C924 => {
    //   block [0x82C6C924..0x82C6C928)
	// 82C6C924: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6C928; continue 'dispatch;
            }
            0x82C6C928 => {
    //   block [0x82C6C928..0x82C6C940)
	// 82C6C928: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C6C92C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6C930: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C6C934: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82C6C938: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6C93C: 4803CB20  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6C940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6C940 size=200
    let mut pc: u32 = 0x82C6C940;
    'dispatch: loop {
        match pc {
            0x82C6C940 => {
    //   block [0x82C6C940..0x82C6C974)
	// 82C6C940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6C944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6C948: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6C94C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6C950: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6C954: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6C958: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82C6C95C: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 82C6C960: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6C964: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6C968: 409A000C  bne cr6, 0x82c6c974
	if !ctx.cr[6].eq {
	pc = 0x82C6C974; continue 'dispatch;
	}
	// 82C6C96C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C6C970: 48000010  b 0x82c6c980
	pc = 0x82C6C980; continue 'dispatch;
            }
            0x82C6C974 => {
    //   block [0x82C6C974..0x82C6C980)
	// 82C6C974: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C978: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6C97C: 7D484BD6  divw r10, r8, r9
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x82C6C980; continue 'dispatch;
            }
            0x82C6C980 => {
    //   block [0x82C6C980..0x82C6C9BC)
	// 82C6C980: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6C984: 419A0044  beq cr6, 0x82c6c9c8
	if ctx.cr[6].eq {
	pc = 0x82C6C9C8; continue 'dispatch;
	}
	// 82C6C988: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6C98C: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82C6C990: 7CA74BD6  divw r5, r7, r9
	ctx.r[5].s32 = ctx.r[7].s32 / ctx.r[9].s32;
	// 82C6C994: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C6C998: 40980030  bge cr6, 0x82c6c9c8
	if !ctx.cr[6].lt {
	pc = 0x82C6C9C8; continue 'dispatch;
	}
	// 82C6C99C: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C9A0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C6C9A4: 419A0018  beq cr6, 0x82c6c9bc
	if ctx.cr[6].eq {
	pc = 0x82C6C9BC; continue 'dispatch;
	}
	// 82C6C9A8: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6C9AC: 38860004  addi r4, r6, 4
	ctx.r[4].s64 = ctx.r[6].s64 + 4;
	// 82C6C9B0: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82C6C9B4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C6C9B8: 4B70F591  bl 0x8237bf48
	ctx.lr = 0x82C6C9BC;
	sub_8237BF48(ctx, base);
	pc = 0x82C6C9BC; continue 'dispatch;
            }
            0x82C6C9BC => {
    //   block [0x82C6C9BC..0x82C6C9C8)
	// 82C6C9BC: 397E0014  addi r11, r30, 0x14
	ctx.r[11].s64 = ctx.r[30].s64 + 20;
	// 82C6C9C0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C6C9C4: 4800002C  b 0x82c6c9f0
	pc = 0x82C6C9F0; continue 'dispatch;
            }
            0x82C6C9C8 => {
    //   block [0x82C6C9C8..0x82C6C9D8)
	// 82C6C9C8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6C9CC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6C9D0: 40990008  ble cr6, 0x82c6c9d8
	if !ctx.cr[6].gt {
	pc = 0x82C6C9D8; continue 'dispatch;
	}
	// 82C6C9D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6C9D8; continue 'dispatch;
            }
            0x82C6C9D8 => {
    //   block [0x82C6C9D8..0x82C6C9F0)
	// 82C6C9D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C6C9DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82C6C9E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C6C9E4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82C6C9E8: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C6C9EC: 4BFFFE6D  bl 0x82c6c858
	ctx.lr = 0x82C6C9F0;
	sub_82C6C858(ctx, base);
	pc = 0x82C6C9F0; continue 'dispatch;
            }
            0x82C6C9F0 => {
    //   block [0x82C6C9F0..0x82C6CA08)
	// 82C6C9F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6C9F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6C9F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6C9FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6CA00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6CA04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6CA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6CA08 size=1012
    let mut pc: u32 = 0x82C6CA08;
    'dispatch: loop {
        match pc {
            0x82C6CA08 => {
    //   block [0x82C6CA08..0x82C6CAB0)
	// 82C6CA08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6CA0C: 4803C9E5  bl 0x82ca93f0
	ctx.lr = 0x82C6CA10;
	sub_82CA93D0(ctx, base);
	// 82C6CA10: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6CA14: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C6CA18: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C6CA1C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C6CA20: 394BDEA0  addi r10, r11, -0x2160
	ctx.r[10].s64 = ctx.r[11].s64 + -8544;
	// 82C6CA24: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 82C6CA28: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C6CA2C: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 82C6CA30: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C6CA34: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C6CA38: 93FE001C  stw r31, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 82C6CA3C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C6CA40: 913E0020  stw r9, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 82C6CA44: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82C6CA48: B3FE000C  sth r31, 0xc(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[31].u16 ) };
	// 82C6CA4C: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 82C6CA50: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82C6CA54: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82C6CA58: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82C6CA5C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6CA60: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82C6CA64: 4B689C35  bl 0x822f6698
	ctx.lr = 0x82C6CA68;
	sub_822F6698(ctx, base);
	// 82C6CA68: 8119001C  lwz r8, 0x1c(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6CA6C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C6CA70: 911E0024  stw r8, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[8].u32 ) };
	// 82C6CA74: 80F90020  lwz r7, 0x20(r25)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C6CA78: 90FE0028  stw r7, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[7].u32 ) };
	// 82C6CA7C: 80DB0000  lwz r6, 0(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6CA80: 90DE002C  stw r6, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[6].u32 ) };
	// 82C6CA84: 80BB0004  lwz r5, 4(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6CA88: 90BE0030  stw r5, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[5].u32 ) };
	// 82C6CA8C: 809B0008  lwz r4, 8(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6CA90: 909E0034  stw r4, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[4].u32 ) };
	// 82C6CA94: 93BE0038  stw r29, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[29].u32 ) };
	// 82C6CA98: 419A0018  beq cr6, 0x82c6cab0
	if ctx.cr[6].eq {
	pc = 0x82C6CAB0; continue 'dispatch;
	}
	// 82C6CA9C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6CAA0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6CAA4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6CAA8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6CAAC: 4E800421  bctrl
	ctx.lr = 0x82C6CAB0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6CAB0 => {
    //   block [0x82C6CAB0..0x82C6CAD0)
	// 82C6CAB0: 939E003C  stw r28, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[28].u32 ) };
	// 82C6CAB4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C6CAB8: 419A0018  beq cr6, 0x82c6cad0
	if ctx.cr[6].eq {
	pc = 0x82C6CAD0; continue 'dispatch;
	}
	// 82C6CABC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6CAC0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C6CAC4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6CAC8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6CACC: 4E800421  bctrl
	ctx.lr = 0x82C6CAD0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6CAD0 => {
    //   block [0x82C6CAD0..0x82C6CB34)
	// 82C6CAD0: 93FE0044  stw r31, 0x44(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(68 as u32), ctx.r[31].u32 ) };
	// 82C6CAD4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6CAD8: 93FE0048  stw r31, 0x48(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(72 as u32), ctx.r[31].u32 ) };
	// 82C6CADC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C6CAE0: 93FE004C  stw r31, 0x4c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 82C6CAE4: 3B9E0040  addi r28, r30, 0x40
	ctx.r[28].s64 = ctx.r[30].s64 + 64;
	// 82C6CAE8: 93FE0054  stw r31, 0x54(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82C6CAEC: 3B1E0050  addi r24, r30, 0x50
	ctx.r[24].s64 = ctx.r[30].s64 + 80;
	// 82C6CAF0: 93FE0058  stw r31, 0x58(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82C6CAF4: 3B3E0060  addi r25, r30, 0x60
	ctx.r[25].s64 = ctx.r[30].s64 + 96;
	// 82C6CAF8: 93FE005C  stw r31, 0x5c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82C6CAFC: 93FE0064  stw r31, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82C6CB00: 93FE0068  stw r31, 0x68(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 82C6CB04: 93FE006C  stw r31, 0x6c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 82C6CB08: 93FE0074  stw r31, 0x74(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82C6CB0C: 93FE0078  stw r31, 0x78(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 82C6CB10: 93FE007C  stw r31, 0x7c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 82C6CB14: 4BFFE3E5  bl 0x82c6aef8
	ctx.lr = 0x82C6CB18;
	sub_82C6AEF8(ctx, base);
	// 82C6CB18: 82C10054  lwz r22, 0x54(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C6CB1C: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 82C6CB20: 409A0014  bne cr6, 0x82c6cb34
	if !ctx.cr[6].eq {
	pc = 0x82C6CB34; continue 'dispatch;
	}
	// 82C6CB24: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82C6CB28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6CB2C: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82C6CB30: 4803C910  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6CB34 => {
    //   block [0x82C6CB34..0x82C6CB48)
	// 82C6CB34: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C6CB38: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C6CB3C: 409A000C  bne cr6, 0x82c6cb48
	if !ctx.cr[6].eq {
	pc = 0x82C6CB48; continue 'dispatch;
	}
	// 82C6CB40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C6CB44: 4800001C  b 0x82c6cb60
	pc = 0x82C6CB60; continue 'dispatch;
            }
            0x82C6CB48 => {
    //   block [0x82C6CB48..0x82C6CB60)
	// 82C6CB48: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82C6CB4C: 3CA00001  lis r5, 1
	ctx.r[5].s64 = 65536;
	// 82C6CB50: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82C6CB54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C6CB58: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82C6CB5C: 4BEE0E35  bl 0x82b4d990
	ctx.lr = 0x82C6CB60;
	sub_82B4D990(ctx, base);
	pc = 0x82C6CB60; continue 'dispatch;
            }
            0x82C6CB60 => {
    //   block [0x82C6CB60..0x82C6CB80)
	// 82C6CB60: 82E30000  lwz r23, 0(r3)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6CB64: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 82C6CB68: 419A0018  beq cr6, 0x82c6cb80
	if ctx.cr[6].eq {
	pc = 0x82C6CB80; continue 'dispatch;
	}
	// 82C6CB6C: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6CB70: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82C6CB74: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6CB78: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6CB7C: 4E800421  bctrl
	ctx.lr = 0x82C6CB80;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6CB80 => {
    //   block [0x82C6CB80..0x82C6CBA8)
	// 82C6CB80: 574B07FE  clrlwi r11, r26, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	// 82C6CB84: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C6CB88: 419A0020  beq cr6, 0x82c6cba8
	if ctx.cr[6].eq {
	pc = 0x82C6CBA8; continue 'dispatch;
	}
	// 82C6CB8C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C6CB90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6CB94: 419A0014  beq cr6, 0x82c6cba8
	if ctx.cr[6].eq {
	pc = 0x82C6CBA8; continue 'dispatch;
	}
	// 82C6CB98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6CB9C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6CBA0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6CBA4: 4E800421  bctrl
	ctx.lr = 0x82C6CBA8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6CBA8 => {
    //   block [0x82C6CBA8..0x82C6CBC8)
	// 82C6CBA8: 92E10070  stw r23, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[23].u32 ) };
	// 82C6CBAC: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 82C6CBB0: 419A0018  beq cr6, 0x82c6cbc8
	if ctx.cr[6].eq {
	pc = 0x82C6CBC8; continue 'dispatch;
	}
	// 82C6CBB4: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6CBB8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82C6CBBC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6CBC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6CBC4: 4E800421  bctrl
	ctx.lr = 0x82C6CBC8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6CBC8 => {
    //   block [0x82C6CBC8..0x82C6CBF8)
	// 82C6CBC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C6CBCC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82C6CBD0: 99610074  stb r11, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	// 82C6CBD4: 4B6B53D5  bl 0x82321fa8
	ctx.lr = 0x82C6CBD8;
	sub_82321FA8(ctx, base);
	// 82C6CBD8: 89210074  lbz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82C6CBDC: 9BE10075  stb r31, 0x75(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(117 as u32), ctx.r[31].u8 ) };
	// 82C6CBE0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C6CBE4: 419A0014  beq cr6, 0x82c6cbf8
	if ctx.cr[6].eq {
	pc = 0x82C6CBF8; continue 'dispatch;
	}
	// 82C6CBE8: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82C6CBEC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C6CBF0: 4801DEF1  bl 0x82c8aae0
	ctx.lr = 0x82C6CBF4;
	sub_82C8AAE0(ctx, base);
	// 82C6CBF4: 98610074  stb r3, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u8 ) };
	pc = 0x82C6CBF8; continue 'dispatch;
            }
            0x82C6CBF8 => {
    //   block [0x82C6CBF8..0x82C6CC2C)
	// 82C6CBF8: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C6CBFC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C6CC00: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C6CC04: 4BFFE99D  bl 0x82c6b5a0
	ctx.lr = 0x82C6CC08;
	sub_82C6B5A0(ctx, base);
	// 82C6CC08: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6CC0C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C6CC10: 4BFFF039  bl 0x82c6bc48
	ctx.lr = 0x82C6CC14;
	sub_82C6BC48(ctx, base);
	// 82C6CC14: 897B0008  lbz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6CC18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6CC1C: 419A0010  beq cr6, 0x82c6cc2c
	if ctx.cr[6].eq {
	pc = 0x82C6CC2C; continue 'dispatch;
	}
	// 82C6CC20: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6CC24: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82C6CC28: 4BFFF841  bl 0x82c6c468
	ctx.lr = 0x82C6CC2C;
	sub_82C6C468(ctx, base);
	pc = 0x82C6CC2C; continue 'dispatch;
            }
            0x82C6CC2C => {
    //   block [0x82C6CC2C..0x82C6CC44)
	// 82C6CC2C: 3B60000F  li r27, 0xf
	ctx.r[27].s64 = 15;
	// 82C6CC30: 93E100C4  stw r31, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[31].u32 ) };
	// 82C6CC34: 9BE100B4  stb r31, 0xb4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[31].u8 ) };
	// 82C6CC38: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C6CC3C: 936100C8  stw r27, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[27].u32 ) };
	// 82C6CC40: 419A0150  beq cr6, 0x82c6cd90
	if ctx.cr[6].eq {
	pc = 0x82C6CD90; continue 'dispatch;
	}
	pc = 0x82C6CC44; continue 'dispatch;
            }
            0x82C6CC44 => {
    //   block [0x82C6CC44..0x82C6CC68)
	// 82C6CC44: 89410074  lbz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82C6CC48: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 82C6CC4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C6CC50: 419A0018  beq cr6, 0x82c6cc68
	if ctx.cr[6].eq {
	pc = 0x82C6CC68; continue 'dispatch;
	}
	// 82C6CC54: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 82C6CC58: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82C6CC5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6CC60: 4BFFE7D1  bl 0x82c6b430
	ctx.lr = 0x82C6CC64;
	sub_82C6B430(ctx, base);
	// 82C6CC64: 98610074  stb r3, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u8 ) };
	pc = 0x82C6CC68; continue 'dispatch;
            }
            0x82C6CC68 => {
    //   block [0x82C6CC68..0x82C6CC7C)
	// 82C6CC68: 816100C8  lwz r11, 0xc8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 82C6CC6C: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82C6CC70: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 82C6CC74: 40980008  bge cr6, 0x82c6cc7c
	if !ctx.cr[6].lt {
	pc = 0x82C6CC7C; continue 'dispatch;
	}
	// 82C6CC78: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	pc = 0x82C6CC7C; continue 'dispatch;
            }
            0x82C6CC7C => {
    //   block [0x82C6CC7C..0x82C6CCB4)
	// 82C6CC7C: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 82C6CC80: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 82C6CC84: 4B969EDD  bl 0x825d6b60
	ctx.lr = 0x82C6CC88;
	sub_825D6B60(ctx, base);
	// 82C6CC88: 89610074  lbz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82C6CC8C: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 82C6CC90: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 82C6CC94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6CC98: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82C6CC9C: 419A0018  beq cr6, 0x82c6ccb4
	if ctx.cr[6].eq {
	pc = 0x82C6CCB4; continue 'dispatch;
	}
	// 82C6CCA0: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C6CCA4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C6CCA8: 4801DE39  bl 0x82c8aae0
	ctx.lr = 0x82C6CCAC;
	sub_82C8AAE0(ctx, base);
	// 82C6CCAC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C6CCB0: 99610074  stb r11, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	pc = 0x82C6CCB4; continue 'dispatch;
            }
            0x82C6CCB4 => {
    //   block [0x82C6CCB4..0x82C6CCD4)
	// 82C6CCB4: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C6CCB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C6CCBC: 419A0018  beq cr6, 0x82c6ccd4
	if ctx.cr[6].eq {
	pc = 0x82C6CCD4; continue 'dispatch;
	}
	// 82C6CCC0: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82C6CCC4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C6CCC8: 4801DE19  bl 0x82c8aae0
	ctx.lr = 0x82C6CCCC;
	sub_82C8AAE0(ctx, base);
	// 82C6CCCC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C6CCD0: 99610074  stb r11, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	pc = 0x82C6CCD4; continue 'dispatch;
            }
            0x82C6CCD4 => {
    //   block [0x82C6CCD4..0x82C6CD14)
	// 82C6CCD4: 895E0034  lbz r10, 0x34(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C6CCD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C6CCDC: 419A0080  beq cr6, 0x82c6cd5c
	if ctx.cr[6].eq {
	pc = 0x82C6CD5C; continue 'dispatch;
	}
	// 82C6CCE0: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C6CCE4: 5569063E  clrlwi r9, r11, 0x18
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C6CCE8: 93E10098  stw r31, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[31].u32 ) };
	// 82C6CCEC: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 82C6CCF0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C6CCF4: 93E100A0  stw r31, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[31].u32 ) };
	// 82C6CCF8: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 82C6CCFC: 419A0018  beq cr6, 0x82c6cd14
	if ctx.cr[6].eq {
	pc = 0x82C6CD14; continue 'dispatch;
	}
	// 82C6CD00: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82C6CD04: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C6CD08: 4801DDD9  bl 0x82c8aae0
	ctx.lr = 0x82C6CD0C;
	sub_82C8AAE0(ctx, base);
	// 82C6CD0C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C6CD10: 99610074  stb r11, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	pc = 0x82C6CD14; continue 'dispatch;
            }
            0x82C6CD14 => {
    //   block [0x82C6CD14..0x82C6CD34)
	// 82C6CD14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C6CD18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6CD1C: 419A0018  beq cr6, 0x82c6cd34
	if ctx.cr[6].eq {
	pc = 0x82C6CD34; continue 'dispatch;
	}
	// 82C6CD20: 38A10094  addi r5, r1, 0x94
	ctx.r[5].s64 = ctx.r[1].s64 + 148;
	// 82C6CD24: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82C6CD28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6CD2C: 4B71278D  bl 0x8237f4b8
	ctx.lr = 0x82C6CD30;
	sub_8237F4B8(ctx, base);
	// 82C6CD30: 98610074  stb r3, 0x74(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u8 ) };
	pc = 0x82C6CD34; continue 'dispatch;
            }
            0x82C6CD34 => {
    //   block [0x82C6CD34..0x82C6CD50)
	// 82C6CD34: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82C6CD38: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82C6CD3C: 4BFFFC05  bl 0x82c6c940
	ctx.lr = 0x82C6CD40;
	sub_82C6C940(ctx, base);
	// 82C6CD40: 80610098  lwz r3, 0x98(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82C6CD44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6CD48: 419A0008  beq cr6, 0x82c6cd50
	if ctx.cr[6].eq {
	pc = 0x82C6CD50; continue 'dispatch;
	}
	// 82C6CD4C: 4BBD8A65  bl 0x828457b0
	ctx.lr = 0x82C6CD50;
	sub_828457B0(ctx, base);
	pc = 0x82C6CD50; continue 'dispatch;
            }
            0x82C6CD50 => {
    //   block [0x82C6CD50..0x82C6CD5C)
	// 82C6CD50: 93E10098  stw r31, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[31].u32 ) };
	// 82C6CD54: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 82C6CD58: 93E100A0  stw r31, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[31].u32 ) };
	pc = 0x82C6CD5C; continue 'dispatch;
            }
            0x82C6CD5C => {
    //   block [0x82C6CD5C..0x82C6CD90)
	// 82C6CD5C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C6CD60: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C6CD64: 4BFFECF5  bl 0x82c6ba58
	ctx.lr = 0x82C6CD68;
	sub_82C6BA58(ctx, base);
	// 82C6CD68: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 82C6CD6C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C6CD70: 4BFFF569  bl 0x82c6c2d8
	ctx.lr = 0x82C6CD74;
	sub_82C6C2D8(ctx, base);
	// 82C6CD74: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C6CD78: 409AFECC  bne cr6, 0x82c6cc44
	if !ctx.cr[6].eq {
	pc = 0x82C6CC44; continue 'dispatch;
	}
	// 82C6CD7C: 816100C8  lwz r11, 0xc8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 82C6CD80: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 82C6CD84: 4198000C  blt cr6, 0x82c6cd90
	if ctx.cr[6].lt {
	pc = 0x82C6CD90; continue 'dispatch;
	}
	// 82C6CD88: 806100B4  lwz r3, 0xb4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82C6CD8C: 4BBD8A25  bl 0x828457b0
	ctx.lr = 0x82C6CD90;
	sub_828457B0(ctx, base);
	pc = 0x82C6CD90; continue 'dispatch;
            }
            0x82C6CD90 => {
    //   block [0x82C6CD90..0x82C6CDC0)
	// 82C6CD90: 936100C8  stw r27, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[27].u32 ) };
	// 82C6CD94: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82C6CD98: 93E100C4  stw r31, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[31].u32 ) };
	// 82C6CD9C: 9BE100B4  stb r31, 0xb4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[31].u8 ) };
	// 82C6CDA0: 4B6F6241  bl 0x82362fe0
	ctx.lr = 0x82C6CDA4;
	sub_82362FE0(ctx, base);
	// 82C6CDA4: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82C6CDA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6CDAC: 419A0014  beq cr6, 0x82c6cdc0
	if ctx.cr[6].eq {
	pc = 0x82C6CDC0; continue 'dispatch;
	}
	// 82C6CDB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6CDB4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6CDB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6CDBC: 4E800421  bctrl
	ctx.lr = 0x82C6CDC0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6CDC0 => {
    //   block [0x82C6CDC0..0x82C6CDDC)
	// 82C6CDC0: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 82C6CDC4: 419A0018  beq cr6, 0x82c6cddc
	if ctx.cr[6].eq {
	pc = 0x82C6CDDC; continue 'dispatch;
	}
	// 82C6CDC8: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6CDCC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82C6CDD0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6CDD4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6CDD8: 4E800421  bctrl
	ctx.lr = 0x82C6CDDC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6CDDC => {
    //   block [0x82C6CDDC..0x82C6CDFC)
	// 82C6CDDC: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6CDE0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82C6CDE4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6CDE8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6CDEC: 4E800421  bctrl
	ctx.lr = 0x82C6CDF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6CDF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6CDF4: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82C6CDF8: 4803C648  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6CE00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6CE00 size=1156
    let mut pc: u32 = 0x82C6CE00;
    'dispatch: loop {
        match pc {
            0x82C6CE00 => {
    //   block [0x82C6CE00..0x82C6CE50)
	// 82C6CE00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6CE04: 4803C5DD  bl 0x82ca93e0
	ctx.lr = 0x82C6CE08;
	sub_82CA93D0(ctx, base);
	// 82C6CE08: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6CE0C: 54DE07FE  clrlwi r30, r6, 0x1f
	ctx.r[30].u64 = ctx.r[6].u32 as u64 & 0x00000001u64;
	// 82C6CE10: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 82C6CE14: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 82C6CE18: 7CB42B78  mr r20, r5
	ctx.r[20].u64 = ctx.r[5].u64;
	// 82C6CE1C: 3B80000C  li r28, 0xc
	ctx.r[28].s64 = 12;
	// 82C6CE20: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C6CE24: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C6CE28: 419A00F0  beq cr6, 0x82c6cf18
	if ctx.cr[6].eq {
	pc = 0x82C6CF18; continue 'dispatch;
	}
	// 82C6CE2C: 81750064  lwz r11, 0x64(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C6CE30: 3BF50060  addi r31, r21, 0x60
	ctx.r[31].s64 = ctx.r[21].s64 + 96;
	// 82C6CE34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6CE38: 419A0018  beq cr6, 0x82c6ce50
	if ctx.cr[6].eq {
	pc = 0x82C6CE50; continue 'dispatch;
	}
	// 82C6CE3C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6CE40: 3920001C  li r9, 0x1c
	ctx.r[9].s64 = 28;
	// 82C6CE44: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6CE48: 7CE84BD7  divw. r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82C6CE4C: 408200A8  bne 0x82c6cef4
	if !ctx.cr[0].eq {
	pc = 0x82C6CEF4; continue 'dispatch;
	}
	pc = 0x82C6CE50; continue 'dispatch;
            }
            0x82C6CE50 => {
    //   block [0x82C6CE50..0x82C6CE98)
	// 82C6CE50: 81750044  lwz r11, 0x44(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(68 as u32) ) } as u64;
	// 82C6CE54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6CE58: 419A009C  beq cr6, 0x82c6cef4
	if ctx.cr[6].eq {
	pc = 0x82C6CEF4; continue 'dispatch;
	}
	// 82C6CE5C: 81550048  lwz r10, 0x48(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82C6CE60: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6CE64: 7D09E3D7  divw. r8, r9, r28
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[28].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82C6CE68: 4182008C  beq 0x82c6cef4
	if ctx.cr[0].eq {
	pc = 0x82C6CEF4; continue 'dispatch;
	}
	// 82C6CE6C: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 82C6CE70: 4B5B23E9  bl 0x8221f258
	ctx.lr = 0x82C6CE74;
	sub_8221F258(ctx, base);
	// 82C6CE74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6CE78: 419A0020  beq cr6, 0x82c6ce98
	if ctx.cr[6].eq {
	pc = 0x82C6CE98; continue 'dispatch;
	}
	// 82C6CE7C: 38F50008  addi r7, r21, 8
	ctx.r[7].s64 = ctx.r[21].s64 + 8;
	// 82C6CE80: 80D5003C  lwz r6, 0x3c(r21)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(60 as u32) ) } as u64;
	// 82C6CE84: 3895002C  addi r4, r21, 0x2c
	ctx.r[4].s64 = ctx.r[21].s64 + 44;
	// 82C6CE88: 80B50038  lwz r5, 0x38(r21)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(56 as u32) ) } as u64;
	// 82C6CE8C: 4BFFFB7D  bl 0x82c6ca08
	ctx.lr = 0x82C6CE90;
	sub_82C6CA08(ctx, base);
	// 82C6CE90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6CE94: 48000008  b 0x82c6ce9c
	pc = 0x82C6CE9C; continue 'dispatch;
            }
            0x82C6CE98 => {
    //   block [0x82C6CE98..0x82C6CE9C)
	// 82C6CE98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x82C6CE9C; continue 'dispatch;
            }
            0x82C6CE9C => {
    //   block [0x82C6CE9C..0x82C6CEF4)
	// 82C6CE9C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C6CEA0: 4BFFD961  bl 0x82c6a800
	ctx.lr = 0x82C6CEA4;
	sub_82C6A800(ctx, base);
	// 82C6CEA4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C6CEA8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6CEAC: 39630060  addi r11, r3, 0x60
	ctx.r[11].s64 = ctx.r[3].s64 + 96;
	// 82C6CEB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6CEB4: 81630064  lwz r11, 0x64(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C6CEB8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C6CEBC: 91430064  stw r10, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82C6CEC0: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6CEC4: 81030068  lwz r8, 0x68(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C6CEC8: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82C6CECC: 91230068  stw r9, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 82C6CED0: 80FF000C  lwz r7, 0xc(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6CED4: 80C3006C  lwz r6, 0x6c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C6CED8: 90DF000C  stw r6, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 82C6CEDC: 90E3006C  stw r7, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82C6CEE0: 419A0014  beq cr6, 0x82c6cef4
	if ctx.cr[6].eq {
	pc = 0x82C6CEF4; continue 'dispatch;
	}
	// 82C6CEE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6CEE8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6CEEC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6CEF0: 4E800421  bctrl
	ctx.lr = 0x82C6CEF4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6CEF4 => {
    //   block [0x82C6CEF4..0x82C6CF18)
	// 82C6CEF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C6CEF8: 4B7075E1  bl 0x823744d8
	ctx.lr = 0x82C6CEFC;
	sub_823744D8(ctx, base);
	// 82C6CEFC: 82610054  lwz r19, 0x54(r1)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C6CF00: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 82C6CF04: 409A0030  bne cr6, 0x82c6cf34
	if !ctx.cr[6].eq {
	pc = 0x82C6CF34; continue 'dispatch;
	}
	// 82C6CF08: 93B20000  stw r29, 0(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C6CF0C: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 82C6CF10: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82C6CF14: 4803C51C  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6CF18 => {
    //   block [0x82C6CF18..0x82C6CF34)
	// 82C6CF18: 2F140000  cmpwi cr6, r20, 0
	ctx.cr[6].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 82C6CF1C: 409AFFD8  bne cr6, 0x82c6cef4
	if !ctx.cr[6].eq {
	pc = 0x82C6CEF4; continue 'dispatch;
	}
	// 82C6CF20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6CF24: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 82C6CF28: 91720000  stw r11, 0(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C6CF2C: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82C6CF30: 4803C500  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6CF34 => {
    //   block [0x82C6CF34..0x82C6CF4C)
	// 82C6CF34: 81750044  lwz r11, 0x44(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(68 as u32) ) } as u64;
	// 82C6CF38: 3B350040  addi r25, r21, 0x40
	ctx.r[25].s64 = ctx.r[21].s64 + 64;
	// 82C6CF3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6CF40: 409A000C  bne cr6, 0x82c6cf4c
	if !ctx.cr[6].eq {
	pc = 0x82C6CF4C; continue 'dispatch;
	}
	// 82C6CF44: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6CF48: 48000010  b 0x82c6cf58
	pc = 0x82C6CF58; continue 'dispatch;
            }
            0x82C6CF4C => {
    //   block [0x82C6CF4C..0x82C6CF58)
	// 82C6CF4C: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6CF50: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6CF54: 7C89E3D6  divw r4, r9, r28
	ctx.r[4].s32 = ctx.r[9].s32 / ctx.r[28].s32;
	pc = 0x82C6CF58; continue 'dispatch;
            }
            0x82C6CF58 => {
    //   block [0x82C6CF58..0x82C6CF80)
	// 82C6CF58: 3AF30008  addi r23, r19, 8
	ctx.r[23].s64 = ctx.r[19].s64 + 8;
	// 82C6CF5C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82C6CF60: 4BED9701  bl 0x82b46660
	ctx.lr = 0x82C6CF64;
	sub_82B46660(ctx, base);
	// 82C6CF64: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C6CF68: 419A01E4  beq cr6, 0x82c6d14c
	if ctx.cr[6].eq {
	pc = 0x82C6D14C; continue 'dispatch;
	}
	// 82C6CF6C: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6CF70: 81390008  lwz r9, 8(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6CF74: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C6CF78: 40990008  ble cr6, 0x82c6cf80
	if !ctx.cr[6].gt {
	pc = 0x82C6CF80; continue 'dispatch;
	}
	// 82C6CF7C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6CF80; continue 'dispatch;
            }
            0x82C6CF80 => {
    //   block [0x82C6CF80..0x82C6CF9C)
	// 82C6CF80: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 82C6CF84: 81750064  lwz r11, 0x64(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C6CF88: 81550068  lwz r10, 0x68(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C6CF8C: 3B150060  addi r24, r21, 0x60
	ctx.r[24].s64 = ctx.r[21].s64 + 96;
	// 82C6CF90: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6CF94: 40990008  ble cr6, 0x82c6cf9c
	if !ctx.cr[6].gt {
	pc = 0x82C6CF9C; continue 'dispatch;
	}
	// 82C6CF98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6CF9C; continue 'dispatch;
            }
            0x82C6CF9C => {
    //   block [0x82C6CF9C..0x82C6CFB0)
	// 82C6CF9C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82C6CFA0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82C6CFA4: 3AC0005C  li r22, 0x5c
	ctx.r[22].s64 = 92;
	// 82C6CFA8: 3B800007  li r28, 7
	ctx.r[28].s64 = 7;
	// 82C6CFAC: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
	pc = 0x82C6CFB0; continue 'dispatch;
            }
            0x82C6CFB0 => {
    //   block [0x82C6CFB0..0x82C6CFC4)
	// 82C6CFB0: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6CFB4: 81190004  lwz r8, 4(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6CFB8: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6CFBC: 40990008  ble cr6, 0x82c6cfc4
	if !ctx.cr[6].gt {
	pc = 0x82C6CFC4; continue 'dispatch;
	}
	// 82C6CFC0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6CFC4; continue 'dispatch;
            }
            0x82C6CFC4 => {
    //   block [0x82C6CFC4..0x82C6CFD0)
	// 82C6CFC4: 7F19C840  cmplw cr6, r25, r25
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82C6CFC8: 419A0008  beq cr6, 0x82c6cfd0
	if ctx.cr[6].eq {
	pc = 0x82C6CFD0; continue 'dispatch;
	}
	// 82C6CFCC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6CFD0; continue 'dispatch;
            }
            0x82C6CFD0 => {
    //   block [0x82C6CFD0..0x82C6CFE4)
	// 82C6CFD0: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6CFD4: 419A0228  beq cr6, 0x82c6d1fc
	if ctx.cr[6].eq {
	pc = 0x82C6D1FC; continue 'dispatch;
	}
	// 82C6CFD8: 7F1B4840  cmplw cr6, r27, r9
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C6CFDC: 41980008  blt cr6, 0x82c6cfe4
	if ctx.cr[6].lt {
	pc = 0x82C6CFE4; continue 'dispatch;
	}
	// 82C6CFE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6CFE4; continue 'dispatch;
            }
            0x82C6CFE4 => {
    //   block [0x82C6CFE4..0x82C6CFF0)
	// 82C6CFE4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6CFE8: 41980008  blt cr6, 0x82c6cff0
	if ctx.cr[6].lt {
	pc = 0x82C6CFF0; continue 'dispatch;
	}
	// 82C6CFEC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6CFF0; continue 'dispatch;
            }
            0x82C6CFF0 => {
    //   block [0x82C6CFF0..0x82C6D02C)
	// 82C6CFF0: 2F140000  cmpwi cr6, r20, 0
	ctx.cr[6].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 82C6CFF4: 409A0090  bne cr6, 0x82c6d084
	if !ctx.cr[6].eq {
	pc = 0x82C6D084; continue 'dispatch;
	}
	// 82C6CFF8: 9AC10050  stb r22, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u8 ) };
	// 82C6CFFC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82C6D000: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6D004: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C6D008: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6D00C: 4BFFD8BD  bl 0x82c6a8c8
	ctx.lr = 0x82C6D010;
	sub_82C6A8C8(ctx, base);
	// 82C6D010: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82C6D014: 409A0108  bne cr6, 0x82c6d11c
	if !ctx.cr[6].eq {
	pc = 0x82C6D11C; continue 'dispatch;
	}
	// 82C6D018: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6D01C: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 82C6D020: 4198000C  blt cr6, 0x82c6d02c
	if ctx.cr[6].lt {
	pc = 0x82C6D02C; continue 'dispatch;
	}
	// 82C6D024: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6D028: 48000008  b 0x82c6d030
	pc = 0x82C6D030; continue 'dispatch;
            }
            0x82C6D02C => {
    //   block [0x82C6D02C..0x82C6D030)
	// 82C6D02C: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	pc = 0x82C6D030; continue 'dispatch;
            }
            0x82C6D030 => {
    //   block [0x82C6D030..0x82C6D084)
	// 82C6D030: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82C6D034: 4B50E075  bl 0x8217b0a8
	ctx.lr = 0x82C6D038;
	sub_8217B0A8(ctx, base);
	// 82C6D038: 938100E8  stw r28, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[28].u32 ) };
	// 82C6D03C: 93A100E4  stw r29, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[29].u32 ) };
	// 82C6D040: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82C6D044: B3A100D4  sth r29, 0xd4(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[29].u16 ) };
	// 82C6D048: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6D04C: 38810130  addi r4, r1, 0x130
	ctx.r[4].s64 = ctx.r[1].s64 + 304;
	// 82C6D050: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82C6D054: 4B689645  bl 0x822f6698
	ctx.lr = 0x82C6D058;
	sub_822F6698(ctx, base);
	// 82C6D058: 8161014C  lwz r11, 0x14c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	// 82C6D05C: 93C100F0  stw r30, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[30].u32 ) };
	// 82C6D060: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82C6D064: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82C6D068: 916100EC  stw r11, 0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82C6D06C: 4B707D0D  bl 0x82374d78
	ctx.lr = 0x82C6D070;
	sub_82374D78(ctx, base);
	// 82C6D070: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 82C6D074: 4B685245  bl 0x822f22b8
	ctx.lr = 0x82C6D078;
	sub_822F22B8(ctx, base);
	// 82C6D078: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82C6D07C: 4B68523D  bl 0x822f22b8
	ctx.lr = 0x82C6D080;
	sub_822F22B8(ctx, base);
	// 82C6D080: 4800009C  b 0x82c6d11c
	pc = 0x82C6D11C; continue 'dispatch;
            }
            0x82C6D084 => {
    //   block [0x82C6D084..0x82C6D098)
	// 82C6D084: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6D088: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 82C6D08C: 4198000C  blt cr6, 0x82c6d098
	if ctx.cr[6].lt {
	pc = 0x82C6D098; continue 'dispatch;
	}
	// 82C6D090: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6D094: 48000008  b 0x82c6d09c
	pc = 0x82C6D09C; continue 'dispatch;
            }
            0x82C6D098 => {
    //   block [0x82C6D098..0x82C6D09C)
	// 82C6D098: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	pc = 0x82C6D09C; continue 'dispatch;
            }
            0x82C6D09C => {
    //   block [0x82C6D09C..0x82C6D0F0)
	// 82C6D09C: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82C6D0A0: 4B50E009  bl 0x8217b0a8
	ctx.lr = 0x82C6D0A4;
	sub_8217B0A8(ctx, base);
	// 82C6D0A4: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 82C6D0A8: 93A10084  stw r29, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	// 82C6D0AC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82C6D0B0: B3A10074  sth r29, 0x74(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u16 ) };
	// 82C6D0B4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6D0B8: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 82C6D0BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C6D0C0: 4B6895D9  bl 0x822f6698
	ctx.lr = 0x82C6D0C4;
	sub_822F6698(ctx, base);
	// 82C6D0C4: 8161011C  lwz r11, 0x11c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 82C6D0C8: 93C10090  stw r30, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[30].u32 ) };
	// 82C6D0CC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82C6D0D0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82C6D0D4: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82C6D0D8: 4B707CA1  bl 0x82374d78
	ctx.lr = 0x82C6D0DC;
	sub_82374D78(ctx, base);
	// 82C6D0DC: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82C6D0E0: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 82C6D0E4: 4198000C  blt cr6, 0x82c6d0f0
	if ctx.cr[6].lt {
	pc = 0x82C6D0F0; continue 'dispatch;
	}
	// 82C6D0E8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82C6D0EC: 4BBD86C5  bl 0x828457b0
	ctx.lr = 0x82C6D0F0;
	sub_828457B0(ctx, base);
	pc = 0x82C6D0F0; continue 'dispatch;
            }
            0x82C6D0F0 => {
    //   block [0x82C6D0F0..0x82C6D110)
	// 82C6D0F0: 81610118  lwz r11, 0x118(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(280 as u32) ) } as u64;
	// 82C6D0F4: 93810088  stw r28, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 82C6D0F8: 93A10084  stw r29, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	// 82C6D0FC: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82C6D100: B3A10074  sth r29, 0x74(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u16 ) };
	// 82C6D104: 4198000C  blt cr6, 0x82c6d110
	if ctx.cr[6].lt {
	pc = 0x82C6D110; continue 'dispatch;
	}
	// 82C6D108: 80610104  lwz r3, 0x104(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82C6D10C: 4BBD86A5  bl 0x828457b0
	ctx.lr = 0x82C6D110;
	sub_828457B0(ctx, base);
	pc = 0x82C6D110; continue 'dispatch;
            }
            0x82C6D110 => {
    //   block [0x82C6D110..0x82C6D11C)
	// 82C6D110: 93810118  stw r28, 0x118(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[28].u32 ) };
	// 82C6D114: 93A10114  stw r29, 0x114(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), ctx.r[29].u32 ) };
	// 82C6D118: B3A10104  sth r29, 0x104(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[29].u16 ) };
	pc = 0x82C6D11C; continue 'dispatch;
            }
            0x82C6D11C => {
    //   block [0x82C6D11C..0x82C6D12C)
	// 82C6D11C: 81390008  lwz r9, 8(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D120: 7F1B4840  cmplw cr6, r27, r9
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C6D124: 41980008  blt cr6, 0x82c6d12c
	if ctx.cr[6].lt {
	pc = 0x82C6D12C; continue 'dispatch;
	}
	// 82C6D128: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6D12C; continue 'dispatch;
            }
            0x82C6D12C => {
    //   block [0x82C6D12C..0x82C6D140)
	// 82C6D12C: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D130: 3B7B000C  addi r27, r27, 0xc
	ctx.r[27].s64 = ctx.r[27].s64 + 12;
	// 82C6D134: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6D138: 41980008  blt cr6, 0x82c6d140
	if ctx.cr[6].lt {
	pc = 0x82C6D140; continue 'dispatch;
	}
	// 82C6D13C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6D140; continue 'dispatch;
            }
            0x82C6D140 => {
    //   block [0x82C6D140..0x82C6D14C)
	// 82C6D140: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82C6D144: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C6D148: 4BFFFE68  b 0x82c6cfb0
	pc = 0x82C6CFB0; continue 'dispatch;
            }
            0x82C6D14C => {
    //   block [0x82C6D14C..0x82C6D164)
	// 82C6D14C: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6D150: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82C6D154: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D158: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6D15C: 40990008  ble cr6, 0x82c6d164
	if !ctx.cr[6].gt {
	pc = 0x82C6D164; continue 'dispatch;
	}
	// 82C6D160: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6D164; continue 'dispatch;
            }
            0x82C6D164 => {
    //   block [0x82C6D164..0x82C6D168)
	// 82C6D164: 3B800007  li r28, 7
	ctx.r[28].s64 = 7;
	pc = 0x82C6D168; continue 'dispatch;
            }
            0x82C6D168 => {
    //   block [0x82C6D168..0x82C6D17C)
	// 82C6D168: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D16C: 81390004  lwz r9, 4(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6D170: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6D174: 40990008  ble cr6, 0x82c6d17c
	if !ctx.cr[6].gt {
	pc = 0x82C6D17C; continue 'dispatch;
	}
	// 82C6D178: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6D17C; continue 'dispatch;
            }
            0x82C6D17C => {
    //   block [0x82C6D17C..0x82C6D188)
	// 82C6D17C: 7F19C840  cmplw cr6, r25, r25
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82C6D180: 419A0008  beq cr6, 0x82c6d188
	if ctx.cr[6].eq {
	pc = 0x82C6D188; continue 'dispatch;
	}
	// 82C6D184: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6D188; continue 'dispatch;
            }
            0x82C6D188 => {
    //   block [0x82C6D188..0x82C6D19C)
	// 82C6D188: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6D18C: 419A0070  beq cr6, 0x82c6d1fc
	if ctx.cr[6].eq {
	pc = 0x82C6D1FC; continue 'dispatch;
	}
	// 82C6D190: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6D194: 41980008  blt cr6, 0x82c6d19c
	if ctx.cr[6].lt {
	pc = 0x82C6D19C; continue 'dispatch;
	}
	// 82C6D198: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6D19C; continue 'dispatch;
            }
            0x82C6D19C => {
    //   block [0x82C6D19C..0x82C6D1D4)
	// 82C6D19C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D1A0: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82C6D1A4: 93C100C0  stw r30, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 82C6D1A8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82C6D1AC: 938100B8  stw r28, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[28].u32 ) };
	// 82C6D1B0: 93A100B4  stw r29, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[29].u32 ) };
	// 82C6D1B4: B3A100A4  sth r29, 0xa4(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[29].u16 ) };
	// 82C6D1B8: 916100BC  stw r11, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 82C6D1BC: 4B707BBD  bl 0x82374d78
	ctx.lr = 0x82C6D1C0;
	sub_82374D78(ctx, base);
	// 82C6D1C0: 814100B8  lwz r10, 0xb8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82C6D1C4: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 82C6D1C8: 4198000C  blt cr6, 0x82c6d1d4
	if ctx.cr[6].lt {
	pc = 0x82C6D1D4; continue 'dispatch;
	}
	// 82C6D1CC: 806100A4  lwz r3, 0xa4(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82C6D1D0: 4BBD85E1  bl 0x828457b0
	ctx.lr = 0x82C6D1D4;
	sub_828457B0(ctx, base);
	pc = 0x82C6D1D4; continue 'dispatch;
            }
            0x82C6D1D4 => {
    //   block [0x82C6D1D4..0x82C6D1F0)
	// 82C6D1D4: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D1D8: 938100B8  stw r28, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[28].u32 ) };
	// 82C6D1DC: 93A100B4  stw r29, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[29].u32 ) };
	// 82C6D1E0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6D1E4: B3A100A4  sth r29, 0xa4(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[29].u16 ) };
	// 82C6D1E8: 41980008  blt cr6, 0x82c6d1f0
	if ctx.cr[6].lt {
	pc = 0x82C6D1F0; continue 'dispatch;
	}
	// 82C6D1EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6D1F0; continue 'dispatch;
            }
            0x82C6D1F0 => {
    //   block [0x82C6D1F0..0x82C6D1FC)
	// 82C6D1F0: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82C6D1F4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C6D1F8: 4BFFFF70  b 0x82c6d168
	pc = 0x82C6D168; continue 'dispatch;
            }
            0x82C6D1FC => {
    //   block [0x82C6D1FC..0x82C6D240)
	// 82C6D1FC: 80750064  lwz r3, 0x64(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C6D200: 39750060  addi r11, r21, 0x60
	ctx.r[11].s64 = ctx.r[21].s64 + 96;
	// 82C6D204: 93B50064  stw r29, 0x64(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82C6D208: 80950068  lwz r4, 0x68(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C6D20C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6D210: 93B50068  stw r29, 0x68(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82C6D214: 8175006C  lwz r11, 0x6c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C6D218: 90610064  stw r3, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	// 82C6D21C: 90810068  stw r4, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[4].u32 ) };
	// 82C6D220: 93B5006C  stw r29, 0x6c(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82C6D224: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82C6D228: 419A0018  beq cr6, 0x82c6d240
	if ctx.cr[6].eq {
	pc = 0x82C6D240; continue 'dispatch;
	}
	// 82C6D22C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82C6D230: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6D234: 4BFFE295  bl 0x82c6b4c8
	ctx.lr = 0x82C6D238;
	sub_82C6B4C8(ctx, base);
	// 82C6D238: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C6D23C: 4BBD8575  bl 0x828457b0
	ctx.lr = 0x82C6D240;
	sub_828457B0(ctx, base);
	pc = 0x82C6D240; continue 'dispatch;
            }
            0x82C6D240 => {
    //   block [0x82C6D240..0x82C6D284)
	// 82C6D240: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82C6D244: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82C6D248: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 82C6D24C: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82C6D250: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D254: 92720000  stw r19, 0(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(0 as u32), ctx.r[19].u32 ) };
	// 82C6D258: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6D25C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D260: 4E800421  bctrl
	ctx.lr = 0x82C6D264;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6D264: 81330000  lwz r9, 0(r19)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D268: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82C6D26C: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D270: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C6D274: 4E800421  bctrl
	ctx.lr = 0x82C6D278;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6D278: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 82C6D27C: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82C6D280: 4803C1B0  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6D288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6D288 size=1344
    let mut pc: u32 = 0x82C6D288;
    'dispatch: loop {
        match pc {
            0x82C6D288 => {
    //   block [0x82C6D288..0x82C6D2AC)
	// 82C6D288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6D28C: 4803C169  bl 0x82ca93f4
	ctx.lr = 0x82C6D290;
	sub_82CA93D0(ctx, base);
	// 82C6D290: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6D294: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C6D298: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 82C6D29C: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82C6D2A0: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82C6D2A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C6D2A8: 409A0018  bne cr6, 0x82c6d2c0
	if !ctx.cr[6].eq {
	pc = 0x82C6D2C0; continue 'dispatch;
	}
	pc = 0x82C6D2AC; continue 'dispatch;
            }
            0x82C6D2AC => {
    //   block [0x82C6D2AC..0x82C6D2C0)
	// 82C6D2AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6D2B0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82C6D2B4: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C6D2B8: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82C6D2BC: 4803C188  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6D2C0 => {
    //   block [0x82C6D2C0..0x82C6D324)
	// 82C6D2C0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D2C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6D2C8: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6D2CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D2D0: 4E800421  bctrl
	ctx.lr = 0x82C6D2D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6D2D4: 2B23000C  cmpldi cr6, r3, 0xc
	ctx.cr[6].compare_u64(ctx.r[3].u64, 12, &mut ctx.xer);
	// 82C6D2D8: 4198FFD4  blt cr6, 0x82c6d2ac
	if ctx.cr[6].lt {
	pc = 0x82C6D2AC; continue 'dispatch;
	}
	// 82C6D2DC: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 82C6D2E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6D2E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6D2E8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82C6D2EC: 4BEE5EFD  bl 0x82b531e8
	ctx.lr = 0x82C6D2F0;
	sub_82B531E8(ctx, base);
	// 82C6D2F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C6D2F4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82C6D2F8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C6D2FC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D300: 4BEDDB11  bl 0x82b4ae10
	ctx.lr = 0x82C6D304;
	sub_82B4AE10(ctx, base);
	// 82C6D304: 83030000  lwz r24, 0(r3)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D308: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82C6D30C: 419A0018  beq cr6, 0x82c6d324
	if ctx.cr[6].eq {
	pc = 0x82C6D324; continue 'dispatch;
	}
	// 82C6D310: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D314: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82C6D318: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6D31C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D320: 4E800421  bctrl
	ctx.lr = 0x82C6D324;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D324 => {
    //   block [0x82C6D324..0x82C6D340)
	// 82C6D324: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C6D328: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6D32C: 419A0014  beq cr6, 0x82c6d340
	if ctx.cr[6].eq {
	pc = 0x82C6D340; continue 'dispatch;
	}
	// 82C6D330: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D334: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D338: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D33C: 4E800421  bctrl
	ctx.lr = 0x82C6D340;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D340 => {
    //   block [0x82C6D340..0x82C6D35C)
	// 82C6D340: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C6D344: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6D348: 419A0014  beq cr6, 0x82c6d35c
	if ctx.cr[6].eq {
	pc = 0x82C6D35C; continue 'dispatch;
	}
	// 82C6D34C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D350: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D354: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D358: 4E800421  bctrl
	ctx.lr = 0x82C6D35C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D35C => {
    //   block [0x82C6D35C..0x82C6D388)
	// 82C6D35C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82C6D360: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C6D364: 4BFFDB95  bl 0x82c6aef8
	ctx.lr = 0x82C6D368;
	sub_82C6AEF8(ctx, base);
	// 82C6D368: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D36C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6D370: 90610090  stw r3, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[3].u32 ) };
	// 82C6D374: 419A0014  beq cr6, 0x82c6d388
	if ctx.cr[6].eq {
	pc = 0x82C6D388; continue 'dispatch;
	}
	// 82C6D378: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D37C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6D380: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D384: 4E800421  bctrl
	ctx.lr = 0x82C6D388;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D388 => {
    //   block [0x82C6D388..0x82C6D3BC)
	// 82C6D388: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C6D38C: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 82C6D390: 99610094  stb r11, 0x94(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u8 ) };
	// 82C6D394: 4B6B4C15  bl 0x82321fa8
	ctx.lr = 0x82C6D398;
	sub_82321FA8(ctx, base);
	// 82C6D398: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82C6D39C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C6D3A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6D3A4: 9BE10095  stb r31, 0x95(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(149 as u32), ctx.r[31].u8 ) };
	// 82C6D3A8: 419A0014  beq cr6, 0x82c6d3bc
	if ctx.cr[6].eq {
	pc = 0x82C6D3BC; continue 'dispatch;
	}
	// 82C6D3AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D3B0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D3B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D3B8: 4E800421  bctrl
	ctx.lr = 0x82C6D3BC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D3BC => {
    //   block [0x82C6D3BC..0x82C6D3D8)
	// 82C6D3BC: 88610094  lbz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82C6D3C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6D3C4: 419A0014  beq cr6, 0x82c6d3d8
	if ctx.cr[6].eq {
	pc = 0x82C6D3D8; continue 'dispatch;
	}
	// 82C6D3C8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82C6D3CC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82C6D3D0: 4801D711  bl 0x82c8aae0
	ctx.lr = 0x82C6D3D4;
	sub_82C8AAE0(ctx, base);
	// 82C6D3D4: 98610094  stb r3, 0x94(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u8 ) };
	pc = 0x82C6D3D8; continue 'dispatch;
            }
            0x82C6D3D8 => {
    //   block [0x82C6D3D8..0x82C6D3F4)
	// 82C6D3D8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C6D3DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6D3E0: 419A0014  beq cr6, 0x82c6d3f4
	if ctx.cr[6].eq {
	pc = 0x82C6D3F4; continue 'dispatch;
	}
	// 82C6D3E4: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 82C6D3E8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82C6D3EC: 4801D6F5  bl 0x82c8aae0
	ctx.lr = 0x82C6D3F0;
	sub_82C8AAE0(ctx, base);
	// 82C6D3F0: 98610094  stb r3, 0x94(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u8 ) };
	pc = 0x82C6D3F4; continue 'dispatch;
            }
            0x82C6D3F4 => {
    //   block [0x82C6D3F4..0x82C6D410)
	// 82C6D3F4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C6D3F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6D3FC: 419A0014  beq cr6, 0x82c6d410
	if ctx.cr[6].eq {
	pc = 0x82C6D410; continue 'dispatch;
	}
	// 82C6D400: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82C6D404: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82C6D408: 4B6FF849  bl 0x8236cc50
	ctx.lr = 0x82C6D40C;
	sub_8236CC50(ctx, base);
	// 82C6D40C: 98610094  stb r3, 0x94(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[3].u8 ) };
	pc = 0x82C6D410; continue 'dispatch;
            }
            0x82C6D410 => {
    //   block [0x82C6D410..0x82C6D424)
	// 82C6D410: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C6D414: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6D418: 409A000C  bne cr6, 0x82c6d424
	if !ctx.cr[6].eq {
	pc = 0x82C6D424; continue 'dispatch;
	}
	// 82C6D41C: 93F70000  stw r31, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C6D420: 48000378  b 0x82c6d798
	pc = 0x82C6D798; continue 'dispatch;
            }
            0x82C6D424 => {
    //   block [0x82C6D424..0x82C6D43C)
	// 82C6D424: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82C6D428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6D42C: 419A0010  beq cr6, 0x82c6d43c
	if ctx.cr[6].eq {
	pc = 0x82C6D43C; continue 'dispatch;
	}
	// 82C6D430: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82C6D434: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C6D438: 40990008  ble cr6, 0x82c6d440
	if !ctx.cr[6].gt {
	pc = 0x82C6D440; continue 'dispatch;
	}
	pc = 0x82C6D43C; continue 'dispatch;
            }
            0x82C6D43C => {
    //   block [0x82C6D43C..0x82C6D440)
	// 82C6D43C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82C6D440; continue 'dispatch;
            }
            0x82C6D440 => {
    //   block [0x82C6D440..0x82C6D454)
	// 82C6D440: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C6D444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6D448: 409A000C  bne cr6, 0x82c6d454
	if !ctx.cr[6].eq {
	pc = 0x82C6D454; continue 'dispatch;
	}
	// 82C6D44C: 93F70000  stw r31, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C6D450: 48000348  b 0x82c6d798
	pc = 0x82C6D798; continue 'dispatch;
            }
            0x82C6D454 => {
    //   block [0x82C6D454..0x82C6D47C)
	// 82C6D454: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D458: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6D45C: 83C10080  lwz r30, 0x80(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82C6D460: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6D464: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C6D468: 4E800421  bctrl
	ctx.lr = 0x82C6D46C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6D46C: 7F3E1840  cmpld cr6, r30, r3
	ctx.cr[6].compare_u64(ctx.r[30].u64, ctx.r[3].u64, &mut ctx.xer);
	// 82C6D470: 4099000C  ble cr6, 0x82c6d47c
	if !ctx.cr[6].gt {
	pc = 0x82C6D47C; continue 'dispatch;
	}
	// 82C6D474: 93F70000  stw r31, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C6D478: 48000320  b 0x82c6d798
	pc = 0x82C6D798; continue 'dispatch;
            }
            0x82C6D47C => {
    //   block [0x82C6D47C..0x82C6D4E0)
	// 82C6D47C: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82C6D480: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82C6D484: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82C6D488: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82C6D48C: 409A007C  bne cr6, 0x82c6d508
	if !ctx.cr[6].eq {
	pc = 0x82C6D508; continue 'dispatch;
	}
	// 82C6D490: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D494: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6D498: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6D49C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D4A0: 4E800421  bctrl
	ctx.lr = 0x82C6D4A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6D4A4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82C6D4A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6D4AC: 80A10080  lwz r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82C6D4B0: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82C6D4B4: 4BEE5D35  bl 0x82b531e8
	ctx.lr = 0x82C6D4B8;
	sub_82B531E8(ctx, base);
	// 82C6D4B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6D4BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C6D4C0: 4B8BD559  bl 0x8252aa18
	ctx.lr = 0x82C6D4C4;
	sub_8252AA18(ctx, base);
	// 82C6D4C4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C6D4C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6D4CC: 419A0014  beq cr6, 0x82c6d4e0
	if ctx.cr[6].eq {
	pc = 0x82C6D4E0; continue 'dispatch;
	}
	// 82C6D4D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D4D4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D4D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D4DC: 4E800421  bctrl
	ctx.lr = 0x82C6D4E0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D4E0 => {
    //   block [0x82C6D4E0..0x82C6D508)
	// 82C6D4E0: 38A00009  li r5, 9
	ctx.r[5].s64 = 9;
	// 82C6D4E4: 80C10080  lwz r6, 0x80(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82C6D4E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6D4EC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82C6D4F0: 4BEE5CF9  bl 0x82b531e8
	ctx.lr = 0x82C6D4F4;
	sub_82B531E8(ctx, base);
	// 82C6D4F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6D4F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6D4FC: 4B8BD51D  bl 0x8252aa18
	ctx.lr = 0x82C6D500;
	sub_8252AA18(ctx, base);
	// 82C6D500: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C6D504: 48000078  b 0x82c6d57c
	pc = 0x82C6D57C; continue 'dispatch;
            }
            0x82C6D508 => {
    //   block [0x82C6D508..0x82C6D544)
	// 82C6D508: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C6D50C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6D510: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6D514: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82C6D518: 4BEE5CD1  bl 0x82b531e8
	ctx.lr = 0x82C6D51C;
	sub_82B531E8(ctx, base);
	// 82C6D51C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6D520: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C6D524: 4B8BD4F5  bl 0x8252aa18
	ctx.lr = 0x82C6D528;
	sub_8252AA18(ctx, base);
	// 82C6D528: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C6D52C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6D530: 419A0014  beq cr6, 0x82c6d544
	if ctx.cr[6].eq {
	pc = 0x82C6D544; continue 'dispatch;
	}
	// 82C6D534: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D538: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D53C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D540: 4E800421  bctrl
	ctx.lr = 0x82C6D544;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D544 => {
    //   block [0x82C6D544..0x82C6D57C)
	// 82C6D544: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D548: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6D54C: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6D550: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D554: 4E800421  bctrl
	ctx.lr = 0x82C6D558;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6D558: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82C6D55C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6D560: 80A10080  lwz r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82C6D564: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C6D568: 4BEE5C81  bl 0x82b531e8
	ctx.lr = 0x82C6D56C;
	sub_82B531E8(ctx, base);
	// 82C6D56C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6D570: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6D574: 4B8BD4A5  bl 0x8252aa18
	ctx.lr = 0x82C6D578;
	sub_8252AA18(ctx, base);
	// 82C6D578: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
            }
            0x82C6D57C => {
    //   block [0x82C6D57C..0x82C6D594)
	// 82C6D57C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6D580: 419A0014  beq cr6, 0x82c6d594
	if ctx.cr[6].eq {
	pc = 0x82C6D594; continue 'dispatch;
	}
	// 82C6D584: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D588: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D58C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D590: 4E800421  bctrl
	ctx.lr = 0x82C6D594;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D594 => {
    //   block [0x82C6D594..0x82C6D5D4)
	// 82C6D594: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6D598: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82C6D59C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 82C6D5A0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C6D5A4: 4BEDD86D  bl 0x82b4ae10
	ctx.lr = 0x82C6D5A8;
	sub_82B4AE10(ctx, base);
	// 82C6D5A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C6D5AC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82C6D5B0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D5B4: 4BFFD24D  bl 0x82c6a800
	ctx.lr = 0x82C6D5B8;
	sub_82C6A800(ctx, base);
	// 82C6D5B8: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82C6D5BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6D5C0: 419A0014  beq cr6, 0x82c6d5d4
	if ctx.cr[6].eq {
	pc = 0x82C6D5D4; continue 'dispatch;
	}
	// 82C6D5C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D5C8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D5CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D5D0: 4E800421  bctrl
	ctx.lr = 0x82C6D5D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D5D4 => {
    //   block [0x82C6D5D4..0x82C6D638)
	// 82C6D5D4: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C6D5D8: 83A10078  lwz r29, 0x78(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C6D5DC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C6D5E0: 419A0160  beq cr6, 0x82c6d740
	if ctx.cr[6].eq {
	pc = 0x82C6D740; continue 'dispatch;
	}
	// 82C6D5E4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C6D5E8: 419A0158  beq cr6, 0x82c6d740
	if ctx.cr[6].eq {
	pc = 0x82C6D740; continue 'dispatch;
	}
	// 82C6D5EC: 2B1A0001  cmplwi cr6, r26, 1
	ctx.cr[6].compare_u32(ctx.r[26].u32, 1 as u32, &mut ctx.xer);
	// 82C6D5F0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82C6D5F4: 419800A0  blt cr6, 0x82c6d694
	if ctx.cr[6].lt {
	pc = 0x82C6D694; continue 'dispatch;
	}
	// 82C6D5F8: 409A00EC  bne cr6, 0x82c6d6e4
	if !ctx.cr[6].eq {
	pc = 0x82C6D6E4; continue 'dispatch;
	}
	// 82C6D5FC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82C6D600: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C6D604: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82C6D608: 4BEDD809  bl 0x82b4ae10
	ctx.lr = 0x82C6D60C;
	sub_82B4AE10(ctx, base);
	// 82C6D60C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C6D610: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82C6D614: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D618: 4BFFD1E9  bl 0x82c6a800
	ctx.lr = 0x82C6D61C;
	sub_82C6A800(ctx, base);
	// 82C6D61C: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82C6D620: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6D624: 419A0014  beq cr6, 0x82c6d638
	if ctx.cr[6].eq {
	pc = 0x82C6D638; continue 'dispatch;
	}
	// 82C6D628: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D62C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D630: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D634: 4E800421  bctrl
	ctx.lr = 0x82C6D638;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D638 => {
    //   block [0x82C6D638..0x82C6D668)
	// 82C6D638: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 82C6D63C: 4B5B1C1D  bl 0x8221f258
	ctx.lr = 0x82C6D640;
	sub_8221F258(ctx, base);
	// 82C6D640: 83C10078  lwz r30, 0x78(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C6D644: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6D648: 419A0020  beq cr6, 0x82c6d668
	if ctx.cr[6].eq {
	pc = 0x82C6D668; continue 'dispatch;
	}
	// 82C6D64C: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82C6D650: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C6D654: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C6D658: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82C6D65C: 4BFFF3AD  bl 0x82c6ca08
	ctx.lr = 0x82C6D660;
	sub_82C6CA08(ctx, base);
	// 82C6D660: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6D664: 48000008  b 0x82c6d66c
	pc = 0x82C6D66C; continue 'dispatch;
            }
            0x82C6D668 => {
    //   block [0x82C6D668..0x82C6D66C)
	// 82C6D668: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	pc = 0x82C6D66C; continue 'dispatch;
            }
            0x82C6D66C => {
    //   block [0x82C6D66C..0x82C6D694)
	// 82C6D66C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C6D670: 4BBFD721  bl 0x8286ad90
	ctx.lr = 0x82C6D674;
	sub_8286AD90(ctx, base);
	// 82C6D674: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C6D678: 419A0054  beq cr6, 0x82c6d6cc
	if ctx.cr[6].eq {
	pc = 0x82C6D6CC; continue 'dispatch;
	}
	// 82C6D67C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D680: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6D684: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D688: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D68C: 4E800421  bctrl
	ctx.lr = 0x82C6D690;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6D690: 4800003C  b 0x82c6d6cc
	pc = 0x82C6D6CC; continue 'dispatch;
            }
            0x82C6D694 => {
    //   block [0x82C6D694..0x82C6D6C0)
	// 82C6D694: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 82C6D698: 4B5B1BC1  bl 0x8221f258
	ctx.lr = 0x82C6D69C;
	sub_8221F258(ctx, base);
	// 82C6D69C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6D6A0: 419A0020  beq cr6, 0x82c6d6c0
	if ctx.cr[6].eq {
	pc = 0x82C6D6C0; continue 'dispatch;
	}
	// 82C6D6A4: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 82C6D6A8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82C6D6AC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C6D6B0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82C6D6B4: 4BFFF355  bl 0x82c6ca08
	ctx.lr = 0x82C6D6B8;
	sub_82C6CA08(ctx, base);
	// 82C6D6B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6D6BC: 48000008  b 0x82c6d6c4
	pc = 0x82C6D6C4; continue 'dispatch;
            }
            0x82C6D6C0 => {
    //   block [0x82C6D6C0..0x82C6D6C4)
	// 82C6D6C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	pc = 0x82C6D6C4; continue 'dispatch;
            }
            0x82C6D6C4 => {
    //   block [0x82C6D6C4..0x82C6D6CC)
	// 82C6D6C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C6D6C8: 4BBFD6C9  bl 0x8286ad90
	ctx.lr = 0x82C6D6CC;
	sub_8286AD90(ctx, base);
	pc = 0x82C6D6CC; continue 'dispatch;
            }
            0x82C6D6CC => {
    //   block [0x82C6D6CC..0x82C6D6E4)
	// 82C6D6CC: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C6D6D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C6D6D4: 419A0010  beq cr6, 0x82c6d6e4
	if ctx.cr[6].eq {
	pc = 0x82C6D6E4; continue 'dispatch;
	}
	// 82C6D6D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C6D6DC: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82C6D6E0: 4B8BD339  bl 0x8252aa18
	ctx.lr = 0x82C6D6E4;
	sub_8252AA18(ctx, base);
	pc = 0x82C6D6E4; continue 'dispatch;
            }
            0x82C6D6E4 => {
    //   block [0x82C6D6E4..0x82C6D70C)
	// 82C6D6E4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82C6D6E8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82C6D6EC: 4B68820D  bl 0x822f58f8
	ctx.lr = 0x82C6D6F0;
	sub_822F58F8(ctx, base);
	// 82C6D6F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C6D6F4: 419A0018  beq cr6, 0x82c6d70c
	if ctx.cr[6].eq {
	pc = 0x82C6D70C; continue 'dispatch;
	}
	// 82C6D6F8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D6FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6D700: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D704: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D708: 4E800421  bctrl
	ctx.lr = 0x82C6D70C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D70C => {
    //   block [0x82C6D70C..0x82C6D740)
	// 82C6D70C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D710: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6D714: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D718: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D71C: 4E800421  bctrl
	ctx.lr = 0x82C6D720;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6D720: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82C6D724: 419A0060  beq cr6, 0x82c6d784
	if ctx.cr[6].eq {
	pc = 0x82C6D784; continue 'dispatch;
	}
	// 82C6D728: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D72C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C6D730: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D734: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D738: 4E800421  bctrl
	ctx.lr = 0x82C6D73C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6D73C: 48000048  b 0x82c6d784
	pc = 0x82C6D784; continue 'dispatch;
            }
            0x82C6D740 => {
    //   block [0x82C6D740..0x82C6D760)
	// 82C6D740: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C6D744: 93F70000  stw r31, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C6D748: 419A0018  beq cr6, 0x82c6d760
	if ctx.cr[6].eq {
	pc = 0x82C6D760; continue 'dispatch;
	}
	// 82C6D74C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D750: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6D754: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D758: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D75C: 4E800421  bctrl
	ctx.lr = 0x82C6D760;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D760 => {
    //   block [0x82C6D760..0x82C6D77C)
	// 82C6D760: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82C6D764: 419A0018  beq cr6, 0x82c6d77c
	if ctx.cr[6].eq {
	pc = 0x82C6D77C; continue 'dispatch;
	}
	// 82C6D768: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D76C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C6D770: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D774: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D778: 4E800421  bctrl
	ctx.lr = 0x82C6D77C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D77C => {
    //   block [0x82C6D77C..0x82C6D784)
	// 82C6D77C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C6D780: 419A0018  beq cr6, 0x82c6d798
	if ctx.cr[6].eq {
	pc = 0x82C6D798; continue 'dispatch;
	}
	pc = 0x82C6D784; continue 'dispatch;
            }
            0x82C6D784 => {
    //   block [0x82C6D784..0x82C6D798)
	// 82C6D784: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D788: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C6D78C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D790: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D794: 4E800421  bctrl
	ctx.lr = 0x82C6D798;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D798 => {
    //   block [0x82C6D798..0x82C6D7BC)
	// 82C6D798: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82C6D79C: 4B6FB725  bl 0x82368ec0
	ctx.lr = 0x82C6D7A0;
	sub_82368EC0(ctx, base);
	// 82C6D7A0: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82C6D7A4: 419A0018  beq cr6, 0x82c6d7bc
	if ctx.cr[6].eq {
	pc = 0x82C6D7BC; continue 'dispatch;
	}
	// 82C6D7A8: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D7AC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82C6D7B0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D7B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D7B8: 4E800421  bctrl
	ctx.lr = 0x82C6D7BC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D7BC => {
    //   block [0x82C6D7BC..0x82C6D7C8)
	// 82C6D7BC: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82C6D7C0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82C6D7C4: 4803BC80  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6D7C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6D7C8 size=160
    let mut pc: u32 = 0x82C6D7C8;
    'dispatch: loop {
        match pc {
            0x82C6D7C8 => {
    //   block [0x82C6D7C8..0x82C6D7F8)
	// 82C6D7C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6D7CC: 4803BC41  bl 0x82ca940c
	ctx.lr = 0x82C6D7D0;
	sub_82CA93D0(ctx, base);
	// 82C6D7D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6D7D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C6D7D8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C6D7DC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82C6D7E0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C6D7E4: 409A0014  bne cr6, 0x82c6d7f8
	if !ctx.cr[6].eq {
	pc = 0x82C6D7F8; continue 'dispatch;
	}
	// 82C6D7E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6D7EC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C6D7F0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6D7F4: 4803BC68  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6D7F8 => {
    //   block [0x82C6D7F8..0x82C6D834)
	// 82C6D7F8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D7FC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82C6D800: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C6D804: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6D808: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C6D80C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D810: 4E800421  bctrl
	ctx.lr = 0x82C6D814;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6D814: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6D818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6D81C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C6D820: 409A0014  bne cr6, 0x82c6d834
	if !ctx.cr[6].eq {
	pc = 0x82C6D834; continue 'dispatch;
	}
	// 82C6D824: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6D828: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C6D82C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6D830: 4803BC2C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6D834 => {
    //   block [0x82C6D834..0x82C6D85C)
	// 82C6D834: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82C6D838: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C6D83C: 4BFFFA4D  bl 0x82c6d288
	ctx.lr = 0x82C6D840;
	sub_82C6D288(ctx, base);
	// 82C6D840: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6D844: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6D848: 419A0014  beq cr6, 0x82c6d85c
	if ctx.cr[6].eq {
	pc = 0x82C6D85C; continue 'dispatch;
	}
	// 82C6D84C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D850: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D854: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D858: 4E800421  bctrl
	ctx.lr = 0x82C6D85C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D85C => {
    //   block [0x82C6D85C..0x82C6D868)
	// 82C6D85C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6D860: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6D864: 4803BBF8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6D868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6D868 size=120
    let mut pc: u32 = 0x82C6D868;
    'dispatch: loop {
        match pc {
            0x82C6D868 => {
    //   block [0x82C6D868..0x82C6D8A4)
	// 82C6D868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6D86C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6D870: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6D874: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6D878: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6D87C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C6D880: 394BDEC8  addi r10, r11, -0x2138
	ctx.r[10].s64 = ctx.r[11].s64 + -8504;
	// 82C6D884: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C6D888: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6D88C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6D890: 419A0014  beq cr6, 0x82c6d8a4
	if ctx.cr[6].eq {
	pc = 0x82C6D8A4; continue 'dispatch;
	}
	// 82C6D894: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D898: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D89C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D8A0: 4E800421  bctrl
	ctx.lr = 0x82C6D8A4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D8A4 => {
    //   block [0x82C6D8A4..0x82C6D8C0)
	// 82C6D8A4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D8A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6D8AC: 419A0014  beq cr6, 0x82c6d8c0
	if ctx.cr[6].eq {
	pc = 0x82C6D8C0; continue 'dispatch;
	}
	// 82C6D8B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D8B4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6D8B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D8BC: 4E800421  bctrl
	ctx.lr = 0x82C6D8C0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D8C0 => {
    //   block [0x82C6D8C0..0x82C6D8E0)
	// 82C6D8C0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82C6D8C4: 394B8F38  addi r10, r11, -0x70c8
	ctx.r[10].s64 = ctx.r[11].s64 + -28872;
	// 82C6D8C8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C6D8CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6D8D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6D8D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6D8D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6D8DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6D8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6D8E0 size=84
    let mut pc: u32 = 0x82C6D8E0;
    'dispatch: loop {
        match pc {
            0x82C6D8E0 => {
    //   block [0x82C6D8E0..0x82C6D91C)
	// 82C6D8E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6D8E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6D8E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6D8EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6D8F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6D8F4: 8064000C  lwz r3, 0xc(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6D8F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C6D8FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6D900: 99640010  stb r11, 0x10(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 82C6D904: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C6D908: 419A0014  beq cr6, 0x82c6d91c
	if ctx.cr[6].eq {
	pc = 0x82C6D91C; continue 'dispatch;
	}
	// 82C6D90C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D910: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6D914: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D918: 4E800421  bctrl
	ctx.lr = 0x82C6D91C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D91C => {
    //   block [0x82C6D91C..0x82C6D934)
	// 82C6D91C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6D920: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6D924: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6D928: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6D92C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6D930: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6D938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6D938 size=80
    let mut pc: u32 = 0x82C6D938;
    'dispatch: loop {
        match pc {
            0x82C6D938 => {
    //   block [0x82C6D938..0x82C6D970)
	// 82C6D938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6D93C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6D940: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6D944: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6D948: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6D94C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6D950: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C6D954: 4BFFFF15  bl 0x82c6d868
	ctx.lr = 0x82C6D958;
	sub_82C6D868(ctx, base);
	// 82C6D958: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C6D95C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6D960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6D964: 419A000C  beq cr6, 0x82c6d970
	if ctx.cr[6].eq {
	pc = 0x82C6D970; continue 'dispatch;
	}
	// 82C6D968: 4BBD7E49  bl 0x828457b0
	ctx.lr = 0x82C6D96C;
	sub_828457B0(ctx, base);
	// 82C6D96C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C6D970; continue 'dispatch;
            }
            0x82C6D970 => {
    //   block [0x82C6D970..0x82C6D988)
	// 82C6D970: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6D974: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6D978: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6D97C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6D980: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6D984: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6D988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6D988 size=152
    let mut pc: u32 = 0x82C6D988;
    'dispatch: loop {
        match pc {
            0x82C6D988 => {
    //   block [0x82C6D988..0x82C6D9D4)
	// 82C6D988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6D98C: 4803BA81  bl 0x82ca940c
	ctx.lr = 0x82C6D990;
	sub_82CA93D0(ctx, base);
	// 82C6D990: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6D994: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6D998: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C6D99C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C6D9A0: 392BDEC8  addi r9, r11, -0x2138
	ctx.r[9].s64 = ctx.r[11].s64 + -8504;
	// 82C6D9A4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C6D9A8: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C6D9AC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82C6D9B0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C6D9B4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C6D9B8: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82C6D9BC: 419A0018  beq cr6, 0x82c6d9d4
	if ctx.cr[6].eq {
	pc = 0x82C6D9D4; continue 'dispatch;
	}
	// 82C6D9C0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D9C4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C6D9C8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6D9CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D9D0: 4E800421  bctrl
	ctx.lr = 0x82C6D9D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D9D4 => {
    //   block [0x82C6D9D4..0x82C6D9F4)
	// 82C6D9D4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D9D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6D9DC: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82C6D9E0: 419A0014  beq cr6, 0x82c6d9f4
	if ctx.cr[6].eq {
	pc = 0x82C6D9F4; continue 'dispatch;
	}
	// 82C6D9E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D9E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6D9EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6D9F0: 4E800421  bctrl
	ctx.lr = 0x82C6D9F4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6D9F4 => {
    //   block [0x82C6D9F4..0x82C6DA14)
	// 82C6D9F4: 9BBF0010  stb r29, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 82C6D9F8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6D9FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6DA00: 419A0014  beq cr6, 0x82c6da14
	if ctx.cr[6].eq {
	pc = 0x82C6DA14; continue 'dispatch;
	}
	// 82C6DA04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DA08: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6DA0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6DA10: 4E800421  bctrl
	ctx.lr = 0x82C6DA14;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6DA14 => {
    //   block [0x82C6DA14..0x82C6DA20)
	// 82C6DA14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6DA18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6DA1C: 4803BA40  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6DA20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6DA20 size=108
    let mut pc: u32 = 0x82C6DA20;
    'dispatch: loop {
        match pc {
            0x82C6DA20 => {
    //   block [0x82C6DA20..0x82C6DA40)
	// 82C6DA20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6DA24: 4803B9E9  bl 0x82ca940c
	ctx.lr = 0x82C6DA28;
	sub_82CA93D0(ctx, base);
	// 82C6DA28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6DA2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6DA30: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C6DA34: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C6DA38: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C6DA3C: 419A0044  beq cr6, 0x82c6da80
	if ctx.cr[6].eq {
	pc = 0x82C6DA80; continue 'dispatch;
	}
	pc = 0x82C6DA40; continue 'dispatch;
            }
            0x82C6DA40 => {
    //   block [0x82C6DA40..0x82C6DA58)
	// 82C6DA40: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6DA44: 80FE0014  lwz r7, 0x14(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6DA48: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82C6DA4C: 4198000C  blt cr6, 0x82c6da58
	if ctx.cr[6].lt {
	pc = 0x82C6DA58; continue 'dispatch;
	}
	// 82C6DA50: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6DA54: 48000008  b 0x82c6da5c
	pc = 0x82C6DA5C; continue 'dispatch;
            }
            0x82C6DA58 => {
    //   block [0x82C6DA58..0x82C6DA5C)
	// 82C6DA58: 38DE0004  addi r6, r30, 4
	ctx.r[6].s64 = ctx.r[30].s64 + 4;
	pc = 0x82C6DA5C; continue 'dispatch;
            }
            0x82C6DA5C => {
    //   block [0x82C6DA5C..0x82C6DA80)
	// 82C6DA5C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C6DA60: 80BF0014  lwz r5, 0x14(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6DA64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6DA68: 4B709AD1  bl 0x82377538
	ctx.lr = 0x82C6DA6C;
	sub_82377538(ctx, base);
	// 82C6DA6C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C6DA70: 419A0010  beq cr6, 0x82c6da80
	if ctx.cr[6].eq {
	pc = 0x82C6DA80; continue 'dispatch;
	}
	// 82C6DA74: 3BFF0024  addi r31, r31, 0x24
	ctx.r[31].s64 = ctx.r[31].s64 + 36;
	// 82C6DA78: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C6DA7C: 409AFFC4  bne cr6, 0x82c6da40
	if !ctx.cr[6].eq {
	pc = 0x82C6DA40; continue 'dispatch;
	}
	pc = 0x82C6DA80; continue 'dispatch;
            }
            0x82C6DA80 => {
    //   block [0x82C6DA80..0x82C6DA8C)
	// 82C6DA80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6DA84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6DA88: 4803B9D4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6DA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6DA90 size=220
    let mut pc: u32 = 0x82C6DA90;
    'dispatch: loop {
        match pc {
            0x82C6DA90 => {
    //   block [0x82C6DA90..0x82C6DAC8)
	// 82C6DA90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6DA94: 4803B975  bl 0x82ca9408
	ctx.lr = 0x82C6DA98;
	sub_82CA93D0(ctx, base);
	// 82C6DA98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6DA9C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C6DAA0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C6DAA4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C6DAA8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82C6DAAC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6DAB0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82C6DAB4: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6DAB8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6DABC: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82C6DAC0: 40990008  ble cr6, 0x82c6dac8
	if !ctx.cr[6].gt {
	pc = 0x82C6DAC8; continue 'dispatch;
	}
	// 82C6DAC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6DAC8; continue 'dispatch;
            }
            0x82C6DAC8 => {
    //   block [0x82C6DAC8..0x82C6DADC)
	// 82C6DAC8: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6DACC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6DAD0: 7F035040  cmplw cr6, r3, r10
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6DAD4: 40990008  ble cr6, 0x82c6dadc
	if !ctx.cr[6].gt {
	pc = 0x82C6DADC; continue 'dispatch;
	}
	// 82C6DAD8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6DADC; continue 'dispatch;
            }
            0x82C6DADC => {
    //   block [0x82C6DADC..0x82C6DB10)
	// 82C6DADC: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82C6DAE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C6DAE4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C6DAE8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C6DAEC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82C6DAF0: 4BFFFF31  bl 0x82c6da20
	ctx.lr = 0x82C6DAF4;
	sub_82C6DA20(ctx, base);
	// 82C6DAF4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6DAF8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82C6DAFC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6DB00: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6DB04: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6DB08: 40990008  ble cr6, 0x82c6db10
	if !ctx.cr[6].gt {
	pc = 0x82C6DB10; continue 'dispatch;
	}
	// 82C6DB0C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6DB10; continue 'dispatch;
            }
            0x82C6DB10 => {
    //   block [0x82C6DB10..0x82C6DB24)
	// 82C6DB10: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6DB14: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C6DB18: 419A000C  beq cr6, 0x82c6db24
	if ctx.cr[6].eq {
	pc = 0x82C6DB24; continue 'dispatch;
	}
	// 82C6DB1C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6DB20: 419A0008  beq cr6, 0x82c6db28
	if ctx.cr[6].eq {
	pc = 0x82C6DB28; continue 'dispatch;
	}
	pc = 0x82C6DB24; continue 'dispatch;
            }
            0x82C6DB24 => {
    //   block [0x82C6DB24..0x82C6DB28)
	// 82C6DB24: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C6DB28; continue 'dispatch;
            }
            0x82C6DB28 => {
    //   block [0x82C6DB28..0x82C6DB44)
	// 82C6DB28: 7F035040  cmplw cr6, r3, r10
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C6DB2C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6DB30: 409A0014  bne cr6, 0x82c6db44
	if !ctx.cr[6].eq {
	pc = 0x82C6DB44; continue 'dispatch;
	}
	// 82C6DB34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6DB38: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C6DB3C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6DB40: 4803B918  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6DB44 => {
    //   block [0x82C6DB44..0x82C6DB6C)
	// 82C6DB44: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6DB48: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82C6DB4C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C6DB50: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DB54: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C6DB58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6DB5C: 4E800421  bctrl
	ctx.lr = 0x82C6DB60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6DB60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6DB64: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6DB68: 4803B8F0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6DB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6DB70 size=104
    let mut pc: u32 = 0x82C6DB70;
    'dispatch: loop {
        match pc {
            0x82C6DB70 => {
    //   block [0x82C6DB70..0x82C6DBD8)
	// 82C6DB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6DB74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6DB78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6DB7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6DB80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6DB84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6DB88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6DB8C: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 82C6DB90: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C6DB94: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82C6DB98: 3BC9DEF0  addi r30, r9, -0x2110
	ctx.r[30].s64 = ctx.r[9].s64 + -8464;
	// 82C6DB9C: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 82C6DBA0: B17F0004  sth r11, 4(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 82C6DBA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6DBA8: 4B50D4D9  bl 0x8217b080
	ctx.lr = 0x82C6DBAC;
	sub_8217B080(ctx, base);
	// 82C6DBAC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C6DBB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6DBB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C6DBB8: 4B50D059  bl 0x8217ac10
	ctx.lr = 0x82C6DBBC;
	sub_8217AC10(ctx, base);
	// 82C6DBBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6DBC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6DBC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6DBC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6DBCC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6DBD0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6DBD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6DBD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6DBD8 size=140
    let mut pc: u32 = 0x82C6DBD8;
    'dispatch: loop {
        match pc {
            0x82C6DBD8 => {
    //   block [0x82C6DBD8..0x82C6DC1C)
	// 82C6DBD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6DBDC: 4803B831  bl 0x82ca940c
	ctx.lr = 0x82C6DBE0;
	sub_82CA93D0(ctx, base);
	// 82C6DBE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6DBE4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C6DBE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C6DBEC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82C6DBF0: 3885FFFF  addi r4, r5, -1
	ctx.r[4].s64 = ctx.r[5].s64 + -1;
	// 82C6DBF4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6DBF8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6DBFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C6DC00: 419A001C  beq cr6, 0x82c6dc1c
	if ctx.cr[6].eq {
	pc = 0x82C6DC1C; continue 'dispatch;
	}
	// 82C6DC04: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C6DC08: 39000024  li r8, 0x24
	ctx.r[8].s64 = 36;
	// 82C6DC0C: 7CEA4850  subf r7, r10, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82C6DC10: 7CC743D6  divw r6, r7, r8
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[8].s32;
	// 82C6DC14: 7F043040  cmplw cr6, r4, r6
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82C6DC18: 41980018  blt cr6, 0x82c6dc30
	if ctx.cr[6].lt {
	pc = 0x82C6DC30; continue 'dispatch;
	}
	pc = 0x82C6DC1C; continue 'dispatch;
            }
            0x82C6DC1C => {
    //   block [0x82C6DC1C..0x82C6DC30)
	// 82C6DC1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6DC20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6DC24: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C6DC28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6DC2C: 4803B830  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6DC30 => {
    //   block [0x82C6DC30..0x82C6DC64)
	// 82C6DC30: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82C6DC34: 4B6A57CD  bl 0x82313400
	ctx.lr = 0x82C6DC38;
	sub_82313400(ctx, base);
	// 82C6DC38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DC3C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C6DC40: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82C6DC44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C6DC48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6DC4C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C6DC50: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6DC54: 4E800421  bctrl
	ctx.lr = 0x82C6DC58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6DC58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6DC5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6DC60: 4803B7FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6DC68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6DC68 size=204
    let mut pc: u32 = 0x82C6DC68;
    'dispatch: loop {
        match pc {
            0x82C6DC68 => {
    //   block [0x82C6DC68..0x82C6DC94)
	// 82C6DC68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6DC6C: 4803B79D  bl 0x82ca9408
	ctx.lr = 0x82C6DC70;
	sub_82CA93D0(ctx, base);
	// 82C6DC70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6DC74: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C6DC78: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C6DC7C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C6DC80: 409A0014  bne cr6, 0x82c6dc94
	if !ctx.cr[6].eq {
	pc = 0x82C6DC94; continue 'dispatch;
	}
	// 82C6DC84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6DC88: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C6DC8C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6DC90: 4803B7C8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6DC94 => {
    //   block [0x82C6DC94..0x82C6DCD4)
	// 82C6DC94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6DC98: 4B706841  bl 0x823744d8
	ctx.lr = 0x82C6DC9C;
	sub_823744D8(ctx, base);
	// 82C6DC9C: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82C6DCA0: 4B5B15B9  bl 0x8221f258
	ctx.lr = 0x82C6DCA4;
	sub_8221F258(ctx, base);
	// 82C6DCA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6DCA8: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6DCAC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C6DCB0: 419A003C  beq cr6, 0x82c6dcec
	if ctx.cr[6].eq {
	pc = 0x82C6DCEC; continue 'dispatch;
	}
	// 82C6DCB4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82C6DCB8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C6DCBC: 419A0018  beq cr6, 0x82c6dcd4
	if ctx.cr[6].eq {
	pc = 0x82C6DCD4; continue 'dispatch;
	}
	// 82C6DCC0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DCC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6DCC8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6DCCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6DCD0: 4E800421  bctrl
	ctx.lr = 0x82C6DCD4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6DCD4 => {
    //   block [0x82C6DCD4..0x82C6DCEC)
	// 82C6DCD4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82C6DCD8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C6DCDC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C6DCE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6DCE4: 4BFFFCA5  bl 0x82c6d988
	ctx.lr = 0x82C6DCE8;
	sub_82C6D988(ctx, base);
	// 82C6DCE8: 48000008  b 0x82c6dcf0
	pc = 0x82C6DCF0; continue 'dispatch;
            }
            0x82C6DCEC => {
    //   block [0x82C6DCEC..0x82C6DCF0)
	// 82C6DCEC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82C6DCF0; continue 'dispatch;
            }
            0x82C6DCF0 => {
    //   block [0x82C6DCF0..0x82C6DD0C)
	// 82C6DCF0: 907C0000  stw r3, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C6DCF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6DCF8: 419A0014  beq cr6, 0x82c6dd0c
	if ctx.cr[6].eq {
	pc = 0x82C6DD0C; continue 'dispatch;
	}
	// 82C6DCFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DD00: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6DD04: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6DD08: 4E800421  bctrl
	ctx.lr = 0x82C6DD0C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6DD0C => {
    //   block [0x82C6DD0C..0x82C6DD28)
	// 82C6DD0C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C6DD10: 419A0018  beq cr6, 0x82c6dd28
	if ctx.cr[6].eq {
	pc = 0x82C6DD28; continue 'dispatch;
	}
	// 82C6DD14: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DD18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C6DD1C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6DD20: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6DD24: 4E800421  bctrl
	ctx.lr = 0x82C6DD28;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6DD28 => {
    //   block [0x82C6DD28..0x82C6DD34)
	// 82C6DD28: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C6DD2C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6DD30: 4803B728  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6DD38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6DD38 size=1164
    let mut pc: u32 = 0x82C6DD38;
    'dispatch: loop {
        match pc {
            0x82C6DD38 => {
    //   block [0x82C6DD38..0x82C6DD6C)
	// 82C6DD38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6DD3C: 4803B6A5  bl 0x82ca93e0
	ctx.lr = 0x82C6DD40;
	sub_82CA93D0(ctx, base);
	// 82C6DD40: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 82C6DD44: 9421E650  stwu r1, -0x19b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-6576 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6DD48: 7C932378  mr r19, r4
	ctx.r[19].u64 = ctx.r[4].u64;
	// 82C6DD4C: 7C721B78  mr r18, r3
	ctx.r[18].u64 = ctx.r[3].u64;
	// 82C6DD50: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C6DD54: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 82C6DD58: 409A0014  bne cr6, 0x82c6dd6c
	if !ctx.cr[6].eq {
	pc = 0x82C6DD6C; continue 'dispatch;
	}
	// 82C6DD5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6DD60: 91720000  stw r11, 0(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C6DD64: 382119B0  addi r1, r1, 0x19b0
	ctx.r[1].s64 = ctx.r[1].s64 + 6576;
	// 82C6DD68: 4803B6C8  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6DD6C => {
    //   block [0x82C6DD6C..0x82C6DDD4)
	// 82C6DD6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C6DD70: 4B706769  bl 0x823744d8
	ctx.lr = 0x82C6DD74;
	sub_823744D8(ctx, base);
	// 82C6DD74: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DD78: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82C6DD7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C6DD80: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 82C6DD84: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C6DD88: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C6DD8C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6DD90: 4E800421  bctrl
	ctx.lr = 0x82C6DD94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6DD94: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C6DD98: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C6DD9C: 409A004C  bne cr6, 0x82c6dde8
	if !ctx.cr[6].eq {
	pc = 0x82C6DDE8; continue 'dispatch;
	}
	// 82C6DDA0: 92720000  stw r19, 0(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(0 as u32), ctx.r[19].u32 ) };
	// 82C6DDA4: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82C6DDA8: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DDAC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6DDB0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6DDB4: 4E800421  bctrl
	ctx.lr = 0x82C6DDB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6DDB8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C6DDBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6DDC0: 419A0014  beq cr6, 0x82c6ddd4
	if ctx.cr[6].eq {
	pc = 0x82C6DDD4; continue 'dispatch;
	}
	// 82C6DDC4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DDC8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6DDCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6DDD0: 4E800421  bctrl
	ctx.lr = 0x82C6DDD4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6DDD4 => {
    //   block [0x82C6DDD4..0x82C6DDE8)
	// 82C6DDD4: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C6DDD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6DDDC: 419A03DC  beq cr6, 0x82c6e1b8
	if ctx.cr[6].eq {
	pc = 0x82C6E1B8; continue 'dispatch;
	}
	// 82C6DDE0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DDE4: 480003C8  b 0x82c6e1ac
	pc = 0x82C6E1AC; continue 'dispatch;
            }
            0x82C6DDE8 => {
    //   block [0x82C6DDE8..0x82C6DE2C)
	// 82C6DDE8: 3CC00001  lis r6, 1
	ctx.r[6].s64 = 65536;
	// 82C6DDEC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6DDF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6DDF4: 4BEE05FD  bl 0x82b4e3f0
	ctx.lr = 0x82C6DDF8;
	sub_82B4E3F0(ctx, base);
	// 82C6DDF8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6DDFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6DE00: 409A005C  bne cr6, 0x82c6de5c
	if !ctx.cr[6].eq {
	pc = 0x82C6DE5C; continue 'dispatch;
	}
	// 82C6DE04: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 82C6DE08: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 82C6DE0C: 4BFFC9F5  bl 0x82c6a800
	ctx.lr = 0x82C6DE10;
	sub_82C6A800(ctx, base);
	// 82C6DE10: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6DE14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6DE18: 419A0014  beq cr6, 0x82c6de2c
	if ctx.cr[6].eq {
	pc = 0x82C6DE2C; continue 'dispatch;
	}
	// 82C6DE1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DE20: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6DE24: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6DE28: 4E800421  bctrl
	ctx.lr = 0x82C6DE2C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6DE2C => {
    //   block [0x82C6DE2C..0x82C6DE48)
	// 82C6DE2C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C6DE30: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6DE34: 419A0014  beq cr6, 0x82c6de48
	if ctx.cr[6].eq {
	pc = 0x82C6DE48; continue 'dispatch;
	}
	// 82C6DE38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DE3C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6DE40: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6DE44: 4E800421  bctrl
	ctx.lr = 0x82C6DE48;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6DE48 => {
    //   block [0x82C6DE48..0x82C6DE5C)
	// 82C6DE48: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C6DE4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6DE50: 419A0368  beq cr6, 0x82c6e1b8
	if ctx.cr[6].eq {
	pc = 0x82C6E1B8; continue 'dispatch;
	}
	// 82C6DE54: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DE58: 48000354  b 0x82c6e1ac
	pc = 0x82C6E1AC; continue 'dispatch;
            }
            0x82C6DE5C => {
    //   block [0x82C6DE5C..0x82C6DEA0)
	// 82C6DE5C: 3C600002  lis r3, 2
	ctx.r[3].s64 = 131072;
	// 82C6DE60: 4B5B13F9  bl 0x8221f258
	ctx.lr = 0x82C6DE64;
	sub_8221F258(ctx, base);
	// 82C6DE64: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 82C6DE68: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 82C6DE6C: 409A0064  bne cr6, 0x82c6ded0
	if !ctx.cr[6].eq {
	pc = 0x82C6DED0; continue 'dispatch;
	}
	// 82C6DE70: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 82C6DE74: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 82C6DE78: 4BFFC989  bl 0x82c6a800
	ctx.lr = 0x82C6DE7C;
	sub_82C6A800(ctx, base);
	// 82C6DE7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C6DE80: 4BBD7931  bl 0x828457b0
	ctx.lr = 0x82C6DE84;
	sub_828457B0(ctx, base);
	// 82C6DE84: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6DE88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6DE8C: 419A0014  beq cr6, 0x82c6dea0
	if ctx.cr[6].eq {
	pc = 0x82C6DEA0; continue 'dispatch;
	}
	// 82C6DE90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DE94: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6DE98: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6DE9C: 4E800421  bctrl
	ctx.lr = 0x82C6DEA0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6DEA0 => {
    //   block [0x82C6DEA0..0x82C6DEBC)
	// 82C6DEA0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C6DEA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6DEA8: 419A0014  beq cr6, 0x82c6debc
	if ctx.cr[6].eq {
	pc = 0x82C6DEBC; continue 'dispatch;
	}
	// 82C6DEAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DEB0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6DEB4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6DEB8: 4E800421  bctrl
	ctx.lr = 0x82C6DEBC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6DEBC => {
    //   block [0x82C6DEBC..0x82C6DED0)
	// 82C6DEBC: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C6DEC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6DEC4: 419A02F4  beq cr6, 0x82c6e1b8
	if ctx.cr[6].eq {
	pc = 0x82C6E1B8; continue 'dispatch;
	}
	// 82C6DEC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DECC: 480002E0  b 0x82c6e1ac
	pc = 0x82C6E1AC; continue 'dispatch;
            }
            0x82C6DED0 => {
    //   block [0x82C6DED0..0x82C6DF0C)
	// 82C6DED0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6DED4: 3BA10120  addi r29, r1, 0x120
	ctx.r[29].s64 = ctx.r[1].s64 + 288;
	// 82C6DED8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DEDC: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6DEE0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6DEE4: 4E800421  bctrl
	ctx.lr = 0x82C6DEE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6DEE8: 5478003E  slwi r24, r3, 0
	ctx.r[24].u32 = ctx.r[3].u32.wrapping_shl(0);
	ctx.r[24].u64 = ctx.r[24].u32 as u64;
	// 82C6DEEC: 82C10058  lwz r22, 0x58(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C6DEF0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C6DEF4: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82C6DEF8: 419A021C  beq cr6, 0x82c6e114
	if ctx.cr[6].eq {
	pc = 0x82C6E114; continue 'dispatch;
	}
	// 82C6DEFC: 3E800002  lis r20, 2
	ctx.r[20].s64 = 131072;
	// 82C6DF00: 3B800007  li r28, 7
	ctx.r[28].s64 = 7;
	// 82C6DF04: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
	// 82C6DF08: 3AA00024  li r21, 0x24
	ctx.r[21].s64 = 36;
            }
            0x82C6DF0C => {
    //   block [0x82C6DF0C..0x82C6DF1C)
	// 82C6DF0C: 7F18A040  cmplw cr6, r24, r20
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[20].u32, &mut ctx.xer);
	// 82C6DF10: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 82C6DF14: 41980008  blt cr6, 0x82c6df1c
	if ctx.cr[6].lt {
	pc = 0x82C6DF1C; continue 'dispatch;
	}
	// 82C6DF18: 7E9EA378  mr r30, r20
	ctx.r[30].u64 = ctx.r[20].u64;
	pc = 0x82C6DF1C; continue 'dispatch;
            }
            0x82C6DF1C => {
    //   block [0x82C6DF1C..0x82C6DF54)
	// 82C6DF1C: 92E10088  stw r23, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[23].u32 ) };
	// 82C6DF20: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C6DF24: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6DF28: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82C6DF2C: 93E1008C  stw r31, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[31].u32 ) };
	// 82C6DF30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DF34: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6DF38: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6DF3C: 4E800421  bctrl
	ctx.lr = 0x82C6DF40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6DF40: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C6DF44: 4198014C  blt cr6, 0x82c6e090
	if ctx.cr[6].lt {
	pc = 0x82C6E090; continue 'dispatch;
	}
	// 82C6DF48: 7F1EC050  subf r24, r30, r24
	ctx.r[24].s64 = ctx.r[24].s64 - ctx.r[30].s64;
	// 82C6DF4C: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 82C6DF50: 7F3EBA14  add r25, r30, r23
	ctx.r[25].u64 = ctx.r[30].u64 + ctx.r[23].u64;
            }
            0x82C6DF54 => {
    //   block [0x82C6DF54..0x82C6DF78)
	// 82C6DF54: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6DF58: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 82C6DF5C: 2F0A000A  cmpwi cr6, r10, 0xa
	ctx.cr[6].compare_i32(ctx.r[10].s32, 10, &mut ctx.xer);
	// 82C6DF60: 419A0018  beq cr6, 0x82c6df78
	if ctx.cr[6].eq {
	pc = 0x82C6DF78; continue 'dispatch;
	}
	// 82C6DF64: 2F0A000D  cmpwi cr6, r10, 0xd
	ctx.cr[6].compare_i32(ctx.r[10].s32, 13, &mut ctx.xer);
	// 82C6DF68: 419A0010  beq cr6, 0x82c6df78
	if ctx.cr[6].eq {
	pc = 0x82C6DF78; continue 'dispatch;
	}
	// 82C6DF6C: 997D0000  stb r11, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82C6DF70: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C6DF74: 48000104  b 0x82c6e078
	pc = 0x82C6E078; continue 'dispatch;
            }
            0x82C6DF78 => {
    //   block [0x82C6DF78..0x82C6DFEC)
	// 82C6DF78: 39610120  addi r11, r1, 0x120
	ctx.r[11].s64 = ctx.r[1].s64 + 288;
	// 82C6DF7C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6DF80: 419A00F8  beq cr6, 0x82c6e078
	if ctx.cr[6].eq {
	pc = 0x82C6E078; continue 'dispatch;
	}
	// 82C6DF84: 9BFD0000  stb r31, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	// 82C6DF88: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82C6DF8C: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 82C6DF90: 38C10120  addi r6, r1, 0x120
	ctx.r[6].s64 = ctx.r[1].s64 + 288;
	// 82C6DF94: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82C6DF98: 38A00801  li r5, 0x801
	ctx.r[5].s64 = 2049;
	// 82C6DF9C: B3E10064  sth r31, 0x64(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u16 ) };
	// 82C6DFA0: 38810930  addi r4, r1, 0x930
	ctx.r[4].s64 = ctx.r[1].s64 + 2352;
	// 82C6DFA4: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 82C6DFA8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C6DFAC: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 82C6DFB0: 4B50CF19  bl 0x8217aec8
	ctx.lr = 0x82C6DFB4;
	sub_8217AEC8(ctx, base);
	// 82C6DFB4: 38610930  addi r3, r1, 0x930
	ctx.r[3].s64 = ctx.r[1].s64 + 2352;
	// 82C6DFB8: 4B50D0C9  bl 0x8217b080
	ctx.lr = 0x82C6DFBC;
	sub_8217B080(ctx, base);
	// 82C6DFBC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C6DFC0: 38810930  addi r4, r1, 0x930
	ctx.r[4].s64 = ctx.r[1].s64 + 2352;
	// 82C6DFC4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C6DFC8: 4B50CC49  bl 0x8217ac10
	ctx.lr = 0x82C6DFCC;
	sub_8217AC10(ctx, base);
	// 82C6DFCC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C6DFD0: 4B50CFA1  bl 0x8217af70
	ctx.lr = 0x82C6DFD4;
	sub_8217AF70(ctx, base);
	// 82C6DFD4: 8176000C  lwz r11, 0xc(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6DFD8: 3BD60008  addi r30, r22, 8
	ctx.r[30].s64 = ctx.r[22].s64 + 8;
	// 82C6DFDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6DFE0: 409A000C  bne cr6, 0x82c6dfec
	if !ctx.cr[6].eq {
	pc = 0x82C6DFEC; continue 'dispatch;
	}
	// 82C6DFE4: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82C6DFE8: 48000010  b 0x82c6dff8
	pc = 0x82C6DFF8; continue 'dispatch;
            }
            0x82C6DFEC => {
    //   block [0x82C6DFEC..0x82C6DFF8)
	// 82C6DFEC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6DFF0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6DFF4: 7FA9ABD6  divw r29, r9, r21
	ctx.r[29].s32 = ctx.r[9].s32 / ctx.r[21].s32;
	pc = 0x82C6DFF8; continue 'dispatch;
            }
            0x82C6DFF8 => {
    //   block [0x82C6DFF8..0x82C6E048)
	// 82C6DFF8: 938100A8  stw r28, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[28].u32 ) };
	// 82C6DFFC: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82C6E000: 93E100A4  stw r31, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[31].u32 ) };
	// 82C6E004: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6E008: B3E10094  sth r31, 0x94(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u16 ) };
	// 82C6E00C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C6E010: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82C6E014: 4B688685  bl 0x822f6698
	ctx.lr = 0x82C6E018;
	sub_822F6698(ctx, base);
	// 82C6E018: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82C6E01C: 397D0001  addi r11, r29, 1
	ctx.r[11].s64 = ctx.r[29].s64 + 1;
	// 82C6E020: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82C6E024: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82C6E028: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6E02C: 914100AC  stw r10, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 82C6E030: 4B706D49  bl 0x82374d78
	ctx.lr = 0x82C6E034;
	sub_82374D78(ctx, base);
	// 82C6E034: 812100A8  lwz r9, 0xa8(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) } as u64;
	// 82C6E038: 2B090008  cmplwi cr6, r9, 8
	ctx.cr[6].compare_u32(ctx.r[9].u32, 8 as u32, &mut ctx.xer);
	// 82C6E03C: 4198000C  blt cr6, 0x82c6e048
	if ctx.cr[6].lt {
	pc = 0x82C6E048; continue 'dispatch;
	}
	// 82C6E040: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82C6E044: 4BBD776D  bl 0x828457b0
	ctx.lr = 0x82C6E048;
	sub_828457B0(ctx, base);
	pc = 0x82C6E048; continue 'dispatch;
            }
            0x82C6E048 => {
    //   block [0x82C6E048..0x82C6E068)
	// 82C6E048: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82C6E04C: 938100A8  stw r28, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[28].u32 ) };
	// 82C6E050: 93E100A4  stw r31, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[31].u32 ) };
	// 82C6E054: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82C6E058: B3E10094  sth r31, 0x94(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u16 ) };
	// 82C6E05C: 4198000C  blt cr6, 0x82c6e068
	if ctx.cr[6].lt {
	pc = 0x82C6E068; continue 'dispatch;
	}
	// 82C6E060: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C6E064: 4BBD774D  bl 0x828457b0
	ctx.lr = 0x82C6E068;
	sub_828457B0(ctx, base);
	pc = 0x82C6E068; continue 'dispatch;
            }
            0x82C6E068 => {
    //   block [0x82C6E068..0x82C6E078)
	// 82C6E068: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 82C6E06C: 3BA10120  addi r29, r1, 0x120
	ctx.r[29].s64 = ctx.r[1].s64 + 288;
	// 82C6E070: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82C6E074: B3E10064  sth r31, 0x64(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u16 ) };
	pc = 0x82C6E078; continue 'dispatch;
            }
            0x82C6E078 => {
    //   block [0x82C6E078..0x82C6E090)
	// 82C6E078: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82C6E07C: 39610921  addi r11, r1, 0x921
	ctx.r[11].s64 = ctx.r[1].s64 + 2337;
	// 82C6E080: 7F1BC840  cmplw cr6, r27, r25
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82C6E084: 419A0014  beq cr6, 0x82c6e098
	if ctx.cr[6].eq {
	pc = 0x82C6E098; continue 'dispatch;
	}
	// 82C6E088: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6E08C: 409AFEC8  bne cr6, 0x82c6df54
	if !ctx.cr[6].eq {
	pc = 0x82C6DF54; continue 'dispatch;
	}
	pc = 0x82C6E090; continue 'dispatch;
            }
            0x82C6E090 => {
    //   block [0x82C6E090..0x82C6E098)
	// 82C6E090: 93F20000  stw r31, 0(r18)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[18].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C6E094: 480000C8  b 0x82c6e15c
	pc = 0x82C6E15C; continue 'dispatch;
            }
            0x82C6E098 => {
    //   block [0x82C6E098..0x82C6E0DC)
	// 82C6E098: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6E09C: 419AFFF4  beq cr6, 0x82c6e090
	if ctx.cr[6].eq {
	pc = 0x82C6E090; continue 'dispatch;
	}
	// 82C6E0A0: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82C6E0A4: 409AFE68  bne cr6, 0x82c6df0c
	if !ctx.cr[6].eq {
	pc = 0x82C6DF0C; continue 'dispatch;
	}
	// 82C6E0A8: 39610120  addi r11, r1, 0x120
	ctx.r[11].s64 = ctx.r[1].s64 + 288;
	// 82C6E0AC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C6E0B0: 419A0064  beq cr6, 0x82c6e114
	if ctx.cr[6].eq {
	pc = 0x82C6E114; continue 'dispatch;
	}
	// 82C6E0B4: 9BFD0000  stb r31, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u8 ) };
	// 82C6E0B8: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 82C6E0BC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82C6E0C0: 4B50CFE9  bl 0x8217b0a8
	ctx.lr = 0x82C6E0C4;
	sub_8217B0A8(ctx, base);
	// 82C6E0C4: 8176000C  lwz r11, 0xc(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6E0C8: 3BD60008  addi r30, r22, 8
	ctx.r[30].s64 = ctx.r[22].s64 + 8;
	// 82C6E0CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6E0D0: 409A000C  bne cr6, 0x82c6e0dc
	if !ctx.cr[6].eq {
	pc = 0x82C6E0DC; continue 'dispatch;
	}
	// 82C6E0D4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82C6E0D8: 48000010  b 0x82c6e0e8
	pc = 0x82C6E0E8; continue 'dispatch;
            }
            0x82C6E0DC => {
    //   block [0x82C6E0DC..0x82C6E0E8)
	// 82C6E0DC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E0E0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6E0E4: 7D69ABD6  divw r11, r9, r21
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[21].s32;
	pc = 0x82C6E0E8; continue 'dispatch;
            }
            0x82C6E0E8 => {
    //   block [0x82C6E0E8..0x82C6E114)
	// 82C6E0E8: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 82C6E0EC: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82C6E0F0: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82C6E0F4: 4BFFCF45  bl 0x82c6b038
	ctx.lr = 0x82C6E0F8;
	sub_82C6B038(ctx, base);
	// 82C6E0F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6E0FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6E100: 4B706C79  bl 0x82374d78
	ctx.lr = 0x82C6E104;
	sub_82374D78(ctx, base);
	// 82C6E104: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82C6E108: 4B6841B1  bl 0x822f22b8
	ctx.lr = 0x82C6E10C;
	sub_822F22B8(ctx, base);
	// 82C6E10C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82C6E110: 4B6841A9  bl 0x822f22b8
	ctx.lr = 0x82C6E114;
	sub_822F22B8(ctx, base);
	pc = 0x82C6E114; continue 'dispatch;
            }
            0x82C6E114 => {
    //   block [0x82C6E114..0x82C6E150)
	// 82C6E114: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82C6E118: 4B5B1141  bl 0x8221f258
	ctx.lr = 0x82C6E11C;
	sub_8221F258(ctx, base);
	// 82C6E11C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C6E120: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C6E124: 419A002C  beq cr6, 0x82c6e150
	if ctx.cr[6].eq {
	pc = 0x82C6E150; continue 'dispatch;
	}
	// 82C6E128: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82C6E12C: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 82C6E130: 4B6877C9  bl 0x822f58f8
	ctx.lr = 0x82C6E134;
	sub_822F58F8(ctx, base);
	// 82C6E134: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C6E138: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 82C6E13C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6E140: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82C6E144: 4BFFF845  bl 0x82c6d988
	ctx.lr = 0x82C6E148;
	sub_82C6D988(ctx, base);
	// 82C6E148: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6E14C: 48000008  b 0x82c6e154
	pc = 0x82C6E154; continue 'dispatch;
            }
            0x82C6E150 => {
    //   block [0x82C6E150..0x82C6E154)
	// 82C6E150: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	pc = 0x82C6E154; continue 'dispatch;
            }
            0x82C6E154 => {
    //   block [0x82C6E154..0x82C6E15C)
	// 82C6E154: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 82C6E158: 4BFFC6A9  bl 0x82c6a800
	ctx.lr = 0x82C6E15C;
	sub_82C6A800(ctx, base);
	pc = 0x82C6E15C; continue 'dispatch;
            }
            0x82C6E15C => {
    //   block [0x82C6E15C..0x82C6E180)
	// 82C6E15C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82C6E160: 4BBD7651  bl 0x828457b0
	ctx.lr = 0x82C6E164;
	sub_828457B0(ctx, base);
	// 82C6E164: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6E168: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6E16C: 419A0014  beq cr6, 0x82c6e180
	if ctx.cr[6].eq {
	pc = 0x82C6E180; continue 'dispatch;
	}
	// 82C6E170: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E174: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E178: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6E17C: 4E800421  bctrl
	ctx.lr = 0x82C6E180;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6E180 => {
    //   block [0x82C6E180..0x82C6E19C)
	// 82C6E180: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C6E184: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6E188: 419A0014  beq cr6, 0x82c6e19c
	if ctx.cr[6].eq {
	pc = 0x82C6E19C; continue 'dispatch;
	}
	// 82C6E18C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E190: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E194: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6E198: 4E800421  bctrl
	ctx.lr = 0x82C6E19C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6E19C => {
    //   block [0x82C6E19C..0x82C6E1AC)
	// 82C6E19C: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 82C6E1A0: 419A0018  beq cr6, 0x82c6e1b8
	if ctx.cr[6].eq {
	pc = 0x82C6E1B8; continue 'dispatch;
	}
	// 82C6E1A4: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E1A8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	pc = 0x82C6E1AC; continue 'dispatch;
            }
            0x82C6E1AC => {
    //   block [0x82C6E1AC..0x82C6E1B8)
	// 82C6E1AC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E1B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6E1B4: 4E800421  bctrl
	ctx.lr = 0x82C6E1B8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6E1B8 => {
    //   block [0x82C6E1B8..0x82C6E1C4)
	// 82C6E1B8: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 82C6E1BC: 382119B0  addi r1, r1, 0x19b0
	ctx.r[1].s64 = ctx.r[1].s64 + 6576;
	// 82C6E1C0: 4803B270  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E1C8 size=192
    let mut pc: u32 = 0x82C6E1C8;
    'dispatch: loop {
        match pc {
            0x82C6E1C8 => {
    //   block [0x82C6E1C8..0x82C6E204)
	// 82C6E1C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E1CC: 4803B241  bl 0x82ca940c
	ctx.lr = 0x82C6E1D0;
	sub_82CA93D0(ctx, base);
	// 82C6E1D0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E1D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C6E1D8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C6E1DC: 897E0010  lbz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C6E1E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6E1E4: 409A0094  bne cr6, 0x82c6e278
	if !ctx.cr[6].eq {
	pc = 0x82C6E278; continue 'dispatch;
	}
	// 82C6E1E8: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6E1EC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C6E1F0: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6E1F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6E1F8: 409A000C  bne cr6, 0x82c6e204
	if !ctx.cr[6].eq {
	pc = 0x82C6E204; continue 'dispatch;
	}
	// 82C6E1FC: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 82C6E200: 48000014  b 0x82c6e214
	pc = 0x82C6E214; continue 'dispatch;
            }
            0x82C6E204 => {
    //   block [0x82C6E204..0x82C6E214)
	// 82C6E204: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C6E208: 39000024  li r8, 0x24
	ctx.r[8].s64 = 36;
	// 82C6E20C: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C6E210: 7FE743D6  divw r31, r7, r8
	ctx.r[31].s32 = ctx.r[7].s32 / ctx.r[8].s32;
	pc = 0x82C6E214; continue 'dispatch;
            }
            0x82C6E214 => {
    //   block [0x82C6E214..0x82C6E26C)
	// 82C6E214: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 82C6E218: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82C6E21C: B1210054  sth r9, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u16 ) };
	// 82C6E220: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82C6E224: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82C6E228: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6E22C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C6E230: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6E234: 4B688465  bl 0x822f6698
	ctx.lr = 0x82C6E238;
	sub_822F6698(ctx, base);
	// 82C6E238: 813D001C  lwz r9, 0x1c(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C6E23C: 395F0001  addi r10, r31, 1
	ctx.r[10].s64 = ctx.r[31].s64 + 1;
	// 82C6E240: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6E244: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C6E248: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82C6E24C: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82C6E250: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 82C6E254: 4B706B25  bl 0x82374d78
	ctx.lr = 0x82C6E258;
	sub_82374D78(ctx, base);
	// 82C6E258: 81010068  lwz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C6E25C: 2B080008  cmplwi cr6, r8, 8
	ctx.cr[6].compare_u32(ctx.r[8].u32, 8 as u32, &mut ctx.xer);
	// 82C6E260: 4198000C  blt cr6, 0x82c6e26c
	if ctx.cr[6].lt {
	pc = 0x82C6E26C; continue 'dispatch;
	}
	// 82C6E264: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C6E268: 4BBD7549  bl 0x828457b0
	ctx.lr = 0x82C6E26C;
	sub_828457B0(ctx, base);
	pc = 0x82C6E26C; continue 'dispatch;
            }
            0x82C6E26C => {
    //   block [0x82C6E26C..0x82C6E278)
	// 82C6E26C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C6E270: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C6E274: 4803B1E8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C6E278 => {
    //   block [0x82C6E278..0x82C6E288)
	// 82C6E278: 3C608000  lis r3, -0x8000
	ctx.r[3].s64 = -2147483648;
	// 82C6E27C: 60634005  ori r3, r3, 0x4005
	ctx.r[3].u64 = ctx.r[3].u64 | 16389;
	// 82C6E280: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C6E284: 4803B1D8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E288 size=64
    let mut pc: u32 = 0x82C6E288;
    'dispatch: loop {
        match pc {
            0x82C6E288 => {
    //   block [0x82C6E288..0x82C6E2C8)
	// 82C6E288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E28C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6E290: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E294: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6E298: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6E29C: 4B58089D  bl 0x821eeb38
	ctx.lr = 0x82C6E2A0;
	sub_821EEB38(ctx, base);
	// 82C6E2A0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C6E2A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6E2A8: 386B5998  addi r3, r11, 0x5998
	ctx.r[3].s64 = ctx.r[11].s64 + 22936;
	// 82C6E2AC: 4B5F6EF5  bl 0x822651a0
	ctx.lr = 0x82C6E2B0;
	sub_822651A0(ctx, base);
	// 82C6E2B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6E2B4: 4B5A6B25  bl 0x82214dd8
	ctx.lr = 0x82C6E2B8;
	sub_82214DD8(ctx, base);
	// 82C6E2B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6E2BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E2C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E2C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E2C8 size=64
    let mut pc: u32 = 0x82C6E2C8;
    'dispatch: loop {
        match pc {
            0x82C6E2C8 => {
    //   block [0x82C6E2C8..0x82C6E308)
	// 82C6E2C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E2CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6E2D0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E2D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6E2D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6E2DC: 4B58085D  bl 0x821eeb38
	ctx.lr = 0x82C6E2E0;
	sub_821EEB38(ctx, base);
	// 82C6E2E0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C6E2E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6E2E8: 386B5994  addi r3, r11, 0x5994
	ctx.r[3].s64 = ctx.r[11].s64 + 22932;
	// 82C6E2EC: 4B5F6EB5  bl 0x822651a0
	ctx.lr = 0x82C6E2F0;
	sub_822651A0(ctx, base);
	// 82C6E2F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6E2F4: 4B5A6AE5  bl 0x82214dd8
	ctx.lr = 0x82C6E2F8;
	sub_82214DD8(ctx, base);
	// 82C6E2F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6E2FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E300: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E304: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E308 size=52
    let mut pc: u32 = 0x82C6E308;
    'dispatch: loop {
        match pc {
            0x82C6E308 => {
    //   block [0x82C6E308..0x82C6E33C)
	// 82C6E308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E30C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6E310: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6E314: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E318: 38840004  addi r4, r4, 4
	ctx.r[4].s64 = ctx.r[4].s64 + 4;
	// 82C6E31C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6E320: 4B581F21  bl 0x821f0240
	ctx.lr = 0x82C6E324;
	sub_821F0240(ctx, base);
	// 82C6E324: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6E328: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6E32C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E330: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E334: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6E338: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E340 size=64
    let mut pc: u32 = 0x82C6E340;
    'dispatch: loop {
        match pc {
            0x82C6E340 => {
    //   block [0x82C6E340..0x82C6E380)
	// 82C6E340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E344: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6E348: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6E34C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E350: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6E354: 4BEDF50D  bl 0x82b4d860
	ctx.lr = 0x82C6E358;
	sub_82B4D860(ctx, base);
	// 82C6E358: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82C6E35C: 4BEDF505  bl 0x82b4d860
	ctx.lr = 0x82C6E360;
	sub_82B4D860(ctx, base);
	// 82C6E360: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82C6E364: 4BEDF4FD  bl 0x82b4d860
	ctx.lr = 0x82C6E368;
	sub_82B4D860(ctx, base);
	// 82C6E368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6E36C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6E370: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E374: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E378: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6E37C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E380 size=76
    let mut pc: u32 = 0x82C6E380;
    'dispatch: loop {
        match pc {
            0x82C6E380 => {
    //   block [0x82C6E380..0x82C6E3CC)
	// 82C6E380: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E384: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6E388: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6E38C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E390: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6E394: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C6E398: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C6E39C: 394BDF08  addi r10, r11, -0x20f8
	ctx.r[10].s64 = ctx.r[11].s64 + -8440;
	// 82C6E3A0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C6E3A4: 4B58945D  bl 0x821f7800
	ctx.lr = 0x82C6E3A8;
	sub_821F7800(ctx, base);
	// 82C6E3A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6E3AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6E3B0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C6E3B4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C6E3B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6E3BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E3C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E3C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6E3C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E3D0 size=116
    let mut pc: u32 = 0x82C6E3D0;
    'dispatch: loop {
        match pc {
            0x82C6E3D0 => {
    //   block [0x82C6E3D0..0x82C6E428)
	// 82C6E3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E3D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6E3D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6E3DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6E3E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E3E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6E3E8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C6E3EC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C6E3F0: 394BDF08  addi r10, r11, -0x20f8
	ctx.r[10].s64 = ctx.r[11].s64 + -8440;
	// 82C6E3F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C6E3F8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C6E3FC: 4B589405  bl 0x821f7800
	ctx.lr = 0x82C6E400;
	sub_821F7800(ctx, base);
	// 82C6E400: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C6E404: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C6E408: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C6E40C: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82C6E410: 419A0018  beq cr6, 0x82c6e428
	if ctx.cr[6].eq {
	pc = 0x82C6E428; continue 'dispatch;
	}
	// 82C6E414: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E418: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C6E41C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C6E420: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6E424: 4E800421  bctrl
	ctx.lr = 0x82C6E428;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6E428 => {
    //   block [0x82C6E428..0x82C6E444)
	// 82C6E428: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6E42C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6E430: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E434: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E438: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6E43C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6E440: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E448 size=128
    let mut pc: u32 = 0x82C6E448;
    'dispatch: loop {
        match pc {
            0x82C6E448 => {
    //   block [0x82C6E448..0x82C6E484)
	// 82C6E448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E44C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6E450: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6E454: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E458: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6E45C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C6E460: 394BDF08  addi r10, r11, -0x20f8
	ctx.r[10].s64 = ctx.r[11].s64 + -8440;
	// 82C6E464: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C6E468: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6E46C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6E470: 419A0014  beq cr6, 0x82c6e484
	if ctx.cr[6].eq {
	pc = 0x82C6E484; continue 'dispatch;
	}
	// 82C6E474: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E478: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E47C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6E480: 4E800421  bctrl
	ctx.lr = 0x82C6E484;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6E484 => {
    //   block [0x82C6E484..0x82C6E4A0)
	// 82C6E484: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E488: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6E48C: 419A0014  beq cr6, 0x82c6e4a0
	if ctx.cr[6].eq {
	pc = 0x82C6E4A0; continue 'dispatch;
	}
	// 82C6E490: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E494: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E498: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6E49C: 4E800421  bctrl
	ctx.lr = 0x82C6E4A0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6E4A0 => {
    //   block [0x82C6E4A0..0x82C6E4C8)
	// 82C6E4A0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C6E4A4: 4B5A6935  bl 0x82214dd8
	ctx.lr = 0x82C6E4A8;
	sub_82214DD8(ctx, base);
	// 82C6E4A8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82C6E4AC: 394B4928  addi r10, r11, 0x4928
	ctx.r[10].s64 = ctx.r[11].s64 + 18728;
	// 82C6E4B0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C6E4B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6E4B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E4BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E4C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6E4C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E4C8 size=76
    let mut pc: u32 = 0x82C6E4C8;
    'dispatch: loop {
        match pc {
            0x82C6E4C8 => {
    //   block [0x82C6E4C8..0x82C6E500)
	// 82C6E4C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E4CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6E4D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6E4D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E4D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6E4DC: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6E4E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6E4E4: 419A001C  beq cr6, 0x82c6e500
	if ctx.cr[6].eq {
	pc = 0x82C6E500; continue 'dispatch;
	}
	// 82C6E4E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E4EC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E4F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6E4F4: 4E800421  bctrl
	ctx.lr = 0x82C6E4F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6E4F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C6E4FC: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
            }
            0x82C6E500 => {
    //   block [0x82C6E500..0x82C6E514)
	// 82C6E500: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6E504: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E508: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E50C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6E510: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E518 size=152
    let mut pc: u32 = 0x82C6E518;
    'dispatch: loop {
        match pc {
            0x82C6E518 => {
    //   block [0x82C6E518..0x82C6E578)
	// 82C6E518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E51C: 4803AEF1  bl 0x82ca940c
	ctx.lr = 0x82C6E520;
	sub_82CA93D0(ctx, base);
	// 82C6E520: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E524: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6E528: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C6E52C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C6E530: 3BE3000C  addi r31, r3, 0xc
	ctx.r[31].s64 = ctx.r[3].s64 + 12;
	// 82C6E534: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6E538: 409A0040  bne cr6, 0x82c6e578
	if !ctx.cr[6].eq {
	pc = 0x82C6E578; continue 'dispatch;
	}
	// 82C6E53C: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E540: 3CC00001  lis r6, 1
	ctx.r[6].s64 = 65536;
	// 82C6E544: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6E548: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6E54C: 4BEDFEA5  bl 0x82b4e3f0
	ctx.lr = 0x82C6E550;
	sub_82B4E3F0(ctx, base);
	// 82C6E550: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6E554: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6E558: 4B8BC4C1  bl 0x8252aa18
	ctx.lr = 0x82C6E55C;
	sub_8252AA18(ctx, base);
	// 82C6E55C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6E560: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6E564: 419A0014  beq cr6, 0x82c6e578
	if ctx.cr[6].eq {
	pc = 0x82C6E578; continue 'dispatch;
	}
	// 82C6E568: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E56C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E570: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6E574: 4E800421  bctrl
	ctx.lr = 0x82C6E578;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6E578 => {
    //   block [0x82C6E578..0x82C6E5A8)
	// 82C6E578: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E57C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C6E580: 419A0028  beq cr6, 0x82c6e5a8
	if ctx.cr[6].eq {
	pc = 0x82C6E5A8; continue 'dispatch;
	}
	// 82C6E584: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6E588: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82C6E58C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C6E590: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82C6E594: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82C6E598: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E59C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6E5A0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C6E5A4: 4E800421  bctrl
	ctx.lr = 0x82C6E5A8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6E5A8 => {
    //   block [0x82C6E5A8..0x82C6E5B0)
	// 82C6E5A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6E5AC: 4803AEB0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E5B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E5B0 size=152
    let mut pc: u32 = 0x82C6E5B0;
    'dispatch: loop {
        match pc {
            0x82C6E5B0 => {
    //   block [0x82C6E5B0..0x82C6E610)
	// 82C6E5B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E5B4: 4803AE59  bl 0x82ca940c
	ctx.lr = 0x82C6E5B8;
	sub_82CA93D0(ctx, base);
	// 82C6E5B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E5BC: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6E5C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C6E5C4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C6E5C8: 3BE3000C  addi r31, r3, 0xc
	ctx.r[31].s64 = ctx.r[3].s64 + 12;
	// 82C6E5CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6E5D0: 409A0040  bne cr6, 0x82c6e610
	if !ctx.cr[6].eq {
	pc = 0x82C6E610; continue 'dispatch;
	}
	// 82C6E5D4: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E5D8: 3CC00001  lis r6, 1
	ctx.r[6].s64 = 65536;
	// 82C6E5DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6E5E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6E5E4: 4BEDFE0D  bl 0x82b4e3f0
	ctx.lr = 0x82C6E5E8;
	sub_82B4E3F0(ctx, base);
	// 82C6E5E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6E5EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6E5F0: 4B8BC429  bl 0x8252aa18
	ctx.lr = 0x82C6E5F4;
	sub_8252AA18(ctx, base);
	// 82C6E5F4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6E5F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6E5FC: 419A0014  beq cr6, 0x82c6e610
	if ctx.cr[6].eq {
	pc = 0x82C6E610; continue 'dispatch;
	}
	// 82C6E600: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E604: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E608: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6E60C: 4E800421  bctrl
	ctx.lr = 0x82C6E610;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6E610 => {
    //   block [0x82C6E610..0x82C6E640)
	// 82C6E610: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E614: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C6E618: 419A0028  beq cr6, 0x82c6e640
	if ctx.cr[6].eq {
	pc = 0x82C6E640; continue 'dispatch;
	}
	// 82C6E61C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6E620: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82C6E624: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C6E628: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82C6E62C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82C6E630: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E634: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C6E638: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C6E63C: 4E800421  bctrl
	ctx.lr = 0x82C6E640;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6E640 => {
    //   block [0x82C6E640..0x82C6E648)
	// 82C6E640: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6E644: 4803AE18  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E648 size=160
    let mut pc: u32 = 0x82C6E648;
    'dispatch: loop {
        match pc {
            0x82C6E648 => {
    //   block [0x82C6E648..0x82C6E6AC)
	// 82C6E648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E64C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6E650: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6E654: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6E658: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E65C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6E660: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C6E664: 3BE3000C  addi r31, r3, 0xc
	ctx.r[31].s64 = ctx.r[3].s64 + 12;
	// 82C6E668: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6E66C: 409A0040  bne cr6, 0x82c6e6ac
	if !ctx.cr[6].eq {
	pc = 0x82C6E6AC; continue 'dispatch;
	}
	// 82C6E670: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E674: 3CC00001  lis r6, 1
	ctx.r[6].s64 = 65536;
	// 82C6E678: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6E67C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6E680: 4BEDFD71  bl 0x82b4e3f0
	ctx.lr = 0x82C6E684;
	sub_82B4E3F0(ctx, base);
	// 82C6E684: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6E688: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6E68C: 4B8BC38D  bl 0x8252aa18
	ctx.lr = 0x82C6E690;
	sub_8252AA18(ctx, base);
	// 82C6E690: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6E694: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6E698: 419A0014  beq cr6, 0x82c6e6ac
	if ctx.cr[6].eq {
	pc = 0x82C6E6AC; continue 'dispatch;
	}
	// 82C6E69C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E6A0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E6A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6E6A8: 4E800421  bctrl
	ctx.lr = 0x82C6E6AC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6E6AC => {
    //   block [0x82C6E6AC..0x82C6E6D0)
	// 82C6E6AC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E6B0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C6E6B4: 419A001C  beq cr6, 0x82c6e6d0
	if ctx.cr[6].eq {
	pc = 0x82C6E6D0; continue 'dispatch;
	}
	// 82C6E6B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E6BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6E6C0: 7FC407B4  extsw r4, r30
	ctx.r[4].s64 = ctx.r[30].s32 as i64;
	// 82C6E6C4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6E6C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6E6CC: 4E800421  bctrl
	ctx.lr = 0x82C6E6D0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6E6D0 => {
    //   block [0x82C6E6D0..0x82C6E6E8)
	// 82C6E6D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6E6D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E6D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E6DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6E6E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6E6E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E6E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E6E8 size=160
    let mut pc: u32 = 0x82C6E6E8;
    'dispatch: loop {
        match pc {
            0x82C6E6E8 => {
    //   block [0x82C6E6E8..0x82C6E74C)
	// 82C6E6E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E6EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6E6F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6E6F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6E6F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E6FC: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6E700: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C6E704: 3BE3000C  addi r31, r3, 0xc
	ctx.r[31].s64 = ctx.r[3].s64 + 12;
	// 82C6E708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6E70C: 409A0040  bne cr6, 0x82c6e74c
	if !ctx.cr[6].eq {
	pc = 0x82C6E74C; continue 'dispatch;
	}
	// 82C6E710: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E714: 3CC00001  lis r6, 1
	ctx.r[6].s64 = 65536;
	// 82C6E718: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C6E71C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6E720: 4BEDFCD1  bl 0x82b4e3f0
	ctx.lr = 0x82C6E724;
	sub_82B4E3F0(ctx, base);
	// 82C6E724: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6E728: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6E72C: 4B8BC2ED  bl 0x8252aa18
	ctx.lr = 0x82C6E730;
	sub_8252AA18(ctx, base);
	// 82C6E730: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6E734: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6E738: 419A0014  beq cr6, 0x82c6e74c
	if ctx.cr[6].eq {
	pc = 0x82C6E74C; continue 'dispatch;
	}
	// 82C6E73C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E740: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E744: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6E748: 4E800421  bctrl
	ctx.lr = 0x82C6E74C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6E74C => {
    //   block [0x82C6E74C..0x82C6E770)
	// 82C6E74C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E750: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C6E754: 419A001C  beq cr6, 0x82c6e770
	if ctx.cr[6].eq {
	pc = 0x82C6E770; continue 'dispatch;
	}
	// 82C6E758: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E75C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C6E760: 7FC407B4  extsw r4, r30
	ctx.r[4].s64 = ctx.r[30].s32 as i64;
	// 82C6E764: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6E768: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6E76C: 4E800421  bctrl
	ctx.lr = 0x82C6E770;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6E770 => {
    //   block [0x82C6E770..0x82C6E788)
	// 82C6E770: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6E774: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E778: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E77C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6E780: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6E784: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E788 size=80
    let mut pc: u32 = 0x82C6E788;
    'dispatch: loop {
        match pc {
            0x82C6E788 => {
    //   block [0x82C6E788..0x82C6E7C4)
	// 82C6E788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E78C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6E790: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E794: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6E798: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C6E79C: 419A0028  beq cr6, 0x82c6e7c4
	if ctx.cr[6].eq {
	pc = 0x82C6E7C4; continue 'dispatch;
	}
	// 82C6E7A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E7A4: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6E7A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6E7AC: 4E800421  bctrl
	ctx.lr = 0x82C6E7B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6E7B0: 5463003E  slwi r3, r3, 0
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C6E7B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6E7B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E7BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E7C0: 4E800020  blr
	return;
            }
            0x82C6E7C4 => {
    //   block [0x82C6E7C4..0x82C6E7D8)
	// 82C6E7C4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C6E7C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6E7CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E7D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E7D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E7D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E7D8 size=80
    let mut pc: u32 = 0x82C6E7D8;
    'dispatch: loop {
        match pc {
            0x82C6E7D8 => {
    //   block [0x82C6E7D8..0x82C6E814)
	// 82C6E7D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E7DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6E7E0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E7E4: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E7E8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C6E7EC: 419A0028  beq cr6, 0x82c6e814
	if ctx.cr[6].eq {
	pc = 0x82C6E814; continue 'dispatch;
	}
	// 82C6E7F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E7F4: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6E7F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6E7FC: 4E800421  bctrl
	ctx.lr = 0x82C6E800;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6E800: 5463003E  slwi r3, r3, 0
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C6E804: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6E808: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E80C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E810: 4E800020  blr
	return;
            }
            0x82C6E814 => {
    //   block [0x82C6E814..0x82C6E828)
	// 82C6E814: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C6E818: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6E81C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E820: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E824: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C6E828 size=20
    let mut pc: u32 = 0x82C6E828;
    'dispatch: loop {
        match pc {
            0x82C6E828 => {
    //   block [0x82C6E828..0x82C6E83C)
	// 82C6E828: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E82C: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82C6E830: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82C6E834: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 82C6E838: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E840 size=72
    let mut pc: u32 = 0x82C6E840;
    'dispatch: loop {
        match pc {
            0x82C6E840 => {
    //   block [0x82C6E840..0x82C6E888)
	// 82C6E840: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E844: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6E848: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6E84C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E850: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6E854: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C6E858: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C6E85C: 394BDF48  addi r10, r11, -0x20b8
	ctx.r[10].s64 = ctx.r[11].s64 + -8376;
	// 82C6E860: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C6E864: 4B588F9D  bl 0x821f7800
	ctx.lr = 0x82C6E868;
	sub_821F7800(ctx, base);
	// 82C6E868: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C6E86C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6E870: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C6E874: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6E878: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E87C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E880: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6E884: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E888 size=104
    let mut pc: u32 = 0x82C6E888;
    'dispatch: loop {
        match pc {
            0x82C6E888 => {
    //   block [0x82C6E888..0x82C6E8D4)
	// 82C6E888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E88C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6E890: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6E894: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E898: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6E89C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E8A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6E8A4: 419A0030  beq cr6, 0x82c6e8d4
	if ctx.cr[6].eq {
	pc = 0x82C6E8D4; continue 'dispatch;
	}
	// 82C6E8A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E8AC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E8B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6E8B4: 4E800421  bctrl
	ctx.lr = 0x82C6E8B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6E8B8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C6E8BC: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C6E8C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6E8C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E8C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E8CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6E8D0: 4E800020  blr
	return;
            }
            0x82C6E8D4 => {
    //   block [0x82C6E8D4..0x82C6E8F0)
	// 82C6E8D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6E8D8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C6E8DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6E8E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E8E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E8E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6E8EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E8F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E8F0 size=132
    let mut pc: u32 = 0x82C6E8F0;
    'dispatch: loop {
        match pc {
            0x82C6E8F0 => {
    //   block [0x82C6E8F0..0x82C6E95C)
	// 82C6E8F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E8F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6E8F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6E8FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6E900: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E904: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C6E908: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6E90C: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C6E910: 4099004C  ble cr6, 0x82c6e95c
	if !ctx.cr[6].gt {
	pc = 0x82C6E95C; continue 'dispatch;
	}
	// 82C6E914: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E918: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C6E91C: 419A0040  beq cr6, 0x82c6e95c
	if ctx.cr[6].eq {
	pc = 0x82C6E95C; continue 'dispatch;
	}
	// 82C6E920: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6E924: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82C6E928: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6E92C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82C6E930: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C6E934: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C6E938: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E93C: 7D4507B4  extsw r5, r10
	ctx.r[5].s64 = ctx.r[10].s32 as i64;
	// 82C6E940: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C6E944: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6E948: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C6E94C: 4E800421  bctrl
	ctx.lr = 0x82C6E950;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6E950: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6E954: 7CFE5A14  add r7, r30, r11
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82C6E958: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
            }
            0x82C6E95C => {
    //   block [0x82C6E95C..0x82C6E974)
	// 82C6E95C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6E960: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E964: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E968: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6E96C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6E970: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6E978 size=120
    let mut pc: u32 = 0x82C6E978;
    'dispatch: loop {
        match pc {
            0x82C6E978 => {
    //   block [0x82C6E978..0x82C6E9D8)
	// 82C6E978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6E97C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6E980: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6E984: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6E988: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6E98C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C6E990: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C6E994: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E998: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C6E99C: 419A003C  beq cr6, 0x82c6e9d8
	if ctx.cr[6].eq {
	pc = 0x82C6E9D8; continue 'dispatch;
	}
	// 82C6E9A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C6E9A4: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82C6E9A8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6E9AC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C6E9B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C6E9B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C6E9B8: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6E9BC: 7D4507B4  extsw r5, r10
	ctx.r[5].s64 = ctx.r[10].s32 as i64;
	// 82C6E9C0: 81090014  lwz r8, 0x14(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C6E9C4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C6E9C8: 4E800421  bctrl
	ctx.lr = 0x82C6E9CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6E9CC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6E9D0: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C6E9D4: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
            }
            0x82C6E9D8 => {
    //   block [0x82C6E9D8..0x82C6E9F0)
	// 82C6E9D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6E9DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6E9E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6E9E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6E9E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6E9EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6E9F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C6E9F0 size=20
    let mut pc: u32 = 0x82C6E9F0;
    'dispatch: loop {
        match pc {
            0x82C6E9F0 => {
    //   block [0x82C6E9F0..0x82C6EA04)
	// 82C6E9F0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6E9F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C6E9F8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C6E9FC: 9083000C  stw r4, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82C6EA00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6EA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C6EA08 size=28
    let mut pc: u32 = 0x82C6EA08;
    'dispatch: loop {
        match pc {
            0x82C6EA08 => {
    //   block [0x82C6EA08..0x82C6EA24)
	// 82C6EA08: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6EA0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C6EA10: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82C6EA14: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6EA18: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 82C6EA1C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C6EA20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6EA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C6EA28 size=20
    let mut pc: u32 = 0x82C6EA28;
    'dispatch: loop {
        match pc {
            0x82C6EA28 => {
    //   block [0x82C6EA28..0x82C6EA3C)
	// 82C6EA28: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6EA2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C6EA30: 419A000C  beq cr6, 0x82c6ea3c
	if ctx.cr[6].eq {
		sub_82C6EA3C(ctx, base);
		return;
	}
	// 82C6EA34: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6EA38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6EA3C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C6EA3C size=8
    let mut pc: u32 = 0x82C6EA3C;
    'dispatch: loop {
        match pc {
            0x82C6EA3C => {
    //   block [0x82C6EA3C..0x82C6EA44)
	// 82C6EA3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C6EA40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6EA48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6EA48 size=52
    let mut pc: u32 = 0x82C6EA48;
    'dispatch: loop {
        match pc {
            0x82C6EA48 => {
    //   block [0x82C6EA48..0x82C6EA7C)
	// 82C6EA48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6EA4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6EA50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6EA54: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6EA58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6EA5C: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C6EA60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6EA64: 4E800421  bctrl
	ctx.lr = 0x82C6EA68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6EA68: 5463003E  slwi r3, r3, 0
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C6EA6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6EA70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6EA74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6EA78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6EA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6EA80 size=84
    let mut pc: u32 = 0x82C6EA80;
    'dispatch: loop {
        match pc {
            0x82C6EA80 => {
    //   block [0x82C6EA80..0x82C6EAAC)
	// 82C6EA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6EA84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6EA88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6EA8C: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6EA90: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C6EA94: 409A0018  bne cr6, 0x82c6eaac
	if !ctx.cr[6].eq {
	pc = 0x82C6EAAC; continue 'dispatch;
	}
	// 82C6EA98: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C6EA9C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6EAA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6EAA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6EAA8: 4E800020  blr
	return;
            }
            0x82C6EAAC => {
    //   block [0x82C6EAAC..0x82C6EAD4)
	// 82C6EAAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6EAB0: 4BEDCBB9  bl 0x82b4b668
	ctx.lr = 0x82C6EAB4;
	sub_82B4B668(ctx, base);
	// 82C6EAB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6EAB8: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82C6EABC: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82C6EAC0: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 82C6EAC4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6EAC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6EACC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6EAD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6EAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6EAD8 size=72
    let mut pc: u32 = 0x82C6EAD8;
    'dispatch: loop {
        match pc {
            0x82C6EAD8 => {
    //   block [0x82C6EAD8..0x82C6EB0C)
	// 82C6EAD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6EADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6EAE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6EAE4: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6EAE8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82C6EAEC: 419A0020  beq cr6, 0x82c6eb0c
	if ctx.cr[6].eq {
	pc = 0x82C6EB0C; continue 'dispatch;
	}
	// 82C6EAF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6EAF4: 4BEDCB75  bl 0x82b4b668
	ctx.lr = 0x82C6EAF8;
	sub_82B4B668(ctx, base);
	// 82C6EAF8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6EAFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6EB00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6EB04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6EB08: 4E800020  blr
	return;
            }
            0x82C6EB0C => {
    //   block [0x82C6EB0C..0x82C6EB20)
	// 82C6EB0C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C6EB10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C6EB14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6EB18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6EB1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6EB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6EB20 size=136
    let mut pc: u32 = 0x82C6EB20;
    'dispatch: loop {
        match pc {
            0x82C6EB20 => {
    //   block [0x82C6EB20..0x82C6EB78)
	// 82C6EB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6EB24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C6EB28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C6EB2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C6EB30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6EB34: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6EB38: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C6EB3C: 3BE30008  addi r31, r3, 8
	ctx.r[31].s64 = ctx.r[3].s64 + 8;
	// 82C6EB40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6EB44: 409A0034  bne cr6, 0x82c6eb78
	if !ctx.cr[6].eq {
	pc = 0x82C6EB78; continue 'dispatch;
	}
	// 82C6EB48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6EB4C: 4BED959D  bl 0x82b480e8
	ctx.lr = 0x82C6EB50;
	sub_82B480E8(ctx, base);
	// 82C6EB50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6EB54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6EB58: 4B8BBEC1  bl 0x8252aa18
	ctx.lr = 0x82C6EB5C;
	sub_8252AA18(ctx, base);
	// 82C6EB5C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6EB60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6EB64: 419A0014  beq cr6, 0x82c6eb78
	if ctx.cr[6].eq {
	pc = 0x82C6EB78; continue 'dispatch;
	}
	// 82C6EB68: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6EB6C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6EB70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6EB74: 4E800421  bctrl
	ctx.lr = 0x82C6EB78;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6EB78 => {
    //   block [0x82C6EB78..0x82C6EBA8)
	// 82C6EB78: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6EB7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C6EB80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6EB84: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C6EB88: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6EB8C: 4E800421  bctrl
	ctx.lr = 0x82C6EB90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6EB90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C6EB94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C6EB98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C6EB9C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C6EBA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C6EBA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C6EBA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C6EBA8 size=120
    let mut pc: u32 = 0x82C6EBA8;
    'dispatch: loop {
        match pc {
            0x82C6EBA8 => {
    //   block [0x82C6EBA8..0x82C6EBFC)
	// 82C6EBA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C6EBAC: 4803A861  bl 0x82ca940c
	ctx.lr = 0x82C6EBB0;
	sub_82CA93D0(ctx, base);
	// 82C6EBB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C6EBB4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6EBB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C6EBBC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C6EBC0: 3BE30008  addi r31, r3, 8
	ctx.r[31].s64 = ctx.r[3].s64 + 8;
	// 82C6EBC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C6EBC8: 409A0034  bne cr6, 0x82c6ebfc
	if !ctx.cr[6].eq {
	pc = 0x82C6EBFC; continue 'dispatch;
	}
	// 82C6EBCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C6EBD0: 4BED9519  bl 0x82b480e8
	ctx.lr = 0x82C6EBD4;
	sub_82B480E8(ctx, base);
	// 82C6EBD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C6EBD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C6EBDC: 4B8BBE3D  bl 0x8252aa18
	ctx.lr = 0x82C6EBE0;
	sub_8252AA18(ctx, base);
	// 82C6EBE0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C6EBE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C6EBE8: 419A0014  beq cr6, 0x82c6ebfc
	if ctx.cr[6].eq {
	pc = 0x82C6EBFC; continue 'dispatch;
	}
	// 82C6EBEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6EBF0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C6EBF4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6EBF8: 4E800421  bctrl
	ctx.lr = 0x82C6EBFC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C6EBFC => {
    //   block [0x82C6EBFC..0x82C6EC20)
	// 82C6EBFC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6EC00: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C6EC04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C6EC08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C6EC0C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C6EC10: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C6EC14: 4E800421  bctrl
	ctx.lr = 0x82C6EC18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C6EC18: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C6EC1C: 4803A840  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


