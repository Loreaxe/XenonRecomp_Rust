pub fn sub_82A0F468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0F468 size=140
    let mut pc: u32 = 0x82A0F468;
    'dispatch: loop {
        match pc {
            0x82A0F468 => {
    //   block [0x82A0F468..0x82A0F48C)
	// 82A0F468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0F46C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A0F470: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0F474: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F478: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82A0F47C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A0F480: 409A000C  bne cr6, 0x82a0f48c
	if !ctx.cr[6].eq {
	pc = 0x82A0F48C; continue 'dispatch;
	}
	// 82A0F484: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A0F488: 48000010  b 0x82a0f498
	pc = 0x82A0F498; continue 'dispatch;
            }
            0x82A0F48C => {
    //   block [0x82A0F48C..0x82A0F498)
	// 82A0F48C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0F490: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A0F494: 7D291670  srawi r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x82A0F498; continue 'dispatch;
            }
            0x82A0F498 => {
    //   block [0x82A0F498..0x82A0F4CC)
	// 82A0F498: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0F49C: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A0F4A0: 7D481670  srawi r8, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 82A0F4A4: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A0F4A8: 40980024  bge cr6, 0x82a0f4cc
	if !ctx.cr[6].lt {
	pc = 0x82A0F4CC; continue 'dispatch;
	}
	// 82A0F4AC: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 82A0F4B0: C0060000  lfs f0, 0(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A0F4B4: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A0F4B8: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0F4BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A0F4C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0F4C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0F4C8: 4E800020  blr
	return;
            }
            0x82A0F4CC => {
    //   block [0x82A0F4CC..0x82A0F4F4)
	// 82A0F4CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A0F4D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0F4D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A0F4D8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A0F4DC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0F4E0: 48000019  bl 0x82a0f4f8
	ctx.lr = 0x82A0F4E4;
	sub_82A0F4F8(ctx, base);
	// 82A0F4E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A0F4E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0F4EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A0F4F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0F4F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0F4F8 size=652
    let mut pc: u32 = 0x82A0F4F8;
    'dispatch: loop {
        match pc {
            0x82A0F4F8 => {
    //   block [0x82A0F4F8..0x82A0F52C)
	// 82A0F4F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0F4FC: 48299F05  bl 0x82ca9400
	ctx.lr = 0x82A0F500;
	sub_82CA93D0(ctx, base);
	// 82A0F500: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82A0F504: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0F508: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A0F50C: C3E60000  lfs f31, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A0F510: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82A0F514: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A0F518: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F51C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0F520: 409A000C  bne cr6, 0x82a0f52c
	if !ctx.cr[6].eq {
	pc = 0x82A0F52C; continue 'dispatch;
	}
	// 82A0F524: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A0F528: 48000010  b 0x82a0f538
	pc = 0x82A0F538; continue 'dispatch;
            }
            0x82A0F52C => {
    //   block [0x82A0F52C..0x82A0F538)
	// 82A0F52C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A0F530: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0F534: 7D291670  srawi r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x82A0F538; continue 'dispatch;
            }
            0x82A0F538 => {
    //   block [0x82A0F538..0x82A0F570)
	// 82A0F538: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A0F53C: 419A023C  beq cr6, 0x82a0f778
	if ctx.cr[6].eq {
	pc = 0x82A0F778; continue 'dispatch;
	}
	// 82A0F540: 839F0008  lwz r28, 8(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0F544: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82A0F548: 7D0BE050  subf r8, r11, r28
	ctx.r[8].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 82A0F54C: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82A0F550: 7D0B1670  srawi r11, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 82A0F554: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0F558: 7F07E840  cmplw cr6, r7, r29
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A0F55C: 40980014  bge cr6, 0x82a0f570
	if !ctx.cr[6].lt {
	pc = 0x82A0F570; continue 'dispatch;
	}
	// 82A0F560: 48037F69  bl 0x82a474c8
	ctx.lr = 0x82A0F564;
	sub_82A474C8(ctx, base);
	// 82A0F564: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A0F568: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82A0F56C: 48299EE4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0F570 => {
    //   block [0x82A0F570..0x82A0F594)
	// 82A0F570: 7D0BEA14  add r8, r11, r29
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82A0F574: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A0F578: 409800F0  bge cr6, 0x82a0f668
	if !ctx.cr[6].lt {
	pc = 0x82A0F668; continue 'dispatch;
	}
	// 82A0F57C: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0F580: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A0F584: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A0F588: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A0F58C: 41980008  blt cr6, 0x82a0f594
	if ctx.cr[6].lt {
	pc = 0x82A0F594; continue 'dispatch;
	}
	// 82A0F590: 7F4B4A14  add r26, r11, r9
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A0F594; continue 'dispatch;
            }
            0x82A0F594 => {
    //   block [0x82A0F594..0x82A0F5A0)
	// 82A0F594: 7F1A4040  cmplw cr6, r26, r8
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A0F598: 40980008  bge cr6, 0x82a0f5a0
	if !ctx.cr[6].lt {
	pc = 0x82A0F5A0; continue 'dispatch;
	}
	// 82A0F59C: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	pc = 0x82A0F5A0; continue 'dispatch;
            }
            0x82A0F5A0 => {
    //   block [0x82A0F5A0..0x82A0F5D4)
	// 82A0F5A0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A0F5A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A0F5A8: 48076A71  bl 0x82a86018
	ctx.lr = 0x82A0F5AC;
	sub_82A86018(ctx, base);
	// 82A0F5AC: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F5B0: 836100AC  lwz r27, 0xac(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A0F5B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0F5B8: 7D65D850  subf r11, r5, r27
	ctx.r[11].s64 = ctx.r[27].s64 - ctx.r[5].s64;
	// 82A0F5BC: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0F5C0: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A0F5C4: 7F86F214  add r28, r6, r30
	ctx.r[28].u64 = ctx.r[6].u64 + ctx.r[30].u64;
	// 82A0F5C8: 4182000C  beq 0x82a0f5d4
	if ctx.cr[0].eq {
	pc = 0x82A0F5D4; continue 'dispatch;
	}
	// 82A0F5CC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A0F5D0: 4829AA59  bl 0x82caa028
	ctx.lr = 0x82A0F5D4;
	sub_82CAA028(ctx, base);
	pc = 0x82A0F5D4; continue 'dispatch;
            }
            0x82A0F5D4 => {
    //   block [0x82A0F5D4..0x82A0F5F8)
	// 82A0F5D4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A0F5D8: 419A0020  beq cr6, 0x82a0f5f8
	if ctx.cr[6].eq {
	pc = 0x82A0F5F8; continue 'dispatch;
	}
	// 82A0F5DC: D3FC0000  stfs f31, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A0F5E0: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0F5E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A0F5E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A0F5EC: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 82A0F5F0: 5565003A  rlwinm r5, r11, 0, 0, 0x1d
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A0F5F4: 4829A315  bl 0x82ca9908
	ctx.lr = 0x82A0F5F8;
	sub_82CA9908(ctx, base);
	pc = 0x82A0F5F8; continue 'dispatch;
            }
            0x82A0F5F8 => {
    //   block [0x82A0F5F8..0x82A0F620)
	// 82A0F5F8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0F5FC: 7D5B5850  subf r10, r27, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 82A0F600: 7D4B1671  srawi. r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0F604: 4182001C  beq 0x82a0f620
	if ctx.cr[0].eq {
	pc = 0x82A0F620; continue 'dispatch;
	}
	// 82A0F608: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A0F60C: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0F610: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82A0F614: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A0F618: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82A0F61C: 4829AA0D  bl 0x82caa028
	ctx.lr = 0x82A0F620;
	sub_82CAA028(ctx, base);
	pc = 0x82A0F620; continue 'dispatch;
            }
            0x82A0F620 => {
    //   block [0x82A0F620..0x82A0F640)
	// 82A0F620: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F624: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0F628: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A0F62C: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A0F630: 7D4B1670  srawi r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 82A0F634: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82A0F638: 419A0008  beq cr6, 0x82a0f640
	if ctx.cr[6].eq {
	pc = 0x82A0F640; continue 'dispatch;
	}
	// 82A0F63C: 4B80C6FD  bl 0x8221bd38
	ctx.lr = 0x82A0F640;
	sub_8221BD38(ctx, base);
	pc = 0x82A0F640; continue 'dispatch;
            }
            0x82A0F640 => {
    //   block [0x82A0F640..0x82A0F668)
	// 82A0F640: 574B103A  slwi r11, r26, 2
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0F644: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A0F648: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A0F64C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A0F650: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A0F654: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A0F658: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0F65C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A0F660: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82A0F664: 48299DEC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0F668 => {
    //   block [0x82A0F668..0x82A0F69C)
	// 82A0F668: 83C100AC  lwz r30, 0xac(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A0F66C: 7D7EE050  subf r11, r30, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	// 82A0F670: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82A0F674: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A0F678: 4098008C  bge cr6, 0x82a0f704
	if !ctx.cr[6].lt {
	pc = 0x82A0F704; continue 'dispatch;
	}
	// 82A0F67C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0F680: 419A001C  beq cr6, 0x82a0f69c
	if ctx.cr[6].eq {
	pc = 0x82A0F69C; continue 'dispatch;
	}
	// 82A0F684: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A0F688: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0F68C: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82A0F690: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A0F694: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A0F698: 4829A991  bl 0x82caa028
	ctx.lr = 0x82A0F69C;
	sub_82CAA028(ctx, base);
	pc = 0x82A0F69C; continue 'dispatch;
            }
            0x82A0F69C => {
    //   block [0x82A0F69C..0x82A0F6C8)
	// 82A0F69C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0F6A0: 7D7E2050  subf r11, r30, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 82A0F6A4: 7D6A1670  srawi r10, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82A0F6A8: 7D6AE851  subf. r11, r10, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0F6AC: 4182001C  beq 0x82a0f6c8
	if ctx.cr[0].eq {
	pc = 0x82A0F6C8; continue 'dispatch;
	}
	// 82A0F6B0: D3E40000  stfs f31, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A0F6B4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0F6B8: 38640004  addi r3, r4, 4
	ctx.r[3].s64 = ctx.r[4].s64 + 4;
	// 82A0F6BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A0F6C0: 5565003A  rlwinm r5, r11, 0, 0, 0x1d
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A0F6C4: 4829A245  bl 0x82ca9908
	ctx.lr = 0x82A0F6C8;
	sub_82CA9908(ctx, base);
	pc = 0x82A0F6C8; continue 'dispatch;
            }
            0x82A0F6C8 => {
    //   block [0x82A0F6C8..0x82A0F6E8)
	// 82A0F6C8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0F6CC: 57A9103A  slwi r9, r29, 2
	ctx.r[9].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A0F6D0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82A0F6D4: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A0F6D8: 7D295050  subf r9, r9, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82A0F6DC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A0F6E0: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A0F6E4: 419A0094  beq cr6, 0x82a0f778
	if ctx.cr[6].eq {
	pc = 0x82A0F778; continue 'dispatch;
	}
	pc = 0x82A0F6E8; continue 'dispatch;
            }
            0x82A0F6E8 => {
    //   block [0x82A0F6E8..0x82A0F704)
	// 82A0F6E8: D3EB0000  stfs f31, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A0F6EC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A0F6F0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A0F6F4: 409AFFF4  bne cr6, 0x82a0f6e8
	if !ctx.cr[6].eq {
	pc = 0x82A0F6E8; continue 'dispatch;
	}
	// 82A0F6F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A0F6FC: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82A0F700: 48299D50  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0F704 => {
    //   block [0x82A0F704..0x82A0F730)
	// 82A0F704: 57BB103A  slwi r27, r29, 2
	ctx.r[27].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82A0F708: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A0F70C: 7FBBE050  subf r29, r27, r28
	ctx.r[29].s64 = ctx.r[28].s64 - ctx.r[27].s64;
	// 82A0F710: 7D7DE050  subf r11, r29, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 82A0F714: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0F718: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A0F71C: 7F461A14  add r26, r6, r3
	ctx.r[26].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 82A0F720: 41820010  beq 0x82a0f730
	if ctx.cr[0].eq {
	pc = 0x82A0F730; continue 'dispatch;
	}
	// 82A0F724: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A0F728: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A0F72C: 4829A8FD  bl 0x82caa028
	ctx.lr = 0x82A0F730;
	sub_82CAA028(ctx, base);
	pc = 0x82A0F730; continue 'dispatch;
            }
            0x82A0F730 => {
    //   block [0x82A0F730..0x82A0F758)
	// 82A0F730: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82A0F734: 935F0008  stw r26, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82A0F738: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A0F73C: 4081001C  ble 0x82a0f758
	if !ctx.cr[0].gt {
	pc = 0x82A0F758; continue 'dispatch;
	}
	// 82A0F740: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0F744: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A0F748: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82A0F74C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82A0F750: 7C6BE050  subf r3, r11, r28
	ctx.r[3].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 82A0F754: 4829A8D5  bl 0x82caa028
	ctx.lr = 0x82A0F758;
	sub_82CAA028(ctx, base);
	pc = 0x82A0F758; continue 'dispatch;
            }
            0x82A0F758 => {
    //   block [0x82A0F758..0x82A0F768)
	// 82A0F758: 7D5BF214  add r10, r27, r30
	ctx.r[10].u64 = ctx.r[27].u64 + ctx.r[30].u64;
	// 82A0F75C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82A0F760: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A0F764: 419A0014  beq cr6, 0x82a0f778
	if ctx.cr[6].eq {
	pc = 0x82A0F778; continue 'dispatch;
	}
	pc = 0x82A0F768; continue 'dispatch;
            }
            0x82A0F768 => {
    //   block [0x82A0F768..0x82A0F778)
	// 82A0F768: D3EB0000  stfs f31, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A0F76C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A0F770: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A0F774: 409AFFF4  bne cr6, 0x82a0f768
	if !ctx.cr[6].eq {
	pc = 0x82A0F768; continue 'dispatch;
	}
	pc = 0x82A0F778; continue 'dispatch;
            }
            0x82A0F778 => {
    //   block [0x82A0F778..0x82A0F784)
	// 82A0F778: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A0F77C: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82A0F780: 48299CD0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0F788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0F788 size=464
    let mut pc: u32 = 0x82A0F788;
    'dispatch: loop {
        match pc {
            0x82A0F788 => {
    //   block [0x82A0F788..0x82A0F7C4)
	// 82A0F788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0F78C: 48299C71  bl 0x82ca93fc
	ctx.lr = 0x82A0F790;
	sub_82CA93D0(ctx, base);
	// 82A0F790: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0F794: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A0F798: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82A0F79C: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 82A0F7A0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A0F7A4: FB4100B8  std r26, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[26].u64 ) };
	// 82A0F7A8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A0F7AC: 832100B4  lwz r25, 0xb4(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A0F7B0: 83C100BC  lwz r30, 0xbc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A0F7B4: 7D79F050  subf r11, r25, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[25].s64;
	// 82A0F7B8: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A0F7BC: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82A0F7C0: 409900A0  ble cr6, 0x82a0f860
	if !ctx.cr[6].gt {
	pc = 0x82A0F860; continue 'dispatch;
	}
	pc = 0x82A0F7C4; continue 'dispatch;
            }
            0x82A0F7C4 => {
    //   block [0x82A0F7C4..0x82A0F838)
	// 82A0F7C4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0F7C8: 409900B8  ble cr6, 0x82a0f880
	if !ctx.cr[6].gt {
	pc = 0x82A0F880; continue 'dispatch;
	}
	// 82A0F7CC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A0F7D0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82A0F7D4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A0F7D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A0F7DC: 4800017D  bl 0x82a0f958
	ctx.lr = 0x82A0F7E0;
	sub_82A0F958(ctx, base);
	// 82A0F7E0: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 82A0F7E4: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0F7E8: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82A0F7EC: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0F7F0: 7CE9F050  subf r7, r9, r30
	ctx.r[7].s64 = ctx.r[30].s64 - ctx.r[9].s64;
	// 82A0F7F4: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A0F7F8: 7CD94050  subf r6, r25, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[25].s64;
	// 82A0F7FC: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82A0F800: 54E50038  rlwinm r5, r7, 0, 0, 0x1c
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 82A0F804: 54C40038  rlwinm r4, r6, 0, 0, 0x1c
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 82A0F808: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A0F80C: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82A0F810: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A0F814: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A0F818: 40980020  bge cr6, 0x82a0f838
	if !ctx.cr[6].lt {
	pc = 0x82A0F838; continue 'dispatch;
	}
	// 82A0F81C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A0F820: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0F824: 4BFFFF65  bl 0x82a0f788
	ctx.lr = 0x82A0F828;
	sub_82A0F788(ctx, base);
	// 82A0F828: EB610058  ld r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0F82C: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 82A0F830: 832100B4  lwz r25, 0xb4(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A0F834: 4800001C  b 0x82a0f850
	pc = 0x82A0F850; continue 'dispatch;
            }
            0x82A0F838 => {
    //   block [0x82A0F838..0x82A0F850)
	// 82A0F838: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A0F83C: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0F840: 4BFFFF49  bl 0x82a0f788
	ctx.lr = 0x82A0F844;
	sub_82A0F788(ctx, base);
	// 82A0F844: EB410050  ld r26, 0x50(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0F848: FB4100B8  std r26, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[26].u64 ) };
	// 82A0F84C: 83C100BC  lwz r30, 0xbc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	pc = 0x82A0F850; continue 'dispatch;
            }
            0x82A0F850 => {
    //   block [0x82A0F850..0x82A0F860)
	// 82A0F850: 7D79F050  subf r11, r25, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[25].s64;
	// 82A0F854: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A0F858: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82A0F85C: 4199FF68  bgt cr6, 0x82a0f7c4
	if ctx.cr[6].gt {
	pc = 0x82A0F7C4; continue 'dispatch;
	}
	pc = 0x82A0F860; continue 'dispatch;
            }
            0x82A0F860 => {
    //   block [0x82A0F860..0x82A0F878)
	// 82A0F860: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A0F864: 40990014  ble cr6, 0x82a0f878
	if !ctx.cr[6].gt {
	pc = 0x82A0F878; continue 'dispatch;
	}
	// 82A0F868: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A0F86C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A0F870: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A0F874: 480004D5  bl 0x82a0fd48
	ctx.lr = 0x82A0F878;
	sub_82A0FD48(ctx, base);
	pc = 0x82A0F878; continue 'dispatch;
            }
            0x82A0F878 => {
    //   block [0x82A0F878..0x82A0F880)
	// 82A0F878: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A0F87C: 48299BD0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0F880 => {
    //   block [0x82A0F880..0x82A0F8AC)
	// 82A0F880: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82A0F884: 4099FFDC  ble cr6, 0x82a0f860
	if !ctx.cr[6].gt {
	pc = 0x82A0F860; continue 'dispatch;
	}
	// 82A0F888: 7D79F050  subf r11, r25, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[25].s64;
	// 82A0F88C: 7D7C1E70  srawi r28, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A0F890: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 82A0F894: 40990074  ble cr6, 0x82a0f908
	if !ctx.cr[6].gt {
	pc = 0x82A0F908; continue 'dispatch;
	}
	// 82A0F898: 7F8B0E70  srawi r11, r28, 1
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[28].s32 >> 1) as i64;
	// 82A0F89C: 7FEB0195  addze. r31, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[31].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0F8A0: 40810068  ble 0x82a0f908
	if !ctx.cr[0].gt {
	pc = 0x82A0F908; continue 'dispatch;
	}
	// 82A0F8A4: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0F8A8: 7FCBCA14  add r30, r11, r25
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	pc = 0x82A0F8AC; continue 'dispatch;
            }
            0x82A0F8AC => {
    //   block [0x82A0F8AC..0x82A0F8CC)
	// 82A0F8AC: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 82A0F8B0: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 82A0F8B4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F8B8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0F8BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0F8C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A0F8C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A0F8C8: 419A0020  beq cr6, 0x82a0f8e8
	if ctx.cr[6].eq {
	pc = 0x82A0F8E8; continue 'dispatch;
	}
	pc = 0x82A0F8CC; continue 'dispatch;
            }
            0x82A0F8CC => {
    //   block [0x82A0F8CC..0x82A0F8E8)
	// 82A0F8CC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A0F8D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0F8D4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A0F8D8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A0F8DC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0F8E0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0F8E4: 4082FFE8  bne 0x82a0f8cc
	if !ctx.cr[0].eq {
	pc = 0x82A0F8CC; continue 'dispatch;
	}
	pc = 0x82A0F8E8; continue 'dispatch;
            }
            0x82A0F8E8 => {
    //   block [0x82A0F8E8..0x82A0F908)
	// 82A0F8E8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A0F8EC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A0F8F0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A0F8F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A0F8F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A0F8FC: 480008A5  bl 0x82a101a0
	ctx.lr = 0x82A0F900;
	sub_82A101A0(ctx, base);
	// 82A0F900: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A0F904: 4199FFA8  bgt cr6, 0x82a0f8ac
	if ctx.cr[6].gt {
	pc = 0x82A0F8AC; continue 'dispatch;
	}
	pc = 0x82A0F908; continue 'dispatch;
            }
            0x82A0F908 => {
    //   block [0x82A0F908..0x82A0F924)
	// 82A0F908: FB410050  std r26, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u64 ) };
	// 82A0F90C: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 82A0F910: 4099FF68  ble cr6, 0x82a0f878
	if !ctx.cr[6].gt {
	pc = 0x82A0F878; continue 'dispatch;
	}
	// 82A0F914: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82A0F918: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0F91C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A0F920: 40990018  ble cr6, 0x82a0f938
	if !ctx.cr[6].gt {
	pc = 0x82A0F938; continue 'dispatch;
	}
	pc = 0x82A0F924; continue 'dispatch;
            }
            0x82A0F924 => {
    //   block [0x82A0F924..0x82A0F938)
	// 82A0F924: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0F928: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0F92C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A0F930: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A0F934: 48000B35  bl 0x82a10468
	ctx.lr = 0x82A0F938;
	sub_82A10468(ctx, base);
	pc = 0x82A0F938; continue 'dispatch;
            }
            0x82A0F938 => {
    //   block [0x82A0F938..0x82A0F958)
	// 82A0F938: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 82A0F93C: 7D79F850  subf r11, r25, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[25].s64;
	// 82A0F940: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A0F944: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A0F948: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A0F94C: 4199FFD8  bgt cr6, 0x82a0f924
	if ctx.cr[6].gt {
	pc = 0x82A0F924; continue 'dispatch;
	}
	// 82A0F950: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A0F954: 48299AF8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0F958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0F958 size=1004
    let mut pc: u32 = 0x82A0F958;
    'dispatch: loop {
        match pc {
            0x82A0F958 => {
    //   block [0x82A0F958..0x82A0F9DC)
	// 82A0F958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0F95C: 48299A99  bl 0x82ca93f4
	ctx.lr = 0x82A0F960;
	sub_82CA93D0(ctx, base);
	// 82A0F960: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0F964: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 82A0F968: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 82A0F96C: F8A100F0  std r5, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[5].u64 ) };
	// 82A0F970: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82A0F974: 830100F4  lwz r24, 0xf4(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 82A0F978: 3978FFF8  addi r11, r24, -8
	ctx.r[11].s64 = ctx.r[24].s64 + -8;
	// 82A0F97C: F8A10068  std r5, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[5].u64 ) };
	// 82A0F980: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A0F984: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A0F988: 832100EC  lwz r25, 0xec(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A0F98C: 7D59C050  subf r10, r25, r24
	ctx.r[10].s64 = ctx.r[24].s64 - ctx.r[25].s64;
	// 82A0F990: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82A0F994: F8810060  std r4, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[4].u64 ) };
	// 82A0F998: 7D280E70  srawi r8, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 82A0F99C: 7CE80194  addze r7, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[7].s64 = tmp.s64;
	// 82A0F9A0: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A0F9A4: 7FEBCA14  add r31, r11, r25
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 82A0F9A8: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82A0F9AC: EBC10060  ld r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A0F9B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0F9B4: 480004E5  bl 0x82a0fe98
	ctx.lr = 0x82A0F9B8;
	sub_82A0FE98(ctx, base);
	// 82A0F9B8: 38FF0008  addi r7, r31, 8
	ctx.r[7].s64 = ctx.r[31].s64 + 8;
	// 82A0F9BC: FBC10068  std r30, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u64 ) };
	// 82A0F9C0: 7F19F840  cmplw cr6, r25, r31
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0F9C4: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82A0F9C8: E8C10068  ld r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A0F9CC: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 82A0F9D0: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A0F9D4: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82A0F9D8: 40980098  bge cr6, 0x82a0fa70
	if !ctx.cr[6].lt {
	pc = 0x82A0FA70; continue 'dispatch;
	}
	pc = 0x82A0F9DC; continue 'dispatch;
            }
            0x82A0F9DC => {
    //   block [0x82A0F9DC..0x82A0F9FC)
	// 82A0F9DC: 811B0000  lwz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0F9E0: 815BFFF8  lwz r10, -8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0F9E4: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F9E8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0F9EC: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A0F9F0: 4098000C  bge cr6, 0x82a0f9fc
	if !ctx.cr[6].lt {
	pc = 0x82A0F9FC; continue 'dispatch;
	}
	// 82A0F9F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0F9F8: 4800001C  b 0x82a0fa14
	pc = 0x82A0FA14; continue 'dispatch;
            }
            0x82A0F9FC => {
    //   block [0x82A0F9FC..0x82A0FA10)
	// 82A0F9FC: 409A0014  bne cr6, 0x82a0fa10
	if !ctx.cr[6].eq {
	pc = 0x82A0FA10; continue 'dispatch;
	}
	// 82A0FA00: 7D685010  subfc r11, r8, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[8].u32;
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82A0FA04: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A0FA08: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82A0FA0C: 48000008  b 0x82a0fa14
	pc = 0x82A0FA14; continue 'dispatch;
            }
            0x82A0FA10 => {
    //   block [0x82A0FA10..0x82A0FA14)
	// 82A0FA10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0FA14; continue 'dispatch;
            }
            0x82A0FA14 => {
    //   block [0x82A0FA14..0x82A0FA38)
	// 82A0FA14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0FA18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0FA1C: 409A0054  bne cr6, 0x82a0fa70
	if !ctx.cr[6].eq {
	pc = 0x82A0FA70; continue 'dispatch;
	}
	// 82A0FA20: 815BFFF8  lwz r10, -8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0FA24: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0FA28: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A0FA2C: 4098000C  bge cr6, 0x82a0fa38
	if !ctx.cr[6].lt {
	pc = 0x82A0FA38; continue 'dispatch;
	}
	// 82A0FA30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0FA34: 4800001C  b 0x82a0fa50
	pc = 0x82A0FA50; continue 'dispatch;
            }
            0x82A0FA38 => {
    //   block [0x82A0FA38..0x82A0FA4C)
	// 82A0FA38: 409A0014  bne cr6, 0x82a0fa4c
	if !ctx.cr[6].eq {
	pc = 0x82A0FA4C; continue 'dispatch;
	}
	// 82A0FA3C: 7D6A4010  subfc r11, r10, r8
	ctx.xer.ca = ctx.r[8].u32 >= ctx.r[10].u32;
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 82A0FA40: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A0FA44: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82A0FA48: 48000008  b 0x82a0fa50
	pc = 0x82A0FA50; continue 'dispatch;
            }
            0x82A0FA4C => {
    //   block [0x82A0FA4C..0x82A0FA50)
	// 82A0FA4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0FA50; continue 'dispatch;
            }
            0x82A0FA50 => {
    //   block [0x82A0FA50..0x82A0FA70)
	// 82A0FA50: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0FA54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0FA58: 409A0018  bne cr6, 0x82a0fa70
	if !ctx.cr[6].eq {
	pc = 0x82A0FA70; continue 'dispatch;
	}
	// 82A0FA5C: 3B7BFFF8  addi r27, r27, -8
	ctx.r[27].s64 = ctx.r[27].s64 + -8;
	// 82A0FA60: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82A0FA64: 7F19D840  cmplw cr6, r25, r27
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A0FA68: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0FA6C: 4198FF70  blt cr6, 0x82a0f9dc
	if ctx.cr[6].lt {
	pc = 0x82A0F9DC; continue 'dispatch;
	}
	pc = 0x82A0FA70; continue 'dispatch;
            }
            0x82A0FA70 => {
    //   block [0x82A0FA70..0x82A0FA84)
	// 82A0FA70: 8341005C  lwz r26, 0x5c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0FA74: 7F07C040  cmplw cr6, r7, r24
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A0FA78: 4098008C  bge cr6, 0x82a0fb04
	if !ctx.cr[6].lt {
	pc = 0x82A0FB04; continue 'dispatch;
	}
	// 82A0FA7C: 80FB0000  lwz r7, 0(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0FA80: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A0FA84; continue 'dispatch;
            }
            0x82A0FA84 => {
    //   block [0x82A0FA84..0x82A0FA9C)
	// 82A0FA84: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0FA88: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0FA8C: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82A0FA90: 4098000C  bge cr6, 0x82a0fa9c
	if !ctx.cr[6].lt {
	pc = 0x82A0FA9C; continue 'dispatch;
	}
	// 82A0FA94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0FA98: 4800001C  b 0x82a0fab4
	pc = 0x82A0FAB4; continue 'dispatch;
            }
            0x82A0FA9C => {
    //   block [0x82A0FA9C..0x82A0FAB0)
	// 82A0FA9C: 409A0014  bne cr6, 0x82a0fab0
	if !ctx.cr[6].eq {
	pc = 0x82A0FAB0; continue 'dispatch;
	}
	// 82A0FAA0: 7D674810  subfc r11, r7, r9
	ctx.xer.ca = ctx.r[9].u32 >= ctx.r[7].u32;
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 82A0FAA4: 7CCB5910  subfe r6, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[6].u32 = res;
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A0FAA8: 54CB07FE  clrlwi r11, r6, 0x1f
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x00000001u64;
	// 82A0FAAC: 48000008  b 0x82a0fab4
	pc = 0x82A0FAB4; continue 'dispatch;
            }
            0x82A0FAB0 => {
    //   block [0x82A0FAB0..0x82A0FAB4)
	// 82A0FAB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0FAB4; continue 'dispatch;
            }
            0x82A0FAB4 => {
    //   block [0x82A0FAB4..0x82A0FAD0)
	// 82A0FAB4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0FAB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0FABC: 409A0048  bne cr6, 0x82a0fb04
	if !ctx.cr[6].eq {
	pc = 0x82A0FB04; continue 'dispatch;
	}
	// 82A0FAC0: 7F085000  cmpw cr6, r8, r10
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A0FAC4: 4098000C  bge cr6, 0x82a0fad0
	if !ctx.cr[6].lt {
	pc = 0x82A0FAD0; continue 'dispatch;
	}
	// 82A0FAC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0FACC: 4800001C  b 0x82a0fae8
	pc = 0x82A0FAE8; continue 'dispatch;
            }
            0x82A0FAD0 => {
    //   block [0x82A0FAD0..0x82A0FAE4)
	// 82A0FAD0: 409A0014  bne cr6, 0x82a0fae4
	if !ctx.cr[6].eq {
	pc = 0x82A0FAE4; continue 'dispatch;
	}
	// 82A0FAD4: 7D693810  subfc r11, r9, r7
	ctx.xer.ca = ctx.r[7].u32 >= ctx.r[9].u32;
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 82A0FAD8: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A0FADC: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82A0FAE0: 48000008  b 0x82a0fae8
	pc = 0x82A0FAE8; continue 'dispatch;
            }
            0x82A0FAE4 => {
    //   block [0x82A0FAE4..0x82A0FAE8)
	// 82A0FAE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0FAE8; continue 'dispatch;
            }
            0x82A0FAE8 => {
    //   block [0x82A0FAE8..0x82A0FB04)
	// 82A0FAE8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0FAEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0FAF0: 409A0014  bne cr6, 0x82a0fb04
	if !ctx.cr[6].eq {
	pc = 0x82A0FB04; continue 'dispatch;
	}
	// 82A0FAF4: 3B5A0008  addi r26, r26, 8
	ctx.r[26].s64 = ctx.r[26].s64 + 8;
	// 82A0FAF8: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82A0FAFC: 7F1AC040  cmplw cr6, r26, r24
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A0FB00: 4198FF84  blt cr6, 0x82a0fa84
	if ctx.cr[6].lt {
	pc = 0x82A0FA84; continue 'dispatch;
	}
	pc = 0x82A0FB04; continue 'dispatch;
            }
            0x82A0FB04 => {
    //   block [0x82A0FB04..0x82A0FB18)
	// 82A0FB04: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0FB08: FBC10068  std r30, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u64 ) };
	// 82A0FB0C: 83A1006C  lwz r29, 0x6c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A0FB10: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82A0FB14: 83810064  lwz r28, 0x64(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	pc = 0x82A0FB18; continue 'dispatch;
            }
            0x82A0FB18 => {
    //   block [0x82A0FB18..0x82A0FB20)
	// 82A0FB18: 7F1CC040  cmplw cr6, r28, r24
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A0FB1C: 409800A0  bge cr6, 0x82a0fbbc
	if !ctx.cr[6].lt {
	pc = 0x82A0FBBC; continue 'dispatch;
	}
	pc = 0x82A0FB20; continue 'dispatch;
            }
            0x82A0FB20 => {
    //   block [0x82A0FB20..0x82A0FB40)
	// 82A0FB20: 811B0000  lwz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0FB24: 80FC0000  lwz r7, 0(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0FB28: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0FB2C: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0FB30: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A0FB34: 4098000C  bge cr6, 0x82a0fb40
	if !ctx.cr[6].lt {
	pc = 0x82A0FB40; continue 'dispatch;
	}
	// 82A0FB38: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A0FB3C: 4800001C  b 0x82a0fb58
	pc = 0x82A0FB58; continue 'dispatch;
            }
            0x82A0FB40 => {
    //   block [0x82A0FB40..0x82A0FB54)
	// 82A0FB40: 409A0014  bne cr6, 0x82a0fb54
	if !ctx.cr[6].eq {
	pc = 0x82A0FB54; continue 'dispatch;
	}
	// 82A0FB44: 7D274010  subfc r9, r7, r8
	ctx.xer.ca = ctx.r[8].u32 >= ctx.r[7].u32;
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82A0FB48: 7CC94910  subfe r6, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[6].u32 = res;
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A0FB4C: 54C907FE  clrlwi r9, r6, 0x1f
	ctx.r[9].u64 = ctx.r[6].u32 as u64 & 0x00000001u64;
	// 82A0FB50: 48000008  b 0x82a0fb58
	pc = 0x82A0FB58; continue 'dispatch;
            }
            0x82A0FB54 => {
    //   block [0x82A0FB54..0x82A0FB58)
	// 82A0FB54: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82A0FB58; continue 'dispatch;
            }
            0x82A0FB58 => {
    //   block [0x82A0FB58..0x82A0FB74)
	// 82A0FB58: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82A0FB5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A0FB60: 409A004C  bne cr6, 0x82a0fbac
	if !ctx.cr[6].eq {
	pc = 0x82A0FBAC; continue 'dispatch;
	}
	// 82A0FB64: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A0FB68: 4098000C  bge cr6, 0x82a0fb74
	if !ctx.cr[6].lt {
	pc = 0x82A0FB74; continue 'dispatch;
	}
	// 82A0FB6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0FB70: 4800001C  b 0x82a0fb8c
	pc = 0x82A0FB8C; continue 'dispatch;
            }
            0x82A0FB74 => {
    //   block [0x82A0FB74..0x82A0FB88)
	// 82A0FB74: 409A0014  bne cr6, 0x82a0fb88
	if !ctx.cr[6].eq {
	pc = 0x82A0FB88; continue 'dispatch;
	}
	// 82A0FB78: 7D683810  subfc r11, r8, r7
	ctx.xer.ca = ctx.r[7].u32 >= ctx.r[8].u32;
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 82A0FB7C: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A0FB80: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82A0FB84: 48000008  b 0x82a0fb8c
	pc = 0x82A0FB8C; continue 'dispatch;
            }
            0x82A0FB88 => {
    //   block [0x82A0FB88..0x82A0FB8C)
	// 82A0FB88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0FB8C; continue 'dispatch;
            }
            0x82A0FB8C => {
    //   block [0x82A0FB8C..0x82A0FBAC)
	// 82A0FB8C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0FB90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0FB94: 409A0028  bne cr6, 0x82a0fbbc
	if !ctx.cr[6].eq {
	pc = 0x82A0FBBC; continue 'dispatch;
	}
	// 82A0FB98: 3B5A0008  addi r26, r26, 8
	ctx.r[26].s64 = ctx.r[26].s64 + 8;
	// 82A0FB9C: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0FBA0: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A0FBA4: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82A0FBA8: 48000409  bl 0x82a0ffb0
	ctx.lr = 0x82A0FBAC;
	sub_82A0FFB0(ctx, base);
	pc = 0x82A0FBAC; continue 'dispatch;
            }
            0x82A0FBAC => {
    //   block [0x82A0FBAC..0x82A0FBBC)
	// 82A0FBAC: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82A0FBB0: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82A0FBB4: 7F1CC040  cmplw cr6, r28, r24
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A0FBB8: 4198FF68  blt cr6, 0x82a0fb20
	if ctx.cr[6].lt {
	pc = 0x82A0FB20; continue 'dispatch;
	}
	pc = 0x82A0FBBC; continue 'dispatch;
            }
            0x82A0FBBC => {
    //   block [0x82A0FBBC..0x82A0FBC4)
	// 82A0FBBC: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A0FBC0: 409900C0  ble cr6, 0x82a0fc80
	if !ctx.cr[6].gt {
	pc = 0x82A0FC80; continue 'dispatch;
	}
	pc = 0x82A0FBC4; continue 'dispatch;
            }
            0x82A0FBC4 => {
    //   block [0x82A0FBC4..0x82A0FBE8)
	// 82A0FBC4: 811B0000  lwz r8, 0(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0FBC8: 3BFDFFF8  addi r31, r29, -8
	ctx.r[31].s64 = ctx.r[29].s64 + -8;
	// 82A0FBCC: 815DFFF8  lwz r10, -8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A0FBD0: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0FBD4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0FBD8: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A0FBDC: 4098000C  bge cr6, 0x82a0fbe8
	if !ctx.cr[6].lt {
	pc = 0x82A0FBE8; continue 'dispatch;
	}
	// 82A0FBE0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0FBE4: 4800001C  b 0x82a0fc00
	pc = 0x82A0FC00; continue 'dispatch;
            }
            0x82A0FBE8 => {
    //   block [0x82A0FBE8..0x82A0FBFC)
	// 82A0FBE8: 409A0014  bne cr6, 0x82a0fbfc
	if !ctx.cr[6].eq {
	pc = 0x82A0FBFC; continue 'dispatch;
	}
	// 82A0FBEC: 7D685010  subfc r11, r8, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[8].u32;
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82A0FBF0: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A0FBF4: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82A0FBF8: 48000008  b 0x82a0fc00
	pc = 0x82A0FC00; continue 'dispatch;
            }
            0x82A0FBFC => {
    //   block [0x82A0FBFC..0x82A0FC00)
	// 82A0FBFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0FC00; continue 'dispatch;
            }
            0x82A0FC00 => {
    //   block [0x82A0FC00..0x82A0FC24)
	// 82A0FC00: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0FC04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0FC08: 409A0064  bne cr6, 0x82a0fc6c
	if !ctx.cr[6].eq {
	pc = 0x82A0FC6C; continue 'dispatch;
	}
	// 82A0FC0C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0FC10: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0FC14: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A0FC18: 4098000C  bge cr6, 0x82a0fc24
	if !ctx.cr[6].lt {
	pc = 0x82A0FC24; continue 'dispatch;
	}
	// 82A0FC1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0FC20: 4800001C  b 0x82a0fc3c
	pc = 0x82A0FC3C; continue 'dispatch;
            }
            0x82A0FC24 => {
    //   block [0x82A0FC24..0x82A0FC38)
	// 82A0FC24: 409A0014  bne cr6, 0x82a0fc38
	if !ctx.cr[6].eq {
	pc = 0x82A0FC38; continue 'dispatch;
	}
	// 82A0FC28: 7D6A4010  subfc r11, r10, r8
	ctx.xer.ca = ctx.r[8].u32 >= ctx.r[10].u32;
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 82A0FC2C: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A0FC30: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82A0FC34: 48000008  b 0x82a0fc3c
	pc = 0x82A0FC3C; continue 'dispatch;
            }
            0x82A0FC38 => {
    //   block [0x82A0FC38..0x82A0FC3C)
	// 82A0FC38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0FC3C; continue 'dispatch;
            }
            0x82A0FC3C => {
    //   block [0x82A0FC3C..0x82A0FC6C)
	// 82A0FC3C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0FC40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0FC44: 409A0038  bne cr6, 0x82a0fc7c
	if !ctx.cr[6].eq {
	pc = 0x82A0FC7C; continue 'dispatch;
	}
	// 82A0FC48: 3B7BFFF8  addi r27, r27, -8
	ctx.r[27].s64 = ctx.r[27].s64 + -8;
	// 82A0FC4C: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A0FC50: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82A0FC54: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 82A0FC58: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82A0FC5C: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0FC60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0FC64: E8810070  ld r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A0FC68: 48000349  bl 0x82a0ffb0
	ctx.lr = 0x82A0FC6C;
	sub_82A0FFB0(ctx, base);
	pc = 0x82A0FC6C; continue 'dispatch;
            }
            0x82A0FC6C => {
    //   block [0x82A0FC6C..0x82A0FC7C)
	// 82A0FC6C: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82A0FC70: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82A0FC74: 7F19E840  cmplw cr6, r25, r29
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A0FC78: 4198FF4C  blt cr6, 0x82a0fbc4
	if ctx.cr[6].lt {
	pc = 0x82A0FBC4; continue 'dispatch;
	}
	pc = 0x82A0FC7C; continue 'dispatch;
            }
            0x82A0FC7C => {
    //   block [0x82A0FC7C..0x82A0FC80)
	// 82A0FC7C: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	pc = 0x82A0FC80; continue 'dispatch;
            }
            0x82A0FC80 => {
    //   block [0x82A0FC80..0x82A0FCA0)
	// 82A0FC80: 409A004C  bne cr6, 0x82a0fccc
	if !ctx.cr[6].eq {
	pc = 0x82A0FCCC; continue 'dispatch;
	}
	// 82A0FC84: 7F1CC040  cmplw cr6, r28, r24
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A0FC88: 419A00A4  beq cr6, 0x82a0fd2c
	if ctx.cr[6].eq {
	pc = 0x82A0FD2C; continue 'dispatch;
	}
	// 82A0FC8C: 7F1AE040  cmplw cr6, r26, r28
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0FC90: 419A0010  beq cr6, 0x82a0fca0
	if ctx.cr[6].eq {
	pc = 0x82A0FCA0; continue 'dispatch;
	}
	// 82A0FC94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0FC98: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0FC9C: 48000315  bl 0x82a0ffb0
	ctx.lr = 0x82A0FCA0;
	sub_82A0FFB0(ctx, base);
	pc = 0x82A0FCA0; continue 'dispatch;
            }
            0x82A0FCA0 => {
    //   block [0x82A0FCA0..0x82A0FCCC)
	// 82A0FCA0: 3B5A0008  addi r26, r26, 8
	ctx.r[26].s64 = ctx.r[26].s64 + 8;
	// 82A0FCA4: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A0FCA8: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82A0FCAC: 3B7B0008  addi r27, r27, 8
	ctx.r[27].s64 = ctx.r[27].s64 + 8;
	// 82A0FCB0: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82A0FCB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0FCB8: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82A0FCBC: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82A0FCC0: 480002F1  bl 0x82a0ffb0
	ctx.lr = 0x82A0FCC4;
	sub_82A0FFB0(ctx, base);
	// 82A0FCC4: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0FCC8: 4BFFFE50  b 0x82a0fb18
	pc = 0x82A0FB18; continue 'dispatch;
            }
            0x82A0FCCC => {
    //   block [0x82A0FCCC..0x82A0FCFC)
	// 82A0FCCC: 3BBDFFF8  addi r29, r29, -8
	ctx.r[29].s64 = ctx.r[29].s64 + -8;
	// 82A0FCD0: 7F1CC040  cmplw cr6, r28, r24
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A0FCD4: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82A0FCD8: 409A003C  bne cr6, 0x82a0fd14
	if !ctx.cr[6].eq {
	pc = 0x82A0FD14; continue 'dispatch;
	}
	// 82A0FCDC: 3B7BFFF8  addi r27, r27, -8
	ctx.r[27].s64 = ctx.r[27].s64 + -8;
	// 82A0FCE0: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82A0FCE4: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A0FCE8: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0FCEC: 419A0010  beq cr6, 0x82a0fcfc
	if ctx.cr[6].eq {
	pc = 0x82A0FCFC; continue 'dispatch;
	}
	// 82A0FCF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A0FCF4: E8610068  ld r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A0FCF8: 480002B9  bl 0x82a0ffb0
	ctx.lr = 0x82A0FCFC;
	sub_82A0FFB0(ctx, base);
	pc = 0x82A0FCFC; continue 'dispatch;
            }
            0x82A0FCFC => {
    //   block [0x82A0FCFC..0x82A0FD14)
	// 82A0FCFC: 3B5AFFF8  addi r26, r26, -8
	ctx.r[26].s64 = ctx.r[26].s64 + -8;
	// 82A0FD00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A0FD04: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82A0FD08: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0FD0C: 480002A5  bl 0x82a0ffb0
	ctx.lr = 0x82A0FD10;
	sub_82A0FFB0(ctx, base);
	// 82A0FD10: 4BFFFE08  b 0x82a0fb18
	pc = 0x82A0FB18; continue 'dispatch;
            }
            0x82A0FD14 => {
    //   block [0x82A0FD14..0x82A0FD2C)
	// 82A0FD14: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82A0FD18: E8610060  ld r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A0FD1C: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A0FD20: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82A0FD24: 4800028D  bl 0x82a0ffb0
	ctx.lr = 0x82A0FD28;
	sub_82A0FFB0(ctx, base);
	// 82A0FD28: 4BFFFDF0  b 0x82a0fb18
	pc = 0x82A0FB18; continue 'dispatch;
            }
            0x82A0FD2C => {
    //   block [0x82A0FD2C..0x82A0FD44)
	// 82A0FD2C: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0FD30: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82A0FD34: FBD70000  std r30, 0(r23)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 82A0FD38: F9770008  std r11, 8(r23)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[23].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82A0FD3C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A0FD40: 48299704  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0FD48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0FD48 size=336
    let mut pc: u32 = 0x82A0FD48;
    'dispatch: loop {
        match pc {
            0x82A0FD48 => {
    //   block [0x82A0FD48..0x82A0FD84)
	// 82A0FD48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0FD4C: 482996BD  bl 0x82ca9408
	ctx.lr = 0x82A0FD50;
	sub_82CA93D0(ctx, base);
	// 82A0FD50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0FD54: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A0FD58: FBA100A0  std r29, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u64 ) };
	// 82A0FD5C: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82A0FD60: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A0FD64: 838100AC  lwz r28, 0xac(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A0FD68: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0FD6C: 419A0124  beq cr6, 0x82a0fe90
	if ctx.cr[6].eq {
	pc = 0x82A0FE90; continue 'dispatch;
	}
	// 82A0FD70: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 82A0FD74: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 82A0FD78: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A0FD7C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0FD80: 419A0110  beq cr6, 0x82a0fe90
	if ctx.cr[6].eq {
	pc = 0x82A0FE90; continue 'dispatch;
	}
	pc = 0x82A0FD84; continue 'dispatch;
            }
            0x82A0FD84 => {
    //   block [0x82A0FD84..0x82A0FDA4)
	// 82A0FD84: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0FD88: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0FD8C: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0FD90: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0FD94: 7F085800  cmpw cr6, r8, r11
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A0FD98: 4098000C  bge cr6, 0x82a0fda4
	if !ctx.cr[6].lt {
	pc = 0x82A0FDA4; continue 'dispatch;
	}
	// 82A0FD9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0FDA0: 4800001C  b 0x82a0fdbc
	pc = 0x82A0FDBC; continue 'dispatch;
            }
            0x82A0FDA4 => {
    //   block [0x82A0FDA4..0x82A0FDB8)
	// 82A0FDA4: 409A0014  bne cr6, 0x82a0fdb8
	if !ctx.cr[6].eq {
	pc = 0x82A0FDB8; continue 'dispatch;
	}
	// 82A0FDA8: 7D6A3810  subfc r11, r10, r7
	ctx.xer.ca = ctx.r[7].u32 >= ctx.r[10].u32;
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 82A0FDAC: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A0FDB0: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82A0FDB4: 48000008  b 0x82a0fdbc
	pc = 0x82A0FDBC; continue 'dispatch;
            }
            0x82A0FDB8 => {
    //   block [0x82A0FDB8..0x82A0FDBC)
	// 82A0FDB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0FDBC; continue 'dispatch;
            }
            0x82A0FDBC => {
    //   block [0x82A0FDBC..0x82A0FDF0)
	// 82A0FDBC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0FDC0: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0FDC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0FDC8: 419A0028  beq cr6, 0x82a0fdf0
	if ctx.cr[6].eq {
	pc = 0x82A0FDF0; continue 'dispatch;
	}
	// 82A0FDCC: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 82A0FDD0: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 82A0FDD4: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0FDD8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A0FDDC: 419A00A4  beq cr6, 0x82a0fe80
	if ctx.cr[6].eq {
	pc = 0x82A0FE80; continue 'dispatch;
	}
	// 82A0FDE0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A0FDE4: 419A009C  beq cr6, 0x82a0fe80
	if ctx.cr[6].eq {
	pc = 0x82A0FE80; continue 'dispatch;
	}
	// 82A0FDE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A0FDEC: 48000084  b 0x82a0fe70
	pc = 0x82A0FE70; continue 'dispatch;
            }
            0x82A0FDF0 => {
    //   block [0x82A0FDF0..0x82A0FE00)
	// 82A0FDF0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82A0FDF4: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 82A0FDF8: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 82A0FDFC: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x82A0FE00; continue 'dispatch;
            }
            0x82A0FE00 => {
    //   block [0x82A0FE00..0x82A0FE20)
	// 82A0FE00: 3929FFF8  addi r9, r9, -8
	ctx.r[9].s64 = ctx.r[9].s64 + -8;
	// 82A0FE04: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82A0FE08: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0FE0C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0FE10: 7F085800  cmpw cr6, r8, r11
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A0FE14: 4098000C  bge cr6, 0x82a0fe20
	if !ctx.cr[6].lt {
	pc = 0x82A0FE20; continue 'dispatch;
	}
	// 82A0FE18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A0FE1C: 4800001C  b 0x82a0fe38
	pc = 0x82A0FE38; continue 'dispatch;
            }
            0x82A0FE20 => {
    //   block [0x82A0FE20..0x82A0FE34)
	// 82A0FE20: 409A0014  bne cr6, 0x82a0fe34
	if !ctx.cr[6].eq {
	pc = 0x82A0FE34; continue 'dispatch;
	}
	// 82A0FE24: 7D6A3810  subfc r11, r10, r7
	ctx.xer.ca = ctx.r[7].u32 >= ctx.r[10].u32;
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 82A0FE28: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A0FE2C: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82A0FE30: 48000008  b 0x82a0fe38
	pc = 0x82A0FE38; continue 'dispatch;
            }
            0x82A0FE34 => {
    //   block [0x82A0FE34..0x82A0FE38)
	// 82A0FE34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A0FE38; continue 'dispatch;
            }
            0x82A0FE38 => {
    //   block [0x82A0FE38..0x82A0FE4C)
	// 82A0FE38: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A0FE3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A0FE40: 419A000C  beq cr6, 0x82a0fe4c
	if ctx.cr[6].eq {
	pc = 0x82A0FE4C; continue 'dispatch;
	}
	// 82A0FE44: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0FE48: 4BFFFFB8  b 0x82a0fe00
	pc = 0x82A0FE00; continue 'dispatch;
            }
            0x82A0FE4C => {
    //   block [0x82A0FE4C..0x82A0FE70)
	// 82A0FE4C: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 82A0FE50: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A0FE54: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A0FE58: 419A0028  beq cr6, 0x82a0fe80
	if ctx.cr[6].eq {
	pc = 0x82A0FE80; continue 'dispatch;
	}
	// 82A0FE5C: 397F0008  addi r11, r31, 8
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	// 82A0FE60: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 82A0FE64: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A0FE68: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A0FE6C: 419A0014  beq cr6, 0x82a0fe80
	if ctx.cr[6].eq {
	pc = 0x82A0FE80; continue 'dispatch;
	}
	pc = 0x82A0FE70; continue 'dispatch;
            }
            0x82A0FE70 => {
    //   block [0x82A0FE70..0x82A0FE80)
	// 82A0FE70: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A0FE74: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0FE78: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A0FE7C: 480006DD  bl 0x82a10558
	ctx.lr = 0x82A0FE80;
	sub_82A10558(ctx, base);
	pc = 0x82A0FE80; continue 'dispatch;
            }
            0x82A0FE80 => {
    //   block [0x82A0FE80..0x82A0FE90)
	// 82A0FE80: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82A0FE84: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A0FE88: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A0FE8C: 409AFEF8  bne cr6, 0x82a0fd84
	if !ctx.cr[6].eq {
	pc = 0x82A0FD84; continue 'dispatch;
	}
	pc = 0x82A0FE90; continue 'dispatch;
            }
            0x82A0FE90 => {
    //   block [0x82A0FE90..0x82A0FE98)
	// 82A0FE90: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A0FE94: 482995C4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0FE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A0FE98 size=276
    let mut pc: u32 = 0x82A0FE98;
    'dispatch: loop {
        match pc {
            0x82A0FE98 => {
    //   block [0x82A0FE98..0x82A0FF98)
	// 82A0FE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0FE9C: 4829955D  bl 0x82ca93f8
	ctx.lr = 0x82A0FEA0;
	sub_82CA93D0(ctx, base);
	// 82A0FEA0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0FEA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A0FEA8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A0FEAC: FBC100C0  std r30, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u64 ) };
	// 82A0FEB0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A0FEB4: FB8100D0  std r28, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[28].u64 ) };
	// 82A0FEB8: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82A0FEBC: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A0FEC0: 830100D4  lwz r24, 0xd4(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A0FEC4: 7D6AC050  subf r11, r10, r24
	ctx.r[11].s64 = ctx.r[24].s64 - ctx.r[10].s64;
	// 82A0FEC8: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A0FECC: FBA100C8  std r29, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[29].u64 ) };
	// 82A0FED0: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 82A0FED4: 409900C4  ble cr6, 0x82a0ff98
	if !ctx.cr[6].gt {
	pc = 0x82A0FF98; continue 'dispatch;
	}
	// 82A0FED8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A0FEDC: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 82A0FEE0: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 82A0FEE4: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A0FEE8: 7D690194  addze r11, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82A0FEEC: 557F1838  slwi r31, r11, 3
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82A0FEF0: 55792036  slwi r25, r11, 4
	ctx.r[25].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 82A0FEF4: 7F5F5214  add r26, r31, r10
	ctx.r[26].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 82A0FEF8: 7D195214  add r8, r25, r10
	ctx.r[8].u64 = ctx.r[25].u64 + ctx.r[10].u64;
	// 82A0FEFC: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82A0FF00: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82A0FF04: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0FF08: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0FF0C: 4800016D  bl 0x82a10078
	ctx.lr = 0x82A0FF10;
	sub_82A10078(ctx, base);
	// 82A0FF10: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A0FF14: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A0FF18: FBA10058  std r29, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u64 ) };
	// 82A0FF1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0FF20: 7CBF5850  subf r5, r31, r11
	ctx.r[5].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 82A0FF24: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 82A0FF28: 7CFF5A14  add r7, r31, r11
	ctx.r[7].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A0FF2C: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 82A0FF30: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 82A0FF34: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0FF38: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0FF3C: 4800013D  bl 0x82a10078
	ctx.lr = 0x82A0FF40;
	sub_82A10078(ctx, base);
	// 82A0FF40: 7C99C050  subf r4, r25, r24
	ctx.r[4].s64 = ctx.r[24].s64 - ctx.r[25].s64;
	// 82A0FF44: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 82A0FF48: 7FFFC050  subf r31, r31, r24
	ctx.r[31].s64 = ctx.r[24].s64 - ctx.r[31].s64;
	// 82A0FF4C: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 82A0FF50: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A0FF54: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82A0FF58: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A0FF5C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A0FF60: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0FF64: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0FF68: 48000111  bl 0x82a10078
	ctx.lr = 0x82A0FF6C;
	sub_82A10078(ctx, base);
	// 82A0FF6C: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 82A0FF70: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A0FF74: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 82A0FF78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0FF7C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A0FF80: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82A0FF84: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A0FF88: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A0FF8C: 480000ED  bl 0x82a10078
	ctx.lr = 0x82A0FF90;
	sub_82A10078(ctx, base);
	// 82A0FF90: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A0FF94: 482994B4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A0FF98 => {
    //   block [0x82A0FF98..0x82A0FFAC)
	// 82A0FF98: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A0FF9C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A0FFA0: 480000D9  bl 0x82a10078
	ctx.lr = 0x82A0FFA4;
	sub_82A10078(ctx, base);
	// 82A0FFA4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A0FFA8: 482994A0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A0FFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A0FFB0 size=200
    let mut pc: u32 = 0x82A0FFB0;
    'dispatch: loop {
        match pc {
            0x82A0FFB0 => {
    //   block [0x82A0FFB0..0x82A0FFE0)
	// 82A0FFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A0FFB4: 4829944D  bl 0x82ca9400
	ctx.lr = 0x82A0FFB8;
	sub_82CA93D0(ctx, base);
	// 82A0FFB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A0FFBC: F86100A0  std r3, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[3].u64 ) };
	// 82A0FFC0: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A0FFC4: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82A0FFC8: 839E0004  lwz r28, 4(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A0FFCC: 835E0000  lwz r26, 0(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A0FFD0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A0FFD4: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 82A0FFD8: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82A0FFDC: 419A0020  beq cr6, 0x82a0fffc
	if ctx.cr[6].eq {
	pc = 0x82A0FFFC; continue 'dispatch;
	}
	pc = 0x82A0FFE0; continue 'dispatch;
            }
            0x82A0FFE0 => {
    //   block [0x82A0FFE0..0x82A0FFFC)
	// 82A0FFE0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A0FFE4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0FFE8: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A0FFEC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A0FFF0: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A0FFF4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A0FFF8: 4082FFE8  bne 0x82a0ffe0
	if !ctx.cr[0].eq {
	pc = 0x82A0FFE0; continue 'dispatch;
	}
	pc = 0x82A0FFFC; continue 'dispatch;
            }
            0x82A0FFFC => {
    //   block [0x82A0FFFC..0x82A10038)
	// 82A0FFFC: 83A100AC  lwz r29, 0xac(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A10000: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10004: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10008: 837D0000  lwz r27, 0(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1000C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A10010: 419A0028  beq cr6, 0x82a10038
	if ctx.cr[6].eq {
	pc = 0x82A10038; continue 'dispatch;
	}
	// 82A10014: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A10018: 4B7A7B01  bl 0x821b7b18
	ctx.lr = 0x82A1001C;
	sub_821B7B18(ctx, base);
	// 82A1001C: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A10020: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A10024: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A10028: 419A0010  beq cr6, 0x82a10038
	if ctx.cr[6].eq {
	pc = 0x82A10038; continue 'dispatch;
	}
	// 82A1002C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A10030: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A10034: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A10038; continue 'dispatch;
            }
            0x82A10038 => {
    //   block [0x82A10038..0x82A10068)
	// 82A10038: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1003C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A10040: 419A0028  beq cr6, 0x82a10068
	if ctx.cr[6].eq {
	pc = 0x82A10068; continue 'dispatch;
	}
	// 82A10044: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A10048: 4B7A7AD1  bl 0x821b7b18
	ctx.lr = 0x82A1004C;
	sub_821B7B18(ctx, base);
	// 82A1004C: 935D0000  stw r26, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82A10050: 939D0004  stw r28, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A10054: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A10058: 419A0010  beq cr6, 0x82a10068
	if ctx.cr[6].eq {
	pc = 0x82A10068; continue 'dispatch;
	}
	// 82A1005C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A10060: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A10064: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A10068; continue 'dispatch;
            }
            0x82A10068 => {
    //   block [0x82A10068..0x82A10078)
	// 82A10068: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1006C: 4B7A7AAD  bl 0x821b7b18
	ctx.lr = 0x82A10070;
	sub_821B7B18(ctx, base);
	// 82A10070: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A10074: 482993DC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A10078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A10078 size=296
    let mut pc: u32 = 0x82A10078;
    'dispatch: loop {
        match pc {
            0x82A10078 => {
    //   block [0x82A10078..0x82A100C4)
	// 82A10078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1007C: 48299389  bl 0x82ca9404
	ctx.lr = 0x82A10080;
	sub_82CA93D0(ctx, base);
	// 82A10080: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A10084: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A10088: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A1008C: FB610090  std r27, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[27].u64 ) };
	// 82A10090: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A10094: FB810098  std r28, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u64 ) };
	// 82A10098: 83E1009C  lwz r31, 0x9c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A1009C: 83C10094  lwz r30, 0x94(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A100A0: FBA100A0  std r29, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u64 ) };
	// 82A100A4: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A100A8: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A100AC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A100B0: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A100B4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A100B8: 4098000C  bge cr6, 0x82a100c4
	if !ctx.cr[6].lt {
	pc = 0x82A100C4; continue 'dispatch;
	}
	// 82A100BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A100C0: 4800001C  b 0x82a100dc
	pc = 0x82A100DC; continue 'dispatch;
            }
            0x82A100C4 => {
    //   block [0x82A100C4..0x82A100D8)
	// 82A100C4: 409A0014  bne cr6, 0x82a100d8
	if !ctx.cr[6].eq {
	pc = 0x82A100D8; continue 'dispatch;
	}
	// 82A100C8: 7D684810  subfc r11, r8, r9
	ctx.xer.ca = ctx.r[9].u32 >= ctx.r[8].u32;
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82A100CC: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A100D0: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82A100D4: 48000008  b 0x82a100dc
	pc = 0x82A100DC; continue 'dispatch;
            }
            0x82A100D8 => {
    //   block [0x82A100D8..0x82A100DC)
	// 82A100D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A100DC; continue 'dispatch;
            }
            0x82A100DC => {
    //   block [0x82A100DC..0x82A100F4)
	// 82A100DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A100E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A100E4: 419A0010  beq cr6, 0x82a100f4
	if ctx.cr[6].eq {
	pc = 0x82A100F4; continue 'dispatch;
	}
	// 82A100E8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A100EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A100F0: 4BFFFEC1  bl 0x82a0ffb0
	ctx.lr = 0x82A100F4;
	sub_82A0FFB0(ctx, base);
	pc = 0x82A100F4; continue 'dispatch;
            }
            0x82A100F4 => {
    //   block [0x82A100F4..0x82A10118)
	// 82A100F4: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A100F8: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A100FC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A10100: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10104: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10108: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A1010C: 4098000C  bge cr6, 0x82a10118
	if !ctx.cr[6].lt {
	pc = 0x82A10118; continue 'dispatch;
	}
	// 82A10110: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A10114: 4800001C  b 0x82a10130
	pc = 0x82A10130; continue 'dispatch;
            }
            0x82A10118 => {
    //   block [0x82A10118..0x82A1012C)
	// 82A10118: 409A0014  bne cr6, 0x82a1012c
	if !ctx.cr[6].eq {
	pc = 0x82A1012C; continue 'dispatch;
	}
	// 82A1011C: 7D684810  subfc r11, r8, r9
	ctx.xer.ca = ctx.r[9].u32 >= ctx.r[8].u32;
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82A10120: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A10124: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82A10128: 48000008  b 0x82a10130
	pc = 0x82A10130; continue 'dispatch;
            }
            0x82A1012C => {
    //   block [0x82A1012C..0x82A10130)
	// 82A1012C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A10130; continue 'dispatch;
            }
            0x82A10130 => {
    //   block [0x82A10130..0x82A10148)
	// 82A10130: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A10134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A10138: 419A0010  beq cr6, 0x82a10148
	if ctx.cr[6].eq {
	pc = 0x82A10148; continue 'dispatch;
	}
	// 82A1013C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A10140: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A10144: 4BFFFE6D  bl 0x82a0ffb0
	ctx.lr = 0x82A10148;
	sub_82A0FFB0(ctx, base);
	pc = 0x82A10148; continue 'dispatch;
            }
            0x82A10148 => {
    //   block [0x82A10148..0x82A10168)
	// 82A10148: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1014C: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A10150: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10154: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10158: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A1015C: 4098000C  bge cr6, 0x82a10168
	if !ctx.cr[6].lt {
	pc = 0x82A10168; continue 'dispatch;
	}
	// 82A10160: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A10164: 4800001C  b 0x82a10180
	pc = 0x82A10180; continue 'dispatch;
            }
            0x82A10168 => {
    //   block [0x82A10168..0x82A1017C)
	// 82A10168: 409A0014  bne cr6, 0x82a1017c
	if !ctx.cr[6].eq {
	pc = 0x82A1017C; continue 'dispatch;
	}
	// 82A1016C: 7D684810  subfc r11, r8, r9
	ctx.xer.ca = ctx.r[9].u32 >= ctx.r[8].u32;
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82A10170: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A10174: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82A10178: 48000008  b 0x82a10180
	pc = 0x82A10180; continue 'dispatch;
            }
            0x82A1017C => {
    //   block [0x82A1017C..0x82A10180)
	// 82A1017C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A10180; continue 'dispatch;
            }
            0x82A10180 => {
    //   block [0x82A10180..0x82A10198)
	// 82A10180: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A10184: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A10188: 419A0010  beq cr6, 0x82a10198
	if ctx.cr[6].eq {
	pc = 0x82A10198; continue 'dispatch;
	}
	// 82A1018C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A10190: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A10194: 4BFFFE1D  bl 0x82a0ffb0
	ctx.lr = 0x82A10198;
	sub_82A0FFB0(ctx, base);
	pc = 0x82A10198; continue 'dispatch;
            }
            0x82A10198 => {
    //   block [0x82A10198..0x82A101A0)
	// 82A10198: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1019C: 482992B8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A101A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A101A0 size=412
    let mut pc: u32 = 0x82A101A0;
    'dispatch: loop {
        match pc {
            0x82A101A0 => {
    //   block [0x82A101A0..0x82A101D8)
	// 82A101A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A101A4: 4829924D  bl 0x82ca93f0
	ctx.lr = 0x82A101A8;
	sub_82CA93D0(ctx, base);
	// 82A101A8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A101AC: 39640001  addi r11, r4, 1
	ctx.r[11].s64 = ctx.r[4].s64 + 1;
	// 82A101B0: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82A101B4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A101B8: 557D083C  slwi r29, r11, 1
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82A101BC: FB0100C0  std r24, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[24].u64 ) };
	// 82A101C0: 838100C4  lwz r28, 0xc4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A101C4: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82A101C8: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 82A101CC: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82A101D0: 7F1DD000  cmpw cr6, r29, r26
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[26].s32, &mut ctx.xer);
	// 82A101D4: 409800BC  bge cr6, 0x82a10290
	if !ctx.cr[6].lt {
	pc = 0x82A10290; continue 'dispatch;
	}
	pc = 0x82A101D8; continue 'dispatch;
            }
            0x82A101D8 => {
    //   block [0x82A101D8..0x82A10208)
	// 82A101D8: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A101DC: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82A101E0: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 82A101E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A101E8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A101EC: 812BFFF8  lwz r9, -8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A101F0: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A101F4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A101F8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A101FC: 4098000C  bge cr6, 0x82a10208
	if !ctx.cr[6].lt {
	pc = 0x82A10208; continue 'dispatch;
	}
	// 82A10200: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A10204: 4800001C  b 0x82a10220
	pc = 0x82A10220; continue 'dispatch;
            }
            0x82A10208 => {
    //   block [0x82A10208..0x82A1021C)
	// 82A10208: 409A0014  bne cr6, 0x82a1021c
	if !ctx.cr[6].eq {
	pc = 0x82A1021C; continue 'dispatch;
	}
	// 82A1020C: 7D694010  subfc r11, r9, r8
	ctx.xer.ca = ctx.r[8].u32 >= ctx.r[9].u32;
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82A10210: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A10214: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82A10218: 48000008  b 0x82a10220
	pc = 0x82A10220; continue 'dispatch;
            }
            0x82A1021C => {
    //   block [0x82A1021C..0x82A10220)
	// 82A1021C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A10220; continue 'dispatch;
            }
            0x82A10220 => {
    //   block [0x82A10220..0x82A10230)
	// 82A10220: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A10224: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A10228: 419A0008  beq cr6, 0x82a10230
	if ctx.cr[6].eq {
	pc = 0x82A10230; continue 'dispatch;
	}
	// 82A1022C: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	pc = 0x82A10230; continue 'dispatch;
            }
            0x82A10230 => {
    //   block [0x82A10230..0x82A10278)
	// 82A10230: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A10234: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A10238: 7FCAE214  add r30, r10, r28
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 82A1023C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82A10240: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10244: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10248: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1024C: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A10250: 419A0028  beq cr6, 0x82a10278
	if ctx.cr[6].eq {
	pc = 0x82A10278; continue 'dispatch;
	}
	// 82A10254: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A10258: 4B7A78C1  bl 0x821b7b18
	ctx.lr = 0x82A1025C;
	sub_821B7B18(ctx, base);
	// 82A1025C: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A10260: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A10264: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A10268: 419A0010  beq cr6, 0x82a10278
	if ctx.cr[6].eq {
	pc = 0x82A10278; continue 'dispatch;
	}
	// 82A1026C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A10270: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A10274: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A10278; continue 'dispatch;
            }
            0x82A10278 => {
    //   block [0x82A10278..0x82A10290)
	// 82A10278: 397D0001  addi r11, r29, 1
	ctx.r[11].s64 = ctx.r[29].s64 + 1;
	// 82A1027C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A10280: 557D083C  slwi r29, r11, 1
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82A10284: 7F1DD000  cmpw cr6, r29, r26
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[26].s32, &mut ctx.xer);
	// 82A10288: 4198FF50  blt cr6, 0x82a101d8
	if ctx.cr[6].lt {
	pc = 0x82A101D8; continue 'dispatch;
	}
	// 82A1028C: 7F1DD000  cmpw cr6, r29, r26
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[26].s32, &mut ctx.xer);
	pc = 0x82A10290; continue 'dispatch;
            }
            0x82A10290 => {
    //   block [0x82A10290..0x82A102E0)
	// 82A10290: 409A0054  bne cr6, 0x82a102e4
	if !ctx.cr[6].eq {
	pc = 0x82A102E4; continue 'dispatch;
	}
	// 82A10294: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A10298: 574B1838  slwi r11, r26, 3
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1029C: 7FCAE214  add r30, r10, r28
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 82A102A0: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82A102A4: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 82A102A8: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A102AC: 83EBFFFC  lwz r31, -4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82A102B0: 83ABFFF8  lwz r29, -8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A102B4: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A102B8: 419A0028  beq cr6, 0x82a102e0
	if ctx.cr[6].eq {
	pc = 0x82A102E0; continue 'dispatch;
	}
	// 82A102BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A102C0: 4B7A7859  bl 0x821b7b18
	ctx.lr = 0x82A102C4;
	sub_821B7B18(ctx, base);
	// 82A102C4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A102C8: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A102CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A102D0: 419A0010  beq cr6, 0x82a102e0
	if ctx.cr[6].eq {
	pc = 0x82A102E0; continue 'dispatch;
	}
	// 82A102D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A102D8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A102DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A102E0; continue 'dispatch;
            }
            0x82A102E0 => {
    //   block [0x82A102E0..0x82A102E4)
	// 82A102E0: 389AFFFF  addi r4, r26, -1
	ctx.r[4].s64 = ctx.r[26].s64 + -1;
	pc = 0x82A102E4; continue 'dispatch;
            }
            0x82A102E4 => {
    //   block [0x82A102E4..0x82A102FC)
	// 82A102E4: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A102E8: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A102EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A102F0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A102F4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A102F8: 419A0020  beq cr6, 0x82a10318
	if ctx.cr[6].eq {
	pc = 0x82A10318; continue 'dispatch;
	}
	pc = 0x82A102FC; continue 'dispatch;
            }
            0x82A102FC => {
    //   block [0x82A102FC..0x82A10318)
	// 82A102FC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A10300: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A10304: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A10308: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1030C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A10310: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A10314: 4082FFE8  bne 0x82a102fc
	if !ctx.cr[0].eq {
	pc = 0x82A102FC; continue 'dispatch;
	}
	pc = 0x82A10318; continue 'dispatch;
            }
            0x82A10318 => {
    //   block [0x82A10318..0x82A1033C)
	// 82A10318: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 82A1031C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A10320: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 82A10324: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A10328: 48000019  bl 0x82a10340
	ctx.lr = 0x82A1032C;
	sub_82A10340(ctx, base);
	// 82A1032C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A10330: 4B7A77E9  bl 0x821b7b18
	ctx.lr = 0x82A10334;
	sub_821B7B18(ctx, base);
	// 82A10334: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A10338: 48299108  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A10340(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A10340 size=292
    let mut pc: u32 = 0x82A10340;
    'dispatch: loop {
        match pc {
            0x82A10340 => {
    //   block [0x82A10340..0x82A10370)
	// 82A10340: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A10344: 482990B9  bl 0x82ca93fc
	ctx.lr = 0x82A10348;
	sub_82CA93D0(ctx, base);
	// 82A10348: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1034C: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82A10350: F86100A0  std r3, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[3].u64 ) };
	// 82A10354: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82A10358: 838100A4  lwz r28, 0xa4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A1035C: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A10360: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82A10364: 7F192000  cmpw cr6, r25, r4
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82A10368: 7F6A0194  addze r27, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[27].s64 = tmp.s64;
	// 82A1036C: 409800A8  bge cr6, 0x82a10414
	if !ctx.cr[6].lt {
	pc = 0x82A10414; continue 'dispatch;
	}
	pc = 0x82A10370; continue 'dispatch;
            }
            0x82A10370 => {
    //   block [0x82A10370..0x82A10398)
	// 82A10370: 576B1838  slwi r11, r27, 3
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A10374: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A10378: 7CEBE214  add r7, r11, r28
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82A1037C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10380: 81070000  lwz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A10384: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10388: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A1038C: 4098000C  bge cr6, 0x82a10398
	if !ctx.cr[6].lt {
	pc = 0x82A10398; continue 'dispatch;
	}
	// 82A10390: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A10394: 4800001C  b 0x82a103b0
	pc = 0x82A103B0; continue 'dispatch;
            }
            0x82A10398 => {
    //   block [0x82A10398..0x82A103AC)
	// 82A10398: 409A0014  bne cr6, 0x82a103ac
	if !ctx.cr[6].eq {
	pc = 0x82A103AC; continue 'dispatch;
	}
	// 82A1039C: 7D694010  subfc r11, r9, r8
	ctx.xer.ca = ctx.r[8].u32 >= ctx.r[9].u32;
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82A103A0: 7D4B5910  subfe r10, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82A103A4: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82A103A8: 48000008  b 0x82a103b0
	pc = 0x82A103B0; continue 'dispatch;
            }
            0x82A103AC => {
    //   block [0x82A103AC..0x82A103B0)
	// 82A103AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A103B0; continue 'dispatch;
            }
            0x82A103B0 => {
    //   block [0x82A103B0..0x82A103FC)
	// 82A103B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A103B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A103B8: 419A005C  beq cr6, 0x82a10414
	if ctx.cr[6].eq {
	pc = 0x82A10414; continue 'dispatch;
	}
	// 82A103BC: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A103C0: 83E70004  lwz r31, 4(r7)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A103C4: 83A70000  lwz r29, 0(r7)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A103C8: 7FCBE214  add r30, r11, r28
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82A103CC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A103D0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A103D4: 419A0028  beq cr6, 0x82a103fc
	if ctx.cr[6].eq {
	pc = 0x82A103FC; continue 'dispatch;
	}
	// 82A103D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A103DC: 4B7A773D  bl 0x821b7b18
	ctx.lr = 0x82A103E0;
	sub_821B7B18(ctx, base);
	// 82A103E0: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A103E4: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A103E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A103EC: 419A0010  beq cr6, 0x82a103fc
	if ctx.cr[6].eq {
	pc = 0x82A103FC; continue 'dispatch;
	}
	// 82A103F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A103F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A103F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A103FC; continue 'dispatch;
            }
            0x82A103FC => {
    //   block [0x82A103FC..0x82A10414)
	// 82A103FC: 397BFFFF  addi r11, r27, -1
	ctx.r[11].s64 = ctx.r[27].s64 + -1;
	// 82A10400: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A10404: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A10408: 7F192000  cmpw cr6, r25, r4
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82A1040C: 7F6A0194  addze r27, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[27].s64 = tmp.s64;
	// 82A10410: 4198FF60  blt cr6, 0x82a10370
	if ctx.cr[6].lt {
	pc = 0x82A10370; continue 'dispatch;
	}
	pc = 0x82A10414; continue 'dispatch;
            }
            0x82A10414 => {
    //   block [0x82A10414..0x82A10454)
	// 82A10414: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A10418: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1041C: 83BA0000  lwz r29, 0(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A10420: 7FCBE214  add r30, r11, r28
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82A10424: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10428: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A1042C: 419A0028  beq cr6, 0x82a10454
	if ctx.cr[6].eq {
	pc = 0x82A10454; continue 'dispatch;
	}
	// 82A10430: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A10434: 4B7A76E5  bl 0x821b7b18
	ctx.lr = 0x82A10438;
	sub_821B7B18(ctx, base);
	// 82A10438: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A1043C: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A10440: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A10444: 419A0010  beq cr6, 0x82a10454
	if ctx.cr[6].eq {
	pc = 0x82A10454; continue 'dispatch;
	}
	// 82A10448: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1044C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A10450: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A10454; continue 'dispatch;
            }
            0x82A10454 => {
    //   block [0x82A10454..0x82A10464)
	// 82A10454: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A10458: 4B7A76C1  bl 0x821b7b18
	ctx.lr = 0x82A1045C;
	sub_821B7B18(ctx, base);
	// 82A1045C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A10460: 48298FEC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A10468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A10468 size=240
    let mut pc: u32 = 0x82A10468;
    'dispatch: loop {
        match pc {
            0x82A10468 => {
    //   block [0x82A10468..0x82A104A8)
	// 82A10468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1046C: 48298F8D  bl 0x82ca93f8
	ctx.lr = 0x82A10470;
	sub_82CA93D0(ctx, base);
	// 82A10470: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A10474: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A10478: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 82A1047C: FB2100C0  std r25, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[25].u64 ) };
	// 82A10480: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 82A10484: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A10488: 3BEBFFF8  addi r31, r11, -8
	ctx.r[31].s64 = ctx.r[11].s64 + -8;
	// 82A1048C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82A10490: 83AA0004  lwz r29, 4(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10494: 834A0000  lwz r26, 0(r10)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A10498: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A1049C: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 82A104A0: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82A104A4: 419A0020  beq cr6, 0x82a104c4
	if ctx.cr[6].eq {
	pc = 0x82A104C4; continue 'dispatch;
	}
	pc = 0x82A104A8; continue 'dispatch;
            }
            0x82A104A8 => {
    //   block [0x82A104A8..0x82A104C4)
	// 82A104A8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A104AC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A104B0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A104B4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A104B8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A104BC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A104C0: 4082FFE8  bne 0x82a104a8
	if !ctx.cr[0].eq {
	pc = 0x82A104A8; continue 'dispatch;
	}
	pc = 0x82A104C4; continue 'dispatch;
            }
            0x82A104C4 => {
    //   block [0x82A104C4..0x82A10500)
	// 82A104C4: 836100C4  lwz r27, 0xc4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A104C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A104CC: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A104D0: 839B0000  lwz r28, 0(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A104D4: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A104D8: 419A0028  beq cr6, 0x82a10500
	if ctx.cr[6].eq {
	pc = 0x82A10500; continue 'dispatch;
	}
	// 82A104DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A104E0: 4B7A7639  bl 0x821b7b18
	ctx.lr = 0x82A104E4;
	sub_821B7B18(ctx, base);
	// 82A104E4: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A104E8: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A104EC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A104F0: 419A0010  beq cr6, 0x82a10500
	if ctx.cr[6].eq {
	pc = 0x82A10500; continue 'dispatch;
	}
	// 82A104F4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A104F8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A104FC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A10500; continue 'dispatch;
            }
            0x82A10500 => {
    //   block [0x82A10500..0x82A10510)
	// 82A10500: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82A10504: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A10508: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A1050C: 419A0020  beq cr6, 0x82a1052c
	if ctx.cr[6].eq {
	pc = 0x82A1052C; continue 'dispatch;
	}
	pc = 0x82A10510; continue 'dispatch;
            }
            0x82A10510 => {
    //   block [0x82A10510..0x82A1052C)
	// 82A10510: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A10514: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A10518: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A1051C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A10520: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A10524: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A10528: 4082FFE8  bne 0x82a10510
	if !ctx.cr[0].eq {
	pc = 0x82A10510; continue 'dispatch;
	}
	pc = 0x82A1052C; continue 'dispatch;
            }
            0x82A1052C => {
    //   block [0x82A1052C..0x82A10558)
	// 82A1052C: 7D7BF850  subf r11, r27, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[27].s64;
	// 82A10530: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 82A10534: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A10538: 7D651E70  srawi r5, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A1053C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A10540: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A10544: 4BFFFC5D  bl 0x82a101a0
	ctx.lr = 0x82A10548;
	sub_82A101A0(ctx, base);
	// 82A10548: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1054C: 4B7A75CD  bl 0x821b7b18
	ctx.lr = 0x82A10550;
	sub_821B7B18(ctx, base);
	// 82A10550: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A10554: 48298EF4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A10558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A10558 size=488
    let mut pc: u32 = 0x82A10558;
    'dispatch: loop {
        match pc {
            0x82A10558 => {
    //   block [0x82A10558..0x82A1059C)
	// 82A10558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1055C: 48298E85  bl 0x82ca93e0
	ctx.lr = 0x82A10560;
	sub_82CA93D0(ctx, base);
	// 82A10560: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A10564: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 82A10568: FAE10110  std r23, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[23].u64 ) };
	// 82A1056C: F8A10120  std r5, 0x120(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[5].u64 ) };
	// 82A10570: 82610124  lwz r19, 0x124(r1)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 82A10574: F8810118  std r4, 0x118(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[4].u64 ) };
	// 82A10578: 82C10114  lwz r22, 0x114(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 82A1057C: 8161011C  lwz r11, 0x11c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 82A10580: 7D565850  subf r10, r22, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[22].s64;
	// 82A10584: 7D369850  subf r9, r22, r19
	ctx.r[9].s64 = ctx.r[19].s64 - ctx.r[22].s64;
	// 82A10588: 7D591E71  srawi. r25, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[25].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 82A1058C: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82A10590: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82A10594: 7D344B78  mr r20, r9
	ctx.r[20].u64 = ctx.r[9].u64;
	// 82A10598: 4182001C  beq 0x82a105b4
	if ctx.cr[0].eq {
	pc = 0x82A105B4; continue 'dispatch;
	}
	pc = 0x82A1059C; continue 'dispatch;
            }
            0x82A1059C => {
    //   block [0x82A1059C..0x82A105B4)
	// 82A1059C: 7D545BD6  divw r10, r20, r11
	ctx.r[10].s32 = ctx.r[20].s32 / ctx.r[11].s32;
	// 82A105A0: 7D0A59D6  mullw r8, r10, r11
	ctx.r[8].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82A105A4: 7D48A051  subf. r10, r8, r20
	ctx.r[10].s64 = ctx.r[20].s64 - ctx.r[8].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A105A8: 7D745B78  mr r20, r11
	ctx.r[20].u64 = ctx.r[11].u64;
	// 82A105AC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A105B0: 4082FFEC  bne 0x82a1059c
	if !ctx.cr[0].eq {
	pc = 0x82A1059C; continue 'dispatch;
	}
	pc = 0x82A105B4; continue 'dispatch;
            }
            0x82A105B4 => {
    //   block [0x82A105B4..0x82A105D0)
	// 82A105B4: 7F144800  cmpw cr6, r20, r9
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A105B8: 40980180  bge cr6, 0x82a10738
	if !ctx.cr[6].lt {
	pc = 0x82A10738; continue 'dispatch;
	}
	// 82A105BC: 2F140000  cmpwi cr6, r20, 0
	ctx.cr[6].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 82A105C0: 40990178  ble cr6, 0x82a10738
	if !ctx.cr[6].gt {
	pc = 0x82A10738; continue 'dispatch;
	}
	// 82A105C4: 568B1838  slwi r11, r20, 3
	ctx.r[11].u32 = ctx.r[20].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A105C8: 57351838  slwi r21, r25, 3
	ctx.r[21].u32 = ctx.r[25].u32.wrapping_shl(3);
	ctx.r[21].u64 = ctx.r[21].u32 as u64;
	// 82A105CC: 7F4BB214  add r26, r11, r22
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[22].u64;
	pc = 0x82A105D0; continue 'dispatch;
            }
            0x82A105D0 => {
    //   block [0x82A105D0..0x82A105F8)
	// 82A105D0: FAE10058  std r23, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u64 ) };
	// 82A105D4: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82A105D8: 831A0004  lwz r24, 4(r26)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A105DC: 825A0000  lwz r18, 0(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A105E0: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82A105E4: 93010064  stw r24, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[24].u32 ) };
	// 82A105E8: 92410060  stw r18, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[18].u32 ) };
	// 82A105EC: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A105F0: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82A105F4: 419A0020  beq cr6, 0x82a10614
	if ctx.cr[6].eq {
	pc = 0x82A10614; continue 'dispatch;
	}
	pc = 0x82A105F8; continue 'dispatch;
            }
            0x82A105F8 => {
    //   block [0x82A105F8..0x82A10614)
	// 82A105F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A105FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A10600: 7D60C028  lwarx r11, 0, r24
	// lwarx
	let ea = ctx.r[24].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A10604: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A10608: 7D60C12D  stwcx. r11, 0, r24
	// stwcx.
	let addr = ctx.r[24].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1060C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A10610: 4082FFE8  bne 0x82a105f8
	if !ctx.cr[0].eq {
	pc = 0x82A105F8; continue 'dispatch;
	}
	pc = 0x82A10614; continue 'dispatch;
            }
            0x82A10614 => {
    //   block [0x82A10614..0x82A10628)
	// 82A10614: 7D7AAA14  add r11, r26, r21
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[21].u64;
	// 82A10618: 7F0B9840  cmplw cr6, r11, r19
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[19].u32, &mut ctx.xer);
	// 82A1061C: 409A000C  bne cr6, 0x82a10628
	if !ctx.cr[6].eq {
	pc = 0x82A10628; continue 'dispatch;
	}
	// 82A10620: 39410110  addi r10, r1, 0x110
	ctx.r[10].s64 = ctx.r[1].s64 + 272;
	// 82A10624: 48000018  b 0x82a1063c
	pc = 0x82A1063C; continue 'dispatch;
            }
            0x82A10628 => {
    //   block [0x82A10628..0x82A1063C)
	// 82A10628: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82A1062C: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 82A10630: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A10634: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A10638: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	pc = 0x82A1063C; continue 'dispatch;
            }
            0x82A1063C => {
    //   block [0x82A1063C..0x82A10650)
	// 82A1063C: EB6A0000  ld r27, 0(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82A10640: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 82A10644: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A10648: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A1064C: 419A00A4  beq cr6, 0x82a106f0
	if ctx.cr[6].eq {
	pc = 0x82A106F0; continue 'dispatch;
	}
	pc = 0x82A10650; continue 'dispatch;
            }
            0x82A10650 => {
    //   block [0x82A10650..0x82A1068C)
	// 82A10650: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A10654: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10658: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1065C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10660: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A10664: 419A0028  beq cr6, 0x82a1068c
	if ctx.cr[6].eq {
	pc = 0x82A1068C; continue 'dispatch;
	}
	// 82A10668: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1066C: 4B7A74AD  bl 0x821b7b18
	ctx.lr = 0x82A10670;
	sub_821B7B18(ctx, base);
	// 82A10670: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A10674: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A10678: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A1067C: 419A0010  beq cr6, 0x82a1068c
	if ctx.cr[6].eq {
	pc = 0x82A1068C; continue 'dispatch;
	}
	// 82A10680: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A10684: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A10688: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A1068C; continue 'dispatch;
            }
            0x82A1068C => {
    //   block [0x82A1068C..0x82A106BC)
	// 82A1068C: 7D7F9850  subf r11, r31, r19
	ctx.r[11].s64 = ctx.r[19].s64 - ctx.r[31].s64;
	// 82A10690: FB610058  std r27, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u64 ) };
	// 82A10694: 7D6B1E70  srawi r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A10698: 7F195800  cmpw cr6, r25, r11
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A1069C: 40980020  bge cr6, 0x82a106bc
	if !ctx.cr[6].lt {
	pc = 0x82A106BC; continue 'dispatch;
	}
	// 82A106A0: 7D55FA14  add r10, r21, r31
	ctx.r[10].u64 = ctx.r[21].u64 + ctx.r[31].u64;
	// 82A106A4: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 82A106A8: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82A106AC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A106B0: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A106B4: F9210070  std r9, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u64 ) };
	// 82A106B8: 48000024  b 0x82a106dc
	pc = 0x82A106DC; continue 'dispatch;
            }
            0x82A106BC => {
    //   block [0x82A106BC..0x82A106DC)
	// 82A106BC: FAE10050  std r23, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u64 ) };
	// 82A106C0: 7D4BC850  subf r10, r11, r25
	ctx.r[10].s64 = ctx.r[25].s64 - ctx.r[11].s64;
	// 82A106C4: 39610078  addi r11, r1, 0x78
	ctx.r[11].s64 = ctx.r[1].s64 + 120;
	// 82A106C8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A106CC: 7D2AB214  add r9, r10, r22
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[22].u64;
	// 82A106D0: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A106D4: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A106D8: F9010078  std r8, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[8].u64 ) };
	pc = 0x82A106DC; continue 'dispatch;
            }
            0x82A106DC => {
    //   block [0x82A106DC..0x82A106F0)
	// 82A106DC: EB6B0000  ld r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A106E0: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 82A106E4: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A106E8: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A106EC: 409AFF64  bne cr6, 0x82a10650
	if !ctx.cr[6].eq {
	pc = 0x82A10650; continue 'dispatch;
	}
	pc = 0x82A106F0; continue 'dispatch;
            }
            0x82A106F0 => {
    //   block [0x82A106F0..0x82A10724)
	// 82A106F0: 83E1005C  lwz r31, 0x5c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A106F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A106F8: 7F0BC040  cmplw cr6, r11, r24
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A106FC: 419A0028  beq cr6, 0x82a10724
	if ctx.cr[6].eq {
	pc = 0x82A10724; continue 'dispatch;
	}
	// 82A10700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A10704: 4B7A7415  bl 0x821b7b18
	ctx.lr = 0x82A10708;
	sub_821B7B18(ctx, base);
	// 82A10708: 925F0000  stw r18, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[18].u32 ) };
	// 82A1070C: 931F0004  stw r24, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 82A10710: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82A10714: 419A0010  beq cr6, 0x82a10724
	if ctx.cr[6].eq {
	pc = 0x82A10724; continue 'dispatch;
	}
	// 82A10718: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1071C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A10720: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A10724; continue 'dispatch;
            }
            0x82A10724 => {
    //   block [0x82A10724..0x82A10738)
	// 82A10724: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A10728: 4B7A73F1  bl 0x821b7b18
	ctx.lr = 0x82A1072C;
	sub_821B7B18(ctx, base);
	// 82A1072C: 3694FFFF  addic. r20, r20, -1
	ctx.xer.ca = (ctx.r[20].u32 > (!(-1 as u32)));
	ctx.r[20].s64 = ctx.r[20].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 82A10730: 3B5AFFF8  addi r26, r26, -8
	ctx.r[26].s64 = ctx.r[26].s64 + -8;
	// 82A10734: 4181FE9C  bgt 0x82a105d0
	if ctx.cr[0].gt {
	pc = 0x82A105D0; continue 'dispatch;
	}
	pc = 0x82A10738; continue 'dispatch;
            }
            0x82A10738 => {
    //   block [0x82A10738..0x82A10740)
	// 82A10738: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82A1073C: 48298CF4  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A10740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A10740 size=120
    let mut pc: u32 = 0x82A10740;
    'dispatch: loop {
        match pc {
            0x82A10740 => {
    //   block [0x82A10740..0x82A107B8)
	// 82A10740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A10744: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A10748: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1074C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A10750: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A10754: F8810090  std r4, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[4].u64 ) };
	// 82A10758: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A1075C: F8A10098  std r5, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[5].u64 ) };
	// 82A10760: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A10764: 39200050  li r9, 0x50
	ctx.r[9].s64 = 80;
	// 82A10768: 387F0020  addi r3, r31, 0x20
	ctx.r[3].s64 = ctx.r[31].s64 + 32;
	// 82A1076C: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A10770: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A107B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A107B8 size=708
    let mut pc: u32 = 0x82A107B8;
    'dispatch: loop {
        match pc {
            0x82A107B8 => {
    //   block [0x82A107B8..0x82A10818)
	// 82A107B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A107BC: 48298C45  bl 0x82ca9400
	ctx.lr = 0x82A107C0;
	sub_82CA93D0(ctx, base);
	// 82A107C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A107C4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A107C8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82A107CC: 7F1AD840  cmplw cr6, r26, r27
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A107D0: 419A02A0  beq cr6, 0x82a10a70
	if ctx.cr[6].eq {
	pc = 0x82A10A70; continue 'dispatch;
	}
	// 82A107D4: 83DB0008  lwz r30, 8(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A107D8: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A107DC: 7D7FF050  subf r11, r31, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82A107E0: 7D692671  srawi. r9, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 4) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A107E4: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A107E8: 4082008C  bne 0x82a10874
	if !ctx.cr[0].eq {
	pc = 0x82A10874; continue 'dispatch;
	}
	// 82A107EC: 83FA0008  lwz r31, 8(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A107F0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A107F4: 419A027C  beq cr6, 0x82a10a70
	if ctx.cr[6].eq {
	pc = 0x82A10A70; continue 'dispatch;
	}
	// 82A107F8: 7D5FF850  subf r10, r31, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[31].s64;
	// 82A107FC: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82A10800: 7D492670  srawi r9, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 82A10804: 7F1FF840  cmplw cr6, r31, r31
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A10808: 552A2036  slwi r10, r9, 4
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1080C: 7F6A5A14  add r27, r10, r11
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A10810: 419A0020  beq cr6, 0x82a10830
	if ctx.cr[6].eq {
	pc = 0x82A10830; continue 'dispatch;
	}
	// 82A10814: 7FBF5850  subf r29, r31, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	pc = 0x82A10818; continue 'dispatch;
            }
            0x82A10818 => {
    //   block [0x82A10818..0x82A10830)
	// 82A10818: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1081C: 7C7DF214  add r3, r29, r30
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 82A10820: 48004901  bl 0x82a15120
	ctx.lr = 0x82A10824;
	sub_82A15120(ctx, base);
	// 82A10824: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82A10828: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A1082C: 409AFFEC  bne cr6, 0x82a10818
	if !ctx.cr[6].eq {
	pc = 0x82A10818; continue 'dispatch;
	}
	pc = 0x82A10830; continue 'dispatch;
            }
            0x82A10830 => {
    //   block [0x82A10830..0x82A10844)
	// 82A10830: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A10834: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A10838: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A1083C: 419A0028  beq cr6, 0x82a10864
	if ctx.cr[6].eq {
	pc = 0x82A10864; continue 'dispatch;
	}
	// 82A10840: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82A10844; continue 'dispatch;
            }
            0x82A10844 => {
    //   block [0x82A10844..0x82A10858)
	// 82A10844: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A10848: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1084C: 419A000C  beq cr6, 0x82a10858
	if ctx.cr[6].eq {
	pc = 0x82A10858; continue 'dispatch;
	}
	// 82A10850: 4B80B4E9  bl 0x8221bd38
	ctx.lr = 0x82A10854;
	sub_8221BD38(ctx, base);
	// 82A10854: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82A10858; continue 'dispatch;
            }
            0x82A10858 => {
    //   block [0x82A10858..0x82A10864)
	// 82A10858: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82A1085C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A10860: 409AFFE4  bne cr6, 0x82a10844
	if !ctx.cr[6].eq {
	pc = 0x82A10844; continue 'dispatch;
	}
	pc = 0x82A10864; continue 'dispatch;
            }
            0x82A10864 => {
    //   block [0x82A10864..0x82A10874)
	// 82A10864: 937A0008  stw r27, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82A10868: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A1086C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A10870: 48298BE0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A10874 => {
    //   block [0x82A10874..0x82A108A4)
	// 82A10874: 83BA0008  lwz r29, 8(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A10878: 7D4BE850  subf r10, r11, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 82A1087C: 7D4A2670  srawi r10, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 82A10880: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A10884: 41990098  bgt cr6, 0x82a1091c
	if ctx.cr[6].gt {
	pc = 0x82A1091C; continue 'dispatch;
	}
	// 82A10888: 7D5FF050  subf r10, r31, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82A1088C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A10890: 7D492670  srawi r9, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 82A10894: 552A2036  slwi r10, r9, 4
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A10898: 7F8A5A14  add r28, r10, r11
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A1089C: 419A0020  beq cr6, 0x82a108bc
	if ctx.cr[6].eq {
	pc = 0x82A108BC; continue 'dispatch;
	}
	// 82A108A0: 7FBF5850  subf r29, r31, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	pc = 0x82A108A4; continue 'dispatch;
            }
            0x82A108A4 => {
    //   block [0x82A108A4..0x82A108BC)
	// 82A108A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A108A8: 7C7DFA14  add r3, r29, r31
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 82A108AC: 48004875  bl 0x82a15120
	ctx.lr = 0x82A108B0;
	sub_82A15120(ctx, base);
	// 82A108B0: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82A108B4: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A108B8: 409AFFEC  bne cr6, 0x82a108a4
	if !ctx.cr[6].eq {
	pc = 0x82A108A4; continue 'dispatch;
	}
	pc = 0x82A108BC; continue 'dispatch;
            }
            0x82A108BC => {
    //   block [0x82A108BC..0x82A108D0)
	// 82A108BC: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A108C0: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A108C4: 7F1CF040  cmplw cr6, r28, r30
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A108C8: 419A0028  beq cr6, 0x82a108f0
	if ctx.cr[6].eq {
	pc = 0x82A108F0; continue 'dispatch;
	}
	// 82A108CC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82A108D0; continue 'dispatch;
            }
            0x82A108D0 => {
    //   block [0x82A108D0..0x82A108E4)
	// 82A108D0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A108D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A108D8: 419A000C  beq cr6, 0x82a108e4
	if ctx.cr[6].eq {
	pc = 0x82A108E4; continue 'dispatch;
	}
	// 82A108DC: 4B80B45D  bl 0x8221bd38
	ctx.lr = 0x82A108E0;
	sub_8221BD38(ctx, base);
	// 82A108E0: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82A108E4; continue 'dispatch;
            }
            0x82A108E4 => {
    //   block [0x82A108E4..0x82A108F0)
	// 82A108E4: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82A108E8: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A108EC: 409AFFE4  bne cr6, 0x82a108d0
	if !ctx.cr[6].eq {
	pc = 0x82A108D0; continue 'dispatch;
	}
	pc = 0x82A108F0; continue 'dispatch;
            }
            0x82A108F0 => {
    //   block [0x82A108F0..0x82A1091C)
	// 82A108F0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A108F4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A108F8: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A108FC: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10900: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A10904: 7D072670  srawi r7, r8, 4
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 4) as i64;
	// 82A10908: 54EB2036  slwi r11, r7, 4
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1090C: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A10910: 90DA0008  stw r6, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82A10914: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A10918: 48298B38  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A1091C => {
    //   block [0x82A1091C..0x82A10930)
	// 82A1091C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A10920: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A10924: 409A000C  bne cr6, 0x82a10930
	if !ctx.cr[6].eq {
	pc = 0x82A10930; continue 'dispatch;
	}
	// 82A10928: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82A1092C: 48000010  b 0x82a1093c
	pc = 0x82A1093C; continue 'dispatch;
            }
            0x82A10930 => {
    //   block [0x82A10930..0x82A1093C)
	// 82A10930: 811A000C  lwz r8, 0xc(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A10934: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82A10938: 7CE82670  srawi r8, r7, 4
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[7].s32 >> 4) as i64;
	pc = 0x82A1093C; continue 'dispatch;
            }
            0x82A1093C => {
    //   block [0x82A1093C..0x82A1095C)
	// 82A1093C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A10940: 4199007C  bgt cr6, 0x82a109bc
	if ctx.cr[6].gt {
	pc = 0x82A109BC; continue 'dispatch;
	}
	// 82A10944: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10948: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1094C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82A10950: 7FEAF214  add r31, r10, r30
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A10954: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A10958: 419A0020  beq cr6, 0x82a10978
	if ctx.cr[6].eq {
	pc = 0x82A10978; continue 'dispatch;
	}
	pc = 0x82A1095C; continue 'dispatch;
            }
            0x82A1095C => {
    //   block [0x82A1095C..0x82A10978)
	// 82A1095C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A10960: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A10964: 480047BD  bl 0x82a15120
	ctx.lr = 0x82A10968;
	sub_82A15120(ctx, base);
	// 82A10968: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82A1096C: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 82A10970: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A10974: 409AFFE8  bne cr6, 0x82a1095c
	if !ctx.cr[6].eq {
	pc = 0x82A1095C; continue 'dispatch;
	}
	pc = 0x82A10978; continue 'dispatch;
            }
            0x82A10978 => {
    //   block [0x82A10978..0x82A10988)
	// 82A10978: 83BB0008  lwz r29, 8(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1097C: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A10980: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A10984: 419A00E8  beq cr6, 0x82a10a6c
	if ctx.cr[6].eq {
	pc = 0x82A10A6C; continue 'dispatch;
	}
	pc = 0x82A10988; continue 'dispatch;
            }
            0x82A10988 => {
    //   block [0x82A10988..0x82A1099C)
	// 82A10988: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A1098C: 419A0010  beq cr6, 0x82a1099c
	if ctx.cr[6].eq {
	pc = 0x82A1099C; continue 'dispatch;
	}
	// 82A10990: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A10994: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A10998: 48000CA9  bl 0x82a11640
	ctx.lr = 0x82A1099C;
	sub_82A11640(ctx, base);
	pc = 0x82A1099C; continue 'dispatch;
            }
            0x82A1099C => {
    //   block [0x82A1099C..0x82A109BC)
	// 82A1099C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82A109A0: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82A109A4: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A109A8: 409AFFE0  bne cr6, 0x82a10988
	if !ctx.cr[6].eq {
	pc = 0x82A10988; continue 'dispatch;
	}
	// 82A109AC: 93DA0008  stw r30, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A109B0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A109B4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A109B8: 48298A98  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A109BC => {
    //   block [0x82A109BC..0x82A109D0)
	// 82A109BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A109C0: 419A0038  beq cr6, 0x82a109f8
	if ctx.cr[6].eq {
	pc = 0x82A109F8; continue 'dispatch;
	}
	// 82A109C4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82A109C8: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A109CC: 419A0024  beq cr6, 0x82a109f0
	if ctx.cr[6].eq {
	pc = 0x82A109F0; continue 'dispatch;
	}
	pc = 0x82A109D0; continue 'dispatch;
            }
            0x82A109D0 => {
    //   block [0x82A109D0..0x82A109E4)
	// 82A109D0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A109D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A109D8: 419A000C  beq cr6, 0x82a109e4
	if ctx.cr[6].eq {
	pc = 0x82A109E4; continue 'dispatch;
	}
	// 82A109DC: 4B80B35D  bl 0x8221bd38
	ctx.lr = 0x82A109E0;
	sub_8221BD38(ctx, base);
	// 82A109E0: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82A109E4; continue 'dispatch;
            }
            0x82A109E4 => {
    //   block [0x82A109E4..0x82A109F0)
	// 82A109E4: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82A109E8: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A109EC: 409AFFE4  bne cr6, 0x82a109d0
	if !ctx.cr[6].eq {
	pc = 0x82A109D0; continue 'dispatch;
	}
	pc = 0x82A109F0; continue 'dispatch;
            }
            0x82A109F0 => {
    //   block [0x82A109F0..0x82A109F8)
	// 82A109F0: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A109F4: 4B80B345  bl 0x8221bd38
	ctx.lr = 0x82A109F8;
	sub_8221BD38(ctx, base);
	pc = 0x82A109F8; continue 'dispatch;
            }
            0x82A109F8 => {
    //   block [0x82A109F8..0x82A10A20)
	// 82A109F8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A109FC: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10A00: 939A0004  stw r28, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A10A04: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A10A08: 939A0008  stw r28, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82A10A0C: 939A000C  stw r28, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82A10A10: 7D242671  srawi. r4, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[9].s32 >> 4) as i64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82A10A14: 4082000C  bne 0x82a10a20
	if !ctx.cr[0].eq {
	pc = 0x82A10A20; continue 'dispatch;
	}
	// 82A10A18: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A10A1C: 4800000C  b 0x82a10a28
	pc = 0x82A10A28; continue 'dispatch;
            }
            0x82A10A20 => {
    //   block [0x82A10A20..0x82A10A28)
	// 82A10A20: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A10A24: 4B99C3AD  bl 0x823acdd0
	ctx.lr = 0x82A10A28;
	sub_823ACDD0(ctx, base);
	pc = 0x82A10A28; continue 'dispatch;
            }
            0x82A10A28 => {
    //   block [0x82A10A28..0x82A10A48)
	// 82A10A28: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A10A2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A10A30: 419A0040  beq cr6, 0x82a10a70
	if ctx.cr[6].eq {
	pc = 0x82A10A70; continue 'dispatch;
	}
	// 82A10A34: 83BB0008  lwz r29, 8(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A10A38: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10A3C: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10A40: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A10A44: 419A0028  beq cr6, 0x82a10a6c
	if ctx.cr[6].eq {
	pc = 0x82A10A6C; continue 'dispatch;
	}
	pc = 0x82A10A48; continue 'dispatch;
            }
            0x82A10A48 => {
    //   block [0x82A10A48..0x82A10A5C)
	// 82A10A48: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A10A4C: 419A0010  beq cr6, 0x82a10a5c
	if ctx.cr[6].eq {
	pc = 0x82A10A5C; continue 'dispatch;
	}
	// 82A10A50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A10A54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A10A58: 48000BE9  bl 0x82a11640
	ctx.lr = 0x82A10A5C;
	sub_82A11640(ctx, base);
	pc = 0x82A10A5C; continue 'dispatch;
            }
            0x82A10A5C => {
    //   block [0x82A10A5C..0x82A10A6C)
	// 82A10A5C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82A10A60: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82A10A64: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A10A68: 409AFFE0  bne cr6, 0x82a10a48
	if !ctx.cr[6].eq {
	pc = 0x82A10A48; continue 'dispatch;
	}
	pc = 0x82A10A6C; continue 'dispatch;
            }
            0x82A10A6C => {
    //   block [0x82A10A6C..0x82A10A70)
	// 82A10A6C: 93DA0008  stw r30, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x82A10A70; continue 'dispatch;
            }
            0x82A10A70 => {
    //   block [0x82A10A70..0x82A10A7C)
	// 82A10A70: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A10A74: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A10A78: 482989D8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A10A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A10A80 size=160
    let mut pc: u32 = 0x82A10A80;
    'dispatch: loop {
        match pc {
            0x82A10A80 => {
    //   block [0x82A10A80..0x82A10AAC)
	// 82A10A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A10A84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A10A88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A10A8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A10A90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A10A94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A10A98: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10A9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A10AA0: 409A000C  bne cr6, 0x82a10aac
	if !ctx.cr[6].eq {
	pc = 0x82A10AAC; continue 'dispatch;
	}
	// 82A10AA4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A10AA8: 48000010  b 0x82a10ab8
	pc = 0x82A10AB8; continue 'dispatch;
            }
            0x82A10AAC => {
    //   block [0x82A10AAC..0x82A10AB8)
	// 82A10AAC: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A10AB0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A10AB4: 7D2A2670  srawi r10, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 4) as i64;
	pc = 0x82A10AB8; continue 'dispatch;
            }
            0x82A10AB8 => {
    //   block [0x82A10AB8..0x82A10ADC)
	// 82A10AB8: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A10ABC: 7D6BF850  subf r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A10AC0: 7D692670  srawi r9, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 82A10AC4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A10AC8: 40980020  bge cr6, 0x82a10ae8
	if !ctx.cr[6].lt {
	pc = 0x82A10AE8; continue 'dispatch;
	}
	// 82A10ACC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A10AD0: 419A000C  beq cr6, 0x82a10adc
	if ctx.cr[6].eq {
	pc = 0x82A10ADC; continue 'dispatch;
	}
	// 82A10AD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A10AD8: 48000B69  bl 0x82a11640
	ctx.lr = 0x82A10ADC;
	sub_82A11640(ctx, base);
	pc = 0x82A10ADC; continue 'dispatch;
            }
            0x82A10ADC => {
    //   block [0x82A10ADC..0x82A10AE8)
	// 82A10ADC: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 82A10AE0: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A10AE4: 48000024  b 0x82a10b08
	pc = 0x82A10B08; continue 'dispatch;
            }
            0x82A10AE8 => {
    //   block [0x82A10AE8..0x82A10B08)
	// 82A10AE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A10AEC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A10AF0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82A10AF4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A10AF8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A10AFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A10B00: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A10B04: 480004CD  bl 0x82a10fd0
	ctx.lr = 0x82A10B08;
	sub_82A10FD0(ctx, base);
	pc = 0x82A10B08; continue 'dispatch;
            }
            0x82A10B08 => {
    //   block [0x82A10B08..0x82A10B20)
	// 82A10B08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A10B0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A10B10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A10B14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A10B18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A10B1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A10B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A10B20 size=708
    let mut pc: u32 = 0x82A10B20;
    'dispatch: loop {
        match pc {
            0x82A10B20 => {
    //   block [0x82A10B20..0x82A10B80)
	// 82A10B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A10B24: 482988DD  bl 0x82ca9400
	ctx.lr = 0x82A10B28;
	sub_82CA93D0(ctx, base);
	// 82A10B28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A10B2C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A10B30: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82A10B34: 7F1AD840  cmplw cr6, r26, r27
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A10B38: 419A02A0  beq cr6, 0x82a10dd8
	if ctx.cr[6].eq {
	pc = 0x82A10DD8; continue 'dispatch;
	}
	// 82A10B3C: 83DB0008  lwz r30, 8(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A10B40: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10B44: 7D7FF050  subf r11, r31, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82A10B48: 7D692E71  srawi. r9, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 5) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A10B4C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10B50: 4082008C  bne 0x82a10bdc
	if !ctx.cr[0].eq {
	pc = 0x82A10BDC; continue 'dispatch;
	}
	// 82A10B54: 83FA0008  lwz r31, 8(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A10B58: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A10B5C: 419A027C  beq cr6, 0x82a10dd8
	if ctx.cr[6].eq {
	pc = 0x82A10DD8; continue 'dispatch;
	}
	// 82A10B60: 7D5FF850  subf r10, r31, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[31].s64;
	// 82A10B64: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82A10B68: 7D492E70  srawi r9, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 82A10B6C: 7F1FF840  cmplw cr6, r31, r31
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A10B70: 552A2834  slwi r10, r9, 5
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A10B74: 7F6A5A14  add r27, r10, r11
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A10B78: 419A0020  beq cr6, 0x82a10b98
	if ctx.cr[6].eq {
	pc = 0x82A10B98; continue 'dispatch;
	}
	// 82A10B7C: 7FBF5850  subf r29, r31, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	pc = 0x82A10B80; continue 'dispatch;
            }
            0x82A10B80 => {
    //   block [0x82A10B80..0x82A10B98)
	// 82A10B80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A10B84: 7C7DF214  add r3, r29, r30
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 82A10B88: 480046A9  bl 0x82a15230
	ctx.lr = 0x82A10B8C;
	sub_82A15230(ctx, base);
	// 82A10B8C: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 82A10B90: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A10B94: 409AFFEC  bne cr6, 0x82a10b80
	if !ctx.cr[6].eq {
	pc = 0x82A10B80; continue 'dispatch;
	}
	pc = 0x82A10B98; continue 'dispatch;
            }
            0x82A10B98 => {
    //   block [0x82A10B98..0x82A10BAC)
	// 82A10B98: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A10B9C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A10BA0: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A10BA4: 419A0028  beq cr6, 0x82a10bcc
	if ctx.cr[6].eq {
	pc = 0x82A10BCC; continue 'dispatch;
	}
	// 82A10BA8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82A10BAC; continue 'dispatch;
            }
            0x82A10BAC => {
    //   block [0x82A10BAC..0x82A10BC0)
	// 82A10BAC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A10BB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A10BB4: 419A000C  beq cr6, 0x82a10bc0
	if ctx.cr[6].eq {
	pc = 0x82A10BC0; continue 'dispatch;
	}
	// 82A10BB8: 4B80B181  bl 0x8221bd38
	ctx.lr = 0x82A10BBC;
	sub_8221BD38(ctx, base);
	// 82A10BBC: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82A10BC0; continue 'dispatch;
            }
            0x82A10BC0 => {
    //   block [0x82A10BC0..0x82A10BCC)
	// 82A10BC0: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A10BC4: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A10BC8: 409AFFE4  bne cr6, 0x82a10bac
	if !ctx.cr[6].eq {
	pc = 0x82A10BAC; continue 'dispatch;
	}
	pc = 0x82A10BCC; continue 'dispatch;
            }
            0x82A10BCC => {
    //   block [0x82A10BCC..0x82A10BDC)
	// 82A10BCC: 937A0008  stw r27, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82A10BD0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A10BD4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A10BD8: 48298878  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A10BDC => {
    //   block [0x82A10BDC..0x82A10C0C)
	// 82A10BDC: 83BA0008  lwz r29, 8(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A10BE0: 7D4BE850  subf r10, r11, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 82A10BE4: 7D4A2E70  srawi r10, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 82A10BE8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A10BEC: 41990098  bgt cr6, 0x82a10c84
	if ctx.cr[6].gt {
	pc = 0x82A10C84; continue 'dispatch;
	}
	// 82A10BF0: 7D5FF050  subf r10, r31, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82A10BF4: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A10BF8: 7D492E70  srawi r9, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 82A10BFC: 552A2834  slwi r10, r9, 5
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A10C00: 7F8A5A14  add r28, r10, r11
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A10C04: 419A0020  beq cr6, 0x82a10c24
	if ctx.cr[6].eq {
	pc = 0x82A10C24; continue 'dispatch;
	}
	// 82A10C08: 7FBF5850  subf r29, r31, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	pc = 0x82A10C0C; continue 'dispatch;
            }
            0x82A10C0C => {
    //   block [0x82A10C0C..0x82A10C24)
	// 82A10C0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A10C10: 7C7DFA14  add r3, r29, r31
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 82A10C14: 4800461D  bl 0x82a15230
	ctx.lr = 0x82A10C18;
	sub_82A15230(ctx, base);
	// 82A10C18: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A10C1C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A10C20: 409AFFEC  bne cr6, 0x82a10c0c
	if !ctx.cr[6].eq {
	pc = 0x82A10C0C; continue 'dispatch;
	}
	pc = 0x82A10C24; continue 'dispatch;
            }
            0x82A10C24 => {
    //   block [0x82A10C24..0x82A10C38)
	// 82A10C24: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A10C28: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A10C2C: 7F1CF040  cmplw cr6, r28, r30
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A10C30: 419A0028  beq cr6, 0x82a10c58
	if ctx.cr[6].eq {
	pc = 0x82A10C58; continue 'dispatch;
	}
	// 82A10C34: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82A10C38; continue 'dispatch;
            }
            0x82A10C38 => {
    //   block [0x82A10C38..0x82A10C4C)
	// 82A10C38: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A10C3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A10C40: 419A000C  beq cr6, 0x82a10c4c
	if ctx.cr[6].eq {
	pc = 0x82A10C4C; continue 'dispatch;
	}
	// 82A10C44: 4B80B0F5  bl 0x8221bd38
	ctx.lr = 0x82A10C48;
	sub_8221BD38(ctx, base);
	// 82A10C48: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82A10C4C; continue 'dispatch;
            }
            0x82A10C4C => {
    //   block [0x82A10C4C..0x82A10C58)
	// 82A10C4C: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A10C50: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A10C54: 409AFFE4  bne cr6, 0x82a10c38
	if !ctx.cr[6].eq {
	pc = 0x82A10C38; continue 'dispatch;
	}
	pc = 0x82A10C58; continue 'dispatch;
            }
            0x82A10C58 => {
    //   block [0x82A10C58..0x82A10C84)
	// 82A10C58: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A10C5C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A10C60: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10C64: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10C68: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A10C6C: 7D072E70  srawi r7, r8, 5
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 5) as i64;
	// 82A10C70: 54EB2834  slwi r11, r7, 5
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A10C74: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A10C78: 90DA0008  stw r6, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82A10C7C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A10C80: 482987D0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A10C84 => {
    //   block [0x82A10C84..0x82A10C98)
	// 82A10C84: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A10C88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A10C8C: 409A000C  bne cr6, 0x82a10c98
	if !ctx.cr[6].eq {
	pc = 0x82A10C98; continue 'dispatch;
	}
	// 82A10C90: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 82A10C94: 48000010  b 0x82a10ca4
	pc = 0x82A10CA4; continue 'dispatch;
            }
            0x82A10C98 => {
    //   block [0x82A10C98..0x82A10CA4)
	// 82A10C98: 811A000C  lwz r8, 0xc(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A10C9C: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82A10CA0: 7CE82E70  srawi r8, r7, 5
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[7].s32 >> 5) as i64;
	pc = 0x82A10CA4; continue 'dispatch;
            }
            0x82A10CA4 => {
    //   block [0x82A10CA4..0x82A10CC4)
	// 82A10CA4: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A10CA8: 4199007C  bgt cr6, 0x82a10d24
	if ctx.cr[6].gt {
	pc = 0x82A10D24; continue 'dispatch;
	}
	// 82A10CAC: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10CB0: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A10CB4: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 82A10CB8: 7FEAF214  add r31, r10, r30
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A10CBC: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A10CC0: 419A0020  beq cr6, 0x82a10ce0
	if ctx.cr[6].eq {
	pc = 0x82A10CE0; continue 'dispatch;
	}
	pc = 0x82A10CC4; continue 'dispatch;
            }
            0x82A10CC4 => {
    //   block [0x82A10CC4..0x82A10CE0)
	// 82A10CC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A10CC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A10CCC: 48004565  bl 0x82a15230
	ctx.lr = 0x82A10CD0;
	sub_82A15230(ctx, base);
	// 82A10CD0: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 82A10CD4: 3BBD0020  addi r29, r29, 0x20
	ctx.r[29].s64 = ctx.r[29].s64 + 32;
	// 82A10CD8: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A10CDC: 409AFFE8  bne cr6, 0x82a10cc4
	if !ctx.cr[6].eq {
	pc = 0x82A10CC4; continue 'dispatch;
	}
	pc = 0x82A10CE0; continue 'dispatch;
            }
            0x82A10CE0 => {
    //   block [0x82A10CE0..0x82A10CF0)
	// 82A10CE0: 83BB0008  lwz r29, 8(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A10CE4: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A10CE8: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A10CEC: 419A00E8  beq cr6, 0x82a10dd4
	if ctx.cr[6].eq {
	pc = 0x82A10DD4; continue 'dispatch;
	}
	pc = 0x82A10CF0; continue 'dispatch;
            }
            0x82A10CF0 => {
    //   block [0x82A10CF0..0x82A10D04)
	// 82A10CF0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A10CF4: 419A0010  beq cr6, 0x82a10d04
	if ctx.cr[6].eq {
	pc = 0x82A10D04; continue 'dispatch;
	}
	// 82A10CF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A10CFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A10D00: 48000A59  bl 0x82a11758
	ctx.lr = 0x82A10D04;
	sub_82A11758(ctx, base);
	pc = 0x82A10D04; continue 'dispatch;
            }
            0x82A10D04 => {
    //   block [0x82A10D04..0x82A10D24)
	// 82A10D04: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A10D08: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 82A10D0C: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A10D10: 409AFFE0  bne cr6, 0x82a10cf0
	if !ctx.cr[6].eq {
	pc = 0x82A10CF0; continue 'dispatch;
	}
	// 82A10D14: 93DA0008  stw r30, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A10D18: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A10D1C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A10D20: 48298730  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A10D24 => {
    //   block [0x82A10D24..0x82A10D38)
	// 82A10D24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A10D28: 419A0038  beq cr6, 0x82a10d60
	if ctx.cr[6].eq {
	pc = 0x82A10D60; continue 'dispatch;
	}
	// 82A10D2C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82A10D30: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A10D34: 419A0024  beq cr6, 0x82a10d58
	if ctx.cr[6].eq {
	pc = 0x82A10D58; continue 'dispatch;
	}
	pc = 0x82A10D38; continue 'dispatch;
            }
            0x82A10D38 => {
    //   block [0x82A10D38..0x82A10D4C)
	// 82A10D38: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A10D3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A10D40: 419A000C  beq cr6, 0x82a10d4c
	if ctx.cr[6].eq {
	pc = 0x82A10D4C; continue 'dispatch;
	}
	// 82A10D44: 4B80AFF5  bl 0x8221bd38
	ctx.lr = 0x82A10D48;
	sub_8221BD38(ctx, base);
	// 82A10D48: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82A10D4C; continue 'dispatch;
            }
            0x82A10D4C => {
    //   block [0x82A10D4C..0x82A10D58)
	// 82A10D4C: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A10D50: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A10D54: 409AFFE4  bne cr6, 0x82a10d38
	if !ctx.cr[6].eq {
	pc = 0x82A10D38; continue 'dispatch;
	}
	pc = 0x82A10D58; continue 'dispatch;
            }
            0x82A10D58 => {
    //   block [0x82A10D58..0x82A10D60)
	// 82A10D58: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10D5C: 4B80AFDD  bl 0x8221bd38
	ctx.lr = 0x82A10D60;
	sub_8221BD38(ctx, base);
	pc = 0x82A10D60; continue 'dispatch;
            }
            0x82A10D60 => {
    //   block [0x82A10D60..0x82A10D88)
	// 82A10D60: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A10D64: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10D68: 939A0004  stw r28, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A10D6C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A10D70: 939A0008  stw r28, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82A10D74: 939A000C  stw r28, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82A10D78: 7D242E71  srawi. r4, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[9].s32 >> 5) as i64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82A10D7C: 4082000C  bne 0x82a10d88
	if !ctx.cr[0].eq {
	pc = 0x82A10D88; continue 'dispatch;
	}
	// 82A10D80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A10D84: 4800000C  b 0x82a10d90
	pc = 0x82A10D90; continue 'dispatch;
            }
            0x82A10D88 => {
    //   block [0x82A10D88..0x82A10D90)
	// 82A10D88: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A10D8C: 48000165  bl 0x82a10ef0
	ctx.lr = 0x82A10D90;
	sub_82A10EF0(ctx, base);
	pc = 0x82A10D90; continue 'dispatch;
            }
            0x82A10D90 => {
    //   block [0x82A10D90..0x82A10DB0)
	// 82A10D90: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A10D94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A10D98: 419A0040  beq cr6, 0x82a10dd8
	if ctx.cr[6].eq {
	pc = 0x82A10DD8; continue 'dispatch;
	}
	// 82A10D9C: 83BB0008  lwz r29, 8(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A10DA0: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10DA4: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10DA8: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A10DAC: 419A0028  beq cr6, 0x82a10dd4
	if ctx.cr[6].eq {
	pc = 0x82A10DD4; continue 'dispatch;
	}
	pc = 0x82A10DB0; continue 'dispatch;
            }
            0x82A10DB0 => {
    //   block [0x82A10DB0..0x82A10DC4)
	// 82A10DB0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A10DB4: 419A0010  beq cr6, 0x82a10dc4
	if ctx.cr[6].eq {
	pc = 0x82A10DC4; continue 'dispatch;
	}
	// 82A10DB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A10DBC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A10DC0: 48000999  bl 0x82a11758
	ctx.lr = 0x82A10DC4;
	sub_82A11758(ctx, base);
	pc = 0x82A10DC4; continue 'dispatch;
            }
            0x82A10DC4 => {
    //   block [0x82A10DC4..0x82A10DD4)
	// 82A10DC4: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A10DC8: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 82A10DCC: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A10DD0: 409AFFE0  bne cr6, 0x82a10db0
	if !ctx.cr[6].eq {
	pc = 0x82A10DB0; continue 'dispatch;
	}
	pc = 0x82A10DD4; continue 'dispatch;
            }
            0x82A10DD4 => {
    //   block [0x82A10DD4..0x82A10DD8)
	// 82A10DD4: 93DA0008  stw r30, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x82A10DD8; continue 'dispatch;
            }
            0x82A10DD8 => {
    //   block [0x82A10DD8..0x82A10DE4)
	// 82A10DD8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A10DDC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A10DE0: 48298670  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A10DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A10DE8 size=160
    let mut pc: u32 = 0x82A10DE8;
    'dispatch: loop {
        match pc {
            0x82A10DE8 => {
    //   block [0x82A10DE8..0x82A10E14)
	// 82A10DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A10DEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A10DF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A10DF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A10DF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A10DFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A10E00: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10E04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A10E08: 409A000C  bne cr6, 0x82a10e14
	if !ctx.cr[6].eq {
	pc = 0x82A10E14; continue 'dispatch;
	}
	// 82A10E0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A10E10: 48000010  b 0x82a10e20
	pc = 0x82A10E20; continue 'dispatch;
            }
            0x82A10E14 => {
    //   block [0x82A10E14..0x82A10E20)
	// 82A10E14: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A10E18: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A10E1C: 7D2A2E70  srawi r10, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 5) as i64;
	pc = 0x82A10E20; continue 'dispatch;
            }
            0x82A10E20 => {
    //   block [0x82A10E20..0x82A10E44)
	// 82A10E20: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A10E24: 7D6BF850  subf r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A10E28: 7D692E70  srawi r9, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 82A10E2C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A10E30: 40980020  bge cr6, 0x82a10e50
	if !ctx.cr[6].lt {
	pc = 0x82A10E50; continue 'dispatch;
	}
	// 82A10E34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A10E38: 419A000C  beq cr6, 0x82a10e44
	if ctx.cr[6].eq {
	pc = 0x82A10E44; continue 'dispatch;
	}
	// 82A10E3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A10E40: 48000919  bl 0x82a11758
	ctx.lr = 0x82A10E44;
	sub_82A11758(ctx, base);
	pc = 0x82A10E44; continue 'dispatch;
            }
            0x82A10E44 => {
    //   block [0x82A10E44..0x82A10E50)
	// 82A10E44: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 82A10E48: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A10E4C: 48000024  b 0x82a10e70
	pc = 0x82A10E70; continue 'dispatch;
            }
            0x82A10E50 => {
    //   block [0x82A10E50..0x82A10E70)
	// 82A10E50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A10E54: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A10E58: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82A10E5C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A10E60: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A10E64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A10E68: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A10E6C: 48000465  bl 0x82a112d0
	ctx.lr = 0x82A10E70;
	sub_82A112D0(ctx, base);
	pc = 0x82A10E70; continue 'dispatch;
            }
            0x82A10E70 => {
    //   block [0x82A10E70..0x82A10E88)
	// 82A10E70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A10E74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A10E78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A10E7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A10E80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A10E84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A10E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A10E88 size=104
    let mut pc: u32 = 0x82A10E88;
    'dispatch: loop {
        match pc {
            0x82A10E88 => {
    //   block [0x82A10E88..0x82A10EB4)
	// 82A10E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A10E8C: 4829857D  bl 0x82ca9408
	ctx.lr = 0x82A10E90;
	sub_82CA93D0(ctx, base);
	// 82A10E90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A10E94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A10E98: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A10E9C: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10EA0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A10EA4: 419A0038  beq cr6, 0x82a10edc
	if ctx.cr[6].eq {
	pc = 0x82A10EDC; continue 'dispatch;
	}
	// 82A10EA8: 83BE0008  lwz r29, 8(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A10EAC: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A10EB0: 419A0024  beq cr6, 0x82a10ed4
	if ctx.cr[6].eq {
	pc = 0x82A10ED4; continue 'dispatch;
	}
	pc = 0x82A10EB4; continue 'dispatch;
            }
            0x82A10EB4 => {
    //   block [0x82A10EB4..0x82A10EC8)
	// 82A10EB4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A10EB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A10EBC: 419A000C  beq cr6, 0x82a10ec8
	if ctx.cr[6].eq {
	pc = 0x82A10EC8; continue 'dispatch;
	}
	// 82A10EC0: 4B80AE79  bl 0x8221bd38
	ctx.lr = 0x82A10EC4;
	sub_8221BD38(ctx, base);
	// 82A10EC4: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82A10EC8; continue 'dispatch;
            }
            0x82A10EC8 => {
    //   block [0x82A10EC8..0x82A10ED4)
	// 82A10EC8: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82A10ECC: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A10ED0: 409AFFE4  bne cr6, 0x82a10eb4
	if !ctx.cr[6].eq {
	pc = 0x82A10EB4; continue 'dispatch;
	}
	pc = 0x82A10ED4; continue 'dispatch;
            }
            0x82A10ED4 => {
    //   block [0x82A10ED4..0x82A10EDC)
	// 82A10ED4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10ED8: 4B80AE61  bl 0x8221bd38
	ctx.lr = 0x82A10EDC;
	sub_8221BD38(ctx, base);
	pc = 0x82A10EDC; continue 'dispatch;
            }
            0x82A10EDC => {
    //   block [0x82A10EDC..0x82A10EF0)
	// 82A10EDC: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A10EE0: 939E0008  stw r28, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82A10EE4: 939E000C  stw r28, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82A10EE8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A10EEC: 4829856C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A10EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A10EF0 size=116
    let mut pc: u32 = 0x82A10EF0;
    'dispatch: loop {
        match pc {
            0x82A10EF0 => {
    //   block [0x82A10EF0..0x82A10F24)
	// 82A10EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A10EF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A10EF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A10EFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A10F00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A10F04: 3D6007FF  lis r11, 0x7ff
	ctx.r[11].s64 = 134152192;
	// 82A10F08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A10F0C: 616AFFFF  ori r10, r11, 0xffff
	ctx.r[10].u64 = ctx.r[11].u64 | 65535;
	// 82A10F10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A10F14: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A10F18: 4099000C  ble cr6, 0x82a10f24
	if !ctx.cr[6].gt {
	pc = 0x82A10F24; continue 'dispatch;
	}
	// 82A10F1C: 480365AD  bl 0x82a474c8
	ctx.lr = 0x82A10F20;
	sub_82A474C8(ctx, base);
	// 82A10F20: 48000028  b 0x82a10f48
	pc = 0x82A10F48; continue 'dispatch;
            }
            0x82A10F24 => {
    //   block [0x82A10F24..0x82A10F48)
	// 82A10F24: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A10F28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A10F2C: 480006A5  bl 0x82a115d0
	ctx.lr = 0x82A10F30;
	sub_82A115D0(ctx, base);
	// 82A10F30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A10F34: 57CA2834  slwi r10, r30, 5
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A10F38: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A10F3C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A10F40: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A10F44: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x82A10F48; continue 'dispatch;
            }
            0x82A10F48 => {
    //   block [0x82A10F48..0x82A10F64)
	// 82A10F48: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A10F4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A10F50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A10F54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A10F58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A10F5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A10F60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A10F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A10F68 size=104
    let mut pc: u32 = 0x82A10F68;
    'dispatch: loop {
        match pc {
            0x82A10F68 => {
    //   block [0x82A10F68..0x82A10F94)
	// 82A10F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A10F6C: 4829849D  bl 0x82ca9408
	ctx.lr = 0x82A10F70;
	sub_82CA93D0(ctx, base);
	// 82A10F70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A10F74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A10F78: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A10F7C: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10F80: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A10F84: 419A0038  beq cr6, 0x82a10fbc
	if ctx.cr[6].eq {
	pc = 0x82A10FBC; continue 'dispatch;
	}
	// 82A10F88: 83BE0008  lwz r29, 8(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A10F8C: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A10F90: 419A0024  beq cr6, 0x82a10fb4
	if ctx.cr[6].eq {
	pc = 0x82A10FB4; continue 'dispatch;
	}
	pc = 0x82A10F94; continue 'dispatch;
            }
            0x82A10F94 => {
    //   block [0x82A10F94..0x82A10FA8)
	// 82A10F94: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A10F98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A10F9C: 419A000C  beq cr6, 0x82a10fa8
	if ctx.cr[6].eq {
	pc = 0x82A10FA8; continue 'dispatch;
	}
	// 82A10FA0: 4B80AD99  bl 0x8221bd38
	ctx.lr = 0x82A10FA4;
	sub_8221BD38(ctx, base);
	// 82A10FA4: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82A10FA8; continue 'dispatch;
            }
            0x82A10FA8 => {
    //   block [0x82A10FA8..0x82A10FB4)
	// 82A10FA8: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A10FAC: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A10FB0: 409AFFE4  bne cr6, 0x82a10f94
	if !ctx.cr[6].eq {
	pc = 0x82A10F94; continue 'dispatch;
	}
	pc = 0x82A10FB4; continue 'dispatch;
            }
            0x82A10FB4 => {
    //   block [0x82A10FB4..0x82A10FBC)
	// 82A10FB4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10FB8: 4B80AD81  bl 0x8221bd38
	ctx.lr = 0x82A10FBC;
	sub_8221BD38(ctx, base);
	pc = 0x82A10FBC; continue 'dispatch;
            }
            0x82A10FBC => {
    //   block [0x82A10FBC..0x82A10FD0)
	// 82A10FBC: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A10FC0: 939E0008  stw r28, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82A10FC4: 939E000C  stw r28, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82A10FC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A10FCC: 4829848C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A10FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A10FD0 size=764
    let mut pc: u32 = 0x82A10FD0;
    'dispatch: loop {
        match pc {
            0x82A10FD0 => {
    //   block [0x82A10FD0..0x82A11008)
	// 82A10FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A10FD4: 48298425  bl 0x82ca93f8
	ctx.lr = 0x82A10FD8;
	sub_82CA93D0(ctx, base);
	// 82A10FD8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A10FDC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A10FE0: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 82A10FE4: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A10FE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A10FEC: 48000655  bl 0x82a11640
	ctx.lr = 0x82A10FF0;
	sub_82A11640(ctx, base);
	// 82A10FF0: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A10FF4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82A10FF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A10FFC: 409A000C  bne cr6, 0x82a11008
	if !ctx.cr[6].eq {
	pc = 0x82A11008; continue 'dispatch;
	}
	// 82A11000: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 82A11004: 48000010  b 0x82a11014
	pc = 0x82A11014; continue 'dispatch;
            }
            0x82A11008 => {
    //   block [0x82A11008..0x82A11014)
	// 82A11008: 815A000C  lwz r10, 0xc(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1100C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A11010: 7D292670  srawi r9, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 4) as i64;
	pc = 0x82A11014; continue 'dispatch;
            }
            0x82A11014 => {
    //   block [0x82A11014..0x82A1103C)
	// 82A11014: 839A0008  lwz r28, 8(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A11018: 3D400FFF  lis r10, 0xfff
	ctx.r[10].s64 = 268369920;
	// 82A1101C: 7D0BE050  subf r8, r11, r28
	ctx.r[8].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 82A11020: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82A11024: 7D0B2670  srawi r11, r8, 4
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 4) as i64;
	// 82A11028: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A1102C: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 82A11030: 4098000C  bge cr6, 0x82a1103c
	if !ctx.cr[6].lt {
	pc = 0x82A1103C; continue 'dispatch;
	}
	// 82A11034: 48036495  bl 0x82a474c8
	ctx.lr = 0x82A11038;
	sub_82A474C8(ctx, base);
	// 82A11038: 4800027C  b 0x82a112b4
	pc = 0x82A112B4; continue 'dispatch;
            }
            0x82A1103C => {
    //   block [0x82A1103C..0x82A11060)
	// 82A1103C: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82A11040: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A11044: 40980130  bge cr6, 0x82a11174
	if !ctx.cr[6].lt {
	pc = 0x82A11174; continue 'dispatch;
	}
	// 82A11048: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1104C: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	// 82A11050: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A11054: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A11058: 41980008  blt cr6, 0x82a11060
	if ctx.cr[6].lt {
	pc = 0x82A11060; continue 'dispatch;
	}
	// 82A1105C: 7F2B4A14  add r25, r11, r9
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A11060; continue 'dispatch;
            }
            0x82A11060 => {
    //   block [0x82A11060..0x82A1106C)
	// 82A11060: 7F194040  cmplw cr6, r25, r8
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A11064: 40980008  bge cr6, 0x82a1106c
	if !ctx.cr[6].lt {
	pc = 0x82A1106C; continue 'dispatch;
	}
	// 82A11068: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	pc = 0x82A1106C; continue 'dispatch;
            }
            0x82A1106C => {
    //   block [0x82A1106C..0x82A11090)
	// 82A1106C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A11070: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A11074: 4BA121C5  bl 0x82423238
	ctx.lr = 0x82A11078;
	sub_82423238(ctx, base);
	// 82A11078: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1107C: 83A100CC  lwz r29, 0xcc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A11080: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A11084: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A11088: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A1108C: 419A0028  beq cr6, 0x82a110b4
	if ctx.cr[6].eq {
	pc = 0x82A110B4; continue 'dispatch;
	}
	pc = 0x82A11090; continue 'dispatch;
            }
            0x82A11090 => {
    //   block [0x82A11090..0x82A110A4)
	// 82A11090: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A11094: 419A0010  beq cr6, 0x82a110a4
	if ctx.cr[6].eq {
	pc = 0x82A110A4; continue 'dispatch;
	}
	// 82A11098: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1109C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A110A0: 480005A1  bl 0x82a11640
	ctx.lr = 0x82A110A4;
	sub_82A11640(ctx, base);
	pc = 0x82A110A4; continue 'dispatch;
            }
            0x82A110A4 => {
    //   block [0x82A110A4..0x82A110B4)
	// 82A110A4: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82A110A8: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82A110AC: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A110B0: 409AFFE0  bne cr6, 0x82a11090
	if !ctx.cr[6].eq {
	pc = 0x82A11090; continue 'dispatch;
	}
	pc = 0x82A110B4; continue 'dispatch;
            }
            0x82A110B4 => {
    //   block [0x82A110B4..0x82A110C8)
	// 82A110B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A110B8: 419A0010  beq cr6, 0x82a110c8
	if ctx.cr[6].eq {
	pc = 0x82A110C8; continue 'dispatch;
	}
	// 82A110BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A110C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A110C4: 4800057D  bl 0x82a11640
	ctx.lr = 0x82A110C8;
	sub_82A11640(ctx, base);
	pc = 0x82A110C8; continue 'dispatch;
            }
            0x82A110C8 => {
    //   block [0x82A110C8..0x82A110E4)
	// 82A110C8: 839A0008  lwz r28, 8(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A110CC: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82A110D0: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A110D4: 419A0034  beq cr6, 0x82a11108
	if ctx.cr[6].eq {
	pc = 0x82A11108; continue 'dispatch;
	}
	// 82A110D8: 7D7FF050  subf r11, r31, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82A110DC: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82A110E0: 3BEBFFF0  addi r31, r11, -0x10
	ctx.r[31].s64 = ctx.r[11].s64 + -16;
	pc = 0x82A110E4; continue 'dispatch;
            }
            0x82A110E4 => {
    //   block [0x82A110E4..0x82A110F8)
	// 82A110E4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A110E8: 419A0010  beq cr6, 0x82a110f8
	if ctx.cr[6].eq {
	pc = 0x82A110F8; continue 'dispatch;
	}
	// 82A110EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A110F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A110F4: 4800054D  bl 0x82a11640
	ctx.lr = 0x82A110F8;
	sub_82A11640(ctx, base);
	pc = 0x82A110F8; continue 'dispatch;
            }
            0x82A110F8 => {
    //   block [0x82A110F8..0x82A11108)
	// 82A110F8: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82A110FC: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82A11100: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A11104: 409AFFE0  bne cr6, 0x82a110e4
	if !ctx.cr[6].eq {
	pc = 0x82A110E4; continue 'dispatch;
	}
	pc = 0x82A11108; continue 'dispatch;
            }
            0x82A11108 => {
    //   block [0x82A11108..0x82A1112C)
	// 82A11108: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1110C: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A11110: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A11114: 7D7FF050  subf r11, r31, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82A11118: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 82A1111C: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 82A11120: 419A0034  beq cr6, 0x82a11154
	if ctx.cr[6].eq {
	pc = 0x82A11154; continue 'dispatch;
	}
	// 82A11124: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A11128: 419A0024  beq cr6, 0x82a1114c
	if ctx.cr[6].eq {
	pc = 0x82A1114C; continue 'dispatch;
	}
	pc = 0x82A1112C; continue 'dispatch;
            }
            0x82A1112C => {
    //   block [0x82A1112C..0x82A11140)
	// 82A1112C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11130: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A11134: 419A000C  beq cr6, 0x82a11140
	if ctx.cr[6].eq {
	pc = 0x82A11140; continue 'dispatch;
	}
	// 82A11138: 4B80AC01  bl 0x8221bd38
	ctx.lr = 0x82A1113C;
	sub_8221BD38(ctx, base);
	// 82A1113C: 931F0000  stw r24, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	pc = 0x82A11140; continue 'dispatch;
            }
            0x82A11140 => {
    //   block [0x82A11140..0x82A1114C)
	// 82A11140: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82A11144: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A11148: 409AFFE4  bne cr6, 0x82a1112c
	if !ctx.cr[6].eq {
	pc = 0x82A1112C; continue 'dispatch;
	}
	pc = 0x82A1114C; continue 'dispatch;
            }
            0x82A1114C => {
    //   block [0x82A1114C..0x82A11154)
	// 82A1114C: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A11150: 4B80ABE9  bl 0x8221bd38
	ctx.lr = 0x82A11154;
	sub_8221BD38(ctx, base);
	pc = 0x82A11154; continue 'dispatch;
            }
            0x82A11154 => {
    //   block [0x82A11154..0x82A11174)
	// 82A11154: 572A2036  slwi r10, r25, 4
	ctx.r[10].u32 = ctx.r[25].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A11158: 937A0004  stw r27, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A1115C: 57AB2036  slwi r11, r29, 4
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A11160: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82A11164: 7D2BDA14  add r9, r11, r27
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A11168: 915A000C  stw r10, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82A1116C: 913A0008  stw r9, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82A11170: 48000144  b 0x82a112b4
	pc = 0x82A112B4; continue 'dispatch;
            }
            0x82A11174 => {
    //   block [0x82A11174..0x82A11198)
	// 82A11174: 836100CC  lwz r27, 0xcc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A11178: 7D7BE050  subf r11, r27, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[27].s64;
	// 82A1117C: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 82A11180: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82A11184: 409800A8  bge cr6, 0x82a1122c
	if !ctx.cr[6].lt {
	pc = 0x82A1122C; continue 'dispatch;
	}
	// 82A11188: 3BFB0010  addi r31, r27, 0x10
	ctx.r[31].s64 = ctx.r[27].s64 + 16;
	// 82A1118C: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A11190: 419A002C  beq cr6, 0x82a111bc
	if ctx.cr[6].eq {
	pc = 0x82A111BC; continue 'dispatch;
	}
	// 82A11194: 3BDFFFF0  addi r30, r31, -0x10
	ctx.r[30].s64 = ctx.r[31].s64 + -16;
	pc = 0x82A11198; continue 'dispatch;
            }
            0x82A11198 => {
    //   block [0x82A11198..0x82A111AC)
	// 82A11198: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A1119C: 419A0010  beq cr6, 0x82a111ac
	if ctx.cr[6].eq {
	pc = 0x82A111AC; continue 'dispatch;
	}
	// 82A111A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A111A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A111A8: 48000499  bl 0x82a11640
	ctx.lr = 0x82A111AC;
	sub_82A11640(ctx, base);
	pc = 0x82A111AC; continue 'dispatch;
            }
            0x82A111AC => {
    //   block [0x82A111AC..0x82A111BC)
	// 82A111AC: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82A111B0: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82A111B4: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A111B8: 409AFFE0  bne cr6, 0x82a11198
	if !ctx.cr[6].eq {
	pc = 0x82A11198; continue 'dispatch;
	}
	pc = 0x82A111BC; continue 'dispatch;
            }
            0x82A111BC => {
    //   block [0x82A111BC..0x82A111D4)
	// 82A111BC: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A111C0: 7D7BF050  subf r11, r27, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 82A111C4: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 82A111C8: 23EA0001  subfic r31, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[31].s64 = (1 as i64) - ctx.r[10].s64;
	// 82A111CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A111D0: 419A0024  beq cr6, 0x82a111f4
	if ctx.cr[6].eq {
	pc = 0x82A111F4; continue 'dispatch;
	}
	pc = 0x82A111D4; continue 'dispatch;
            }
            0x82A111D4 => {
    //   block [0x82A111D4..0x82A111E8)
	// 82A111D4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A111D8: 419A0010  beq cr6, 0x82a111e8
	if ctx.cr[6].eq {
	pc = 0x82A111E8; continue 'dispatch;
	}
	// 82A111DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A111E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A111E4: 4800045D  bl 0x82a11640
	ctx.lr = 0x82A111E8;
	sub_82A11640(ctx, base);
	pc = 0x82A111E8; continue 'dispatch;
            }
            0x82A111E8 => {
    //   block [0x82A111E8..0x82A111F4)
	// 82A111E8: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A111EC: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82A111F0: 4082FFE4  bne 0x82a111d4
	if !ctx.cr[0].eq {
	pc = 0x82A111D4; continue 'dispatch;
	}
	pc = 0x82A111F4; continue 'dispatch;
            }
            0x82A111F4 => {
    //   block [0x82A111F4..0x82A11210)
	// 82A111F4: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A111F8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A111FC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82A11200: 3BCBFFF0  addi r30, r11, -0x10
	ctx.r[30].s64 = ctx.r[11].s64 + -16;
	// 82A11204: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A11208: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A1120C: 419A00A8  beq cr6, 0x82a112b4
	if ctx.cr[6].eq {
	pc = 0x82A112B4; continue 'dispatch;
	}
	pc = 0x82A11210; continue 'dispatch;
            }
            0x82A11210 => {
    //   block [0x82A11210..0x82A1122C)
	// 82A11210: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A11214: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11218: 48003F09  bl 0x82a15120
	ctx.lr = 0x82A1121C;
	sub_82A15120(ctx, base);
	// 82A1121C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82A11220: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A11224: 409AFFEC  bne cr6, 0x82a11210
	if !ctx.cr[6].eq {
	pc = 0x82A11210; continue 'dispatch;
	}
	// 82A11228: 4800008C  b 0x82a112b4
	pc = 0x82A112B4; continue 'dispatch;
            }
            0x82A1122C => {
    //   block [0x82A1122C..0x82A11240)
	// 82A1122C: 3BFCFFF0  addi r31, r28, -0x10
	ctx.r[31].s64 = ctx.r[28].s64 + -16;
	// 82A11230: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82A11234: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82A11238: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A1123C: 419A0028  beq cr6, 0x82a11264
	if ctx.cr[6].eq {
	pc = 0x82A11264; continue 'dispatch;
	}
	pc = 0x82A11240; continue 'dispatch;
            }
            0x82A11240 => {
    //   block [0x82A11240..0x82A11254)
	// 82A11240: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A11244: 419A0010  beq cr6, 0x82a11254
	if ctx.cr[6].eq {
	pc = 0x82A11254; continue 'dispatch;
	}
	// 82A11248: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1124C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A11250: 480003F1  bl 0x82a11640
	ctx.lr = 0x82A11254;
	sub_82A11640(ctx, base);
	pc = 0x82A11254; continue 'dispatch;
            }
            0x82A11254 => {
    //   block [0x82A11254..0x82A11264)
	// 82A11254: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 82A11258: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82A1125C: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A11260: 409AFFE0  bne cr6, 0x82a11240
	if !ctx.cr[6].eq {
	pc = 0x82A11240; continue 'dispatch;
	}
	pc = 0x82A11264; continue 'dispatch;
            }
            0x82A11264 => {
    //   block [0x82A11264..0x82A11274)
	// 82A11264: 93DA0008  stw r30, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A11268: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A1126C: 419A0020  beq cr6, 0x82a1128c
	if ctx.cr[6].eq {
	pc = 0x82A1128C; continue 'dispatch;
	}
	// 82A11270: 7FDFE050  subf r30, r31, r28
	ctx.r[30].s64 = ctx.r[28].s64 - ctx.r[31].s64;
	pc = 0x82A11274; continue 'dispatch;
            }
            0x82A11274 => {
    //   block [0x82A11274..0x82A1128C)
	// 82A11274: 3BFFFFF0  addi r31, r31, -0x10
	ctx.r[31].s64 = ctx.r[31].s64 + -16;
	// 82A11278: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1127C: 7C7FF214  add r3, r31, r30
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 82A11280: 48003EA1  bl 0x82a15120
	ctx.lr = 0x82A11284;
	sub_82A15120(ctx, base);
	// 82A11284: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A11288: 409AFFEC  bne cr6, 0x82a11274
	if !ctx.cr[6].eq {
	pc = 0x82A11274; continue 'dispatch;
	}
	pc = 0x82A1128C; continue 'dispatch;
            }
            0x82A1128C => {
    //   block [0x82A1128C..0x82A1129C)
	// 82A1128C: 3BDB0010  addi r30, r27, 0x10
	ctx.r[30].s64 = ctx.r[27].s64 + 16;
	// 82A11290: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A11294: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A11298: 419A001C  beq cr6, 0x82a112b4
	if ctx.cr[6].eq {
	pc = 0x82A112B4; continue 'dispatch;
	}
	pc = 0x82A1129C; continue 'dispatch;
            }
            0x82A1129C => {
    //   block [0x82A1129C..0x82A112B4)
	// 82A1129C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A112A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A112A4: 48003E7D  bl 0x82a15120
	ctx.lr = 0x82A112A8;
	sub_82A15120(ctx, base);
	// 82A112A8: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82A112AC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A112B0: 409AFFEC  bne cr6, 0x82a1129c
	if !ctx.cr[6].eq {
	pc = 0x82A1129C; continue 'dispatch;
	}
	pc = 0x82A112B4; continue 'dispatch;
            }
            0x82A112B4 => {
    //   block [0x82A112B4..0x82A112C4)
	// 82A112B4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A112B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A112BC: 419A0008  beq cr6, 0x82a112c4
	if ctx.cr[6].eq {
	pc = 0x82A112C4; continue 'dispatch;
	}
	// 82A112C0: 4B80AA79  bl 0x8221bd38
	ctx.lr = 0x82A112C4;
	sub_8221BD38(ctx, base);
	pc = 0x82A112C4; continue 'dispatch;
            }
            0x82A112C4 => {
    //   block [0x82A112C4..0x82A112CC)
	// 82A112C4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A112C8: 48298180  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A112D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A112D0 size=764
    let mut pc: u32 = 0x82A112D0;
    'dispatch: loop {
        match pc {
            0x82A112D0 => {
    //   block [0x82A112D0..0x82A11308)
	// 82A112D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A112D4: 48298125  bl 0x82ca93f8
	ctx.lr = 0x82A112D8;
	sub_82CA93D0(ctx, base);
	// 82A112D8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A112DC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A112E0: F88100D8  std r4, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[4].u64 ) };
	// 82A112E4: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A112E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A112EC: 4800046D  bl 0x82a11758
	ctx.lr = 0x82A112F0;
	sub_82A11758(ctx, base);
	// 82A112F0: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A112F4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82A112F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A112FC: 409A000C  bne cr6, 0x82a11308
	if !ctx.cr[6].eq {
	pc = 0x82A11308; continue 'dispatch;
	}
	// 82A11300: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 82A11304: 48000010  b 0x82a11314
	pc = 0x82A11314; continue 'dispatch;
            }
            0x82A11308 => {
    //   block [0x82A11308..0x82A11314)
	// 82A11308: 815A000C  lwz r10, 0xc(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1130C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A11310: 7D292E70  srawi r9, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 5) as i64;
	pc = 0x82A11314; continue 'dispatch;
            }
            0x82A11314 => {
    //   block [0x82A11314..0x82A1133C)
	// 82A11314: 839A0008  lwz r28, 8(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A11318: 3D4007FF  lis r10, 0x7ff
	ctx.r[10].s64 = 134152192;
	// 82A1131C: 7D0BE050  subf r8, r11, r28
	ctx.r[8].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 82A11320: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82A11324: 7D0B2E70  srawi r11, r8, 5
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 5) as i64;
	// 82A11328: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A1132C: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 82A11330: 4098000C  bge cr6, 0x82a1133c
	if !ctx.cr[6].lt {
	pc = 0x82A1133C; continue 'dispatch;
	}
	// 82A11334: 48036195  bl 0x82a474c8
	ctx.lr = 0x82A11338;
	sub_82A474C8(ctx, base);
	// 82A11338: 4800027C  b 0x82a115b4
	pc = 0x82A115B4; continue 'dispatch;
            }
            0x82A1133C => {
    //   block [0x82A1133C..0x82A11360)
	// 82A1133C: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82A11340: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A11344: 40980130  bge cr6, 0x82a11474
	if !ctx.cr[6].lt {
	pc = 0x82A11474; continue 'dispatch;
	}
	// 82A11348: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1134C: 7F19C378  mr r25, r24
	ctx.r[25].u64 = ctx.r[24].u64;
	// 82A11350: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A11354: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A11358: 41980008  blt cr6, 0x82a11360
	if ctx.cr[6].lt {
	pc = 0x82A11360; continue 'dispatch;
	}
	// 82A1135C: 7F2B4A14  add r25, r11, r9
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A11360; continue 'dispatch;
            }
            0x82A11360 => {
    //   block [0x82A11360..0x82A1136C)
	// 82A11360: 7F194040  cmplw cr6, r25, r8
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A11364: 40980008  bge cr6, 0x82a1136c
	if !ctx.cr[6].lt {
	pc = 0x82A1136C; continue 'dispatch;
	}
	// 82A11368: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	pc = 0x82A1136C; continue 'dispatch;
            }
            0x82A1136C => {
    //   block [0x82A1136C..0x82A11390)
	// 82A1136C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A11370: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A11374: 4800025D  bl 0x82a115d0
	ctx.lr = 0x82A11378;
	sub_82A115D0(ctx, base);
	// 82A11378: 83DA0004  lwz r30, 4(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1137C: 83A100DC  lwz r29, 0xdc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A11380: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A11384: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A11388: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A1138C: 419A0028  beq cr6, 0x82a113b4
	if ctx.cr[6].eq {
	pc = 0x82A113B4; continue 'dispatch;
	}
	pc = 0x82A11390; continue 'dispatch;
            }
            0x82A11390 => {
    //   block [0x82A11390..0x82A113A4)
	// 82A11390: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A11394: 419A0010  beq cr6, 0x82a113a4
	if ctx.cr[6].eq {
	pc = 0x82A113A4; continue 'dispatch;
	}
	// 82A11398: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1139C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A113A0: 480003B9  bl 0x82a11758
	ctx.lr = 0x82A113A4;
	sub_82A11758(ctx, base);
	pc = 0x82A113A4; continue 'dispatch;
            }
            0x82A113A4 => {
    //   block [0x82A113A4..0x82A113B4)
	// 82A113A4: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 82A113A8: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A113AC: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A113B0: 409AFFE0  bne cr6, 0x82a11390
	if !ctx.cr[6].eq {
	pc = 0x82A11390; continue 'dispatch;
	}
	pc = 0x82A113B4; continue 'dispatch;
            }
            0x82A113B4 => {
    //   block [0x82A113B4..0x82A113C8)
	// 82A113B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A113B8: 419A0010  beq cr6, 0x82a113c8
	if ctx.cr[6].eq {
	pc = 0x82A113C8; continue 'dispatch;
	}
	// 82A113BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A113C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A113C4: 48000395  bl 0x82a11758
	ctx.lr = 0x82A113C8;
	sub_82A11758(ctx, base);
	pc = 0x82A113C8; continue 'dispatch;
            }
            0x82A113C8 => {
    //   block [0x82A113C8..0x82A113E4)
	// 82A113C8: 839A0008  lwz r28, 8(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A113CC: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	// 82A113D0: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A113D4: 419A0034  beq cr6, 0x82a11408
	if ctx.cr[6].eq {
	pc = 0x82A11408; continue 'dispatch;
	}
	// 82A113D8: 7D7FF050  subf r11, r31, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82A113DC: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82A113E0: 3BEBFFE0  addi r31, r11, -0x20
	ctx.r[31].s64 = ctx.r[11].s64 + -32;
	pc = 0x82A113E4; continue 'dispatch;
            }
            0x82A113E4 => {
    //   block [0x82A113E4..0x82A113F8)
	// 82A113E4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A113E8: 419A0010  beq cr6, 0x82a113f8
	if ctx.cr[6].eq {
	pc = 0x82A113F8; continue 'dispatch;
	}
	// 82A113EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A113F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A113F4: 48000365  bl 0x82a11758
	ctx.lr = 0x82A113F8;
	sub_82A11758(ctx, base);
	pc = 0x82A113F8; continue 'dispatch;
            }
            0x82A113F8 => {
    //   block [0x82A113F8..0x82A11408)
	// 82A113F8: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A113FC: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 82A11400: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A11404: 409AFFE0  bne cr6, 0x82a113e4
	if !ctx.cr[6].eq {
	pc = 0x82A113E4; continue 'dispatch;
	}
	pc = 0x82A11408; continue 'dispatch;
            }
            0x82A11408 => {
    //   block [0x82A11408..0x82A1142C)
	// 82A11408: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1140C: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A11410: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A11414: 7D7FF050  subf r11, r31, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82A11418: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 82A1141C: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 82A11420: 419A0034  beq cr6, 0x82a11454
	if ctx.cr[6].eq {
	pc = 0x82A11454; continue 'dispatch;
	}
	// 82A11424: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A11428: 419A0024  beq cr6, 0x82a1144c
	if ctx.cr[6].eq {
	pc = 0x82A1144C; continue 'dispatch;
	}
	pc = 0x82A1142C; continue 'dispatch;
            }
            0x82A1142C => {
    //   block [0x82A1142C..0x82A11440)
	// 82A1142C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11430: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A11434: 419A000C  beq cr6, 0x82a11440
	if ctx.cr[6].eq {
	pc = 0x82A11440; continue 'dispatch;
	}
	// 82A11438: 4B80A901  bl 0x8221bd38
	ctx.lr = 0x82A1143C;
	sub_8221BD38(ctx, base);
	// 82A1143C: 931F0000  stw r24, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	pc = 0x82A11440; continue 'dispatch;
            }
            0x82A11440 => {
    //   block [0x82A11440..0x82A1144C)
	// 82A11440: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A11444: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A11448: 409AFFE4  bne cr6, 0x82a1142c
	if !ctx.cr[6].eq {
	pc = 0x82A1142C; continue 'dispatch;
	}
	pc = 0x82A1144C; continue 'dispatch;
            }
            0x82A1144C => {
    //   block [0x82A1144C..0x82A11454)
	// 82A1144C: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A11450: 4B80A8E9  bl 0x8221bd38
	ctx.lr = 0x82A11454;
	sub_8221BD38(ctx, base);
	pc = 0x82A11454; continue 'dispatch;
            }
            0x82A11454 => {
    //   block [0x82A11454..0x82A11474)
	// 82A11454: 572A2834  slwi r10, r25, 5
	ctx.r[10].u32 = ctx.r[25].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A11458: 937A0004  stw r27, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A1145C: 57AB2834  slwi r11, r29, 5
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A11460: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82A11464: 7D2BDA14  add r9, r11, r27
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A11468: 915A000C  stw r10, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82A1146C: 913A0008  stw r9, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82A11470: 48000144  b 0x82a115b4
	pc = 0x82A115B4; continue 'dispatch;
            }
            0x82A11474 => {
    //   block [0x82A11474..0x82A11498)
	// 82A11474: 836100DC  lwz r27, 0xdc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A11478: 7D7BE050  subf r11, r27, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[27].s64;
	// 82A1147C: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 82A11480: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82A11484: 409800A8  bge cr6, 0x82a1152c
	if !ctx.cr[6].lt {
	pc = 0x82A1152C; continue 'dispatch;
	}
	// 82A11488: 3BFB0020  addi r31, r27, 0x20
	ctx.r[31].s64 = ctx.r[27].s64 + 32;
	// 82A1148C: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A11490: 419A002C  beq cr6, 0x82a114bc
	if ctx.cr[6].eq {
	pc = 0x82A114BC; continue 'dispatch;
	}
	// 82A11494: 3BDFFFE0  addi r30, r31, -0x20
	ctx.r[30].s64 = ctx.r[31].s64 + -32;
	pc = 0x82A11498; continue 'dispatch;
            }
            0x82A11498 => {
    //   block [0x82A11498..0x82A114AC)
	// 82A11498: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A1149C: 419A0010  beq cr6, 0x82a114ac
	if ctx.cr[6].eq {
	pc = 0x82A114AC; continue 'dispatch;
	}
	// 82A114A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A114A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A114A8: 480002B1  bl 0x82a11758
	ctx.lr = 0x82A114AC;
	sub_82A11758(ctx, base);
	pc = 0x82A114AC; continue 'dispatch;
            }
            0x82A114AC => {
    //   block [0x82A114AC..0x82A114BC)
	// 82A114AC: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 82A114B0: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A114B4: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A114B8: 409AFFE0  bne cr6, 0x82a11498
	if !ctx.cr[6].eq {
	pc = 0x82A11498; continue 'dispatch;
	}
	pc = 0x82A114BC; continue 'dispatch;
            }
            0x82A114BC => {
    //   block [0x82A114BC..0x82A114D4)
	// 82A114BC: 83DA0008  lwz r30, 8(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A114C0: 7D7BF050  subf r11, r27, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 82A114C4: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 82A114C8: 23EA0001  subfic r31, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[31].s64 = (1 as i64) - ctx.r[10].s64;
	// 82A114CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A114D0: 419A0024  beq cr6, 0x82a114f4
	if ctx.cr[6].eq {
	pc = 0x82A114F4; continue 'dispatch;
	}
	pc = 0x82A114D4; continue 'dispatch;
            }
            0x82A114D4 => {
    //   block [0x82A114D4..0x82A114E8)
	// 82A114D4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A114D8: 419A0010  beq cr6, 0x82a114e8
	if ctx.cr[6].eq {
	pc = 0x82A114E8; continue 'dispatch;
	}
	// 82A114DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A114E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A114E4: 48000275  bl 0x82a11758
	ctx.lr = 0x82A114E8;
	sub_82A11758(ctx, base);
	pc = 0x82A114E8; continue 'dispatch;
            }
            0x82A114E8 => {
    //   block [0x82A114E8..0x82A114F4)
	// 82A114E8: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A114EC: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 82A114F0: 4082FFE4  bne 0x82a114d4
	if !ctx.cr[0].eq {
	pc = 0x82A114D4; continue 'dispatch;
	}
	pc = 0x82A114F4; continue 'dispatch;
            }
            0x82A114F4 => {
    //   block [0x82A114F4..0x82A11510)
	// 82A114F4: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A114F8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A114FC: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 82A11500: 3BCBFFE0  addi r30, r11, -0x20
	ctx.r[30].s64 = ctx.r[11].s64 + -32;
	// 82A11504: 917A0008  stw r11, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A11508: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A1150C: 419A00A8  beq cr6, 0x82a115b4
	if ctx.cr[6].eq {
	pc = 0x82A115B4; continue 'dispatch;
	}
	pc = 0x82A11510; continue 'dispatch;
            }
            0x82A11510 => {
    //   block [0x82A11510..0x82A1152C)
	// 82A11510: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A11514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11518: 48003D19  bl 0x82a15230
	ctx.lr = 0x82A1151C;
	sub_82A15230(ctx, base);
	// 82A1151C: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A11520: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A11524: 409AFFEC  bne cr6, 0x82a11510
	if !ctx.cr[6].eq {
	pc = 0x82A11510; continue 'dispatch;
	}
	// 82A11528: 4800008C  b 0x82a115b4
	pc = 0x82A115B4; continue 'dispatch;
            }
            0x82A1152C => {
    //   block [0x82A1152C..0x82A11540)
	// 82A1152C: 3BFCFFE0  addi r31, r28, -0x20
	ctx.r[31].s64 = ctx.r[28].s64 + -32;
	// 82A11530: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82A11534: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82A11538: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A1153C: 419A0028  beq cr6, 0x82a11564
	if ctx.cr[6].eq {
	pc = 0x82A11564; continue 'dispatch;
	}
	pc = 0x82A11540; continue 'dispatch;
            }
            0x82A11540 => {
    //   block [0x82A11540..0x82A11554)
	// 82A11540: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A11544: 419A0010  beq cr6, 0x82a11554
	if ctx.cr[6].eq {
	pc = 0x82A11554; continue 'dispatch;
	}
	// 82A11548: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1154C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A11550: 48000209  bl 0x82a11758
	ctx.lr = 0x82A11554;
	sub_82A11758(ctx, base);
	pc = 0x82A11554; continue 'dispatch;
            }
            0x82A11554 => {
    //   block [0x82A11554..0x82A11564)
	// 82A11554: 3BBD0020  addi r29, r29, 0x20
	ctx.r[29].s64 = ctx.r[29].s64 + 32;
	// 82A11558: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 82A1155C: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A11560: 409AFFE0  bne cr6, 0x82a11540
	if !ctx.cr[6].eq {
	pc = 0x82A11540; continue 'dispatch;
	}
	pc = 0x82A11564; continue 'dispatch;
            }
            0x82A11564 => {
    //   block [0x82A11564..0x82A11574)
	// 82A11564: 93DA0008  stw r30, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A11568: 7F1BF840  cmplw cr6, r27, r31
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A1156C: 419A0020  beq cr6, 0x82a1158c
	if ctx.cr[6].eq {
	pc = 0x82A1158C; continue 'dispatch;
	}
	// 82A11570: 7FDFE050  subf r30, r31, r28
	ctx.r[30].s64 = ctx.r[28].s64 - ctx.r[31].s64;
	pc = 0x82A11574; continue 'dispatch;
            }
            0x82A11574 => {
    //   block [0x82A11574..0x82A1158C)
	// 82A11574: 3BFFFFE0  addi r31, r31, -0x20
	ctx.r[31].s64 = ctx.r[31].s64 + -32;
	// 82A11578: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1157C: 7C7FF214  add r3, r31, r30
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 82A11580: 48003CB1  bl 0x82a15230
	ctx.lr = 0x82A11584;
	sub_82A15230(ctx, base);
	// 82A11584: 7F1FD840  cmplw cr6, r31, r27
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A11588: 409AFFEC  bne cr6, 0x82a11574
	if !ctx.cr[6].eq {
	pc = 0x82A11574; continue 'dispatch;
	}
	pc = 0x82A1158C; continue 'dispatch;
            }
            0x82A1158C => {
    //   block [0x82A1158C..0x82A1159C)
	// 82A1158C: 3BDB0020  addi r30, r27, 0x20
	ctx.r[30].s64 = ctx.r[27].s64 + 32;
	// 82A11590: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A11594: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A11598: 419A001C  beq cr6, 0x82a115b4
	if ctx.cr[6].eq {
	pc = 0x82A115B4; continue 'dispatch;
	}
	pc = 0x82A1159C; continue 'dispatch;
            }
            0x82A1159C => {
    //   block [0x82A1159C..0x82A115B4)
	// 82A1159C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A115A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A115A4: 48003C8D  bl 0x82a15230
	ctx.lr = 0x82A115A8;
	sub_82A15230(ctx, base);
	// 82A115A8: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 82A115AC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A115B0: 409AFFEC  bne cr6, 0x82a1159c
	if !ctx.cr[6].eq {
	pc = 0x82A1159C; continue 'dispatch;
	}
	pc = 0x82A115B4; continue 'dispatch;
            }
            0x82A115B4 => {
    //   block [0x82A115B4..0x82A115C4)
	// 82A115B4: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A115B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A115BC: 419A0008  beq cr6, 0x82a115c4
	if ctx.cr[6].eq {
	pc = 0x82A115C4; continue 'dispatch;
	}
	// 82A115C0: 4B80A779  bl 0x8221bd38
	ctx.lr = 0x82A115C4;
	sub_8221BD38(ctx, base);
	pc = 0x82A115C4; continue 'dispatch;
            }
            0x82A115C4 => {
    //   block [0x82A115C4..0x82A115CC)
	// 82A115C4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A115C8: 48297E80  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A115D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A115D0 size=112
    let mut pc: u32 = 0x82A115D0;
    'dispatch: loop {
        match pc {
            0x82A115D0 => {
    //   block [0x82A115D0..0x82A11624)
	// 82A115D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A115D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A115D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A115DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A115E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A115E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A115E8: 419A003C  beq cr6, 0x82a11624
	if ctx.cr[6].eq {
	pc = 0x82A11624; continue 'dispatch;
	}
	// 82A115EC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82A115F0: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 82A115F4: 2B0A0020  cmplwi cr6, r10, 0x20
	ctx.cr[6].compare_u32(ctx.r[10].u32, 32 as u32, &mut ctx.xer);
	// 82A115F8: 4098002C  bge cr6, 0x82a11624
	if !ctx.cr[6].lt {
	pc = 0x82A11624; continue 'dispatch;
	}
	// 82A115FC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A11600: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A11604: 392B1714  addi r9, r11, 0x1714
	ctx.r[9].s64 = ctx.r[11].s64 + 5908;
	// 82A11608: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A1160C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A11610: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A11614: 4B8E080D  bl 0x822f1e20
	ctx.lr = 0x82A11618;
	sub_822F1E20(ctx, base);
	// 82A11618: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82A1161C: 38E81708  addi r7, r8, 0x1708
	ctx.r[7].s64 = ctx.r[8].s64 + 5896;
	// 82A11620: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	pc = 0x82A11624; continue 'dispatch;
            }
            0x82A11624 => {
    //   block [0x82A11624..0x82A11640)
	// 82A11624: 57E32834  slwi r3, r31, 5
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(5);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A11628: 4B80DC31  bl 0x8221f258
	ctx.lr = 0x82A1162C;
	sub_8221F258(ctx, base);
	// 82A1162C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A11630: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A11634: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A11638: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1163C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A11640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A11640 size=280
    let mut pc: u32 = 0x82A11640;
    'dispatch: loop {
        match pc {
            0x82A11640 => {
    //   block [0x82A11640..0x82A1173C)
	// 82A11640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A11644: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A11648: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1164C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A11650: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A11654: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A11658: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1165C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A11660: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A11664: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A11668: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A1166C: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A11670: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A11674: C19E000C  lfs f12, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A11678: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A1167C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11680: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A11684: 419A00B8  beq cr6, 0x82a1173c
	if ctx.cr[6].eq {
	pc = 0x82A1173C; continue 'dispatch;
	}
	// 82A11688: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82A1168C: 4B80DBCD  bl 0x8221f258
	ctx.lr = 0x82A11690;
	sub_8221F258(ctx, base);
	// 82A11690: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A11694: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11698: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A1169C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A116A0: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A116A4: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A116A8: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A116AC: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A116B0: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A116B4: D1A80004  stfs f13, 4(r8)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A116B8: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A116BC: C1870008  lfs f12, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A116C0: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A116C4: D1860008  stfs f12, 8(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A116C8: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A116CC: C165000C  lfs f11, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A116D0: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A116D4: D164000C  stfs f11, 0xc(r4)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A116D8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A116DC: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82A116E0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A116E4: D14A0010  stfs f10, 0x10(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82A116E8: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A116EC: C1290014  lfs f9, 0x14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82A116F0: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A116F4: D1280014  stfs f9, 0x14(r8)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82A116F8: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A116FC: C1070018  lfs f8, 0x18(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82A11700: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11704: D1060018  stfs f8, 0x18(r6)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A11708: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1170C: C0E5001C  lfs f7, 0x1c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82A11710: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11714: D0E4001C  stfs f7, 0x1c(r4)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82A11718: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1171C: C0CB0020  lfs f6, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82A11720: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11724: D0CA0020  stfs f6, 0x20(r10)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82A11728: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1172C: C0A90024  lfs f5, 0x24(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(36 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82A11730: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11734: D0A80024  stfs f5, 0x24(r8)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82A11738: 48000008  b 0x82a11740
	pc = 0x82A11740; continue 'dispatch;
            }
            0x82A1173C => {
    //   block [0x82A1173C..0x82A11740)
	// 82A1173C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A11740; continue 'dispatch;
            }
            0x82A11740 => {
    //   block [0x82A11740..0x82A11758)
	// 82A11740: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A11744: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A11748: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1174C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A11750: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A11754: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A11758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A11758 size=296
    let mut pc: u32 = 0x82A11758;
    'dispatch: loop {
        match pc {
            0x82A11758 => {
    //   block [0x82A11758..0x82A11880)
	// 82A11758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1175C: 48297CA9  bl 0x82ca9404
	ctx.lr = 0x82A11760;
	sub_82CA93D0(ctx, base);
	// 82A11760: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A11764: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A11768: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1176C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A11770: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 82A11774: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A11778: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1177C: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A11780: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A11784: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A11880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A11880 size=368
    let mut pc: u32 = 0x82A11880;
    'dispatch: loop {
        match pc {
            0x82A11880 => {
    //   block [0x82A11880..0x82A118D4)
	// 82A11880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A11884: 48297B85  bl 0x82ca9408
	ctx.lr = 0x82A11888;
	sub_82CA93D0(ctx, base);
	// 82A11888: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1188C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A11890: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A11894: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A11898: 386BE688  addi r3, r11, -0x1978
	ctx.r[3].s64 = ctx.r[11].s64 + -6520;
	// 82A1189C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A118A0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A118A4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A118A8: 4882F489  bl 0x83240d30
	ctx.lr = 0x82A118AC;
	sub_83240D30(ctx, base);
	// 82A118AC: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A118B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A118B4: 419A0020  beq cr6, 0x82a118d4
	if ctx.cr[6].eq {
	pc = 0x82A118D4; continue 'dispatch;
	}
	// 82A118B8: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A118BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A118C0: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A118C4: 4B7A6255  bl 0x821b7b18
	ctx.lr = 0x82A118C8;
	sub_821B7B18(ctx, base);
	// 82A118C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A118CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A118D0: 48297B88  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A118D4 => {
    //   block [0x82A118D4..0x82A11918)
	// 82A118D4: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82A118D8: 4B80D981  bl 0x8221f258
	ctx.lr = 0x82A118DC;
	sub_8221F258(ctx, base);
	// 82A118DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A118E0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A118E4: 419A0034  beq cr6, 0x82a11918
	if ctx.cr[6].eq {
	pc = 0x82A11918; continue 'dispatch;
	}
	// 82A118E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A118EC: 48832225  bl 0x83243b10
	ctx.lr = 0x82A118F0;
	sub_83243B10(ctx, base);
	// 82A118F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A118F4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82A118F8: 9BDF00E0  stb r30, 0xe0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[30].u8 ) };
	// 82A118FC: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82A11900: 9BDF00E1  stb r30, 0xe1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(225 as u32), ctx.r[30].u8 ) };
	// 82A11904: 392A4B48  addi r9, r10, 0x4b48
	ctx.r[9].s64 = ctx.r[10].s64 + 19272;
	// 82A11908: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1190C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A11910: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82A11914: 48000008  b 0x82a1191c
	pc = 0x82A1191C; continue 'dispatch;
            }
            0x82A11918 => {
    //   block [0x82A11918..0x82A1191C)
	// 82A11918: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	pc = 0x82A1191C; continue 'dispatch;
            }
            0x82A1191C => {
    //   block [0x82A1191C..0x82A11964)
	// 82A1191C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A11920: 4B7A61F9  bl 0x821b7b18
	ctx.lr = 0x82A11924;
	sub_821B7B18(ctx, base);
	// 82A11924: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A11928: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A1192C: 419A0044  beq cr6, 0x82a11970
	if ctx.cr[6].eq {
	pc = 0x82A11970; continue 'dispatch;
	}
	// 82A11930: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A11934: 4B80D925  bl 0x8221f258
	ctx.lr = 0x82A11938;
	sub_8221F258(ctx, base);
	// 82A11938: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1193C: 419A0028  beq cr6, 0x82a11964
	if ctx.cr[6].eq {
	pc = 0x82A11964; continue 'dispatch;
	}
	// 82A11940: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82A11944: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82A11948: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A1194C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82A11950: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A11954: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A11958: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A1195C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A11960: 48000014  b 0x82a11974
	pc = 0x82A11974; continue 'dispatch;
            }
            0x82A11964 => {
    //   block [0x82A11964..0x82A11970)
	// 82A11964: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82A11968: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A1196C: 48000008  b 0x82a11974
	pc = 0x82A11974; continue 'dispatch;
            }
            0x82A11970 => {
    //   block [0x82A11970..0x82A11974)
	// 82A11970: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82A11974; continue 'dispatch;
            }
            0x82A11974 => {
    //   block [0x82A11974..0x82A11984)
	// 82A11974: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82A11978: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A1197C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A11980: 419A0020  beq cr6, 0x82a119a0
	if ctx.cr[6].eq {
	pc = 0x82A119A0; continue 'dispatch;
	}
	pc = 0x82A11984; continue 'dispatch;
            }
            0x82A11984 => {
    //   block [0x82A11984..0x82A119A0)
	// 82A11984: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A11988: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1198C: 7D60F828  lwarx r11, 0, r31
	// lwarx
	let ea = ctx.r[31].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A11990: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A11994: 7D60F92D  stwcx. r11, 0, r31
	// stwcx.
	let addr = ctx.r[31].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A11998: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1199C: 4082FFE8  bne 0x82a11984
	if !ctx.cr[0].eq {
	pc = 0x82A11984; continue 'dispatch;
	}
	pc = 0x82A119A0; continue 'dispatch;
            }
            0x82A119A0 => {
    //   block [0x82A119A0..0x82A119C0)
	// 82A119A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A119A4: 4881A40D  bl 0x8322bdb0
	ctx.lr = 0x82A119A8;
	sub_8322BDB0(ctx, base);
	// 82A119A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A119AC: 4B7A616D  bl 0x821b7b18
	ctx.lr = 0x82A119B0;
	sub_821B7B18(ctx, base);
	// 82A119B0: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A119B4: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A119B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A119BC: 419A0020  beq cr6, 0x82a119dc
	if ctx.cr[6].eq {
	pc = 0x82A119DC; continue 'dispatch;
	}
	pc = 0x82A119C0; continue 'dispatch;
            }
            0x82A119C0 => {
    //   block [0x82A119C0..0x82A119DC)
	// 82A119C0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A119C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A119C8: 7D60F828  lwarx r11, 0, r31
	// lwarx
	let ea = ctx.r[31].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A119CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A119D0: 7D60F92D  stwcx. r11, 0, r31
	// stwcx.
	let addr = ctx.r[31].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A119D4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A119D8: 4082FFE8  bne 0x82a119c0
	if !ctx.cr[0].eq {
	pc = 0x82A119C0; continue 'dispatch;
	}
	pc = 0x82A119DC; continue 'dispatch;
            }
            0x82A119DC => {
    //   block [0x82A119DC..0x82A119F0)
	// 82A119DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A119E0: 4B7A6139  bl 0x821b7b18
	ctx.lr = 0x82A119E4;
	sub_821B7B18(ctx, base);
	// 82A119E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A119E8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A119EC: 48297A6C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A119F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A119F0 size=88
    let mut pc: u32 = 0x82A119F0;
    'dispatch: loop {
        match pc {
            0x82A119F0 => {
    //   block [0x82A119F0..0x82A11A3C)
	// 82A119F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A119F4: 48297A19  bl 0x82ca940c
	ctx.lr = 0x82A119F8;
	sub_82CA93D0(ctx, base);
	// 82A119F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A119FC: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82A11A00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A11A04: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A11A08: 4B80D851  bl 0x8221f258
	ctx.lr = 0x82A11A0C;
	sub_8221F258(ctx, base);
	// 82A11A0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A11A10: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A11A14: 419A0028  beq cr6, 0x82a11a3c
	if ctx.cr[6].eq {
	pc = 0x82A11A3C; continue 'dispatch;
	}
	// 82A11A18: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A11A1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A11A20: 48834859  bl 0x83246278
	ctx.lr = 0x82A11A24;
	sub_83246278(ctx, base);
	// 82A11A24: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A11A28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11A2C: 394B4B48  addi r10, r11, 0x4b48
	ctx.r[10].s64 = ctx.r[11].s64 + 19272;
	// 82A11A30: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A11A34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A11A38: 48297A24  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A11A3C => {
    //   block [0x82A11A3C..0x82A11A48)
	// 82A11A3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A11A40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A11A44: 48297A18  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A11A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A11A48 size=124
    let mut pc: u32 = 0x82A11A48;
    'dispatch: loop {
        match pc {
            0x82A11A48 => {
    //   block [0x82A11A48..0x82A11AA8)
	// 82A11A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A11A4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A11A50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A11A54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A11A58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A11A5C: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82A11A60: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A11A64: 4B80D7F5  bl 0x8221f258
	ctx.lr = 0x82A11A68;
	sub_8221F258(ctx, base);
	// 82A11A68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A11A6C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A11A70: 419A0038  beq cr6, 0x82a11aa8
	if ctx.cr[6].eq {
	pc = 0x82A11AA8; continue 'dispatch;
	}
	// 82A11A74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A11A78: 48832099  bl 0x83243b10
	ctx.lr = 0x82A11A7C;
	sub_83243B10(ctx, base);
	// 82A11A7C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A11A80: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A11A84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A11A88: 39094B48  addi r8, r9, 0x4b48
	ctx.r[8].s64 = ctx.r[9].s64 + 19272;
	// 82A11A8C: 997F00E0  stb r11, 0xe0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[11].u8 ) };
	// 82A11A90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11A94: C00A9490  lfs f0, -0x6b70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A11A98: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A11A9C: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82A11AA0: 997F00E1  stb r11, 0xe1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(225 as u32), ctx.r[11].u8 ) };
	// 82A11AA4: 48000008  b 0x82a11aac
	pc = 0x82A11AAC; continue 'dispatch;
            }
            0x82A11AA8 => {
    //   block [0x82A11AA8..0x82A11AAC)
	// 82A11AA8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82A11AAC; continue 'dispatch;
            }
            0x82A11AAC => {
    //   block [0x82A11AAC..0x82A11AC4)
	// 82A11AAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A11AB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A11AB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A11AB8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A11ABC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A11AC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A11AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A11AC8 size=444
    let mut pc: u32 = 0x82A11AC8;
    'dispatch: loop {
        match pc {
            0x82A11AC8 => {
    //   block [0x82A11AC8..0x82A11B50)
	// 82A11AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A11ACC: 48297935  bl 0x82ca9400
	ctx.lr = 0x82A11AD0;
	sub_82CA93D0(ctx, base);
	// 82A11AD0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A11AD4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A11AD8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A11ADC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A11AE0: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82A11AE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11AE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11AEC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A11AF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A11AF4: 4E800421  bctrl
	ctx.lr = 0x82A11AF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A11AF8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A11AFC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A11B00: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A11B04: 4198004C  blt cr6, 0x82a11b50
	if ctx.cr[6].lt {
	pc = 0x82A11B50; continue 'dispatch;
	}
	// 82A11B08: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A11B0C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A11B10: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82A11B14: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A11B18: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A11B1C: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A11B20: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11B24: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A11B28: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A11B2C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A11B30: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A11B34: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A11B38: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A11B3C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A11B40: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A11B44: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A11B48: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A11B4C: 48000014  b 0x82a11b60
	pc = 0x82A11B60; continue 'dispatch;
            }
            0x82A11B50 => {
    //   block [0x82A11B50..0x82A11B60)
	// 82A11B50: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A11B54: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A11B58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11B5C: 4800F38D  bl 0x82a20ee8
	ctx.lr = 0x82A11B60;
	sub_82A20EE8(ctx, base);
	pc = 0x82A11B60; continue 'dispatch;
            }
            0x82A11B60 => {
    //   block [0x82A11B60..0x82A11B94)
	// 82A11B60: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A11B64: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A11B68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A11B6C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A11B70: 419A0024  beq cr6, 0x82a11b94
	if ctx.cr[6].eq {
	pc = 0x82A11B94; continue 'dispatch;
	}
	// 82A11B74: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A11B78: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A11B7C: 89210057  lbz r9, 0x57(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 82A11B80: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A11B84: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A11B88: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82A11B8C: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A11B90: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82A11B94; continue 'dispatch;
            }
            0x82A11B94 => {
    //   block [0x82A11B94..0x82A11C00)
	// 82A11B94: 3D60BAAD  lis r11, -0x4553
	ctx.r[11].s64 = -1163067392;
	// 82A11B98: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A11B9C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A11BA0: 6169F00D  ori r9, r11, 0xf00d
	ctx.r[9].u64 = ctx.r[11].u64 | 61453;
	// 82A11BA4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A11BA8: 409A00A4  bne cr6, 0x82a11c4c
	if !ctx.cr[6].eq {
	pc = 0x82A11C4C; continue 'dispatch;
	}
	// 82A11BAC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A11BB0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A11BB4: 4198004C  blt cr6, 0x82a11c00
	if ctx.cr[6].lt {
	pc = 0x82A11C00; continue 'dispatch;
	}
	// 82A11BB8: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A11BBC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A11BC0: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82A11BC4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A11BC8: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A11BCC: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A11BD0: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11BD4: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A11BD8: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A11BDC: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A11BE0: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A11BE4: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A11BE8: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A11BEC: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A11BF0: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A11BF4: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A11BF8: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A11BFC: 48000014  b 0x82a11c10
	pc = 0x82A11C10; continue 'dispatch;
            }
            0x82A11C00 => {
    //   block [0x82A11C00..0x82A11C10)
	// 82A11C00: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A11C04: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A11C08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11C0C: 4800F2DD  bl 0x82a20ee8
	ctx.lr = 0x82A11C10;
	sub_82A20EE8(ctx, base);
	pc = 0x82A11C10; continue 'dispatch;
            }
            0x82A11C10 => {
    //   block [0x82A11C10..0x82A11C44)
	// 82A11C10: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A11C14: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A11C18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A11C1C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A11C20: 419A0024  beq cr6, 0x82a11c44
	if ctx.cr[6].eq {
	pc = 0x82A11C44; continue 'dispatch;
	}
	// 82A11C24: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A11C28: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A11C2C: 8921005B  lbz r9, 0x5b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 82A11C30: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A11C34: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A11C38: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82A11C3C: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A11C40: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82A11C44; continue 'dispatch;
            }
            0x82A11C44 => {
    //   block [0x82A11C44..0x82A11C4C)
	// 82A11C44: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A11C48: 4800001C  b 0x82a11c64
	pc = 0x82A11C64; continue 'dispatch;
            }
            0x82A11C4C => {
    //   block [0x82A11C4C..0x82A11C64)
	// 82A11C4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11C50: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A11C54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11C58: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A11C5C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A11C60: 4E800421  bctrl
	ctx.lr = 0x82A11C64;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A11C64 => {
    //   block [0x82A11C64..0x82A11C84)
	// 82A11C64: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A11C68: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82A11C6C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A11C70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A11C74: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A11C78: 488346B9  bl 0x83246330
	ctx.lr = 0x82A11C7C;
	sub_83246330(ctx, base);
	// 82A11C7C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A11C80: 482977D0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A11C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A11C88 size=92
    let mut pc: u32 = 0x82A11C88;
    'dispatch: loop {
        match pc {
            0x82A11C88 => {
    //   block [0x82A11C88..0x82A11CE4)
	// 82A11C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A11C8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A11C90: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A11C94: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A11C98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A11C9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A11CA0: 3C80BAAD  lis r4, -0x4553
	ctx.r[4].s64 = -1163067392;
	// 82A11CA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A11CA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A11CAC: 6084F00D  ori r4, r4, 0xf00d
	ctx.r[4].u64 = ctx.r[4].u64 | 61453;
	// 82A11CB0: 48010949  bl 0x82a225f8
	ctx.lr = 0x82A11CB4;
	sub_82A225F8(ctx, base);
	// 82A11CB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A11CB8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82A11CBC: 4801093D  bl 0x82a225f8
	ctx.lr = 0x82A11CC0;
	sub_82A225F8(ctx, base);
	// 82A11CC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A11CC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11CC8: 48833F71  bl 0x83245c38
	ctx.lr = 0x82A11CCC;
	sub_83245C38(ctx, base);
	// 82A11CCC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A11CD0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A11CD4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A11CD8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A11CDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A11CE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A11CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A11CE8 size=292
    let mut pc: u32 = 0x82A11CE8;
    'dispatch: loop {
        match pc {
            0x82A11CE8 => {
    //   block [0x82A11CE8..0x82A11D24)
	// 82A11CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A11CEC: 48297715  bl 0x82ca9400
	ctx.lr = 0x82A11CF0;
	sub_82CA93D0(ctx, base);
	// 82A11CF0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A11CF4: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A11CF8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A11CFC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A11D00: 3BCBFFDF  addi r30, r11, -0x21
	ctx.r[30].s64 = ctx.r[11].s64 + -33;
	// 82A11D04: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A11D08: 816AE748  lwz r11, -0x18b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6328 as u32) ) } as u64;
	// 82A11D0C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A11D10: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82A11D14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A11D18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A11D1C: 419A0008  beq cr6, 0x82a11d24
	if ctx.cr[6].eq {
	pc = 0x82A11D24; continue 'dispatch;
	}
	// 82A11D20: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A11D24; continue 'dispatch;
            }
            0x82A11D24 => {
    //   block [0x82A11D24..0x82A11D64)
	// 82A11D24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11D28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11D2C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A11D30: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A11D34: 4E800421  bctrl
	ctx.lr = 0x82A11D38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A11D38: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A11D3C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A11D40: 419A00AC  beq cr6, 0x82a11dec
	if ctx.cr[6].eq {
	pc = 0x82A11DEC; continue 'dispatch;
	}
	// 82A11D44: 3FA0834A  lis r29, -0x7cb6
	ctx.r[29].s64 = -2092302336;
	// 82A11D48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A11D4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A11D50: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A11D54: 817DE74C  lwz r11, -0x18b4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-6324 as u32) ) } as u64;
	// 82A11D58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A11D5C: 419A0008  beq cr6, 0x82a11d64
	if ctx.cr[6].eq {
	pc = 0x82A11D64; continue 'dispatch;
	}
	// 82A11D60: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A11D64 => {
    //   block [0x82A11D64..0x82A11D98)
	// 82A11D64: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11D68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11D6C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A11D70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A11D74: 4E800421  bctrl
	ctx.lr = 0x82A11D78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A11D78: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A11D7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A11D80: 419A0038  beq cr6, 0x82a11db8
	if ctx.cr[6].eq {
	pc = 0x82A11DB8; continue 'dispatch;
	}
	// 82A11D84: 817DE74C  lwz r11, -0x18b4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-6324 as u32) ) } as u64;
	// 82A11D88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A11D8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A11D90: 419A0008  beq cr6, 0x82a11d98
	if ctx.cr[6].eq {
	pc = 0x82A11D98; continue 'dispatch;
	}
	// 82A11D94: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A11D98 => {
    //   block [0x82A11D98..0x82A11DB8)
	// 82A11D98: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A11D9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11DA0: 4BA6EA29  bl 0x824807c8
	ctx.lr = 0x82A11DA4;
	sub_824807C8(ctx, base);
	// 82A11DA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11DA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11DAC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A11DB0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A11DB4: 4E800421  bctrl
	ctx.lr = 0x82A11DB8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A11DB8 => {
    //   block [0x82A11DB8..0x82A11DEC)
	// 82A11DB8: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82A11DBC: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A11DC0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A11DC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A11DC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A11DCC: 488347E5  bl 0x832465b0
	ctx.lr = 0x82A11DD0;
	sub_832465B0(ctx, base);
	// 82A11DD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11DD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11DD8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A11DDC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A11DE0: 4E800421  bctrl
	ctx.lr = 0x82A11DE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A11DE4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A11DE8: 48297668  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A11DEC => {
    //   block [0x82A11DEC..0x82A11E0C)
	// 82A11DEC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A11DF0: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82A11DF4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A11DF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A11DFC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A11E00: 488347B1  bl 0x832465b0
	ctx.lr = 0x82A11E04;
	sub_832465B0(ctx, base);
	// 82A11E04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A11E08: 48297648  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A11E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A11E10 size=240
    let mut pc: u32 = 0x82A11E10;
    'dispatch: loop {
        match pc {
            0x82A11E10 => {
    //   block [0x82A11E10..0x82A11E44)
	// 82A11E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A11E14: 482975F5  bl 0x82ca9408
	ctx.lr = 0x82A11E18;
	sub_82CA93D0(ctx, base);
	// 82A11E18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A11E1C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A11E20: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A11E24: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A11E28: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 82A11E2C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A11E30: 816AE748  lwz r11, -0x18b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6328 as u32) ) } as u64;
	// 82A11E34: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A11E38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A11E3C: 419A0008  beq cr6, 0x82a11e44
	if ctx.cr[6].eq {
	pc = 0x82A11E44; continue 'dispatch;
	}
	// 82A11E40: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A11E44; continue 'dispatch;
            }
            0x82A11E44 => {
    //   block [0x82A11E44..0x82A11E7C)
	// 82A11E44: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11E48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11E4C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A11E50: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A11E54: 4E800421  bctrl
	ctx.lr = 0x82A11E58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A11E58: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A11E5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A11E60: 419A0098  beq cr6, 0x82a11ef8
	if ctx.cr[6].eq {
	pc = 0x82A11EF8; continue 'dispatch;
	}
	// 82A11E64: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 82A11E68: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A11E6C: 817EE74C  lwz r11, -0x18b4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-6324 as u32) ) } as u64;
	// 82A11E70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A11E74: 419A0008  beq cr6, 0x82a11e7c
	if ctx.cr[6].eq {
	pc = 0x82A11E7C; continue 'dispatch;
	}
	// 82A11E78: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A11E7C => {
    //   block [0x82A11E7C..0x82A11EB8)
	// 82A11E7C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11E80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11E84: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A11E88: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A11E8C: 4E800421  bctrl
	ctx.lr = 0x82A11E90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A11E90: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A11E94: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A11E98: 419A0040  beq cr6, 0x82a11ed8
	if ctx.cr[6].eq {
	pc = 0x82A11ED8; continue 'dispatch;
	}
	// 82A11E9C: 817EE74C  lwz r11, -0x18b4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-6324 as u32) ) } as u64;
	// 82A11EA0: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 82A11EA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A11EA8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A11EAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A11EB0: 419A0008  beq cr6, 0x82a11eb8
	if ctx.cr[6].eq {
	pc = 0x82A11EB8; continue 'dispatch;
	}
	// 82A11EB4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A11EB8 => {
    //   block [0x82A11EB8..0x82A11ED8)
	// 82A11EB8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A11EBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11EC0: 4BA6E909  bl 0x824807c8
	ctx.lr = 0x82A11EC4;
	sub_824807C8(ctx, base);
	// 82A11EC4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11EC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11ECC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A11ED0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A11ED4: 4E800421  bctrl
	ctx.lr = 0x82A11ED8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A11ED8 => {
    //   block [0x82A11ED8..0x82A11EF8)
	// 82A11ED8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A11EDC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A11EE0: 48833E09  bl 0x83245ce8
	ctx.lr = 0x82A11EE4;
	sub_83245CE8(ctx, base);
	// 82A11EE4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A11EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A11EEC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A11EF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A11EF4: 4E800421  bctrl
	ctx.lr = 0x82A11EF8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A11EF8 => {
    //   block [0x82A11EF8..0x82A11F00)
	// 82A11EF8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A11EFC: 4829755C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A11F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A11F00 size=320
    let mut pc: u32 = 0x82A11F00;
    'dispatch: loop {
        match pc {
            0x82A11F00 => {
    //   block [0x82A11F00..0x82A11F54)
	// 82A11F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A11F04: 48297509  bl 0x82ca940c
	ctx.lr = 0x82A11F08;
	sub_82CA93D0(ctx, base);
	// 82A11F08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A11F0C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A11F10: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A11F14: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A11F18: 386BE688  addi r3, r11, -0x1978
	ctx.r[3].s64 = ctx.r[11].s64 + -6520;
	// 82A11F1C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A11F20: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A11F24: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A11F28: 4882EE09  bl 0x83240d30
	ctx.lr = 0x82A11F2C;
	sub_83240D30(ctx, base);
	// 82A11F2C: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A11F30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A11F34: 419A0020  beq cr6, 0x82a11f54
	if ctx.cr[6].eq {
	pc = 0x82A11F54; continue 'dispatch;
	}
	// 82A11F38: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A11F3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A11F40: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A11F44: 4B7A5BD5  bl 0x821b7b18
	ctx.lr = 0x82A11F48;
	sub_821B7B18(ctx, base);
	// 82A11F48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A11F4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A11F50: 4829750C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A11F54 => {
    //   block [0x82A11F54..0x82A11F74)
	// 82A11F54: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82A11F58: 4B80D301  bl 0x8221f258
	ctx.lr = 0x82A11F5C;
	sub_8221F258(ctx, base);
	// 82A11F5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A11F60: 419A0014  beq cr6, 0x82a11f74
	if ctx.cr[6].eq {
	pc = 0x82A11F74; continue 'dispatch;
	}
	// 82A11F64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A11F68: 48002301  bl 0x82a14268
	ctx.lr = 0x82A11F6C;
	sub_82A14268(ctx, base);
	// 82A11F6C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A11F70: 48000008  b 0x82a11f78
	pc = 0x82A11F78; continue 'dispatch;
            }
            0x82A11F74 => {
    //   block [0x82A11F74..0x82A11F78)
	// 82A11F74: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	pc = 0x82A11F78; continue 'dispatch;
            }
            0x82A11F78 => {
    //   block [0x82A11F78..0x82A11FB8)
	// 82A11F78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A11F7C: 4B7A5B9D  bl 0x821b7b18
	ctx.lr = 0x82A11F80;
	sub_821B7B18(ctx, base);
	// 82A11F80: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A11F84: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A11F88: 419A0038  beq cr6, 0x82a11fc0
	if ctx.cr[6].eq {
	pc = 0x82A11FC0; continue 'dispatch;
	}
	// 82A11F8C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A11F90: 4B80D2C9  bl 0x8221f258
	ctx.lr = 0x82A11F94;
	sub_8221F258(ctx, base);
	// 82A11F94: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A11F98: 419A0020  beq cr6, 0x82a11fb8
	if ctx.cr[6].eq {
	pc = 0x82A11FB8; continue 'dispatch;
	}
	// 82A11F9C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82A11FA0: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A11FA4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A11FA8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82A11FAC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A11FB0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A11FB4: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x82A11FB8; continue 'dispatch;
            }
            0x82A11FB8 => {
    //   block [0x82A11FB8..0x82A11FC0)
	// 82A11FB8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A11FBC: 48000008  b 0x82a11fc4
	pc = 0x82A11FC4; continue 'dispatch;
            }
            0x82A11FC0 => {
    //   block [0x82A11FC0..0x82A11FC4)
	// 82A11FC0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82A11FC4; continue 'dispatch;
            }
            0x82A11FC4 => {
    //   block [0x82A11FC4..0x82A11FD4)
	// 82A11FC4: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82A11FC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A11FCC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A11FD0: 419A0020  beq cr6, 0x82a11ff0
	if ctx.cr[6].eq {
	pc = 0x82A11FF0; continue 'dispatch;
	}
	pc = 0x82A11FD4; continue 'dispatch;
            }
            0x82A11FD4 => {
    //   block [0x82A11FD4..0x82A11FF0)
	// 82A11FD4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A11FD8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A11FDC: 7D60F828  lwarx r11, 0, r31
	// lwarx
	let ea = ctx.r[31].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A11FE0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A11FE4: 7D60F92D  stwcx. r11, 0, r31
	// stwcx.
	let addr = ctx.r[31].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A11FE8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A11FEC: 4082FFE8  bne 0x82a11fd4
	if !ctx.cr[0].eq {
	pc = 0x82A11FD4; continue 'dispatch;
	}
	pc = 0x82A11FF0; continue 'dispatch;
            }
            0x82A11FF0 => {
    //   block [0x82A11FF0..0x82A12010)
	// 82A11FF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A11FF4: 48819DBD  bl 0x8322bdb0
	ctx.lr = 0x82A11FF8;
	sub_8322BDB0(ctx, base);
	// 82A11FF8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A11FFC: 4B7A5B1D  bl 0x821b7b18
	ctx.lr = 0x82A12000;
	sub_821B7B18(ctx, base);
	// 82A12000: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A12004: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A12008: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A1200C: 419A0020  beq cr6, 0x82a1202c
	if ctx.cr[6].eq {
	pc = 0x82A1202C; continue 'dispatch;
	}
	pc = 0x82A12010; continue 'dispatch;
            }
            0x82A12010 => {
    //   block [0x82A12010..0x82A1202C)
	// 82A12010: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A12014: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A12018: 7D60F828  lwarx r11, 0, r31
	// lwarx
	let ea = ctx.r[31].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A1201C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A12020: 7D60F92D  stwcx. r11, 0, r31
	// stwcx.
	let addr = ctx.r[31].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A12024: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A12028: 4082FFE8  bne 0x82a12010
	if !ctx.cr[0].eq {
	pc = 0x82A12010; continue 'dispatch;
	}
	pc = 0x82A1202C; continue 'dispatch;
            }
            0x82A1202C => {
    //   block [0x82A1202C..0x82A12040)
	// 82A1202C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A12030: 4B7A5AE9  bl 0x821b7b18
	ctx.lr = 0x82A12034;
	sub_821B7B18(ctx, base);
	// 82A12034: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A12038: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1203C: 48297420  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A12040(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A12040 size=112
    let mut pc: u32 = 0x82A12040;
    'dispatch: loop {
        match pc {
            0x82A12040 => {
    //   block [0x82A12040..0x82A120A4)
	// 82A12040: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A12044: 482973C9  bl 0x82ca940c
	ctx.lr = 0x82A12048;
	sub_82CA93D0(ctx, base);
	// 82A12048: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1204C: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82A12050: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A12054: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A12058: 4B80D201  bl 0x8221f258
	ctx.lr = 0x82A1205C;
	sub_8221F258(ctx, base);
	// 82A1205C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A12060: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A12064: 419A0040  beq cr6, 0x82a120a4
	if ctx.cr[6].eq {
	pc = 0x82A120A4; continue 'dispatch;
	}
	// 82A12068: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1206C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A12070: 48834209  bl 0x83246278
	ctx.lr = 0x82A12074;
	sub_83246278(ctx, base);
	// 82A12074: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A12078: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A1207C: 392B4B08  addi r9, r11, 0x4b08
	ctx.r[9].s64 = ctx.r[11].s64 + 19208;
	// 82A12080: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A12084: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A12088: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1208C: 997F00F4  stb r11, 0xf4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u8 ) };
	// 82A12090: C00AB650  lfs f0, -0x49b0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A12094: 997F00F5  stb r11, 0xf5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(245 as u32), ctx.r[11].u8 ) };
	// 82A12098: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82A1209C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A120A0: 482973BC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A120A4 => {
    //   block [0x82A120A4..0x82A120B0)
	// 82A120A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A120A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A120AC: 482973B0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A120B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A120B0 size=88
    let mut pc: u32 = 0x82A120B0;
    'dispatch: loop {
        match pc {
            0x82A120B0 => {
    //   block [0x82A120B0..0x82A120F0)
	// 82A120B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A120B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A120B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A120BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A120C0: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82A120C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A120C8: 4B80D191  bl 0x8221f258
	ctx.lr = 0x82A120CC;
	sub_8221F258(ctx, base);
	// 82A120CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A120D0: 419A0020  beq cr6, 0x82a120f0
	if ctx.cr[6].eq {
	pc = 0x82A120F0; continue 'dispatch;
	}
	// 82A120D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A120D8: 48002191  bl 0x82a14268
	ctx.lr = 0x82A120DC;
	sub_82A14268(ctx, base);
	// 82A120DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A120E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A120E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A120E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A120EC: 4E800020  blr
	return;
            }
            0x82A120F0 => {
    //   block [0x82A120F0..0x82A12108)
	// 82A120F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A120F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A120F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A120FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A12100: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A12104: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A12108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A12108 size=456
    let mut pc: u32 = 0x82A12108;
    'dispatch: loop {
        match pc {
            0x82A12108 => {
    //   block [0x82A12108..0x82A12190)
	// 82A12108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1210C: 482972F5  bl 0x82ca9400
	ctx.lr = 0x82A12110;
	sub_82CA93D0(ctx, base);
	// 82A12110: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A12114: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A12118: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A1211C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A12120: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82A12124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12128: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1212C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A12130: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A12134: 4E800421  bctrl
	ctx.lr = 0x82A12138;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A12138: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A1213C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A12140: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A12144: 4198004C  blt cr6, 0x82a12190
	if ctx.cr[6].lt {
	pc = 0x82A12190; continue 'dispatch;
	}
	// 82A12148: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A1214C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A12150: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82A12154: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A12158: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A1215C: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A12160: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A12164: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A12168: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A1216C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A12170: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A12174: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A12178: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A1217C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A12180: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A12184: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A12188: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A1218C: 48000014  b 0x82a121a0
	pc = 0x82A121A0; continue 'dispatch;
            }
            0x82A12190 => {
    //   block [0x82A12190..0x82A121A0)
	// 82A12190: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A12194: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A12198: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1219C: 4800ED4D  bl 0x82a20ee8
	ctx.lr = 0x82A121A0;
	sub_82A20EE8(ctx, base);
	pc = 0x82A121A0; continue 'dispatch;
            }
            0x82A121A0 => {
    //   block [0x82A121A0..0x82A121D4)
	// 82A121A0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A121A4: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A121A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A121AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A121B0: 419A0024  beq cr6, 0x82a121d4
	if ctx.cr[6].eq {
	pc = 0x82A121D4; continue 'dispatch;
	}
	// 82A121B4: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A121B8: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A121BC: 89210057  lbz r9, 0x57(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 82A121C0: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A121C4: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A121C8: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82A121CC: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A121D0: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82A121D4; continue 'dispatch;
            }
            0x82A121D4 => {
    //   block [0x82A121D4..0x82A12240)
	// 82A121D4: 3D60BAAD  lis r11, -0x4553
	ctx.r[11].s64 = -1163067392;
	// 82A121D8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A121DC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A121E0: 6169F00D  ori r9, r11, 0xf00d
	ctx.r[9].u64 = ctx.r[11].u64 | 61453;
	// 82A121E4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A121E8: 409A00B0  bne cr6, 0x82a12298
	if !ctx.cr[6].eq {
	pc = 0x82A12298; continue 'dispatch;
	}
	// 82A121EC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A121F0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A121F4: 4198004C  blt cr6, 0x82a12240
	if ctx.cr[6].lt {
	pc = 0x82A12240; continue 'dispatch;
	}
	// 82A121F8: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A121FC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A12200: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82A12204: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A12208: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A1220C: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A12210: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A12214: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A12218: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A1221C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A12220: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A12224: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A12228: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A1222C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A12230: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A12234: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A12238: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A1223C: 48000014  b 0x82a12250
	pc = 0x82A12250; continue 'dispatch;
            }
            0x82A12240 => {
    //   block [0x82A12240..0x82A12250)
	// 82A12240: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A12244: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A12248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1224C: 4800EC9D  bl 0x82a20ee8
	ctx.lr = 0x82A12250;
	sub_82A20EE8(ctx, base);
	pc = 0x82A12250; continue 'dispatch;
            }
            0x82A12250 => {
    //   block [0x82A12250..0x82A12284)
	// 82A12250: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A12254: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A12258: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1225C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A12260: 419A0024  beq cr6, 0x82a12284
	if ctx.cr[6].eq {
	pc = 0x82A12284; continue 'dispatch;
	}
	// 82A12264: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A12268: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A1226C: 8921005B  lbz r9, 0x5b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 82A12270: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A12274: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A12278: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82A1227C: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A12280: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82A12284; continue 'dispatch;
            }
            0x82A12284 => {
    //   block [0x82A12284..0x82A12298)
	// 82A12284: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A12288: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1228C: 387C00F0  addi r3, r28, 0xf0
	ctx.r[3].s64 = ctx.r[28].s64 + 240;
	// 82A12290: 48812209  bl 0x83224498
	ctx.lr = 0x82A12294;
	sub_83224498(ctx, base);
	// 82A12294: 4800001C  b 0x82a122b0
	pc = 0x82A122B0; continue 'dispatch;
            }
            0x82A12298 => {
    //   block [0x82A12298..0x82A122B0)
	// 82A12298: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1229C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A122A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A122A4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A122A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A122AC: 4E800421  bctrl
	ctx.lr = 0x82A122B0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A122B0 => {
    //   block [0x82A122B0..0x82A122D0)
	// 82A122B0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A122B4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82A122B8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A122BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A122C0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A122C4: 4883406D  bl 0x83246330
	ctx.lr = 0x82A122C8;
	sub_83246330(ctx, base);
	// 82A122C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A122CC: 48297184  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A122D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A122D0 size=104
    let mut pc: u32 = 0x82A122D0;
    'dispatch: loop {
        match pc {
            0x82A122D0 => {
    //   block [0x82A122D0..0x82A12338)
	// 82A122D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A122D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A122D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A122DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A122E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A122E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A122E8: 3C80BAAD  lis r4, -0x4553
	ctx.r[4].s64 = -1163067392;
	// 82A122EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A122F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A122F4: 6084F00D  ori r4, r4, 0xf00d
	ctx.r[4].u64 = ctx.r[4].u64 | 61453;
	// 82A122F8: 48010301  bl 0x82a225f8
	ctx.lr = 0x82A122FC;
	sub_82A225F8(ctx, base);
	// 82A122FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A12300: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82A12304: 480102F5  bl 0x82a225f8
	ctx.lr = 0x82A12308;
	sub_82A225F8(ctx, base);
	// 82A12308: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1230C: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 82A12310: 48811FD9  bl 0x832242e8
	ctx.lr = 0x82A12314;
	sub_832242E8(ctx, base);
	// 82A12314: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A12318: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1231C: 4883391D  bl 0x83245c38
	ctx.lr = 0x82A12320;
	sub_83245C38(ctx, base);
	// 82A12320: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A12324: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A12328: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1232C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A12330: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A12334: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A12338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A12338 size=304
    let mut pc: u32 = 0x82A12338;
    'dispatch: loop {
        match pc {
            0x82A12338 => {
    //   block [0x82A12338..0x82A12374)
	// 82A12338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1233C: 482970C5  bl 0x82ca9400
	ctx.lr = 0x82A12340;
	sub_82CA93D0(ctx, base);
	// 82A12340: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A12344: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A12348: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A1234C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A12350: 3BCBFFDF  addi r30, r11, -0x21
	ctx.r[30].s64 = ctx.r[11].s64 + -33;
	// 82A12354: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A12358: 816AE748  lwz r11, -0x18b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6328 as u32) ) } as u64;
	// 82A1235C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A12360: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82A12364: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A12368: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1236C: 419A0008  beq cr6, 0x82a12374
	if ctx.cr[6].eq {
	pc = 0x82A12374; continue 'dispatch;
	}
	// 82A12370: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A12374; continue 'dispatch;
            }
            0x82A12374 => {
    //   block [0x82A12374..0x82A123B4)
	// 82A12374: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A12378: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1237C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A12380: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A12384: 4E800421  bctrl
	ctx.lr = 0x82A12388;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A12388: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1238C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A12390: 419A00B8  beq cr6, 0x82a12448
	if ctx.cr[6].eq {
	pc = 0x82A12448; continue 'dispatch;
	}
	// 82A12394: 3FA0834A  lis r29, -0x7cb6
	ctx.r[29].s64 = -2092302336;
	// 82A12398: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1239C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A123A0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A123A4: 817DE74C  lwz r11, -0x18b4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-6324 as u32) ) } as u64;
	// 82A123A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A123AC: 419A0008  beq cr6, 0x82a123b4
	if ctx.cr[6].eq {
	pc = 0x82A123B4; continue 'dispatch;
	}
	// 82A123B0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A123B4 => {
    //   block [0x82A123B4..0x82A123E8)
	// 82A123B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A123B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A123BC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A123C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A123C4: 4E800421  bctrl
	ctx.lr = 0x82A123C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A123C8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A123CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A123D0: 419A0038  beq cr6, 0x82a12408
	if ctx.cr[6].eq {
	pc = 0x82A12408; continue 'dispatch;
	}
	// 82A123D4: 817DE74C  lwz r11, -0x18b4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-6324 as u32) ) } as u64;
	// 82A123D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A123DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A123E0: 419A0008  beq cr6, 0x82a123e8
	if ctx.cr[6].eq {
	pc = 0x82A123E8; continue 'dispatch;
	}
	// 82A123E4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A123E8 => {
    //   block [0x82A123E8..0x82A12408)
	// 82A123E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A123EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A123F0: 4BA6E3D9  bl 0x824807c8
	ctx.lr = 0x82A123F4;
	sub_824807C8(ctx, base);
	// 82A123F4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A123F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A123FC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A12400: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A12404: 4E800421  bctrl
	ctx.lr = 0x82A12408;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A12408 => {
    //   block [0x82A12408..0x82A12448)
	// 82A12408: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1240C: 387C00F0  addi r3, r28, 0xf0
	ctx.r[3].s64 = ctx.r[28].s64 + 240;
	// 82A12410: 48811F79  bl 0x83224388
	ctx.lr = 0x82A12414;
	sub_83224388(ctx, base);
	// 82A12414: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82A12418: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A1241C: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A12420: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A12424: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A12428: 48834189  bl 0x832465b0
	ctx.lr = 0x82A1242C;
	sub_832465B0(ctx, base);
	// 82A1242C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A12430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12434: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A12438: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A1243C: 4E800421  bctrl
	ctx.lr = 0x82A12440;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A12440: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A12444: 4829700C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A12448 => {
    //   block [0x82A12448..0x82A12468)
	// 82A12448: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A1244C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82A12450: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A12454: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A12458: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1245C: 48834155  bl 0x832465b0
	ctx.lr = 0x82A12460;
	sub_832465B0(ctx, base);
	// 82A12460: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A12464: 48296FEC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A12468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A12468 size=252
    let mut pc: u32 = 0x82A12468;
    'dispatch: loop {
        match pc {
            0x82A12468 => {
    //   block [0x82A12468..0x82A1249C)
	// 82A12468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1246C: 48296F9D  bl 0x82ca9408
	ctx.lr = 0x82A12470;
	sub_82CA93D0(ctx, base);
	// 82A12470: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A12474: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A12478: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A1247C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A12480: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 82A12484: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A12488: 816AE748  lwz r11, -0x18b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6328 as u32) ) } as u64;
	// 82A1248C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A12490: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A12494: 419A0008  beq cr6, 0x82a1249c
	if ctx.cr[6].eq {
	pc = 0x82A1249C; continue 'dispatch;
	}
	// 82A12498: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1249C; continue 'dispatch;
            }
            0x82A1249C => {
    //   block [0x82A1249C..0x82A124D4)
	// 82A1249C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A124A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A124A4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A124A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A124AC: 4E800421  bctrl
	ctx.lr = 0x82A124B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A124B0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A124B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A124B8: 419A00A4  beq cr6, 0x82a1255c
	if ctx.cr[6].eq {
	pc = 0x82A1255C; continue 'dispatch;
	}
	// 82A124BC: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 82A124C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A124C4: 817EE74C  lwz r11, -0x18b4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-6324 as u32) ) } as u64;
	// 82A124C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A124CC: 419A0008  beq cr6, 0x82a124d4
	if ctx.cr[6].eq {
	pc = 0x82A124D4; continue 'dispatch;
	}
	// 82A124D0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A124D4 => {
    //   block [0x82A124D4..0x82A12510)
	// 82A124D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A124D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A124DC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A124E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A124E4: 4E800421  bctrl
	ctx.lr = 0x82A124E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A124E8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A124EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A124F0: 419A0040  beq cr6, 0x82a12530
	if ctx.cr[6].eq {
	pc = 0x82A12530; continue 'dispatch;
	}
	// 82A124F4: 817EE74C  lwz r11, -0x18b4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-6324 as u32) ) } as u64;
	// 82A124F8: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 82A124FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A12500: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A12504: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A12508: 419A0008  beq cr6, 0x82a12510
	if ctx.cr[6].eq {
	pc = 0x82A12510; continue 'dispatch;
	}
	// 82A1250C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A12510 => {
    //   block [0x82A12510..0x82A12530)
	// 82A12510: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A12514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12518: 4BA6E2B1  bl 0x824807c8
	ctx.lr = 0x82A1251C;
	sub_824807C8(ctx, base);
	// 82A1251C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A12520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12524: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A12528: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A1252C: 4E800421  bctrl
	ctx.lr = 0x82A12530;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A12530 => {
    //   block [0x82A12530..0x82A1255C)
	// 82A12530: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A12534: 387C00F0  addi r3, r28, 0xf0
	ctx.r[3].s64 = ctx.r[28].s64 + 240;
	// 82A12538: 48811ED9  bl 0x83224410
	ctx.lr = 0x82A1253C;
	sub_83224410(ctx, base);
	// 82A1253C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A12540: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A12544: 488337A5  bl 0x83245ce8
	ctx.lr = 0x82A12548;
	sub_83245CE8(ctx, base);
	// 82A12548: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1254C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12550: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A12554: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A12558: 4E800421  bctrl
	ctx.lr = 0x82A1255C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A1255C => {
    //   block [0x82A1255C..0x82A12564)
	// 82A1255C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A12560: 48296EF8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A12568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A12568 size=320
    let mut pc: u32 = 0x82A12568;
    'dispatch: loop {
        match pc {
            0x82A12568 => {
    //   block [0x82A12568..0x82A125BC)
	// 82A12568: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1256C: 48296EA1  bl 0x82ca940c
	ctx.lr = 0x82A12570;
	sub_82CA93D0(ctx, base);
	// 82A12570: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A12574: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A12578: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A1257C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A12580: 386BE688  addi r3, r11, -0x1978
	ctx.r[3].s64 = ctx.r[11].s64 + -6520;
	// 82A12584: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A12588: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A1258C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A12590: 4882E7A1  bl 0x83240d30
	ctx.lr = 0x82A12594;
	sub_83240D30(ctx, base);
	// 82A12594: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A12598: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1259C: 419A0020  beq cr6, 0x82a125bc
	if ctx.cr[6].eq {
	pc = 0x82A125BC; continue 'dispatch;
	}
	// 82A125A0: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A125A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A125A8: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A125AC: 4B7A556D  bl 0x821b7b18
	ctx.lr = 0x82A125B0;
	sub_821B7B18(ctx, base);
	// 82A125B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A125B4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A125B8: 48296EA4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A125BC => {
    //   block [0x82A125BC..0x82A125DC)
	// 82A125BC: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82A125C0: 4B80CC99  bl 0x8221f258
	ctx.lr = 0x82A125C4;
	sub_8221F258(ctx, base);
	// 82A125C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A125C8: 419A0014  beq cr6, 0x82a125dc
	if ctx.cr[6].eq {
	pc = 0x82A125DC; continue 'dispatch;
	}
	// 82A125CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A125D0: 48001D01  bl 0x82a142d0
	ctx.lr = 0x82A125D4;
	sub_82A142D0(ctx, base);
	// 82A125D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A125D8: 48000008  b 0x82a125e0
	pc = 0x82A125E0; continue 'dispatch;
            }
            0x82A125DC => {
    //   block [0x82A125DC..0x82A125E0)
	// 82A125DC: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	pc = 0x82A125E0; continue 'dispatch;
            }
            0x82A125E0 => {
    //   block [0x82A125E0..0x82A12620)
	// 82A125E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A125E4: 4B7A5535  bl 0x821b7b18
	ctx.lr = 0x82A125E8;
	sub_821B7B18(ctx, base);
	// 82A125E8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A125EC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A125F0: 419A0038  beq cr6, 0x82a12628
	if ctx.cr[6].eq {
	pc = 0x82A12628; continue 'dispatch;
	}
	// 82A125F4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A125F8: 4B80CC61  bl 0x8221f258
	ctx.lr = 0x82A125FC;
	sub_8221F258(ctx, base);
	// 82A125FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A12600: 419A0020  beq cr6, 0x82a12620
	if ctx.cr[6].eq {
	pc = 0x82A12620; continue 'dispatch;
	}
	// 82A12604: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82A12608: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A1260C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A12610: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82A12614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A12618: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1261C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x82A12620; continue 'dispatch;
            }
            0x82A12620 => {
    //   block [0x82A12620..0x82A12628)
	// 82A12620: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A12624: 48000008  b 0x82a1262c
	pc = 0x82A1262C; continue 'dispatch;
            }
            0x82A12628 => {
    //   block [0x82A12628..0x82A1262C)
	// 82A12628: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82A1262C; continue 'dispatch;
            }
            0x82A1262C => {
    //   block [0x82A1262C..0x82A1263C)
	// 82A1262C: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82A12630: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A12634: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A12638: 419A0020  beq cr6, 0x82a12658
	if ctx.cr[6].eq {
	pc = 0x82A12658; continue 'dispatch;
	}
	pc = 0x82A1263C; continue 'dispatch;
            }
            0x82A1263C => {
    //   block [0x82A1263C..0x82A12658)
	// 82A1263C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A12640: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A12644: 7D60F828  lwarx r11, 0, r31
	// lwarx
	let ea = ctx.r[31].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A12648: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A1264C: 7D60F92D  stwcx. r11, 0, r31
	// stwcx.
	let addr = ctx.r[31].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A12650: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A12654: 4082FFE8  bne 0x82a1263c
	if !ctx.cr[0].eq {
	pc = 0x82A1263C; continue 'dispatch;
	}
	pc = 0x82A12658; continue 'dispatch;
            }
            0x82A12658 => {
    //   block [0x82A12658..0x82A12678)
	// 82A12658: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1265C: 48819755  bl 0x8322bdb0
	ctx.lr = 0x82A12660;
	sub_8322BDB0(ctx, base);
	// 82A12660: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A12664: 4B7A54B5  bl 0x821b7b18
	ctx.lr = 0x82A12668;
	sub_821B7B18(ctx, base);
	// 82A12668: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A1266C: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A12670: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A12674: 419A0020  beq cr6, 0x82a12694
	if ctx.cr[6].eq {
	pc = 0x82A12694; continue 'dispatch;
	}
	pc = 0x82A12678; continue 'dispatch;
            }
            0x82A12678 => {
    //   block [0x82A12678..0x82A12694)
	// 82A12678: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A1267C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A12680: 7D60F828  lwarx r11, 0, r31
	// lwarx
	let ea = ctx.r[31].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A12684: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A12688: 7D60F92D  stwcx. r11, 0, r31
	// stwcx.
	let addr = ctx.r[31].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1268C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A12690: 4082FFE8  bne 0x82a12678
	if !ctx.cr[0].eq {
	pc = 0x82A12678; continue 'dispatch;
	}
	pc = 0x82A12694; continue 'dispatch;
            }
            0x82A12694 => {
    //   block [0x82A12694..0x82A126A8)
	// 82A12694: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A12698: 4B7A5481  bl 0x821b7b18
	ctx.lr = 0x82A1269C;
	sub_821B7B18(ctx, base);
	// 82A1269C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A126A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A126A4: 48296DB8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A126A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A126A8 size=112
    let mut pc: u32 = 0x82A126A8;
    'dispatch: loop {
        match pc {
            0x82A126A8 => {
    //   block [0x82A126A8..0x82A1270C)
	// 82A126A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A126AC: 48296D61  bl 0x82ca940c
	ctx.lr = 0x82A126B0;
	sub_82CA93D0(ctx, base);
	// 82A126B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A126B4: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82A126B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A126BC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A126C0: 4B80CB99  bl 0x8221f258
	ctx.lr = 0x82A126C4;
	sub_8221F258(ctx, base);
	// 82A126C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A126C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A126CC: 419A0040  beq cr6, 0x82a1270c
	if ctx.cr[6].eq {
	pc = 0x82A1270C; continue 'dispatch;
	}
	// 82A126D0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A126D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A126D8: 48833BA1  bl 0x83246278
	ctx.lr = 0x82A126DC;
	sub_83246278(ctx, base);
	// 82A126DC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A126E0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A126E4: 392B5158  addi r9, r11, 0x5158
	ctx.r[9].s64 = ctx.r[11].s64 + 20824;
	// 82A126E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A126EC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A126F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A126F4: 997F00F4  stb r11, 0xf4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u8 ) };
	// 82A126F8: C00AB650  lfs f0, -0x49b0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A126FC: 997F00F5  stb r11, 0xf5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(245 as u32), ctx.r[11].u8 ) };
	// 82A12700: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82A12704: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A12708: 48296D54  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A1270C => {
    //   block [0x82A1270C..0x82A12718)
	// 82A1270C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A12710: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A12714: 48296D48  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A12718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A12718 size=88
    let mut pc: u32 = 0x82A12718;
    'dispatch: loop {
        match pc {
            0x82A12718 => {
    //   block [0x82A12718..0x82A12758)
	// 82A12718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1271C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A12720: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A12724: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A12728: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82A1272C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A12730: 4B80CB29  bl 0x8221f258
	ctx.lr = 0x82A12734;
	sub_8221F258(ctx, base);
	// 82A12734: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A12738: 419A0020  beq cr6, 0x82a12758
	if ctx.cr[6].eq {
	pc = 0x82A12758; continue 'dispatch;
	}
	// 82A1273C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A12740: 48001B91  bl 0x82a142d0
	ctx.lr = 0x82A12744;
	sub_82A142D0(ctx, base);
	// 82A12744: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A12748: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1274C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A12750: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A12754: 4E800020  blr
	return;
            }
            0x82A12758 => {
    //   block [0x82A12758..0x82A12770)
	// 82A12758: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A1275C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A12760: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A12764: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A12768: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1276C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A12770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A12770 size=456
    let mut pc: u32 = 0x82A12770;
    'dispatch: loop {
        match pc {
            0x82A12770 => {
    //   block [0x82A12770..0x82A127F8)
	// 82A12770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A12774: 48296C8D  bl 0x82ca9400
	ctx.lr = 0x82A12778;
	sub_82CA93D0(ctx, base);
	// 82A12778: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1277C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A12780: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A12784: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A12788: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82A1278C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12790: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A12794: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A12798: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A1279C: 4E800421  bctrl
	ctx.lr = 0x82A127A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A127A0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A127A4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A127A8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A127AC: 4198004C  blt cr6, 0x82a127f8
	if ctx.cr[6].lt {
	pc = 0x82A127F8; continue 'dispatch;
	}
	// 82A127B0: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A127B4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A127B8: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82A127BC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A127C0: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A127C4: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A127C8: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A127CC: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A127D0: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A127D4: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A127D8: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A127DC: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A127E0: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A127E4: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A127E8: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A127EC: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A127F0: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A127F4: 48000014  b 0x82a12808
	pc = 0x82A12808; continue 'dispatch;
            }
            0x82A127F8 => {
    //   block [0x82A127F8..0x82A12808)
	// 82A127F8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A127FC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A12800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12804: 4800E6E5  bl 0x82a20ee8
	ctx.lr = 0x82A12808;
	sub_82A20EE8(ctx, base);
	pc = 0x82A12808; continue 'dispatch;
            }
            0x82A12808 => {
    //   block [0x82A12808..0x82A1283C)
	// 82A12808: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A1280C: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A12810: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A12814: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A12818: 419A0024  beq cr6, 0x82a1283c
	if ctx.cr[6].eq {
	pc = 0x82A1283C; continue 'dispatch;
	}
	// 82A1281C: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A12820: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A12824: 89210057  lbz r9, 0x57(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 82A12828: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A1282C: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A12830: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82A12834: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A12838: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82A1283C; continue 'dispatch;
            }
            0x82A1283C => {
    //   block [0x82A1283C..0x82A128A8)
	// 82A1283C: 3D60BAAD  lis r11, -0x4553
	ctx.r[11].s64 = -1163067392;
	// 82A12840: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A12844: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A12848: 6169F00D  ori r9, r11, 0xf00d
	ctx.r[9].u64 = ctx.r[11].u64 | 61453;
	// 82A1284C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A12850: 409A00B0  bne cr6, 0x82a12900
	if !ctx.cr[6].eq {
	pc = 0x82A12900; continue 'dispatch;
	}
	// 82A12854: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A12858: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A1285C: 4198004C  blt cr6, 0x82a128a8
	if ctx.cr[6].lt {
	pc = 0x82A128A8; continue 'dispatch;
	}
	// 82A12860: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A12864: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A12868: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82A1286C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A12870: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A12874: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A12878: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1287C: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A12880: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A12884: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A12888: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A1288C: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A12890: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A12894: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A12898: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A1289C: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A128A0: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A128A4: 48000014  b 0x82a128b8
	pc = 0x82A128B8; continue 'dispatch;
            }
            0x82A128A8 => {
    //   block [0x82A128A8..0x82A128B8)
	// 82A128A8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A128AC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A128B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A128B4: 4800E635  bl 0x82a20ee8
	ctx.lr = 0x82A128B8;
	sub_82A20EE8(ctx, base);
	pc = 0x82A128B8; continue 'dispatch;
            }
            0x82A128B8 => {
    //   block [0x82A128B8..0x82A128EC)
	// 82A128B8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A128BC: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A128C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A128C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A128C8: 419A0024  beq cr6, 0x82a128ec
	if ctx.cr[6].eq {
	pc = 0x82A128EC; continue 'dispatch;
	}
	// 82A128CC: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A128D0: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A128D4: 8921005B  lbz r9, 0x5b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 82A128D8: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A128DC: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A128E0: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82A128E4: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A128E8: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82A128EC; continue 'dispatch;
            }
            0x82A128EC => {
    //   block [0x82A128EC..0x82A12900)
	// 82A128EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A128F0: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A128F4: 387C00F0  addi r3, r28, 0xf0
	ctx.r[3].s64 = ctx.r[28].s64 + 240;
	// 82A128F8: 48811631  bl 0x83223f28
	ctx.lr = 0x82A128FC;
	sub_83223F28(ctx, base);
	// 82A128FC: 4800001C  b 0x82a12918
	pc = 0x82A12918; continue 'dispatch;
            }
            0x82A12900 => {
    //   block [0x82A12900..0x82A12918)
	// 82A12900: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A12904: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A12908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1290C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A12910: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A12914: 4E800421  bctrl
	ctx.lr = 0x82A12918;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A12918 => {
    //   block [0x82A12918..0x82A12938)
	// 82A12918: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A1291C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82A12920: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A12924: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A12928: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1292C: 48833A05  bl 0x83246330
	ctx.lr = 0x82A12930;
	sub_83246330(ctx, base);
	// 82A12930: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A12934: 48296B1C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A12938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A12938 size=104
    let mut pc: u32 = 0x82A12938;
    'dispatch: loop {
        match pc {
            0x82A12938 => {
    //   block [0x82A12938..0x82A129A0)
	// 82A12938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1293C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A12940: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A12944: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A12948: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1294C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A12950: 3C80BAAD  lis r4, -0x4553
	ctx.r[4].s64 = -1163067392;
	// 82A12954: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A12958: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1295C: 6084F00D  ori r4, r4, 0xf00d
	ctx.r[4].u64 = ctx.r[4].u64 | 61453;
	// 82A12960: 4800FC99  bl 0x82a225f8
	ctx.lr = 0x82A12964;
	sub_82A225F8(ctx, base);
	// 82A12964: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A12968: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82A1296C: 4800FC8D  bl 0x82a225f8
	ctx.lr = 0x82A12970;
	sub_82A225F8(ctx, base);
	// 82A12970: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A12974: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 82A12978: 48811401  bl 0x83223d78
	ctx.lr = 0x82A1297C;
	sub_83223D78(ctx, base);
	// 82A1297C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A12980: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12984: 488332B5  bl 0x83245c38
	ctx.lr = 0x82A12988;
	sub_83245C38(ctx, base);
	// 82A12988: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1298C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A12990: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A12994: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A12998: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1299C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A129A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A129A0 size=304
    let mut pc: u32 = 0x82A129A0;
    'dispatch: loop {
        match pc {
            0x82A129A0 => {
    //   block [0x82A129A0..0x82A129DC)
	// 82A129A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A129A4: 48296A5D  bl 0x82ca9400
	ctx.lr = 0x82A129A8;
	sub_82CA93D0(ctx, base);
	// 82A129A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A129AC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A129B0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A129B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A129B8: 3BCBFFDF  addi r30, r11, -0x21
	ctx.r[30].s64 = ctx.r[11].s64 + -33;
	// 82A129BC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A129C0: 816AE748  lwz r11, -0x18b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6328 as u32) ) } as u64;
	// 82A129C4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A129C8: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82A129CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A129D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A129D4: 419A0008  beq cr6, 0x82a129dc
	if ctx.cr[6].eq {
	pc = 0x82A129DC; continue 'dispatch;
	}
	// 82A129D8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A129DC; continue 'dispatch;
            }
            0x82A129DC => {
    //   block [0x82A129DC..0x82A12A1C)
	// 82A129DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A129E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A129E4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A129E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A129EC: 4E800421  bctrl
	ctx.lr = 0x82A129F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A129F0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A129F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A129F8: 419A00B8  beq cr6, 0x82a12ab0
	if ctx.cr[6].eq {
	pc = 0x82A12AB0; continue 'dispatch;
	}
	// 82A129FC: 3FA0834A  lis r29, -0x7cb6
	ctx.r[29].s64 = -2092302336;
	// 82A12A00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A12A04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A12A08: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A12A0C: 817DE74C  lwz r11, -0x18b4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-6324 as u32) ) } as u64;
	// 82A12A10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A12A14: 419A0008  beq cr6, 0x82a12a1c
	if ctx.cr[6].eq {
	pc = 0x82A12A1C; continue 'dispatch;
	}
	// 82A12A18: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A12A1C => {
    //   block [0x82A12A1C..0x82A12A50)
	// 82A12A1C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A12A20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12A24: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A12A28: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A12A2C: 4E800421  bctrl
	ctx.lr = 0x82A12A30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A12A30: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A12A34: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A12A38: 419A0038  beq cr6, 0x82a12a70
	if ctx.cr[6].eq {
	pc = 0x82A12A70; continue 'dispatch;
	}
	// 82A12A3C: 817DE74C  lwz r11, -0x18b4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-6324 as u32) ) } as u64;
	// 82A12A40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A12A44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A12A48: 419A0008  beq cr6, 0x82a12a50
	if ctx.cr[6].eq {
	pc = 0x82A12A50; continue 'dispatch;
	}
	// 82A12A4C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A12A50 => {
    //   block [0x82A12A50..0x82A12A70)
	// 82A12A50: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A12A54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12A58: 4BA6DD71  bl 0x824807c8
	ctx.lr = 0x82A12A5C;
	sub_824807C8(ctx, base);
	// 82A12A5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A12A60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12A64: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A12A68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A12A6C: 4E800421  bctrl
	ctx.lr = 0x82A12A70;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A12A70 => {
    //   block [0x82A12A70..0x82A12AB0)
	// 82A12A70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A12A74: 387C00F0  addi r3, r28, 0xf0
	ctx.r[3].s64 = ctx.r[28].s64 + 240;
	// 82A12A78: 488113A1  bl 0x83223e18
	ctx.lr = 0x82A12A7C;
	sub_83223E18(ctx, base);
	// 82A12A7C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82A12A80: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A12A84: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A12A88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A12A8C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A12A90: 48833B21  bl 0x832465b0
	ctx.lr = 0x82A12A94;
	sub_832465B0(ctx, base);
	// 82A12A94: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A12A98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12A9C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A12AA0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A12AA4: 4E800421  bctrl
	ctx.lr = 0x82A12AA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A12AA8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A12AAC: 482969A4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A12AB0 => {
    //   block [0x82A12AB0..0x82A12AD0)
	// 82A12AB0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A12AB4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82A12AB8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A12ABC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A12AC0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A12AC4: 48833AED  bl 0x832465b0
	ctx.lr = 0x82A12AC8;
	sub_832465B0(ctx, base);
	// 82A12AC8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A12ACC: 48296984  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A12AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A12AD0 size=252
    let mut pc: u32 = 0x82A12AD0;
    'dispatch: loop {
        match pc {
            0x82A12AD0 => {
    //   block [0x82A12AD0..0x82A12B04)
	// 82A12AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A12AD4: 48296935  bl 0x82ca9408
	ctx.lr = 0x82A12AD8;
	sub_82CA93D0(ctx, base);
	// 82A12AD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A12ADC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A12AE0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A12AE4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A12AE8: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 82A12AEC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A12AF0: 816AE748  lwz r11, -0x18b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6328 as u32) ) } as u64;
	// 82A12AF4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A12AF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A12AFC: 419A0008  beq cr6, 0x82a12b04
	if ctx.cr[6].eq {
	pc = 0x82A12B04; continue 'dispatch;
	}
	// 82A12B00: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A12B04; continue 'dispatch;
            }
            0x82A12B04 => {
    //   block [0x82A12B04..0x82A12B3C)
	// 82A12B04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A12B08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12B0C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A12B10: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A12B14: 4E800421  bctrl
	ctx.lr = 0x82A12B18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A12B18: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A12B1C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A12B20: 419A00A4  beq cr6, 0x82a12bc4
	if ctx.cr[6].eq {
	pc = 0x82A12BC4; continue 'dispatch;
	}
	// 82A12B24: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 82A12B28: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A12B2C: 817EE74C  lwz r11, -0x18b4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-6324 as u32) ) } as u64;
	// 82A12B30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A12B34: 419A0008  beq cr6, 0x82a12b3c
	if ctx.cr[6].eq {
	pc = 0x82A12B3C; continue 'dispatch;
	}
	// 82A12B38: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A12B3C => {
    //   block [0x82A12B3C..0x82A12B78)
	// 82A12B3C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A12B40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12B44: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A12B48: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A12B4C: 4E800421  bctrl
	ctx.lr = 0x82A12B50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A12B50: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A12B54: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A12B58: 419A0040  beq cr6, 0x82a12b98
	if ctx.cr[6].eq {
	pc = 0x82A12B98; continue 'dispatch;
	}
	// 82A12B5C: 817EE74C  lwz r11, -0x18b4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-6324 as u32) ) } as u64;
	// 82A12B60: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 82A12B64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A12B68: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A12B6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A12B70: 419A0008  beq cr6, 0x82a12b78
	if ctx.cr[6].eq {
	pc = 0x82A12B78; continue 'dispatch;
	}
	// 82A12B74: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A12B78 => {
    //   block [0x82A12B78..0x82A12B98)
	// 82A12B78: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A12B7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12B80: 4BA6DC49  bl 0x824807c8
	ctx.lr = 0x82A12B84;
	sub_824807C8(ctx, base);
	// 82A12B84: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A12B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12B8C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A12B90: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A12B94: 4E800421  bctrl
	ctx.lr = 0x82A12B98;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A12B98 => {
    //   block [0x82A12B98..0x82A12BC4)
	// 82A12B98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A12B9C: 387C00F0  addi r3, r28, 0xf0
	ctx.r[3].s64 = ctx.r[28].s64 + 240;
	// 82A12BA0: 48811301  bl 0x83223ea0
	ctx.lr = 0x82A12BA4;
	sub_83223EA0(ctx, base);
	// 82A12BA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A12BA8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A12BAC: 4883313D  bl 0x83245ce8
	ctx.lr = 0x82A12BB0;
	sub_83245CE8(ctx, base);
	// 82A12BB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A12BB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12BB8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A12BBC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A12BC0: 4E800421  bctrl
	ctx.lr = 0x82A12BC4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A12BC4 => {
    //   block [0x82A12BC4..0x82A12BCC)
	// 82A12BC4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A12BC8: 48296890  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A12BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A12BD0 size=356
    let mut pc: u32 = 0x82A12BD0;
    'dispatch: loop {
        match pc {
            0x82A12BD0 => {
    //   block [0x82A12BD0..0x82A12C24)
	// 82A12BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A12BD4: 48296835  bl 0x82ca9408
	ctx.lr = 0x82A12BD8;
	sub_82CA93D0(ctx, base);
	// 82A12BD8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A12BDC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A12BE0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A12BE4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A12BE8: 386BE688  addi r3, r11, -0x1978
	ctx.r[3].s64 = ctx.r[11].s64 + -6520;
	// 82A12BEC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A12BF0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A12BF4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A12BF8: 4882E139  bl 0x83240d30
	ctx.lr = 0x82A12BFC;
	sub_83240D30(ctx, base);
	// 82A12BFC: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A12C00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A12C04: 419A0020  beq cr6, 0x82a12c24
	if ctx.cr[6].eq {
	pc = 0x82A12C24; continue 'dispatch;
	}
	// 82A12C08: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A12C0C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A12C10: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A12C14: 4B7A4F05  bl 0x821b7b18
	ctx.lr = 0x82A12C18;
	sub_821B7B18(ctx, base);
	// 82A12C18: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A12C1C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A12C20: 48296838  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A12C24 => {
    //   block [0x82A12C24..0x82A12C68)
	// 82A12C24: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82A12C28: 4B80C631  bl 0x8221f258
	ctx.lr = 0x82A12C2C;
	sub_8221F258(ctx, base);
	// 82A12C2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A12C30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A12C34: 419A0034  beq cr6, 0x82a12c68
	if ctx.cr[6].eq {
	pc = 0x82A12C68; continue 'dispatch;
	}
	// 82A12C38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A12C3C: 48830ED5  bl 0x83243b10
	ctx.lr = 0x82A12C40;
	sub_83243B10(ctx, base);
	// 82A12C40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A12C44: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82A12C48: 9BDF00E0  stb r30, 0xe0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[30].u8 ) };
	// 82A12C4C: 9BDF00E1  stb r30, 0xe1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(225 as u32), ctx.r[30].u8 ) };
	// 82A12C50: 392A24B8  addi r9, r10, 0x24b8
	ctx.r[9].s64 = ctx.r[10].s64 + 9400;
	// 82A12C54: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A12C58: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A12C5C: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82A12C60: 9BDF00F0  stb r30, 0xf0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[30].u8 ) };
	// 82A12C64: 48000008  b 0x82a12c6c
	pc = 0x82A12C6C; continue 'dispatch;
            }
            0x82A12C68 => {
    //   block [0x82A12C68..0x82A12C6C)
	// 82A12C68: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	pc = 0x82A12C6C; continue 'dispatch;
            }
            0x82A12C6C => {
    //   block [0x82A12C6C..0x82A12CAC)
	// 82A12C6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A12C70: 4B7A4EA9  bl 0x821b7b18
	ctx.lr = 0x82A12C74;
	sub_821B7B18(ctx, base);
	// 82A12C74: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A12C78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A12C7C: 419A0038  beq cr6, 0x82a12cb4
	if ctx.cr[6].eq {
	pc = 0x82A12CB4; continue 'dispatch;
	}
	// 82A12C80: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A12C84: 4B80C5D5  bl 0x8221f258
	ctx.lr = 0x82A12C88;
	sub_8221F258(ctx, base);
	// 82A12C88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A12C8C: 419A0020  beq cr6, 0x82a12cac
	if ctx.cr[6].eq {
	pc = 0x82A12CAC; continue 'dispatch;
	}
	// 82A12C90: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82A12C94: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82A12C98: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A12C9C: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82A12CA0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A12CA4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A12CA8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x82A12CAC; continue 'dispatch;
            }
            0x82A12CAC => {
    //   block [0x82A12CAC..0x82A12CB4)
	// 82A12CAC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A12CB0: 48000008  b 0x82a12cb8
	pc = 0x82A12CB8; continue 'dispatch;
            }
            0x82A12CB4 => {
    //   block [0x82A12CB4..0x82A12CB8)
	// 82A12CB4: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82A12CB8; continue 'dispatch;
            }
            0x82A12CB8 => {
    //   block [0x82A12CB8..0x82A12CC8)
	// 82A12CB8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82A12CBC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A12CC0: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82A12CC4: 419A0020  beq cr6, 0x82a12ce4
	if ctx.cr[6].eq {
	pc = 0x82A12CE4; continue 'dispatch;
	}
	pc = 0x82A12CC8; continue 'dispatch;
            }
            0x82A12CC8 => {
    //   block [0x82A12CC8..0x82A12CE4)
	// 82A12CC8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A12CCC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A12CD0: 7D60F028  lwarx r11, 0, r30
	// lwarx
	let ea = ctx.r[30].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A12CD4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A12CD8: 7D60F12D  stwcx. r11, 0, r30
	// stwcx.
	let addr = ctx.r[30].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A12CDC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A12CE0: 4082FFE8  bne 0x82a12cc8
	if !ctx.cr[0].eq {
	pc = 0x82A12CC8; continue 'dispatch;
	}
	pc = 0x82A12CE4; continue 'dispatch;
            }
            0x82A12CE4 => {
    //   block [0x82A12CE4..0x82A12D04)
	// 82A12CE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A12CE8: 488190C9  bl 0x8322bdb0
	ctx.lr = 0x82A12CEC;
	sub_8322BDB0(ctx, base);
	// 82A12CEC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A12CF0: 4B7A4E29  bl 0x821b7b18
	ctx.lr = 0x82A12CF4;
	sub_821B7B18(ctx, base);
	// 82A12CF4: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A12CF8: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A12CFC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A12D00: 419A0020  beq cr6, 0x82a12d20
	if ctx.cr[6].eq {
	pc = 0x82A12D20; continue 'dispatch;
	}
	pc = 0x82A12D04; continue 'dispatch;
            }
            0x82A12D04 => {
    //   block [0x82A12D04..0x82A12D20)
	// 82A12D04: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A12D08: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A12D0C: 7D60F028  lwarx r11, 0, r30
	// lwarx
	let ea = ctx.r[30].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A12D10: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A12D14: 7D60F12D  stwcx. r11, 0, r30
	// stwcx.
	let addr = ctx.r[30].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A12D18: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A12D1C: 4082FFE8  bne 0x82a12d04
	if !ctx.cr[0].eq {
	pc = 0x82A12D04; continue 'dispatch;
	}
	pc = 0x82A12D20; continue 'dispatch;
            }
            0x82A12D20 => {
    //   block [0x82A12D20..0x82A12D34)
	// 82A12D20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A12D24: 4B7A4DF5  bl 0x821b7b18
	ctx.lr = 0x82A12D28;
	sub_821B7B18(ctx, base);
	// 82A12D28: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A12D2C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A12D30: 48296728  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A12D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A12D38 size=96
    let mut pc: u32 = 0x82A12D38;
    'dispatch: loop {
        match pc {
            0x82A12D38 => {
    //   block [0x82A12D38..0x82A12D8C)
	// 82A12D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A12D3C: 482966D1  bl 0x82ca940c
	ctx.lr = 0x82A12D40;
	sub_82CA93D0(ctx, base);
	// 82A12D40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A12D44: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82A12D48: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A12D4C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A12D50: 4B80C509  bl 0x8221f258
	ctx.lr = 0x82A12D54;
	sub_8221F258(ctx, base);
	// 82A12D54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A12D58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A12D5C: 419A0030  beq cr6, 0x82a12d8c
	if ctx.cr[6].eq {
	pc = 0x82A12D8C; continue 'dispatch;
	}
	// 82A12D60: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A12D64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A12D68: 48833511  bl 0x83246278
	ctx.lr = 0x82A12D6C;
	sub_83246278(ctx, base);
	// 82A12D6C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A12D70: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A12D74: 392B24B8  addi r9, r11, 0x24b8
	ctx.r[9].s64 = ctx.r[11].s64 + 9400;
	// 82A12D78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12D7C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A12D80: 995F00F0  stb r10, 0xf0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[10].u8 ) };
	// 82A12D84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A12D88: 482966D4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A12D8C => {
    //   block [0x82A12D8C..0x82A12D98)
	// 82A12D8C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A12D90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A12D94: 482966C8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A12D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A12D98 size=128
    let mut pc: u32 = 0x82A12D98;
    'dispatch: loop {
        match pc {
            0x82A12D98 => {
    //   block [0x82A12D98..0x82A12DFC)
	// 82A12D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A12D9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A12DA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A12DA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A12DA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A12DAC: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82A12DB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A12DB4: 4B80C4A5  bl 0x8221f258
	ctx.lr = 0x82A12DB8;
	sub_8221F258(ctx, base);
	// 82A12DB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A12DBC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A12DC0: 419A003C  beq cr6, 0x82a12dfc
	if ctx.cr[6].eq {
	pc = 0x82A12DFC; continue 'dispatch;
	}
	// 82A12DC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A12DC8: 48830D49  bl 0x83243b10
	ctx.lr = 0x82A12DCC;
	sub_83243B10(ctx, base);
	// 82A12DCC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A12DD0: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 82A12DD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A12DD8: 390924B8  addi r8, r9, 0x24b8
	ctx.r[8].s64 = ctx.r[9].s64 + 9400;
	// 82A12DDC: 997F00E0  stb r11, 0xe0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[11].u8 ) };
	// 82A12DE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12DE4: C00A9490  lfs f0, -0x6b70(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A12DE8: 997F00E1  stb r11, 0xe1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(225 as u32), ctx.r[11].u8 ) };
	// 82A12DEC: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82A12DF0: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A12DF4: 997F00F0  stb r11, 0xf0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u8 ) };
	// 82A12DF8: 48000008  b 0x82a12e00
	pc = 0x82A12E00; continue 'dispatch;
            }
            0x82A12DFC => {
    //   block [0x82A12DFC..0x82A12E00)
	// 82A12DFC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82A12E00; continue 'dispatch;
            }
            0x82A12E00 => {
    //   block [0x82A12E00..0x82A12E18)
	// 82A12E00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A12E04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A12E08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A12E0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A12E10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A12E14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A12E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A12E18 size=456
    let mut pc: u32 = 0x82A12E18;
    'dispatch: loop {
        match pc {
            0x82A12E18 => {
    //   block [0x82A12E18..0x82A12EA0)
	// 82A12E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A12E1C: 482965E5  bl 0x82ca9400
	ctx.lr = 0x82A12E20;
	sub_82CA93D0(ctx, base);
	// 82A12E20: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A12E24: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A12E28: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A12E2C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A12E30: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82A12E34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12E38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A12E3C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A12E40: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A12E44: 4E800421  bctrl
	ctx.lr = 0x82A12E48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A12E48: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A12E4C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A12E50: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A12E54: 4198004C  blt cr6, 0x82a12ea0
	if ctx.cr[6].lt {
	pc = 0x82A12EA0; continue 'dispatch;
	}
	// 82A12E58: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A12E5C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A12E60: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 82A12E64: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A12E68: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A12E6C: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A12E70: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A12E74: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A12E78: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A12E7C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A12E80: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A12E84: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A12E88: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A12E8C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A12E90: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A12E94: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A12E98: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A12E9C: 48000014  b 0x82a12eb0
	pc = 0x82A12EB0; continue 'dispatch;
            }
            0x82A12EA0 => {
    //   block [0x82A12EA0..0x82A12EB0)
	// 82A12EA0: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A12EA4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A12EA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12EAC: 4800E03D  bl 0x82a20ee8
	ctx.lr = 0x82A12EB0;
	sub_82A20EE8(ctx, base);
	pc = 0x82A12EB0; continue 'dispatch;
            }
            0x82A12EB0 => {
    //   block [0x82A12EB0..0x82A12EE4)
	// 82A12EB0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A12EB4: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A12EB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A12EBC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A12EC0: 419A0024  beq cr6, 0x82a12ee4
	if ctx.cr[6].eq {
	pc = 0x82A12EE4; continue 'dispatch;
	}
	// 82A12EC4: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A12EC8: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A12ECC: 89210057  lbz r9, 0x57(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 82A12ED0: 89010054  lbz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A12ED4: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A12ED8: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82A12EDC: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A12EE0: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82A12EE4; continue 'dispatch;
            }
            0x82A12EE4 => {
    //   block [0x82A12EE4..0x82A12F50)
	// 82A12EE4: 3D60BAAD  lis r11, -0x4553
	ctx.r[11].s64 = -1163067392;
	// 82A12EE8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A12EEC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A12EF0: 6169F00D  ori r9, r11, 0xf00d
	ctx.r[9].u64 = ctx.r[11].u64 | 61453;
	// 82A12EF4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A12EF8: 409A00B0  bne cr6, 0x82a12fa8
	if !ctx.cr[6].eq {
	pc = 0x82A12FA8; continue 'dispatch;
	}
	// 82A12EFC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A12F00: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A12F04: 4198004C  blt cr6, 0x82a12f50
	if ctx.cr[6].lt {
	pc = 0x82A12F50; continue 'dispatch;
	}
	// 82A12F08: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A12F0C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A12F10: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82A12F14: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A12F18: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A12F1C: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A12F20: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A12F24: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A12F28: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A12F2C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A12F30: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A12F34: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A12F38: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A12F3C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A12F40: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A12F44: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A12F48: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A12F4C: 48000014  b 0x82a12f60
	pc = 0x82A12F60; continue 'dispatch;
            }
            0x82A12F50 => {
    //   block [0x82A12F50..0x82A12F60)
	// 82A12F50: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A12F54: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A12F58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12F5C: 4800DF8D  bl 0x82a20ee8
	ctx.lr = 0x82A12F60;
	sub_82A20EE8(ctx, base);
	pc = 0x82A12F60; continue 'dispatch;
            }
            0x82A12F60 => {
    //   block [0x82A12F60..0x82A12F94)
	// 82A12F60: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A12F64: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A12F68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A12F6C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A12F70: 419A0024  beq cr6, 0x82a12f94
	if ctx.cr[6].eq {
	pc = 0x82A12F94; continue 'dispatch;
	}
	// 82A12F74: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A12F78: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A12F7C: 8921005B  lbz r9, 0x5b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 82A12F80: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A12F84: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A12F88: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82A12F8C: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A12F90: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82A12F94; continue 'dispatch;
            }
            0x82A12F94 => {
    //   block [0x82A12F94..0x82A12FA8)
	// 82A12F94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A12F98: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A12F9C: 387C00F0  addi r3, r28, 0xf0
	ctx.r[3].s64 = ctx.r[28].s64 + 240;
	// 82A12FA0: 48810D31  bl 0x83223cd0
	ctx.lr = 0x82A12FA4;
	sub_83223CD0(ctx, base);
	// 82A12FA4: 4800001C  b 0x82a12fc0
	pc = 0x82A12FC0; continue 'dispatch;
            }
            0x82A12FA8 => {
    //   block [0x82A12FA8..0x82A12FC0)
	// 82A12FA8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A12FAC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A12FB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A12FB4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A12FB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A12FBC: 4E800421  bctrl
	ctx.lr = 0x82A12FC0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A12FC0 => {
    //   block [0x82A12FC0..0x82A12FE0)
	// 82A12FC0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A12FC4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82A12FC8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A12FCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A12FD0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A12FD4: 4883335D  bl 0x83246330
	ctx.lr = 0x82A12FD8;
	sub_83246330(ctx, base);
	// 82A12FD8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A12FDC: 48296474  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A12FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A12FE0 size=140
    let mut pc: u32 = 0x82A12FE0;
    'dispatch: loop {
        match pc {
            0x82A12FE0 => {
    //   block [0x82A12FE0..0x82A1306C)
	// 82A12FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A12FE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A12FE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A12FEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A12FF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A12FF4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A12FF8: 3C80BAAD  lis r4, -0x4553
	ctx.r[4].s64 = -1163067392;
	// 82A12FFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A13000: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A13004: 6084F00D  ori r4, r4, 0xf00d
	ctx.r[4].u64 = ctx.r[4].u64 | 61453;
	// 82A13008: 4800F5F1  bl 0x82a225f8
	ctx.lr = 0x82A1300C;
	sub_82A225F8(ctx, base);
	// 82A1300C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A13010: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82A13014: 4800F5E5  bl 0x82a225f8
	ctx.lr = 0x82A13018;
	sub_82A225F8(ctx, base);
	// 82A13018: 897F00F0  lbz r11, 0xf0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82A1301C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13020: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A13024: 7D690034  cntlzw r9, r11
	ctx.r[9].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A13028: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A1302C: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 82A13030: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A13034: 69070001  xori r7, r8, 1
	ctx.r[7].u64 = ctx.r[8].u64 ^ 1;
	// 82A13038: 80CA0010  lwz r6, 0x10(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1303C: 98E10050  stb r7, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u8 ) };
	// 82A13040: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82A13044: 4E800421  bctrl
	ctx.lr = 0x82A13048;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A13048: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1304C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13050: 48832BE9  bl 0x83245c38
	ctx.lr = 0x82A13054;
	sub_83245C38(ctx, base);
	// 82A13054: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A13058: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1305C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A13060: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A13064: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A13068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A13070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A13070 size=312
    let mut pc: u32 = 0x82A13070;
    'dispatch: loop {
        match pc {
            0x82A13070 => {
    //   block [0x82A13070..0x82A130AC)
	// 82A13070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A13074: 4829638D  bl 0x82ca9400
	ctx.lr = 0x82A13078;
	sub_82CA93D0(ctx, base);
	// 82A13078: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1307C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A13080: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A13084: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A13088: 3BCBFFDF  addi r30, r11, -0x21
	ctx.r[30].s64 = ctx.r[11].s64 + -33;
	// 82A1308C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A13090: 816AE748  lwz r11, -0x18b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6328 as u32) ) } as u64;
	// 82A13094: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A13098: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82A1309C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A130A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A130A4: 419A0008  beq cr6, 0x82a130ac
	if ctx.cr[6].eq {
	pc = 0x82A130AC; continue 'dispatch;
	}
	// 82A130A8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A130AC; continue 'dispatch;
            }
            0x82A130AC => {
    //   block [0x82A130AC..0x82A130EC)
	// 82A130AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A130B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A130B4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A130B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A130BC: 4E800421  bctrl
	ctx.lr = 0x82A130C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A130C0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A130C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A130C8: 419A00C0  beq cr6, 0x82a13188
	if ctx.cr[6].eq {
	pc = 0x82A13188; continue 'dispatch;
	}
	// 82A130CC: 3FA0834A  lis r29, -0x7cb6
	ctx.r[29].s64 = -2092302336;
	// 82A130D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A130D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A130D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A130DC: 817DE74C  lwz r11, -0x18b4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-6324 as u32) ) } as u64;
	// 82A130E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A130E4: 419A0008  beq cr6, 0x82a130ec
	if ctx.cr[6].eq {
	pc = 0x82A130EC; continue 'dispatch;
	}
	// 82A130E8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A130EC => {
    //   block [0x82A130EC..0x82A13120)
	// 82A130EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A130F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A130F4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A130F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A130FC: 4E800421  bctrl
	ctx.lr = 0x82A13100;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A13100: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A13104: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A13108: 419A0038  beq cr6, 0x82a13140
	if ctx.cr[6].eq {
	pc = 0x82A13140; continue 'dispatch;
	}
	// 82A1310C: 817DE74C  lwz r11, -0x18b4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-6324 as u32) ) } as u64;
	// 82A13110: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A13114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A13118: 419A0008  beq cr6, 0x82a13120
	if ctx.cr[6].eq {
	pc = 0x82A13120; continue 'dispatch;
	}
	// 82A1311C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A13120 => {
    //   block [0x82A13120..0x82A13140)
	// 82A13120: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A13124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13128: 4BA6D6A1  bl 0x824807c8
	ctx.lr = 0x82A1312C;
	sub_824807C8(ctx, base);
	// 82A1312C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13134: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A13138: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A1313C: 4E800421  bctrl
	ctx.lr = 0x82A13140;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A13140 => {
    //   block [0x82A13140..0x82A13188)
	// 82A13140: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A13144: 38BC00F0  addi r5, r28, 0xf0
	ctx.r[5].s64 = ctx.r[28].s64 + 240;
	// 82A13148: 386BE804  addi r3, r11, -0x17fc
	ctx.r[3].s64 = ctx.r[11].s64 + -6140;
	// 82A1314C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A13150: 488224B1  bl 0x83235600
	ctx.lr = 0x82A13154;
	sub_83235600(ctx, base);
	// 82A13154: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82A13158: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A1315C: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A13160: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A13164: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A13168: 48833449  bl 0x832465b0
	ctx.lr = 0x82A1316C;
	sub_832465B0(ctx, base);
	// 82A1316C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13174: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A13178: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82A1317C: 4E800421  bctrl
	ctx.lr = 0x82A13180;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A13180: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A13184: 482962CC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A13188 => {
    //   block [0x82A13188..0x82A131A8)
	// 82A13188: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A1318C: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82A13190: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A13194: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A13198: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1319C: 48833415  bl 0x832465b0
	ctx.lr = 0x82A131A0;
	sub_832465B0(ctx, base);
	// 82A131A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A131A4: 482962AC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A131A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A131A8 size=260
    let mut pc: u32 = 0x82A131A8;
    'dispatch: loop {
        match pc {
            0x82A131A8 => {
    //   block [0x82A131A8..0x82A131DC)
	// 82A131A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A131AC: 4829625D  bl 0x82ca9408
	ctx.lr = 0x82A131B0;
	sub_82CA93D0(ctx, base);
	// 82A131B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A131B4: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A131B8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A131BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A131C0: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 82A131C4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A131C8: 816AE748  lwz r11, -0x18b8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-6328 as u32) ) } as u64;
	// 82A131CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A131D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A131D4: 419A0008  beq cr6, 0x82a131dc
	if ctx.cr[6].eq {
	pc = 0x82A131DC; continue 'dispatch;
	}
	// 82A131D8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A131DC; continue 'dispatch;
            }
            0x82A131DC => {
    //   block [0x82A131DC..0x82A13214)
	// 82A131DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A131E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A131E4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A131E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A131EC: 4E800421  bctrl
	ctx.lr = 0x82A131F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A131F0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A131F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A131F8: 419A00AC  beq cr6, 0x82a132a4
	if ctx.cr[6].eq {
	pc = 0x82A132A4; continue 'dispatch;
	}
	// 82A131FC: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 82A13200: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A13204: 817EE74C  lwz r11, -0x18b4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-6324 as u32) ) } as u64;
	// 82A13208: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1320C: 419A0008  beq cr6, 0x82a13214
	if ctx.cr[6].eq {
	pc = 0x82A13214; continue 'dispatch;
	}
	// 82A13210: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A13214 => {
    //   block [0x82A13214..0x82A13250)
	// 82A13214: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13218: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1321C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A13220: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A13224: 4E800421  bctrl
	ctx.lr = 0x82A13228;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A13228: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1322C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A13230: 419A0040  beq cr6, 0x82a13270
	if ctx.cr[6].eq {
	pc = 0x82A13270; continue 'dispatch;
	}
	// 82A13234: 817EE74C  lwz r11, -0x18b4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-6324 as u32) ) } as u64;
	// 82A13238: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 82A1323C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A13240: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A13244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A13248: 419A0008  beq cr6, 0x82a13250
	if ctx.cr[6].eq {
	pc = 0x82A13250; continue 'dispatch;
	}
	// 82A1324C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A13250 => {
    //   block [0x82A13250..0x82A13270)
	// 82A13250: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A13254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13258: 4BA6D571  bl 0x824807c8
	ctx.lr = 0x82A1325C;
	sub_824807C8(ctx, base);
	// 82A1325C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13264: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A13268: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A1326C: 4E800421  bctrl
	ctx.lr = 0x82A13270;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A13270 => {
    //   block [0x82A13270..0x82A132A4)
	// 82A13270: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A13274: 38BC00F0  addi r5, r28, 0xf0
	ctx.r[5].s64 = ctx.r[28].s64 + 240;
	// 82A13278: 386BE804  addi r3, r11, -0x17fc
	ctx.r[3].s64 = ctx.r[11].s64 + -6140;
	// 82A1327C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A13280: 48822381  bl 0x83235600
	ctx.lr = 0x82A13284;
	sub_83235600(ctx, base);
	// 82A13284: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A13288: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1328C: 48832A5D  bl 0x83245ce8
	ctx.lr = 0x82A13290;
	sub_83245CE8(ctx, base);
	// 82A13290: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13298: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1329C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82A132A0: 4E800421  bctrl
	ctx.lr = 0x82A132A4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A132A4 => {
    //   block [0x82A132A4..0x82A132AC)
	// 82A132A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A132A8: 482961B0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A132B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A132B0 size=944
    let mut pc: u32 = 0x82A132B0;
    'dispatch: loop {
        match pc {
            0x82A132B0 => {
    //   block [0x82A132B0..0x82A13330)
	// 82A132B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A132B4: 4829614D  bl 0x82ca9400
	ctx.lr = 0x82A132B8;
	sub_82CA93D0(ctx, base);
	// 82A132B8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A132BC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A132C0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A132C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A132C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A132CC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A132D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A132D4: 4E800421  bctrl
	ctx.lr = 0x82A132D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A132D8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A132DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A132E0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A132E4: 4198004C  blt cr6, 0x82a13330
	if ctx.cr[6].lt {
	pc = 0x82A13330; continue 'dispatch;
	}
	// 82A132E8: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A132EC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A132F0: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82A132F4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A132F8: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A132FC: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A13300: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13304: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A13308: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A1330C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A13310: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A13314: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A13318: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A1331C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A13320: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A13324: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A13328: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A1332C: 48000014  b 0x82a13340
	pc = 0x82A13340; continue 'dispatch;
            }
            0x82A13330 => {
    //   block [0x82A13330..0x82A13340)
	// 82A13330: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A13334: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A13338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1333C: 4800DBAD  bl 0x82a20ee8
	ctx.lr = 0x82A13340;
	sub_82A20EE8(ctx, base);
	pc = 0x82A13340; continue 'dispatch;
            }
            0x82A13340 => {
    //   block [0x82A13340..0x82A13374)
	// 82A13340: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A13344: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A13348: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1334C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A13350: 419A0024  beq cr6, 0x82a13374
	if ctx.cr[6].eq {
	pc = 0x82A13374; continue 'dispatch;
	}
	// 82A13354: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A13358: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A1335C: 8921005B  lbz r9, 0x5b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 82A13360: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A13364: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A13368: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82A1336C: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A13370: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82A13374; continue 'dispatch;
            }
            0x82A13374 => {
    //   block [0x82A13374..0x82A133DC)
	// 82A13374: 3D604AD7  lis r11, 0x4ad7
	ctx.r[11].s64 = 1255604224;
	// 82A13378: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1337C: 61698C59  ori r9, r11, 0x8c59
	ctx.r[9].u64 = ctx.r[11].u64 | 35929;
	// 82A13380: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A13384: 409A006C  bne cr6, 0x82a133f0
	if !ctx.cr[6].eq {
	pc = 0x82A133F0; continue 'dispatch;
	}
	// 82A13388: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A1338C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A13390: 4198004C  blt cr6, 0x82a133dc
	if ctx.cr[6].lt {
	pc = 0x82A133DC; continue 'dispatch;
	}
	// 82A13394: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A13398: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1339C: 39010064  addi r8, r1, 0x64
	ctx.r[8].s64 = ctx.r[1].s64 + 100;
	// 82A133A0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A133A4: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A133A8: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A133AC: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A133B0: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A133B4: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A133B8: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A133BC: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A133C0: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A133C4: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A133C8: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A133CC: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A133D0: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A133D4: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A133D8: 48000030  b 0x82a13408
	pc = 0x82A13408; continue 'dispatch;
            }
            0x82A133DC => {
    //   block [0x82A133DC..0x82A133F0)
	// 82A133DC: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A133E0: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82A133E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A133E8: 4800DB01  bl 0x82a20ee8
	ctx.lr = 0x82A133EC;
	sub_82A20EE8(ctx, base);
	// 82A133EC: 4800001C  b 0x82a13408
	pc = 0x82A13408; continue 'dispatch;
            }
            0x82A133F0 => {
    //   block [0x82A133F0..0x82A13408)
	// 82A133F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A133F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A133F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A133FC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A13400: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A13404: 4E800421  bctrl
	ctx.lr = 0x82A13408;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A13408 => {
    //   block [0x82A13408..0x82A13464)
	// 82A13408: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A1340C: 4BE34BA5  bl 0x82847fb0
	ctx.lr = 0x82A13410;
	sub_82847FB0(ctx, base);
	// 82A13410: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A13414: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A13418: 4198004C  blt cr6, 0x82a13464
	if ctx.cr[6].lt {
	pc = 0x82A13464; continue 'dispatch;
	}
	// 82A1341C: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A13420: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A13424: 3901005C  addi r8, r1, 0x5c
	ctx.r[8].s64 = ctx.r[1].s64 + 92;
	// 82A13428: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1342C: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A13430: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A13434: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13438: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A1343C: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A13440: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A13444: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A13448: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A1344C: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A13450: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A13454: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A13458: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A1345C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A13460: 48000014  b 0x82a13474
	pc = 0x82A13474; continue 'dispatch;
            }
            0x82A13464 => {
    //   block [0x82A13464..0x82A13474)
	// 82A13464: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A13468: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82A1346C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13470: 4800DA79  bl 0x82a20ee8
	ctx.lr = 0x82A13474;
	sub_82A20EE8(ctx, base);
	pc = 0x82A13474; continue 'dispatch;
            }
            0x82A13474 => {
    //   block [0x82A13474..0x82A134AC)
	// 82A13474: 8361005C  lwz r27, 0x5c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A13478: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A1347C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A13480: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82A13484: 419A0028  beq cr6, 0x82a134ac
	if ctx.cr[6].eq {
	pc = 0x82A134AC; continue 'dispatch;
	}
	// 82A13488: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A1348C: 8901005F  lbz r8, 0x5f(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(95 as u32) ) } as u64;
	// 82A13490: 89210052  lbz r9, 0x52(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A13494: 8941005C  lbz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A13498: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A1349C: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 82A134A0: 99210051  stb r9, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[9].u8 ) };
	// 82A134A4: 99410053  stb r10, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[10].u8 ) };
	// 82A134A8: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82A134AC; continue 'dispatch;
            }
            0x82A134AC => {
    //   block [0x82A134AC..0x82A134CC)
	// 82A134AC: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82A134B0: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 82A134B4: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82A134B8: 3BABF1BC  addi r29, r11, -0xe44
	ctx.r[29].s64 = ctx.r[11].s64 + -3652;
	// 82A134BC: 40990104  ble cr6, 0x82a135c0
	if !ctx.cr[6].gt {
	pc = 0x82A135C0; continue 'dispatch;
	}
	// 82A134C0: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82A134C4: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82A134C8: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	pc = 0x82A134CC; continue 'dispatch;
            }
            0x82A134CC => {
    //   block [0x82A134CC..0x82A13520)
	// 82A134CC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A134D0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A134D4: 4198004C  blt cr6, 0x82a13520
	if ctx.cr[6].lt {
	pc = 0x82A13520; continue 'dispatch;
	}
	// 82A134D8: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A134DC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A134E0: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82A134E4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A134E8: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A134EC: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A134F0: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A134F4: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A134F8: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A134FC: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A13500: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A13504: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A13508: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A1350C: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A13510: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A13514: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A13518: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A1351C: 48000014  b 0x82a13530
	pc = 0x82A13530; continue 'dispatch;
            }
            0x82A13520 => {
    //   block [0x82A13520..0x82A13530)
	// 82A13520: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A13524: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A13528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1352C: 4800D9BD  bl 0x82a20ee8
	ctx.lr = 0x82A13530;
	sub_82A20EE8(ctx, base);
	pc = 0x82A13530; continue 'dispatch;
            }
            0x82A13530 => {
    //   block [0x82A13530..0x82A13564)
	// 82A13530: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A13534: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A13538: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A1353C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A13540: 419A0024  beq cr6, 0x82a13564
	if ctx.cr[6].eq {
	pc = 0x82A13564; continue 'dispatch;
	}
	// 82A13544: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A13548: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A1354C: 89210053  lbz r9, 0x53(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(83 as u32) ) } as u64;
	// 82A13550: 89010052  lbz r8, 0x52(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A13554: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 82A13558: 99410052  stb r10, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 82A1355C: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A13560: 99010051  stb r8, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[8].u8 ) };
	pc = 0x82A13564; continue 'dispatch;
            }
            0x82A13564 => {
    //   block [0x82A13564..0x82A135C0)
	// 82A13564: 817C6DD4  lwz r11, 0x6dd4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28116 as u32) ) } as u64;
	// 82A13568: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1356C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A13570: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A13574: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13578: 7DABEC2E  lfsx f13, r11, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A1357C: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A13580: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82A13584: D9610050  stfd f11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[11].u64 ) };
	// 82A13588: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A1358C: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82A13590: 48822299  bl 0x83235828
	ctx.lr = 0x82A13594;
	sub_83235828(ctx, base);
	// 82A13594: 81210084  lwz r9, 0x84(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A13598: C1410068  lfs f10, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82A1359C: D1410074  stfs f10, 0x74(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A135A0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82A135A4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A135A8: 9121007C  stw r9, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	// 82A135AC: E8810078  ld r4, 0x78(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82A135B0: 48003A29  bl 0x82a16fd8
	ctx.lr = 0x82A135B4;
	sub_82A16FD8(ctx, base);
	// 82A135B4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A135B8: 4082FF14  bne 0x82a134cc
	if !ctx.cr[0].eq {
	pc = 0x82A134CC; continue 'dispatch;
	}
	// 82A135BC: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	pc = 0x82A135C0; continue 'dispatch;
            }
            0x82A135C0 => {
    //   block [0x82A135C0..0x82A135D4)
	// 82A135C0: 409A0014  bne cr6, 0x82a135d4
	if !ctx.cr[6].eq {
	pc = 0x82A135D4; continue 'dispatch;
	}
	// 82A135C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A135C8: C00BD5C8  lfs f0, -0x2a38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A135CC: D01A0008  stfs f0, 8(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A135D0: 48000064  b 0x82a13634
	pc = 0x82A13634; continue 'dispatch;
            }
            0x82A135D4 => {
    //   block [0x82A135D4..0x82A135E8)
	// 82A135D4: 81210084  lwz r9, 0x84(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A135D8: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A135DC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A135E0: 409A0008  bne cr6, 0x82a135e8
	if !ctx.cr[6].eq {
	pc = 0x82A135E8; continue 'dispatch;
	}
	// 82A135E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A135E8; continue 'dispatch;
            }
            0x82A135E8 => {
    //   block [0x82A135E8..0x82A1362C)
	// 82A135E8: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A135EC: 38FD0008  addi r7, r29, 8
	ctx.r[7].s64 = ctx.r[29].s64 + 8;
	// 82A135F0: 815C6DD4  lwz r10, 0x6dd4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28116 as u32) ) } as u64;
	// 82A135F4: 2F1B0001  cmpwi cr6, r27, 1
	ctx.cr[6].compare_i32(ctx.r[27].s32, 1, &mut ctx.xer);
	// 82A135F8: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82A135FC: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A13600: F8C10078  std r6, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[6].u64 ) };
	// 82A13604: C8010078  lfd f0, 0x78(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82A13608: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82A1360C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A13610: 7D653C2E  lfsx f11, r5, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A13614: ED4B0332  fmuls f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A13618: D15A0008  stfs f10, 8(r26)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A1361C: 409A0018  bne cr6, 0x82a13634
	if !ctx.cr[6].eq {
	pc = 0x82A13634; continue 'dispatch;
	}
	// 82A13620: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A13624: 409A0008  bne cr6, 0x82a1362c
	if !ctx.cr[6].eq {
	pc = 0x82A1362C; continue 'dispatch;
	}
	// 82A13628: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A1362C; continue 'dispatch;
            }
            0x82A1362C => {
    //   block [0x82A1362C..0x82A13634)
	// 82A1362C: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A13630: D01A000C  stfs f0, 0xc(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x82A13634; continue 'dispatch;
            }
            0x82A13634 => {
    //   block [0x82A13634..0x82A13660)
	// 82A13634: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A13638: 48000D01  bl 0x82a14338
	ctx.lr = 0x82A1363C;
	sub_82A14338(ctx, base);
	// 82A1363C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A13640: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A13644: 48001845  bl 0x82a14e88
	ctx.lr = 0x82A13648;
	sub_82A14E88(ctx, base);
	// 82A13648: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A1364C: 48001745  bl 0x82a14d90
	ctx.lr = 0x82A13650;
	sub_82A14D90(ctx, base);
	// 82A13650: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A13654: 4B8086E5  bl 0x8221bd38
	ctx.lr = 0x82A13658;
	sub_8221BD38(ctx, base);
	// 82A13658: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A1365C: 48295DF4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A13660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A13660 size=944
    let mut pc: u32 = 0x82A13660;
    'dispatch: loop {
        match pc {
            0x82A13660 => {
    //   block [0x82A13660..0x82A136D0)
	// 82A13660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A13664: 48295D8D  bl 0x82ca93f0
	ctx.lr = 0x82A13668;
	sub_82CA93D0(ctx, base);
	// 82A13668: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1366C: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 82A13670: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A13674: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A13678: 4BE34939  bl 0x82847fb0
	ctx.lr = 0x82A1367C;
	sub_82847FB0(ctx, base);
	// 82A1367C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A13680: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A13684: 3B0BD5C8  addi r24, r11, -0x2a38
	ctx.r[24].s64 = ctx.r[11].s64 + -10808;
	// 82A13688: 3898D630  addi r4, r24, -0x29d0
	ctx.r[4].s64 = ctx.r[24].s64 + -10704;
	// 82A1368C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13690: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A13694: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A13698: 4E800421  bctrl
	ctx.lr = 0x82A1369C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1369C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A136A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A136A4: 419A0340  beq cr6, 0x82a139e4
	if ctx.cr[6].eq {
	pc = 0x82A139E4; continue 'dispatch;
	}
	// 82A136A8: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 82A136AC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A136B0: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82A136B4: 3B2BFFDF  addi r25, r11, -0x21
	ctx.r[25].s64 = ctx.r[11].s64 + -33;
	// 82A136B8: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 82A136BC: 817FE73C  lwz r11, -0x18c4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-6340 as u32) ) } as u64;
	// 82A136C0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A136C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A136C8: 419A0008  beq cr6, 0x82a136d0
	if ctx.cr[6].eq {
	pc = 0x82A136D0; continue 'dispatch;
	}
	// 82A136CC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A136D0 => {
    //   block [0x82A136D0..0x82A13704)
	// 82A136D0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A136D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A136D8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A136DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A136E0: 4E800421  bctrl
	ctx.lr = 0x82A136E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A136E4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A136E8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A136EC: 419A0038  beq cr6, 0x82a13724
	if ctx.cr[6].eq {
	pc = 0x82A13724; continue 'dispatch;
	}
	// 82A136F0: 817FE73C  lwz r11, -0x18c4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-6340 as u32) ) } as u64;
	// 82A136F4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A136F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A136FC: 419A0008  beq cr6, 0x82a13704
	if ctx.cr[6].eq {
	pc = 0x82A13704; continue 'dispatch;
	}
	// 82A13700: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A13704 => {
    //   block [0x82A13704..0x82A13724)
	// 82A13704: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A13708: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1370C: 4BA6D0BD  bl 0x824807c8
	ctx.lr = 0x82A13710;
	sub_824807C8(ctx, base);
	// 82A13710: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13714: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A13718: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1371C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A13720: 4E800421  bctrl
	ctx.lr = 0x82A13724;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A13724 => {
    //   block [0x82A13724..0x82A13748)
	// 82A13724: 3898D64C  addi r4, r24, -0x29b4
	ctx.r[4].s64 = ctx.r[24].s64 + -10676;
	// 82A13728: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A1372C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A13730: 4B8197A1  bl 0x8222ced0
	ctx.lr = 0x82A13734;
	sub_8222CED0(ctx, base);
	// 82A13734: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A13738: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A1373C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A13740: 419A0008  beq cr6, 0x82a13748
	if ctx.cr[6].eq {
	pc = 0x82A13748; continue 'dispatch;
	}
	// 82A13744: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A13748; continue 'dispatch;
            }
            0x82A13748 => {
    //   block [0x82A13748..0x82A13788)
	// 82A13748: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A1374C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A13750: 4BA6D079  bl 0x824807c8
	ctx.lr = 0x82A13754;
	sub_824807C8(ctx, base);
	// 82A13754: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A13758: 4B801681  bl 0x82214dd8
	ctx.lr = 0x82A1375C;
	sub_82214DD8(ctx, base);
	// 82A1375C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82A13760: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 82A13764: 3BEBF1BC  addi r31, r11, -0xe44
	ctx.r[31].s64 = ctx.r[11].s64 + -3652;
	// 82A13768: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 82A1376C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A13770: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A13774: 40990134  ble cr6, 0x82a138a8
	if !ctx.cr[6].gt {
	pc = 0x82A138A8; continue 'dispatch;
	}
	// 82A13778: 39610088  addi r11, r1, 0x88
	ctx.r[11].s64 = ctx.r[1].s64 + 136;
	// 82A1377C: 3F40834A  lis r26, -0x7cb6
	ctx.r[26].s64 = -2092302336;
	// 82A13780: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A13784: 3F60834A  lis r27, -0x7cb6
	ctx.r[27].s64 = -2092302336;
	pc = 0x82A13788; continue 'dispatch;
            }
            0x82A13788 => {
    //   block [0x82A13788..0x82A137D0)
	// 82A13788: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1378C: 3898D658  addi r4, r24, -0x29a8
	ctx.r[4].s64 = ctx.r[24].s64 + -10664;
	// 82A13790: 92E10070  stw r23, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[23].u32 ) };
	// 82A13794: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A13798: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1379C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A137A0: 4E800421  bctrl
	ctx.lr = 0x82A137A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A137A4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A137A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A137AC: 419A00D0  beq cr6, 0x82a1387c
	if ctx.cr[6].eq {
	pc = 0x82A1387C; continue 'dispatch;
	}
	// 82A137B0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A137B4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A137B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A137BC: 409A002C  bne cr6, 0x82a137e8
	if !ctx.cr[6].eq {
	pc = 0x82A137E8; continue 'dispatch;
	}
	// 82A137C0: 817BE740  lwz r11, -0x18c0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-6336 as u32) ) } as u64;
	// 82A137C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A137C8: 419A0008  beq cr6, 0x82a137d0
	if ctx.cr[6].eq {
	pc = 0x82A137D0; continue 'dispatch;
	}
	// 82A137CC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A137D0 => {
    //   block [0x82A137D0..0x82A137E8)
	// 82A137D0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A137D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A137D8: 4BA6CFF1  bl 0x824807c8
	ctx.lr = 0x82A137DC;
	sub_824807C8(ctx, base);
	// 82A137DC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A137E0: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A137E4: 48000044  b 0x82a13828
	pc = 0x82A13828; continue 'dispatch;
            }
            0x82A137E8 => {
    //   block [0x82A137E8..0x82A137F8)
	// 82A137E8: 817AE744  lwz r11, -0x18bc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6332 as u32) ) } as u64;
	// 82A137EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A137F0: 419A0008  beq cr6, 0x82a137f8
	if ctx.cr[6].eq {
	pc = 0x82A137F8; continue 'dispatch;
	}
	// 82A137F4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A137F8; continue 'dispatch;
            }
            0x82A137F8 => {
    //   block [0x82A137F8..0x82A13828)
	// 82A137F8: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 82A137FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A13800: 4BA6D051  bl 0x82480850
	ctx.lr = 0x82A13804;
	sub_82480850(ctx, base);
	// 82A13804: 817D6DD4  lwz r11, 0x6dd4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28116 as u32) ) } as u64;
	// 82A13808: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1380C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A13810: 7DABFC2E  lfsx f13, r11, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A13814: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A13818: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82A1381C: D9610080  stfd f11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.f[11].u64 ) };
	// 82A13820: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A13824: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	pc = 0x82A13828; continue 'dispatch;
            }
            0x82A13828 => {
    //   block [0x82A13828..0x82A1384C)
	// 82A13828: 3898D66C  addi r4, r24, -0x2994
	ctx.r[4].s64 = ctx.r[24].s64 + -10644;
	// 82A1382C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A13830: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A13834: 4B81969D  bl 0x8222ced0
	ctx.lr = 0x82A13838;
	sub_8222CED0(ctx, base);
	// 82A13838: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A1383C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A13840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A13844: 419A0008  beq cr6, 0x82a1384c
	if ctx.cr[6].eq {
	pc = 0x82A1384C; continue 'dispatch;
	}
	// 82A13848: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1384C; continue 'dispatch;
            }
            0x82A1384C => {
    //   block [0x82A1384C..0x82A1387C)
	// 82A1384C: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82A13850: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A13854: 4BA6CFFD  bl 0x82480850
	ctx.lr = 0x82A13858;
	sub_82480850(ctx, base);
	// 82A13858: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1385C: 4B80157D  bl 0x82214dd8
	ctx.lr = 0x82A13860;
	sub_82214DD8(ctx, base);
	// 82A13860: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13864: C0010068  lfs f0, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A13868: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1386C: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A13870: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A13874: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A13878: 4E800421  bctrl
	ctx.lr = 0x82A1387C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A1387C => {
    //   block [0x82A1387C..0x82A138A8)
	// 82A1387C: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A13880: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82A13884: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A13888: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A1388C: E8810078  ld r4, 0x78(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82A13890: 48003749  bl 0x82a16fd8
	ctx.lr = 0x82A13894;
	sub_82A16FD8(ctx, base);
	// 82A13894: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A13898: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82A1389C: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A138A0: 4198FEE8  blt cr6, 0x82a13788
	if ctx.cr[6].lt {
	pc = 0x82A13788; continue 'dispatch;
	}
	// 82A138A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	pc = 0x82A138A8; continue 'dispatch;
            }
            0x82A138A8 => {
    //   block [0x82A138A8..0x82A138B8)
	// 82A138A8: 409A0010  bne cr6, 0x82a138b8
	if !ctx.cr[6].eq {
	pc = 0x82A138B8; continue 'dispatch;
	}
	// 82A138AC: C0180000  lfs f0, 0(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A138B0: D0160008  stfs f0, 8(r22)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A138B4: 48000048  b 0x82a138fc
	pc = 0x82A138FC; continue 'dispatch;
            }
            0x82A138B8 => {
    //   block [0x82A138B8..0x82A138CC)
	// 82A138B8: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A138BC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A138C0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A138C4: 409A0008  bne cr6, 0x82a138cc
	if !ctx.cr[6].eq {
	pc = 0x82A138CC; continue 'dispatch;
	}
	// 82A138C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A138CC; continue 'dispatch;
            }
            0x82A138CC => {
    //   block [0x82A138CC..0x82A138FC)
	// 82A138CC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A138D0: 393F0008  addi r9, r31, 8
	ctx.r[9].s64 = ctx.r[31].s64 + 8;
	// 82A138D4: 817D6DD4  lwz r11, 0x6dd4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28116 as u32) ) } as u64;
	// 82A138D8: 7D4807B4  extsw r8, r10
	ctx.r[8].s64 = ctx.r[10].s32 as i64;
	// 82A138DC: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A138E0: F9010080  std r8, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[8].u64 ) };
	// 82A138E4: C8010080  lfd f0, 0x80(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82A138E8: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82A138EC: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A138F0: 7D674C2E  lfsx f11, r7, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A138F4: ED4B0332  fmuls f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A138F8: D1560008  stfs f10, 8(r22)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82A138FC; continue 'dispatch;
            }
            0x82A138FC => {
    //   block [0x82A138FC..0x82A13928)
	// 82A138FC: C016000C  lfs f0, 0xc(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A13900: 3898D674  addi r4, r24, -0x298c
	ctx.r[4].s64 = ctx.r[24].s64 + -10636;
	// 82A13904: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A13908: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A1390C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A13910: 4B8195C1  bl 0x8222ced0
	ctx.lr = 0x82A13914;
	sub_8222CED0(ctx, base);
	// 82A13914: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A13918: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A1391C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A13920: 419A0008  beq cr6, 0x82a13928
	if ctx.cr[6].eq {
	pc = 0x82A13928; continue 'dispatch;
	}
	// 82A13924: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A13928; continue 'dispatch;
            }
            0x82A13928 => {
    //   block [0x82A13928..0x82A13944)
	// 82A13928: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82A1392C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A13930: 4BA6CF21  bl 0x82480850
	ctx.lr = 0x82A13934;
	sub_82480850(ctx, base);
	// 82A13934: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A13938: 4B7B2E31  bl 0x821c6768
	ctx.lr = 0x82A1393C;
	sub_821C6768(ctx, base);
	// 82A1393C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A13940: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	pc = 0x82A13944; continue 'dispatch;
            }
            0x82A13944 => {
    //   block [0x82A13944..0x82A139C0)
	// 82A13944: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A13948: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1394C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A13950: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A13954: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A13958: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1395C: 4082FFE8  bne 0x82a13944
	if !ctx.cr[0].eq {
	pc = 0x82A13944; continue 'dispatch;
	}
	// 82A13960: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13964: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A13968: 80C7000C  lwz r6, 0xc(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1396C: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82A13970: 4E800421  bctrl
	ctx.lr = 0x82A13974;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A13974: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A13978: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1397C: 409A0044  bne cr6, 0x82a139c0
	if !ctx.cr[6].eq {
	pc = 0x82A139C0; continue 'dispatch;
	}
	// 82A13980: C1B6000C  lfs f13, 0xc(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A13984: C001005C  lfs f0, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A13988: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A1398C: 419A0058  beq cr6, 0x82a139e4
	if ctx.cr[6].eq {
	pc = 0x82A139E4; continue 'dispatch;
	}
	// 82A13990: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A13994: D016000C  stfs f0, 0xc(r22)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A13998: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82A1399C: 92E10078  stw r23, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[23].u32 ) };
	// 82A139A0: 39410088  addi r10, r1, 0x88
	ctx.r[10].s64 = ctx.r[1].s64 + 136;
	// 82A139A4: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 82A139A8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A139AC: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82A139B0: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A139B4: E8810070  ld r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A139B8: 48003621  bl 0x82a16fd8
	ctx.lr = 0x82A139BC;
	sub_82A16FD8(ctx, base);
	// 82A139BC: 48000028  b 0x82a139e4
	pc = 0x82A139E4; continue 'dispatch;
            }
            0x82A139C0 => {
    //   block [0x82A139C0..0x82A139DC)
	// 82A139C0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A139C4: 409A0020  bne cr6, 0x82a139e4
	if !ctx.cr[6].eq {
	pc = 0x82A139E4; continue 'dispatch;
	}
	// 82A139C8: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A139CC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A139D0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A139D4: 409A0008  bne cr6, 0x82a139dc
	if !ctx.cr[6].eq {
	pc = 0x82A139DC; continue 'dispatch;
	}
	// 82A139D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A139DC; continue 'dispatch;
            }
            0x82A139DC => {
    //   block [0x82A139DC..0x82A139E4)
	// 82A139DC: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A139E0: D016000C  stfs f0, 0xc(r22)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x82A139E4; continue 'dispatch;
            }
            0x82A139E4 => {
    //   block [0x82A139E4..0x82A13A10)
	// 82A139E4: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A139E8: 48000951  bl 0x82a14338
	ctx.lr = 0x82A139EC;
	sub_82A14338(ctx, base);
	// 82A139EC: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82A139F0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82A139F4: 48001495  bl 0x82a14e88
	ctx.lr = 0x82A139F8;
	sub_82A14E88(ctx, base);
	// 82A139F8: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A139FC: 48001395  bl 0x82a14d90
	ctx.lr = 0x82A13A00;
	sub_82A14D90(ctx, base);
	// 82A13A00: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A13A04: 4B808335  bl 0x8221bd38
	ctx.lr = 0x82A13A08;
	sub_8221BD38(ctx, base);
	// 82A13A08: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A13A0C: 48295A34  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A13A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A13A10 size=964
    let mut pc: u32 = 0x82A13A10;
    'dispatch: loop {
        match pc {
            0x82A13A10 => {
    //   block [0x82A13A10..0x82A13A90)
	// 82A13A10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A13A14: 482959ED  bl 0x82ca9400
	ctx.lr = 0x82A13A18;
	sub_82CA93D0(ctx, base);
	// 82A13A18: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A13A1C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A13A20: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A13A24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13A28: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13A2C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A13A30: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A13A34: 4E800421  bctrl
	ctx.lr = 0x82A13A38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A13A38: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A13A3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A13A40: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A13A44: 4198004C  blt cr6, 0x82a13a90
	if ctx.cr[6].lt {
	pc = 0x82A13A90; continue 'dispatch;
	}
	// 82A13A48: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A13A4C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A13A50: 39010058  addi r8, r1, 0x58
	ctx.r[8].s64 = ctx.r[1].s64 + 88;
	// 82A13A54: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A13A58: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A13A5C: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A13A60: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13A64: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A13A68: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A13A6C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A13A70: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A13A74: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A13A78: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A13A7C: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A13A80: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A13A84: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A13A88: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A13A8C: 48000014  b 0x82a13aa0
	pc = 0x82A13AA0; continue 'dispatch;
            }
            0x82A13A90 => {
    //   block [0x82A13A90..0x82A13AA0)
	// 82A13A90: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A13A94: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A13A98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13A9C: 4800D44D  bl 0x82a20ee8
	ctx.lr = 0x82A13AA0;
	sub_82A20EE8(ctx, base);
	pc = 0x82A13AA0; continue 'dispatch;
            }
            0x82A13AA0 => {
    //   block [0x82A13AA0..0x82A13AD4)
	// 82A13AA0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A13AA4: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A13AA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A13AAC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A13AB0: 419A0024  beq cr6, 0x82a13ad4
	if ctx.cr[6].eq {
	pc = 0x82A13AD4; continue 'dispatch;
	}
	// 82A13AB4: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A13AB8: 89410052  lbz r10, 0x52(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A13ABC: 8921005B  lbz r9, 0x5b(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(91 as u32) ) } as u64;
	// 82A13AC0: 89010058  lbz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A13AC4: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A13AC8: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82A13ACC: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A13AD0: 99010053  stb r8, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[8].u8 ) };
	pc = 0x82A13AD4; continue 'dispatch;
            }
            0x82A13AD4 => {
    //   block [0x82A13AD4..0x82A13B3C)
	// 82A13AD4: 3D604AD7  lis r11, 0x4ad7
	ctx.r[11].s64 = 1255604224;
	// 82A13AD8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A13ADC: 61698C59  ori r9, r11, 0x8c59
	ctx.r[9].u64 = ctx.r[11].u64 | 35929;
	// 82A13AE0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A13AE4: 409A006C  bne cr6, 0x82a13b50
	if !ctx.cr[6].eq {
	pc = 0x82A13B50; continue 'dispatch;
	}
	// 82A13AE8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A13AEC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A13AF0: 4198004C  blt cr6, 0x82a13b3c
	if ctx.cr[6].lt {
	pc = 0x82A13B3C; continue 'dispatch;
	}
	// 82A13AF4: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A13AF8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A13AFC: 39010064  addi r8, r1, 0x64
	ctx.r[8].s64 = ctx.r[1].s64 + 100;
	// 82A13B00: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A13B04: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A13B08: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A13B0C: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13B10: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A13B14: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A13B18: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A13B1C: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A13B20: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A13B24: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A13B28: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A13B2C: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A13B30: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A13B34: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A13B38: 48000030  b 0x82a13b68
	pc = 0x82A13B68; continue 'dispatch;
            }
            0x82A13B3C => {
    //   block [0x82A13B3C..0x82A13B50)
	// 82A13B3C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A13B40: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82A13B44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13B48: 4800D3A1  bl 0x82a20ee8
	ctx.lr = 0x82A13B4C;
	sub_82A20EE8(ctx, base);
	// 82A13B4C: 4800001C  b 0x82a13b68
	pc = 0x82A13B68; continue 'dispatch;
            }
            0x82A13B50 => {
    //   block [0x82A13B50..0x82A13B68)
	// 82A13B50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13B54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A13B58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13B5C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A13B60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A13B64: 4E800421  bctrl
	ctx.lr = 0x82A13B68;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A13B68 => {
    //   block [0x82A13B68..0x82A13BC4)
	// 82A13B68: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A13B6C: 48000A7D  bl 0x82a145e8
	ctx.lr = 0x82A13B70;
	sub_82A145E8(ctx, base);
	// 82A13B70: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A13B74: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A13B78: 4198004C  blt cr6, 0x82a13bc4
	if ctx.cr[6].lt {
	pc = 0x82A13BC4; continue 'dispatch;
	}
	// 82A13B7C: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A13B80: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A13B84: 3901005C  addi r8, r1, 0x5c
	ctx.r[8].s64 = ctx.r[1].s64 + 92;
	// 82A13B88: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A13B8C: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A13B90: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A13B94: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13B98: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A13B9C: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A13BA0: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A13BA4: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A13BA8: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A13BAC: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A13BB0: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A13BB4: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A13BB8: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A13BBC: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A13BC0: 48000014  b 0x82a13bd4
	pc = 0x82A13BD4; continue 'dispatch;
            }
            0x82A13BC4 => {
    //   block [0x82A13BC4..0x82A13BD4)
	// 82A13BC4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A13BC8: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82A13BCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13BD0: 4800D319  bl 0x82a20ee8
	ctx.lr = 0x82A13BD4;
	sub_82A20EE8(ctx, base);
	pc = 0x82A13BD4; continue 'dispatch;
            }
            0x82A13BD4 => {
    //   block [0x82A13BD4..0x82A13C0C)
	// 82A13BD4: 8361005C  lwz r27, 0x5c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A13BD8: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A13BDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A13BE0: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82A13BE4: 419A0028  beq cr6, 0x82a13c0c
	if ctx.cr[6].eq {
	pc = 0x82A13C0C; continue 'dispatch;
	}
	// 82A13BE8: 89610051  lbz r11, 0x51(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A13BEC: 8901005F  lbz r8, 0x5f(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(95 as u32) ) } as u64;
	// 82A13BF0: 89210052  lbz r9, 0x52(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A13BF4: 8941005C  lbz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A13BF8: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A13BFC: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 82A13C00: 99210051  stb r9, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[9].u8 ) };
	// 82A13C04: 99410053  stb r10, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[10].u8 ) };
	// 82A13C08: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82A13C0C; continue 'dispatch;
            }
            0x82A13C0C => {
    //   block [0x82A13C0C..0x82A13C80)
	// 82A13C0C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82A13C10: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 82A13C14: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82A13C18: 3BABF1BC  addi r29, r11, -0xe44
	ctx.r[29].s64 = ctx.r[11].s64 + -3652;
	// 82A13C1C: 4099010C  ble cr6, 0x82a13d28
	if !ctx.cr[6].gt {
	pc = 0x82A13D28; continue 'dispatch;
	}
	// 82A13C20: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82A13C24: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 82A13C28: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A13C2C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A13C30: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A13C34: 4198004C  blt cr6, 0x82a13c80
	if ctx.cr[6].lt {
	pc = 0x82A13C80; continue 'dispatch;
	}
	// 82A13C38: 392BFFFC  addi r9, r11, -4
	ctx.r[9].s64 = ctx.r[11].s64 + -4;
	// 82A13C3C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A13C40: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82A13C44: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A13C48: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 82A13C4C: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 82A13C50: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13C54: 98A80000  stb r5, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u8 ) };
	// 82A13C58: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A13C5C: 98880001  stb r4, 1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82A13C60: 886B0002  lbz r3, 2(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A13C64: 98680002  stb r3, 2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 82A13C68: 896B0003  lbz r11, 3(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 82A13C6C: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82A13C70: 913F0014  stw r9, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A13C74: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A13C78: 99680003  stb r11, 3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(3 as u32), ctx.r[11].u8 ) };
	// 82A13C7C: 48000014  b 0x82a13c90
	pc = 0x82A13C90; continue 'dispatch;
            }
            0x82A13C80 => {
    //   block [0x82A13C80..0x82A13C90)
	// 82A13C80: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A13C84: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A13C88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13C8C: 4800D25D  bl 0x82a20ee8
	ctx.lr = 0x82A13C90;
	sub_82A20EE8(ctx, base);
	pc = 0x82A13C90; continue 'dispatch;
            }
            0x82A13C90 => {
    //   block [0x82A13C90..0x82A13CC4)
	// 82A13C90: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A13C94: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A13C98: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82A13C9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A13CA0: 419A0024  beq cr6, 0x82a13cc4
	if ctx.cr[6].eq {
	pc = 0x82A13CC4; continue 'dispatch;
	}
	// 82A13CA4: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A13CA8: 89410051  lbz r10, 0x51(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82A13CAC: 89210053  lbz r9, 0x53(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(83 as u32) ) } as u64;
	// 82A13CB0: 89010052  lbz r8, 0x52(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82A13CB4: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 82A13CB8: 99410052  stb r10, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u8 ) };
	// 82A13CBC: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82A13CC0: 99010051  stb r8, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[8].u8 ) };
	pc = 0x82A13CC4; continue 'dispatch;
            }
            0x82A13CC4 => {
    //   block [0x82A13CC4..0x82A13D28)
	// 82A13CC4: 817C6DD4  lwz r11, 0x6dd4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28116 as u32) ) } as u64;
	// 82A13CC8: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A13CCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A13CD0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A13CD4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A13CD8: 7DABEC2E  lfsx f13, r11, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A13CDC: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A13CE0: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82A13CE4: D9610050  stfd f11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[11].u64 ) };
	// 82A13CE8: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A13CEC: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 82A13CF0: 4800DC21  bl 0x82a21910
	ctx.lr = 0x82A13CF4;
	sub_82A21910(ctx, base);
	// 82A13CF4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82A13CF8: 81010074  lwz r8, 0x74(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A13CFC: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 82A13D00: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82A13D04: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	pc = 0x82A13D28; continue 'dispatch;
            }
            0x82A13D28 => {
    //   block [0x82A13D28..0x82A13DD4)
	// 82A13D28: 409A0014  bne cr6, 0x82a13d3c
	if !ctx.cr[6].eq {
	pc = 0x82A13D3C; continue 'dispatch;
	}
	// 82A13D2C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A13D30: C00BD5C8  lfs f0, -0x2a38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A13D34: D01A0008  stfs f0, 8(r26)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A13D38: 48000070  b 0x82a13da8
	pc = 0x82A13DA8; continue 'dispatch;
	// 82A13D3C: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A13D40: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13D44: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A13D48: 409A0008  bne cr6, 0x82a13d50
	if !ctx.cr[6].eq {
	pc = 0x82A13D50; continue 'dispatch;
	}
	// 82A13D4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82A13D50: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A13D54: 391D0008  addi r8, r29, 8
	ctx.r[8].s64 = ctx.r[29].s64 + 8;
	// 82A13D58: 817C6DD4  lwz r11, 0x6dd4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28116 as u32) ) } as u64;
	// 82A13D5C: 2F1B0001  cmpwi cr6, r27, 1
	ctx.cr[6].compare_i32(ctx.r[27].s32, 1, &mut ctx.xer);
	// 82A13D60: 7D2707B4  extsw r7, r9
	ctx.r[7].s64 = ctx.r[9].s32 as i64;
	// 82A13D64: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A13D68: F8E10068  std r7, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[7].u64 ) };
	// 82A13D6C: C8010068  lfd f0, 0x68(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A13D70: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82A13D74: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A13D78: 7D66442E  lfsx f11, r6, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A13D7C: ED4B0332  fmuls f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A13D80: D15A0008  stfs f10, 8(r26)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A13D84: 409A0024  bne cr6, 0x82a13da8
	if !ctx.cr[6].eq {
	pc = 0x82A13DA8; continue 'dispatch;
	}
	// 82A13D88: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13D8C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A13D90: 409A0008  bne cr6, 0x82a13d98
	if !ctx.cr[6].eq {
	pc = 0x82A13D98; continue 'dispatch;
	}
	// 82A13D94: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82A13D98: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 82A13D9C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A13DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A13DD8 size=960
    let mut pc: u32 = 0x82A13DD8;
    'dispatch: loop {
        match pc {
            0x82A13DD8 => {
    //   block [0x82A13DD8..0x82A13E48)
	// 82A13DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A13DDC: 48295615  bl 0x82ca93f0
	ctx.lr = 0x82A13DE0;
	sub_82CA93D0(ctx, base);
	// 82A13DE0: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A13DE4: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 82A13DE8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A13DEC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A13DF0: 480007F9  bl 0x82a145e8
	ctx.lr = 0x82A13DF4;
	sub_82A145E8(ctx, base);
	// 82A13DF4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A13DF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13DFC: 3B0BD5C8  addi r24, r11, -0x2a38
	ctx.r[24].s64 = ctx.r[11].s64 + -10808;
	// 82A13E00: 3898D684  addi r4, r24, -0x297c
	ctx.r[4].s64 = ctx.r[24].s64 + -10620;
	// 82A13E04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13E08: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A13E0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A13E10: 4E800421  bctrl
	ctx.lr = 0x82A13E14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A13E14: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A13E18: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A13E1C: 419A0350  beq cr6, 0x82a1416c
	if ctx.cr[6].eq {
	pc = 0x82A1416C; continue 'dispatch;
	}
	// 82A13E20: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 82A13E24: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A13E28: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82A13E2C: 3B2BFFDF  addi r25, r11, -0x21
	ctx.r[25].s64 = ctx.r[11].s64 + -33;
	// 82A13E30: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 82A13E34: 817EE73C  lwz r11, -0x18c4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-6340 as u32) ) } as u64;
	// 82A13E38: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A13E3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A13E40: 419A0008  beq cr6, 0x82a13e48
	if ctx.cr[6].eq {
	pc = 0x82A13E48; continue 'dispatch;
	}
	// 82A13E44: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A13E48 => {
    //   block [0x82A13E48..0x82A13E7C)
	// 82A13E48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13E4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13E50: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A13E54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A13E58: 4E800421  bctrl
	ctx.lr = 0x82A13E5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A13E5C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A13E60: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A13E64: 419A0038  beq cr6, 0x82a13e9c
	if ctx.cr[6].eq {
	pc = 0x82A13E9C; continue 'dispatch;
	}
	// 82A13E68: 817EE73C  lwz r11, -0x18c4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-6340 as u32) ) } as u64;
	// 82A13E6C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A13E70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A13E74: 419A0008  beq cr6, 0x82a13e7c
	if ctx.cr[6].eq {
	pc = 0x82A13E7C; continue 'dispatch;
	}
	// 82A13E78: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A13E7C => {
    //   block [0x82A13E7C..0x82A13E9C)
	// 82A13E7C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A13E80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13E84: 4BA6C945  bl 0x824807c8
	ctx.lr = 0x82A13E88;
	sub_824807C8(ctx, base);
	// 82A13E88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13E8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13E90: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A13E94: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A13E98: 4E800421  bctrl
	ctx.lr = 0x82A13E9C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A13E9C => {
    //   block [0x82A13E9C..0x82A13EC0)
	// 82A13E9C: 3898D6A0  addi r4, r24, -0x2960
	ctx.r[4].s64 = ctx.r[24].s64 + -10592;
	// 82A13EA0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A13EA4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A13EA8: 4B819029  bl 0x8222ced0
	ctx.lr = 0x82A13EAC;
	sub_8222CED0(ctx, base);
	// 82A13EAC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A13EB0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A13EB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A13EB8: 419A0008  beq cr6, 0x82a13ec0
	if ctx.cr[6].eq {
	pc = 0x82A13EC0; continue 'dispatch;
	}
	// 82A13EBC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A13EC0; continue 'dispatch;
            }
            0x82A13EC0 => {
    //   block [0x82A13EC0..0x82A13F48)
	// 82A13EC0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A13EC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13EC8: 4BA6C901  bl 0x824807c8
	ctx.lr = 0x82A13ECC;
	sub_824807C8(ctx, base);
	// 82A13ECC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A13ED0: 4B800F09  bl 0x82214dd8
	ctx.lr = 0x82A13ED4;
	sub_82214DD8(ctx, base);
	// 82A13ED4: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82A13ED8: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 82A13EDC: 3BCBF1BC  addi r30, r11, -0xe44
	ctx.r[30].s64 = ctx.r[11].s64 + -3652;
	// 82A13EE0: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 82A13EE4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A13EE8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A13EEC: 4099012C  ble cr6, 0x82a14018
	if !ctx.cr[6].gt {
	pc = 0x82A14018; continue 'dispatch;
	}
	// 82A13EF0: 39610078  addi r11, r1, 0x78
	ctx.r[11].s64 = ctx.r[1].s64 + 120;
	// 82A13EF4: 3F40834A  lis r26, -0x7cb6
	ctx.r[26].s64 = -2092302336;
	// 82A13EF8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A13EFC: 3F60834A  lis r27, -0x7cb6
	ctx.r[27].s64 = -2092302336;
	// 82A13F00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13F04: 3898D6AC  addi r4, r24, -0x2954
	ctx.r[4].s64 = ctx.r[24].s64 + -10580;
	// 82A13F08: 92E100B0  stw r23, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[23].u32 ) };
	// 82A13F0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13F10: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A13F14: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A13F18: 4E800421  bctrl
	ctx.lr = 0x82A13F1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A13F1C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A13F20: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A13F24: 419A00C8  beq cr6, 0x82a13fec
	if ctx.cr[6].eq {
	pc = 0x82A13FEC; continue 'dispatch;
	}
	// 82A13F28: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A13F2C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A13F30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A13F34: 409A002C  bne cr6, 0x82a13f60
	if !ctx.cr[6].eq {
	pc = 0x82A13F60; continue 'dispatch;
	}
	// 82A13F38: 817BE740  lwz r11, -0x18c0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-6336 as u32) ) } as u64;
	// 82A13F3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A13F40: 419A0008  beq cr6, 0x82a13f48
	if ctx.cr[6].eq {
	pc = 0x82A13F48; continue 'dispatch;
	}
	// 82A13F44: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A13F48 => {
    //   block [0x82A13F48..0x82A13F60)
	// 82A13F48: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82A13F4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13F50: 4BA6C879  bl 0x824807c8
	ctx.lr = 0x82A13F54;
	sub_824807C8(ctx, base);
	// 82A13F54: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A13F58: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82A13F5C: 48000044  b 0x82a13fa0
	pc = 0x82A13FA0; continue 'dispatch;
            }
            0x82A13F60 => {
    //   block [0x82A13F60..0x82A13F70)
	// 82A13F60: 817AE744  lwz r11, -0x18bc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6332 as u32) ) } as u64;
	// 82A13F64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A13F68: 419A0008  beq cr6, 0x82a13f70
	if ctx.cr[6].eq {
	pc = 0x82A13F70; continue 'dispatch;
	}
	// 82A13F6C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A13F70; continue 'dispatch;
            }
            0x82A13F70 => {
    //   block [0x82A13F70..0x82A13FA0)
	// 82A13F70: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A13F74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A13F78: 4BA6C8D9  bl 0x82480850
	ctx.lr = 0x82A13F7C;
	sub_82480850(ctx, base);
	// 82A13F7C: 817D6DD4  lwz r11, 0x6dd4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28116 as u32) ) } as u64;
	// 82A13F80: C0010060  lfs f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A13F84: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A13F88: 7DABF42E  lfsx f13, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A13F8C: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A13F90: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82A13F94: D9610070  stfd f11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[11].u64 ) };
	// 82A13F98: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A13F9C: 914100B0  stw r10, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	pc = 0x82A13FA0; continue 'dispatch;
            }
            0x82A13FA0 => {
    //   block [0x82A13FA0..0x82A13FEC)
	// 82A13FA0: 3898D6C0  addi r4, r24, -0x2940
	ctx.r[4].s64 = ctx.r[24].s64 + -10560;
	// 82A13FA4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A13FA8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A13FAC: 4B818F25  bl 0x8222ced0
	ctx.lr = 0x82A13FB0;
	sub_8222CED0(ctx, base);
	// 82A13FB0: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 82A13FB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A13FB8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A13FBC: 48821555  bl 0x83235510
	ctx.lr = 0x82A13FC0;
	sub_83235510(ctx, base);
	// 82A13FC0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A13FC4: 4B800E15  bl 0x82214dd8
	ctx.lr = 0x82A13FC8;
	sub_82214DD8(ctx, base);
	// 82A13FC8: 396100A0  addi r11, r1, 0xa0
	ctx.r[11].s64 = ctx.r[1].s64 + 160;
	// 82A13FCC: 394100C0  addi r10, r1, 0xc0
	ctx.r[10].s64 = ctx.r[1].s64 + 192;
	// 82A13FD0: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A13FD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A13FEC; continue 'dispatch;
            }
            0x82A13FEC => {
    //   block [0x82A13FEC..0x82A14018)
	// 82A13FEC: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A13FF0: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 82A13FF4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A13FF8: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A13FFC: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A14000: 48000AF9  bl 0x82a14af8
	ctx.lr = 0x82A14004;
	sub_82A14AF8(ctx, base);
	// 82A14004: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A14008: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82A1400C: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A14010: 4198FEF0  blt cr6, 0x82a13f00
	if ctx.cr[6].lt {
	pc = 0x82A13F00; continue 'dispatch;
	}
	// 82A14014: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	pc = 0x82A14018; continue 'dispatch;
            }
            0x82A14018 => {
    //   block [0x82A14018..0x82A1416C)
	// 82A14018: 409A0010  bne cr6, 0x82a14028
	if !ctx.cr[6].eq {
	pc = 0x82A14028; continue 'dispatch;
	}
	// 82A1401C: C0180000  lfs f0, 0(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A14020: D0160008  stfs f0, 8(r22)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A14024: 48000048  b 0x82a1406c
	pc = 0x82A1406C; continue 'dispatch;
	// 82A14028: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A1402C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14030: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A14034: 409A0008  bne cr6, 0x82a1403c
	if !ctx.cr[6].eq {
	pc = 0x82A1403C; continue 'dispatch;
	}
	// 82A14038: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82A1403C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A14040: 393E0008  addi r9, r30, 8
	ctx.r[9].s64 = ctx.r[30].s64 + 8;
	// 82A14044: 817D6DD4  lwz r11, 0x6dd4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28116 as u32) ) } as u64;
	// 82A14048: 7D4807B4  extsw r8, r10
	ctx.r[8].s64 = ctx.r[10].s32 as i64;
	// 82A1404C: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A14050: F9010070  std r8, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u64 ) };
	// 82A14054: C8010070  lfd f0, 0x70(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A14058: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82A1405C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A14060: 7D674C2E  lfsx f11, r7, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A14064: ED4B0332  fmuls f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A14068: D1560008  stfs f10, 8(r22)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A1406C: 3BD60010  addi r30, r22, 0x10
	ctx.r[30].s64 = ctx.r[22].s64 + 16;
	// 82A14070: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 82A14074: 3898D6C8  addi r4, r24, -0x2938
	ctx.r[4].s64 = ctx.r[24].s64 + -10552;
	// 82A14078: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A1407C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
            }
            0x82A1416C => {
    //   block [0x82A1416C..0x82A14198)
	// 82A1416C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A14170: 480004D1  bl 0x82a14640
	ctx.lr = 0x82A14174;
	sub_82A14640(ctx, base);
	// 82A14174: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 82A14178: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82A1417C: 48000E55  bl 0x82a14fd0
	ctx.lr = 0x82A14180;
	sub_82A14FD0(ctx, base);
	// 82A14180: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A14184: 48000C0D  bl 0x82a14d90
	ctx.lr = 0x82A14188;
	sub_82A14D90(ctx, base);
	// 82A14188: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A1418C: 4B807BAD  bl 0x8221bd38
	ctx.lr = 0x82A14190;
	sub_8221BD38(ctx, base);
	// 82A14190: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82A14194: 482952AC  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A14198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A14198 size=28
    let mut pc: u32 = 0x82A14198;
    'dispatch: loop {
        match pc {
            0x82A14198 => {
    //   block [0x82A14198..0x82A141B4)
	// 82A14198: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1419C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A141A0: 409A0014  bne cr6, 0x82a141b4
	if !ctx.cr[6].eq {
		sub_82A141B4(ctx, base);
		return;
	}
	// 82A141A4: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A141B4(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A141B4 size=180
    let mut pc: u32 = 0x82A141B4;
    'dispatch: loop {
        match pc {
            0x82A141B4 => {
    //   block [0x82A141B4..0x82A14268)
	// 82A141B4: 7CAB07B4  extsw r11, r5
	ctx.r[11].s64 = ctx.r[5].s32 as i64;
	// 82A141B8: C0040008  lfs f0, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A141BC: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A141C0: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
	// 82A141C4: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82A141C8: C981FFF0  lfd f12, -0x10(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A141CC: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82A141D0: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82A141D4: ED2A0028  fsubs f9, f10, f0
	ctx.f[9].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A141D8: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A141DC: FCE0401E  fctiwz f7, f8
	ctx.f[7].s64 = if ctx.f[8].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[8].f64.trunc() as i32 as i64 };
	// 82A141E0: D8E1FFF0  stfd f7, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[7].u64 ) };
	// 82A141E4: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82A141E8: 7D66FE70  srawi r6, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 82A141EC: 7CC55838  and r5, r6, r11
	ctx.r[5].u64 = ctx.r[6].u64 & ctx.r[11].u64;
	// 82A141F0: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82A141F4: 7D255850  subf r9, r5, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 82A141F8: 21690009  subfic r11, r9, 9
	ctx.xer.ca = ctx.r[9].u32 <= 9 as u32;
	ctx.r[11].s64 = (9 as i64) - ctx.r[9].s64;
	// 82A141FC: 7D64FE70  srawi r4, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 82A14200: 7D46FE70  srawi r6, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 82A14204: 7C8B5838  and r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 & ctx.r[11].u64;
	// 82A14208: 7CC55038  and r5, r6, r10
	ctx.r[5].u64 = ctx.r[6].u64 & ctx.r[10].u64;
	// 82A1420C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A14210: 7D255050  subf r9, r5, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[5].s64;
	// 82A14214: 7D6407B4  extsw r4, r11
	ctx.r[4].s64 = ctx.r[11].s32 as i64;
	// 82A14218: 21490009  subfic r10, r9, 9
	ctx.xer.ca = ctx.r[9].u32 <= 9 as u32;
	ctx.r[10].s64 = (9 as i64) - ctx.r[9].s64;
	// 82A1421C: F881FFF0  std r4, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[4].u64 ) };
	// 82A14220: C8C1FFF0  lfd f6, -0x10(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A14224: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 82A14228: 7D46FE70  srawi r6, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 82A1422C: 7CCA5038  and r10, r6, r10
	ctx.r[10].u64 = ctx.r[6].u64 & ctx.r[10].u64;
	// 82A14230: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 82A14234: 55652036  slwi r5, r11, 4
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A14238: 7C8A4A14  add r4, r10, r9
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82A1423C: 548B2036  slwi r11, r4, 4
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A14268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A14268 size=104
    let mut pc: u32 = 0x82A14268;
    'dispatch: loop {
        match pc {
            0x82A14268 => {
    //   block [0x82A14268..0x82A142D0)
	// 82A14268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1426C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A14270: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A14274: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A14278: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1427C: 4882F895  bl 0x83243b10
	ctx.lr = 0x82A14280;
	sub_83243B10(ctx, base);
	// 82A14280: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A14284: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A14288: 390AB650  addi r8, r10, -0x49b0
	ctx.r[8].s64 = ctx.r[10].s64 + -18864;
	// 82A1428C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A14290: 38E94B08  addi r7, r9, 0x4b08
	ctx.r[7].s64 = ctx.r[9].s64 + 19208;
	// 82A14294: C1AAB650  lfs f13, -0x49b0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A14298: 997F00E0  stb r11, 0xe0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[11].u8 ) };
	// 82A1429C: 997F00E1  stb r11, 0xe1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(225 as u32), ctx.r[11].u8 ) };
	// 82A142A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A142A4: C008DE40  lfs f0, -0x21c0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8640 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A142A8: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A142AC: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82A142B0: 997F00F4  stb r11, 0xf4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u8 ) };
	// 82A142B4: D1BF00F0  stfs f13, 0xf0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82A142B8: 997F00F5  stb r11, 0xf5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(245 as u32), ctx.r[11].u8 ) };
	// 82A142BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A142C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A142C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A142C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A142CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A142D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A142D0 size=104
    let mut pc: u32 = 0x82A142D0;
    'dispatch: loop {
        match pc {
            0x82A142D0 => {
    //   block [0x82A142D0..0x82A14338)
	// 82A142D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A142D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A142D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A142DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A142E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A142E4: 4882F82D  bl 0x83243b10
	ctx.lr = 0x82A142E8;
	sub_83243B10(ctx, base);
	// 82A142E8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A142EC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82A142F0: 390AB650  addi r8, r10, -0x49b0
	ctx.r[8].s64 = ctx.r[10].s64 + -18864;
	// 82A142F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A142F8: 38E95158  addi r7, r9, 0x5158
	ctx.r[7].s64 = ctx.r[9].s64 + 20824;
	// 82A142FC: C1AAB650  lfs f13, -0x49b0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A14300: 997F00E0  stb r11, 0xe0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[11].u8 ) };
	// 82A14304: 997F00E1  stb r11, 0xe1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(225 as u32), ctx.r[11].u8 ) };
	// 82A14308: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1430C: C008DE40  lfs f0, -0x21c0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-8640 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A14310: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A14314: D01F00E4  stfs f0, 0xe4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82A14318: 997F00F4  stb r11, 0xf4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u8 ) };
	// 82A1431C: D1BF00F0  stfs f13, 0xf0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82A14320: 997F00F5  stb r11, 0xf5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(245 as u32), ctx.r[11].u8 ) };
	// 82A14324: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A14328: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1432C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A14330: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A14334: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A14338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A14338 size=684
    let mut pc: u32 = 0x82A14338;
    'dispatch: loop {
        match pc {
            0x82A14338 => {
    //   block [0x82A14338..0x82A14368)
	// 82A14338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1433C: 482950C5  bl 0x82ca9400
	ctx.lr = 0x82A14340;
	sub_82CA93D0(ctx, base);
	// 82A14340: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A14344: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A14348: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1434C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82A14350: 4198028C  blt cr6, 0x82a145dc
	if ctx.cr[6].lt {
	pc = 0x82A145DC; continue 'dispatch;
	}
	// 82A14354: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A14358: 4B80AF01  bl 0x8221f258
	ctx.lr = 0x82A1435C;
	sub_8221F258(ctx, base);
	// 82A1435C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A14360: 419A0008  beq cr6, 0x82a14368
	if ctx.cr[6].eq {
	pc = 0x82A14368; continue 'dispatch;
	}
	// 82A14364: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82A14368; continue 'dispatch;
            }
            0x82A14368 => {
    //   block [0x82A14368..0x82A14374)
	// 82A14368: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1436C: 41820008  beq 0x82a14374
	if ctx.cr[0].eq {
	pc = 0x82A14374; continue 'dispatch;
	}
	// 82A14370: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82A14374; continue 'dispatch;
            }
            0x82A14374 => {
    //   block [0x82A14374..0x82A1438C)
	// 82A14374: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A14378: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82A1437C: 3BA00019  li r29, 0x19
	ctx.r[29].s64 = 25;
	// 82A14380: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82A14384: 3BE10088  addi r31, r1, 0x88
	ctx.r[31].s64 = ctx.r[1].s64 + 136;
	// 82A14388: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	pc = 0x82A1438C; continue 'dispatch;
            }
            0x82A1438C => {
    //   block [0x82A1438C..0x82A143BC)
	// 82A1438C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A14390: 4B80AF31  bl 0x8221f2c0
	ctx.lr = 0x82A14394;
	sub_8221F2C0(ctx, base);
	// 82A14394: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A14398: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A1439C: 409A0028  bne cr6, 0x82a143c4
	if !ctx.cr[6].eq {
	pc = 0x82A143C4; continue 'dispatch;
	}
	// 82A143A0: 817C6F6C  lwz r11, 0x6f6c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82A143A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A143A8: 419A0014  beq cr6, 0x82a143bc
	if ctx.cr[6].eq {
	pc = 0x82A143BC; continue 'dispatch;
	}
	// 82A143AC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A143B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A143B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A143B8: 4E800421  bctrl
	ctx.lr = 0x82A143BC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A143BC => {
    //   block [0x82A143BC..0x82A143C4)
	// 82A143BC: 482ADFED  bl 0x82cc23a8
	ctx.lr = 0x82A143C0;
	sub_82CC23A8(ctx, base);
	// 82A143C0: 48000008  b 0x82a143c8
	pc = 0x82A143C8; continue 'dispatch;
            }
            0x82A143C4 => {
    //   block [0x82A143C4..0x82A143C8)
	// 82A143C4: 93DE0000  stw r30, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x82A143C8; continue 'dispatch;
            }
            0x82A143C8 => {
    //   block [0x82A143C8..0x82A143D4)
	// 82A143C8: 357E0004  addic. r11, r30, 4
	ctx.xer.ca = (ctx.r[30].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A143CC: 41820008  beq 0x82a143d4
	if ctx.cr[0].eq {
	pc = 0x82A143D4; continue 'dispatch;
	}
	// 82A143D0: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x82A143D4; continue 'dispatch;
            }
            0x82A143D4 => {
    //   block [0x82A143D4..0x82A14408)
	// 82A143D4: 93DFFFFC  stw r30, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[30].u32 ) };
	// 82A143D8: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A143DC: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82A143E0: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82A143E4: 4080FFA8  bge 0x82a1438c
	if !ctx.cr[0].lt {
	pc = 0x82A1438C; continue 'dispatch;
	}
	// 82A143E8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A143EC: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82A143F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A143F4: 419A011C  beq cr6, 0x82a14510
	if ctx.cr[6].eq {
	pc = 0x82A14510; continue 'dispatch;
	}
	// 82A143F8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A143FC: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 82A14400: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82A14404: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	pc = 0x82A14408; continue 'dispatch;
            }
            0x82A14408 => {
    //   block [0x82A14408..0x82A1441C)
	// 82A14408: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1440C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14410: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A14414: 409A0008  bne cr6, 0x82a1441c
	if !ctx.cr[6].eq {
	pc = 0x82A1441C; continue 'dispatch;
	}
	// 82A14418: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A1441C; continue 'dispatch;
            }
            0x82A1441C => {
    //   block [0x82A1441C..0x82A14464)
	// 82A1441C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A14420: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A14424: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14428: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A1442C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A14430: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A14434: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A14438: E8C10070  ld r6, 0x70(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A1443C: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14440: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82A14444: E8E10068  ld r7, 0x68(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A14448: 90810064  stw r4, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[4].u32 ) };
	// 82A1444C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A14450: 48000611  bl 0x82a14a60
	ctx.lr = 0x82A14454;
	sub_82A14A60(ctx, base);
	// 82A14454: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82A14458: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A1445C: 419A0068  beq cr6, 0x82a144c4
	if ctx.cr[6].eq {
	pc = 0x82A144C4; continue 'dispatch;
	}
	// 82A14460: 3BE10088  addi r31, r1, 0x88
	ctx.r[31].s64 = ctx.r[1].s64 + 136;
	pc = 0x82A14464; continue 'dispatch;
            }
            0x82A14464 => {
    //   block [0x82A14464..0x82A144AC)
	// 82A14464: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1446C: 419A0040  beq cr6, 0x82a144ac
	if ctx.cr[6].eq {
	pc = 0x82A144AC; continue 'dispatch;
	}
	// 82A14470: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A14474: 387FFFF8  addi r3, r31, -8
	ctx.r[3].s64 = ctx.r[31].s64 + -8;
	// 82A14478: 48000479  bl 0x82a148f0
	ctx.lr = 0x82A1447C;
	sub_82A148F0(ctx, base);
	// 82A1447C: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82A14480: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A14484: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82A14488: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A1448C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A14490: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A14494: 915FFFFC  stw r10, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	// 82A14498: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1449C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A144A0: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82A144A4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A144A8: 4198FFBC  blt cr6, 0x82a14464
	if ctx.cr[6].lt {
	pc = 0x82A14464; continue 'dispatch;
	}
	pc = 0x82A144AC; continue 'dispatch;
            }
            0x82A144AC => {
    //   block [0x82A144AC..0x82A144C4)
	// 82A144AC: 2B1E0019  cmplwi cr6, r30, 0x19
	ctx.cr[6].compare_u32(ctx.r[30].u32, 25 as u32, &mut ctx.xer);
	// 82A144B0: 409A0014  bne cr6, 0x82a144c4
	if !ctx.cr[6].eq {
	pc = 0x82A144C4; continue 'dispatch;
	}
	// 82A144B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A144B8: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82A144BC: 48000435  bl 0x82a148f0
	ctx.lr = 0x82A144C0;
	sub_82A148F0(ctx, base);
	// 82A144C0: 48000044  b 0x82a14504
	pc = 0x82A14504; continue 'dispatch;
            }
            0x82A144C4 => {
    //   block [0x82A144C4..0x82A14504)
	// 82A144C4: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A144C8: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A144CC: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82A144D0: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A144D4: 7CFE5A14  add r7, r30, r11
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82A144D8: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A144DC: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A144E0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A144E4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A144E8: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A144EC: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A144F0: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A144F4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A144F8: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 82A144FC: 409A0008  bne cr6, 0x82a14504
	if !ctx.cr[6].eq {
	pc = 0x82A14504; continue 'dispatch;
	}
	// 82A14500: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	pc = 0x82A14504; continue 'dispatch;
            }
            0x82A14504 => {
    //   block [0x82A14504..0x82A14510)
	// 82A14504: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A14508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1450C: 409AFEFC  bne cr6, 0x82a14408
	if !ctx.cr[6].eq {
	pc = 0x82A14408; continue 'dispatch;
	}
	pc = 0x82A14510; continue 'dispatch;
            }
            0x82A14510 => {
    //   block [0x82A14510..0x82A14520)
	// 82A14510: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 82A14514: 40990024  ble cr6, 0x82a14538
	if !ctx.cr[6].gt {
	pc = 0x82A14538; continue 'dispatch;
	}
	// 82A14518: 3BE1008C  addi r31, r1, 0x8c
	ctx.r[31].s64 = ctx.r[1].s64 + 140;
	// 82A1451C: 3BDDFFFF  addi r30, r29, -1
	ctx.r[30].s64 = ctx.r[29].s64 + -1;
	pc = 0x82A14520; continue 'dispatch;
            }
            0x82A14520 => {
    //   block [0x82A14520..0x82A14538)
	// 82A14520: 389FFFF4  addi r4, r31, -0xc
	ctx.r[4].s64 = ctx.r[31].s64 + -12;
	// 82A14524: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A14528: 480003C9  bl 0x82a148f0
	ctx.lr = 0x82A1452C;
	sub_82A148F0(ctx, base);
	// 82A1452C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A14530: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82A14534: 4082FFEC  bne 0x82a14520
	if !ctx.cr[0].eq {
	pc = 0x82A14520; continue 'dispatch;
	}
	pc = 0x82A14538; continue 'dispatch;
            }
            0x82A14538 => {
    //   block [0x82A14538..0x82A145A4)
	// 82A14538: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1453C: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14540: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82A14544: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 82A14548: 7D1D5A14  add r8, r29, r11
	ctx.r[8].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82A1454C: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A14550: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14554: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A14558: 38ABFFF4  addi r5, r11, -0xc
	ctx.r[5].s64 = ctx.r[11].s64 + -12;
	// 82A1455C: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82A14560: 7F1B2840  cmplw cr6, r27, r5
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A14564: 419A0040  beq cr6, 0x82a145a4
	if ctx.cr[6].eq {
	pc = 0x82A145A4; continue 'dispatch;
	}
	// 82A14568: 81050008  lwz r8, 8(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1456C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A14570: 419A0034  beq cr6, 0x82a145a4
	if ctx.cr[6].eq {
	pc = 0x82A145A4; continue 'dispatch;
	}
	// 82A14574: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14578: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A1457C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A14580: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A14584: 90A10068  stw r5, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[5].u32 ) };
	// 82A14588: 90A10060  stw r5, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u32 ) };
	// 82A1458C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14590: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A14594: E8E10068  ld r7, 0x68(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A14598: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A1459C: E8C10060  ld r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A145A0: 480004C1  bl 0x82a14a60
	ctx.lr = 0x82A145A4;
	sub_82A14A60(ctx, base);
	pc = 0x82A145A4; continue 'dispatch;
            }
            0x82A145A4 => {
    //   block [0x82A145A4..0x82A145AC)
	// 82A145A4: 3BC00019  li r30, 0x19
	ctx.r[30].s64 = 25;
	// 82A145A8: 3BE101BC  addi r31, r1, 0x1bc
	ctx.r[31].s64 = ctx.r[1].s64 + 444;
	pc = 0x82A145AC; continue 'dispatch;
            }
            0x82A145AC => {
    //   block [0x82A145AC..0x82A145DC)
	// 82A145AC: 3BFFFFF4  addi r31, r31, -0xc
	ctx.r[31].s64 = ctx.r[31].s64 + -12;
	// 82A145B0: 387FFFFC  addi r3, r31, -4
	ctx.r[3].s64 = ctx.r[31].s64 + -4;
	// 82A145B4: 480007DD  bl 0x82a14d90
	ctx.lr = 0x82A145B8;
	sub_82A14D90(ctx, base);
	// 82A145B8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A145BC: 4B80777D  bl 0x8221bd38
	ctx.lr = 0x82A145C0;
	sub_8221BD38(ctx, base);
	// 82A145C0: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A145C4: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82A145C8: 4080FFE4  bge 0x82a145ac
	if !ctx.cr[0].lt {
	pc = 0x82A145AC; continue 'dispatch;
	}
	// 82A145CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A145D0: 480007C1  bl 0x82a14d90
	ctx.lr = 0x82A145D4;
	sub_82A14D90(ctx, base);
	// 82A145D4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A145D8: 4B807761  bl 0x8221bd38
	ctx.lr = 0x82A145DC;
	sub_8221BD38(ctx, base);
	pc = 0x82A145DC; continue 'dispatch;
            }
            0x82A145DC => {
    //   block [0x82A145DC..0x82A145E4)
	// 82A145DC: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 82A145E0: 48294E70  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A145E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A145E8 size=88
    let mut pc: u32 = 0x82A145E8;
    'dispatch: loop {
        match pc {
            0x82A145E8 => {
    //   block [0x82A145E8..0x82A14610)
	// 82A145E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A145EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A145F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A145F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A145F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A145FC: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82A14600: 4B80AC59  bl 0x8221f258
	ctx.lr = 0x82A14604;
	sub_8221F258(ctx, base);
	// 82A14604: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A14608: 419A0008  beq cr6, 0x82a14610
	if ctx.cr[6].eq {
	pc = 0x82A14610; continue 'dispatch;
	}
	// 82A1460C: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82A14610; continue 'dispatch;
            }
            0x82A14610 => {
    //   block [0x82A14610..0x82A1461C)
	// 82A14610: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A14614: 41820008  beq 0x82a1461c
	if ctx.cr[0].eq {
	pc = 0x82A1461C; continue 'dispatch;
	}
	// 82A14618: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82A1461C; continue 'dispatch;
            }
            0x82A1461C => {
    //   block [0x82A1461C..0x82A14640)
	// 82A1461C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A14620: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82A14624: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A14628: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A1462C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A14630: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A14634: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A14638: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1463C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A14640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A14640 size=684
    let mut pc: u32 = 0x82A14640;
    'dispatch: loop {
        match pc {
            0x82A14640 => {
    //   block [0x82A14640..0x82A14670)
	// 82A14640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A14644: 48294DBD  bl 0x82ca9400
	ctx.lr = 0x82A14648;
	sub_82CA93D0(ctx, base);
	// 82A14648: 9421FE00  stwu r1, -0x200(r1)
	ea = ctx.r[1].u32.wrapping_add(-512 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1464C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A14650: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A14654: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82A14658: 4198028C  blt cr6, 0x82a148e4
	if ctx.cr[6].lt {
	pc = 0x82A148E4; continue 'dispatch;
	}
	// 82A1465C: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82A14660: 4B80ABF9  bl 0x8221f258
	ctx.lr = 0x82A14664;
	sub_8221F258(ctx, base);
	// 82A14664: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A14668: 419A0008  beq cr6, 0x82a14670
	if ctx.cr[6].eq {
	pc = 0x82A14670; continue 'dispatch;
	}
	// 82A1466C: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82A14670; continue 'dispatch;
            }
            0x82A14670 => {
    //   block [0x82A14670..0x82A1467C)
	// 82A14670: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A14674: 41820008  beq 0x82a1467c
	if ctx.cr[0].eq {
	pc = 0x82A1467C; continue 'dispatch;
	}
	// 82A14678: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82A1467C; continue 'dispatch;
            }
            0x82A1467C => {
    //   block [0x82A1467C..0x82A14694)
	// 82A1467C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A14680: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82A14684: 3BA00019  li r29, 0x19
	ctx.r[29].s64 = 25;
	// 82A14688: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82A1468C: 3BE10088  addi r31, r1, 0x88
	ctx.r[31].s64 = ctx.r[1].s64 + 136;
	// 82A14690: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	pc = 0x82A14694; continue 'dispatch;
            }
            0x82A14694 => {
    //   block [0x82A14694..0x82A146C4)
	// 82A14694: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82A14698: 4B80AC29  bl 0x8221f2c0
	ctx.lr = 0x82A1469C;
	sub_8221F2C0(ctx, base);
	// 82A1469C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A146A0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A146A4: 409A0028  bne cr6, 0x82a146cc
	if !ctx.cr[6].eq {
	pc = 0x82A146CC; continue 'dispatch;
	}
	// 82A146A8: 817C6F6C  lwz r11, 0x6f6c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82A146AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A146B0: 419A0014  beq cr6, 0x82a146c4
	if ctx.cr[6].eq {
	pc = 0x82A146C4; continue 'dispatch;
	}
	// 82A146B4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A146B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A146BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A146C0: 4E800421  bctrl
	ctx.lr = 0x82A146C4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A146C4 => {
    //   block [0x82A146C4..0x82A146CC)
	// 82A146C4: 482ADCE5  bl 0x82cc23a8
	ctx.lr = 0x82A146C8;
	sub_82CC23A8(ctx, base);
	// 82A146C8: 48000008  b 0x82a146d0
	pc = 0x82A146D0; continue 'dispatch;
            }
            0x82A146CC => {
    //   block [0x82A146CC..0x82A146D0)
	// 82A146CC: 93DE0000  stw r30, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x82A146D0; continue 'dispatch;
            }
            0x82A146D0 => {
    //   block [0x82A146D0..0x82A146DC)
	// 82A146D0: 357E0004  addic. r11, r30, 4
	ctx.xer.ca = (ctx.r[30].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A146D4: 41820008  beq 0x82a146dc
	if ctx.cr[0].eq {
	pc = 0x82A146DC; continue 'dispatch;
	}
	// 82A146D8: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x82A146DC; continue 'dispatch;
            }
            0x82A146DC => {
    //   block [0x82A146DC..0x82A14710)
	// 82A146DC: 93DFFFFC  stw r30, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[30].u32 ) };
	// 82A146E0: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A146E4: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82A146E8: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82A146EC: 4080FFA8  bge 0x82a14694
	if !ctx.cr[0].lt {
	pc = 0x82A14694; continue 'dispatch;
	}
	// 82A146F0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A146F4: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82A146F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A146FC: 419A011C  beq cr6, 0x82a14818
	if ctx.cr[6].eq {
	pc = 0x82A14818; continue 'dispatch;
	}
	// 82A14700: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A14704: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 82A14708: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82A1470C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	pc = 0x82A14710; continue 'dispatch;
            }
            0x82A14710 => {
    //   block [0x82A14710..0x82A14724)
	// 82A14710: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14714: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14718: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A1471C: 409A0008  bne cr6, 0x82a14724
	if !ctx.cr[6].eq {
	pc = 0x82A14724; continue 'dispatch;
	}
	// 82A14720: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A14724; continue 'dispatch;
            }
            0x82A14724 => {
    //   block [0x82A14724..0x82A1476C)
	// 82A14724: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A14728: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A1472C: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14730: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A14734: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A14738: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A1473C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A14740: E8C10070  ld r6, 0x70(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A14744: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14748: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82A1474C: E8E10068  ld r7, 0x68(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A14750: 90810064  stw r4, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[4].u32 ) };
	// 82A14754: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A14758: 480005A1  bl 0x82a14cf8
	ctx.lr = 0x82A1475C;
	sub_82A14CF8(ctx, base);
	// 82A1475C: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82A14760: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A14764: 419A0068  beq cr6, 0x82a147cc
	if ctx.cr[6].eq {
	pc = 0x82A147CC; continue 'dispatch;
	}
	// 82A14768: 3BE10088  addi r31, r1, 0x88
	ctx.r[31].s64 = ctx.r[1].s64 + 136;
	pc = 0x82A1476C; continue 'dispatch;
            }
            0x82A1476C => {
    //   block [0x82A1476C..0x82A147B4)
	// 82A1476C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A14774: 419A0040  beq cr6, 0x82a147b4
	if ctx.cr[6].eq {
	pc = 0x82A147B4; continue 'dispatch;
	}
	// 82A14778: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1477C: 387FFFF8  addi r3, r31, -8
	ctx.r[3].s64 = ctx.r[31].s64 + -8;
	// 82A14780: 48000409  bl 0x82a14b88
	ctx.lr = 0x82A14784;
	sub_82A14B88(ctx, base);
	// 82A14784: 817FFFFC  lwz r11, -4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82A14788: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A1478C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82A14790: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A14794: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A14798: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A1479C: 915FFFFC  stw r10, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	// 82A147A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A147A4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A147A8: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82A147AC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A147B0: 4198FFBC  blt cr6, 0x82a1476c
	if ctx.cr[6].lt {
	pc = 0x82A1476C; continue 'dispatch;
	}
	pc = 0x82A147B4; continue 'dispatch;
            }
            0x82A147B4 => {
    //   block [0x82A147B4..0x82A147CC)
	// 82A147B4: 2B1E0019  cmplwi cr6, r30, 0x19
	ctx.cr[6].compare_u32(ctx.r[30].u32, 25 as u32, &mut ctx.xer);
	// 82A147B8: 409A0014  bne cr6, 0x82a147cc
	if !ctx.cr[6].eq {
	pc = 0x82A147CC; continue 'dispatch;
	}
	// 82A147BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A147C0: 386101A0  addi r3, r1, 0x1a0
	ctx.r[3].s64 = ctx.r[1].s64 + 416;
	// 82A147C4: 480003C5  bl 0x82a14b88
	ctx.lr = 0x82A147C8;
	sub_82A14B88(ctx, base);
	// 82A147C8: 48000044  b 0x82a1480c
	pc = 0x82A1480C; continue 'dispatch;
            }
            0x82A147CC => {
    //   block [0x82A147CC..0x82A1480C)
	// 82A147CC: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A147D0: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A147D4: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82A147D8: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A147DC: 7CFE5A14  add r7, r30, r11
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82A147E0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A147E4: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A147E8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A147EC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A147F0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A147F4: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A147F8: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A147FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A14800: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 82A14804: 409A0008  bne cr6, 0x82a1480c
	if !ctx.cr[6].eq {
	pc = 0x82A1480C; continue 'dispatch;
	}
	// 82A14808: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	pc = 0x82A1480C; continue 'dispatch;
            }
            0x82A1480C => {
    //   block [0x82A1480C..0x82A14818)
	// 82A1480C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A14810: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A14814: 409AFEFC  bne cr6, 0x82a14710
	if !ctx.cr[6].eq {
	pc = 0x82A14710; continue 'dispatch;
	}
	pc = 0x82A14818; continue 'dispatch;
            }
            0x82A14818 => {
    //   block [0x82A14818..0x82A14828)
	// 82A14818: 2B1D0001  cmplwi cr6, r29, 1
	ctx.cr[6].compare_u32(ctx.r[29].u32, 1 as u32, &mut ctx.xer);
	// 82A1481C: 40990024  ble cr6, 0x82a14840
	if !ctx.cr[6].gt {
	pc = 0x82A14840; continue 'dispatch;
	}
	// 82A14820: 3BE1008C  addi r31, r1, 0x8c
	ctx.r[31].s64 = ctx.r[1].s64 + 140;
	// 82A14824: 3BDDFFFF  addi r30, r29, -1
	ctx.r[30].s64 = ctx.r[29].s64 + -1;
	pc = 0x82A14828; continue 'dispatch;
            }
            0x82A14828 => {
    //   block [0x82A14828..0x82A14840)
	// 82A14828: 389FFFF4  addi r4, r31, -0xc
	ctx.r[4].s64 = ctx.r[31].s64 + -12;
	// 82A1482C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A14830: 48000359  bl 0x82a14b88
	ctx.lr = 0x82A14834;
	sub_82A14B88(ctx, base);
	// 82A14834: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A14838: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82A1483C: 4082FFEC  bne 0x82a14828
	if !ctx.cr[0].eq {
	pc = 0x82A14828; continue 'dispatch;
	}
	pc = 0x82A14840; continue 'dispatch;
            }
            0x82A14840 => {
    //   block [0x82A14840..0x82A148AC)
	// 82A14840: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A14844: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14848: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 82A1484C: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 82A14850: 7D1D5A14  add r8, r29, r11
	ctx.r[8].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82A14854: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A14858: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1485C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A14860: 38ABFFF4  addi r5, r11, -0xc
	ctx.r[5].s64 = ctx.r[11].s64 + -12;
	// 82A14864: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82A14868: 7F1B2840  cmplw cr6, r27, r5
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A1486C: 419A0040  beq cr6, 0x82a148ac
	if ctx.cr[6].eq {
	pc = 0x82A148AC; continue 'dispatch;
	}
	// 82A14870: 81050008  lwz r8, 8(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A14874: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A14878: 419A0034  beq cr6, 0x82a148ac
	if ctx.cr[6].eq {
	pc = 0x82A148AC; continue 'dispatch;
	}
	// 82A1487C: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14880: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A14884: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A14888: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A1488C: 90A10068  stw r5, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[5].u32 ) };
	// 82A14890: 90A10060  stw r5, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u32 ) };
	// 82A14894: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14898: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A1489C: E8E10068  ld r7, 0x68(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A148A0: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A148A4: E8C10060  ld r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A148A8: 48000451  bl 0x82a14cf8
	ctx.lr = 0x82A148AC;
	sub_82A14CF8(ctx, base);
	pc = 0x82A148AC; continue 'dispatch;
            }
            0x82A148AC => {
    //   block [0x82A148AC..0x82A148B4)
	// 82A148AC: 3BC00019  li r30, 0x19
	ctx.r[30].s64 = 25;
	// 82A148B0: 3BE101BC  addi r31, r1, 0x1bc
	ctx.r[31].s64 = ctx.r[1].s64 + 444;
	pc = 0x82A148B4; continue 'dispatch;
            }
            0x82A148B4 => {
    //   block [0x82A148B4..0x82A148E4)
	// 82A148B4: 3BFFFFF4  addi r31, r31, -0xc
	ctx.r[31].s64 = ctx.r[31].s64 + -12;
	// 82A148B8: 387FFFFC  addi r3, r31, -4
	ctx.r[3].s64 = ctx.r[31].s64 + -4;
	// 82A148BC: 480004D5  bl 0x82a14d90
	ctx.lr = 0x82A148C0;
	sub_82A14D90(ctx, base);
	// 82A148C0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A148C4: 4B807475  bl 0x8221bd38
	ctx.lr = 0x82A148C8;
	sub_8221BD38(ctx, base);
	// 82A148C8: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A148CC: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82A148D0: 4080FFE4  bge 0x82a148b4
	if !ctx.cr[0].lt {
	pc = 0x82A148B4; continue 'dispatch;
	}
	// 82A148D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A148D8: 480004B9  bl 0x82a14d90
	ctx.lr = 0x82A148DC;
	sub_82A14D90(ctx, base);
	// 82A148DC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A148E0: 4B807459  bl 0x8221bd38
	ctx.lr = 0x82A148E4;
	sub_8221BD38(ctx, base);
	pc = 0x82A148E4; continue 'dispatch;
            }
            0x82A148E4 => {
    //   block [0x82A148E4..0x82A148EC)
	// 82A148E4: 38210200  addi r1, r1, 0x200
	ctx.r[1].s64 = ctx.r[1].s64 + 512;
	// 82A148E8: 48294B68  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A148F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A148F0 size=368
    let mut pc: u32 = 0x82A148F0;
    'dispatch: loop {
        match pc {
            0x82A148F0 => {
    //   block [0x82A148F0..0x82A14948)
	// 82A148F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A148F4: 48294B0D  bl 0x82ca9400
	ctx.lr = 0x82A148F8;
	sub_82CA93D0(ctx, base);
	// 82A148F8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A148FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A14900: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A14904: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A14908: 419A0150  beq cr6, 0x82a14a58
	if ctx.cr[6].eq {
	pc = 0x82A14A58; continue 'dispatch;
	}
	// 82A1490C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14910: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A14914: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14918: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 82A1491C: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 82A14920: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 82A14924: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82A14928: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 82A1492C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14930: 838A0000  lwz r28, 0(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14934: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82A14938: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82A1493C: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 82A14940: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A14944: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	pc = 0x82A14948; continue 'dispatch;
            }
            0x82A14948 => {
    //   block [0x82A14948..0x82A1494C)
	// 82A14948: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	pc = 0x82A1494C; continue 'dispatch;
            }
            0x82A1494C => {
    //   block [0x82A1494C..0x82A14964)
	// 82A1494C: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A14950: 419A00D0  beq cr6, 0x82a14a20
	if ctx.cr[6].eq {
	pc = 0x82A14A20; continue 'dispatch;
	}
	// 82A14954: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A14958: 419A000C  beq cr6, 0x82a14964
	if ctx.cr[6].eq {
	pc = 0x82A14964; continue 'dispatch;
	}
	// 82A1495C: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A14960: 419A0008  beq cr6, 0x82a14968
	if ctx.cr[6].eq {
	pc = 0x82A14968; continue 'dispatch;
	}
	pc = 0x82A14964; continue 'dispatch;
            }
            0x82A14964 => {
    //   block [0x82A14964..0x82A14968)
	// 82A14964: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A14968; continue 'dispatch;
            }
            0x82A14968 => {
    //   block [0x82A14968..0x82A14980)
	// 82A14968: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A1496C: 419A00B4  beq cr6, 0x82a14a20
	if ctx.cr[6].eq {
	pc = 0x82A14A20; continue 'dispatch;
	}
	// 82A14970: 811D0004  lwz r8, 4(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14974: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A14978: 409A0008  bne cr6, 0x82a14980
	if !ctx.cr[6].eq {
	pc = 0x82A14980; continue 'dispatch;
	}
	// 82A1497C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A14980; continue 'dispatch;
            }
            0x82A14980 => {
    //   block [0x82A14980..0x82A1498C)
	// 82A14980: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A14984: 409A0008  bne cr6, 0x82a1498c
	if !ctx.cr[6].eq {
	pc = 0x82A1498C; continue 'dispatch;
	}
	// 82A14988: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A1498C; continue 'dispatch;
            }
            0x82A1498C => {
    //   block [0x82A1498C..0x82A1499C)
	// 82A1498C: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14990: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A14994: 409A0008  bne cr6, 0x82a1499c
	if !ctx.cr[6].eq {
	pc = 0x82A1499C; continue 'dispatch;
	}
	// 82A14998: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A1499C; continue 'dispatch;
            }
            0x82A1499C => {
    //   block [0x82A1499C..0x82A149B4)
	// 82A1499C: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A149A0: 80BC0008  lwz r5, 8(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A149A4: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82A149A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A149AC: 41980008  blt cr6, 0x82a149b4
	if ctx.cr[6].lt {
	pc = 0x82A149B4; continue 'dispatch;
	}
	// 82A149B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A149B4; continue 'dispatch;
            }
            0x82A149B4 => {
    //   block [0x82A149B4..0x82A149D0)
	// 82A149B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A149B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A149BC: 419A0050  beq cr6, 0x82a14a0c
	if ctx.cr[6].eq {
	pc = 0x82A14A0C; continue 'dispatch;
	}
	// 82A149C0: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 82A149C4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A149C8: 409A0008  bne cr6, 0x82a149d0
	if !ctx.cr[6].eq {
	pc = 0x82A149D0; continue 'dispatch;
	}
	// 82A149CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A149D0; continue 'dispatch;
            }
            0x82A149D0 => {
    //   block [0x82A149D0..0x82A14A0C)
	// 82A149D0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A149D4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A149D8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A149DC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A149E0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A149E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A149E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A149EC: EBE10050  ld r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A149F0: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A149F4: 4800006D  bl 0x82a14a60
	ctx.lr = 0x82A149F8;
	sub_82A14A60(ctx, base);
	// 82A149F8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A149FC: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 82A14A00: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A14A04: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A14A08: 4BFFFF44  b 0x82a1494c
	pc = 0x82A1494C; continue 'dispatch;
            }
            0x82A14A0C => {
    //   block [0x82A14A0C..0x82A14A18)
	// 82A14A0C: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A14A10: 409A0008  bne cr6, 0x82a14a18
	if !ctx.cr[6].eq {
	pc = 0x82A14A18; continue 'dispatch;
	}
	// 82A14A14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A14A18; continue 'dispatch;
            }
            0x82A14A18 => {
    //   block [0x82A14A18..0x82A14A20)
	// 82A14A18: 839C0000  lwz r28, 0(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14A1C: 4BFFFF2C  b 0x82a14948
	pc = 0x82A14948; continue 'dispatch;
            }
            0x82A14A20 => {
    //   block [0x82A14A20..0x82A14A30)
	// 82A14A20: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A14A24: 419A000C  beq cr6, 0x82a14a30
	if ctx.cr[6].eq {
	pc = 0x82A14A30; continue 'dispatch;
	}
	// 82A14A28: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A14A2C: 419A0008  beq cr6, 0x82a14a34
	if ctx.cr[6].eq {
	pc = 0x82A14A34; continue 'dispatch;
	}
	pc = 0x82A14A30; continue 'dispatch;
            }
            0x82A14A30 => {
    //   block [0x82A14A30..0x82A14A34)
	// 82A14A30: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A14A34; continue 'dispatch;
            }
            0x82A14A34 => {
    //   block [0x82A14A34..0x82A14A58)
	// 82A14A34: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A14A38: 419A0020  beq cr6, 0x82a14a58
	if ctx.cr[6].eq {
	pc = 0x82A14A58; continue 'dispatch;
	}
	// 82A14A3C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A14A40: E8E10060  ld r7, 0x60(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A14A44: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A14A48: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A14A4C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A14A50: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A14A54: 4800000D  bl 0x82a14a60
	ctx.lr = 0x82A14A58;
	sub_82A14A60(ctx, base);
	pc = 0x82A14A58; continue 'dispatch;
            }
            0x82A14A58 => {
    //   block [0x82A14A58..0x82A14A60)
	// 82A14A58: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A14A5C: 482949F4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A14A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A14A60 size=152
    let mut pc: u32 = 0x82A14A60;
    'dispatch: loop {
        match pc {
            0x82A14A60 => {
    //   block [0x82A14A60..0x82A14AA4)
	// 82A14A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A14A64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A14A68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A14A6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A14A70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A14A74: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A14A78: F8810088  std r4, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[4].u64 ) };
	// 82A14A7C: F8C10098  std r6, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[6].u64 ) };
	// 82A14A80: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 82A14A84: F8E100A0  std r7, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[7].u64 ) };
	// 82A14A88: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A14A8C: 419A0018  beq cr6, 0x82a14aa4
	if ctx.cr[6].eq {
	pc = 0x82A14AA4; continue 'dispatch;
	}
	// 82A14A90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A14A94: 4B9C590D  bl 0x823da3a0
	ctx.lr = 0x82A14A98;
	sub_823DA3A0(ctx, base);
	// 82A14A98: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A14A9C: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82A14AA0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82A14AA4; continue 'dispatch;
            }
            0x82A14AA4 => {
    //   block [0x82A14AA4..0x82A14AF8)
	// 82A14AA4: 8121009C  lwz r9, 0x9c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A14AA8: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A14AAC: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A14AB0: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14AB4: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A14AB8: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14ABC: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A14AC0: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14AC4: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A14AC8: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14ACC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14AD0: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82A14AD4: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14AD8: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82A14ADC: 90A90004  stw r5, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82A14AE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A14AE4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A14AE8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A14AEC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A14AF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A14AF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A14AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A14AF8 size=144
    let mut pc: u32 = 0x82A14AF8;
    'dispatch: loop {
        match pc {
            0x82A14AF8 => {
    //   block [0x82A14AF8..0x82A14B30)
	// 82A14AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A14AFC: 48294905  bl 0x82ca9400
	ctx.lr = 0x82A14B00;
	sub_82CA93D0(ctx, base);
	// 82A14B00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A14B04: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82A14B08: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A14B0C: 838100AC  lwz r28, 0xac(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A14B10: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82A14B14: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A14B18: 837C0004  lwz r27, 4(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14B1C: 4B80A73D  bl 0x8221f258
	ctx.lr = 0x82A14B20;
	sub_8221F258(ctx, base);
	// 82A14B20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A14B24: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A14B28: 419A0008  beq cr6, 0x82a14b30
	if ctx.cr[6].eq {
	pc = 0x82A14B30; continue 'dispatch;
	}
	// 82A14B2C: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82A14B30; continue 'dispatch;
            }
            0x82A14B30 => {
    //   block [0x82A14B30..0x82A14B40)
	// 82A14B30: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82A14B34: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A14B38: 419A0008  beq cr6, 0x82a14b40
	if ctx.cr[6].eq {
	pc = 0x82A14B40; continue 'dispatch;
	}
	// 82A14B3C: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x82A14B40; continue 'dispatch;
            }
            0x82A14B40 => {
    //   block [0x82A14B40..0x82A14B68)
	// 82A14B40: 357F0010  addic. r11, r31, 0x10
	ctx.xer.ca = (ctx.r[31].u32 > (!(16 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A14B44: 41820024  beq 0x82a14b68
	if ctx.cr[0].eq {
	pc = 0x82A14B68; continue 'dispatch;
	}
	// 82A14B48: E95D0000  ld r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 82A14B4C: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82A14B50: E93D0008  ld r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 82A14B54: F92B0008  std r9, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 82A14B58: E91D0010  ld r8, 0x10(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) };
	// 82A14B5C: F90B0010  std r8, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[8].u64 ) };
	// 82A14B60: E8FD0018  ld r7, 0x18(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	// 82A14B64: F8EB0018  std r7, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[7].u64 ) };
	pc = 0x82A14B68; continue 'dispatch;
            }
            0x82A14B68 => {
    //   block [0x82A14B68..0x82A14B88)
	// 82A14B68: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A14B6C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A14B70: 48000291  bl 0x82a14e00
	ctx.lr = 0x82A14B74;
	sub_82A14E00(ctx, base);
	// 82A14B74: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A14B78: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14B7C: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A14B80: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A14B84: 482948CC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A14B88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A14B88 size=368
    let mut pc: u32 = 0x82A14B88;
    'dispatch: loop {
        match pc {
            0x82A14B88 => {
    //   block [0x82A14B88..0x82A14BE0)
	// 82A14B88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A14B8C: 48294875  bl 0x82ca9400
	ctx.lr = 0x82A14B90;
	sub_82CA93D0(ctx, base);
	// 82A14B90: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A14B94: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A14B98: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A14B9C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A14BA0: 419A0150  beq cr6, 0x82a14cf0
	if ctx.cr[6].eq {
	pc = 0x82A14CF0; continue 'dispatch;
	}
	// 82A14BA4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14BA8: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A14BAC: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14BB0: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 82A14BB4: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 82A14BB8: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 82A14BBC: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82A14BC0: 93410064  stw r26, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[26].u32 ) };
	// 82A14BC4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14BC8: 838A0000  lwz r28, 0(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14BCC: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82A14BD0: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82A14BD4: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 82A14BD8: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A14BDC: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	pc = 0x82A14BE0; continue 'dispatch;
            }
            0x82A14BE0 => {
    //   block [0x82A14BE0..0x82A14BE4)
	// 82A14BE0: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	pc = 0x82A14BE4; continue 'dispatch;
            }
            0x82A14BE4 => {
    //   block [0x82A14BE4..0x82A14BFC)
	// 82A14BE4: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A14BE8: 419A00D0  beq cr6, 0x82a14cb8
	if ctx.cr[6].eq {
	pc = 0x82A14CB8; continue 'dispatch;
	}
	// 82A14BEC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A14BF0: 419A000C  beq cr6, 0x82a14bfc
	if ctx.cr[6].eq {
	pc = 0x82A14BFC; continue 'dispatch;
	}
	// 82A14BF4: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A14BF8: 419A0008  beq cr6, 0x82a14c00
	if ctx.cr[6].eq {
	pc = 0x82A14C00; continue 'dispatch;
	}
	pc = 0x82A14BFC; continue 'dispatch;
            }
            0x82A14BFC => {
    //   block [0x82A14BFC..0x82A14C00)
	// 82A14BFC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A14C00; continue 'dispatch;
            }
            0x82A14C00 => {
    //   block [0x82A14C00..0x82A14C18)
	// 82A14C00: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A14C04: 419A00B4  beq cr6, 0x82a14cb8
	if ctx.cr[6].eq {
	pc = 0x82A14CB8; continue 'dispatch;
	}
	// 82A14C08: 811D0004  lwz r8, 4(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14C0C: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A14C10: 409A0008  bne cr6, 0x82a14c18
	if !ctx.cr[6].eq {
	pc = 0x82A14C18; continue 'dispatch;
	}
	// 82A14C14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A14C18; continue 'dispatch;
            }
            0x82A14C18 => {
    //   block [0x82A14C18..0x82A14C24)
	// 82A14C18: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A14C1C: 409A0008  bne cr6, 0x82a14c24
	if !ctx.cr[6].eq {
	pc = 0x82A14C24; continue 'dispatch;
	}
	// 82A14C20: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A14C24; continue 'dispatch;
            }
            0x82A14C24 => {
    //   block [0x82A14C24..0x82A14C34)
	// 82A14C24: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14C28: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A14C2C: 409A0008  bne cr6, 0x82a14c34
	if !ctx.cr[6].eq {
	pc = 0x82A14C34; continue 'dispatch;
	}
	// 82A14C30: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A14C34; continue 'dispatch;
            }
            0x82A14C34 => {
    //   block [0x82A14C34..0x82A14C4C)
	// 82A14C34: 81690010  lwz r11, 0x10(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A14C38: 80BC0010  lwz r5, 0x10(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A14C3C: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82A14C40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A14C44: 41980008  blt cr6, 0x82a14c4c
	if ctx.cr[6].lt {
	pc = 0x82A14C4C; continue 'dispatch;
	}
	// 82A14C48: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A14C4C; continue 'dispatch;
            }
            0x82A14C4C => {
    //   block [0x82A14C4C..0x82A14C68)
	// 82A14C4C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A14C50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A14C54: 419A0050  beq cr6, 0x82a14ca4
	if ctx.cr[6].eq {
	pc = 0x82A14CA4; continue 'dispatch;
	}
	// 82A14C58: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 82A14C5C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A14C60: 409A0008  bne cr6, 0x82a14c68
	if !ctx.cr[6].eq {
	pc = 0x82A14C68; continue 'dispatch;
	}
	// 82A14C64: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A14C68; continue 'dispatch;
            }
            0x82A14C68 => {
    //   block [0x82A14C68..0x82A14CA4)
	// 82A14C68: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14C6C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A14C70: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A14C74: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A14C78: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A14C7C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A14C80: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A14C84: EBE10050  ld r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A14C88: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82A14C8C: 4800006D  bl 0x82a14cf8
	ctx.lr = 0x82A14C90;
	sub_82A14CF8(ctx, base);
	// 82A14C90: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A14C94: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 82A14C98: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A14C9C: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A14CA0: 4BFFFF44  b 0x82a14be4
	pc = 0x82A14BE4; continue 'dispatch;
            }
            0x82A14CA4 => {
    //   block [0x82A14CA4..0x82A14CB0)
	// 82A14CA4: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A14CA8: 409A0008  bne cr6, 0x82a14cb0
	if !ctx.cr[6].eq {
	pc = 0x82A14CB0; continue 'dispatch;
	}
	// 82A14CAC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A14CB0; continue 'dispatch;
            }
            0x82A14CB0 => {
    //   block [0x82A14CB0..0x82A14CB8)
	// 82A14CB0: 839C0000  lwz r28, 0(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14CB4: 4BFFFF2C  b 0x82a14be0
	pc = 0x82A14BE0; continue 'dispatch;
            }
            0x82A14CB8 => {
    //   block [0x82A14CB8..0x82A14CC8)
	// 82A14CB8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A14CBC: 419A000C  beq cr6, 0x82a14cc8
	if ctx.cr[6].eq {
	pc = 0x82A14CC8; continue 'dispatch;
	}
	// 82A14CC0: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A14CC4: 419A0008  beq cr6, 0x82a14ccc
	if ctx.cr[6].eq {
	pc = 0x82A14CCC; continue 'dispatch;
	}
	pc = 0x82A14CC8; continue 'dispatch;
            }
            0x82A14CC8 => {
    //   block [0x82A14CC8..0x82A14CCC)
	// 82A14CC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A14CCC; continue 'dispatch;
            }
            0x82A14CCC => {
    //   block [0x82A14CCC..0x82A14CF0)
	// 82A14CCC: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A14CD0: 419A0020  beq cr6, 0x82a14cf0
	if ctx.cr[6].eq {
	pc = 0x82A14CF0; continue 'dispatch;
	}
	// 82A14CD4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A14CD8: E8E10060  ld r7, 0x60(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A14CDC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A14CE0: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A14CE4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A14CE8: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A14CEC: 4800000D  bl 0x82a14cf8
	ctx.lr = 0x82A14CF0;
	sub_82A14CF8(ctx, base);
	pc = 0x82A14CF0; continue 'dispatch;
            }
            0x82A14CF0 => {
    //   block [0x82A14CF0..0x82A14CF8)
	// 82A14CF0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A14CF4: 4829475C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A14CF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A14CF8 size=152
    let mut pc: u32 = 0x82A14CF8;
    'dispatch: loop {
        match pc {
            0x82A14CF8 => {
    //   block [0x82A14CF8..0x82A14D3C)
	// 82A14CF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A14CFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A14D00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A14D04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A14D08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A14D0C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A14D10: F8810088  std r4, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[4].u64 ) };
	// 82A14D14: F8C10098  std r6, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[6].u64 ) };
	// 82A14D18: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 82A14D1C: F8E100A0  std r7, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[7].u64 ) };
	// 82A14D20: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A14D24: 419A0018  beq cr6, 0x82a14d3c
	if ctx.cr[6].eq {
	pc = 0x82A14D3C; continue 'dispatch;
	}
	// 82A14D28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A14D2C: 480000D5  bl 0x82a14e00
	ctx.lr = 0x82A14D30;
	sub_82A14E00(ctx, base);
	// 82A14D30: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A14D34: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82A14D38: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82A14D3C; continue 'dispatch;
            }
            0x82A14D3C => {
    //   block [0x82A14D3C..0x82A14D90)
	// 82A14D3C: 8121009C  lwz r9, 0x9c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A14D40: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A14D44: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A14D48: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14D4C: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A14D50: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14D54: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A14D58: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14D5C: 91260000  stw r9, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A14D60: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14D64: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14D68: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82A14D6C: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14D70: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82A14D74: 90A90004  stw r5, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82A14D78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A14D7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A14D80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A14D84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A14D88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A14D8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A14D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A14D90 size=112
    let mut pc: u32 = 0x82A14D90;
    'dispatch: loop {
        match pc {
            0x82A14D90 => {
    //   block [0x82A14D90..0x82A14DD0)
	// 82A14D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A14D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A14D98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A14D9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A14DA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A14DA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A14DA8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A14DAC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14DB0: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14DB4: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A14DB8: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14DBC: 91290004  stw r9, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A14DC0: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14DC4: 7F034040  cmplw cr6, r3, r8
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A14DC8: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A14DCC: 419A001C  beq cr6, 0x82a14de8
	if ctx.cr[6].eq {
	pc = 0x82A14DE8; continue 'dispatch;
	}
	pc = 0x82A14DD0; continue 'dispatch;
            }
            0x82A14DD0 => {
    //   block [0x82A14DD0..0x82A14DE8)
	// 82A14DD0: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14DD4: 4B806F65  bl 0x8221bd38
	ctx.lr = 0x82A14DD8;
	sub_8221BD38(ctx, base);
	// 82A14DD8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A14DE0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A14DE4: 409AFFEC  bne cr6, 0x82a14dd0
	if !ctx.cr[6].eq {
	pc = 0x82A14DD0; continue 'dispatch;
	}
	pc = 0x82A14DE8; continue 'dispatch;
            }
            0x82A14DE8 => {
    //   block [0x82A14DE8..0x82A14E00)
	// 82A14DE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A14DEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A14DF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A14DF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A14DF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A14DFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A14E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A14E00 size=132
    let mut pc: u32 = 0x82A14E00;
    'dispatch: loop {
        match pc {
            0x82A14E00 => {
    //   block [0x82A14E00..0x82A14E70)
	// 82A14E00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A14E04: 48294609  bl 0x82ca940c
	ctx.lr = 0x82A14E08;
	sub_82CA93D0(ctx, base);
	// 82A14E08: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A14E0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A14E10: 3D6007FF  lis r11, 0x7ff
	ctx.r[11].s64 = 134152192;
	// 82A14E14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A14E18: 6169FFFF  ori r9, r11, 0xffff
	ctx.r[9].u64 = ctx.r[11].u64 | 65535;
	// 82A14E1C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A14E20: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82A14E24: 7F08F040  cmplw cr6, r8, r30
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A14E28: 40980048  bge cr6, 0x82a14e70
	if !ctx.cr[6].lt {
	pc = 0x82A14E70; continue 'dispatch;
	}
	// 82A14E2C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A14E30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A14E34: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 82A14E38: 4B8DD109  bl 0x822f1f40
	ctx.lr = 0x82A14E3C;
	sub_822F1F40(ctx, base);
	// 82A14E3C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A14E40: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A14E44: 4B8DCF6D  bl 0x822f1db0
	ctx.lr = 0x82A14E48;
	sub_822F1DB0(ctx, base);
	// 82A14E48: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A14E4C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A14E50: 3BAA1720  addi r29, r10, 0x1720
	ctx.r[29].s64 = ctx.r[10].s64 + 5920;
	// 82A14E54: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82A14E58: 4B8DCFC9  bl 0x822f1e20
	ctx.lr = 0x82A14E5C;
	sub_822F1E20(ctx, base);
	// 82A14E5C: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82A14E60: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A14E64: 4BC6697D  bl 0x8267b7e0
	ctx.lr = 0x82A14E68;
	sub_8267B7E0(ctx, base);
	// 82A14E68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A14E6C: 4B75C9A5  bl 0x82171810
	ctx.lr = 0x82A14E70;
	sub_82171810(ctx, base);
	pc = 0x82A14E70; continue 'dispatch;
            }
            0x82A14E70 => {
    //   block [0x82A14E70..0x82A14E84)
	// 82A14E70: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A14E74: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A14E78: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A14E7C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A14E80: 482945DC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A14E88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A14E88 size=328
    let mut pc: u32 = 0x82A14E88;
    'dispatch: loop {
        match pc {
            0x82A14E88 => {
    //   block [0x82A14E88..0x82A14ED8)
	// 82A14E88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A14E8C: 4829457D  bl 0x82ca9408
	ctx.lr = 0x82A14E90;
	sub_82CA93D0(ctx, base);
	// 82A14E90: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82A14E94: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A14E98: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A14E9C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A14EA0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A14EA4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A14EA8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A14EAC: 4199002C  bgt cr6, 0x82a14ed8
	if ctx.cr[6].gt {
	pc = 0x82A14ED8; continue 'dispatch;
	}
	// 82A14EB0: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14EB4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A14EB8: 419A0108  beq cr6, 0x82a14fc0
	if ctx.cr[6].eq {
	pc = 0x82A14FC0; continue 'dispatch;
	}
	// 82A14EBC: 4B806E7D  bl 0x8221bd38
	ctx.lr = 0x82A14EC0;
	sub_8221BD38(ctx, base);
	// 82A14EC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A14EC4: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A14EC8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A14ECC: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A14ED0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A14ED4: 48294584  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A14ED8 => {
    //   block [0x82A14ED8..0x82A14EF0)
	// 82A14ED8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14EDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A14EE0: 409A0010  bne cr6, 0x82a14ef0
	if !ctx.cr[6].eq {
	pc = 0x82A14EF0; continue 'dispatch;
	}
	// 82A14EE4: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82A14EE8: 4B80A371  bl 0x8221f258
	ctx.lr = 0x82A14EEC;
	sub_8221F258(ctx, base);
	// 82A14EEC: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82A14EF0; continue 'dispatch;
            }
            0x82A14EF0 => {
    //   block [0x82A14EF0..0x82A14F08)
	// 82A14EF0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14EF4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A14EF8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A14EFC: 409A000C  bne cr6, 0x82a14f08
	if !ctx.cr[6].eq {
	pc = 0x82A14F08; continue 'dispatch;
	}
	// 82A14F00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82A14F04: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A14F08; continue 'dispatch;
            }
            0x82A14F08 => {
    //   block [0x82A14F08..0x82A14F1C)
	// 82A14F08: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14F0C: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A14F10: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A14F14: 409A0008  bne cr6, 0x82a14f1c
	if !ctx.cr[6].eq {
	pc = 0x82A14F1C; continue 'dispatch;
	}
	// 82A14F18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A14F1C; continue 'dispatch;
            }
            0x82A14F1C => {
    //   block [0x82A14F1C..0x82A14F4C)
	// 82A14F1C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A14F20: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82A14F24: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A14F28: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A14F2C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A14F30: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 82A14F34: C00A0ED8  lfs f0, 0xed8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3800 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A14F38: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82A14F3C: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A14F40: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A14F44: FFE06018  frsp f31, f12
	ctx.f[31].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A14F48: EFDF0032  fmuls f30, f31, f0
	ctx.f[30].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82A14F4C; continue 'dispatch;
            }
            0x82A14F4C => {
    //   block [0x82A14F4C..0x82A14FB0)
	// 82A14F4C: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 82A14F50: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A14F54: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82A14F58: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A14F5C: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82A14F60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A14F64: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A14F68: ED6C07B2  fmuls f11, f12, f30
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 82A14F6C: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A14F70: D9410058  stfd f10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[10].u64 ) };
	// 82A14F74: 80A1005C  lwz r5, 0x5c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A14F78: 480003D9  bl 0x82a15350
	ctx.lr = 0x82A14F7C;
	sub_82A15350(ctx, base);
	// 82A14F7C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14F80: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82A14F84: 7C3F552E  stfsx f1, r31, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82A14F88: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82A14F8C: 2F1F0028  cmpwi cr6, r31, 0x28
	ctx.cr[6].compare_i32(ctx.r[31].s32, 40, &mut ctx.xer);
	// 82A14F90: 4198FFBC  blt cr6, 0x82a14f4c
	if ctx.cr[6].lt {
	pc = 0x82A14F4C; continue 'dispatch;
	}
	// 82A14F94: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A14F98: 396B9490  addi r11, r11, -0x6b70
	ctx.r[11].s64 = ctx.r[11].s64 + -27504;
	// 82A14F9C: C00BFFF4  lfs f0, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A14FA0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82A14FA4: 4099000C  ble cr6, 0x82a14fb0
	if !ctx.cr[6].gt {
	pc = 0x82A14FB0; continue 'dispatch;
	}
	// 82A14FA8: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A14FAC: EC00F824  fdivs f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	pc = 0x82A14FB0; continue 'dispatch;
            }
            0x82A14FB0 => {
    //   block [0x82A14FB0..0x82A14FC0)
	// 82A14FB0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A14FB4: C1AB0A54  lfs f13, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A14FB8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A14FBC: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x82A14FC0; continue 'dispatch;
            }
            0x82A14FC0 => {
    //   block [0x82A14FC0..0x82A14FD0)
	// 82A14FC0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A14FC4: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A14FC8: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A14FCC: 4829448C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A14FD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A14FD0 size=336
    let mut pc: u32 = 0x82A14FD0;
    'dispatch: loop {
        match pc {
            0x82A14FD0 => {
    //   block [0x82A14FD0..0x82A15020)
	// 82A14FD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A14FD4: 48294435  bl 0x82ca9408
	ctx.lr = 0x82A14FD8;
	sub_82CA93D0(ctx, base);
	// 82A14FD8: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82A14FDC: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A14FE0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A14FE4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A14FE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A14FEC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A14FF0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A14FF4: 4199002C  bgt cr6, 0x82a15020
	if ctx.cr[6].gt {
	pc = 0x82A15020; continue 'dispatch;
	}
	// 82A14FF8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A14FFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A15000: 419A0110  beq cr6, 0x82a15110
	if ctx.cr[6].eq {
	pc = 0x82A15110; continue 'dispatch;
	}
	// 82A15004: 4B806D35  bl 0x8221bd38
	ctx.lr = 0x82A15008;
	sub_8221BD38(ctx, base);
	// 82A15008: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1500C: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A15010: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A15014: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A15018: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A1501C: 4829443C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A15020 => {
    //   block [0x82A15020..0x82A15038)
	// 82A15020: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A15024: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A15028: 409A0010  bne cr6, 0x82a15038
	if !ctx.cr[6].eq {
	pc = 0x82A15038; continue 'dispatch;
	}
	// 82A1502C: 386000A0  li r3, 0xa0
	ctx.r[3].s64 = 160;
	// 82A15030: 4B80A229  bl 0x8221f258
	ctx.lr = 0x82A15034;
	sub_8221F258(ctx, base);
	// 82A15034: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82A15038; continue 'dispatch;
            }
            0x82A15038 => {
    //   block [0x82A15038..0x82A15050)
	// 82A15038: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1503C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15040: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A15044: 409A000C  bne cr6, 0x82a15050
	if !ctx.cr[6].eq {
	pc = 0x82A15050; continue 'dispatch;
	}
	// 82A15048: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82A1504C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A15050; continue 'dispatch;
            }
            0x82A15050 => {
    //   block [0x82A15050..0x82A15064)
	// 82A15050: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A15054: 81290010  lwz r9, 0x10(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15058: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A1505C: 409A0008  bne cr6, 0x82a15064
	if !ctx.cr[6].eq {
	pc = 0x82A15064; continue 'dispatch;
	}
	// 82A15060: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A15064; continue 'dispatch;
            }
            0x82A15064 => {
    //   block [0x82A15064..0x82A15110)
	// 82A15064: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15068: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82A1506C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A15070: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A15074: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A15078: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 82A1507C: C00A0ED8  lfs f0, 0xed8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3800 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A15080: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82A15084: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A15088: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A1508C: FFE06018  frsp f31, f12
	ctx.f[31].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A15090: EFDF0032  fmuls f30, f31, f0
	ctx.f[30].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A15094: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 82A15098: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A1509C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82A150A0: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A150A4: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82A150A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A150AC: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A150B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A150B4: ED6C07B2  fmuls f11, f12, f30
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 82A150B8: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A150BC: D9410058  stfd f10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[10].u64 ) };
	// 82A150C0: 80C1005C  lwz r6, 0x5c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A150C4: 480003B5  bl 0x82a15478
	ctx.lr = 0x82A150C8;
	sub_82A15478(ctx, base);
	// 82A150C8: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A15110; continue 'dispatch;
            }
            0x82A15110 => {
    //   block [0x82A15110..0x82A15120)
	// 82A15110: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A15114: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A15118: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A1511C: 4829433C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A15120(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A15120 size=272
    let mut pc: u32 = 0x82A15120;
    'dispatch: loop {
        match pc {
            0x82A15120 => {
    //   block [0x82A15120..0x82A15214)
	// 82A15120: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A15124: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A15128: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1512C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A15130: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A15134: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A15138: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1513C: C01E000C  lfs f0, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A15140: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A15144: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A15148: D1BF0004  stfs f13, 4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A1514C: C19E0008  lfs f12, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A15150: D19F0008  stfs f12, 8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A15154: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A15158: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1515C: 419A00B8  beq cr6, 0x82a15214
	if ctx.cr[6].eq {
	pc = 0x82A15214; continue 'dispatch;
	}
	// 82A15160: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82A15164: 4B80A0F5  bl 0x8221f258
	ctx.lr = 0x82A15168;
	sub_8221F258(ctx, base);
	// 82A15168: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A1516C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A15170: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A15174: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A15178: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1517C: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A15180: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A15184: C1A90004  lfs f13, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A15188: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1518C: D1A80004  stfs f13, 4(r8)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A15190: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A15194: C1870008  lfs f12, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A15198: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1519C: D1860008  stfs f12, 8(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A151A0: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A151A4: C165000C  lfs f11, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A151A8: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A151AC: D164000C  stfs f11, 0xc(r4)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A151B0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A151B4: C14B0010  lfs f10, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82A151B8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A151BC: D14A0010  stfs f10, 0x10(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82A151C0: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A151C4: C1290014  lfs f9, 0x14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82A151C8: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A151CC: D1280014  stfs f9, 0x14(r8)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82A151D0: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A151D4: C1070018  lfs f8, 0x18(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82A151D8: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A151DC: D1060018  stfs f8, 0x18(r6)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82A151E0: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A151E4: C0E5001C  lfs f7, 0x1c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82A151E8: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A151EC: D0E4001C  stfs f7, 0x1c(r4)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82A151F0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A151F4: C0CB0020  lfs f6, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82A151F8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A151FC: D0CA0020  stfs f6, 0x20(r10)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82A15200: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A15204: C0A90024  lfs f5, 0x24(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(36 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82A15208: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1520C: D0A80024  stfs f5, 0x24(r8)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82A15210: 48000008  b 0x82a15218
	pc = 0x82A15218; continue 'dispatch;
            }
            0x82A15214 => {
    //   block [0x82A15214..0x82A15218)
	// 82A15214: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A15218; continue 'dispatch;
            }
            0x82A15218 => {
    //   block [0x82A15218..0x82A15230)
	// 82A15218: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1521C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A15220: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A15224: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A15228: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1522C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A15230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A15230 size=288
    let mut pc: u32 = 0x82A15230;
    'dispatch: loop {
        match pc {
            0x82A15230 => {
    //   block [0x82A15230..0x82A15350)
	// 82A15230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A15234: 482941D1  bl 0x82ca9404
	ctx.lr = 0x82A15238;
	sub_82CA93D0(ctx, base);
	// 82A15238: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1523C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A15240: 3BA00010  li r29, 0x10
	ctx.r[29].s64 = 16;
	// 82A15244: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A15350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A15350 size=204
    let mut pc: u32 = 0x82A15350;
    'dispatch: loop {
        match pc {
            0x82A15350 => {
    //   block [0x82A15350..0x82A15384)
	// 82A15350: 80E40004  lwz r7, 4(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15354: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A15358: 9081FFE0  stw r4, -0x20(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u32 ) };
	// 82A1535C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A15360: 9141FFF0  stw r10, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u32 ) };
	// 82A15364: 90E1FFE4  stw r7, -0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), ctx.r[7].u32 ) };
	// 82A15368: E8C1FFE0  ld r6, -0x20(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A1536C: F8C1FFE4  std r6, -0x1c(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), ctx.r[6].u64 ) };
	// 82A15370: 8121FFE4  lwz r9, -0x1c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-28 as u32) ) } as u64;
	// 82A15374: 8161FFE8  lwz r11, -0x18(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) } as u64;
	// 82A15378: 80E70000  lwz r7, 0(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1537C: 9121FFF4  stw r9, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[9].u32 ) };
	// 82A15380: 9161FFF8  stw r11, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	pc = 0x82A15384; continue 'dispatch;
            }
            0x82A15384 => {
    //   block [0x82A15384..0x82A15394)
	// 82A15384: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A15388: 419A000C  beq cr6, 0x82a15394
	if ctx.cr[6].eq {
	pc = 0x82A15394; continue 'dispatch;
	}
	// 82A1538C: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A15390: 419A0008  beq cr6, 0x82a15398
	if ctx.cr[6].eq {
	pc = 0x82A15398; continue 'dispatch;
	}
	pc = 0x82A15394; continue 'dispatch;
            }
            0x82A15394 => {
    //   block [0x82A15394..0x82A15398)
	// 82A15394: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A15398; continue 'dispatch;
            }
            0x82A15398 => {
    //   block [0x82A15398..0x82A153B4)
	// 82A15398: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A1539C: 419A00D0  beq cr6, 0x82a1546c
	if ctx.cr[6].eq {
		sub_82A1546C(ctx, base);
		return;
	}
	// 82A153A0: E941FFF4  ld r10, -0xc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) };
	// 82A153A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A153A8: F941FFE0  std r10, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[10].u64 ) };
	// 82A153AC: 409A0008  bne cr6, 0x82a153b4
	if !ctx.cr[6].eq {
	pc = 0x82A153B4; continue 'dispatch;
	}
	// 82A153B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A153B4; continue 'dispatch;
            }
            0x82A153B4 => {
    //   block [0x82A153B4..0x82A153D0)
	// 82A153B4: 80C1FFE0  lwz r6, -0x20(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) } as u64;
	// 82A153B8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A153BC: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A153C0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A153C4: 409A000C  bne cr6, 0x82a153d0
	if !ctx.cr[6].eq {
	pc = 0x82A153D0; continue 'dispatch;
	}
	// 82A153C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82A153CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A153D0; continue 'dispatch;
            }
            0x82A153D0 => {
    //   block [0x82A153D0..0x82A153F0)
	// 82A153D0: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A153D4: 396A0008  addi r11, r10, 8
	ctx.r[11].s64 = ctx.r[10].s64 + 8;
	// 82A153D8: 7F053000  cmpw cr6, r5, r6
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82A153DC: 40980030  bge cr6, 0x82a1540c
	if !ctx.cr[6].lt {
	pc = 0x82A1540C; continue 'dispatch;
	}
	// 82A153E0: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82A153E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A153E8: 409A0008  bne cr6, 0x82a153f0
	if !ctx.cr[6].eq {
	pc = 0x82A153F0; continue 'dispatch;
	}
	// 82A153EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A153F0; continue 'dispatch;
            }
            0x82A153F0 => {
    //   block [0x82A153F0..0x82A1540C)
	// 82A153F0: 80C90004  lwz r6, 4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A153F4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A153F8: 9161FFF8  stw r11, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	// 82A153FC: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A15400: 409AFF84  bne cr6, 0x82a15384
	if !ctx.cr[6].eq {
	pc = 0x82A15384; continue 'dispatch;
	}
	// 82A15404: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82A15408: 4BFFFF7C  b 0x82a15384
	pc = 0x82A15384; continue 'dispatch;
            }
            0x82A1540C => {
    //   block [0x82A1540C..0x82A1541C)
	// 82A1540C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A15410: 409A000C  bne cr6, 0x82a1541c
	if !ctx.cr[6].eq {
		sub_82A1541C(ctx, base);
		return;
	}
	// 82A15414: C02B0004  lfs f1, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A15418: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1541C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A1541C size=80
    let mut pc: u32 = 0x82A1541C;
    'dispatch: loop {
        match pc {
            0x82A1541C => {
    //   block [0x82A1541C..0x82A1546C)
	// 82A1541C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A15420: C1A80004  lfs f13, 4(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A15424: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A15428: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1542C: 7D0A2850  subf r8, r10, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82A15430: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82A15434: 7CEA4850  subf r7, r10, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82A15438: 7D0607B4  extsw r6, r8
	ctx.r[6].s64 = ctx.r[8].s32 as i64;
	// 82A1543C: 7CE507B4  extsw r5, r7
	ctx.r[5].s64 = ctx.r[7].s32 as i64;
	// 82A15440: F8C1FFE0  std r6, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[6].u64 ) };
	// 82A15444: C961FFE0  lfd f11, -0x20(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A15448: F8A1FFE0  std r5, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[5].u64 ) };
	// 82A1544C: C941FFE0  lfd f10, -0x20(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A15450: FD205E9C  fcfid f9, f11
	ctx.f[9].f64 = (ctx.f[11].s64 as f64);
	// 82A15454: FD00569C  fcfid f8, f10
	ctx.f[8].f64 = (ctx.f[10].s64 as f64);
	// 82A15458: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82A1545C: FCC04018  frsp f6, f8
	ctx.f[6].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A15460: ECA73024  fdivs f5, f7, f6
	ctx.f[5].f64 = ((ctx.f[7].f64 / ctx.f[6].f64) as f32) as f64;
	// 82A15464: EC25033A  fmadds f1, f5, f12, f0
	ctx.f[1].f64 = (((ctx.f[5].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82A15468: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1546C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A1546C size=8
    let mut pc: u32 = 0x82A1546C;
    'dispatch: loop {
        match pc {
            0x82A1546C => {
    //   block [0x82A1546C..0x82A15474)
	// 82A1546C: C023000C  lfs f1, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82A15470: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A15478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A15478 size=328
    let mut pc: u32 = 0x82A15478;
    'dispatch: loop {
        match pc {
            0x82A15478 => {
    //   block [0x82A15478..0x82A154B0)
	// 82A15478: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82A1547C: 80E50004  lwz r7, 4(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15480: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A15484: 90A1FFD0  stw r5, -0x30(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[5].u32 ) };
	// 82A15488: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1548C: 9141FFE0  stw r10, -0x20(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[10].u32 ) };
	// 82A15490: 90E1FFD4  stw r7, -0x2c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-44 as u32), ctx.r[7].u32 ) };
	// 82A15494: E961FFD0  ld r11, -0x30(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A15498: F961FFD4  std r11, -0x2c(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-44 as u32), ctx.r[11].u64 ) };
	// 82A1549C: 8121FFD4  lwz r9, -0x2c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-44 as u32) ) } as u64;
	// 82A154A0: 8161FFD8  lwz r11, -0x28(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) } as u64;
	// 82A154A4: 80E70000  lwz r7, 0(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A154A8: 9121FFE4  stw r9, -0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), ctx.r[9].u32 ) };
	// 82A154AC: 9161FFE8  stw r11, -0x18(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[11].u32 ) };
	pc = 0x82A154B0; continue 'dispatch;
            }
            0x82A154B0 => {
    //   block [0x82A154B0..0x82A154C0)
	// 82A154B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A154B4: 419A000C  beq cr6, 0x82a154c0
	if ctx.cr[6].eq {
	pc = 0x82A154C0; continue 'dispatch;
	}
	// 82A154B8: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A154BC: 419A0008  beq cr6, 0x82a154c4
	if ctx.cr[6].eq {
	pc = 0x82A154C4; continue 'dispatch;
	}
	pc = 0x82A154C0; continue 'dispatch;
            }
            0x82A154C0 => {
    //   block [0x82A154C0..0x82A154C4)
	// 82A154C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A154C4; continue 'dispatch;
            }
            0x82A154C4 => {
    //   block [0x82A154C4..0x82A154E0)
	// 82A154C4: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A154C8: 419A00E4  beq cr6, 0x82a155ac
	if ctx.cr[6].eq {
	pc = 0x82A155AC; continue 'dispatch;
	}
	// 82A154CC: E941FFE4  ld r10, -0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-28 as u32) ) };
	// 82A154D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A154D4: F941FFD0  std r10, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[10].u64 ) };
	// 82A154D8: 409A0008  bne cr6, 0x82a154e0
	if !ctx.cr[6].eq {
	pc = 0x82A154E0; continue 'dispatch;
	}
	// 82A154DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A154E0; continue 'dispatch;
            }
            0x82A154E0 => {
    //   block [0x82A154E0..0x82A154FC)
	// 82A154E0: 83E1FFD0  lwz r31, -0x30(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) } as u64;
	// 82A154E4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A154E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A154EC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A154F0: 409A000C  bne cr6, 0x82a154fc
	if !ctx.cr[6].eq {
	pc = 0x82A154FC; continue 'dispatch;
	}
	// 82A154F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82A154F8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A154FC; continue 'dispatch;
            }
            0x82A154FC => {
    //   block [0x82A154FC..0x82A1551C)
	// 82A154FC: 83EA0010  lwz r31, 0x10(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15500: 396A0010  addi r11, r10, 0x10
	ctx.r[11].s64 = ctx.r[10].s64 + 16;
	// 82A15504: 7F06F800  cmpw cr6, r6, r31
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82A15508: 40980030  bge cr6, 0x82a15538
	if !ctx.cr[6].lt {
	pc = 0x82A15538; continue 'dispatch;
	}
	// 82A1550C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82A15510: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A15514: 409A0008  bne cr6, 0x82a1551c
	if !ctx.cr[6].eq {
	pc = 0x82A1551C; continue 'dispatch;
	}
	// 82A15518: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A1551C; continue 'dispatch;
            }
            0x82A1551C => {
    //   block [0x82A1551C..0x82A15538)
	// 82A1551C: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15520: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A15524: 9161FFE8  stw r11, -0x18(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[11].u32 ) };
	// 82A15528: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A1552C: 409AFF84  bne cr6, 0x82a154b0
	if !ctx.cr[6].eq {
	pc = 0x82A154B0; continue 'dispatch;
	}
	// 82A15530: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82A15534: 4BFFFF7C  b 0x82a154b0
	pc = 0x82A154B0; continue 'dispatch;
            }
            0x82A15538 => {
    //   block [0x82A15538..0x82A155AC)
	// 82A15538: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82A1553C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	pc = 0x82A155AC; continue 'dispatch;
            }
            0x82A155AC => {
    //   block [0x82A155AC..0x82A155C0)
	// 82A155AC: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A155C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A155C0 size=96
    let mut pc: u32 = 0x82A155C0;
    'dispatch: loop {
        match pc {
            0x82A155C0 => {
    //   block [0x82A155C0..0x82A15608)
	// 82A155C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A155C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A155C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A155CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A155D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A155D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A155D8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A155DC: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82A155E0: 394B24F8  addi r10, r11, 0x24f8
	ctx.r[10].s64 = ctx.r[11].s64 + 9464;
	// 82A155E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A155E8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A155EC: 48812E9D  bl 0x83228488
	ctx.lr = 0x82A155F0;
	sub_83228488(ctx, base);
	// 82A155F0: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A155F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A155F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A155FC: 419A000C  beq cr6, 0x82a15608
	if ctx.cr[6].eq {
	pc = 0x82A15608; continue 'dispatch;
	}
	// 82A15600: 4B806739  bl 0x8221bd38
	ctx.lr = 0x82A15604;
	sub_8221BD38(ctx, base);
	// 82A15604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A15608; continue 'dispatch;
            }
            0x82A15608 => {
    //   block [0x82A15608..0x82A15620)
	// 82A15608: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1560C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A15610: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A15614: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A15618: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1561C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A15620(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A15620 size=636
    let mut pc: u32 = 0x82A15620;
    'dispatch: loop {
        match pc {
            0x82A15620 => {
    //   block [0x82A15620..0x82A156CC)
	// 82A15620: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A15624: 48293DBD  bl 0x82ca93e0
	ctx.lr = 0x82A15628;
	sub_82CA93D0(ctx, base);
	// 82A15628: DBC1FF78  stfd f30, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[30].u64 ) };
	// 82A1562C: DBE1FF80  stfd f31, -0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 82A15630: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A15634: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A15638: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82A1563C: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 82A15640: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82A15644: 81790030  lwz r11, 0x30(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A15648: 82D90028  lwz r22, 0x28(r25)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(40 as u32) ) } as u64;
	// 82A1564C: 3A960004  addi r20, r22, 4
	ctx.r[20].s64 = ctx.r[22].s64 + 4;
	// 82A15650: 3AF60040  addi r23, r22, 0x40
	ctx.r[23].s64 = ctx.r[22].s64 + 64;
	// 82A15654: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A15658: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 82A1565C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 82A15660: 3A6B0030  addi r19, r11, 0x30
	ctx.r[19].s64 = ctx.r[11].s64 + 48;
	// 82A15664: 824B0014  lwz r18, 0x14(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A15668: 4880F271  bl 0x832248d8
	ctx.lr = 0x82A1566C;
	sub_832248D8(ctx, base);
	// 82A1566C: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 82A15670: 80F6000C  lwz r7, 0xc(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A15674: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A15678: 80D60008  lwz r6, 8(r22)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1567C: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 82A15680: 3B4B3B68  addi r26, r11, 0x3b68
	ctx.r[26].s64 = ctx.r[11].s64 + 15208;
	// 82A15684: 7CA63850  subf r5, r6, r7
	ctx.r[5].s64 = ctx.r[7].s64 - ctx.r[6].s64;
	// 82A15688: 816A3B78  lwz r11, 0x3b78(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15224 as u32) ) } as u64;
	// 82A1568C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A15690: 7FE54BD6  divw r31, r5, r9
	ctx.r[31].s32 = ctx.r[5].s32 / ctx.r[9].s32;
	// 82A15694: 556807FE  clrlwi r8, r11, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82A15698: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A1569C: 409A0030  bne cr6, 0x82a156cc
	if !ctx.cr[6].eq {
	pc = 0x82A156CC; continue 'dispatch;
	}
	// 82A156A0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A156A4: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82A156A8: 916A3B78  stw r11, 0x3b78(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15224 as u32), ctx.r[11].u32 ) };
	// 82A156AC: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82A156B0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82A156B4: 913A0004  stw r9, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A156B8: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A156BC: 3D40832B  lis r10, -0x7cd5
	ctx.r[10].s64 = -2094333952;
	// 82A156C0: 917A000C  stw r11, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A156C4: 386A20C0  addi r3, r10, 0x20c0
	ctx.r[3].s64 = ctx.r[10].s64 + 8384;
	// 82A156C8: 48294859  bl 0x82ca9f20
	ctx.lr = 0x82A156CC;
	sub_82CA9F20(ctx, base);
	pc = 0x82A156CC; continue 'dispatch;
            }
            0x82A156CC => {
    //   block [0x82A156CC..0x82A156F8)
	// 82A156CC: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A156D0: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A156D4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A156D8: 7D281670  srawi r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 82A156DC: 7F08F840  cmplw cr6, r8, r31
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A156E0: 40980018  bge cr6, 0x82a156f8
	if !ctx.cr[6].lt {
	pc = 0x82A156F8; continue 'dispatch;
	}
	// 82A156E4: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82A156E8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A156EC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A156F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A156F4: 4B897985  bl 0x822ad078
	ctx.lr = 0x82A156F8;
	sub_822AD078(ctx, base);
	pc = 0x82A156F8; continue 'dispatch;
            }
            0x82A156F8 => {
    //   block [0x82A156F8..0x82A1571C)
	// 82A156F8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A156FC: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A15700: 38AB9484  addi r5, r11, -0x6b7c
	ctx.r[5].s64 = ctx.r[11].s64 + -27516;
	// 82A15704: 40990188  ble cr6, 0x82a1588c
	if !ctx.cr[6].gt {
	pc = 0x82A1588C; continue 'dispatch;
	}
	// 82A15708: C005FE50  lfs f0, -0x1b0(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1570C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82A15710: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A15714: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82A15718: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	pc = 0x82A1571C; continue 'dispatch;
            }
            0x82A1571C => {
    //   block [0x82A1571C..0x82A1577C)
	// 82A1571C: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15720: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15724: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82A15728: 7FCA492E  stwx r30, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[30].u32) };
	// 82A1572C: 80990030  lwz r4, 0x30(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A15730: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A15734: 7C69FE70  srawi r9, r3, 0x1f
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[3].s32 >> 31) as i64;
	// 82A15738: 80840010  lwz r4, 0x10(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1573C: 7D291838  and r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[3].u64;
	// 82A15740: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A15744: 7C691850  subf r3, r9, r3
	ctx.r[3].s64 = ctx.r[3].s64 - ctx.r[9].s64;
	// 82A15748: 5469103A  slwi r9, r3, 2
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A1574C: 7D89242E  lfsx f12, r9, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A15750: ED6C002A  fadds f11, f12, f0
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A15754: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A15758: D9410060  stfd f10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[10].u64 ) };
	// 82A1575C: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A15760: 7C8307B4  extsw r3, r4
	ctx.r[3].s64 = ctx.r[4].s32 as i64;
	// 82A15764: F8610068  std r3, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u64 ) };
	// 82A15768: C9210068  lfd f9, 0x68(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A1576C: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82A15770: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A15774: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82A15778: 41980068  blt cr6, 0x82a157e0
	if ctx.cr[6].lt {
	pc = 0x82A157E0; continue 'dispatch;
	}
	pc = 0x82A1577C; continue 'dispatch;
            }
            0x82A1577C => {
    //   block [0x82A1577C..0x82A157E0)
	// 82A1577C: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A15780: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A15784: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82A15788: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1578C: 7D0A492E  stwx r8, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u32) };
	// 82A15790: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A15794: 80990030  lwz r4, 0x30(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A15798: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A1579C: 7C69FE70  srawi r9, r3, 0x1f
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[3].s32 >> 31) as i64;
	// 82A157A0: 80840010  lwz r4, 0x10(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A157A4: 7D291838  and r9, r9, r3
	ctx.r[9].u64 = ctx.r[9].u64 & ctx.r[3].u64;
	// 82A157A8: 7C691850  subf r3, r9, r3
	ctx.r[3].s64 = ctx.r[3].s64 - ctx.r[9].s64;
	// 82A157AC: 5469103A  slwi r9, r3, 2
	ctx.r[9].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A157B0: 7D89242E  lfsx f12, r9, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A157B4: ED6C002A  fadds f11, f12, f0
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A157B8: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A157BC: D9410060  stfd f10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[10].u64 ) };
	// 82A157C0: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A157C4: 7C8307B4  extsw r3, r4
	ctx.r[3].s64 = ctx.r[4].s32 as i64;
	// 82A157C8: F8610070  std r3, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[3].u64 ) };
	// 82A157CC: C9210070  lfd f9, 0x70(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A157D0: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82A157D4: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A157D8: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82A157DC: 4098FFA0  bge cr6, 0x82a1577c
	if !ctx.cr[6].lt {
	pc = 0x82A1577C; continue 'dispatch;
	}
	pc = 0x82A157E0; continue 'dispatch;
            }
            0x82A157E0 => {
    //   block [0x82A157E0..0x82A1588C)
	// 82A157E0: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82A157E4: 38E70024  addi r7, r7, 0x24
	ctx.r[7].s64 = ctx.r[7].s64 + 36;
	// 82A157E8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A157EC: 4082FF30  bne 0x82a1571c
	if !ctx.cr[0].eq {
	pc = 0x82A1571C; continue 'dispatch;
	}
	// 82A157F0: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A157F4: 40990098  ble cr6, 0x82a1588c
	if !ctx.cr[6].gt {
	pc = 0x82A1588C; continue 'dispatch;
	}
	// 82A157F8: C3E50000  lfs f31, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A157FC: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82A15800: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82A15804: 81740004  lwz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15808: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 82A1580C: 811A0004  lwz r8, 4(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15810: 7E6A9B78  mr r10, r19
	ctx.r[10].u64 = ctx.r[19].u64;
	// 82A15814: 7F7E5A14  add r27, r30, r11
	ctx.r[27].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82A15818: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1581C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A15820: 7E499378  mr r9, r18
	ctx.r[9].u64 = ctx.r[18].u64;
	// 82A15824: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82A15828: 80D90030  lwz r6, 0x30(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A1582C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A15830: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A15834: 7CABE214  add r5, r11, r28
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82A15838: 7D1D402E  lwzx r8, r29, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82A1583C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A15840: 4880D649  bl 0x83222e88
	ctx.lr = 0x82A15844;
	sub_83222E88(ctx, base);
	// 82A15844: 397B0010  addi r11, r27, 0x10
	ctx.r[11].s64 = ctx.r[27].s64 + 16;
	pc = 0x82A1588C; continue 'dispatch;
            }
            0x82A1588C => {
    //   block [0x82A1588C..0x82A1589C)
	// 82A1588C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82A15890: CBC1FF78  lfd f30, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 82A15894: CBE1FF80  lfd f31, -0x80(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82A15898: 48293B98  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A158A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A158A0 size=804
    let mut pc: u32 = 0x82A158A0;
    'dispatch: loop {
        match pc {
            0x82A158A0 => {
    //   block [0x82A158A0..0x82A158F0)
	// 82A158A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A158A4: 48293B41  bl 0x82ca93e4
	ctx.lr = 0x82A158A8;
	sub_82CA93D0(ctx, base);
	// 82A158A8: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 82A158AC: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A158B0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A158B4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82A158B8: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 82A158BC: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82A158C0: 815A0030  lwz r10, 0x30(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A158C4: 82DA0028  lwz r22, 0x28(r26)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 82A158C8: 3BB60004  addi r29, r22, 4
	ctx.r[29].s64 = ctx.r[22].s64 + 4;
	// 82A158CC: 3BF60050  addi r31, r22, 0x50
	ctx.r[31].s64 = ctx.r[22].s64 + 80;
	// 82A158D0: 816A0024  lwz r11, 0x24(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A158D4: C00A001C  lfs f0, 0x1c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A158D8: 81360024  lwz r9, 0x24(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A158DC: 3AAB0030  addi r21, r11, 0x30
	ctx.r[21].s64 = ctx.r[11].s64 + 48;
	// 82A158E0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A158E4: 828B0014  lwz r20, 0x14(r11)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A158E8: 419A0088  beq cr6, 0x82a15970
	if ctx.cr[6].eq {
	pc = 0x82A15970; continue 'dispatch;
	}
	// 82A158EC: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	pc = 0x82A158F0; continue 'dispatch;
            }
            0x82A158F0 => {
    //   block [0x82A158F0..0x82A15970)
	// 82A158F0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A158F4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A158F8: 7D6B5038  and r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 82A158FC: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A15900: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A15904: 550B1838  slwi r11, r8, 3
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A15908: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A1590C: C1A7000C  lfs f13, 0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A15910: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A15914: 4198005C  blt cr6, 0x82a15970
	if ctx.cr[6].lt {
	pc = 0x82A15970; continue 'dispatch;
	}
	// 82A15918: 817A0014  lwz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A1591C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A15920: 917A0014  stw r11, 0x14(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A15924: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A15928: 813D001C  lwz r9, 0x1c(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A1592C: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15930: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 82A15934: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 82A15938: 7D064838  and r6, r8, r9
	ctx.r[6].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 82A1593C: 90FD0020  stw r7, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 82A15940: 90DD0010  stw r6, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 82A15944: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A15948: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A1594C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15950: 38AA0001  addi r5, r10, 1
	ctx.r[5].s64 = ctx.r[10].s64 + 1;
	// 82A15954: 3889FFFF  addi r4, r9, -1
	ctx.r[4].s64 = ctx.r[9].s64 + -1;
	// 82A15958: 7CA35838  and r3, r5, r11
	ctx.r[3].u64 = ctx.r[5].u64 & ctx.r[11].u64;
	// 82A1595C: 909F0020  stw r4, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 82A15960: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82A15964: 815D0020  lwz r10, 0x20(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A15968: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1596C: 409AFF84  bne cr6, 0x82a158f0
	if !ctx.cr[6].eq {
	pc = 0x82A158F0; continue 'dispatch;
	}
	pc = 0x82A15970; continue 'dispatch;
            }
            0x82A15970 => {
    //   block [0x82A15970..0x82A159C0)
	// 82A15970: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 82A15974: 831D0020  lwz r24, 0x20(r29)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A15978: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A1597C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A15980: 3B6B3B54  addi r27, r11, 0x3b54
	ctx.r[27].s64 = ctx.r[11].s64 + 15188;
	// 82A15984: 816A3B64  lwz r11, 0x3b64(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15204 as u32) ) } as u64;
	// 82A15988: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82A1598C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A15990: 409A0030  bne cr6, 0x82a159c0
	if !ctx.cr[6].eq {
	pc = 0x82A159C0; continue 'dispatch;
	}
	// 82A15994: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A15998: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82A1599C: 916A3B64  stw r11, 0x3b64(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15204 as u32), ctx.r[11].u32 ) };
	// 82A159A0: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82A159A4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82A159A8: 913B0004  stw r9, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A159AC: 911B0008  stw r8, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A159B0: 3D40832B  lis r10, -0x7cd5
	ctx.r[10].s64 = -2094333952;
	// 82A159B4: 917B000C  stw r11, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A159B8: 386A2068  addi r3, r10, 0x2068
	ctx.r[3].s64 = ctx.r[10].s64 + 8296;
	// 82A159BC: 48294565  bl 0x82ca9f20
	ctx.lr = 0x82A159C0;
	sub_82CA9F20(ctx, base);
	pc = 0x82A159C0; continue 'dispatch;
            }
            0x82A159C0 => {
    //   block [0x82A159C0..0x82A159EC)
	// 82A159C0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A159C4: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A159C8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A159CC: 7D281670  srawi r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 82A159D0: 7F08C040  cmplw cr6, r8, r24
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A159D4: 40980018  bge cr6, 0x82a159ec
	if !ctx.cr[6].lt {
	pc = 0x82A159EC; continue 'dispatch;
	}
	// 82A159D8: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82A159DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A159E0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A159E4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A159E8: 4B897691  bl 0x822ad078
	ctx.lr = 0x82A159EC;
	sub_822AD078(ctx, base);
	pc = 0x82A159EC; continue 'dispatch;
            }
            0x82A159EC => {
    //   block [0x82A159EC..0x82A15A0C)
	// 82A159EC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A159F0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A159F4: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82A159F8: 38AB9484  addi r5, r11, -0x6b7c
	ctx.r[5].s64 = ctx.r[11].s64 + -27516;
	// 82A159FC: 409901BC  ble cr6, 0x82a15bb8
	if !ctx.cr[6].gt {
	pc = 0x82A15BB8; continue 'dispatch;
	}
	// 82A15A00: C005FE50  lfs f0, -0x1b0(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A15A04: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82A15A08: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	pc = 0x82A15A0C; continue 'dispatch;
            }
            0x82A15A0C => {
    //   block [0x82A15A0C..0x82A15A88)
	// 82A15A0C: 811B0004  lwz r8, 4(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15A10: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15A14: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A15A18: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15A1C: 7C6B3A14  add r3, r11, r7
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82A15A20: 7FCA412E  stwx r30, r10, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), ctx.r[30].u32) };
	// 82A15A24: 7C6B2038  and r11, r3, r4
	ctx.r[11].u64 = ctx.r[3].u64 & ctx.r[4].u64;
	// 82A15A28: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A15A2C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82A15A30: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A15A34: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A15A38: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15A3C: 7D28FE70  srawi r8, r9, 0x1f
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 31) as i64;
	// 82A15A40: 809A0030  lwz r4, 0x30(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A15A44: 7D034838  and r3, r8, r9
	ctx.r[3].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 82A15A48: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A15A4C: 7D234850  subf r9, r3, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 82A15A50: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A15A54: 80840010  lwz r4, 0x10(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15A58: 7D88242E  lfsx f12, r8, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A15A5C: ED6C002A  fadds f11, f12, f0
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A15A60: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A15A64: D9410060  stfd f10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[10].u64 ) };
	// 82A15A68: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A15A6C: 7C6907B4  extsw r9, r3
	ctx.r[9].s64 = ctx.r[3].s32 as i64;
	// 82A15A70: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 82A15A74: C9210068  lfd f9, 0x68(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A15A78: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82A15A7C: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A15A80: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82A15A84: 41980068  blt cr6, 0x82a15aec
	if ctx.cr[6].lt {
	pc = 0x82A15AEC; continue 'dispatch;
	}
	pc = 0x82A15A88; continue 'dispatch;
            }
            0x82A15A88 => {
    //   block [0x82A15A88..0x82A15AEC)
	// 82A15A88: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15A8C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A15A90: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82A15A94: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15A98: 7CCA492E  stwx r6, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[6].u32) };
	// 82A15A9C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A15AA0: 811A0030  lwz r8, 0x30(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A15AA4: 808B0010  lwz r4, 0x10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15AA8: 7C83FE70  srawi r3, r4, 0x1f
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[4].s32 >> 31) as i64;
	// 82A15AAC: 81280010  lwz r9, 0x10(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15AB0: 7C682038  and r8, r3, r4
	ctx.r[8].u64 = ctx.r[3].u64 & ctx.r[4].u64;
	// 82A15AB4: 7C882050  subf r4, r8, r4
	ctx.r[4].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 82A15AB8: 5483103A  slwi r3, r4, 2
	ctx.r[3].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A15ABC: 7D834C2E  lfsx f12, r3, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A15AC0: ED6C002A  fadds f11, f12, f0
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A15AC4: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A15AC8: D9410060  stfd f10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[10].u64 ) };
	// 82A15ACC: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A15AD0: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 82A15AD4: F9010070  std r8, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u64 ) };
	// 82A15AD8: C9210070  lfd f9, 0x70(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A15ADC: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82A15AE0: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A15AE4: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82A15AE8: 4098FFA0  bge cr6, 0x82a15a88
	if !ctx.cr[6].lt {
	pc = 0x82A15A88; continue 'dispatch;
	}
	pc = 0x82A15AEC; continue 'dispatch;
            }
            0x82A15AEC => {
    //   block [0x82A15AEC..0x82A15BB8)
	// 82A15AEC: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82A15AF0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A15AF4: 7F07C000  cmpw cr6, r7, r24
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[24].s32, &mut ctx.xer);
	// 82A15AF8: 4198FF14  blt cr6, 0x82a15a0c
	if ctx.cr[6].lt {
	pc = 0x82A15A0C; continue 'dispatch;
	}
	// 82A15AFC: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82A15B00: 409900B8  ble cr6, 0x82a15bb8
	if !ctx.cr[6].gt {
	pc = 0x82A15BB8; continue 'dispatch;
	}
	// 82A15B04: C0650000  lfs f3, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82A15B08: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82A15B0C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A15B10: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15B14: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15B18: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	// 82A15B1C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 82A15B20: 7CE9F214  add r7, r9, r30
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 82A15B24: 811F001C  lwz r8, 0x1c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A15B28: 7CCBF214  add r6, r11, r30
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A15B2C: 809D001C  lwz r4, 0x1c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A15B30: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82A15B34: 7CEB4038  and r11, r7, r8
	ctx.r[11].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82A15B38: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15B3C: 7CC92038  and r9, r6, r4
	ctx.r[9].u64 = ctx.r[6].u64 & ctx.r[4].u64;
	// 82A15B40: 827B0004  lwz r19, 4(r27)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15B44: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A15B48: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15B4C: 55282834  slwi r8, r9, 5
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A15B50: 80DA0030  lwz r6, 0x30(r26)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A15B54: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82A15B58: D0610060  stfs f3, 0x60(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A15B5C: 7C882A14  add r4, r8, r5
	ctx.r[4].u64 = ctx.r[8].u64 + ctx.r[5].u64;
	// 82A15B60: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A15B64: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A15B68: 7D1C982E  lwzx r8, r28, r19
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[19].u32)) } as u64;
	// 82A15B6C: 7E89A378  mr r9, r20
	ctx.r[9].u64 = ctx.r[20].u64;
	// 82A15B70: 7CAB3A14  add r5, r11, r7
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82A15B74: 4880C29D  bl 0x83221e10
	ctx.lr = 0x82A15B78;
	sub_83221E10(ctx, base);
	pc = 0x82A15BB8; continue 'dispatch;
            }
            0x82A15BB8 => {
    //   block [0x82A15BB8..0x82A15BC4)
	// 82A15BB8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A15BBC: CBE1FF88  lfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 82A15BC0: 48293874  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A15BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A15BC8 size=804
    let mut pc: u32 = 0x82A15BC8;
    'dispatch: loop {
        match pc {
            0x82A15BC8 => {
    //   block [0x82A15BC8..0x82A15C1C)
	// 82A15BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A15BCC: 48293819  bl 0x82ca93e4
	ctx.lr = 0x82A15BD0;
	sub_82CA93D0(ctx, base);
	// 82A15BD0: DBC1FF80  stfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 82A15BD4: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 82A15BD8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A15BDC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A15BE0: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82A15BE4: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 82A15BE8: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82A15BEC: 81590030  lwz r10, 0x30(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A15BF0: 82B90028  lwz r21, 0x28(r25)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(40 as u32) ) } as u64;
	// 82A15BF4: 3BB50004  addi r29, r21, 4
	ctx.r[29].s64 = ctx.r[21].s64 + 4;
	// 82A15BF8: 3BF5002C  addi r31, r21, 0x2c
	ctx.r[31].s64 = ctx.r[21].s64 + 44;
	// 82A15BFC: 816A0024  lwz r11, 0x24(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A15C00: C00A001C  lfs f0, 0x1c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A15C04: 81350024  lwz r9, 0x24(r21)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A15C08: 3A8B0030  addi r20, r11, 0x30
	ctx.r[20].s64 = ctx.r[11].s64 + 48;
	// 82A15C0C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A15C10: 826B0014  lwz r19, 0x14(r11)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A15C14: 419A0080  beq cr6, 0x82a15c94
	if ctx.cr[6].eq {
	pc = 0x82A15C94; continue 'dispatch;
	}
	// 82A15C18: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	pc = 0x82A15C1C; continue 'dispatch;
            }
            0x82A15C1C => {
    //   block [0x82A15C1C..0x82A15C94)
	// 82A15C1C: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15C20: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15C24: 7D684838  and r8, r11, r9
	ctx.r[8].u64 = ctx.r[11].u64 & ctx.r[9].u64;
	// 82A15C28: 1D68002C  mulli r11, r8, 0x2c
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * 44 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A15C2C: 7CEB5214  add r7, r11, r10
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A15C30: C1A7000C  lfs f13, 0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A15C34: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82A15C38: 4198005C  blt cr6, 0x82a15c94
	if ctx.cr[6].lt {
	pc = 0x82A15C94; continue 'dispatch;
	}
	// 82A15C3C: 81790014  lwz r11, 0x14(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A15C40: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A15C44: 91790014  stw r11, 0x14(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A15C48: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A15C4C: 813D001C  lwz r9, 0x1c(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A15C50: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15C54: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 82A15C58: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 82A15C5C: 7D064838  and r6, r8, r9
	ctx.r[6].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 82A15C60: 90FD0020  stw r7, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[7].u32 ) };
	// 82A15C64: 90DD0010  stw r6, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 82A15C68: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A15C6C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A15C70: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15C74: 38AA0001  addi r5, r10, 1
	ctx.r[5].s64 = ctx.r[10].s64 + 1;
	// 82A15C78: 3889FFFF  addi r4, r9, -1
	ctx.r[4].s64 = ctx.r[9].s64 + -1;
	// 82A15C7C: 7CA35838  and r3, r5, r11
	ctx.r[3].u64 = ctx.r[5].u64 & ctx.r[11].u64;
	// 82A15C80: 909F0020  stw r4, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 82A15C84: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82A15C88: 815D0020  lwz r10, 0x20(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A15C8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A15C90: 409AFF8C  bne cr6, 0x82a15c1c
	if !ctx.cr[6].eq {
	pc = 0x82A15C1C; continue 'dispatch;
	}
	pc = 0x82A15C94; continue 'dispatch;
            }
            0x82A15C94 => {
    //   block [0x82A15C94..0x82A15CE4)
	// 82A15C94: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 82A15C98: 82FD0020  lwz r23, 0x20(r29)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A15C9C: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82A15CA0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A15CA4: 3B4B3B40  addi r26, r11, 0x3b40
	ctx.r[26].s64 = ctx.r[11].s64 + 15168;
	// 82A15CA8: 816A3B50  lwz r11, 0x3b50(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(15184 as u32) ) } as u64;
	// 82A15CAC: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82A15CB0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A15CB4: 409A0030  bne cr6, 0x82a15ce4
	if !ctx.cr[6].eq {
	pc = 0x82A15CE4; continue 'dispatch;
	}
	// 82A15CB8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82A15CBC: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82A15CC0: 916A3B50  stw r11, 0x3b50(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(15184 as u32), ctx.r[11].u32 ) };
	// 82A15CC4: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82A15CC8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82A15CCC: 913A0004  stw r9, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A15CD0: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A15CD4: 3D40832B  lis r10, -0x7cd5
	ctx.r[10].s64 = -2094333952;
	// 82A15CD8: 917A000C  stw r11, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A15CDC: 386A2010  addi r3, r10, 0x2010
	ctx.r[3].s64 = ctx.r[10].s64 + 8208;
	// 82A15CE0: 48294241  bl 0x82ca9f20
	ctx.lr = 0x82A15CE4;
	sub_82CA9F20(ctx, base);
	pc = 0x82A15CE4; continue 'dispatch;
            }
            0x82A15CE4 => {
    //   block [0x82A15CE4..0x82A15D10)
	// 82A15CE4: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A15CE8: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15CEC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A15CF0: 7D281670  srawi r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 82A15CF4: 7F08B840  cmplw cr6, r8, r23
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[23].u32, &mut ctx.xer);
	// 82A15CF8: 40980018  bge cr6, 0x82a15d10
	if !ctx.cr[6].lt {
	pc = 0x82A15D10; continue 'dispatch;
	}
	// 82A15CFC: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82A15D00: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A15D04: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A15D08: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82A15D0C: 4B89736D  bl 0x822ad078
	ctx.lr = 0x82A15D10;
	sub_822AD078(ctx, base);
	pc = 0x82A15D10; continue 'dispatch;
            }
            0x82A15D10 => {
    //   block [0x82A15D10..0x82A15D30)
	// 82A15D10: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A15D14: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82A15D18: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 82A15D1C: 38CB9484  addi r6, r11, -0x6b7c
	ctx.r[6].s64 = ctx.r[11].s64 + -27516;
	// 82A15D20: 409901BC  ble cr6, 0x82a15edc
	if !ctx.cr[6].gt {
	pc = 0x82A15EDC; continue 'dispatch;
	}
	// 82A15D24: C006FE50  lfs f0, -0x1b0(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-432 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A15D28: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82A15D2C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	pc = 0x82A15D30; continue 'dispatch;
            }
            0x82A15D30 => {
    //   block [0x82A15D30..0x82A15DA4)
	// 82A15D30: 80BA0004  lwz r5, 4(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15D34: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15D38: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A15D3C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15D40: 7C6B4214  add r3, r11, r8
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82A15D44: 7FCA292E  stwx r30, r10, r5
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32), ctx.r[30].u32) };
	// 82A15D48: 7C6B2038  and r11, r3, r4
	ctx.r[11].u64 = ctx.r[3].u64 & ctx.r[4].u64;
	// 82A15D4C: 1D6B002C  mulli r11, r11, 0x2c
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 44 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A15D50: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A15D54: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15D58: 7D25FE70  srawi r5, r9, 0x1f
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[9].s32 >> 31) as i64;
	// 82A15D5C: 80990030  lwz r4, 0x30(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A15D60: 7CA34838  and r3, r5, r9
	ctx.r[3].u64 = ctx.r[5].u64 & ctx.r[9].u64;
	// 82A15D64: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A15D68: 7D234850  subf r9, r3, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 82A15D6C: 5525103A  slwi r5, r9, 2
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A15D70: 80840010  lwz r4, 0x10(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15D74: 7D85242E  lfsx f12, r5, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A15D78: ED6C002A  fadds f11, f12, f0
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A15D7C: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A15D80: D9410060  stfd f10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[10].u64 ) };
	// 82A15D84: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A15D88: 7C6907B4  extsw r9, r3
	ctx.r[9].s64 = ctx.r[3].s32 as i64;
	// 82A15D8C: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 82A15D90: C9210068  lfd f9, 0x68(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A15D94: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82A15D98: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A15D9C: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82A15DA0: 41980068  blt cr6, 0x82a15e08
	if ctx.cr[6].lt {
	pc = 0x82A15E08; continue 'dispatch;
	}
	pc = 0x82A15DA4; continue 'dispatch;
            }
            0x82A15DA4 => {
    //   block [0x82A15DA4..0x82A15E08)
	// 82A15DA4: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15DA8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82A15DAC: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82A15DB0: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15DB4: 7CEA492E  stwx r7, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 82A15DB8: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A15DBC: 80B90030  lwz r5, 0x30(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A15DC0: 808B0010  lwz r4, 0x10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15DC4: 7C83FE70  srawi r3, r4, 0x1f
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[4].s32 >> 31) as i64;
	// 82A15DC8: 81250010  lwz r9, 0x10(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15DCC: 7C652038  and r5, r3, r4
	ctx.r[5].u64 = ctx.r[3].u64 & ctx.r[4].u64;
	// 82A15DD0: 7C852050  subf r4, r5, r4
	ctx.r[4].s64 = ctx.r[4].s64 - ctx.r[5].s64;
	// 82A15DD4: 5483103A  slwi r3, r4, 2
	ctx.r[3].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A15DD8: 7D834C2E  lfsx f12, r3, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A15DDC: ED6C002A  fadds f11, f12, f0
	ctx.f[11].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82A15DE0: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A15DE4: D9410060  stfd f10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[10].u64 ) };
	// 82A15DE8: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A15DEC: 7D2507B4  extsw r5, r9
	ctx.r[5].s64 = ctx.r[9].s32 as i64;
	// 82A15DF0: F8A10070  std r5, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[5].u64 ) };
	// 82A15DF4: C9210070  lfd f9, 0x70(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A15DF8: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82A15DFC: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82A15E00: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82A15E04: 4098FFA0  bge cr6, 0x82a15da4
	if !ctx.cr[6].lt {
	pc = 0x82A15DA4; continue 'dispatch;
	}
	pc = 0x82A15E08; continue 'dispatch;
            }
            0x82A15E08 => {
    //   block [0x82A15E08..0x82A15EDC)
	// 82A15E08: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82A15E0C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A15E10: 7F08B800  cmpw cr6, r8, r23
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[23].s32, &mut ctx.xer);
	// 82A15E14: 4198FF1C  blt cr6, 0x82a15d30
	if ctx.cr[6].lt {
	pc = 0x82A15D30; continue 'dispatch;
	}
	// 82A15E18: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 82A15E1C: 409900C0  ble cr6, 0x82a15edc
	if !ctx.cr[6].gt {
	pc = 0x82A15EDC; continue 'dispatch;
	}
	// 82A15E20: C3E60000  lfs f31, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82A15E24: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82A15E28: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15E2C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82A15E30: 811D001C  lwz r8, 0x1c(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A15E34: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A15E38: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A15E3C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A15E40: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A15E44: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 82A15E48: 7CEB4038  and r11, r7, r8
	ctx.r[11].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 82A15E4C: 80DF001C  lwz r6, 0x1c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A15E50: 7CA9F214  add r5, r9, r30
	ctx.r[5].u64 = ctx.r[9].u64 + ctx.r[30].u64;
	// 82A15E54: 807A0004  lwz r3, 4(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15E58: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A15E5C: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15E60: 7CA83038  and r8, r5, r6
	ctx.r[8].u64 = ctx.r[5].u64 & ctx.r[6].u64;
	// 82A15E64: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A15E68: 7CAB4A14  add r5, r11, r9
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A15E6C: 80D90030  lwz r6, 0x30(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A15E70: 1D68002C  mulli r11, r8, 0x2c
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * 44 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A15E74: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82A15E78: 7D1C182E  lwzx r8, r28, r3
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82A15E7C: 54A52834  slwi r5, r5, 5
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(5);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A15E80: 7E699B78  mr r9, r19
	ctx.r[9].u64 = ctx.r[19].u64;
	// 82A15E84: 7F652214  add r27, r5, r4
	ctx.r[27].u64 = ctx.r[5].u64 + ctx.r[4].u64;
	// 82A15E88: 7CAB3A14  add r5, r11, r7
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82A15E8C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A15E90: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 82A15E94: 4880B555  bl 0x832213e8
	ctx.lr = 0x82A15E98;
	sub_832213E8(ctx, base);
	// 82A15E98: 397B0010  addi r11, r27, 0x10
	ctx.r[11].s64 = ctx.r[27].s64 + 16;
	pc = 0x82A15EDC; continue 'dispatch;
            }
            0x82A15EDC => {
    //   block [0x82A15EDC..0x82A15EEC)
	// 82A15EDC: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82A15EE0: CBC1FF80  lfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 82A15EE4: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 82A15EE8: 4829354C  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A15EF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A15EF0 size=80
    let mut pc: u32 = 0x82A15EF0;
    'dispatch: loop {
        match pc {
            0x82A15EF0 => {
    //   block [0x82A15EF0..0x82A15F28)
	// 82A15EF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A15EF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A15EF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A15EFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A15F00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A15F04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A15F08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A15F0C: 4880C13D  bl 0x83222048
	ctx.lr = 0x82A15F10;
	sub_83222048(ctx, base);
	// 82A15F10: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A15F14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A15F18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A15F1C: 419A000C  beq cr6, 0x82a15f28
	if ctx.cr[6].eq {
	pc = 0x82A15F28; continue 'dispatch;
	}
	// 82A15F20: 4B805E19  bl 0x8221bd38
	ctx.lr = 0x82A15F24;
	sub_8221BD38(ctx, base);
	// 82A15F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A15F28; continue 'dispatch;
            }
            0x82A15F28 => {
    //   block [0x82A15F28..0x82A15F40)
	// 82A15F28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A15F2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A15F30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A15F34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A15F38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A15F3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A15F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A15F40 size=80
    let mut pc: u32 = 0x82A15F40;
    'dispatch: loop {
        match pc {
            0x82A15F40 => {
    //   block [0x82A15F40..0x82A15F78)
	// 82A15F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A15F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A15F48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A15F4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A15F50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A15F54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A15F58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A15F5C: 4880BA5D  bl 0x832219b8
	ctx.lr = 0x82A15F60;
	sub_832219B8(ctx, base);
	// 82A15F60: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A15F64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A15F68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A15F6C: 419A000C  beq cr6, 0x82a15f78
	if ctx.cr[6].eq {
	pc = 0x82A15F78; continue 'dispatch;
	}
	// 82A15F70: 4B805DC9  bl 0x8221bd38
	ctx.lr = 0x82A15F74;
	sub_8221BD38(ctx, base);
	// 82A15F74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A15F78; continue 'dispatch;
            }
            0x82A15F78 => {
    //   block [0x82A15F78..0x82A15F90)
	// 82A15F78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A15F7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A15F80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A15F84: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A15F88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A15F8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A15F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A15F90 size=128
    let mut pc: u32 = 0x82A15F90;
    'dispatch: loop {
        match pc {
            0x82A15F90 => {
    //   block [0x82A15F90..0x82A15FB8)
	// 82A15F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A15F94: 48293471  bl 0x82ca9404
	ctx.lr = 0x82A15F98;
	sub_82CA93D0(ctx, base);
	// 82A15F98: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A15F9C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A15FA0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82A15FA4: 3BDC0050  addi r30, r28, 0x50
	ctx.r[30].s64 = ctx.r[28].s64 + 80;
	// 82A15FA8: 807C0054  lwz r3, 0x54(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A15FAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A15FB0: 419A0008  beq cr6, 0x82a15fb8
	if ctx.cr[6].eq {
	pc = 0x82A15FB8; continue 'dispatch;
	}
	// 82A15FB4: 4B805D85  bl 0x8221bd38
	ctx.lr = 0x82A15FB8;
	sub_8221BD38(ctx, base);
	pc = 0x82A15FB8; continue 'dispatch;
            }
            0x82A15FB8 => {
    //   block [0x82A15FB8..0x82A15FDC)
	// 82A15FB8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A15FBC: 3BBC002C  addi r29, r28, 0x2c
	ctx.r[29].s64 = ctx.r[28].s64 + 44;
	// 82A15FC0: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A15FC4: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82A15FC8: 93FE000C  stw r31, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A15FCC: 807C0030  lwz r3, 0x30(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A15FD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A15FD4: 419A0008  beq cr6, 0x82a15fdc
	if ctx.cr[6].eq {
	pc = 0x82A15FDC; continue 'dispatch;
	}
	// 82A15FD8: 4B805D61  bl 0x8221bd38
	ctx.lr = 0x82A15FDC;
	sub_8221BD38(ctx, base);
	pc = 0x82A15FDC; continue 'dispatch;
            }
            0x82A15FDC => {
    //   block [0x82A15FDC..0x82A16008)
	// 82A15FDC: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A15FE0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A15FE4: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82A15FE8: 93FD000C  stw r31, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A15FEC: 48000025  bl 0x82a16010
	ctx.lr = 0x82A15FF0;
	sub_82A16010(ctx, base);
	// 82A15FF0: 576B07FE  clrlwi r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	// 82A15FF4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A15FF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A15FFC: 419A000C  beq cr6, 0x82a16008
	if ctx.cr[6].eq {
	pc = 0x82A16008; continue 'dispatch;
	}
	// 82A16000: 4B805D39  bl 0x8221bd38
	ctx.lr = 0x82A16004;
	sub_8221BD38(ctx, base);
	// 82A16004: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	pc = 0x82A16008; continue 'dispatch;
            }
            0x82A16008 => {
    //   block [0x82A16008..0x82A16010)
	// 82A16008: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1600C: 48293448  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A16010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A16010 size=96
    let mut pc: u32 = 0x82A16010;
    'dispatch: loop {
        match pc {
            0x82A16010 => {
    //   block [0x82A16010..0x82A1603C)
	// 82A16010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A16014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A16018: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1601C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A16020: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A16024: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A16028: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 82A1602C: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16030: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A16034: 419A0008  beq cr6, 0x82a1603c
	if ctx.cr[6].eq {
	pc = 0x82A1603C; continue 'dispatch;
	}
	// 82A16038: 4B805D01  bl 0x8221bd38
	ctx.lr = 0x82A1603C;
	sub_8221BD38(ctx, base);
	pc = 0x82A1603C; continue 'dispatch;
            }
            0x82A1603C => {
    //   block [0x82A1603C..0x82A16070)
	// 82A1603C: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82A16040: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A16044: 392A2B90  addi r9, r10, 0x2b90
	ctx.r[9].s64 = ctx.r[10].s64 + 11152;
	// 82A16048: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A1604C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A16050: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A16054: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A16058: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1605C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A16060: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A16064: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A16068: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1606C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A16070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A16070 size=80
    let mut pc: u32 = 0x82A16070;
    'dispatch: loop {
        match pc {
            0x82A16070 => {
    //   block [0x82A16070..0x82A160A8)
	// 82A16070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A16074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A16078: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1607C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A16080: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A16084: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A16088: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1608C: 4882E965  bl 0x832449f0
	ctx.lr = 0x82A16090;
	sub_832449F0(ctx, base);
	// 82A16090: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A16094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A16098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1609C: 419A000C  beq cr6, 0x82a160a8
	if ctx.cr[6].eq {
	pc = 0x82A160A8; continue 'dispatch;
	}
	// 82A160A0: 4B805C99  bl 0x8221bd38
	ctx.lr = 0x82A160A4;
	sub_8221BD38(ctx, base);
	// 82A160A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A160A8; continue 'dispatch;
            }
            0x82A160A8 => {
    //   block [0x82A160A8..0x82A160C0)
	// 82A160A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A160AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A160B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A160B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A160B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A160BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A160C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A160C0 size=84
    let mut pc: u32 = 0x82A160C0;
    'dispatch: loop {
        match pc {
            0x82A160C0 => {
    //   block [0x82A160C0..0x82A1610C)
	// 82A160C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A160C4: 48293349  bl 0x82ca940c
	ctx.lr = 0x82A160C8;
	sub_82CA93D0(ctx, base);
	// 82A160C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A160CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A160D0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A160D4: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82A160D8: 394B2544  addi r10, r11, 0x2544
	ctx.r[10].s64 = ctx.r[11].s64 + 9540;
	// 82A160DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A160E0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A160E4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A160E8: 4B8FD8B1  bl 0x82313998
	ctx.lr = 0x82A160EC;
	sub_82313998(ctx, base);
	// 82A160EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A160F0: 4B8FD719  bl 0x82313808
	ctx.lr = 0x82A160F4;
	sub_82313808(ctx, base);
	// 82A160F4: 57A907FE  clrlwi r9, r29, 0x1f
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 82A160F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A160FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A16100: 419A000C  beq cr6, 0x82a1610c
	if ctx.cr[6].eq {
	pc = 0x82A1610C; continue 'dispatch;
	}
	// 82A16104: 4B805C35  bl 0x8221bd38
	ctx.lr = 0x82A16108;
	sub_8221BD38(ctx, base);
	// 82A16108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1610C; continue 'dispatch;
            }
            0x82A1610C => {
    //   block [0x82A1610C..0x82A16114)
	// 82A1610C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A16110: 4829334C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A16118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A16118 size=260
    let mut pc: u32 = 0x82A16118;
    'dispatch: loop {
        match pc {
            0x82A16118 => {
    //   block [0x82A16118..0x82A16140)
	// 82A16118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1611C: 482932ED  bl 0x82ca9408
	ctx.lr = 0x82A16120;
	sub_82CA93D0(ctx, base);
	// 82A16120: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A16124: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A16128: 839D0004  lwz r28, 4(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1612C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16130: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82A16134: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A16138: 409A0030  bne cr6, 0x82a16168
	if !ctx.cr[6].eq {
	pc = 0x82A16168; continue 'dispatch;
	}
	// 82A1613C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A16140; continue 'dispatch;
            }
            0x82A16140 => {
    //   block [0x82A16140..0x82A16158)
	// 82A16140: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A16144: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A16148: 40980010  bge cr6, 0x82a16158
	if !ctx.cr[6].lt {
	pc = 0x82A16158; continue 'dispatch;
	}
	// 82A1614C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 82A16150: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A16154: 48000008  b 0x82a1615c
	pc = 0x82A1615C; continue 'dispatch;
            }
            0x82A16158 => {
    //   block [0x82A16158..0x82A1615C)
	// 82A16158: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A1615C; continue 'dispatch;
            }
            0x82A1615C => {
    //   block [0x82A1615C..0x82A16168)
	// 82A1615C: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82A16160: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A16164: 419AFFDC  beq cr6, 0x82a16140
	if ctx.cr[6].eq {
	pc = 0x82A16140; continue 'dispatch;
	}
	pc = 0x82A16168; continue 'dispatch;
            }
            0x82A16168 => {
    //   block [0x82A16168..0x82A1618C)
	// 82A16168: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1616C: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82A16170: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A16174: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82A16178: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1617C: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82A16180: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A16184: 409A0030  bne cr6, 0x82a161b4
	if !ctx.cr[6].eq {
	pc = 0x82A161B4; continue 'dispatch;
	}
	// 82A16188: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1618C; continue 'dispatch;
            }
            0x82A1618C => {
    //   block [0x82A1618C..0x82A161A0)
	// 82A1618C: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A16190: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A16194: 4098000C  bge cr6, 0x82a161a0
	if !ctx.cr[6].lt {
	pc = 0x82A161A0; continue 'dispatch;
	}
	// 82A16198: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1619C: 4800000C  b 0x82a161a8
	pc = 0x82A161A8; continue 'dispatch;
            }
            0x82A161A0 => {
    //   block [0x82A161A0..0x82A161A8)
	// 82A161A0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A161A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A161A8; continue 'dispatch;
            }
            0x82A161A8 => {
    //   block [0x82A161A8..0x82A161B4)
	// 82A161A8: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82A161AC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A161B0: 419AFFDC  beq cr6, 0x82a1618c
	if ctx.cr[6].eq {
	pc = 0x82A1618C; continue 'dispatch;
	}
	pc = 0x82A161B4; continue 'dispatch;
            }
            0x82A161B4 => {
    //   block [0x82A161B4..0x82A161C8)
	// 82A161B4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A161B8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A161BC: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A161C0: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A161C4: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	pc = 0x82A161C8; continue 'dispatch;
            }
            0x82A161C8 => {
    //   block [0x82A161C8..0x82A161DC)
	// 82A161C8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A161CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A161D0: 419A000C  beq cr6, 0x82a161dc
	if ctx.cr[6].eq {
	pc = 0x82A161DC; continue 'dispatch;
	}
	// 82A161D4: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A161D8: 419A0008  beq cr6, 0x82a161e0
	if ctx.cr[6].eq {
	pc = 0x82A161E0; continue 'dispatch;
	}
	pc = 0x82A161DC; continue 'dispatch;
            }
            0x82A161DC => {
    //   block [0x82A161DC..0x82A161E0)
	// 82A161DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A161E0; continue 'dispatch;
            }
            0x82A161E0 => {
    //   block [0x82A161E0..0x82A161FC)
	// 82A161E0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A161E4: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A161E8: 419A0014  beq cr6, 0x82a161fc
	if ctx.cr[6].eq {
	pc = 0x82A161FC; continue 'dispatch;
	}
	// 82A161EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A161F0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A161F4: 4BA26BFD  bl 0x8243cdf0
	ctx.lr = 0x82A161F8;
	sub_8243CDF0(ctx, base);
	// 82A161F8: 4BFFFFD0  b 0x82a161c8
	pc = 0x82A161C8; continue 'dispatch;
            }
            0x82A161FC => {
    //   block [0x82A161FC..0x82A1621C)
	// 82A161FC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A16200: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A16204: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A16208: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1620C: 4B8FD6A5  bl 0x823138b0
	ctx.lr = 0x82A16210;
	sub_823138B0(ctx, base);
	// 82A16210: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A16214: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A16218: 48293240  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A16220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A16220 size=80
    let mut pc: u32 = 0x82A16220;
    'dispatch: loop {
        match pc {
            0x82A16220 => {
    //   block [0x82A16220..0x82A16258)
	// 82A16220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A16224: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A16228: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1622C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A16230: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A16234: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A16238: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1623C: 4882852D  bl 0x8323e768
	ctx.lr = 0x82A16240;
	sub_8323E768(ctx, base);
	// 82A16240: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A16244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A16248: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1624C: 419A000C  beq cr6, 0x82a16258
	if ctx.cr[6].eq {
	pc = 0x82A16258; continue 'dispatch;
	}
	// 82A16250: 4B805AE9  bl 0x8221bd38
	ctx.lr = 0x82A16254;
	sub_8221BD38(ctx, base);
	// 82A16254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A16258; continue 'dispatch;
            }
            0x82A16258 => {
    //   block [0x82A16258..0x82A16270)
	// 82A16258: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1625C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A16260: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A16264: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A16268: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1626C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A16270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A16270 size=196
    let mut pc: u32 = 0x82A16270;
    'dispatch: loop {
        match pc {
            0x82A16270 => {
    //   block [0x82A16270..0x82A162E0)
	// 82A16270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A16274: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A16278: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1627C: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16280: 38A0000C  li r5, 0xc
	ctx.r[5].s64 = 12;
	// 82A16284: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16288: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1628C: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82A16290: 7CE94050  subf r7, r9, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82A16294: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A16298: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82A1629C: 7CE72BD6  divw r7, r7, r5
	ctx.r[7].s32 = ctx.r[7].s32 / ctx.r[5].s32;
	// 82A162A0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A162A4: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A162A8: 40990038  ble cr6, 0x82a162e0
	if !ctx.cr[6].gt {
	pc = 0x82A162E0; continue 'dispatch;
	}
	// 82A162AC: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A162B0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A162B4: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82A162B8: 7CE94050  subf r7, r9, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 82A162BC: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82A162C0: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A162C4: 7CA72BD6  divw r5, r7, r5
	ctx.r[5].s32 = ctx.r[7].s32 / ctx.r[5].s32;
	// 82A162C8: 7CA55050  subf r5, r5, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[5].s64;
	// 82A162CC: 48042245  bl 0x82a58510
	ctx.lr = 0x82A162D0;
	sub_82A58510(ctx, base);
	// 82A162D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A162D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A162D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A162DC: 4E800020  blr
	return;
            }
            0x82A162E0 => {
    //   block [0x82A162E0..0x82A16324)
	// 82A162E0: 40980044  bge cr6, 0x82a16324
	if !ctx.cr[6].lt {
	pc = 0x82A16324; continue 'dispatch;
	}
	// 82A162E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A162E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A162EC: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82A162F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A162F4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A162F8: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A162FC: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82A16300: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A16304: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A16308: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A1630C: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A16310: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A16314: 7CAB4A14  add r5, r11, r9
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A16318: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 82A1631C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A16320: 48000191  bl 0x82a164b0
	ctx.lr = 0x82A16324;
	sub_82A164B0(ctx, base);
	pc = 0x82A16324; continue 'dispatch;
            }
            0x82A16324 => {
    //   block [0x82A16324..0x82A16334)
	// 82A16324: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A16328: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1632C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A16330: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A16338(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A16338 size=188
    let mut pc: u32 = 0x82A16338;
    'dispatch: loop {
        match pc {
            0x82A16338 => {
    //   block [0x82A16338..0x82A163A0)
	// 82A16338: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1633C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A16340: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A16344: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A16348: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1634C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A16350: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82A16354: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 82A16358: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A1635C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16360: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16364: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A16368: 7CE82050  subf r7, r8, r4
	ctx.r[7].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 82A1636C: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82A16370: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 82A16374: 7D274BD6  divw r9, r7, r9
	ctx.r[9].s32 = ctx.r[7].s32 / ctx.r[9].s32;
	// 82A16378: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82A1637C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A16380: 40990020  ble cr6, 0x82a163a0
	if !ctx.cr[6].gt {
	pc = 0x82A163A0; continue 'dispatch;
	}
	// 82A16384: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82A16388: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82A1638C: 7CA95850  subf r5, r9, r11
	ctx.r[5].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A16390: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A16394: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A16398: 48000211  bl 0x82a165a8
	ctx.lr = 0x82A1639C;
	sub_82A165A8(ctx, base);
	// 82A1639C: 48000040  b 0x82a163dc
	pc = 0x82A163DC; continue 'dispatch;
            }
            0x82A163A0 => {
    //   block [0x82A163A0..0x82A163DC)
	// 82A163A0: 4098003C  bge cr6, 0x82a163dc
	if !ctx.cr[6].lt {
	pc = 0x82A163DC; continue 'dispatch;
	}
	// 82A163A4: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A163A8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A163AC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A163B0: 7CAB4214  add r5, r11, r8
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82A163B4: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A163B8: 419A0024  beq cr6, 0x82a163dc
	if ctx.cr[6].eq {
	pc = 0x82A163DC; continue 'dispatch;
	}
	// 82A163BC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82A163C0: 480005B1  bl 0x82a16970
	ctx.lr = 0x82A163C4;
	sub_82A16970(ctx, base);
	// 82A163C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A163C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A163CC: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A163D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A163D4: 48000025  bl 0x82a163f8
	ctx.lr = 0x82A163D8;
	sub_82A163F8(ctx, base);
	// 82A163D8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x82A163DC; continue 'dispatch;
            }
            0x82A163DC => {
    //   block [0x82A163DC..0x82A163F4)
	// 82A163DC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A163E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A163E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A163E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A163EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A163F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A163F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A163F8 size=84
    let mut pc: u32 = 0x82A163F8;
    'dispatch: loop {
        match pc {
            0x82A163F8 => {
    //   block [0x82A163F8..0x82A16418)
	// 82A163F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A163FC: 48293011  bl 0x82ca940c
	ctx.lr = 0x82A16400;
	sub_82CA93D0(ctx, base);
	// 82A16400: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A16404: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A16408: 7F04E840  cmplw cr6, r4, r29
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A1640C: 419A0038  beq cr6, 0x82a16444
	if ctx.cr[6].eq {
	pc = 0x82A16444; continue 'dispatch;
	}
	// 82A16410: 3BE40004  addi r31, r4, 4
	ctx.r[31].s64 = ctx.r[4].s64 + 4;
	// 82A16414: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82A16418; continue 'dispatch;
            }
            0x82A16418 => {
    //   block [0x82A16418..0x82A16428)
	// 82A16418: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1641C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A16420: 419A0008  beq cr6, 0x82a16428
	if ctx.cr[6].eq {
	pc = 0x82A16428; continue 'dispatch;
	}
	// 82A16424: 4B805915  bl 0x8221bd38
	ctx.lr = 0x82A16428;
	sub_8221BD38(ctx, base);
	pc = 0x82A16428; continue 'dispatch;
            }
            0x82A16428 => {
    //   block [0x82A16428..0x82A16444)
	// 82A16428: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A1642C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A16430: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A16434: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 82A16438: 397FFFFC  addi r11, r31, -4
	ctx.r[11].s64 = ctx.r[31].s64 + -4;
	// 82A1643C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A16440: 409AFFD8  bne cr6, 0x82a16418
	if !ctx.cr[6].eq {
	pc = 0x82A16418; continue 'dispatch;
	}
	pc = 0x82A16444; continue 'dispatch;
            }
            0x82A16444 => {
    //   block [0x82A16444..0x82A1644C)
	// 82A16444: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A16448: 48293014  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A16450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A16450 size=96
    let mut pc: u32 = 0x82A16450;
    'dispatch: loop {
        match pc {
            0x82A16450 => {
    //   block [0x82A16450..0x82A16478)
	// 82A16450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A16454: 48292FB1  bl 0x82ca9404
	ctx.lr = 0x82A16458;
	sub_82CA93D0(ctx, base);
	// 82A16458: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1645C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A16460: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A16464: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82A16468: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82A1646C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82A16470: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A16474: 419A0024  beq cr6, 0x82a16498
	if ctx.cr[6].eq {
	pc = 0x82A16498; continue 'dispatch;
	}
	pc = 0x82A16478; continue 'dispatch;
            }
            0x82A16478 => {
    //   block [0x82A16478..0x82A1648C)
	// 82A16478: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A1647C: 419A0010  beq cr6, 0x82a1648c
	if ctx.cr[6].eq {
	pc = 0x82A1648C; continue 'dispatch;
	}
	// 82A16480: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A16484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A16488: 48000421  bl 0x82a168a8
	ctx.lr = 0x82A1648C;
	sub_82A168A8(ctx, base);
	pc = 0x82A1648C; continue 'dispatch;
            }
            0x82A1648C => {
    //   block [0x82A1648C..0x82A16498)
	// 82A1648C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A16490: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 82A16494: 4082FFE4  bne 0x82a16478
	if !ctx.cr[0].eq {
	pc = 0x82A16478; continue 'dispatch;
	}
	pc = 0x82A16498; continue 'dispatch;
            }
            0x82A16498 => {
    //   block [0x82A16498..0x82A164B0)
	// 82A16498: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1649C: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82A164A0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A164A4: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82A164A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A164AC: 48292FA8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A164B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A164B0 size=120
    let mut pc: u32 = 0x82A164B0;
    'dispatch: loop {
        match pc {
            0x82A164B0 => {
    //   block [0x82A164B0..0x82A164F4)
	// 82A164B0: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 82A164B4: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 82A164B8: 80E10024  lwz r7, 0x24(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A164BC: 8161002C  lwz r11, 0x2c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A164C0: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A164C4: 419A005C  beq cr6, 0x82a16520
	if ctx.cr[6].eq {
	pc = 0x82A16520; continue 'dispatch;
	}
	// 82A164C8: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A164CC: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 82A164D0: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A164D4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A164D8: 7D284BD6  divw r9, r8, r9
	ctx.r[9].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 82A164DC: 5528083C  slwi r8, r9, 1
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A164E0: 7CC94214  add r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82A164E4: 54C9103A  slwi r9, r6, 2
	ctx.r[9].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A164E8: 7D093A14  add r8, r9, r7
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[7].u64;
	// 82A164EC: 419A0030  beq cr6, 0x82a1651c
	if ctx.cr[6].eq {
	pc = 0x82A1651C; continue 'dispatch;
	}
	// 82A164F0: 7D2B3850  subf r9, r11, r7
	ctx.r[9].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	pc = 0x82A164F4; continue 'dispatch;
            }
            0x82A164F4 => {
    //   block [0x82A164F4..0x82A1651C)
	// 82A164F4: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A164F8: 7CC95A14  add r6, r9, r11
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82A164FC: 7CE9592E  stwx r7, r9, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 82A16500: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16504: 90E60004  stw r7, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A16508: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1650C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82A16510: 90E60008  stw r7, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82A16514: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A16518: 409AFFDC  bne cr6, 0x82a164f4
	if !ctx.cr[6].eq {
	pc = 0x82A164F4; continue 'dispatch;
	}
	pc = 0x82A1651C; continue 'dispatch;
            }
            0x82A1651C => {
    //   block [0x82A1651C..0x82A16520)
	// 82A1651C: 91040008  stw r8, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x82A16520; continue 'dispatch;
            }
            0x82A16520 => {
    //   block [0x82A16520..0x82A16528)
	// 82A16520: F8A30000  std r5, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82A16524: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A16528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A16528 size=124
    let mut pc: u32 = 0x82A16528;
    'dispatch: loop {
        match pc {
            0x82A16528 => {
    //   block [0x82A16528..0x82A1655C)
	// 82A16528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1652C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A16530: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A16534: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A16538: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1653C: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 82A16540: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A16544: 616A5555  ori r10, r11, 0x5555
	ctx.r[10].u64 = ctx.r[11].u64 | 21845;
	// 82A16548: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1654C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A16550: 4099000C  ble cr6, 0x82a1655c
	if !ctx.cr[6].gt {
	pc = 0x82A1655C; continue 'dispatch;
	}
	// 82A16554: 48030F75  bl 0x82a474c8
	ctx.lr = 0x82A16558;
	sub_82A474C8(ctx, base);
	// 82A16558: 48000030  b 0x82a16588
	pc = 0x82A16588; continue 'dispatch;
            }
            0x82A1655C => {
    //   block [0x82A1655C..0x82A16588)
	// 82A1655C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A16560: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A16564: 4B90CE4D  bl 0x823233b0
	ctx.lr = 0x82A16568;
	sub_823233B0(ctx, base);
	// 82A16568: 57CA083C  slwi r10, r30, 1
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1656C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A16570: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82A16574: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A16578: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1657C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A16580: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A16584: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	pc = 0x82A16588; continue 'dispatch;
            }
            0x82A16588 => {
    //   block [0x82A16588..0x82A165A4)
	// 82A16588: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A1658C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A16590: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A16594: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A16598: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1659C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A165A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A165A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A165A8 size=768
    let mut pc: u32 = 0x82A165A8;
    'dispatch: loop {
        match pc {
            0x82A165A8 => {
    //   block [0x82A165A8..0x82A165E4)
	// 82A165A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A165AC: 48292E49  bl 0x82ca93f4
	ctx.lr = 0x82A165B0;
	sub_82CA93D0(ctx, base);
	// 82A165B0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A165B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A165B8: F88100D8  std r4, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[4].u64 ) };
	// 82A165BC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A165C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A165C4: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82A165C8: 480002E1  bl 0x82a168a8
	ctx.lr = 0x82A165CC;
	sub_82A168A8(ctx, base);
	// 82A165CC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A165D0: 3AE00014  li r23, 0x14
	ctx.r[23].s64 = 20;
	// 82A165D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A165D8: 409A000C  bne cr6, 0x82a165e4
	if !ctx.cr[6].eq {
	pc = 0x82A165E4; continue 'dispatch;
	}
	// 82A165DC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A165E0: 48000010  b 0x82a165f0
	pc = 0x82A165F0; continue 'dispatch;
            }
            0x82A165E4 => {
    //   block [0x82A165E4..0x82A165F0)
	// 82A165E4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A165E8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A165EC: 7D29BBD6  divw r9, r9, r23
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[23].s32;
	pc = 0x82A165F0; continue 'dispatch;
            }
            0x82A165F0 => {
    //   block [0x82A165F0..0x82A16620)
	// 82A165F0: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82A165F4: 419A029C  beq cr6, 0x82a16890
	if ctx.cr[6].eq {
	pc = 0x82A16890; continue 'dispatch;
	}
	// 82A165F8: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A165FC: 3D400CCC  lis r10, 0xccc
	ctx.r[10].s64 = 214695936;
	// 82A16600: 7D0BE850  subf r8, r11, r29
	ctx.r[8].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 82A16604: 614ACCCC  ori r10, r10, 0xcccc
	ctx.r[10].u64 = ctx.r[10].u64 | 52428;
	// 82A16608: 7D68BBD6  divw r11, r8, r23
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[23].s32;
	// 82A1660C: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A16610: 7F07C840  cmplw cr6, r7, r25
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A16614: 4098000C  bge cr6, 0x82a16620
	if !ctx.cr[6].lt {
	pc = 0x82A16620; continue 'dispatch;
	}
	// 82A16618: 48030EB1  bl 0x82a474c8
	ctx.lr = 0x82A1661C;
	sub_82A474C8(ctx, base);
	// 82A1661C: 48000274  b 0x82a16890
	pc = 0x82A16890; continue 'dispatch;
            }
            0x82A16620 => {
    //   block [0x82A16620..0x82A16644)
	// 82A16620: 7D0BCA14  add r8, r11, r25
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 82A16624: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A16628: 40980118  bge cr6, 0x82a16740
	if !ctx.cr[6].lt {
	pc = 0x82A16740; continue 'dispatch;
	}
	// 82A1662C: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A16630: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82A16634: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A16638: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1663C: 41980008  blt cr6, 0x82a16644
	if ctx.cr[6].lt {
	pc = 0x82A16644; continue 'dispatch;
	}
	// 82A16640: 7F0B4A14  add r24, r11, r9
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A16644; continue 'dispatch;
            }
            0x82A16644 => {
    //   block [0x82A16644..0x82A16650)
	// 82A16644: 7F184040  cmplw cr6, r24, r8
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A16648: 40980008  bge cr6, 0x82a16650
	if !ctx.cr[6].lt {
	pc = 0x82A16650; continue 'dispatch;
	}
	// 82A1664C: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	pc = 0x82A16650; continue 'dispatch;
            }
            0x82A16650 => {
    //   block [0x82A16650..0x82A16674)
	// 82A16650: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A16654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A16658: 4BA4CCD1  bl 0x82463328
	ctx.lr = 0x82A1665C;
	sub_82463328(ctx, base);
	// 82A1665C: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16660: 838100DC  lwz r28, 0xdc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A16664: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A16668: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A1666C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82A16670: 419A0028  beq cr6, 0x82a16698
	if ctx.cr[6].eq {
	pc = 0x82A16698; continue 'dispatch;
	}
	pc = 0x82A16674; continue 'dispatch;
            }
            0x82A16674 => {
    //   block [0x82A16674..0x82A16688)
	// 82A16674: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A16678: 419A0010  beq cr6, 0x82a16688
	if ctx.cr[6].eq {
	pc = 0x82A16688; continue 'dispatch;
	}
	// 82A1667C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A16680: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A16684: 48000225  bl 0x82a168a8
	ctx.lr = 0x82A16688;
	sub_82A168A8(ctx, base);
	pc = 0x82A16688; continue 'dispatch;
            }
            0x82A16688 => {
    //   block [0x82A16688..0x82A16698)
	// 82A16688: 3BDE0014  addi r30, r30, 0x14
	ctx.r[30].s64 = ctx.r[30].s64 + 20;
	// 82A1668C: 3BBD0014  addi r29, r29, 0x14
	ctx.r[29].s64 = ctx.r[29].s64 + 20;
	// 82A16690: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A16694: 409AFFE0  bne cr6, 0x82a16674
	if !ctx.cr[6].eq {
	pc = 0x82A16674; continue 'dispatch;
	}
	pc = 0x82A16698; continue 'dispatch;
            }
            0x82A16698 => {
    //   block [0x82A16698..0x82A166C0)
	// 82A16698: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A1669C: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82A166A0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A166A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A166A8: 4BFFFDA9  bl 0x82a16450
	ctx.lr = 0x82A166AC;
	sub_82A16450(ctx, base);
	// 82A166AC: 837F0008  lwz r27, 8(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A166B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A166B4: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A166B8: 419A002C  beq cr6, 0x82a166e4
	if ctx.cr[6].eq {
	pc = 0x82A166E4; continue 'dispatch;
	}
	// 82A166BC: 7FA3E050  subf r29, r3, r28
	ctx.r[29].s64 = ctx.r[28].s64 - ctx.r[3].s64;
	pc = 0x82A166C0; continue 'dispatch;
            }
            0x82A166C0 => {
    //   block [0x82A166C0..0x82A166D4)
	// 82A166C0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A166C4: 419A0010  beq cr6, 0x82a166d4
	if ctx.cr[6].eq {
	pc = 0x82A166D4; continue 'dispatch;
	}
	// 82A166C8: 7C9DF214  add r4, r29, r30
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 82A166CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A166D0: 480001D9  bl 0x82a168a8
	ctx.lr = 0x82A166D4;
	sub_82A168A8(ctx, base);
	pc = 0x82A166D4; continue 'dispatch;
            }
            0x82A166D4 => {
    //   block [0x82A166D4..0x82A166E4)
	// 82A166D4: 3BDE0014  addi r30, r30, 0x14
	ctx.r[30].s64 = ctx.r[30].s64 + 20;
	// 82A166D8: 7D7DF214  add r11, r29, r30
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 82A166DC: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82A166E0: 409AFFE0  bne cr6, 0x82a166c0
	if !ctx.cr[6].eq {
	pc = 0x82A166C0; continue 'dispatch;
	}
	pc = 0x82A166E4; continue 'dispatch;
            }
            0x82A166E4 => {
    //   block [0x82A166E4..0x82A16710)
	// 82A166E4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A166E8: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A166EC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A166F0: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 82A166F4: 7D6BBBD6  divw r11, r11, r23
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[23].s32;
	// 82A166F8: 7FCBCA14  add r30, r11, r25
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 82A166FC: 419A0014  beq cr6, 0x82a16710
	if ctx.cr[6].eq {
	pc = 0x82A16710; continue 'dispatch;
	}
	// 82A16700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A16704: 4BFFFCF5  bl 0x82a163f8
	ctx.lr = 0x82A16708;
	sub_82A163F8(ctx, base);
	// 82A16708: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1670C: 4B80562D  bl 0x8221bd38
	ctx.lr = 0x82A16710;
	sub_8221BD38(ctx, base);
	pc = 0x82A16710; continue 'dispatch;
            }
            0x82A16710 => {
    //   block [0x82A16710..0x82A16740)
	// 82A16710: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A16714: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82A16718: 570A103A  slwi r10, r24, 2
	ctx.r[10].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1671C: 7D3E5A14  add r9, r30, r11
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82A16720: 7D585214  add r10, r24, r10
	ctx.r[10].u64 = ctx.r[24].u64 + ctx.r[10].u64;
	// 82A16724: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A16728: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1672C: 7CEBD214  add r7, r11, r26
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82A16730: 7D0AD214  add r8, r10, r26
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 82A16734: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82A16738: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82A1673C: 48000154  b 0x82a16890
	pc = 0x82A16890; continue 'dispatch;
            }
            0x82A16740 => {
    //   block [0x82A16740..0x82A16770)
	// 82A16740: 83C100DC  lwz r30, 0xdc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A16744: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82A16748: 7D4BBBD6  divw r10, r11, r23
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[23].s32;
	// 82A1674C: 572B103A  slwi r11, r25, 2
	ctx.r[11].u32 = ctx.r[25].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A16750: 7F0AC840  cmplw cr6, r10, r25
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82A16754: 7D795A14  add r11, r25, r11
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[11].u64;
	// 82A16758: 40980094  bge cr6, 0x82a167ec
	if !ctx.cr[6].lt {
	pc = 0x82A167EC; continue 'dispatch;
	}
	// 82A1675C: 557A103A  slwi r26, r11, 2
	ctx.r[26].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 82A16760: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A16764: 7F9AF214  add r28, r26, r30
	ctx.r[28].u64 = ctx.r[26].u64 + ctx.r[30].u64;
	// 82A16768: 419A002C  beq cr6, 0x82a16794
	if ctx.cr[6].eq {
	pc = 0x82A16794; continue 'dispatch;
	}
	// 82A1676C: 7F7AE050  subf r27, r26, r28
	ctx.r[27].s64 = ctx.r[28].s64 - ctx.r[26].s64;
	pc = 0x82A16770; continue 'dispatch;
            }
            0x82A16770 => {
    //   block [0x82A16770..0x82A16784)
	// 82A16770: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A16774: 419A0010  beq cr6, 0x82a16784
	if ctx.cr[6].eq {
	pc = 0x82A16784; continue 'dispatch;
	}
	// 82A16778: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A1677C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A16780: 48000129  bl 0x82a168a8
	ctx.lr = 0x82A16784;
	sub_82A168A8(ctx, base);
	pc = 0x82A16784; continue 'dispatch;
            }
            0x82A16784 => {
    //   block [0x82A16784..0x82A16794)
	// 82A16784: 3B7B0014  addi r27, r27, 0x14
	ctx.r[27].s64 = ctx.r[27].s64 + 20;
	// 82A16788: 3B9C0014  addi r28, r28, 0x14
	ctx.r[28].s64 = ctx.r[28].s64 + 20;
	// 82A1678C: 7F1BE840  cmplw cr6, r27, r29
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A16790: 409AFFE0  bne cr6, 0x82a16770
	if !ctx.cr[6].eq {
	pc = 0x82A16770; continue 'dispatch;
	}
	pc = 0x82A16794; continue 'dispatch;
            }
            0x82A16794 => {
    //   block [0x82A16794..0x82A167CC)
	// 82A16794: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16798: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A1679C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A167A0: 7D7E2050  subf r11, r30, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 82A167A4: 7D4BBBD6  divw r10, r11, r23
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[23].s32;
	// 82A167A8: 7CAAC850  subf r5, r10, r25
	ctx.r[5].s64 = ctx.r[25].s64 - ctx.r[10].s64;
	// 82A167AC: 4BFFFCA5  bl 0x82a16450
	ctx.lr = 0x82A167B0;
	sub_82A16450(ctx, base);
	// 82A167B0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A167B4: 7D7A5A14  add r11, r26, r11
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 82A167B8: 7FBA5850  subf r29, r26, r11
	ctx.r[29].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 82A167BC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A167C0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A167C4: 419A00CC  beq cr6, 0x82a16890
	if ctx.cr[6].eq {
	pc = 0x82A16890; continue 'dispatch;
	}
	// 82A167C8: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	pc = 0x82A167CC; continue 'dispatch;
            }
            0x82A167CC => {
    //   block [0x82A167CC..0x82A167EC)
	// 82A167CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A167D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A167D4: 4800020D  bl 0x82a169e0
	ctx.lr = 0x82A167D8;
	sub_82A169E0(ctx, base);
	// 82A167D8: 93FE0010  stw r31, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82A167DC: 3BDE0014  addi r30, r30, 0x14
	ctx.r[30].s64 = ctx.r[30].s64 + 20;
	// 82A167E0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A167E4: 409AFFE8  bne cr6, 0x82a167cc
	if !ctx.cr[6].eq {
	pc = 0x82A167CC; continue 'dispatch;
	}
	// 82A167E8: 480000A8  b 0x82a16890
	pc = 0x82A16890; continue 'dispatch;
            }
            0x82A167EC => {
    //   block [0x82A167EC..0x82A16804)
	// 82A167EC: 5579103A  slwi r25, r11, 2
	ctx.r[25].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 82A167F0: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82A167F4: 7F59E850  subf r26, r25, r29
	ctx.r[26].s64 = ctx.r[29].s64 - ctx.r[25].s64;
	// 82A167F8: 7F5BD378  mr r27, r26
	ctx.r[27].u64 = ctx.r[26].u64;
	// 82A167FC: 7F1AE840  cmplw cr6, r26, r29
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A16800: 419A0028  beq cr6, 0x82a16828
	if ctx.cr[6].eq {
	pc = 0x82A16828; continue 'dispatch;
	}
	pc = 0x82A16804; continue 'dispatch;
            }
            0x82A16804 => {
    //   block [0x82A16804..0x82A16818)
	// 82A16804: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82A16808: 419A0010  beq cr6, 0x82a16818
	if ctx.cr[6].eq {
	pc = 0x82A16818; continue 'dispatch;
	}
	// 82A1680C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A16810: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A16814: 48000095  bl 0x82a168a8
	ctx.lr = 0x82A16818;
	sub_82A168A8(ctx, base);
	pc = 0x82A16818; continue 'dispatch;
            }
            0x82A16818 => {
    //   block [0x82A16818..0x82A16828)
	// 82A16818: 3B7B0014  addi r27, r27, 0x14
	ctx.r[27].s64 = ctx.r[27].s64 + 20;
	// 82A1681C: 3B9C0014  addi r28, r28, 0x14
	ctx.r[28].s64 = ctx.r[28].s64 + 20;
	// 82A16820: 7F1BE840  cmplw cr6, r27, r29
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A16824: 409AFFE0  bne cr6, 0x82a16804
	if !ctx.cr[6].eq {
	pc = 0x82A16804; continue 'dispatch;
	}
	pc = 0x82A16828; continue 'dispatch;
            }
            0x82A16828 => {
    //   block [0x82A16828..0x82A1683C)
	// 82A16828: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82A1682C: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 82A16830: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A16834: 419A002C  beq cr6, 0x82a16860
	if ctx.cr[6].eq {
	pc = 0x82A16860; continue 'dispatch;
	}
	// 82A16838: 7FB9FA14  add r29, r25, r31
	ctx.r[29].u64 = ctx.r[25].u64 + ctx.r[31].u64;
	pc = 0x82A1683C; continue 'dispatch;
            }
            0x82A1683C => {
    //   block [0x82A1683C..0x82A16860)
	// 82A1683C: 3BFFFFEC  addi r31, r31, -0x14
	ctx.r[31].s64 = ctx.r[31].s64 + -20;
	// 82A16840: 3BBDFFEC  addi r29, r29, -0x14
	ctx.r[29].s64 = ctx.r[29].s64 + -20;
	// 82A16844: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A16848: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1684C: 48000195  bl 0x82a169e0
	ctx.lr = 0x82A16850;
	sub_82A169E0(ctx, base);
	// 82A16850: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A16854: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A16858: 917D0010  stw r11, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A1685C: 409AFFE0  bne cr6, 0x82a1683c
	if !ctx.cr[6].eq {
	pc = 0x82A1683C; continue 'dispatch;
	}
	pc = 0x82A16860; continue 'dispatch;
            }
            0x82A16860 => {
    //   block [0x82A16860..0x82A16874)
	// 82A16860: 7FB9F214  add r29, r25, r30
	ctx.r[29].u64 = ctx.r[25].u64 + ctx.r[30].u64;
	// 82A16864: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82A16868: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A1686C: 419A0024  beq cr6, 0x82a16890
	if ctx.cr[6].eq {
	pc = 0x82A16890; continue 'dispatch;
	}
	// 82A16870: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	pc = 0x82A16874; continue 'dispatch;
            }
            0x82A16874 => {
    //   block [0x82A16874..0x82A16890)
	// 82A16874: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A16878: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1687C: 48000165  bl 0x82a169e0
	ctx.lr = 0x82A16880;
	sub_82A169E0(ctx, base);
	// 82A16880: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82A16884: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 82A16888: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A1688C: 409AFFE8  bne cr6, 0x82a16874
	if !ctx.cr[6].eq {
	pc = 0x82A16874; continue 'dispatch;
	}
	pc = 0x82A16890; continue 'dispatch;
            }
            0x82A16890 => {
    //   block [0x82A16890..0x82A168A0)
	// 82A16890: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A16894: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A16898: 419A0008  beq cr6, 0x82a168a0
	if ctx.cr[6].eq {
	pc = 0x82A168A0; continue 'dispatch;
	}
	// 82A1689C: 4B80549D  bl 0x8221bd38
	ctx.lr = 0x82A168A0;
	sub_8221BD38(ctx, base);
	pc = 0x82A168A0; continue 'dispatch;
            }
            0x82A168A0 => {
    //   block [0x82A168A0..0x82A168A8)
	// 82A168A0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A168A4: 48292BA0  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A168A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A168A8 size=200
    let mut pc: u32 = 0x82A168A8;
    'dispatch: loop {
        match pc {
            0x82A168A8 => {
    //   block [0x82A168A8..0x82A168EC)
	// 82A168A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A168AC: 48292B61  bl 0x82ca940c
	ctx.lr = 0x82A168B0;
	sub_82CA93D0(ctx, base);
	// 82A168B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A168B4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A168B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A168BC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A168C0: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 82A168C4: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A168C8: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A168CC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A168D0: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A168D4: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A168D8: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82A168DC: 7C8853D7  divw. r4, r8, r10
	ctx.r[4].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82A168E0: 4082000C  bne 0x82a168ec
	if !ctx.cr[0].eq {
	pc = 0x82A168EC; continue 'dispatch;
	}
	// 82A168E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A168E8: 4800000C  b 0x82a168f4
	pc = 0x82A168F4; continue 'dispatch;
            }
            0x82A168EC => {
    //   block [0x82A168EC..0x82A168F4)
	// 82A168EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A168F0: 4BFFFC39  bl 0x82a16528
	ctx.lr = 0x82A168F4;
	sub_82A16528(ctx, base);
	pc = 0x82A168F4; continue 'dispatch;
            }
            0x82A168F4 => {
    //   block [0x82A168F4..0x82A16928)
	// 82A168F4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A168F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A168FC: 419A0060  beq cr6, 0x82a1695c
	if ctx.cr[6].eq {
	pc = 0x82A1695C; continue 'dispatch;
	}
	// 82A16900: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16904: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16908: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A1690C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A16910: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16914: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A16918: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A1691C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82A16920: 419A0038  beq cr6, 0x82a16958
	if ctx.cr[6].eq {
	pc = 0x82A16958; continue 'dispatch;
	}
	// 82A16924: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82A16928; continue 'dispatch;
            }
            0x82A16928 => {
    //   block [0x82A16928..0x82A16948)
	// 82A16928: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1692C: 419A001C  beq cr6, 0x82a16948
	if ctx.cr[6].eq {
	pc = 0x82A16948; continue 'dispatch;
	}
	// 82A16930: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A16934: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A16938: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1693C: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A16940: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16944: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x82A16948; continue 'dispatch;
            }
            0x82A16948 => {
    //   block [0x82A16948..0x82A16958)
	// 82A16948: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82A1694C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82A16950: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A16954: 409AFFD4  bne cr6, 0x82a16928
	if !ctx.cr[6].eq {
	pc = 0x82A16928; continue 'dispatch;
	}
	pc = 0x82A16958; continue 'dispatch;
            }
            0x82A16958 => {
    //   block [0x82A16958..0x82A1695C)
	// 82A16958: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82A1695C; continue 'dispatch;
            }
            0x82A1695C => {
    //   block [0x82A1695C..0x82A16970)
	// 82A1695C: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A16960: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A16964: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A16968: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1696C: 48292AF0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A16970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A16970 size=108
    let mut pc: u32 = 0x82A16970;
    'dispatch: loop {
        match pc {
            0x82A16970 => {
    //   block [0x82A16970..0x82A169AC)
	// 82A16970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A16974: 48292A95  bl 0x82ca9408
	ctx.lr = 0x82A16978;
	sub_82CA93D0(ctx, base);
	// 82A16978: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1697C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A16980: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 82A16984: 7D63F050  subf r11, r3, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[3].s64;
	// 82A16988: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1698C: 7D6B53D6  divw r11, r11, r10
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	// 82A16990: 7F03F040  cmplw cr6, r3, r30
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A16994: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A16998: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A1699C: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A169A0: 7F8B2A14  add r28, r11, r5
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82A169A4: 419A002C  beq cr6, 0x82a169d0
	if ctx.cr[6].eq {
	pc = 0x82A169D0; continue 'dispatch;
	}
	// 82A169A8: 7FA32850  subf r29, r3, r5
	ctx.r[29].s64 = ctx.r[5].s64 - ctx.r[3].s64;
	pc = 0x82A169AC; continue 'dispatch;
            }
            0x82A169AC => {
    //   block [0x82A169AC..0x82A169D0)
	// 82A169AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A169B0: 7C7DFA14  add r3, r29, r31
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 82A169B4: 4800002D  bl 0x82a169e0
	ctx.lr = 0x82A169B8;
	sub_82A169E0(ctx, base);
	// 82A169B8: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A169BC: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 82A169C0: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 82A169C4: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A169C8: 7D5D592E  stwx r10, r29, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 82A169CC: 409AFFE0  bne cr6, 0x82a169ac
	if !ctx.cr[6].eq {
	pc = 0x82A169AC; continue 'dispatch;
	}
	pc = 0x82A169D0; continue 'dispatch;
            }
            0x82A169D0 => {
    //   block [0x82A169D0..0x82A169DC)
	// 82A169D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A169D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A169D8: 48292A80  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A169E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A169E0 size=584
    let mut pc: u32 = 0x82A169E0;
    'dispatch: loop {
        match pc {
            0x82A169E0 => {
    //   block [0x82A169E0..0x82A16A50)
	// 82A169E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A169E4: 48292A25  bl 0x82ca9408
	ctx.lr = 0x82A169E8;
	sub_82CA93D0(ctx, base);
	// 82A169E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A169EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A169F0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A169F4: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A169F8: 419A0224  beq cr6, 0x82a16c1c
	if ctx.cr[6].eq {
	pc = 0x82A16C1C; continue 'dispatch;
	}
	// 82A169FC: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16A00: 3B80000C  li r28, 0xc
	ctx.r[28].s64 = 12;
	// 82A16A04: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16A08: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82A16A0C: 7CEAE3D7  divw. r7, r10, r28
	ctx.r[7].s32 = ctx.r[10].s32 / ctx.r[28].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82A16A10: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16A14: 4082003C  bne 0x82a16a50
	if !ctx.cr[0].eq {
	pc = 0x82A16A50; continue 'dispatch;
	}
	// 82A16A18: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16A1C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A16A20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A16A24: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A16A28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A16A2C: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82A16A30: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A16A34: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A16A38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A16A3C: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A16A40: 4BFFFA71  bl 0x82a164b0
	ctx.lr = 0x82A16A44;
	sub_82A164B0(ctx, base);
	// 82A16A44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A16A48: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A16A4C: 48292A0C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A16A50 => {
    //   block [0x82A16A50..0x82A16A6C)
	// 82A16A50: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16A54: 7CCA4850  subf r6, r10, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82A16A58: 7D26E3D6  divw r9, r6, r28
	ctx.r[9].s32 = ctx.r[6].s32 / ctx.r[28].s32;
	// 82A16A5C: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A16A60: 41990068  bgt cr6, 0x82a16ac8
	if ctx.cr[6].gt {
	pc = 0x82A16AC8; continue 'dispatch;
	}
	// 82A16A64: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A16A68: 419A002C  beq cr6, 0x82a16a94
	if ctx.cr[6].eq {
	pc = 0x82A16A94; continue 'dispatch;
	}
	pc = 0x82A16A6C; continue 'dispatch;
            }
            0x82A16A6C => {
    //   block [0x82A16A6C..0x82A16A94)
	// 82A16A6C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A16A70: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A16A74: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16A78: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A16A7C: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16A80: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82A16A84: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82A16A88: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82A16A8C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A16A90: 409AFFDC  bne cr6, 0x82a16a6c
	if !ctx.cr[6].eq {
	pc = 0x82A16A6C; continue 'dispatch;
	}
	pc = 0x82A16A94; continue 'dispatch;
            }
            0x82A16A94 => {
    //   block [0x82A16A94..0x82A16AC8)
	// 82A16A94: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16A98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A16A9C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16AA0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16AA4: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A16AA8: 7D68E3D6  divw r11, r8, r28
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[28].s32;
	// 82A16AAC: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A16AB0: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A16AB4: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A16AB8: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A16ABC: 90DE0008  stw r6, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82A16AC0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A16AC4: 48292994  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A16AC8 => {
    //   block [0x82A16AC8..0x82A16ADC)
	// 82A16AC8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A16ACC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A16AD0: 409A000C  bne cr6, 0x82a16adc
	if !ctx.cr[6].eq {
	pc = 0x82A16ADC; continue 'dispatch;
	}
	// 82A16AD4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82A16AD8: 48000010  b 0x82a16ae8
	pc = 0x82A16AE8; continue 'dispatch;
            }
            0x82A16ADC => {
    //   block [0x82A16ADC..0x82A16AE8)
	// 82A16ADC: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A16AE0: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A16AE4: 7D68E3D6  divw r11, r8, r28
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[28].s32;
	pc = 0x82A16AE8; continue 'dispatch;
            }
            0x82A16AE8 => {
    //   block [0x82A16AE8..0x82A16B0C)
	// 82A16AE8: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A16AEC: 4199009C  bgt cr6, 0x82a16b88
	if ctx.cr[6].gt {
	pc = 0x82A16B88; continue 'dispatch;
	}
	// 82A16AF0: 5528083C  slwi r8, r9, 1
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A16AF4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16AF8: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82A16AFC: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A16B00: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82A16B04: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A16B08: 419A002C  beq cr6, 0x82a16b34
	if ctx.cr[6].eq {
	pc = 0x82A16B34; continue 'dispatch;
	}
	pc = 0x82A16B0C; continue 'dispatch;
            }
            0x82A16B0C => {
    //   block [0x82A16B0C..0x82A16B34)
	// 82A16B0C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A16B10: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A16B14: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16B18: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A16B1C: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16B20: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82A16B24: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82A16B28: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82A16B2C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A16B30: 409AFFDC  bne cr6, 0x82a16b0c
	if !ctx.cr[6].eq {
	pc = 0x82A16B0C; continue 'dispatch;
	}
	pc = 0x82A16B34; continue 'dispatch;
            }
            0x82A16B34 => {
    //   block [0x82A16B34..0x82A16B48)
	// 82A16B34: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16B38: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 82A16B3C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16B40: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A16B44: 419A00D4  beq cr6, 0x82a16c18
	if ctx.cr[6].eq {
	pc = 0x82A16C18; continue 'dispatch;
	}
	pc = 0x82A16B48; continue 'dispatch;
            }
            0x82A16B48 => {
    //   block [0x82A16B48..0x82A16B68)
	// 82A16B48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A16B4C: 419A001C  beq cr6, 0x82a16b68
	if ctx.cr[6].eq {
	pc = 0x82A16B68; continue 'dispatch;
	}
	// 82A16B50: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A16B54: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A16B58: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16B5C: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A16B60: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16B64: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x82A16B68; continue 'dispatch;
            }
            0x82A16B68 => {
    //   block [0x82A16B68..0x82A16B88)
	// 82A16B68: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82A16B6C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82A16B70: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A16B74: 409AFFD4  bne cr6, 0x82a16b48
	if !ctx.cr[6].eq {
	pc = 0x82A16B48; continue 'dispatch;
	}
	// 82A16B78: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A16B7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A16B80: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A16B84: 482928D4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A16B88 => {
    //   block [0x82A16B88..0x82A16B98)
	// 82A16B88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A16B8C: 419A000C  beq cr6, 0x82a16b98
	if ctx.cr[6].eq {
	pc = 0x82A16B98; continue 'dispatch;
	}
	// 82A16B90: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82A16B94: 4B8051A5  bl 0x8221bd38
	ctx.lr = 0x82A16B98;
	sub_8221BD38(ctx, base);
	pc = 0x82A16B98; continue 'dispatch;
            }
            0x82A16B98 => {
    //   block [0x82A16B98..0x82A16BC0)
	// 82A16B98: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16B9C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16BA0: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82A16BA4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A16BA8: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82A16BAC: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82A16BB0: 7C89E3D7  divw. r4, r9, r28
	ctx.r[4].s32 = ctx.r[9].s32 / ctx.r[28].s32;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82A16BB4: 4082000C  bne 0x82a16bc0
	if !ctx.cr[0].eq {
	pc = 0x82A16BC0; continue 'dispatch;
	}
	// 82A16BB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A16BBC: 4800000C  b 0x82a16bc8
	pc = 0x82A16BC8; continue 'dispatch;
            }
            0x82A16BC0 => {
    //   block [0x82A16BC0..0x82A16BC8)
	// 82A16BC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A16BC4: 4BFFF965  bl 0x82a16528
	ctx.lr = 0x82A16BC8;
	sub_82A16528(ctx, base);
	pc = 0x82A16BC8; continue 'dispatch;
            }
            0x82A16BC8 => {
    //   block [0x82A16BC8..0x82A16BE8)
	// 82A16BC8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A16BCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A16BD0: 419A004C  beq cr6, 0x82a16c1c
	if ctx.cr[6].eq {
	pc = 0x82A16C1C; continue 'dispatch;
	}
	// 82A16BD4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16BD8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16BDC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16BE0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A16BE4: 419A0034  beq cr6, 0x82a16c18
	if ctx.cr[6].eq {
	pc = 0x82A16C18; continue 'dispatch;
	}
	pc = 0x82A16BE8; continue 'dispatch;
            }
            0x82A16BE8 => {
    //   block [0x82A16BE8..0x82A16C08)
	// 82A16BE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A16BEC: 419A001C  beq cr6, 0x82a16c08
	if ctx.cr[6].eq {
	pc = 0x82A16C08; continue 'dispatch;
	}
	// 82A16BF0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A16BF4: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A16BF8: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16BFC: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A16C00: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16C04: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x82A16C08; continue 'dispatch;
            }
            0x82A16C08 => {
    //   block [0x82A16C08..0x82A16C18)
	// 82A16C08: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 82A16C0C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 82A16C10: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A16C14: 409AFFD4  bne cr6, 0x82a16be8
	if !ctx.cr[6].eq {
	pc = 0x82A16BE8; continue 'dispatch;
	}
	pc = 0x82A16C18; continue 'dispatch;
            }
            0x82A16C18 => {
    //   block [0x82A16C18..0x82A16C1C)
	// 82A16C18: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82A16C1C; continue 'dispatch;
            }
            0x82A16C1C => {
    //   block [0x82A16C1C..0x82A16C28)
	// 82A16C1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A16C20: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A16C24: 48292834  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A16C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A16C28 size=944
    let mut pc: u32 = 0x82A16C28;
    'dispatch: loop {
        match pc {
            0x82A16C28 => {
    //   block [0x82A16C28..0x82A16C98)
	// 82A16C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A16C2C: 482927C5  bl 0x82ca93f0
	ctx.lr = 0x82A16C30;
	sub_82CA93D0(ctx, base);
	// 82A16C30: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A16C34: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 82A16C38: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A16C3C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A16C40: 4BE31371  bl 0x82847fb0
	ctx.lr = 0x82A16C44;
	sub_82847FB0(ctx, base);
	// 82A16C44: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A16C48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A16C4C: 3B0BD5C8  addi r24, r11, -0x2a38
	ctx.r[24].s64 = ctx.r[11].s64 + -10808;
	// 82A16C50: 3898D110  addi r4, r24, -0x2ef0
	ctx.r[4].s64 = ctx.r[24].s64 + -12016;
	// 82A16C54: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A16C58: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16C5C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A16C60: 4E800421  bctrl
	ctx.lr = 0x82A16C64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A16C64: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A16C68: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A16C6C: 419A0340  beq cr6, 0x82a16fac
	if ctx.cr[6].eq {
	pc = 0x82A16FAC; continue 'dispatch;
	}
	// 82A16C70: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 82A16C74: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A16C78: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82A16C7C: 3B2BFFDF  addi r25, r11, -0x21
	ctx.r[25].s64 = ctx.r[11].s64 + -33;
	// 82A16C80: 92E10058  stw r23, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 82A16C84: 817FE878  lwz r11, -0x1788(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-6024 as u32) ) } as u64;
	// 82A16C88: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A16C8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A16C90: 419A0008  beq cr6, 0x82a16c98
	if ctx.cr[6].eq {
	pc = 0x82A16C98; continue 'dispatch;
	}
	// 82A16C94: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A16C98 => {
    //   block [0x82A16C98..0x82A16CCC)
	// 82A16C98: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A16C9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A16CA0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16CA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A16CA8: 4E800421  bctrl
	ctx.lr = 0x82A16CAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A16CAC: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A16CB0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A16CB4: 419A0038  beq cr6, 0x82a16cec
	if ctx.cr[6].eq {
	pc = 0x82A16CEC; continue 'dispatch;
	}
	// 82A16CB8: 817FE878  lwz r11, -0x1788(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-6024 as u32) ) } as u64;
	// 82A16CBC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A16CC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A16CC4: 419A0008  beq cr6, 0x82a16ccc
	if ctx.cr[6].eq {
	pc = 0x82A16CCC; continue 'dispatch;
	}
	// 82A16CC8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A16CCC => {
    //   block [0x82A16CCC..0x82A16CEC)
	// 82A16CCC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A16CD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A16CD4: 4BA69AF5  bl 0x824807c8
	ctx.lr = 0x82A16CD8;
	sub_824807C8(ctx, base);
	// 82A16CD8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A16CDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A16CE0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A16CE4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A16CE8: 4E800421  bctrl
	ctx.lr = 0x82A16CEC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A16CEC => {
    //   block [0x82A16CEC..0x82A16D10)
	// 82A16CEC: 3898D12C  addi r4, r24, -0x2ed4
	ctx.r[4].s64 = ctx.r[24].s64 + -11988;
	// 82A16CF0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A16CF4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A16CF8: 4B8161D9  bl 0x8222ced0
	ctx.lr = 0x82A16CFC;
	sub_8222CED0(ctx, base);
	// 82A16CFC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A16D00: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A16D04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A16D08: 419A0008  beq cr6, 0x82a16d10
	if ctx.cr[6].eq {
	pc = 0x82A16D10; continue 'dispatch;
	}
	// 82A16D0C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A16D10; continue 'dispatch;
            }
            0x82A16D10 => {
    //   block [0x82A16D10..0x82A16D50)
	// 82A16D10: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A16D14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A16D18: 4BA69AB1  bl 0x824807c8
	ctx.lr = 0x82A16D1C;
	sub_824807C8(ctx, base);
	// 82A16D1C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A16D20: 4B7FE0B9  bl 0x82214dd8
	ctx.lr = 0x82A16D24;
	sub_82214DD8(ctx, base);
	// 82A16D24: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82A16D28: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 82A16D2C: 3BEBF1BC  addi r31, r11, -0xe44
	ctx.r[31].s64 = ctx.r[11].s64 + -3652;
	// 82A16D30: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 82A16D34: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A16D38: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A16D3C: 40990134  ble cr6, 0x82a16e70
	if !ctx.cr[6].gt {
	pc = 0x82A16E70; continue 'dispatch;
	}
	// 82A16D40: 39610088  addi r11, r1, 0x88
	ctx.r[11].s64 = ctx.r[1].s64 + 136;
	// 82A16D44: 3F40834A  lis r26, -0x7cb6
	ctx.r[26].s64 = -2092302336;
	// 82A16D48: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82A16D4C: 3F60834A  lis r27, -0x7cb6
	ctx.r[27].s64 = -2092302336;
	pc = 0x82A16D50; continue 'dispatch;
            }
            0x82A16D50 => {
    //   block [0x82A16D50..0x82A16D98)
	// 82A16D50: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A16D54: 3898D138  addi r4, r24, -0x2ec8
	ctx.r[4].s64 = ctx.r[24].s64 + -11976;
	// 82A16D58: 92E10070  stw r23, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[23].u32 ) };
	// 82A16D5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A16D60: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16D64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A16D68: 4E800421  bctrl
	ctx.lr = 0x82A16D6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A16D6C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A16D70: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A16D74: 419A00D0  beq cr6, 0x82a16e44
	if ctx.cr[6].eq {
	pc = 0x82A16E44; continue 'dispatch;
	}
	// 82A16D78: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A16D7C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A16D80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A16D84: 409A002C  bne cr6, 0x82a16db0
	if !ctx.cr[6].eq {
	pc = 0x82A16DB0; continue 'dispatch;
	}
	// 82A16D88: 817BE87C  lwz r11, -0x1784(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-6020 as u32) ) } as u64;
	// 82A16D8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A16D90: 419A0008  beq cr6, 0x82a16d98
	if ctx.cr[6].eq {
	pc = 0x82A16D98; continue 'dispatch;
	}
	// 82A16D94: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
            }
            0x82A16D98 => {
    //   block [0x82A16D98..0x82A16DB0)
	// 82A16D98: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A16D9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A16DA0: 4BA69A29  bl 0x824807c8
	ctx.lr = 0x82A16DA4;
	sub_824807C8(ctx, base);
	// 82A16DA4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A16DA8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A16DAC: 48000044  b 0x82a16df0
	pc = 0x82A16DF0; continue 'dispatch;
            }
            0x82A16DB0 => {
    //   block [0x82A16DB0..0x82A16DC0)
	// 82A16DB0: 817AE880  lwz r11, -0x1780(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6016 as u32) ) } as u64;
	// 82A16DB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A16DB8: 419A0008  beq cr6, 0x82a16dc0
	if ctx.cr[6].eq {
	pc = 0x82A16DC0; continue 'dispatch;
	}
	// 82A16DBC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A16DC0; continue 'dispatch;
            }
            0x82A16DC0 => {
    //   block [0x82A16DC0..0x82A16DF0)
	// 82A16DC0: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 82A16DC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A16DC8: 4BA69A89  bl 0x82480850
	ctx.lr = 0x82A16DCC;
	sub_82480850(ctx, base);
	// 82A16DCC: 817D6DD4  lwz r11, 0x6dd4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28116 as u32) ) } as u64;
	// 82A16DD0: C0010064  lfs f0, 0x64(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A16DD4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A16DD8: 7DABFC2E  lfsx f13, r11, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A16DDC: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82A16DE0: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 82A16DE4: D9610080  stfd f11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.f[11].u64 ) };
	// 82A16DE8: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A16DEC: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	pc = 0x82A16DF0; continue 'dispatch;
            }
            0x82A16DF0 => {
    //   block [0x82A16DF0..0x82A16E14)
	// 82A16DF0: 3898D14C  addi r4, r24, -0x2eb4
	ctx.r[4].s64 = ctx.r[24].s64 + -11956;
	// 82A16DF4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A16DF8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A16DFC: 4B8160D5  bl 0x8222ced0
	ctx.lr = 0x82A16E00;
	sub_8222CED0(ctx, base);
	// 82A16E00: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A16E04: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A16E08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A16E0C: 419A0008  beq cr6, 0x82a16e14
	if ctx.cr[6].eq {
	pc = 0x82A16E14; continue 'dispatch;
	}
	// 82A16E10: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A16E14; continue 'dispatch;
            }
            0x82A16E14 => {
    //   block [0x82A16E14..0x82A16E44)
	// 82A16E14: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82A16E18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A16E1C: 4BA699AD  bl 0x824807c8
	ctx.lr = 0x82A16E20;
	sub_824807C8(ctx, base);
	// 82A16E20: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A16E24: 4B7FDFB5  bl 0x82214dd8
	ctx.lr = 0x82A16E28;
	sub_82214DD8(ctx, base);
	// 82A16E28: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A16E2C: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A16E30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A16E34: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A16E38: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82A16E3C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82A16E40: 4E800421  bctrl
	ctx.lr = 0x82A16E44;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A16E44 => {
    //   block [0x82A16E44..0x82A16E70)
	// 82A16E44: 8161008C  lwz r11, 0x8c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A16E48: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82A16E4C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A16E50: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A16E54: E8810078  ld r4, 0x78(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82A16E58: 48000181  bl 0x82a16fd8
	ctx.lr = 0x82A16E5C;
	sub_82A16FD8(ctx, base);
	// 82A16E5C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A16E60: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82A16E64: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A16E68: 4198FEE8  blt cr6, 0x82a16d50
	if ctx.cr[6].lt {
	pc = 0x82A16D50; continue 'dispatch;
	}
	// 82A16E6C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	pc = 0x82A16E70; continue 'dispatch;
            }
            0x82A16E70 => {
    //   block [0x82A16E70..0x82A16E80)
	// 82A16E70: 409A0010  bne cr6, 0x82a16e80
	if !ctx.cr[6].eq {
	pc = 0x82A16E80; continue 'dispatch;
	}
	// 82A16E74: C0180000  lfs f0, 0(r24)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A16E78: D0160008  stfs f0, 8(r22)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A16E7C: 48000048  b 0x82a16ec4
	pc = 0x82A16EC4; continue 'dispatch;
            }
            0x82A16E80 => {
    //   block [0x82A16E80..0x82A16E94)
	// 82A16E80: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A16E84: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A16E88: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A16E8C: 409A0008  bne cr6, 0x82a16e94
	if !ctx.cr[6].eq {
	pc = 0x82A16E94; continue 'dispatch;
	}
	// 82A16E90: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A16E94; continue 'dispatch;
            }
            0x82A16E94 => {
    //   block [0x82A16E94..0x82A16EC4)
	// 82A16E94: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A16E98: 393F0008  addi r9, r31, 8
	ctx.r[9].s64 = ctx.r[31].s64 + 8;
	// 82A16E9C: 817D6DD4  lwz r11, 0x6dd4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28116 as u32) ) } as u64;
	// 82A16EA0: 7D4807B4  extsw r8, r10
	ctx.r[8].s64 = ctx.r[10].s32 as i64;
	// 82A16EA4: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82A16EA8: F9010080  std r8, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[8].u64 ) };
	// 82A16EAC: C8010080  lfd f0, 0x80(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82A16EB0: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82A16EB4: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A16EB8: 7D674C2E  lfsx f11, r7, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82A16EBC: ED4B0332  fmuls f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82A16EC0: D1560008  stfs f10, 8(r22)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82A16EC4; continue 'dispatch;
            }
            0x82A16EC4 => {
    //   block [0x82A16EC4..0x82A16EF0)
	// 82A16EC4: 8176000C  lwz r11, 0xc(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A16EC8: 3898D154  addi r4, r24, -0x2eac
	ctx.r[4].s64 = ctx.r[24].s64 + -11948;
	// 82A16ECC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A16ED0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A16ED4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A16ED8: 4B815FF9  bl 0x8222ced0
	ctx.lr = 0x82A16EDC;
	sub_8222CED0(ctx, base);
	// 82A16EDC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A16EE0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A16EE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A16EE8: 419A0008  beq cr6, 0x82a16ef0
	if ctx.cr[6].eq {
	pc = 0x82A16EF0; continue 'dispatch;
	}
	// 82A16EEC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A16EF0; continue 'dispatch;
            }
            0x82A16EF0 => {
    //   block [0x82A16EF0..0x82A16F0C)
	// 82A16EF0: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82A16EF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A16EF8: 4BA698D1  bl 0x824807c8
	ctx.lr = 0x82A16EFC;
	sub_824807C8(ctx, base);
	// 82A16EFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A16F00: 4B7AF869  bl 0x821c6768
	ctx.lr = 0x82A16F04;
	sub_821C6768(ctx, base);
	// 82A16F04: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A16F08: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	pc = 0x82A16F0C; continue 'dispatch;
            }
            0x82A16F0C => {
    //   block [0x82A16F0C..0x82A16F88)
	// 82A16F0C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A16F10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A16F14: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A16F18: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A16F1C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A16F20: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A16F24: 4082FFE8  bne 0x82a16f0c
	if !ctx.cr[0].eq {
	pc = 0x82A16F0C; continue 'dispatch;
	}
	// 82A16F28: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A16F2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A16F30: 80C7000C  lwz r6, 0xc(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A16F34: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82A16F38: 4E800421  bctrl
	ctx.lr = 0x82A16F3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A16F3C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A16F40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A16F44: 409A0044  bne cr6, 0x82a16f88
	if !ctx.cr[6].eq {
	pc = 0x82A16F88; continue 'dispatch;
	}
	// 82A16F48: 8156000C  lwz r10, 0xc(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A16F4C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A16F50: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A16F54: 419A0058  beq cr6, 0x82a16fac
	if ctx.cr[6].eq {
	pc = 0x82A16FAC; continue 'dispatch;
	}
	// 82A16F58: 8121008C  lwz r9, 0x8c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A16F5C: 39410088  addi r10, r1, 0x88
	ctx.r[10].s64 = ctx.r[1].s64 + 136;
	// 82A16F60: 9176000C  stw r11, 0xc(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A16F64: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 82A16F68: 92E10078  stw r23, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[23].u32 ) };
	// 82A16F6C: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A16F70: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A16F74: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82A16F78: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 82A16F7C: E8810070  ld r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A16F80: 48000059  bl 0x82a16fd8
	ctx.lr = 0x82A16F84;
	sub_82A16FD8(ctx, base);
	// 82A16F84: 48000028  b 0x82a16fac
	pc = 0x82A16FAC; continue 'dispatch;
            }
            0x82A16F88 => {
    //   block [0x82A16F88..0x82A16FA4)
	// 82A16F88: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A16F8C: 409A0020  bne cr6, 0x82a16fac
	if !ctx.cr[6].eq {
	pc = 0x82A16FAC; continue 'dispatch;
	}
	// 82A16F90: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A16F94: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A16F98: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A16F9C: 409A0008  bne cr6, 0x82a16fa4
	if !ctx.cr[6].eq {
	pc = 0x82A16FA4; continue 'dispatch;
	}
	// 82A16FA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A16FA4; continue 'dispatch;
            }
            0x82A16FA4 => {
    //   block [0x82A16FA4..0x82A16FAC)
	// 82A16FA4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A16FA8: 9176000C  stw r11, 0xc(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x82A16FAC; continue 'dispatch;
            }
            0x82A16FAC => {
    //   block [0x82A16FAC..0x82A16FD8)
	// 82A16FAC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A16FB0: 4BFFD389  bl 0x82a14338
	ctx.lr = 0x82A16FB4;
	sub_82A14338(ctx, base);
	// 82A16FB4: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 82A16FB8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82A16FBC: 4800009D  bl 0x82a17058
	ctx.lr = 0x82A16FC0;
	sub_82A17058(ctx, base);
	// 82A16FC0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 82A16FC4: 4BFFDDCD  bl 0x82a14d90
	ctx.lr = 0x82A16FC8;
	sub_82A14D90(ctx, base);
	// 82A16FC8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A16FCC: 4B804D6D  bl 0x8221bd38
	ctx.lr = 0x82A16FD0;
	sub_8221BD38(ctx, base);
	// 82A16FD0: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A16FD4: 4829246C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A16FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A16FD8 size=128
    let mut pc: u32 = 0x82A16FD8;
    'dispatch: loop {
        match pc {
            0x82A16FD8 => {
    //   block [0x82A16FD8..0x82A17010)
	// 82A16FD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A16FDC: 48292425  bl 0x82ca9400
	ctx.lr = 0x82A16FE0;
	sub_82CA93D0(ctx, base);
	// 82A16FE0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A16FE4: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82A16FE8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A16FEC: 83A100AC  lwz r29, 0xac(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A16FF0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A16FF4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A16FF8: 839D0004  lwz r28, 4(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A16FFC: 4B80825D  bl 0x8221f258
	ctx.lr = 0x82A17000;
	sub_8221F258(ctx, base);
	// 82A17000: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A17004: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A17008: 419A0008  beq cr6, 0x82a17010
	if ctx.cr[6].eq {
	pc = 0x82A17010; continue 'dispatch;
	}
	// 82A1700C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x82A17010; continue 'dispatch;
            }
            0x82A17010 => {
    //   block [0x82A17010..0x82A17020)
	// 82A17010: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82A17014: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A17018: 419A0008  beq cr6, 0x82a17020
	if ctx.cr[6].eq {
	pc = 0x82A17020; continue 'dispatch;
	}
	// 82A1701C: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82A17020; continue 'dispatch;
            }
            0x82A17020 => {
    //   block [0x82A17020..0x82A17038)
	// 82A17020: 357F0008  addic. r11, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A17024: 41820014  beq 0x82a17038
	if ctx.cr[0].eq {
	pc = 0x82A17038; continue 'dispatch;
	}
	// 82A17028: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1702C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A17030: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17034: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	pc = 0x82A17038; continue 'dispatch;
            }
            0x82A17038 => {
    //   block [0x82A17038..0x82A17058)
	// 82A17038: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A1703C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A17040: 4B9C3361  bl 0x823da3a0
	ctx.lr = 0x82A17044;
	sub_823DA3A0(ctx, base);
	// 82A17044: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A17048: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1704C: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A17050: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A17054: 482923FC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A17058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A17058 size=328
    let mut pc: u32 = 0x82A17058;
    'dispatch: loop {
        match pc {
            0x82A17058 => {
    //   block [0x82A17058..0x82A170A8)
	// 82A17058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1705C: 482923AD  bl 0x82ca9408
	ctx.lr = 0x82A17060;
	sub_82CA93D0(ctx, base);
	// 82A17060: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82A17064: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82A17068: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1706C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A17070: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A17074: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A17078: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A1707C: 4199002C  bgt cr6, 0x82a170a8
	if ctx.cr[6].gt {
	pc = 0x82A170A8; continue 'dispatch;
	}
	// 82A17080: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17084: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A17088: 419A0108  beq cr6, 0x82a17190
	if ctx.cr[6].eq {
	pc = 0x82A17190; continue 'dispatch;
	}
	// 82A1708C: 4B804CAD  bl 0x8221bd38
	ctx.lr = 0x82A17090;
	sub_8221BD38(ctx, base);
	// 82A17090: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A17094: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A17098: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1709C: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A170A0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A170A4: 482923B4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A170A8 => {
    //   block [0x82A170A8..0x82A170C0)
	// 82A170A8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A170AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A170B0: 409A0010  bne cr6, 0x82a170c0
	if !ctx.cr[6].eq {
	pc = 0x82A170C0; continue 'dispatch;
	}
	// 82A170B4: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82A170B8: 4B8081A1  bl 0x8221f258
	ctx.lr = 0x82A170BC;
	sub_8221F258(ctx, base);
	// 82A170BC: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82A170C0; continue 'dispatch;
            }
            0x82A170C0 => {
    //   block [0x82A170C0..0x82A170D8)
	// 82A170C0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A170C4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A170C8: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A170CC: 409A000C  bne cr6, 0x82a170d8
	if !ctx.cr[6].eq {
	pc = 0x82A170D8; continue 'dispatch;
	}
	// 82A170D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82A170D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A170D8; continue 'dispatch;
            }
            0x82A170D8 => {
    //   block [0x82A170D8..0x82A170EC)
	// 82A170D8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A170DC: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A170E0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A170E4: 409A0008  bne cr6, 0x82a170ec
	if !ctx.cr[6].eq {
	pc = 0x82A170EC; continue 'dispatch;
	}
	// 82A170E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A170EC; continue 'dispatch;
            }
            0x82A170EC => {
    //   block [0x82A170EC..0x82A1711C)
	// 82A170EC: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A170F0: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82A170F4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A170F8: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A170FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A17100: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 82A17104: C00A0ED8  lfs f0, 0xed8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3800 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A17108: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82A1710C: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A17110: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A17114: FFE06018  frsp f31, f12
	ctx.f[31].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A17118: EFDF0032  fmuls f30, f31, f0
	ctx.f[30].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82A1711C; continue 'dispatch;
            }
            0x82A1711C => {
    //   block [0x82A1711C..0x82A17180)
	// 82A1711C: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 82A17120: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A17124: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82A17128: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A1712C: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82A17130: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A17134: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A17138: ED6C07B2  fmuls f11, f12, f30
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 82A1713C: FD40581E  fctiwz f10, f11
	ctx.f[10].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82A17140: D9410058  stfd f10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[10].u64 ) };
	// 82A17144: 80A1005C  lwz r5, 0x5c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A17148: 48000059  bl 0x82a171a0
	ctx.lr = 0x82A1714C;
	sub_82A171A0(ctx, base);
	// 82A1714C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17150: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82A17154: 7C7F512E  stwx r3, r31, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32), ctx.r[3].u32) };
	// 82A17158: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82A1715C: 2F1F0028  cmpwi cr6, r31, 0x28
	ctx.cr[6].compare_i32(ctx.r[31].s32, 40, &mut ctx.xer);
	// 82A17160: 4198FFBC  blt cr6, 0x82a1711c
	if ctx.cr[6].lt {
	pc = 0x82A1711C; continue 'dispatch;
	}
	// 82A17164: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A17168: 396B9490  addi r11, r11, -0x6b70
	ctx.r[11].s64 = ctx.r[11].s64 + -27504;
	// 82A1716C: C00BFFF4  lfs f0, -0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A17170: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82A17174: 4099000C  ble cr6, 0x82a17180
	if !ctx.cr[6].gt {
	pc = 0x82A17180; continue 'dispatch;
	}
	// 82A17178: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1717C: EC00F824  fdivs f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	pc = 0x82A17180; continue 'dispatch;
            }
            0x82A17180 => {
    //   block [0x82A17180..0x82A17190)
	// 82A17180: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A17184: C1AB0A54  lfs f13, 0xa54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2644 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A17188: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82A1718C: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x82A17190; continue 'dispatch;
            }
            0x82A17190 => {
    //   block [0x82A17190..0x82A171A0)
	// 82A17190: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A17194: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A17198: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82A1719C: 482922BC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A171A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A171A0 size=204
    let mut pc: u32 = 0x82A171A0;
    'dispatch: loop {
        match pc {
            0x82A171A0 => {
    //   block [0x82A171A0..0x82A171D4)
	// 82A171A0: 80E40004  lwz r7, 4(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A171A4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A171A8: 9081FFE0  stw r4, -0x20(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[4].u32 ) };
	// 82A171AC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A171B0: 9141FFF0  stw r10, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u32 ) };
	// 82A171B4: 90E1FFE4  stw r7, -0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), ctx.r[7].u32 ) };
	// 82A171B8: E8C1FFE0  ld r6, -0x20(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A171BC: F8C1FFE4  std r6, -0x1c(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), ctx.r[6].u64 ) };
	// 82A171C0: 8121FFE4  lwz r9, -0x1c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-28 as u32) ) } as u64;
	// 82A171C4: 8161FFE8  lwz r11, -0x18(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) } as u64;
	// 82A171C8: 80E70000  lwz r7, 0(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A171CC: 9121FFF4  stw r9, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[9].u32 ) };
	// 82A171D0: 9161FFF8  stw r11, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	pc = 0x82A171D4; continue 'dispatch;
            }
            0x82A171D4 => {
    //   block [0x82A171D4..0x82A171E4)
	// 82A171D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A171D8: 419A000C  beq cr6, 0x82a171e4
	if ctx.cr[6].eq {
	pc = 0x82A171E4; continue 'dispatch;
	}
	// 82A171DC: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A171E0: 419A0008  beq cr6, 0x82a171e8
	if ctx.cr[6].eq {
	pc = 0x82A171E8; continue 'dispatch;
	}
	pc = 0x82A171E4; continue 'dispatch;
            }
            0x82A171E4 => {
    //   block [0x82A171E4..0x82A171E8)
	// 82A171E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A171E8; continue 'dispatch;
            }
            0x82A171E8 => {
    //   block [0x82A171E8..0x82A17204)
	// 82A171E8: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A171EC: 419A0104  beq cr6, 0x82a172f0
	if ctx.cr[6].eq {
		sub_82A172F0(ctx, base);
		return;
	}
	// 82A171F0: E941FFF4  ld r10, -0xc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) };
	// 82A171F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A171F8: F941FFE0  std r10, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[10].u64 ) };
	// 82A171FC: 409A0008  bne cr6, 0x82a17204
	if !ctx.cr[6].eq {
	pc = 0x82A17204; continue 'dispatch;
	}
	// 82A17200: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A17204; continue 'dispatch;
            }
            0x82A17204 => {
    //   block [0x82A17204..0x82A17220)
	// 82A17204: 80C1FFE0  lwz r6, -0x20(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) } as u64;
	// 82A17208: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1720C: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17210: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A17214: 409A000C  bne cr6, 0x82a17220
	if !ctx.cr[6].eq {
	pc = 0x82A17220; continue 'dispatch;
	}
	// 82A17218: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82A1721C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A17220; continue 'dispatch;
            }
            0x82A17220 => {
    //   block [0x82A17220..0x82A17240)
	// 82A17220: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A17224: 396A0008  addi r11, r10, 8
	ctx.r[11].s64 = ctx.r[10].s64 + 8;
	// 82A17228: 7F053000  cmpw cr6, r5, r6
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82A1722C: 40980030  bge cr6, 0x82a1725c
	if !ctx.cr[6].lt {
	pc = 0x82A1725C; continue 'dispatch;
	}
	// 82A17230: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82A17234: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A17238: 409A0008  bne cr6, 0x82a17240
	if !ctx.cr[6].eq {
	pc = 0x82A17240; continue 'dispatch;
	}
	// 82A1723C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A17240; continue 'dispatch;
            }
            0x82A17240 => {
    //   block [0x82A17240..0x82A1725C)
	// 82A17240: 80C90004  lwz r6, 4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17244: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A17248: 9161FFF8  stw r11, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[11].u32 ) };
	// 82A1724C: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82A17250: 409AFF84  bne cr6, 0x82a171d4
	if !ctx.cr[6].eq {
	pc = 0x82A171D4; continue 'dispatch;
	}
	// 82A17254: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82A17258: 4BFFFF7C  b 0x82a171d4
	pc = 0x82A171D4; continue 'dispatch;
            }
            0x82A1725C => {
    //   block [0x82A1725C..0x82A1726C)
	// 82A1725C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A17260: 409A000C  bne cr6, 0x82a1726c
	if !ctx.cr[6].eq {
		sub_82A1726C(ctx, base);
		return;
	}
	// 82A17264: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17268: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1726C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A1726C size=132
    let mut pc: u32 = 0x82A1726C;
    'dispatch: loop {
        match pc {
            0x82A1726C => {
    //   block [0x82A1726C..0x82A172F0)
	// 82A1726C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17270: 81280000  lwz r9, 0(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17274: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17278: 7CCA2850  subf r6, r10, r5
	ctx.r[6].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 82A1727C: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17280: 7CAA4850  subf r5, r10, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82A17284: 7CE307B4  extsw r3, r7
	ctx.r[3].s64 = ctx.r[7].s32 as i64;
	// 82A17288: 7D472050  subf r10, r7, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[7].s64;
	// 82A1728C: F861FFF0  std r3, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[3].u64 ) };
	// 82A17290: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A17294: 7D4907B4  extsw r9, r10
	ctx.r[9].s64 = ctx.r[10].s32 as i64;
	// 82A17298: FCC06E9C  fcfid f6, f13
	ctx.f[6].f64 = (ctx.f[13].s64 as f64);
	// 82A1729C: 7CAB07B4  extsw r11, r5
	ctx.r[11].s64 = ctx.r[5].s32 as i64;
	// 82A172A0: F921FFF0  std r9, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u64 ) };
	// 82A172A4: 7CC807B4  extsw r8, r6
	ctx.r[8].s64 = ctx.r[6].s32 as i64;
	// 82A172A8: C981FFF0  lfd f12, -0x10(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A172AC: F961FFE0  std r11, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[11].u64 ) };
	// 82A172B0: C801FFE0  lfd f0, -0x20(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82A172B4: F901FFF0  std r8, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u64 ) };
	// 82A172B8: C961FFF0  lfd f11, -0x10(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A172BC: FCE0669C  fcfid f7, f12
	ctx.f[7].f64 = (ctx.f[12].s64 as f64);
	// 82A172C0: FD20069C  fcfid f9, f0
	ctx.f[9].f64 = (ctx.f[0].s64 as f64);
	// 82A172C4: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82A172C8: FC803818  frsp f4, f7
	ctx.f[4].f64 = (ctx.f[7].f64 as f32) as f64;
	// 82A172CC: FC603018  frsp f3, f6
	ctx.f[3].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82A172D0: FCA04818  frsp f5, f9
	ctx.f[5].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82A172D4: FD005018  frsp f8, f10
	ctx.f[8].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82A172D8: EC482824  fdivs f2, f8, f5
	ctx.f[2].f64 = ((ctx.f[8].f64 / ctx.f[5].f64) as f32) as f64;
	// 82A172DC: EC22193A  fmadds f1, f2, f4, f3
	ctx.f[1].f64 = (((ctx.f[2].f64 * ctx.f[4].f64 + ctx.f[3].f64) as f32) as f64);
	// 82A172E0: FC00081E  fctiwz f0, f1
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82A172E4: D801FFF0  stfd f0, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[0].u64 ) };
	// 82A172E8: 8061FFF4  lwz r3, -0xc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82A172EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A172F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A172F0 size=8
    let mut pc: u32 = 0x82A172F0;
    'dispatch: loop {
        match pc {
            0x82A172F0 => {
    //   block [0x82A172F0..0x82A172F8)
	// 82A172F0: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A172F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A172F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A172F8 size=92
    let mut pc: u32 = 0x82A172F8;
    'dispatch: loop {
        match pc {
            0x82A172F8 => {
    //   block [0x82A172F8..0x82A1733C)
	// 82A172F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A172FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A17300: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A17304: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A17308: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1730C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A17310: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A17314: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A17318: 394B25A8  addi r10, r11, 0x25a8
	ctx.r[10].s64 = ctx.r[11].s64 + 9640;
	// 82A1731C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A17320: 48811FF9  bl 0x83229318
	ctx.lr = 0x82A17324;
	sub_83229318(ctx, base);
	// 82A17324: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A17328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1732C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A17330: 419A000C  beq cr6, 0x82a1733c
	if ctx.cr[6].eq {
	pc = 0x82A1733C; continue 'dispatch;
	}
	// 82A17334: 4B804A05  bl 0x8221bd38
	ctx.lr = 0x82A17338;
	sub_8221BD38(ctx, base);
	// 82A17338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1733C; continue 'dispatch;
            }
            0x82A1733C => {
    //   block [0x82A1733C..0x82A17354)
	// 82A1733C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A17340: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A17344: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A17348: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1734C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A17350: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A17358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A17358 size=80
    let mut pc: u32 = 0x82A17358;
    'dispatch: loop {
        match pc {
            0x82A17358 => {
    //   block [0x82A17358..0x82A17390)
	// 82A17358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1735C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A17360: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A17364: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A17368: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1736C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A17370: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A17374: 4882B925  bl 0x83242c98
	ctx.lr = 0x82A17378;
	sub_83242C98(ctx, base);
	// 82A17378: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1737C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A17380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A17384: 419A000C  beq cr6, 0x82a17390
	if ctx.cr[6].eq {
	pc = 0x82A17390; continue 'dispatch;
	}
	// 82A17388: 4B8049B1  bl 0x8221bd38
	ctx.lr = 0x82A1738C;
	sub_8221BD38(ctx, base);
	// 82A1738C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A17390; continue 'dispatch;
            }
            0x82A17390 => {
    //   block [0x82A17390..0x82A173A8)
	// 82A17390: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A17394: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A17398: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1739C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A173A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A173A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A173A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A173A8 size=92
    let mut pc: u32 = 0x82A173A8;
    'dispatch: loop {
        match pc {
            0x82A173A8 => {
    //   block [0x82A173A8..0x82A173EC)
	// 82A173A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A173AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A173B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A173B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A173B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A173BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A173C0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A173C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A173C8: 394B2690  addi r10, r11, 0x2690
	ctx.r[10].s64 = ctx.r[11].s64 + 9872;
	// 82A173CC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A173D0: 48804B89  bl 0x8321bf58
	ctx.lr = 0x82A173D4;
	sub_8321BF58(ctx, base);
	// 82A173D4: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A173D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A173DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A173E0: 419A000C  beq cr6, 0x82a173ec
	if ctx.cr[6].eq {
	pc = 0x82A173EC; continue 'dispatch;
	}
	// 82A173E4: 4B804955  bl 0x8221bd38
	ctx.lr = 0x82A173E8;
	sub_8221BD38(ctx, base);
	// 82A173E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A173EC; continue 'dispatch;
            }
            0x82A173EC => {
    //   block [0x82A173EC..0x82A17404)
	// 82A173EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A173F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A173F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A173F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A173FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A17400: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A17408(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A17408 size=8
    let mut pc: u32 = 0x82A17408;
    'dispatch: loop {
        match pc {
            0x82A17408 => {
    //   block [0x82A17408..0x82A17410)
	// 82A17408: 38600400  li r3, 0x400
	ctx.r[3].s64 = 1024;
	// 82A1740C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A17410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A17410 size=92
    let mut pc: u32 = 0x82A17410;
    'dispatch: loop {
        match pc {
            0x82A17410 => {
    //   block [0x82A17410..0x82A17454)
	// 82A17410: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A17414: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A17418: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1741C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A17420: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A17424: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A17428: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1742C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A17430: 394B26A8  addi r10, r11, 0x26a8
	ctx.r[10].s64 = ctx.r[11].s64 + 9896;
	// 82A17434: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A17438: 48804B21  bl 0x8321bf58
	ctx.lr = 0x82A1743C;
	sub_8321BF58(ctx, base);
	// 82A1743C: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A17440: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A17444: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A17448: 419A000C  beq cr6, 0x82a17454
	if ctx.cr[6].eq {
	pc = 0x82A17454; continue 'dispatch;
	}
	// 82A1744C: 4B8048ED  bl 0x8221bd38
	ctx.lr = 0x82A17450;
	sub_8221BD38(ctx, base);
	// 82A17450: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A17454; continue 'dispatch;
            }
            0x82A17454 => {
    //   block [0x82A17454..0x82A1746C)
	// 82A17454: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A17458: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1745C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A17460: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A17464: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A17468: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A17470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A17470 size=92
    let mut pc: u32 = 0x82A17470;
    'dispatch: loop {
        match pc {
            0x82A17470 => {
    //   block [0x82A17470..0x82A174B4)
	// 82A17470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A17474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A17478: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1747C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A17480: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A17484: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A17488: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1748C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A17490: 394B26C0  addi r10, r11, 0x26c0
	ctx.r[10].s64 = ctx.r[11].s64 + 9920;
	// 82A17494: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A17498: 48804AC1  bl 0x8321bf58
	ctx.lr = 0x82A1749C;
	sub_8321BF58(ctx, base);
	// 82A1749C: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A174A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A174A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A174A8: 419A000C  beq cr6, 0x82a174b4
	if ctx.cr[6].eq {
	pc = 0x82A174B4; continue 'dispatch;
	}
	// 82A174AC: 4B80488D  bl 0x8221bd38
	ctx.lr = 0x82A174B0;
	sub_8221BD38(ctx, base);
	// 82A174B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A174B4; continue 'dispatch;
            }
            0x82A174B4 => {
    //   block [0x82A174B4..0x82A174CC)
	// 82A174B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A174B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A174BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A174C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A174C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A174C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A174D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A174D0 size=8
    let mut pc: u32 = 0x82A174D0;
    'dispatch: loop {
        match pc {
            0x82A174D0 => {
    //   block [0x82A174D0..0x82A174D8)
	// 82A174D0: 38601000  li r3, 0x1000
	ctx.r[3].s64 = 4096;
	// 82A174D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A174D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A174D8 size=92
    let mut pc: u32 = 0x82A174D8;
    'dispatch: loop {
        match pc {
            0x82A174D8 => {
    //   block [0x82A174D8..0x82A1751C)
	// 82A174D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A174DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A174E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A174E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A174E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A174EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A174F0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A174F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A174F8: 394B26D8  addi r10, r11, 0x26d8
	ctx.r[10].s64 = ctx.r[11].s64 + 9944;
	// 82A174FC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A17500: 48804A59  bl 0x8321bf58
	ctx.lr = 0x82A17504;
	sub_8321BF58(ctx, base);
	// 82A17504: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A17508: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1750C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A17510: 419A000C  beq cr6, 0x82a1751c
	if ctx.cr[6].eq {
	pc = 0x82A1751C; continue 'dispatch;
	}
	// 82A17514: 4B804825  bl 0x8221bd38
	ctx.lr = 0x82A17518;
	sub_8221BD38(ctx, base);
	// 82A17518: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1751C; continue 'dispatch;
            }
            0x82A1751C => {
    //   block [0x82A1751C..0x82A17534)
	// 82A1751C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A17520: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A17524: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A17528: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1752C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A17530: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A17538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A17538 size=92
    let mut pc: u32 = 0x82A17538;
    'dispatch: loop {
        match pc {
            0x82A17538 => {
    //   block [0x82A17538..0x82A1757C)
	// 82A17538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1753C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A17540: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A17544: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A17548: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1754C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A17550: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A17554: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A17558: 394B26F0  addi r10, r11, 0x26f0
	ctx.r[10].s64 = ctx.r[11].s64 + 9968;
	// 82A1755C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A17560: 488049F9  bl 0x8321bf58
	ctx.lr = 0x82A17564;
	sub_8321BF58(ctx, base);
	// 82A17564: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A17568: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1756C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A17570: 419A000C  beq cr6, 0x82a1757c
	if ctx.cr[6].eq {
	pc = 0x82A1757C; continue 'dispatch;
	}
	// 82A17574: 4B8047C5  bl 0x8221bd38
	ctx.lr = 0x82A17578;
	sub_8221BD38(ctx, base);
	// 82A17578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1757C; continue 'dispatch;
            }
            0x82A1757C => {
    //   block [0x82A1757C..0x82A17594)
	// 82A1757C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A17580: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A17584: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A17588: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1758C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A17590: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A17598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A17598 size=12
    let mut pc: u32 = 0x82A17598;
    'dispatch: loop {
        match pc {
            0x82A17598 => {
    //   block [0x82A17598..0x82A175A4)
	// 82A17598: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 82A1759C: 60638000  ori r3, r3, 0x8000
	ctx.r[3].u64 = ctx.r[3].u64 | 32768;
	// 82A175A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A175A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A175A8 size=92
    let mut pc: u32 = 0x82A175A8;
    'dispatch: loop {
        match pc {
            0x82A175A8 => {
    //   block [0x82A175A8..0x82A175EC)
	// 82A175A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A175AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A175B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A175B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A175B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A175BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A175C0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A175C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A175C8: 394B2708  addi r10, r11, 0x2708
	ctx.r[10].s64 = ctx.r[11].s64 + 9992;
	// 82A175CC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A175D0: 48804989  bl 0x8321bf58
	ctx.lr = 0x82A175D4;
	sub_8321BF58(ctx, base);
	// 82A175D4: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A175D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A175DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A175E0: 419A000C  beq cr6, 0x82a175ec
	if ctx.cr[6].eq {
	pc = 0x82A175EC; continue 'dispatch;
	}
	// 82A175E4: 4B804755  bl 0x8221bd38
	ctx.lr = 0x82A175E8;
	sub_8221BD38(ctx, base);
	// 82A175E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A175EC; continue 'dispatch;
            }
            0x82A175EC => {
    //   block [0x82A175EC..0x82A17604)
	// 82A175EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A175F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A175F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A175F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A175FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A17600: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A17608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A17608 size=80
    let mut pc: u32 = 0x82A17608;
    'dispatch: loop {
        match pc {
            0x82A17608 => {
    //   block [0x82A17608..0x82A17640)
	// 82A17608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1760C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A17610: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A17614: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A17618: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1761C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A17620: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A17624: 48807C95  bl 0x8321f2b8
	ctx.lr = 0x82A17628;
	sub_8321F2B8(ctx, base);
	// 82A17628: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1762C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A17630: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A17634: 419A000C  beq cr6, 0x82a17640
	if ctx.cr[6].eq {
	pc = 0x82A17640; continue 'dispatch;
	}
	// 82A17638: 4B804701  bl 0x8221bd38
	ctx.lr = 0x82A1763C;
	sub_8221BD38(ctx, base);
	// 82A1763C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A17640; continue 'dispatch;
            }
            0x82A17640 => {
    //   block [0x82A17640..0x82A17658)
	// 82A17640: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A17644: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A17648: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1764C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A17650: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A17654: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A17658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A17658 size=292
    let mut pc: u32 = 0x82A17658;
    'dispatch: loop {
        match pc {
            0x82A17658 => {
    //   block [0x82A17658..0x82A17684)
	// 82A17658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1765C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A17660: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A17664: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82A17668: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A1766C: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17670: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17674: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82A17678: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1767C: 409A0044  bne cr6, 0x82a176c0
	if !ctx.cr[6].eq {
	pc = 0x82A176C0; continue 'dispatch;
	}
	// 82A17680: 80C40000  lwz r6, 0(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A17684; continue 'dispatch;
            }
            0x82A17684 => {
    //   block [0x82A17684..0x82A17698)
	// 82A17684: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A17688: 7F0A3000  cmpw cr6, r10, r6
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[6].s32, &mut ctx.xer);
	// 82A1768C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A17690: 41980008  blt cr6, 0x82a17698
	if ctx.cr[6].lt {
	pc = 0x82A17698; continue 'dispatch;
	}
	// 82A17694: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	pc = 0x82A17698; continue 'dispatch;
            }
            0x82A17698 => {
    //   block [0x82A17698..0x82A176AC)
	// 82A17698: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A1769C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A176A0: 419A000C  beq cr6, 0x82a176ac
	if ctx.cr[6].eq {
	pc = 0x82A176AC; continue 'dispatch;
	}
	// 82A176A4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A176A8: 4800000C  b 0x82a176b4
	pc = 0x82A176B4; continue 'dispatch;
            }
            0x82A176AC => {
    //   block [0x82A176AC..0x82A176B4)
	// 82A176AC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82A176B0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A176B4; continue 'dispatch;
            }
            0x82A176B4 => {
    //   block [0x82A176B4..0x82A176C0)
	// 82A176B4: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82A176B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A176BC: 419AFFC8  beq cr6, 0x82a17684
	if ctx.cr[6].eq {
	pc = 0x82A17684; continue 'dispatch;
	}
	pc = 0x82A176C0; continue 'dispatch;
            }
            0x82A176C0 => {
    //   block [0x82A176C0..0x82A176F0)
	// 82A176C0: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A176C4: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A176C8: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82A176CC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A176D0: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A176D4: 419A0028  beq cr6, 0x82a176fc
	if ctx.cr[6].eq {
	pc = 0x82A176FC; continue 'dispatch;
	}
	// 82A176D8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A176DC: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A176E0: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A176E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A176E8: 41980008  blt cr6, 0x82a176f0
	if ctx.cr[6].lt {
	pc = 0x82A176F0; continue 'dispatch;
	}
	// 82A176EC: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	pc = 0x82A176F0; continue 'dispatch;
            }
            0x82A176F0 => {
    //   block [0x82A176F0..0x82A176FC)
	// 82A176F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A176F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A176F8: 419A0054  beq cr6, 0x82a1774c
	if ctx.cr[6].eq {
	pc = 0x82A1774C; continue 'dispatch;
	}
	pc = 0x82A176FC; continue 'dispatch;
            }
            0x82A176FC => {
    //   block [0x82A176FC..0x82A1774C)
	// 82A176FC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17700: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 82A17704: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82A17708: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 82A1770C: 90E10070  stw r7, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[7].u32 ) };
	// 82A17710: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A17714: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A17718: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 82A1771C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A17720: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 82A17724: 4800017D  bl 0x82a178a0
	ctx.lr = 0x82A17728;
	sub_82A178A0(ctx, base);
	// 82A17728: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82A1772C: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82A17730: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82A17734: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82A17738: 4B7A03E1  bl 0x821b7b18
	ctx.lr = 0x82A1773C;
	sub_821B7B18(ctx, base);
	// 82A1773C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A17740: 4B7A03D9  bl 0x821b7b18
	ctx.lr = 0x82A17744;
	sub_821B7B18(ctx, base);
	// 82A17744: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A17748: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82A1774C; continue 'dispatch;
            }
            0x82A1774C => {
    //   block [0x82A1774C..0x82A17758)
	// 82A1774C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A17750: 409A0008  bne cr6, 0x82a17758
	if !ctx.cr[6].eq {
	pc = 0x82A17758; continue 'dispatch;
	}
	// 82A17754: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A17758; continue 'dispatch;
            }
            0x82A17758 => {
    //   block [0x82A17758..0x82A17768)
	// 82A17758: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1775C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A17760: 409A0008  bne cr6, 0x82a17768
	if !ctx.cr[6].eq {
	pc = 0x82A17768; continue 'dispatch;
	}
	// 82A17764: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A17768; continue 'dispatch;
            }
            0x82A17768 => {
    //   block [0x82A17768..0x82A1777C)
	// 82A17768: 386A0010  addi r3, r10, 0x10
	ctx.r[3].s64 = ctx.r[10].s64 + 16;
	// 82A1776C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A17770: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A17774: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A17778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A17780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A17780 size=84
    let mut pc: u32 = 0x82A17780;
    'dispatch: loop {
        match pc {
            0x82A17780 => {
    //   block [0x82A17780..0x82A177D4)
	// 82A17780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A17784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A17788: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1778C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A17790: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A17794: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17798: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1779C: 4B995B45  bl 0x823ad2e0
	ctx.lr = 0x82A177A0;
	sub_823AD2E0(ctx, base);
	// 82A177A0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A177A4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A177A8: 91290004  stw r9, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A177AC: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A177B0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A177B4: 91080000  stw r8, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A177B8: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A177BC: 90E70008  stw r7, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82A177C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A177C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A177C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A177CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A177D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A177D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A177D8 size=164
    let mut pc: u32 = 0x82A177D8;
    'dispatch: loop {
        match pc {
            0x82A177D8 => {
    //   block [0x82A177D8..0x82A177F0)
	// 82A177D8: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A177DC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A177E0: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82A177E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A177E8: 409A0044  bne cr6, 0x82a1782c
	if !ctx.cr[6].eq {
	pc = 0x82A1782C; continue 'dispatch;
	}
	// 82A177EC: 81050000  lwz r8, 0(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A177F0; continue 'dispatch;
            }
            0x82A177F0 => {
    //   block [0x82A177F0..0x82A17804)
	// 82A177F0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A177F4: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82A177F8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A177FC: 41980008  blt cr6, 0x82a17804
	if ctx.cr[6].lt {
	pc = 0x82A17804; continue 'dispatch;
	}
	// 82A17800: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82A17804; continue 'dispatch;
            }
            0x82A17804 => {
    //   block [0x82A17804..0x82A17818)
	// 82A17804: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A17808: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1780C: 419A000C  beq cr6, 0x82a17818
	if ctx.cr[6].eq {
	pc = 0x82A17818; continue 'dispatch;
	}
	// 82A17810: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A17814: 4800000C  b 0x82a17820
	pc = 0x82A17820; continue 'dispatch;
            }
            0x82A17818 => {
    //   block [0x82A17818..0x82A17820)
	// 82A17818: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82A1781C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A17820; continue 'dispatch;
            }
            0x82A17820 => {
    //   block [0x82A17820..0x82A1782C)
	// 82A17820: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82A17824: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A17828: 419AFFC8  beq cr6, 0x82a177f0
	if ctx.cr[6].eq {
	pc = 0x82A177F0; continue 'dispatch;
	}
	pc = 0x82A1782C; continue 'dispatch;
            }
            0x82A1782C => {
    //   block [0x82A1782C..0x82A17858)
	// 82A1782C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17830: 9121FFF4  stw r9, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[9].u32 ) };
	// 82A17834: 9081FFF0  stw r4, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[4].u32 ) };
	// 82A17838: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A1783C: 419A0040  beq cr6, 0x82a1787c
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A1787C);
		return;
	}
	// 82A17840: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17844: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A17848: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A1784C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A17850: 41980008  blt cr6, 0x82a17858
	if ctx.cr[6].lt {
	pc = 0x82A17858; continue 'dispatch;
	}
	// 82A17854: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A17858; continue 'dispatch;
            }
            0x82A17858 => {
    //   block [0x82A17858..0x82A1787C)
	// 82A17858: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A1785C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A17860: 409A001C  bne cr6, 0x82a1787c
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A1787C);
		return;
	}
	// 82A17864: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 82A17868: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1786C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17870: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A17874: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A17878: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A178A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A178A0 size=644
    let mut pc: u32 = 0x82A178A0;
    'dispatch: loop {
        match pc {
            0x82A178A0 => {
    //   block [0x82A178A0..0x82A178E8)
	// 82A178A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A178A4: 48291B61  bl 0x82ca9404
	ctx.lr = 0x82A178A8;
	sub_82CA93D0(ctx, base);
	// 82A178A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A178AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A178B0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A178B4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A178B8: FBE100B0  std r31, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[31].u64 ) };
	// 82A178BC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82A178C0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A178C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A178C8: 409A0020  bne cr6, 0x82a178e8
	if !ctx.cr[6].eq {
	pc = 0x82A178E8; continue 'dispatch;
	}
	// 82A178CC: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A178D0: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A178D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A178D8: 480006D1  bl 0x82a17fa8
	ctx.lr = 0x82A178DC;
	sub_82A17FA8(ctx, base);
	// 82A178DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A178E0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A178E4: 48291B70  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A178E8 => {
    //   block [0x82A178E8..0x82A17904)
	// 82A178E8: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A178EC: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A178F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A178F4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A178F8: 419A000C  beq cr6, 0x82a17904
	if ctx.cr[6].eq {
	pc = 0x82A17904; continue 'dispatch;
	}
	// 82A178FC: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A17900: 419A0008  beq cr6, 0x82a17908
	if ctx.cr[6].eq {
	pc = 0x82A17908; continue 'dispatch;
	}
	pc = 0x82A17904; continue 'dispatch;
            }
            0x82A17904 => {
    //   block [0x82A17904..0x82A17908)
	// 82A17904: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A17908; continue 'dispatch;
            }
            0x82A17908 => {
    //   block [0x82A17908..0x82A1792C)
	// 82A17908: 836100B4  lwz r27, 0xb4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A1790C: 7F1B4840  cmplw cr6, r27, r9
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A17910: 409A004C  bne cr6, 0x82a1795c
	if !ctx.cr[6].eq {
	pc = 0x82A1795C; continue 'dispatch;
	}
	// 82A17914: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17918: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1791C: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A17920: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A17924: 41980008  blt cr6, 0x82a1792c
	if ctx.cr[6].lt {
	pc = 0x82A1792C; continue 'dispatch;
	}
	// 82A17928: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A1792C; continue 'dispatch;
            }
            0x82A1792C => {
    //   block [0x82A1792C..0x82A1795C)
	// 82A1792C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A17930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A17934: 419A01C0  beq cr6, 0x82a17af4
	if ctx.cr[6].eq {
	pc = 0x82A17AF4; continue 'dispatch;
	}
	// 82A17938: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A1793C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A17940: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A17944: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A17948: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1794C: 4800065D  bl 0x82a17fa8
	ctx.lr = 0x82A17950;
	sub_82A17FA8(ctx, base);
	// 82A17950: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A17954: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A17958: 48291AFC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A1795C => {
    //   block [0x82A1795C..0x82A1796C)
	// 82A1795C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A17960: 419A000C  beq cr6, 0x82a1796c
	if ctx.cr[6].eq {
	pc = 0x82A1796C; continue 'dispatch;
	}
	// 82A17964: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A17968: 419A0008  beq cr6, 0x82a17970
	if ctx.cr[6].eq {
	pc = 0x82A17970; continue 'dispatch;
	}
	pc = 0x82A1796C; continue 'dispatch;
            }
            0x82A1796C => {
    //   block [0x82A1796C..0x82A17970)
	// 82A1796C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A17970; continue 'dispatch;
            }
            0x82A17970 => {
    //   block [0x82A17970..0x82A17994)
	// 82A17970: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17974: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A17978: 409A0048  bne cr6, 0x82a179c0
	if !ctx.cr[6].eq {
	pc = 0x82A179C0; continue 'dispatch;
	}
	// 82A1797C: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A17980: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A17984: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A17988: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A1798C: 41980008  blt cr6, 0x82a17994
	if ctx.cr[6].lt {
	pc = 0x82A17994; continue 'dispatch;
	}
	// 82A17990: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A17994; continue 'dispatch;
            }
            0x82A17994 => {
    //   block [0x82A17994..0x82A179C0)
	// 82A17994: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A17998: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1799C: 419A0158  beq cr6, 0x82a17af4
	if ctx.cr[6].eq {
	pc = 0x82A17AF4; continue 'dispatch;
	}
	// 82A179A0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A179A4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A179A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A179AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A179B0: 480005F9  bl 0x82a17fa8
	ctx.lr = 0x82A179B4;
	sub_82A17FA8(ctx, base);
	// 82A179B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A179B8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A179BC: 48291A98  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A179C0 => {
    //   block [0x82A179C0..0x82A179D4)
	// 82A179C0: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A179C4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A179C8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A179CC: 41980008  blt cr6, 0x82a179d4
	if ctx.cr[6].lt {
	pc = 0x82A179D4; continue 'dispatch;
	}
	// 82A179D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82A179D4; continue 'dispatch;
            }
            0x82A179D4 => {
    //   block [0x82A179D4..0x82A17A08)
	// 82A179D4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A179D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A179DC: 419A006C  beq cr6, 0x82a17a48
	if ctx.cr[6].eq {
	pc = 0x82A17A48; continue 'dispatch;
	}
	// 82A179E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A179E4: FBE10050  std r31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u64 ) };
	// 82A179E8: 4BC48B61  bl 0x82660548
	ctx.lr = 0x82A179EC;
	sub_82660548(ctx, base);
	// 82A179EC: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A179F0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A179F4: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A179F8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A179FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A17A00: 41980008  blt cr6, 0x82a17a08
	if ctx.cr[6].lt {
	pc = 0x82A17A08; continue 'dispatch;
	}
	// 82A17A04: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82A17A08; continue 'dispatch;
            }
            0x82A17A08 => {
    //   block [0x82A17A08..0x82A17A34)
	// 82A17A08: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A17A0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A17A10: 419A0038  beq cr6, 0x82a17a48
	if ctx.cr[6].eq {
	pc = 0x82A17A48; continue 'dispatch;
	}
	// 82A17A14: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A17A18: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A17A1C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A17A20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A17A24: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82A17A28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A17A2C: 409A00B4  bne cr6, 0x82a17ae0
	if !ctx.cr[6].eq {
	pc = 0x82A17AE0; continue 'dispatch;
	}
	// 82A17A30: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82A17A34; continue 'dispatch;
            }
            0x82A17A34 => {
    //   block [0x82A17A34..0x82A17A48)
	// 82A17A34: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A17A38: 48000571  bl 0x82a17fa8
	ctx.lr = 0x82A17A3C;
	sub_82A17FA8(ctx, base);
	// 82A17A3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A17A40: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A17A44: 48291A10  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A17A48 => {
    //   block [0x82A17A48..0x82A17A5C)
	// 82A17A48: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A17A4C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A17A50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A17A54: 41980008  blt cr6, 0x82a17a5c
	if ctx.cr[6].lt {
	pc = 0x82A17A5C; continue 'dispatch;
	}
	// 82A17A58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A17A5C; continue 'dispatch;
            }
            0x82A17A5C => {
    //   block [0x82A17A5C..0x82A17A8C)
	// 82A17A5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A17A60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A17A64: 419A0090  beq cr6, 0x82a17af4
	if ctx.cr[6].eq {
	pc = 0x82A17AF4; continue 'dispatch;
	}
	// 82A17A68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A17A6C: FBE10050  std r31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u64 ) };
	// 82A17A70: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17A74: 4BA2537D  bl 0x8243cdf0
	ctx.lr = 0x82A17A78;
	sub_8243CDF0(ctx, base);
	// 82A17A78: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A17A7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A17A80: 419A000C  beq cr6, 0x82a17a8c
	if ctx.cr[6].eq {
	pc = 0x82A17A8C; continue 'dispatch;
	}
	// 82A17A84: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A17A88: 419A0008  beq cr6, 0x82a17a90
	if ctx.cr[6].eq {
	pc = 0x82A17A90; continue 'dispatch;
	}
	pc = 0x82A17A8C; continue 'dispatch;
            }
            0x82A17A8C => {
    //   block [0x82A17A8C..0x82A17A90)
	// 82A17A8C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A17A90; continue 'dispatch;
            }
            0x82A17A90 => {
    //   block [0x82A17A90..0x82A17AB4)
	// 82A17A90: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A17A94: 7F06F840  cmplw cr6, r6, r31
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A17A98: 419A0028  beq cr6, 0x82a17ac0
	if ctx.cr[6].eq {
	pc = 0x82A17AC0; continue 'dispatch;
	}
	// 82A17A9C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17AA0: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A17AA4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A17AA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A17AAC: 41980008  blt cr6, 0x82a17ab4
	if ctx.cr[6].lt {
	pc = 0x82A17AB4; continue 'dispatch;
	}
	// 82A17AB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A17AB4; continue 'dispatch;
            }
            0x82A17AB4 => {
    //   block [0x82A17AB4..0x82A17AC0)
	// 82A17AB4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A17AB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A17ABC: 419A0038  beq cr6, 0x82a17af4
	if ctx.cr[6].eq {
	pc = 0x82A17AF4; continue 'dispatch;
	}
	pc = 0x82A17AC0; continue 'dispatch;
            }
            0x82A17AC0 => {
    //   block [0x82A17AC0..0x82A17AE0)
	// 82A17AC0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A17AC4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A17AC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A17ACC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A17AD0: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82A17AD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A17AD8: 419AFF5C  beq cr6, 0x82a17a34
	if ctx.cr[6].eq {
	pc = 0x82A17A34; continue 'dispatch;
	}
	// 82A17ADC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82A17AE0; continue 'dispatch;
            }
            0x82A17AE0 => {
    //   block [0x82A17AE0..0x82A17AF4)
	// 82A17AE0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A17AE4: 480004C5  bl 0x82a17fa8
	ctx.lr = 0x82A17AE8;
	sub_82A17FA8(ctx, base);
	// 82A17AE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A17AEC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A17AF0: 48291964  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A17AF4 => {
    //   block [0x82A17AF4..0x82A17B24)
	// 82A17AF4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A17AF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A17AFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A17B00: 480002C9  bl 0x82a17dc8
	ctx.lr = 0x82A17B04;
	sub_82A17DC8(ctx, base);
	// 82A17B04: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A17B08: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A17B0C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17B10: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A17B14: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17B18: 913D0004  stw r9, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A17B1C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A17B20: 48291934  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A17B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A17B28 size=232
    let mut pc: u32 = 0x82A17B28;
    'dispatch: loop {
        match pc {
            0x82A17B28 => {
    //   block [0x82A17B28..0x82A17B60)
	// 82A17B28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A17B2C: 482918D9  bl 0x82ca9404
	ctx.lr = 0x82A17B30;
	sub_82CA93D0(ctx, base);
	// 82A17B30: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A17B34: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A17B38: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 82A17B3C: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A17B40: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A17B44: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82A17B48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A17B4C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17B50: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17B54: 419A000C  beq cr6, 0x82a17b60
	if ctx.cr[6].eq {
	pc = 0x82A17B60; continue 'dispatch;
	}
	// 82A17B58: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A17B5C: 419A0008  beq cr6, 0x82a17b64
	if ctx.cr[6].eq {
	pc = 0x82A17B64; continue 'dispatch;
	}
	pc = 0x82A17B60; continue 'dispatch;
            }
            0x82A17B60 => {
    //   block [0x82A17B60..0x82A17B64)
	// 82A17B60: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A17B64; continue 'dispatch;
            }
            0x82A17B64 => {
    //   block [0x82A17B64..0x82A17B88)
	// 82A17B64: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A17B68: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A17B6C: 83C100B8  lwz r30, 0xb8(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82A17B70: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A17B74: 409A0044  bne cr6, 0x82a17bb8
	if !ctx.cr[6].eq {
	pc = 0x82A17BB8; continue 'dispatch;
	}
	// 82A17B78: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A17B7C: 419A000C  beq cr6, 0x82a17b88
	if ctx.cr[6].eq {
	pc = 0x82A17B88; continue 'dispatch;
	}
	// 82A17B80: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A17B84: 419A0008  beq cr6, 0x82a17b8c
	if ctx.cr[6].eq {
	pc = 0x82A17B8C; continue 'dispatch;
	}
	pc = 0x82A17B88; continue 'dispatch;
            }
            0x82A17B88 => {
    //   block [0x82A17B88..0x82A17B8C)
	// 82A17B88: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A17B8C; continue 'dispatch;
            }
            0x82A17B8C => {
    //   block [0x82A17B8C..0x82A17BB8)
	// 82A17B8C: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A17B90: 409A0028  bne cr6, 0x82a17bb8
	if !ctx.cr[6].eq {
	pc = 0x82A17BB8; continue 'dispatch;
	}
	// 82A17B94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A17B98: 4BFFFBE9  bl 0x82a17780
	ctx.lr = 0x82A17B9C;
	sub_82A17780(ctx, base);
	// 82A17B9C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17BA0: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A17BA4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A17BA8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17BAC: 915C0004  stw r10, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A17BB0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A17BB4: 482918A0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A17BB8 => {
    //   block [0x82A17BB8..0x82A17BC8)
	// 82A17BB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A17BBC: 419A000C  beq cr6, 0x82a17bc8
	if ctx.cr[6].eq {
	pc = 0x82A17BC8; continue 'dispatch;
	}
	// 82A17BC0: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A17BC4: 419A0008  beq cr6, 0x82a17bcc
	if ctx.cr[6].eq {
	pc = 0x82A17BCC; continue 'dispatch;
	}
	pc = 0x82A17BC8; continue 'dispatch;
            }
            0x82A17BC8 => {
    //   block [0x82A17BC8..0x82A17BCC)
	// 82A17BC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A17BCC; continue 'dispatch;
            }
            0x82A17BCC => {
    //   block [0x82A17BCC..0x82A17C00)
	// 82A17BCC: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A17BD0: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A17BD4: 419A002C  beq cr6, 0x82a17c00
	if ctx.cr[6].eq {
	pc = 0x82A17C00; continue 'dispatch;
	}
	// 82A17BD8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A17BDC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A17BE0: 4BA25211  bl 0x8243cdf0
	ctx.lr = 0x82A17BE4;
	sub_8243CDF0(ctx, base);
	// 82A17BE4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A17BE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A17BEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A17BF0: 4BC58081  bl 0x8266fc70
	ctx.lr = 0x82A17BF4;
	sub_8266FC70(ctx, base);
	// 82A17BF4: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82A17BF8: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A17BFC: 4BFFFFBC  b 0x82a17bb8
	pc = 0x82A17BB8; continue 'dispatch;
            }
            0x82A17C00 => {
    //   block [0x82A17C00..0x82A17C10)
	// 82A17C00: F8BC0000  std r5, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82A17C04: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A17C08: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A17C0C: 48291848  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A17C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A17C10 size=104
    let mut pc: u32 = 0x82A17C10;
    'dispatch: loop {
        match pc {
            0x82A17C10 => {
    //   block [0x82A17C10..0x82A17C78)
	// 82A17C10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A17C14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A17C18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A17C1C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A17C20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A17C24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A17C28: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82A17C2C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A17C30: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A17C34: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17C38: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17C3C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A17C40: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A17C44: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A17C48: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A17C4C: 4BFFFEDD  bl 0x82a17b28
	ctx.lr = 0x82A17C50;
	sub_82A17B28(ctx, base);
	// 82A17C50: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17C54: 4B8040E5  bl 0x8221bd38
	ctx.lr = 0x82A17C58;
	sub_8221BD38(ctx, base);
	// 82A17C58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A17C5C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A17C60: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A17C64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A17C68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A17C6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A17C70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A17C74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A17C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A17C78 size=232
    let mut pc: u32 = 0x82A17C78;
    'dispatch: loop {
        match pc {
            0x82A17C78 => {
    //   block [0x82A17C78..0x82A17CB0)
	// 82A17C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A17C7C: 48291789  bl 0x82ca9404
	ctx.lr = 0x82A17C80;
	sub_82CA93D0(ctx, base);
	// 82A17C80: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A17C84: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A17C88: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 82A17C8C: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A17C90: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A17C94: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82A17C98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A17C9C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17CA0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17CA4: 419A000C  beq cr6, 0x82a17cb0
	if ctx.cr[6].eq {
	pc = 0x82A17CB0; continue 'dispatch;
	}
	// 82A17CA8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A17CAC: 419A0008  beq cr6, 0x82a17cb4
	if ctx.cr[6].eq {
	pc = 0x82A17CB4; continue 'dispatch;
	}
	pc = 0x82A17CB0; continue 'dispatch;
            }
            0x82A17CB0 => {
    //   block [0x82A17CB0..0x82A17CB4)
	// 82A17CB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A17CB4; continue 'dispatch;
            }
            0x82A17CB4 => {
    //   block [0x82A17CB4..0x82A17CD8)
	// 82A17CB4: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A17CB8: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A17CBC: 83C100B8  lwz r30, 0xb8(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82A17CC0: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A17CC4: 409A0044  bne cr6, 0x82a17d08
	if !ctx.cr[6].eq {
	pc = 0x82A17D08; continue 'dispatch;
	}
	// 82A17CC8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A17CCC: 419A000C  beq cr6, 0x82a17cd8
	if ctx.cr[6].eq {
	pc = 0x82A17CD8; continue 'dispatch;
	}
	// 82A17CD0: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A17CD4: 419A0008  beq cr6, 0x82a17cdc
	if ctx.cr[6].eq {
	pc = 0x82A17CDC; continue 'dispatch;
	}
	pc = 0x82A17CD8; continue 'dispatch;
            }
            0x82A17CD8 => {
    //   block [0x82A17CD8..0x82A17CDC)
	// 82A17CD8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A17CDC; continue 'dispatch;
            }
            0x82A17CDC => {
    //   block [0x82A17CDC..0x82A17D08)
	// 82A17CDC: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A17CE0: 409A0028  bne cr6, 0x82a17d08
	if !ctx.cr[6].eq {
	pc = 0x82A17D08; continue 'dispatch;
	}
	// 82A17CE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A17CE8: 4B93B931  bl 0x82353618
	ctx.lr = 0x82A17CEC;
	sub_82353618(ctx, base);
	// 82A17CEC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17CF0: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A17CF4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A17CF8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17CFC: 915C0004  stw r10, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A17D00: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A17D04: 48291750  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A17D08 => {
    //   block [0x82A17D08..0x82A17D18)
	// 82A17D08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A17D0C: 419A000C  beq cr6, 0x82a17d18
	if ctx.cr[6].eq {
	pc = 0x82A17D18; continue 'dispatch;
	}
	// 82A17D10: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A17D14: 419A0008  beq cr6, 0x82a17d1c
	if ctx.cr[6].eq {
	pc = 0x82A17D1C; continue 'dispatch;
	}
	pc = 0x82A17D18; continue 'dispatch;
            }
            0x82A17D18 => {
    //   block [0x82A17D18..0x82A17D1C)
	// 82A17D18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A17D1C; continue 'dispatch;
            }
            0x82A17D1C => {
    //   block [0x82A17D1C..0x82A17D50)
	// 82A17D1C: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A17D20: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A17D24: 419A002C  beq cr6, 0x82a17d50
	if ctx.cr[6].eq {
	pc = 0x82A17D50; continue 'dispatch;
	}
	// 82A17D28: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82A17D2C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A17D30: 4B8E83F9  bl 0x82300128
	ctx.lr = 0x82A17D34;
	sub_82300128(ctx, base);
	// 82A17D34: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A17D38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A17D3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A17D40: 480004C1  bl 0x82a18200
	ctx.lr = 0x82A17D44;
	sub_82A18200(ctx, base);
	// 82A17D44: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82A17D48: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82A17D4C: 4BFFFFBC  b 0x82a17d08
	pc = 0x82A17D08; continue 'dispatch;
            }
            0x82A17D50 => {
    //   block [0x82A17D50..0x82A17D60)
	// 82A17D50: F8BC0000  std r5, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82A17D54: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A17D58: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A17D5C: 482916F8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A17D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A17D60 size=104
    let mut pc: u32 = 0x82A17D60;
    'dispatch: loop {
        match pc {
            0x82A17D60 => {
    //   block [0x82A17D60..0x82A17DC8)
	// 82A17D60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A17D64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A17D68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A17D6C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A17D70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A17D74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A17D78: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82A17D7C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A17D80: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A17D84: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17D88: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17D8C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A17D90: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A17D94: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A17D98: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A17D9C: 4BFFFEDD  bl 0x82a17c78
	ctx.lr = 0x82A17DA0;
	sub_82A17C78(ctx, base);
	// 82A17DA0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17DA4: 4B803F95  bl 0x8221bd38
	ctx.lr = 0x82A17DA8;
	sub_8221BD38(ctx, base);
	// 82A17DA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A17DAC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A17DB0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A17DB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A17DB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A17DBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A17DC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A17DC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A17DC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A17DC8 size=344
    let mut pc: u32 = 0x82A17DC8;
    'dispatch: loop {
        match pc {
            0x82A17DC8 => {
    //   block [0x82A17DC8..0x82A17E00)
	// 82A17DC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A17DCC: 48291635  bl 0x82ca9400
	ctx.lr = 0x82A17DD0;
	sub_82CA93D0(ctx, base);
	// 82A17DD0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A17DD4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A17DD8: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82A17DDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A17DE0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A17DE4: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82A17DE8: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17DEC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17DF0: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82A17DF4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A17DF8: 409A0044  bne cr6, 0x82a17e3c
	if !ctx.cr[6].eq {
	pc = 0x82A17E3C; continue 'dispatch;
	}
	// 82A17DFC: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A17E00; continue 'dispatch;
            }
            0x82A17E00 => {
    //   block [0x82A17E00..0x82A17E18)
	// 82A17E00: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A17E04: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82A17E08: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A17E0C: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82A17E10: 41980008  blt cr6, 0x82a17e18
	if ctx.cr[6].lt {
	pc = 0x82A17E18; continue 'dispatch;
	}
	// 82A17E14: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82A17E18; continue 'dispatch;
            }
            0x82A17E18 => {
    //   block [0x82A17E18..0x82A17E2C)
	// 82A17E18: 555D063E  clrlwi r29, r10, 0x18
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A17E1C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A17E20: 419A000C  beq cr6, 0x82a17e2c
	if ctx.cr[6].eq {
	pc = 0x82A17E2C; continue 'dispatch;
	}
	// 82A17E24: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17E28: 48000008  b 0x82a17e30
	pc = 0x82A17E30; continue 'dispatch;
            }
            0x82A17E2C => {
    //   block [0x82A17E2C..0x82A17E30)
	// 82A17E2C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A17E30; continue 'dispatch;
            }
            0x82A17E30 => {
    //   block [0x82A17E30..0x82A17E3C)
	// 82A17E30: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 82A17E34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A17E38: 419AFFC8  beq cr6, 0x82a17e00
	if ctx.cr[6].eq {
	pc = 0x82A17E00; continue 'dispatch;
	}
	pc = 0x82A17E3C; continue 'dispatch;
            }
            0x82A17E3C => {
    //   block [0x82A17E3C..0x82A17E9C)
	// 82A17E3C: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82A17E40: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A17E44: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A17E48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A17E4C: 419A0054  beq cr6, 0x82a17ea0
	if ctx.cr[6].eq {
	pc = 0x82A17EA0; continue 'dispatch;
	}
	// 82A17E50: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17E54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A17E58: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17E5C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A17E60: 409A003C  bne cr6, 0x82a17e9c
	if !ctx.cr[6].eq {
	pc = 0x82A17E9C; continue 'dispatch;
	}
	// 82A17E64: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A17E68: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A17E6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A17E70: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A17E74: 48000135  bl 0x82a17fa8
	ctx.lr = 0x82A17E78;
	sub_82A17FA8(ctx, base);
	// 82A17E78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A17E7C: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82A17E80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A17E84: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17E88: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17E8C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A17E90: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A17E94: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A17E98: 482915B8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A17E9C => {
    //   block [0x82A17E9C..0x82A17EA0)
	// 82A17E9C: 4BC486AD  bl 0x82660548
	ctx.lr = 0x82A17EA0;
	sub_82660548(ctx, base);
	pc = 0x82A17EA0; continue 'dispatch;
            }
            0x82A17EA0 => {
    //   block [0x82A17EA0..0x82A17EBC)
	// 82A17EA0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A17EA4: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17EA8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A17EAC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82A17EB0: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A17EB4: 41980008  blt cr6, 0x82a17ebc
	if ctx.cr[6].lt {
	pc = 0x82A17EBC; continue 'dispatch;
	}
	// 82A17EB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A17EBC; continue 'dispatch;
            }
            0x82A17EBC => {
    //   block [0x82A17EBC..0x82A17F04)
	// 82A17EBC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A17EC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A17EC4: 419A0040  beq cr6, 0x82a17f04
	if ctx.cr[6].eq {
	pc = 0x82A17F04; continue 'dispatch;
	}
	// 82A17EC8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A17ECC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A17ED0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A17ED4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A17ED8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A17EDC: 480000CD  bl 0x82a17fa8
	ctx.lr = 0x82A17EE0;
	sub_82A17FA8(ctx, base);
	// 82A17EE0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A17EE4: 9B5F0008  stb r26, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82A17EE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A17EEC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A17EF0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17EF4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A17EF8: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A17EFC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A17F00: 48291550  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A17F04 => {
    //   block [0x82A17F04..0x82A17F20)
	// 82A17F04: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A17F08: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A17F0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A17F10: 995F0008  stb r10, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82A17F14: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A17F18: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A17F1C: 48291534  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A17F20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A17F20 size=136
    let mut pc: u32 = 0x82A17F20;
    'dispatch: loop {
        match pc {
            0x82A17F20 => {
    //   block [0x82A17F20..0x82A17F4C)
	// 82A17F20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A17F24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A17F28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A17F2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A17F30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A17F34: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A17F38: 4B807321  bl 0x8221f258
	ctx.lr = 0x82A17F3C;
	sub_8221F258(ctx, base);
	// 82A17F3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A17F40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A17F44: 419A0008  beq cr6, 0x82a17f4c
	if ctx.cr[6].eq {
	pc = 0x82A17F4C; continue 'dispatch;
	}
	// 82A17F48: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A17F4C; continue 'dispatch;
            }
            0x82A17F4C => {
    //   block [0x82A17F4C..0x82A17F58)
	// 82A17F4C: 35430004  addic. r10, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[10].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A17F50: 41820008  beq 0x82a17f58
	if ctx.cr[0].eq {
	pc = 0x82A17F58; continue 'dispatch;
	}
	// 82A17F54: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A17F58; continue 'dispatch;
            }
            0x82A17F58 => {
    //   block [0x82A17F58..0x82A17F64)
	// 82A17F58: 35430008  addic. r10, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[10].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A17F5C: 41820008  beq 0x82a17f64
	if ctx.cr[0].eq {
	pc = 0x82A17F64; continue 'dispatch;
	}
	// 82A17F60: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82A17F64; continue 'dispatch;
            }
            0x82A17F64 => {
    //   block [0x82A17F64..0x82A17FA8)
	// 82A17F64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A17F68: 99630019  stb r11, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82A17F6C: 99430018  stb r10, 0x18(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 82A17F70: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82A17F74: 99430019  stb r10, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 82A17F78: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17F7C: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A17F80: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17F84: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A17F88: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A17F8C: 91080008  stw r8, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A17F90: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A17F94: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A17F98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A17F9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A17FA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A17FA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A17FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A17FA8 size=596
    let mut pc: u32 = 0x82A17FA8;
    'dispatch: loop {
        match pc {
            0x82A17FA8 => {
    //   block [0x82A17FA8..0x82A18020)
	// 82A17FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A17FAC: 48291455  bl 0x82ca9400
	ctx.lr = 0x82A17FB0;
	sub_82CA93D0(ctx, base);
	// 82A17FB0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A17FB4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A17FB8: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 82A17FBC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A17FC0: 61695554  ori r9, r11, 0x5554
	ctx.r[9].u64 = ctx.r[11].u64 | 21844;
	// 82A17FC4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A17FC8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A17FCC: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82A17FD0: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82A17FD4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A17FD8: 41980048  blt cr6, 0x82a18020
	if ctx.cr[6].lt {
	pc = 0x82A18020; continue 'dispatch;
	}
	// 82A17FDC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A17FE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A17FE4: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 82A17FE8: 4B8D9F59  bl 0x822f1f40
	ctx.lr = 0x82A17FEC;
	sub_822F1F40(ctx, base);
	// 82A17FEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A17FF0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A17FF4: 4B8D9DBD  bl 0x822f1db0
	ctx.lr = 0x82A17FF8;
	sub_822F1DB0(ctx, base);
	// 82A17FF8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A17FFC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A18000: 3B6A1720  addi r27, r10, 0x1720
	ctx.r[27].s64 = ctx.r[10].s64 + 5920;
	// 82A18004: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82A18008: 4B8D9E19  bl 0x822f1e20
	ctx.lr = 0x82A1800C;
	sub_822F1E20(ctx, base);
	// 82A1800C: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82A18010: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A18014: 4BC637CD  bl 0x8267b7e0
	ctx.lr = 0x82A18018;
	sub_8267B7E0(ctx, base);
	// 82A18018: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1801C: 4B7597F5  bl 0x82171810
	ctx.lr = 0x82A18020;
	sub_82171810(ctx, base);
	pc = 0x82A18020; continue 'dispatch;
            }
            0x82A18020 => {
    //   block [0x82A18020..0x82A18070)
	// 82A18020: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18024: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A18028: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A1802C: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82A18030: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A18034: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A18038: 480005E1  bl 0x82a18618
	ctx.lr = 0x82A1803C;
	sub_82A18618(ctx, base);
	// 82A1803C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A18040: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18044: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A18048: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1804C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A18050: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A18054: 409A001C  bne cr6, 0x82a18070
	if !ctx.cr[6].eq {
	pc = 0x82A18070; continue 'dispatch;
	}
	// 82A18058: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A1805C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18060: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A18064: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18068: 936A0008  stw r27, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82A1806C: 48000044  b 0x82a180b0
	pc = 0x82A180B0; continue 'dispatch;
            }
            0x82A18070 => {
    //   block [0x82A18070..0x82A18098)
	// 82A18070: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82A18074: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A18078: 419A0020  beq cr6, 0x82a18098
	if ctx.cr[6].eq {
	pc = 0x82A18098; continue 'dispatch;
	}
	// 82A1807C: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A18080: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18084: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A18088: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A1808C: 409A0024  bne cr6, 0x82a180b0
	if !ctx.cr[6].eq {
	pc = 0x82A180B0; continue 'dispatch;
	}
	// 82A18090: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82A18094: 4800001C  b 0x82a180b0
	pc = 0x82A180B0; continue 'dispatch;
            }
            0x82A18098 => {
    //   block [0x82A18098..0x82A180B0)
	// 82A18098: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82A1809C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A180A0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A180A4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A180A8: 409A0008  bne cr6, 0x82a180b0
	if !ctx.cr[6].eq {
	pc = 0x82A180B0; continue 'dispatch;
	}
	// 82A180AC: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x82A180B0; continue 'dispatch;
            }
            0x82A180B0 => {
    //   block [0x82A180B0..0x82A180D0)
	// 82A180B0: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A180B4: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 82A180B8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82A180BC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82A180C0: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A180C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A180C8: 409A0114  bne cr6, 0x82a181dc
	if !ctx.cr[6].eq {
	pc = 0x82A181DC; continue 'dispatch;
	}
	// 82A180CC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82A180D0; continue 'dispatch;
            }
            0x82A180D0 => {
    //   block [0x82A180D0..0x82A18118)
	// 82A180D0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A180D4: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A180D8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A180DC: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A180E0: 409A0078  bne cr6, 0x82a18158
	if !ctx.cr[6].eq {
	pc = 0x82A18158; continue 'dispatch;
	}
	// 82A180E4: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A180E8: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A180EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A180F0: 409A0028  bne cr6, 0x82a18118
	if !ctx.cr[6].eq {
	pc = 0x82A18118; continue 'dispatch;
	}
	// 82A180F4: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A180F8: 9BA90018  stb r29, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 82A180FC: 9BAA0018  stb r29, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 82A18100: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A18104: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18108: 9B870018  stb r28, 0x18(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(24 as u32), ctx.r[28].u8 ) };
	// 82A1810C: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A18110: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18114: 480000B4  b 0x82a181c8
	pc = 0x82A181C8; continue 'dispatch;
            }
            0x82A18118 => {
    //   block [0x82A18118..0x82A18130)
	// 82A18118: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1811C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A18120: 409A0010  bne cr6, 0x82a18130
	if !ctx.cr[6].eq {
	pc = 0x82A18130; continue 'dispatch;
	}
	// 82A18124: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A18128: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A1812C: 481F23BD  bl 0x82c0a4e8
	ctx.lr = 0x82A18130;
	sub_82C0A4E8(ctx, base);
	pc = 0x82A18130; continue 'dispatch;
            }
            0x82A18130 => {
    //   block [0x82A18130..0x82A18158)
	// 82A18130: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18134: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A18138: 9BAB0018  stb r29, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 82A1813C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18140: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18144: 9B890018  stb r28, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[28].u8 ) };
	// 82A18148: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1814C: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18150: 481F2411  bl 0x82c0a560
	ctx.lr = 0x82A18154;
	sub_82C0A560(ctx, base);
	// 82A18154: 48000074  b 0x82a181c8
	pc = 0x82A181C8; continue 'dispatch;
            }
            0x82A18158 => {
    //   block [0x82A18158..0x82A1818C)
	// 82A18158: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1815C: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A18160: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A18164: 409A0028  bne cr6, 0x82a1818c
	if !ctx.cr[6].eq {
	pc = 0x82A1818C; continue 'dispatch;
	}
	// 82A18168: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1816C: 9BA90018  stb r29, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 82A18170: 9BAA0018  stb r29, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 82A18174: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A18178: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1817C: 9B870018  stb r28, 0x18(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(24 as u32), ctx.r[28].u8 ) };
	// 82A18180: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A18184: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18188: 48000040  b 0x82a181c8
	pc = 0x82A181C8; continue 'dispatch;
            }
            0x82A1818C => {
    //   block [0x82A1818C..0x82A181A4)
	// 82A1818C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A18190: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A18194: 409A0010  bne cr6, 0x82a181a4
	if !ctx.cr[6].eq {
	pc = 0x82A181A4; continue 'dispatch;
	}
	// 82A18198: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1819C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A181A0: 481F23C1  bl 0x82c0a560
	ctx.lr = 0x82A181A4;
	sub_82C0A560(ctx, base);
	pc = 0x82A181A4; continue 'dispatch;
            }
            0x82A181A4 => {
    //   block [0x82A181A4..0x82A181C8)
	// 82A181A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A181A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A181AC: 9BAB0018  stb r29, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 82A181B0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A181B4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A181B8: 9B890018  stb r28, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[28].u8 ) };
	// 82A181BC: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A181C0: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A181C4: 481F2325  bl 0x82c0a4e8
	ctx.lr = 0x82A181C8;
	sub_82C0A4E8(ctx, base);
	pc = 0x82A181C8; continue 'dispatch;
            }
            0x82A181C8 => {
    //   block [0x82A181C8..0x82A181DC)
	// 82A181C8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A181CC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A181D0: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A181D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A181D8: 419AFEF8  beq cr6, 0x82a180d0
	if ctx.cr[6].eq {
	pc = 0x82A180D0; continue 'dispatch;
	}
	pc = 0x82A181DC; continue 'dispatch;
            }
            0x82A181DC => {
    //   block [0x82A181DC..0x82A181FC)
	// 82A181DC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A181E0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A181E4: 937A0004  stw r27, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A181E8: 93DA0000  stw r30, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A181EC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A181F0: 9BAA0018  stb r29, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 82A181F4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A181F8: 48291258  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A18200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A18200 size=1048
    let mut pc: u32 = 0x82A18200;
    'dispatch: loop {
        match pc {
            0x82A18200 => {
    //   block [0x82A18200..0x82A1826C)
	// 82A18200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A18204: 482911F9  bl 0x82ca93fc
	ctx.lr = 0x82A18208;
	sub_82CA93D0(ctx, base);
	// 82A18208: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1820C: F8A10100  std r5, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[5].u64 ) };
	// 82A18210: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A18214: 83E10104  lwz r31, 0x104(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A18218: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82A1821C: 897F0011  lbz r11, 0x11(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A18220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A18224: 419A0048  beq cr6, 0x82a1826c
	if ctx.cr[6].eq {
	pc = 0x82A1826C; continue 'dispatch;
	}
	// 82A18228: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A1822C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A18230: 388B16C0  addi r4, r11, 0x16c0
	ctx.r[4].s64 = ctx.r[11].s64 + 5824;
	// 82A18234: 4B8D9D0D  bl 0x822f1f40
	ctx.lr = 0x82A18238;
	sub_822F1F40(ctx, base);
	// 82A18238: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1823C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A18240: 4B8D9B71  bl 0x822f1db0
	ctx.lr = 0x82A18244;
	sub_822F1DB0(ctx, base);
	// 82A18244: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A18248: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1824C: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 82A18250: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A18254: 4B8D9BCD  bl 0x822f1e20
	ctx.lr = 0x82A18258;
	sub_822F1E20(ctx, base);
	// 82A18258: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82A1825C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A18260: 4BC63581  bl 0x8267b7e0
	ctx.lr = 0x82A18264;
	sub_8267B7E0(ctx, base);
	// 82A18264: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A18268: 4B7595A9  bl 0x82171810
	ctx.lr = 0x82A1826C;
	sub_82171810(ctx, base);
	pc = 0x82A1826C; continue 'dispatch;
            }
            0x82A1826C => {
    //   block [0x82A1826C..0x82A18290)
	// 82A1826C: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82A18270: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 82A18274: 4B8E7EB5  bl 0x82300128
	ctx.lr = 0x82A18278;
	sub_82300128(ctx, base);
	// 82A18278: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1827C: 896A0011  lbz r11, 0x11(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A18280: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A18284: 419A000C  beq cr6, 0x82a18290
	if ctx.cr[6].eq {
	pc = 0x82A18290; continue 'dispatch;
	}
	// 82A18288: 839A0008  lwz r28, 8(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1828C: 4800002C  b 0x82a182b8
	pc = 0x82A182B8; continue 'dispatch;
            }
            0x82A18290 => {
    //   block [0x82A18290..0x82A182A8)
	// 82A18290: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A18294: 892B0011  lbz r9, 0x11(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A18298: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1829C: 419A000C  beq cr6, 0x82a182a8
	if ctx.cr[6].eq {
	pc = 0x82A182A8; continue 'dispatch;
	}
	// 82A182A0: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 82A182A4: 48000014  b 0x82a182b8
	pc = 0x82A182B8; continue 'dispatch;
            }
            0x82A182A8 => {
    //   block [0x82A182A8..0x82A182B8)
	// 82A182A8: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A182AC: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A182B0: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A182B4: 409A00F0  bne cr6, 0x82a183a4
	if !ctx.cr[6].eq {
	pc = 0x82A183A4; continue 'dispatch;
	}
	pc = 0x82A182B8; continue 'dispatch;
            }
            0x82A182B8 => {
    //   block [0x82A182B8..0x82A182CC)
	// 82A182B8: 897C0011  lbz r11, 0x11(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A182BC: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A182C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A182C4: 409A0008  bne cr6, 0x82a182cc
	if !ctx.cr[6].eq {
	pc = 0x82A182CC; continue 'dispatch;
	}
	// 82A182C8: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82A182CC; continue 'dispatch;
            }
            0x82A182CC => {
    //   block [0x82A182CC..0x82A182E4)
	// 82A182CC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A182D0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A182D4: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A182D8: 409A000C  bne cr6, 0x82a182e4
	if !ctx.cr[6].eq {
	pc = 0x82A182E4; continue 'dispatch;
	}
	// 82A182DC: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A182E0: 4800001C  b 0x82a182fc
	pc = 0x82A182FC; continue 'dispatch;
            }
            0x82A182E4 => {
    //   block [0x82A182E4..0x82A182F8)
	// 82A182E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A182E8: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A182EC: 409A000C  bne cr6, 0x82a182f8
	if !ctx.cr[6].eq {
	pc = 0x82A182F8; continue 'dispatch;
	}
	// 82A182F0: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A182F4: 48000008  b 0x82a182fc
	pc = 0x82A182FC; continue 'dispatch;
            }
            0x82A182F8 => {
    //   block [0x82A182F8..0x82A182FC)
	// 82A182F8: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	pc = 0x82A182FC; continue 'dispatch;
            }
            0x82A182FC => {
    //   block [0x82A182FC..0x82A18320)
	// 82A182FC: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18300: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A18304: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A18308: 409A0044  bne cr6, 0x82a1834c
	if !ctx.cr[6].eq {
	pc = 0x82A1834C; continue 'dispatch;
	}
	// 82A1830C: 897C0011  lbz r11, 0x11(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A18310: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A18314: 419A000C  beq cr6, 0x82a18320
	if ctx.cr[6].eq {
	pc = 0x82A18320; continue 'dispatch;
	}
	// 82A18318: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82A1831C: 4800002C  b 0x82a18348
	pc = 0x82A18348; continue 'dispatch;
            }
            0x82A18320 => {
    //   block [0x82A18320..0x82A18334)
	// 82A18320: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A18324: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82A18328: 890B0011  lbz r8, 0x11(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A1832C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A18330: 409A0018  bne cr6, 0x82a18348
	if !ctx.cr[6].eq {
	pc = 0x82A18348; continue 'dispatch;
	}
	pc = 0x82A18334; continue 'dispatch;
            }
            0x82A18334 => {
    //   block [0x82A18334..0x82A18348)
	// 82A18334: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A18338: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1833C: 890B0011  lbz r8, 0x11(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A18340: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A18344: 419AFFF0  beq cr6, 0x82a18334
	if ctx.cr[6].eq {
	pc = 0x82A18334; continue 'dispatch;
	}
	pc = 0x82A18348; continue 'dispatch;
            }
            0x82A18348 => {
    //   block [0x82A18348..0x82A1834C)
	// 82A18348: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82A1834C; continue 'dispatch;
            }
            0x82A1834C => {
    //   block [0x82A1834C..0x82A18374)
	// 82A1834C: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18350: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A18354: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A18358: 409A00E0  bne cr6, 0x82a18438
	if !ctx.cr[6].eq {
	pc = 0x82A18438; continue 'dispatch;
	}
	// 82A1835C: 897C0011  lbz r11, 0x11(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A18360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A18364: 419A0010  beq cr6, 0x82a18374
	if ctx.cr[6].eq {
	pc = 0x82A18374; continue 'dispatch;
	}
	// 82A18368: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82A1836C: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A18370: 480000C8  b 0x82a18438
	pc = 0x82A18438; continue 'dispatch;
            }
            0x82A18374 => {
    //   block [0x82A18374..0x82A18388)
	// 82A18374: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A18378: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82A1837C: 890B0011  lbz r8, 0x11(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A18380: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A18384: 409A0018  bne cr6, 0x82a1839c
	if !ctx.cr[6].eq {
	pc = 0x82A1839C; continue 'dispatch;
	}
	pc = 0x82A18388; continue 'dispatch;
            }
            0x82A18388 => {
    //   block [0x82A18388..0x82A1839C)
	// 82A18388: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A1838C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A18390: 890B0011  lbz r8, 0x11(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A18394: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A18398: 419AFFF0  beq cr6, 0x82a18388
	if ctx.cr[6].eq {
	pc = 0x82A18388; continue 'dispatch;
	}
	pc = 0x82A1839C; continue 'dispatch;
            }
            0x82A1839C => {
    //   block [0x82A1839C..0x82A183A4)
	// 82A1839C: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A183A0: 48000098  b 0x82a18438
	pc = 0x82A18438; continue 'dispatch;
            }
            0x82A183A4 => {
    //   block [0x82A183A4..0x82A183C4)
	// 82A183A4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A183A8: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A183AC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A183B0: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A183B4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A183B8: 409A000C  bne cr6, 0x82a183c4
	if !ctx.cr[6].eq {
	pc = 0x82A183C4; continue 'dispatch;
	}
	// 82A183BC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82A183C0: 4800002C  b 0x82a183ec
	pc = 0x82A183EC; continue 'dispatch;
            }
            0x82A183C4 => {
    //   block [0x82A183C4..0x82A183D8)
	// 82A183C4: 895C0011  lbz r10, 0x11(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A183C8: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A183CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A183D0: 409A0008  bne cr6, 0x82a183d8
	if !ctx.cr[6].eq {
	pc = 0x82A183D8; continue 'dispatch;
	}
	// 82A183D4: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82A183D8; continue 'dispatch;
            }
            0x82A183D8 => {
    //   block [0x82A183D8..0x82A183EC)
	// 82A183D8: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A183DC: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A183E0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A183E4: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A183E8: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82A183EC; continue 'dispatch;
            }
            0x82A183EC => {
    //   block [0x82A183EC..0x82A18404)
	// 82A183EC: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A183F0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A183F4: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A183F8: 409A000C  bne cr6, 0x82a18404
	if !ctx.cr[6].eq {
	pc = 0x82A18404; continue 'dispatch;
	}
	// 82A183FC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A18400: 48000020  b 0x82a18420
	pc = 0x82A18420; continue 'dispatch;
            }
            0x82A18404 => {
    //   block [0x82A18404..0x82A1841C)
	// 82A18404: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18408: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1840C: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A18410: 409A000C  bne cr6, 0x82a1841c
	if !ctx.cr[6].eq {
	pc = 0x82A1841C; continue 'dispatch;
	}
	// 82A18414: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A18418: 48000008  b 0x82a18420
	pc = 0x82A18420; continue 'dispatch;
            }
            0x82A1841C => {
    //   block [0x82A1841C..0x82A18420)
	// 82A1841C: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82A18420; continue 'dispatch;
            }
            0x82A18420 => {
    //   block [0x82A18420..0x82A18438)
	// 82A18420: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18424: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A18428: 890B0010  lbz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1842C: 893A0010  lbz r9, 0x10(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A18430: 992B0010  stb r9, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u8 ) };
	// 82A18434: 991A0010  stb r8, 0x10(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(16 as u32), ctx.r[8].u8 ) };
	pc = 0x82A18438; continue 'dispatch;
            }
            0x82A18438 => {
    //   block [0x82A18438..0x82A1845C)
	// 82A18438: 897A0010  lbz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1843C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A18440: 409A0198  bne cr6, 0x82a185d8
	if !ctx.cr[6].eq {
	pc = 0x82A185D8; continue 'dispatch;
	}
	// 82A18444: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18448: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82A1844C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18450: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A18454: 419A0180  beq cr6, 0x82a185d4
	if ctx.cr[6].eq {
	pc = 0x82A185D4; continue 'dispatch;
	}
	// 82A18458: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82A1845C; continue 'dispatch;
            }
            0x82A1845C => {
    //   block [0x82A1845C..0x82A1849C)
	// 82A1845C: 897C0010  lbz r11, 0x10(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A18460: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A18464: 409A0170  bne cr6, 0x82a185d4
	if !ctx.cr[6].eq {
	pc = 0x82A185D4; continue 'dispatch;
	}
	// 82A18468: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1846C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A18470: 409A00A8  bne cr6, 0x82a18518
	if !ctx.cr[6].eq {
	pc = 0x82A18518; continue 'dispatch;
	}
	// 82A18474: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A18478: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1847C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A18480: 409A001C  bne cr6, 0x82a1849c
	if !ctx.cr[6].eq {
	pc = 0x82A1849C; continue 'dispatch;
	}
	// 82A18484: 9BAB0010  stb r29, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 82A18488: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1848C: 9BDF0010  stb r30, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	// 82A18490: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A18494: 480026D5  bl 0x82a1ab68
	ctx.lr = 0x82A18498;
	sub_82A1AB68(ctx, base);
	// 82A18498: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A1849C; continue 'dispatch;
            }
            0x82A1849C => {
    //   block [0x82A1849C..0x82A184C8)
	// 82A1849C: 894B0011  lbz r10, 0x11(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A184A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A184A4: 409A00C8  bne cr6, 0x82a1856c
	if !ctx.cr[6].eq {
	pc = 0x82A1856C; continue 'dispatch;
	}
	// 82A184A8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A184AC: 892A0010  lbz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A184B0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A184B4: 409A0014  bne cr6, 0x82a184c8
	if !ctx.cr[6].eq {
	pc = 0x82A184C8; continue 'dispatch;
	}
	// 82A184B8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A184BC: 892A0010  lbz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A184C0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A184C4: 419A00A4  beq cr6, 0x82a18568
	if ctx.cr[6].eq {
	pc = 0x82A18568; continue 'dispatch;
	}
	pc = 0x82A184C8; continue 'dispatch;
            }
            0x82A184C8 => {
    //   block [0x82A184C8..0x82A184F4)
	// 82A184C8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A184CC: 892A0010  lbz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A184D0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A184D4: 409A0020  bne cr6, 0x82a184f4
	if !ctx.cr[6].eq {
	pc = 0x82A184F4; continue 'dispatch;
	}
	// 82A184D8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A184DC: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82A184E0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A184E4: 9BAA0010  stb r29, 0x10(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 82A184E8: 9BCB0010  stb r30, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	// 82A184EC: 4B8FB52D  bl 0x82313a18
	ctx.lr = 0x82A184F0;
	sub_82313A18(ctx, base);
	// 82A184F0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A184F4; continue 'dispatch;
            }
            0x82A184F4 => {
    //   block [0x82A184F4..0x82A18518)
	// 82A184F4: 895F0010  lbz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A184F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A184FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A18500: 994B0010  stb r10, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u8 ) };
	// 82A18504: 9BBF0010  stb r29, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 82A18508: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1850C: 9BA90010  stb r29, 0x10(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 82A18510: 48002659  bl 0x82a1ab68
	ctx.lr = 0x82A18514;
	sub_82A1AB68(ctx, base);
	// 82A18514: 480000C0  b 0x82a185d4
	pc = 0x82A185D4; continue 'dispatch;
            }
            0x82A18518 => {
    //   block [0x82A18518..0x82A1853C)
	// 82A18518: 894B0010  lbz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1851C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A18520: 409A001C  bne cr6, 0x82a1853c
	if !ctx.cr[6].eq {
	pc = 0x82A1853C; continue 'dispatch;
	}
	// 82A18524: 9BAB0010  stb r29, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 82A18528: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1852C: 9BDF0010  stb r30, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	// 82A18530: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A18534: 4B8FB4E5  bl 0x82313a18
	ctx.lr = 0x82A18538;
	sub_82313A18(ctx, base);
	// 82A18538: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1853C; continue 'dispatch;
            }
            0x82A1853C => {
    //   block [0x82A1853C..0x82A18568)
	// 82A1853C: 894B0011  lbz r10, 0x11(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A18540: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A18544: 409A0028  bne cr6, 0x82a1856c
	if !ctx.cr[6].eq {
	pc = 0x82A1856C; continue 'dispatch;
	}
	// 82A18548: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1854C: 892A0010  lbz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A18550: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A18554: 409A0034  bne cr6, 0x82a18588
	if !ctx.cr[6].eq {
	pc = 0x82A18588; continue 'dispatch;
	}
	// 82A18558: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1855C: 892A0010  lbz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A18560: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A18564: 409A0024  bne cr6, 0x82a18588
	if !ctx.cr[6].eq {
	pc = 0x82A18588; continue 'dispatch;
	}
	pc = 0x82A18568; continue 'dispatch;
            }
            0x82A18568 => {
    //   block [0x82A18568..0x82A1856C)
	// 82A18568: 9BCB0010  stb r30, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	pc = 0x82A1856C; continue 'dispatch;
            }
            0x82A1856C => {
    //   block [0x82A1856C..0x82A18588)
	// 82A1856C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18570: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82A18574: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18578: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1857C: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A18580: 409AFEDC  bne cr6, 0x82a1845c
	if !ctx.cr[6].eq {
	pc = 0x82A1845C; continue 'dispatch;
	}
	// 82A18584: 48000050  b 0x82a185d4
	pc = 0x82A185D4; continue 'dispatch;
            }
            0x82A18588 => {
    //   block [0x82A18588..0x82A185B4)
	// 82A18588: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1858C: 892A0010  lbz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A18590: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A18594: 409A0020  bne cr6, 0x82a185b4
	if !ctx.cr[6].eq {
	pc = 0x82A185B4; continue 'dispatch;
	}
	// 82A18598: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1859C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82A185A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A185A4: 9BAA0010  stb r29, 0x10(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 82A185A8: 9BCB0010  stb r30, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	// 82A185AC: 480025BD  bl 0x82a1ab68
	ctx.lr = 0x82A185B0;
	sub_82A1AB68(ctx, base);
	// 82A185B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A185B4; continue 'dispatch;
            }
            0x82A185B4 => {
    //   block [0x82A185B4..0x82A185D4)
	// 82A185B4: 895F0010  lbz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A185B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A185BC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A185C0: 994B0010  stb r10, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u8 ) };
	// 82A185C4: 9BBF0010  stb r29, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 82A185C8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A185CC: 9BA90010  stb r29, 0x10(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	// 82A185D0: 4B8FB449  bl 0x82313a18
	ctx.lr = 0x82A185D4;
	sub_82313A18(ctx, base);
	pc = 0x82A185D4; continue 'dispatch;
            }
            0x82A185D4 => {
    //   block [0x82A185D4..0x82A185D8)
	// 82A185D4: 9BBC0010  stb r29, 0x10(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), ctx.r[29].u8 ) };
	pc = 0x82A185D8; continue 'dispatch;
            }
            0x82A185D8 => {
    //   block [0x82A185D8..0x82A18608)
	// 82A185D8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A185DC: 4B80375D  bl 0x8221bd38
	ctx.lr = 0x82A185E0;
	sub_8221BD38(ctx, base);
	// 82A185E0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A185E4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A185E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A185EC: 419A001C  beq cr6, 0x82a18608
	if ctx.cr[6].eq {
	pc = 0x82A18608; continue 'dispatch;
	}
	// 82A185F0: E9410100  ld r10, 0x100(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82A185F4: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 82A185F8: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82A185FC: F9590000  std r10, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82A18600: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A18604: 48290E48  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A18608 => {
    //   block [0x82A18608..0x82A18618)
	// 82A18608: E9610100  ld r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82A1860C: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A18610: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A18614: 48290E38  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A18618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A18618 size=140
    let mut pc: u32 = 0x82A18618;
    'dispatch: loop {
        match pc {
            0x82A18618 => {
    //   block [0x82A18618..0x82A18674)
	// 82A18618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1861C: 48290DED  bl 0x82ca9408
	ctx.lr = 0x82A18620;
	sub_82CA93D0(ctx, base);
	// 82A18620: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A18624: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82A18628: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1862C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A18630: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82A18634: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82A18638: 4B806C21  bl 0x8221f258
	ctx.lr = 0x82A1863C;
	sub_8221F258(ctx, base);
	// 82A1863C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A18640: 419A005C  beq cr6, 0x82a1869c
	if ctx.cr[6].eq {
	pc = 0x82A1869C; continue 'dispatch;
	}
	// 82A18644: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82A18648: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 82A1864C: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82A18650: 93830008  stw r28, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82A18654: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A18658: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A1865C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18660: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82A18664: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A18668: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1866C: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82A18670: 419A0020  beq cr6, 0x82a18690
	if ctx.cr[6].eq {
	pc = 0x82A18690; continue 'dispatch;
	}
	pc = 0x82A18674; continue 'dispatch;
            }
            0x82A18674 => {
    //   block [0x82A18674..0x82A18690)
	// 82A18674: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A18678: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1867C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A18680: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A18684: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A18688: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1868C: 4082FFE8  bne 0x82a18674
	if !ctx.cr[0].eq {
	pc = 0x82A18674; continue 'dispatch;
	}
	pc = 0x82A18690; continue 'dispatch;
            }
            0x82A18690 => {
    //   block [0x82A18690..0x82A1869C)
	// 82A18690: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A18694: 99630018  stb r11, 0x18(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 82A18698: 99630019  stb r11, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	pc = 0x82A1869C; continue 'dispatch;
            }
            0x82A1869C => {
    //   block [0x82A1869C..0x82A186A4)
	// 82A1869C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A186A0: 48290DB8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A186A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A186A8 size=72
    let mut pc: u32 = 0x82A186A8;
    'dispatch: loop {
        match pc {
            0x82A186A8 => {
    //   block [0x82A186A8..0x82A186DC)
	// 82A186A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A186AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A186B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A186B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A186B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A186BC: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A186C0: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82A186C4: 392B2720  addi r9, r11, 0x2720
	ctx.r[9].s64 = ctx.r[11].s64 + 10016;
	// 82A186C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A186CC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A186D0: 419A000C  beq cr6, 0x82a186dc
	if ctx.cr[6].eq {
	pc = 0x82A186DC; continue 'dispatch;
	}
	// 82A186D4: 4B803665  bl 0x8221bd38
	ctx.lr = 0x82A186D8;
	sub_8221BD38(ctx, base);
	// 82A186D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A186DC; continue 'dispatch;
            }
            0x82A186DC => {
    //   block [0x82A186DC..0x82A186F0)
	// 82A186DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A186E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A186E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A186E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A186EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A186F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A186F0 size=116
    let mut pc: u32 = 0x82A186F0;
    'dispatch: loop {
        match pc {
            0x82A186F0 => {
    //   block [0x82A186F0..0x82A1874C)
	// 82A186F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A186F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A186F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A186FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A18700: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A18704: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A18708: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1870C: 387F008C  addi r3, r31, 0x8c
	ctx.r[3].s64 = ctx.r[31].s64 + 140;
	// 82A18710: 394B2640  addi r10, r11, 0x2640
	ctx.r[10].s64 = ctx.r[11].s64 + 9792;
	// 82A18714: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A18718: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1871C: 4BFF884D  bl 0x82a10f68
	ctx.lr = 0x82A18720;
	sub_82A10F68(ctx, base);
	// 82A18720: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82A18724: 4BFF8765  bl 0x82a10e88
	ctx.lr = 0x82A18728;
	sub_82A10E88(ctx, base);
	// 82A18728: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 82A1872C: 57C807FE  clrlwi r8, r30, 0x1f
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A18730: 38E92720  addi r7, r9, 0x2720
	ctx.r[7].s64 = ctx.r[9].s64 + 10016;
	// 82A18734: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A18738: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A1873C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A18740: 419A000C  beq cr6, 0x82a1874c
	if ctx.cr[6].eq {
	pc = 0x82A1874C; continue 'dispatch;
	}
	// 82A18744: 4B8035F5  bl 0x8221bd38
	ctx.lr = 0x82A18748;
	sub_8221BD38(ctx, base);
	// 82A18748: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1874C; continue 'dispatch;
            }
            0x82A1874C => {
    //   block [0x82A1874C..0x82A18764)
	// 82A1874C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A18750: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A18754: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A18758: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1875C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A18760: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A18768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A18768 size=8
    let mut pc: u32 = 0x82A18768;
    'dispatch: loop {
        match pc {
            0x82A18768 => {
    //   block [0x82A18768..0x82A18770)
	// 82A18768: 886300C0  lbz r3, 0xc0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(192 as u32) ) } as u64;
	// 82A1876C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A18770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A18770 size=168
    let mut pc: u32 = 0x82A18770;
    'dispatch: loop {
        match pc {
            0x82A18770 => {
    //   block [0x82A18770..0x82A18804)
	// 82A18770: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A18774: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A18778: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A1877C: 409A0088  bne cr6, 0x82a18804
	if !ctx.cr[6].eq {
	pc = 0x82A18804; continue 'dispatch;
	}
	// 82A18780: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A18784: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A18788: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A1878C: 409A0078  bne cr6, 0x82a18804
	if !ctx.cr[6].eq {
	pc = 0x82A18804; continue 'dispatch;
	}
	// 82A18790: 89640010  lbz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A18794: 89430010  lbz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A18798: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A1879C: 409A0068  bne cr6, 0x82a18804
	if !ctx.cr[6].eq {
	pc = 0x82A18804; continue 'dispatch;
	}
	// 82A187A0: 89640011  lbz r11, 0x11(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A187A4: 89430011  lbz r10, 0x11(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A187A8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A187AC: 409A0058  bne cr6, 0x82a18804
	if !ctx.cr[6].eq {
	pc = 0x82A18804; continue 'dispatch;
	}
	// 82A187B0: 89640012  lbz r11, 0x12(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82A187B4: 89430012  lbz r10, 0x12(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(18 as u32) ) } as u64;
	// 82A187B8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A187BC: 409A0048  bne cr6, 0x82a18804
	if !ctx.cr[6].eq {
	pc = 0x82A18804; continue 'dispatch;
	}
	// 82A187C0: 89640013  lbz r11, 0x13(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(19 as u32) ) } as u64;
	// 82A187C4: 89430013  lbz r10, 0x13(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(19 as u32) ) } as u64;
	// 82A187C8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A187CC: 409A0038  bne cr6, 0x82a18804
	if !ctx.cr[6].eq {
	pc = 0x82A18804; continue 'dispatch;
	}
	// 82A187D0: 89640014  lbz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A187D4: 89430014  lbz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A187D8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A187DC: 409A0028  bne cr6, 0x82a18804
	if !ctx.cr[6].eq {
	pc = 0x82A18804; continue 'dispatch;
	}
	// 82A187E0: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A187E4: C1A40008  lfs f13, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A187E8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A187EC: 409A0018  bne cr6, 0x82a18804
	if !ctx.cr[6].eq {
	pc = 0x82A18804; continue 'dispatch;
	}
	// 82A187F0: C003000C  lfs f0, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A187F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A187F8: C1A4000C  lfs f13, 0xc(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A187FC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82A18800: 419A0008  beq cr6, 0x82a18808
	if ctx.cr[6].eq {
	pc = 0x82A18808; continue 'dispatch;
	}
	pc = 0x82A18804; continue 'dispatch;
            }
            0x82A18804 => {
    //   block [0x82A18804..0x82A18808)
	// 82A18804: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A18808; continue 'dispatch;
            }
            0x82A18808 => {
    //   block [0x82A18808..0x82A18818)
	// 82A18808: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A1880C: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A18810: 5543DFFE  rlwinm r3, r10, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82A18814: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A18818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A18818 size=80
    let mut pc: u32 = 0x82A18818;
    'dispatch: loop {
        match pc {
            0x82A18818 => {
    //   block [0x82A18818..0x82A18850)
	// 82A18818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1881C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A18820: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A18824: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A18828: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1882C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A18830: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A18834: 48820B8D  bl 0x832393c0
	ctx.lr = 0x82A18838;
	sub_832393C0(ctx, base);
	// 82A18838: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1883C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A18840: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A18844: 419A000C  beq cr6, 0x82a18850
	if ctx.cr[6].eq {
	pc = 0x82A18850; continue 'dispatch;
	}
	// 82A18848: 4B8034F1  bl 0x8221bd38
	ctx.lr = 0x82A1884C;
	sub_8221BD38(ctx, base);
	// 82A1884C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A18850; continue 'dispatch;
            }
            0x82A18850 => {
    //   block [0x82A18850..0x82A18868)
	// 82A18850: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A18854: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A18858: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1885C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A18860: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A18864: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A18868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A18868 size=216
    let mut pc: u32 = 0x82A18868;
    'dispatch: loop {
        match pc {
            0x82A18868 => {
    //   block [0x82A18868..0x82A18890)
	// 82A18868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1886C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A18870: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A18874: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18878: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82A1887C: 39000018  li r8, 0x18
	ctx.r[8].s64 = 24;
	// 82A18880: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A18884: 409A000C  bne cr6, 0x82a18890
	if !ctx.cr[6].eq {
	pc = 0x82A18890; continue 'dispatch;
	}
	// 82A18888: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A1888C: 48000010  b 0x82a1889c
	pc = 0x82A1889C; continue 'dispatch;
            }
            0x82A18890 => {
    //   block [0x82A18890..0x82A1889C)
	// 82A18890: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A18894: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A18898: 7D2943D6  divw r9, r9, r8
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	pc = 0x82A1889C; continue 'dispatch;
            }
            0x82A1889C => {
    //   block [0x82A1889C..0x82A18900)
	// 82A1889C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A188A0: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A188A4: 7D0A43D6  divw r8, r10, r8
	ctx.r[8].s32 = ctx.r[10].s32 / ctx.r[8].s32;
	// 82A188A8: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A188AC: 4098006C  bge cr6, 0x82a18918
	if !ctx.cr[6].lt {
	pc = 0x82A18918; continue 'dispatch;
	}
	// 82A188B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A188B4: 419A004C  beq cr6, 0x82a18900
	if ctx.cr[6].eq {
	pc = 0x82A18900; continue 'dispatch;
	}
	// 82A188B8: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A188BC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A188C0: C0060004  lfs f0, 4(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A188C4: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A188C8: C1A60008  lfs f13, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A188CC: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A188D0: C186000C  lfs f12, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A188D4: D18B000C  stfs f12, 0xc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A188D8: 89260010  lbz r9, 0x10(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A188DC: 992B0010  stb r9, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u8 ) };
	// 82A188E0: 89060011  lbz r8, 0x11(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A188E4: 990B0011  stb r8, 0x11(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(17 as u32), ctx.r[8].u8 ) };
	// 82A188E8: 88E60012  lbz r7, 0x12(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(18 as u32) ) } as u64;
	// 82A188EC: 98EB0012  stb r7, 0x12(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[7].u8 ) };
	// 82A188F0: 88A60013  lbz r5, 0x13(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(19 as u32) ) } as u64;
	// 82A188F4: 98AB0013  stb r5, 0x13(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(19 as u32), ctx.r[5].u8 ) };
	// 82A188F8: 88860014  lbz r4, 0x14(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A188FC: 988B0014  stb r4, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[4].u8 ) };
	pc = 0x82A18900; continue 'dispatch;
            }
            0x82A18900 => {
    //   block [0x82A18900..0x82A18918)
	// 82A18900: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82A18904: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A18908: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A1890C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A18910: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A18914: 4E800020  blr
	return;
            }
            0x82A18918 => {
    //   block [0x82A18918..0x82A18940)
	// 82A18918: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A1891C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A18920: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A18924: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A18928: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A1892C: 48000125  bl 0x82a18a50
	ctx.lr = 0x82A18930;
	sub_82A18A50(ctx, base);
	// 82A18930: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A18934: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A18938: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1893C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A18940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A18940 size=144
    let mut pc: u32 = 0x82A18940;
    'dispatch: loop {
        match pc {
            0x82A18940 => {
    //   block [0x82A18940..0x82A18970)
	// 82A18940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A18944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A18948: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1894C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A18950: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A18954: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 82A18958: 4B806901  bl 0x8221f258
	ctx.lr = 0x82A1895C;
	sub_8221F258(ctx, base);
	// 82A1895C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A18960: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A18964: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A18968: 419A0008  beq cr6, 0x82a18970
	if ctx.cr[6].eq {
	pc = 0x82A18970; continue 'dispatch;
	}
	// 82A1896C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82A18970; continue 'dispatch;
            }
            0x82A18970 => {
    //   block [0x82A18970..0x82A1897C)
	// 82A18970: 352B0004  addic. r9, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A18974: 41820008  beq 0x82a1897c
	if ctx.cr[0].eq {
	pc = 0x82A1897C; continue 'dispatch;
	}
	// 82A18978: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82A1897C; continue 'dispatch;
            }
            0x82A1897C => {
    //   block [0x82A1897C..0x82A18988)
	// 82A1897C: 352B0008  addic. r9, r11, 8
	ctx.xer.ca = (ctx.r[11].u32 > (!(8 as u32)));
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A18980: 41820008  beq 0x82a18988
	if ctx.cr[0].eq {
	pc = 0x82A18988; continue 'dispatch;
	}
	// 82A18984: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82A18988; continue 'dispatch;
            }
            0x82A18988 => {
    //   block [0x82A18988..0x82A189D0)
	// 82A18988: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A1898C: 994B0011  stb r10, 0x11(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(17 as u32), ctx.r[10].u8 ) };
	// 82A18990: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A18994: 992B0010  stb r9, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u8 ) };
	// 82A18998: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A1899C: 992B0011  stb r9, 0x11(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(17 as u32), ctx.r[9].u8 ) };
	// 82A189A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A189A4: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A189A8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A189AC: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A189B0: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A189B4: 91080008  stw r8, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A189B8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A189BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A189C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A189C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A189C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A189CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A189D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A189D0 size=124
    let mut pc: u32 = 0x82A189D0;
    'dispatch: loop {
        match pc {
            0x82A189D0 => {
    //   block [0x82A189D0..0x82A189E0)
	// 82A189D0: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 82A189D4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A189D8: 419A0060  beq cr6, 0x82a18a38
	if ctx.cr[6].eq {
	pc = 0x82A18A38; continue 'dispatch;
	}
	// 82A189DC: 39640008  addi r11, r4, 8
	ctx.r[11].s64 = ctx.r[4].s64 + 8;
	pc = 0x82A189E0; continue 'dispatch;
            }
            0x82A189E0 => {
    //   block [0x82A189E0..0x82A18A30)
	// 82A189E0: 354BFFF8  addic. r10, r11, -8
	ctx.xer.ca = (ctx.r[11].u32 > (!(-8 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A189E4: 4182004C  beq 0x82a18a30
	if ctx.cr[0].eq {
	pc = 0x82A18A30; continue 'dispatch;
	}
	// 82A189E8: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A189EC: 914BFFF8  stw r10, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[10].u32 ) };
	// 82A189F0: C0060004  lfs f0, 4(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A189F4: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82A189F8: C1A60008  lfs f13, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A189FC: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A18A00: C186000C  lfs f12, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A18A04: D18B0004  stfs f12, 4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A18A08: 89260010  lbz r9, 0x10(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A18A0C: 992B0008  stb r9, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u8 ) };
	// 82A18A10: 89060011  lbz r8, 0x11(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A18A14: 990B0009  stb r8, 9(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(9 as u32), ctx.r[8].u8 ) };
	// 82A18A18: 88E60012  lbz r7, 0x12(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(18 as u32) ) } as u64;
	// 82A18A1C: 98EB000A  stb r7, 0xa(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(10 as u32), ctx.r[7].u8 ) };
	// 82A18A20: 88660013  lbz r3, 0x13(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(19 as u32) ) } as u64;
	// 82A18A24: 986B000B  stb r3, 0xb(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(11 as u32), ctx.r[3].u8 ) };
	// 82A18A28: 89460014  lbz r10, 0x14(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A18A2C: 994B000C  stb r10, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u8 ) };
	pc = 0x82A18A30; continue 'dispatch;
            }
            0x82A18A30 => {
    //   block [0x82A18A30..0x82A18A38)
	// 82A18A30: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82A18A34: 4200FFAC  bdnz 0x82a189e0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A189E0; continue 'dispatch;
	}
	pc = 0x82A18A38; continue 'dispatch;
            }
            0x82A18A38 => {
    //   block [0x82A18A38..0x82A18A4C)
	// 82A18A38: 54AB083C  slwi r11, r5, 1
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A18A3C: 7D655A14  add r11, r5, r11
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 82A18A40: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A18A44: 7C6B2214  add r3, r11, r4
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82A18A48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A18A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A18A50 size=632
    let mut pc: u32 = 0x82A18A50;
    'dispatch: loop {
        match pc {
            0x82A18A50 => {
    //   block [0x82A18A50..0x82A18AC4)
	// 82A18A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A18A54: 482909B1  bl 0x82ca9404
	ctx.lr = 0x82A18A58;
	sub_82CA93D0(ctx, base);
	// 82A18A58: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A18A5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A18A60: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 82A18A64: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A18A68: C0060004  lfs f0, 4(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A18A6C: 89260010  lbz r9, 0x10(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A18A70: C1A60008  lfs f13, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A18A74: 89060011  lbz r8, 0x11(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A18A78: C186000C  lfs f12, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A18A7C: 88E60012  lbz r7, 0x12(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(18 as u32) ) } as u64;
	// 82A18A80: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82A18A84: 88A60013  lbz r5, 0x13(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(19 as u32) ) } as u64;
	// 82A18A88: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82A18A8C: 88860014  lbz r4, 0x14(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A18A90: D181005C  stfs f12, 0x5c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A18A94: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18A98: 3B600018  li r27, 0x18
	ctx.r[27].s64 = 24;
	// 82A18A9C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A18AA0: 99210060  stb r9, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u8 ) };
	// 82A18AA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A18AA8: 99010061  stb r8, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[8].u8 ) };
	// 82A18AAC: 98E10062  stb r7, 0x62(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[7].u8 ) };
	// 82A18AB0: 98A10063  stb r5, 0x63(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(99 as u32), ctx.r[5].u8 ) };
	// 82A18AB4: 98810064  stb r4, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[4].u8 ) };
	// 82A18AB8: 409A000C  bne cr6, 0x82a18ac4
	if !ctx.cr[6].eq {
	pc = 0x82A18AC4; continue 'dispatch;
	}
	// 82A18ABC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A18AC0: 48000010  b 0x82a18ad0
	pc = 0x82A18AD0; continue 'dispatch;
            }
            0x82A18AC4 => {
    //   block [0x82A18AC4..0x82A18AD0)
	// 82A18AC4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A18AC8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A18ACC: 7D29DBD6  divw r9, r9, r27
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x82A18AD0; continue 'dispatch;
            }
            0x82A18AD0 => {
    //   block [0x82A18AD0..0x82A18AFC)
	// 82A18AD0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A18AD4: 3D400AAA  lis r10, 0xaaa
	ctx.r[10].s64 = 178913280;
	// 82A18AD8: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82A18ADC: 614AAAAA  ori r10, r10, 0xaaaa
	ctx.r[10].u64 = ctx.r[10].u64 | 43690;
	// 82A18AE0: 7D68DBD6  divw r11, r8, r27
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	// 82A18AE4: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A18AE8: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 82A18AEC: 40980010  bge cr6, 0x82a18afc
	if !ctx.cr[6].lt {
	pc = 0x82A18AFC; continue 'dispatch;
	}
	// 82A18AF0: 4802E9D9  bl 0x82a474c8
	ctx.lr = 0x82A18AF4;
	sub_82A474C8(ctx, base);
	// 82A18AF4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A18AF8: 4829095C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A18AFC => {
    //   block [0x82A18AFC..0x82A18B20)
	// 82A18AFC: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82A18B00: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A18B04: 409800CC  bge cr6, 0x82a18bd0
	if !ctx.cr[6].lt {
	pc = 0x82A18BD0; continue 'dispatch;
	}
	// 82A18B08: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A18B0C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A18B10: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A18B14: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A18B18: 41980008  blt cr6, 0x82a18b20
	if ctx.cr[6].lt {
	pc = 0x82A18B20; continue 'dispatch;
	}
	// 82A18B1C: 7FAB4A14  add r29, r11, r9
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A18B20; continue 'dispatch;
            }
            0x82A18B20 => {
    //   block [0x82A18B20..0x82A18B2C)
	// 82A18B20: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A18B24: 40980008  bge cr6, 0x82a18b2c
	if !ctx.cr[6].lt {
	pc = 0x82A18B2C; continue 'dispatch;
	}
	// 82A18B28: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	pc = 0x82A18B2C; continue 'dispatch;
            }
            0x82A18B2C => {
    //   block [0x82A18B2C..0x82A18B9C)
	// 82A18B2C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A18B30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A18B34: 4806B5C5  bl 0x82a840f8
	ctx.lr = 0x82A18B38;
	sub_82A840F8(ctx, base);
	// 82A18B38: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A18B3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A18B40: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18B44: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A18B48: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A18B4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A18B50: 48000179  bl 0x82a18cc8
	ctx.lr = 0x82A18B54;
	sub_82A18CC8(ctx, base);
	// 82A18B54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A18B58: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A18B5C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A18B60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A18B64: 4BFFFE6D  bl 0x82a189d0
	ctx.lr = 0x82A18B68;
	sub_82A189D0(ctx, base);
	// 82A18B68: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A18B6C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A18B70: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A18B74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A18B78: 48000151  bl 0x82a18cc8
	ctx.lr = 0x82A18B7C;
	sub_82A18CC8(ctx, base);
	// 82A18B7C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18B80: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A18B84: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A18B88: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A18B8C: 7D6ADBD6  divw r11, r10, r27
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 82A18B90: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	// 82A18B94: 419A0008  beq cr6, 0x82a18b9c
	if ctx.cr[6].eq {
	pc = 0x82A18B9C; continue 'dispatch;
	}
	// 82A18B98: 4B8031A1  bl 0x8221bd38
	ctx.lr = 0x82A18B9C;
	sub_8221BD38(ctx, base);
	pc = 0x82A18B9C; continue 'dispatch;
            }
            0x82A18B9C => {
    //   block [0x82A18B9C..0x82A18BD0)
	// 82A18B9C: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A18BA0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A18BA4: 578A083C  slwi r10, r28, 1
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A18BA8: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82A18BAC: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 82A18BB0: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A18BB4: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A18BB8: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A18BBC: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A18BC0: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82A18BC4: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A18BC8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A18BCC: 48290888  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A18BD0 => {
    //   block [0x82A18BD0..0x82A18C34)
	// 82A18BD0: 83C100BC  lwz r30, 0xbc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A18BD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A18BD8: 7D7E2850  subf r11, r30, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[30].s64;
	// 82A18BDC: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 82A18BE0: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82A18BE4: 40980050  bge cr6, 0x82a18c34
	if !ctx.cr[6].lt {
	pc = 0x82A18C34; continue 'dispatch;
	}
	// 82A18BE8: 38DE0018  addi r6, r30, 0x18
	ctx.r[6].s64 = ctx.r[30].s64 + 24;
	// 82A18BEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A18BF0: 480000D9  bl 0x82a18cc8
	ctx.lr = 0x82A18BF4;
	sub_82A18CC8(ctx, base);
	// 82A18BF4: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A18BF8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A18BFC: 7D7E2050  subf r11, r30, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 82A18C00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A18C04: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 82A18C08: 20AA0001  subfic r5, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[10].s64;
	// 82A18C0C: 4BFFFDC5  bl 0x82a189d0
	ctx.lr = 0x82A18C10;
	sub_82A189D0(ctx, base);
	// 82A18C10: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A18C14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A18C18: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82A18C1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A18C20: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A18C24: 388BFFE8  addi r4, r11, -0x18
	ctx.r[4].s64 = ctx.r[11].s64 + -24;
	// 82A18C28: 48000121  bl 0x82a18d48
	ctx.lr = 0x82A18C2C;
	sub_82A18D48(ctx, base);
	// 82A18C2C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A18C30: 48290824  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A18C34 => {
    //   block [0x82A18C34..0x82A18C58)
	// 82A18C34: 3BA5FFE8  addi r29, r5, -0x18
	ctx.r[29].s64 = ctx.r[5].s64 + -24;
	// 82A18C38: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82A18C3C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A18C40: 48000089  bl 0x82a18cc8
	ctx.lr = 0x82A18C44;
	sub_82A18CC8(ctx, base);
	// 82A18C44: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82A18C48: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82A18C4C: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A18C50: 419A0060  beq cr6, 0x82a18cb0
	if ctx.cr[6].eq {
	pc = 0x82A18CB0; continue 'dispatch;
	}
	// 82A18C54: 396A0020  addi r11, r10, 0x20
	ctx.r[11].s64 = ctx.r[10].s64 + 32;
	pc = 0x82A18C58; continue 'dispatch;
            }
            0x82A18C58 => {
    //   block [0x82A18C58..0x82A18CB0)
	// 82A18C58: 394AFFE8  addi r10, r10, -0x18
	ctx.r[10].s64 = ctx.r[10].s64 + -24;
	// 82A18C5C: 396BFFE8  addi r11, r11, -0x18
	ctx.r[11].s64 = ctx.r[11].s64 + -24;
	// 82A18C60: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A18C64: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A18C68: 912BFFF8  stw r9, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[9].u32 ) };
	// 82A18C6C: C00BFFE4  lfs f0, -0x1c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A18C70: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82A18C74: C1ABFFE8  lfs f13, -0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A18C78: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A18C7C: C18BFFEC  lfs f12, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A18C80: D18B0004  stfs f12, 4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A18C84: 890BFFF0  lbz r8, -0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82A18C88: 990B0008  stb r8, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u8 ) };
	// 82A18C8C: 88EBFFF1  lbz r7, -0xf(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-15 as u32) ) } as u64;
	// 82A18C90: 98EB0009  stb r7, 9(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(9 as u32), ctx.r[7].u8 ) };
	// 82A18C94: 88CBFFF2  lbz r6, -0xe(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-14 as u32) ) } as u64;
	// 82A18C98: 98CB000A  stb r6, 0xa(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(10 as u32), ctx.r[6].u8 ) };
	// 82A18C9C: 88ABFFF3  lbz r5, -0xd(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-13 as u32) ) } as u64;
	// 82A18CA0: 98AB000B  stb r5, 0xb(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(11 as u32), ctx.r[5].u8 ) };
	// 82A18CA4: 888BFFF4  lbz r4, -0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82A18CA8: 988B000C  stb r4, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[4].u8 ) };
	// 82A18CAC: 409AFFAC  bne cr6, 0x82a18c58
	if !ctx.cr[6].eq {
	pc = 0x82A18C58; continue 'dispatch;
	}
	pc = 0x82A18CB0; continue 'dispatch;
            }
            0x82A18CB0 => {
    //   block [0x82A18CB0..0x82A18CC8)
	// 82A18CB0: 389E0018  addi r4, r30, 0x18
	ctx.r[4].s64 = ctx.r[30].s64 + 24;
	// 82A18CB4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A18CB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A18CBC: 4800008D  bl 0x82a18d48
	ctx.lr = 0x82A18CC0;
	sub_82A18D48(ctx, base);
	// 82A18CC0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A18CC4: 48290790  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A18CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A18CC8 size=124
    let mut pc: u32 = 0x82A18CC8;
    'dispatch: loop {
        match pc {
            0x82A18CC8 => {
    //   block [0x82A18CC8..0x82A18CDC)
	// 82A18CC8: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82A18CCC: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A18CD0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82A18CD4: 39640008  addi r11, r4, 8
	ctx.r[11].s64 = ctx.r[4].s64 + 8;
	// 82A18CD8: 7D441850  subf r10, r4, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	pc = 0x82A18CDC; continue 'dispatch;
            }
            0x82A18CDC => {
    //   block [0x82A18CDC..0x82A18D2C)
	// 82A18CDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A18CE0: 419A004C  beq cr6, 0x82a18d2c
	if ctx.cr[6].eq {
	pc = 0x82A18D2C; continue 'dispatch;
	}
	// 82A18CE4: 812BFFF8  lwz r9, -8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A18CE8: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A18CEC: C00BFFFC  lfs f0, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A18CF0: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A18CF4: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A18CF8: 7DAA5D2E  stfsx f13, r10, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82A18CFC: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A18D00: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82A18D04: 890B0008  lbz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A18D08: 99030010  stb r8, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[8].u8 ) };
	// 82A18D0C: 88EB0009  lbz r7, 9(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(9 as u32) ) } as u64;
	// 82A18D10: 98E30011  stb r7, 0x11(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(17 as u32), ctx.r[7].u8 ) };
	// 82A18D14: 88CB000A  lbz r6, 0xa(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(10 as u32) ) } as u64;
	// 82A18D18: 98C30012  stb r6, 0x12(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(18 as u32), ctx.r[6].u8 ) };
	// 82A18D1C: 888B000B  lbz r4, 0xb(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(11 as u32) ) } as u64;
	// 82A18D20: 98830013  stb r4, 0x13(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(19 as u32), ctx.r[4].u8 ) };
	// 82A18D24: 892B000C  lbz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A18D28: 99230014  stb r9, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[9].u8 ) };
	pc = 0x82A18D2C; continue 'dispatch;
            }
            0x82A18D2C => {
    //   block [0x82A18D2C..0x82A18D44)
	// 82A18D2C: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82A18D30: 38630018  addi r3, r3, 0x18
	ctx.r[3].s64 = ctx.r[3].s64 + 24;
	// 82A18D34: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82A18D38: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A18D3C: 409AFFA0  bne cr6, 0x82a18cdc
	if !ctx.cr[6].eq {
	pc = 0x82A18CDC; continue 'dispatch;
	}
	// 82A18D40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A18D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A18D48 size=104
    let mut pc: u32 = 0x82A18D48;
    'dispatch: loop {
        match pc {
            0x82A18D48 => {
    //   block [0x82A18D48..0x82A18D54)
	// 82A18D48: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A18D4C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82A18D50: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	pc = 0x82A18D54; continue 'dispatch;
            }
            0x82A18D54 => {
    //   block [0x82A18D54..0x82A18DB0)
	// 82A18D54: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A18D58: 914BFFF8  stw r10, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[10].u32 ) };
	// 82A18D5C: C0050004  lfs f0, 4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A18D60: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82A18D64: C1A50008  lfs f13, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A18D68: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A18D6C: C185000C  lfs f12, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A18D70: D18B0004  stfs f12, 4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82A18D74: 89250010  lbz r9, 0x10(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A18D78: 992B0008  stb r9, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u8 ) };
	// 82A18D7C: 89050011  lbz r8, 0x11(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A18D80: 990B0009  stb r8, 9(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(9 as u32), ctx.r[8].u8 ) };
	// 82A18D84: 88E50012  lbz r7, 0x12(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(18 as u32) ) } as u64;
	// 82A18D88: 98EB000A  stb r7, 0xa(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(10 as u32), ctx.r[7].u8 ) };
	// 82A18D8C: 88C50013  lbz r6, 0x13(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(19 as u32) ) } as u64;
	// 82A18D90: 98CB000B  stb r6, 0xb(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(11 as u32), ctx.r[6].u8 ) };
	// 82A18D94: 88650014  lbz r3, 0x14(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A18D98: 986B000C  stb r3, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[3].u8 ) };
	// 82A18D9C: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 82A18DA0: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 82A18DA4: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82A18DA8: 409AFFAC  bne cr6, 0x82a18d54
	if !ctx.cr[6].eq {
	pc = 0x82A18D54; continue 'dispatch;
	}
	// 82A18DAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A18DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A18DB0 size=664
    let mut pc: u32 = 0x82A18DB0;
    'dispatch: loop {
        match pc {
            0x82A18DB0 => {
    //   block [0x82A18DB0..0x82A18E0C)
	// 82A18DB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A18DB4: 48290651  bl 0x82ca9404
	ctx.lr = 0x82A18DB8;
	sub_82CA93D0(ctx, base);
	// 82A18DB8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A18DBC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A18DC0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A18DC4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A18DC8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A18DCC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A18DD0: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A18DD4: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18DD8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A18DDC: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82A18DE0: 38EBFFF8  addi r7, r11, -8
	ctx.r[7].s64 = ctx.r[11].s64 + -8;
	// 82A18DE4: 7D1C1E71  srawi. r28, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82A18DE8: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82A18DEC: 80CBFFF8  lwz r6, -8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A18DF0: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18DF4: 7CA407B4  extsw r4, r5
	ctx.r[4].s64 = ctx.r[5].s32 as i64;
	// 82A18DF8: F8810050  std r4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u64 ) };
	// 82A18DFC: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A18E00: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82A18E04: FFE06818  frsp f31, f13
	ctx.f[31].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A18E08: 40810050  ble 0x82a18e58
	if !ctx.cr[0].gt {
	pc = 0x82A18E58; continue 'dispatch;
	}
	pc = 0x82A18E0C; continue 'dispatch;
            }
            0x82A18E0C => {
    //   block [0x82A18E0C..0x82A18E34)
	// 82A18E0C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18E10: 57EA1838  slwi r10, r31, 3
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A18E14: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A18E18: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A18E1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A18E20: 7CAA582E  lwzx r5, r10, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A18E24: 409A0010  bne cr6, 0x82a18e34
	if !ctx.cr[6].eq {
	pc = 0x82A18E34; continue 'dispatch;
	}
	// 82A18E28: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A18E2C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A18E30: 48000018  b 0x82a18e48
	pc = 0x82A18E48; continue 'dispatch;
            }
            0x82A18E34 => {
    //   block [0x82A18E34..0x82A18E48)
	// 82A18E34: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A18E38: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A18E3C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A18E40: 7CEBDA14  add r7, r11, r27
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A18E44: 38C7FF70  addi r6, r7, -0x90
	ctx.r[6].s64 = ctx.r[7].s64 + -144;
	pc = 0x82A18E48; continue 'dispatch;
            }
            0x82A18E48 => {
    //   block [0x82A18E48..0x82A18E58)
	// 82A18E48: 48821E49  bl 0x8323ac90
	ctx.lr = 0x82A18E4C;
	sub_8323AC90(ctx, base);
	// 82A18E4C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A18E50: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82A18E54: 4198FFB8  blt cr6, 0x82a18e0c
	if ctx.cr[6].lt {
	pc = 0x82A18E0C; continue 'dispatch;
	}
	pc = 0x82A18E58; continue 'dispatch;
            }
            0x82A18E58 => {
    //   block [0x82A18E58..0x82A18E90)
	// 82A18E58: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A18E5C: 38FCFFFF  addi r7, r28, -1
	ctx.r[7].s64 = ctx.r[28].s64 + -1;
	// 82A18E60: 2F070004  cmpwi cr6, r7, 4
	ctx.cr[6].compare_i32(ctx.r[7].s32, 4, &mut ctx.xer);
	// 82A18E64: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A18E68: 4198015C  blt cr6, 0x82a18fc4
	if ctx.cr[6].lt {
	pc = 0x82A18FC4; continue 'dispatch;
	}
	// 82A18E6C: 3967FFFE  addi r11, r7, -2
	ctx.r[11].s64 = ctx.r[7].s64 + -2;
	// 82A18E70: 54E9003A  rlwinm r9, r7, 0, 0, 0x1d
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 82A18E74: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A18E78: 54E6F0BE  srwi r6, r7, 2
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A18E7C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A18E80: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A18E84: 550A2036  slwi r10, r8, 4
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A18E88: 7CE93850  subf r7, r9, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 82A18E8C: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	pc = 0x82A18E90; continue 'dispatch;
            }
            0x82A18E90 => {
    //   block [0x82A18E90..0x82A18EBC)
	// 82A18E90: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18E94: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 82A18E98: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82A18E9C: 80A9FFF8  lwz r5, -8(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A18EA0: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A18EA4: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18EA8: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18EAC: 7D234850  subf r9, r3, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 82A18EB0: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 82A18EB4: 41990008  bgt cr6, 0x82a18ebc
	if ctx.cr[6].gt {
	pc = 0x82A18EBC; continue 'dispatch;
	}
	// 82A18EB8: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	pc = 0x82A18EBC; continue 'dispatch;
            }
            0x82A18EBC => {
    //   block [0x82A18EBC..0x82A18F04)
	// 82A18EBC: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82A18EC0: 7D2507B4  extsw r5, r9
	ctx.r[5].s64 = ctx.r[9].s32 as i64;
	// 82A18EC4: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 82A18EC8: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A18ECC: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A18ED0: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A18ED4: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A18ED8: D14A0120  stfs f10, 0x120(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82A18EDC: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18EE0: 7C884A14  add r4, r8, r9
	ctx.r[4].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82A18EE4: 8064FFF8  lwz r3, -8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A18EE8: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82A18EEC: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18EF0: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18EF4: 7D282850  subf r9, r8, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[8].s64;
	// 82A18EF8: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 82A18EFC: 41990008  bgt cr6, 0x82a18f04
	if ctx.cr[6].gt {
	pc = 0x82A18F04; continue 'dispatch;
	}
	// 82A18F00: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	pc = 0x82A18F04; continue 'dispatch;
            }
            0x82A18F04 => {
    //   block [0x82A18F04..0x82A18F4C)
	// 82A18F04: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82A18F08: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 82A18F0C: 7D2507B4  extsw r5, r9
	ctx.r[5].s64 = ctx.r[9].s32 as i64;
	// 82A18F10: F8A10058  std r5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u64 ) };
	// 82A18F14: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A18F18: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A18F1C: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A18F20: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A18F24: D14A0090  stfs f10, 0x90(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82A18F28: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18F2C: 7D2B202E  lwzx r9, r11, r4
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82A18F30: 7C68202E  lwzx r3, r8, r4
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82A18F34: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18F38: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18F3C: 7D252050  subf r9, r5, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[5].s64;
	// 82A18F40: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 82A18F44: 41990008  bgt cr6, 0x82a18f4c
	if ctx.cr[6].gt {
	pc = 0x82A18F4C; continue 'dispatch;
	}
	// 82A18F48: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	pc = 0x82A18F4C; continue 'dispatch;
            }
            0x82A18F4C => {
    //   block [0x82A18F4C..0x82A18F94)
	// 82A18F4C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82A18F50: 7D2507B4  extsw r5, r9
	ctx.r[5].s64 = ctx.r[9].s32 as i64;
	// 82A18F54: F8A10060  std r5, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u64 ) };
	// 82A18F58: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A18F5C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A18F60: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A18F64: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A18F68: D14A0000  stfs f10, 0(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A18F6C: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18F70: 7C8B4A14  add r4, r11, r9
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A18F74: 8064FFF0  lwz r3, -0x10(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82A18F78: 7D28482E  lwzx r9, r8, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82A18F7C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18F80: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18F84: 7D254050  subf r9, r5, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[5].s64;
	// 82A18F88: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 82A18F8C: 41990008  bgt cr6, 0x82a18f94
	if ctx.cr[6].gt {
	pc = 0x82A18F94; continue 'dispatch;
	}
	// 82A18F90: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	pc = 0x82A18F94; continue 'dispatch;
            }
            0x82A18F94 => {
    //   block [0x82A18F94..0x82A18FC4)
	// 82A18F94: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82A18F98: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82A18F9C: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 82A18FA0: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	// 82A18FA4: F9010068  std r8, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 82A18FA8: C9A10068  lfd f13, 0x68(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A18FAC: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A18FB0: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A18FB4: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A18FB8: D14AFF70  stfs f10, -0x90(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-144 as u32), tmp.u32 ) };
	// 82A18FBC: 394AFDC0  addi r10, r10, -0x240
	ctx.r[10].s64 = ctx.r[10].s64 + -576;
	// 82A18FC0: 4082FED0  bne 0x82a18e90
	if !ctx.cr[0].eq {
	pc = 0x82A18E90; continue 'dispatch;
	}
	pc = 0x82A18FC4; continue 'dispatch;
            }
            0x82A18FC4 => {
    //   block [0x82A18FC4..0x82A18FE4)
	// 82A18FC4: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 82A18FC8: 41980074  blt cr6, 0x82a1903c
	if ctx.cr[6].lt {
	pc = 0x82A1903C; continue 'dispatch;
	}
	// 82A18FCC: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A18FD0: 54EA1838  slwi r10, r7, 3
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A18FD4: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82A18FD8: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82A18FDC: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A18FE0: 7D0BDA14  add r8, r11, r27
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	pc = 0x82A18FE4; continue 'dispatch;
            }
            0x82A18FE4 => {
    //   block [0x82A18FE4..0x82A1900C)
	// 82A18FE4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18FE8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A18FEC: 80EBFFF8  lwz r7, -8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A18FF0: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A18FF4: 80A70004  lwz r5, 4(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18FF8: 80860004  lwz r4, 4(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A18FFC: 7D652050  subf r11, r5, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[5].s64;
	// 82A19000: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A19004: 41990008  bgt cr6, 0x82a1900c
	if ctx.cr[6].gt {
	pc = 0x82A1900C; continue 'dispatch;
	}
	// 82A19008: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	pc = 0x82A1900C; continue 'dispatch;
            }
            0x82A1900C => {
    //   block [0x82A1900C..0x82A1903C)
	// 82A1900C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A19010: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A19014: 7D6707B4  extsw r7, r11
	ctx.r[7].s64 = ctx.r[11].s32 as i64;
	// 82A19018: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 82A1901C: F8E10068  std r7, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[7].u64 ) };
	// 82A19020: C9A10068  lfd f13, 0x68(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A19024: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A19028: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A1902C: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A19030: D1480000  stfs f10, 0(r8)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A19034: 3908FF70  addi r8, r8, -0x90
	ctx.r[8].s64 = ctx.r[8].s64 + -144;
	// 82A19038: 4082FFAC  bne 0x82a18fe4
	if !ctx.cr[0].eq {
	pc = 0x82A18FE4; continue 'dispatch;
	}
	pc = 0x82A1903C; continue 'dispatch;
            }
            0x82A1903C => {
    //   block [0x82A1903C..0x82A19048)
	// 82A1903C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A19040: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A19044: 48290410  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A19048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A19048 size=664
    let mut pc: u32 = 0x82A19048;
    'dispatch: loop {
        match pc {
            0x82A19048 => {
    //   block [0x82A19048..0x82A190A4)
	// 82A19048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1904C: 482903B9  bl 0x82ca9404
	ctx.lr = 0x82A19050;
	sub_82CA93D0(ctx, base);
	// 82A19050: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A19054: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A19058: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A1905C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A19060: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A19064: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A19068: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1906C: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19070: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A19074: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82A19078: 38EBFFF8  addi r7, r11, -8
	ctx.r[7].s64 = ctx.r[11].s64 + -8;
	// 82A1907C: 7D1C1E71  srawi. r28, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82A19080: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82A19084: 80CBFFF8  lwz r6, -8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A19088: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1908C: 7CA407B4  extsw r4, r5
	ctx.r[4].s64 = ctx.r[5].s32 as i64;
	// 82A19090: F8810050  std r4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u64 ) };
	// 82A19094: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A19098: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82A1909C: FFE06818  frsp f31, f13
	ctx.f[31].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A190A0: 40810050  ble 0x82a190f0
	if !ctx.cr[0].gt {
	pc = 0x82A190F0; continue 'dispatch;
	}
	pc = 0x82A190A4; continue 'dispatch;
            }
            0x82A190A4 => {
    //   block [0x82A190A4..0x82A190CC)
	// 82A190A4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A190A8: 57EA1838  slwi r10, r31, 3
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A190AC: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A190B0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A190B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A190B8: 7CAA582E  lwzx r5, r10, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A190BC: 409A0010  bne cr6, 0x82a190cc
	if !ctx.cr[6].eq {
	pc = 0x82A190CC; continue 'dispatch;
	}
	// 82A190C0: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A190C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A190C8: 48000018  b 0x82a190e0
	pc = 0x82A190E0; continue 'dispatch;
            }
            0x82A190CC => {
    //   block [0x82A190CC..0x82A190E0)
	// 82A190CC: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A190D0: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A190D4: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A190D8: 7CEBDA14  add r7, r11, r27
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A190DC: 38C7FFA0  addi r6, r7, -0x60
	ctx.r[6].s64 = ctx.r[7].s64 + -96;
	pc = 0x82A190E0; continue 'dispatch;
            }
            0x82A190E0 => {
    //   block [0x82A190E0..0x82A190F0)
	// 82A190E0: 488212D9  bl 0x8323a3b8
	ctx.lr = 0x82A190E4;
	sub_8323A3B8(ctx, base);
	// 82A190E4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A190E8: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82A190EC: 4198FFB8  blt cr6, 0x82a190a4
	if ctx.cr[6].lt {
	pc = 0x82A190A4; continue 'dispatch;
	}
	pc = 0x82A190F0; continue 'dispatch;
            }
            0x82A190F0 => {
    //   block [0x82A190F0..0x82A19128)
	// 82A190F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A190F4: 38FCFFFF  addi r7, r28, -1
	ctx.r[7].s64 = ctx.r[28].s64 + -1;
	// 82A190F8: 2F070004  cmpwi cr6, r7, 4
	ctx.cr[6].compare_i32(ctx.r[7].s32, 4, &mut ctx.xer);
	// 82A190FC: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A19100: 4198015C  blt cr6, 0x82a1925c
	if ctx.cr[6].lt {
	pc = 0x82A1925C; continue 'dispatch;
	}
	// 82A19104: 3967FFFE  addi r11, r7, -2
	ctx.r[11].s64 = ctx.r[7].s64 + -2;
	// 82A19108: 54E9003A  rlwinm r9, r7, 0, 0, 0x1d
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1910C: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A19110: 54E6F0BE  srwi r6, r7, 2
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A19114: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A19118: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1911C: 550A2834  slwi r10, r8, 5
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A19120: 7CE93850  subf r7, r9, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 82A19124: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	pc = 0x82A19128; continue 'dispatch;
            }
            0x82A19128 => {
    //   block [0x82A19128..0x82A19154)
	// 82A19128: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1912C: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 82A19130: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82A19134: 80A9FFF8  lwz r5, -8(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A19138: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1913C: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19140: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19144: 7D234850  subf r9, r3, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 82A19148: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 82A1914C: 41990008  bgt cr6, 0x82a19154
	if ctx.cr[6].gt {
	pc = 0x82A19154; continue 'dispatch;
	}
	// 82A19150: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	pc = 0x82A19154; continue 'dispatch;
            }
            0x82A19154 => {
    //   block [0x82A19154..0x82A1919C)
	// 82A19154: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82A19158: 7D2507B4  extsw r5, r9
	ctx.r[5].s64 = ctx.r[9].s32 as i64;
	// 82A1915C: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 82A19160: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A19164: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A19168: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A1916C: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A19170: D14A00C0  stfs f10, 0xc0(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82A19174: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19178: 7C884A14  add r4, r8, r9
	ctx.r[4].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82A1917C: 8064FFF8  lwz r3, -8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A19180: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82A19184: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19188: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1918C: 7D282850  subf r9, r8, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[8].s64;
	// 82A19190: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 82A19194: 41990008  bgt cr6, 0x82a1919c
	if ctx.cr[6].gt {
	pc = 0x82A1919C; continue 'dispatch;
	}
	// 82A19198: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	pc = 0x82A1919C; continue 'dispatch;
            }
            0x82A1919C => {
    //   block [0x82A1919C..0x82A191E4)
	// 82A1919C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82A191A0: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 82A191A4: 7D2507B4  extsw r5, r9
	ctx.r[5].s64 = ctx.r[9].s32 as i64;
	// 82A191A8: F8A10058  std r5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u64 ) };
	// 82A191AC: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A191B0: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A191B4: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A191B8: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A191BC: D14A0060  stfs f10, 0x60(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A191C0: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A191C4: 7D2B202E  lwzx r9, r11, r4
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82A191C8: 7C68202E  lwzx r3, r8, r4
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82A191CC: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A191D0: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A191D4: 7D252050  subf r9, r5, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[5].s64;
	// 82A191D8: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 82A191DC: 41990008  bgt cr6, 0x82a191e4
	if ctx.cr[6].gt {
	pc = 0x82A191E4; continue 'dispatch;
	}
	// 82A191E0: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	pc = 0x82A191E4; continue 'dispatch;
            }
            0x82A191E4 => {
    //   block [0x82A191E4..0x82A1922C)
	// 82A191E4: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82A191E8: 7D2507B4  extsw r5, r9
	ctx.r[5].s64 = ctx.r[9].s32 as i64;
	// 82A191EC: F8A10060  std r5, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u64 ) };
	// 82A191F0: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A191F4: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A191F8: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A191FC: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A19200: D14A0000  stfs f10, 0(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A19204: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19208: 7C8B4A14  add r4, r11, r9
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A1920C: 8064FFF0  lwz r3, -0x10(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82A19210: 7D28482E  lwzx r9, r8, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82A19214: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19218: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1921C: 7D254050  subf r9, r5, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[5].s64;
	// 82A19220: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 82A19224: 41990008  bgt cr6, 0x82a1922c
	if ctx.cr[6].gt {
	pc = 0x82A1922C; continue 'dispatch;
	}
	// 82A19228: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	pc = 0x82A1922C; continue 'dispatch;
            }
            0x82A1922C => {
    //   block [0x82A1922C..0x82A1925C)
	// 82A1922C: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82A19230: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82A19234: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 82A19238: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	// 82A1923C: F9010068  std r8, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 82A19240: C9A10068  lfd f13, 0x68(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A19244: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A19248: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A1924C: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A19250: D14AFFA0  stfs f10, -0x60(r10)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-96 as u32), tmp.u32 ) };
	// 82A19254: 394AFE80  addi r10, r10, -0x180
	ctx.r[10].s64 = ctx.r[10].s64 + -384;
	// 82A19258: 4082FED0  bne 0x82a19128
	if !ctx.cr[0].eq {
	pc = 0x82A19128; continue 'dispatch;
	}
	pc = 0x82A1925C; continue 'dispatch;
            }
            0x82A1925C => {
    //   block [0x82A1925C..0x82A1927C)
	// 82A1925C: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 82A19260: 41980074  blt cr6, 0x82a192d4
	if ctx.cr[6].lt {
	pc = 0x82A192D4; continue 'dispatch;
	}
	// 82A19264: 54EB083C  slwi r11, r7, 1
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A19268: 54EA1838  slwi r10, r7, 3
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1926C: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82A19270: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 82A19274: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A19278: 7D0BDA14  add r8, r11, r27
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	pc = 0x82A1927C; continue 'dispatch;
            }
            0x82A1927C => {
    //   block [0x82A1927C..0x82A192A4)
	// 82A1927C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19280: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A19284: 80EBFFF8  lwz r7, -8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A19288: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1928C: 80A70004  lwz r5, 4(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19290: 80860004  lwz r4, 4(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19294: 7D652050  subf r11, r5, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[5].s64;
	// 82A19298: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A1929C: 41990008  bgt cr6, 0x82a192a4
	if ctx.cr[6].gt {
	pc = 0x82A192A4; continue 'dispatch;
	}
	// 82A192A0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	pc = 0x82A192A4; continue 'dispatch;
            }
            0x82A192A4 => {
    //   block [0x82A192A4..0x82A192D4)
	// 82A192A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A192A8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A192AC: 7D6707B4  extsw r7, r11
	ctx.r[7].s64 = ctx.r[11].s32 as i64;
	// 82A192B0: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 82A192B4: F8E10068  std r7, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[7].u64 ) };
	// 82A192B8: C9A10068  lfd f13, 0x68(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A192BC: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A192C0: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A192C4: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A192C8: D1480000  stfs f10, 0(r8)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A192CC: 3908FFA0  addi r8, r8, -0x60
	ctx.r[8].s64 = ctx.r[8].s64 + -96;
	// 82A192D0: 4082FFAC  bne 0x82a1927c
	if !ctx.cr[0].eq {
	pc = 0x82A1927C; continue 'dispatch;
	}
	pc = 0x82A192D4; continue 'dispatch;
            }
            0x82A192D4 => {
    //   block [0x82A192D4..0x82A192E0)
	// 82A192D4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A192D8: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A192DC: 48290178  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A192E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A192E0 size=640
    let mut pc: u32 = 0x82A192E0;
    'dispatch: loop {
        match pc {
            0x82A192E0 => {
    //   block [0x82A192E0..0x82A1933C)
	// 82A192E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A192E4: 48290121  bl 0x82ca9404
	ctx.lr = 0x82A192E8;
	sub_82CA93D0(ctx, base);
	// 82A192E8: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A192EC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A192F0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A192F4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A192F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A192FC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A19300: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A19304: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19308: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A1930C: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82A19310: 38EBFFF8  addi r7, r11, -8
	ctx.r[7].s64 = ctx.r[11].s64 + -8;
	// 82A19314: 7D1C1E71  srawi. r28, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82A19318: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82A1931C: 80CBFFF8  lwz r6, -8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A19320: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19324: 7CA407B4  extsw r4, r5
	ctx.r[4].s64 = ctx.r[5].s32 as i64;
	// 82A19328: F8810050  std r4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u64 ) };
	// 82A1932C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A19330: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82A19334: FFE06818  frsp f31, f13
	ctx.f[31].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A19338: 40810048  ble 0x82a19380
	if !ctx.cr[0].gt {
	pc = 0x82A19380; continue 'dispatch;
	}
	pc = 0x82A1933C; continue 'dispatch;
            }
            0x82A1933C => {
    //   block [0x82A1933C..0x82A19364)
	// 82A1933C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19340: 57EA1838  slwi r10, r31, 3
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A19344: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A19348: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A1934C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A19350: 7CAA582E  lwzx r5, r10, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A19354: 409A0010  bne cr6, 0x82a19364
	if !ctx.cr[6].eq {
	pc = 0x82A19364; continue 'dispatch;
	}
	// 82A19358: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A1935C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A19360: 48000010  b 0x82a19370
	pc = 0x82A19370; continue 'dispatch;
            }
            0x82A19364 => {
    //   block [0x82A19364..0x82A19370)
	// 82A19364: 57EB3032  slwi r11, r31, 6
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A19368: 7CEBDA14  add r7, r11, r27
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A1936C: 38C7FFC0  addi r6, r7, -0x40
	ctx.r[6].s64 = ctx.r[7].s64 + -64;
	pc = 0x82A19370; continue 'dispatch;
            }
            0x82A19370 => {
    //   block [0x82A19370..0x82A19380)
	// 82A19370: 48820771  bl 0x83239ae0
	ctx.lr = 0x82A19374;
	sub_83239AE0(ctx, base);
	// 82A19374: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A19378: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82A1937C: 4198FFC0  blt cr6, 0x82a1933c
	if ctx.cr[6].lt {
	pc = 0x82A1933C; continue 'dispatch;
	}
	pc = 0x82A19380; continue 'dispatch;
            }
            0x82A19380 => {
    //   block [0x82A19380..0x82A193B0)
	// 82A19380: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A19384: 38FCFFFF  addi r7, r28, -1
	ctx.r[7].s64 = ctx.r[28].s64 + -1;
	// 82A19388: 2F070004  cmpwi cr6, r7, 4
	ctx.cr[6].compare_i32(ctx.r[7].s32, 4, &mut ctx.xer);
	// 82A1938C: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A19390: 41980154  blt cr6, 0x82a194e4
	if ctx.cr[6].lt {
	pc = 0x82A194E4; continue 'dispatch;
	}
	// 82A19394: 3967FFFE  addi r11, r7, -2
	ctx.r[11].s64 = ctx.r[7].s64 + -2;
	// 82A19398: 54E8003A  rlwinm r8, r7, 0, 0, 0x1d
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1939C: 556A3032  slwi r10, r11, 6
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A193A0: 54E6F0BE  srwi r6, r7, 2
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A193A4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A193A8: 7D2ADA14  add r9, r10, r27
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82A193AC: 7CE83850  subf r7, r8, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	pc = 0x82A193B0; continue 'dispatch;
            }
            0x82A193B0 => {
    //   block [0x82A193B0..0x82A193DC)
	// 82A193B0: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A193B4: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 82A193B8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A193BC: 80AAFFF8  lwz r5, -8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A193C0: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A193C4: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A193C8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A193CC: 7D435050  subf r10, r3, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 82A193D0: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82A193D4: 41990008  bgt cr6, 0x82a193dc
	if ctx.cr[6].gt {
	pc = 0x82A193DC; continue 'dispatch;
	}
	// 82A193D8: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	pc = 0x82A193DC; continue 'dispatch;
            }
            0x82A193DC => {
    //   block [0x82A193DC..0x82A19424)
	// 82A193DC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A193E0: 7D4507B4  extsw r5, r10
	ctx.r[5].s64 = ctx.r[10].s32 as i64;
	// 82A193E4: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 82A193E8: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A193EC: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A193F0: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A193F4: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A193F8: D1490080  stfs f10, 0x80(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82A193FC: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19400: 7C885214  add r4, r8, r10
	ctx.r[4].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A19404: 8064FFF8  lwz r3, -8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A19408: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A1940C: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19410: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19414: 7D482850  subf r10, r8, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[8].s64;
	// 82A19418: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82A1941C: 41990008  bgt cr6, 0x82a19424
	if ctx.cr[6].gt {
	pc = 0x82A19424; continue 'dispatch;
	}
	// 82A19420: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	pc = 0x82A19424; continue 'dispatch;
            }
            0x82A19424 => {
    //   block [0x82A19424..0x82A1946C)
	// 82A19424: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A19428: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 82A1942C: 7D4507B4  extsw r5, r10
	ctx.r[5].s64 = ctx.r[10].s32 as i64;
	// 82A19430: F8A10058  std r5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u64 ) };
	// 82A19434: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A19438: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A1943C: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A19440: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A19444: D1490040  stfs f10, 0x40(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82A19448: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1944C: 7C68202E  lwzx r3, r8, r4
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82A19450: 7D4B202E  lwzx r10, r11, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82A19454: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19458: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1945C: 7D442850  subf r10, r4, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 82A19460: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82A19464: 41990008  bgt cr6, 0x82a1946c
	if ctx.cr[6].gt {
	pc = 0x82A1946C; continue 'dispatch;
	}
	// 82A19468: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	pc = 0x82A1946C; continue 'dispatch;
            }
            0x82A1946C => {
    //   block [0x82A1946C..0x82A194B4)
	// 82A1946C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A19470: 7D4507B4  extsw r5, r10
	ctx.r[5].s64 = ctx.r[10].s32 as i64;
	// 82A19474: F8A10060  std r5, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u64 ) };
	// 82A19478: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A1947C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A19480: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A19484: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A19488: D1490000  stfs f10, 0(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A1948C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19490: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A19494: 8064FFF0  lwz r3, -0x10(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82A19498: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A1949C: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A194A0: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A194A4: 7D454050  subf r10, r5, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[5].s64;
	// 82A194A8: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82A194AC: 41990008  bgt cr6, 0x82a194b4
	if ctx.cr[6].gt {
	pc = 0x82A194B4; continue 'dispatch;
	}
	// 82A194B0: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	pc = 0x82A194B4; continue 'dispatch;
            }
            0x82A194B4 => {
    //   block [0x82A194B4..0x82A194E4)
	// 82A194B4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A194B8: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82A194BC: 7D4807B4  extsw r8, r10
	ctx.r[8].s64 = ctx.r[10].s32 as i64;
	// 82A194C0: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	// 82A194C4: F9010068  std r8, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 82A194C8: C9A10068  lfd f13, 0x68(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A194CC: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A194D0: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A194D4: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A194D8: D149FFC0  stfs f10, -0x40(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-64 as u32), tmp.u32 ) };
	// 82A194DC: 3929FF00  addi r9, r9, -0x100
	ctx.r[9].s64 = ctx.r[9].s64 + -256;
	// 82A194E0: 4082FED0  bne 0x82a193b0
	if !ctx.cr[0].eq {
	pc = 0x82A193B0; continue 'dispatch;
	}
	pc = 0x82A194E4; continue 'dispatch;
            }
            0x82A194E4 => {
    //   block [0x82A194E4..0x82A194FC)
	// 82A194E4: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 82A194E8: 4198006C  blt cr6, 0x82a19554
	if ctx.cr[6].lt {
	pc = 0x82A19554; continue 'dispatch;
	}
	// 82A194EC: 54EB3032  slwi r11, r7, 6
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(6);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A194F0: 54EA1838  slwi r10, r7, 3
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A194F4: 7D0BDA14  add r8, r11, r27
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A194F8: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	pc = 0x82A194FC; continue 'dispatch;
            }
            0x82A194FC => {
    //   block [0x82A194FC..0x82A19524)
	// 82A194FC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19500: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A19504: 80EBFFF8  lwz r7, -8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A19508: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1950C: 80A70004  lwz r5, 4(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19510: 80860004  lwz r4, 4(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19514: 7D652050  subf r11, r5, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[5].s64;
	// 82A19518: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A1951C: 41990008  bgt cr6, 0x82a19524
	if ctx.cr[6].gt {
	pc = 0x82A19524; continue 'dispatch;
	}
	// 82A19520: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	pc = 0x82A19524; continue 'dispatch;
            }
            0x82A19524 => {
    //   block [0x82A19524..0x82A19554)
	// 82A19524: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A19528: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A1952C: 7D6707B4  extsw r7, r11
	ctx.r[7].s64 = ctx.r[11].s32 as i64;
	// 82A19530: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 82A19534: F8E10068  std r7, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[7].u64 ) };
	// 82A19538: C9A10068  lfd f13, 0x68(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A1953C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A19540: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A19544: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A19548: D1480000  stfs f10, 0(r8)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A1954C: 3908FFC0  addi r8, r8, -0x40
	ctx.r[8].s64 = ctx.r[8].s64 + -64;
	// 82A19550: 4082FFAC  bne 0x82a194fc
	if !ctx.cr[0].eq {
	pc = 0x82A194FC; continue 'dispatch;
	}
	pc = 0x82A19554; continue 'dispatch;
            }
            0x82A19554 => {
    //   block [0x82A19554..0x82A19560)
	// 82A19554: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A19558: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A1955C: 4828FEF8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A19560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A19560 size=640
    let mut pc: u32 = 0x82A19560;
    'dispatch: loop {
        match pc {
            0x82A19560 => {
    //   block [0x82A19560..0x82A195BC)
	// 82A19560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A19564: 4828FEA1  bl 0x82ca9404
	ctx.lr = 0x82A19568;
	sub_82CA93D0(ctx, base);
	// 82A19568: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82A1956C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A19570: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A19574: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A19578: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1957C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A19580: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A19584: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19588: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A1958C: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82A19590: 38EBFFF8  addi r7, r11, -8
	ctx.r[7].s64 = ctx.r[11].s64 + -8;
	// 82A19594: 7D1C1E71  srawi. r28, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82A19598: 90E1006C  stw r7, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[7].u32 ) };
	// 82A1959C: 80CBFFF8  lwz r6, -8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A195A0: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A195A4: 7CA407B4  extsw r4, r5
	ctx.r[4].s64 = ctx.r[5].s32 as i64;
	// 82A195A8: F8810050  std r4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u64 ) };
	// 82A195AC: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A195B0: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82A195B4: FFE06818  frsp f31, f13
	ctx.f[31].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82A195B8: 40810048  ble 0x82a19600
	if !ctx.cr[0].gt {
	pc = 0x82A19600; continue 'dispatch;
	}
	pc = 0x82A195BC; continue 'dispatch;
            }
            0x82A195BC => {
    //   block [0x82A195BC..0x82A195E4)
	// 82A195BC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A195C0: 57EA1838  slwi r10, r31, 3
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A195C4: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A195C8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82A195CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A195D0: 7CAA582E  lwzx r5, r10, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A195D4: 409A0010  bne cr6, 0x82a195e4
	if !ctx.cr[6].eq {
	pc = 0x82A195E4; continue 'dispatch;
	}
	// 82A195D8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82A195DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A195E0: 48000010  b 0x82a195f0
	pc = 0x82A195F0; continue 'dispatch;
            }
            0x82A195E4 => {
    //   block [0x82A195E4..0x82A195F0)
	// 82A195E4: 1D7F0044  mulli r11, r31, 0x44
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 68 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A195E8: 7CEBDA14  add r7, r11, r27
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A195EC: 38C7FFBC  addi r6, r7, -0x44
	ctx.r[6].s64 = ctx.r[7].s64 + -68;
	pc = 0x82A195F0; continue 'dispatch;
            }
            0x82A195F0 => {
    //   block [0x82A195F0..0x82A19600)
	// 82A195F0: 4881FE41  bl 0x83239430
	ctx.lr = 0x82A195F4;
	sub_83239430(ctx, base);
	// 82A195F4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A195F8: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82A195FC: 4198FFC0  blt cr6, 0x82a195bc
	if ctx.cr[6].lt {
	pc = 0x82A195BC; continue 'dispatch;
	}
	pc = 0x82A19600; continue 'dispatch;
            }
            0x82A19600 => {
    //   block [0x82A19600..0x82A19630)
	// 82A19600: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A19604: 38FCFFFF  addi r7, r28, -1
	ctx.r[7].s64 = ctx.r[28].s64 + -1;
	// 82A19608: 2F070004  cmpwi cr6, r7, 4
	ctx.cr[6].compare_i32(ctx.r[7].s32, 4, &mut ctx.xer);
	// 82A1960C: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A19610: 41980154  blt cr6, 0x82a19764
	if ctx.cr[6].lt {
	pc = 0x82A19764; continue 'dispatch;
	}
	// 82A19614: 3967FFFE  addi r11, r7, -2
	ctx.r[11].s64 = ctx.r[7].s64 + -2;
	// 82A19618: 54E8003A  rlwinm r8, r7, 0, 0, 0x1d
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1961C: 1D4B0044  mulli r10, r11, 0x44
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 68 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A19620: 54E6F0BE  srwi r6, r7, 2
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shr(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A19624: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A19628: 7D2ADA14  add r9, r10, r27
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 82A1962C: 7CE83850  subf r7, r8, r7
	ctx.r[7].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	pc = 0x82A19630; continue 'dispatch;
            }
            0x82A19630 => {
    //   block [0x82A19630..0x82A1965C)
	// 82A19630: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19634: 390B0010  addi r8, r11, 0x10
	ctx.r[8].s64 = ctx.r[11].s64 + 16;
	// 82A19638: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A1963C: 80AAFFF8  lwz r5, -8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A19640: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A19644: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19648: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1964C: 7D435050  subf r10, r3, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 82A19650: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82A19654: 41990008  bgt cr6, 0x82a1965c
	if ctx.cr[6].gt {
	pc = 0x82A1965C; continue 'dispatch;
	}
	// 82A19658: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	pc = 0x82A1965C; continue 'dispatch;
            }
            0x82A1965C => {
    //   block [0x82A1965C..0x82A196A4)
	// 82A1965C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A19660: 7D4507B4  extsw r5, r10
	ctx.r[5].s64 = ctx.r[10].s32 as i64;
	// 82A19664: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 82A19668: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A1966C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A19670: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A19674: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A19678: D1490088  stfs f10, 0x88(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82A1967C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19680: 7C885214  add r4, r8, r10
	ctx.r[4].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A19684: 8064FFF8  lwz r3, -8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A19688: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A1968C: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19690: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19694: 7D482850  subf r10, r8, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[8].s64;
	// 82A19698: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82A1969C: 41990008  bgt cr6, 0x82a196a4
	if ctx.cr[6].gt {
	pc = 0x82A196A4; continue 'dispatch;
	}
	// 82A196A0: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	pc = 0x82A196A4; continue 'dispatch;
            }
            0x82A196A4 => {
    //   block [0x82A196A4..0x82A196EC)
	// 82A196A4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A196A8: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 82A196AC: 7D4507B4  extsw r5, r10
	ctx.r[5].s64 = ctx.r[10].s32 as i64;
	// 82A196B0: F8A10058  std r5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u64 ) };
	// 82A196B4: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A196B8: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A196BC: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A196C0: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A196C4: D1490044  stfs f10, 0x44(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82A196C8: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A196CC: 7C68202E  lwzx r3, r8, r4
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82A196D0: 7D4B202E  lwzx r10, r11, r4
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82A196D4: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A196D8: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A196DC: 7D442850  subf r10, r4, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 82A196E0: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82A196E4: 41990008  bgt cr6, 0x82a196ec
	if ctx.cr[6].gt {
	pc = 0x82A196EC; continue 'dispatch;
	}
	// 82A196E8: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	pc = 0x82A196EC; continue 'dispatch;
            }
            0x82A196EC => {
    //   block [0x82A196EC..0x82A19734)
	// 82A196EC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A196F0: 7D4507B4  extsw r5, r10
	ctx.r[5].s64 = ctx.r[10].s32 as i64;
	// 82A196F4: F8A10060  std r5, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u64 ) };
	// 82A196F8: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A196FC: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A19700: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A19704: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A19708: D1490000  stfs f10, 0(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A1970C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19710: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A19714: 8064FFF0  lwz r3, -0x10(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82A19718: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A1971C: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19720: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19724: 7D454050  subf r10, r5, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[5].s64;
	// 82A19728: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82A1972C: 41990008  bgt cr6, 0x82a19734
	if ctx.cr[6].gt {
	pc = 0x82A19734; continue 'dispatch;
	}
	// 82A19730: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	pc = 0x82A19734; continue 'dispatch;
            }
            0x82A19734 => {
    //   block [0x82A19734..0x82A19764)
	// 82A19734: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A19738: 34C6FFFF  addic. r6, r6, -1
	ctx.xer.ca = (ctx.r[6].u32 > (!(-1 as u32)));
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 82A1973C: 7D4807B4  extsw r8, r10
	ctx.r[8].s64 = ctx.r[10].s32 as i64;
	// 82A19740: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	// 82A19744: F9010068  std r8, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 82A19748: C9A10068  lfd f13, 0x68(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A1974C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A19750: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A19754: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A19758: D149FFBC  stfs f10, -0x44(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-68 as u32), tmp.u32 ) };
	// 82A1975C: 3929FEF0  addi r9, r9, -0x110
	ctx.r[9].s64 = ctx.r[9].s64 + -272;
	// 82A19760: 4082FED0  bne 0x82a19630
	if !ctx.cr[0].eq {
	pc = 0x82A19630; continue 'dispatch;
	}
	pc = 0x82A19764; continue 'dispatch;
            }
            0x82A19764 => {
    //   block [0x82A19764..0x82A1977C)
	// 82A19764: 2F070001  cmpwi cr6, r7, 1
	ctx.cr[6].compare_i32(ctx.r[7].s32, 1, &mut ctx.xer);
	// 82A19768: 4198006C  blt cr6, 0x82a197d4
	if ctx.cr[6].lt {
	pc = 0x82A197D4; continue 'dispatch;
	}
	// 82A1976C: 1D670044  mulli r11, r7, 0x44
	ctx.r[11].s32 = ((ctx.r[7].s32 as i64 * 68 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A19770: 54EA1838  slwi r10, r7, 3
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A19774: 7D0BDA14  add r8, r11, r27
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82A19778: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	pc = 0x82A1977C; continue 'dispatch;
            }
            0x82A1977C => {
    //   block [0x82A1977C..0x82A197A4)
	// 82A1977C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19780: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A19784: 80EBFFF8  lwz r7, -8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A19788: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1978C: 80A70004  lwz r5, 4(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19790: 80860004  lwz r4, 4(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19794: 7D652050  subf r11, r5, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[5].s64;
	// 82A19798: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A1979C: 41990008  bgt cr6, 0x82a197a4
	if ctx.cr[6].gt {
	pc = 0x82A197A4; continue 'dispatch;
	}
	// 82A197A0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	pc = 0x82A197A4; continue 'dispatch;
            }
            0x82A197A4 => {
    //   block [0x82A197A4..0x82A197D4)
	// 82A197A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A197A8: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A197AC: 7D6707B4  extsw r7, r11
	ctx.r[7].s64 = ctx.r[11].s32 as i64;
	// 82A197B0: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 82A197B4: F8E10068  std r7, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[7].u64 ) };
	// 82A197B8: C9A10068  lfd f13, 0x68(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A197BC: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 82A197C0: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82A197C4: ED405824  fdivs f10, f0, f11
	ctx.f[10].f64 = ((ctx.f[0].f64 / ctx.f[11].f64) as f32) as f64;
	// 82A197C8: D1480000  stfs f10, 0(r8)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A197CC: 3908FFBC  addi r8, r8, -0x44
	ctx.r[8].s64 = ctx.r[8].s64 + -68;
	// 82A197D0: 4082FFAC  bne 0x82a1977c
	if !ctx.cr[0].eq {
	pc = 0x82A1977C; continue 'dispatch;
	}
	pc = 0x82A197D4; continue 'dispatch;
            }
            0x82A197D4 => {
    //   block [0x82A197D4..0x82A197E0)
	// 82A197D4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A197D8: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82A197DC: 4828FC78  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A197E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A197E0 size=80
    let mut pc: u32 = 0x82A197E0;
    'dispatch: loop {
        match pc {
            0x82A197E0 => {
    //   block [0x82A197E0..0x82A19818)
	// 82A197E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A197E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A197E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A197EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A197F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A197F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A197F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A197FC: 4881F1A5  bl 0x832389a0
	ctx.lr = 0x82A19800;
	sub_832389A0(ctx, base);
	// 82A19800: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A19804: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A19808: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1980C: 419A000C  beq cr6, 0x82a19818
	if ctx.cr[6].eq {
	pc = 0x82A19818; continue 'dispatch;
	}
	// 82A19810: 4B802529  bl 0x8221bd38
	ctx.lr = 0x82A19814;
	sub_8221BD38(ctx, base);
	// 82A19814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A19818; continue 'dispatch;
            }
            0x82A19818 => {
    //   block [0x82A19818..0x82A19830)
	// 82A19818: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1981C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A19820: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A19824: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A19828: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1982C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A19830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A19830 size=108
    let mut pc: u32 = 0x82A19830;
    'dispatch: loop {
        match pc {
            0x82A19830 => {
    //   block [0x82A19830..0x82A19868)
	// 82A19830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A19834: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A19838: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1983C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A19840: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A19844: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A19848: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1984C: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 82A19850: 394B2390  addi r10, r11, 0x2390
	ctx.r[10].s64 = ctx.r[11].s64 + 9104;
	// 82A19854: 915E0050  stw r10, 0x50(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A19858: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1985C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A19860: 419A0008  beq cr6, 0x82a19868
	if ctx.cr[6].eq {
	pc = 0x82A19868; continue 'dispatch;
	}
	// 82A19864: 4B8024D5  bl 0x8221bd38
	ctx.lr = 0x82A19868;
	sub_8221BD38(ctx, base);
	pc = 0x82A19868; continue 'dispatch;
            }
            0x82A19868 => {
    //   block [0x82A19868..0x82A1989C)
	// 82A19868: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82A1986C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A19870: 392A2B90  addi r9, r10, 0x2b90
	ctx.r[9].s64 = ctx.r[10].s64 + 11152;
	// 82A19874: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A19878: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A1987C: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A19880: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A19884: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A19888: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1988C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A19890: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A19894: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A19898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A198A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A198A0 size=80
    let mut pc: u32 = 0x82A198A0;
    'dispatch: loop {
        match pc {
            0x82A198A0 => {
    //   block [0x82A198A0..0x82A198D8)
	// 82A198A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A198A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A198A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A198AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A198B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A198B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A198B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A198BC: 4BFFFF75  bl 0x82a19830
	ctx.lr = 0x82A198C0;
	sub_82A19830(ctx, base);
	// 82A198C0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A198C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A198C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A198CC: 419A000C  beq cr6, 0x82a198d8
	if ctx.cr[6].eq {
	pc = 0x82A198D8; continue 'dispatch;
	}
	// 82A198D0: 4B802469  bl 0x8221bd38
	ctx.lr = 0x82A198D4;
	sub_8221BD38(ctx, base);
	// 82A198D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A198D8; continue 'dispatch;
            }
            0x82A198D8 => {
    //   block [0x82A198D8..0x82A198F0)
	// 82A198D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A198DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A198E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A198E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A198E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A198EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A198F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A198F0 size=140
    let mut pc: u32 = 0x82A198F0;
    'dispatch: loop {
        match pc {
            0x82A198F0 => {
    //   block [0x82A198F0..0x82A19900)
	// 82A198F0: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 82A198F4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A198F8: 419A0070  beq cr6, 0x82a19968
	if ctx.cr[6].eq {
	pc = 0x82A19968; continue 'dispatch;
	}
	// 82A198FC: 39640018  addi r11, r4, 0x18
	ctx.r[11].s64 = ctx.r[4].s64 + 24;
	pc = 0x82A19900; continue 'dispatch;
            }
            0x82A19900 => {
    //   block [0x82A19900..0x82A1995C)
	// 82A19900: 352BFFE8  addic. r9, r11, -0x18
	ctx.xer.ca = (ctx.r[11].u32 > (!(-24 as u32)));
	ctx.r[9].s64 = ctx.r[11].s64 + -24;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A19904: 41820058  beq 0x82a1995c
	if ctx.cr[0].eq {
	pc = 0x82A1995C; continue 'dispatch;
	}
	// 82A19908: 81260000  lwz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1990C: 390BFFE8  addi r8, r11, -0x18
	ctx.r[8].s64 = ctx.r[11].s64 + -24;
	// 82A19910: 912BFFE8  stw r9, -0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-24 as u32), ctx.r[9].u32 ) };
	// 82A19914: 80E60004  lwz r7, 4(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19918: 90EBFFEC  stw r7, -0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-20 as u32), ctx.r[7].u32 ) };
	// 82A1991C: 80660008  lwz r3, 8(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A19920: 906BFFF0  stw r3, -0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16 as u32), ctx.r[3].u32 ) };
	// 82A19924: 8126000C  lwz r9, 0xc(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A19928: 912BFFF4  stw r9, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[9].u32 ) };
	// 82A1992C: 81060010  lwz r8, 0x10(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A19930: 910BFFF8  stw r8, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[8].u32 ) };
	// 82A19934: 80E60014  lwz r7, 0x14(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A19938: 90EBFFFC  stw r7, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[7].u32 ) };
	// 82A1993C: 80660018  lwz r3, 0x18(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A19940: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82A19944: 8126001C  lwz r9, 0x1c(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A19948: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A1994C: C0060020  lfs f0, 0x20(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A19950: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82A19954: C1A60024  lfs f13, 0x24(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A19958: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x82A1995C; continue 'dispatch;
            }
            0x82A1995C => {
    //   block [0x82A1995C..0x82A19968)
	// 82A1995C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A19960: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 82A19964: 4082FF9C  bne 0x82a19900
	if !ctx.cr[0].eq {
	pc = 0x82A19900; continue 'dispatch;
	}
	pc = 0x82A19968; continue 'dispatch;
            }
            0x82A19968 => {
    //   block [0x82A19968..0x82A1997C)
	// 82A19968: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1996C: 7D655A14  add r11, r5, r11
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 82A19970: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A19974: 7C6B2214  add r3, r11, r4
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82A19978: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A19980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A19980 size=688
    let mut pc: u32 = 0x82A19980;
    'dispatch: loop {
        match pc {
            0x82A19980 => {
    //   block [0x82A19980..0x82A199F0)
	// 82A19980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A19984: 4828FA81  bl 0x82ca9404
	ctx.lr = 0x82A19988;
	sub_82CA93D0(ctx, base);
	// 82A19988: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1998C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A19990: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A19994: 81060004  lwz r8, 4(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19998: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82A1999C: 80E60008  lwz r7, 8(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A199A0: C0060020  lfs f0, 0x20(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A199A4: 80A6000C  lwz r5, 0xc(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A199A8: C1A60024  lfs f13, 0x24(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A199AC: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 82A199B0: 3B600028  li r27, 0x28
	ctx.r[27].s64 = 40;
	// 82A199B4: E8860010  ld r4, 0x10(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) };
	// 82A199B8: E8660018  ld r3, 0x18(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) };
	// 82A199BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A199C0: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A199C4: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82A199C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A199CC: 90E90008  stw r7, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82A199D0: 90A9000C  stw r5, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 82A199D4: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82A199D8: F8810060  std r4, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[4].u64 ) };
	// 82A199DC: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82A199E0: F8610068  std r3, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u64 ) };
	// 82A199E4: 409A000C  bne cr6, 0x82a199f0
	if !ctx.cr[6].eq {
	pc = 0x82A199F0; continue 'dispatch;
	}
	// 82A199E8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A199EC: 48000010  b 0x82a199fc
	pc = 0x82A199FC; continue 'dispatch;
            }
            0x82A199F0 => {
    //   block [0x82A199F0..0x82A199FC)
	// 82A199F0: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A199F4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A199F8: 7D29DBD6  divw r9, r9, r27
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x82A199FC; continue 'dispatch;
            }
            0x82A199FC => {
    //   block [0x82A199FC..0x82A19A28)
	// 82A199FC: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A19A00: 3D400666  lis r10, 0x666
	ctx.r[10].s64 = 107347968;
	// 82A19A04: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82A19A08: 614A6666  ori r10, r10, 0x6666
	ctx.r[10].u64 = ctx.r[10].u64 | 26214;
	// 82A19A0C: 7D68DBD6  divw r11, r8, r27
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	// 82A19A10: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A19A14: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 82A19A18: 40980010  bge cr6, 0x82a19a28
	if !ctx.cr[6].lt {
	pc = 0x82A19A28; continue 'dispatch;
	}
	// 82A19A1C: 4802DAAD  bl 0x82a474c8
	ctx.lr = 0x82A19A20;
	sub_82A474C8(ctx, base);
	// 82A19A20: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A19A24: 4828FA30  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A19A28 => {
    //   block [0x82A19A28..0x82A19A4C)
	// 82A19A28: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82A19A2C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A19A30: 409800CC  bge cr6, 0x82a19afc
	if !ctx.cr[6].lt {
	pc = 0x82A19AFC; continue 'dispatch;
	}
	// 82A19A34: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A19A38: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A19A3C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A19A40: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A19A44: 41980008  blt cr6, 0x82a19a4c
	if ctx.cr[6].lt {
	pc = 0x82A19A4C; continue 'dispatch;
	}
	// 82A19A48: 7FAB4A14  add r29, r11, r9
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A19A4C; continue 'dispatch;
            }
            0x82A19A4C => {
    //   block [0x82A19A4C..0x82A19A58)
	// 82A19A4C: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A19A50: 40980008  bge cr6, 0x82a19a58
	if !ctx.cr[6].lt {
	pc = 0x82A19A58; continue 'dispatch;
	}
	// 82A19A54: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	pc = 0x82A19A58; continue 'dispatch;
            }
            0x82A19A58 => {
    //   block [0x82A19A58..0x82A19AC8)
	// 82A19A58: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A19A5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A19A60: 4BA234D1  bl 0x8243cf30
	ctx.lr = 0x82A19A64;
	sub_8243CF30(ctx, base);
	// 82A19A64: 838100CC  lwz r28, 0xcc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A19A68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A19A6C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19A70: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A19A74: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A19A78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A19A7C: 480001B5  bl 0x82a19c30
	ctx.lr = 0x82A19A80;
	sub_82A19C30(ctx, base);
	// 82A19A80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A19A84: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A19A88: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A19A8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A19A90: 4BFFFE61  bl 0x82a198f0
	ctx.lr = 0x82A19A94;
	sub_82A198F0(ctx, base);
	// 82A19A94: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A19A98: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A19A9C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A19AA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A19AA4: 4800018D  bl 0x82a19c30
	ctx.lr = 0x82A19AA8;
	sub_82A19C30(ctx, base);
	// 82A19AA8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19AAC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A19AB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A19AB4: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A19AB8: 7D6ADBD6  divw r11, r10, r27
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 82A19ABC: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	// 82A19AC0: 419A0008  beq cr6, 0x82a19ac8
	if ctx.cr[6].eq {
	pc = 0x82A19AC8; continue 'dispatch;
	}
	// 82A19AC4: 4B802275  bl 0x8221bd38
	ctx.lr = 0x82A19AC8;
	sub_8221BD38(ctx, base);
	pc = 0x82A19AC8; continue 'dispatch;
            }
            0x82A19AC8 => {
    //   block [0x82A19AC8..0x82A19AFC)
	// 82A19AC8: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A19ACC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A19AD0: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A19AD4: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82A19AD8: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 82A19ADC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A19AE0: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A19AE4: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A19AE8: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A19AEC: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82A19AF0: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A19AF4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A19AF8: 4828F95C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A19AFC => {
    //   block [0x82A19AFC..0x82A19B58)
	// 82A19AFC: 83C100CC  lwz r30, 0xcc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A19B00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A19B04: 7D7E2850  subf r11, r30, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[30].s64;
	// 82A19B08: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 82A19B0C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82A19B10: 40980080  bge cr6, 0x82a19b90
	if !ctx.cr[6].lt {
	pc = 0x82A19B90; continue 'dispatch;
	}
	// 82A19B14: 38DE0028  addi r6, r30, 0x28
	ctx.r[6].s64 = ctx.r[30].s64 + 40;
	// 82A19B18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A19B1C: 48000115  bl 0x82a19c30
	ctx.lr = 0x82A19B20;
	sub_82A19C30(ctx, base);
	// 82A19B20: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A19B24: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A19B28: 7D7E2050  subf r11, r30, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 82A19B2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A19B30: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 82A19B34: 20AA0001  subfic r5, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[10].s64;
	// 82A19B38: 4BFFFDB9  bl 0x82a198f0
	ctx.lr = 0x82A19B3C;
	sub_82A198F0(ctx, base);
	// 82A19B3C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A19B40: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82A19B44: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 82A19B48: 38EBFFD8  addi r7, r11, -0x28
	ctx.r[7].s64 = ctx.r[11].s64 + -40;
	// 82A19B4C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A19B50: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A19B54: 419A00D4  beq cr6, 0x82a19c28
	if ctx.cr[6].eq {
	pc = 0x82A19C28; continue 'dispatch;
	}
	pc = 0x82A19B58; continue 'dispatch;
            }
            0x82A19B58 => {
    //   block [0x82A19B58..0x82A19B68)
	// 82A19B58: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A19B5C: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A19B60: 3900000A  li r8, 0xa
	ctx.r[8].s64 = 10;
	// 82A19B64: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A19B68; continue 'dispatch;
            }
            0x82A19B68 => {
    //   block [0x82A19B68..0x82A19B90)
	// 82A19B68: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A19B6C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A19B70: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A19B74: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A19B78: 4200FFF0  bdnz 0x82a19b68
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A19B68; continue 'dispatch;
	}
	// 82A19B7C: 39290028  addi r9, r9, 0x28
	ctx.r[9].s64 = ctx.r[9].s64 + 40;
	// 82A19B80: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A19B84: 409AFFD4  bne cr6, 0x82a19b58
	if !ctx.cr[6].eq {
	pc = 0x82A19B58; continue 'dispatch;
	}
	// 82A19B88: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A19B8C: 4828F8C8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A19B90 => {
    //   block [0x82A19B90..0x82A19BB4)
	// 82A19B90: 3BA5FFD8  addi r29, r5, -0x28
	ctx.r[29].s64 = ctx.r[5].s64 + -40;
	// 82A19B94: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82A19B98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A19B9C: 48000095  bl 0x82a19c30
	ctx.lr = 0x82A19BA0;
	sub_82A19C30(ctx, base);
	// 82A19BA0: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82A19BA4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82A19BA8: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A19BAC: 419A003C  beq cr6, 0x82a19be8
	if ctx.cr[6].eq {
	pc = 0x82A19BE8; continue 'dispatch;
	}
	// 82A19BB0: 390B0028  addi r8, r11, 0x28
	ctx.r[8].s64 = ctx.r[11].s64 + 40;
	pc = 0x82A19BB4; continue 'dispatch;
            }
            0x82A19BB4 => {
    //   block [0x82A19BB4..0x82A19BCC)
	// 82A19BB4: 396BFFD8  addi r11, r11, -0x28
	ctx.r[11].s64 = ctx.r[11].s64 + -40;
	// 82A19BB8: 3908FFD8  addi r8, r8, -0x28
	ctx.r[8].s64 = ctx.r[8].s64 + -40;
	// 82A19BBC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A19BC0: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82A19BC4: 38E0000A  li r7, 0xa
	ctx.r[7].s64 = 10;
	// 82A19BC8: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x82A19BCC; continue 'dispatch;
            }
            0x82A19BCC => {
    //   block [0x82A19BCC..0x82A19BE8)
	// 82A19BCC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A19BD0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A19BD4: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A19BD8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82A19BDC: 4200FFF0  bdnz 0x82a19bcc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A19BCC; continue 'dispatch;
	}
	// 82A19BE0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A19BE4: 409AFFD0  bne cr6, 0x82a19bb4
	if !ctx.cr[6].eq {
	pc = 0x82A19BB4; continue 'dispatch;
	}
	pc = 0x82A19BE8; continue 'dispatch;
            }
            0x82A19BE8 => {
    //   block [0x82A19BE8..0x82A19BF8)
	// 82A19BE8: 38FE0028  addi r7, r30, 0x28
	ctx.r[7].s64 = ctx.r[30].s64 + 40;
	// 82A19BEC: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82A19BF0: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A19BF4: 419A0034  beq cr6, 0x82a19c28
	if ctx.cr[6].eq {
	pc = 0x82A19C28; continue 'dispatch;
	}
	pc = 0x82A19BF8; continue 'dispatch;
            }
            0x82A19BF8 => {
    //   block [0x82A19BF8..0x82A19C08)
	// 82A19BF8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A19BFC: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A19C00: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 82A19C04: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A19C08; continue 'dispatch;
            }
            0x82A19C08 => {
    //   block [0x82A19C08..0x82A19C28)
	// 82A19C08: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A19C0C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A19C10: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A19C14: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A19C18: 4200FFF0  bdnz 0x82a19c08
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A19C08; continue 'dispatch;
	}
	// 82A19C1C: 39080028  addi r8, r8, 0x28
	ctx.r[8].s64 = ctx.r[8].s64 + 40;
	// 82A19C20: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A19C24: 409AFFD4  bne cr6, 0x82a19bf8
	if !ctx.cr[6].eq {
	pc = 0x82A19BF8; continue 'dispatch;
	}
	pc = 0x82A19C28; continue 'dispatch;
            }
            0x82A19C28 => {
    //   block [0x82A19C28..0x82A19C30)
	// 82A19C28: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A19C2C: 4828F828  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A19C30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A19C30 size=140
    let mut pc: u32 = 0x82A19C30;
    'dispatch: loop {
        match pc {
            0x82A19C30 => {
    //   block [0x82A19C30..0x82A19C44)
	// 82A19C30: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82A19C34: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A19C38: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82A19C3C: 39640018  addi r11, r4, 0x18
	ctx.r[11].s64 = ctx.r[4].s64 + 24;
	// 82A19C40: 7D441850  subf r10, r4, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	pc = 0x82A19C44; continue 'dispatch;
            }
            0x82A19C44 => {
    //   block [0x82A19C44..0x82A19CA4)
	// 82A19C44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A19C48: 419A005C  beq cr6, 0x82a19ca4
	if ctx.cr[6].eq {
	pc = 0x82A19CA4; continue 'dispatch;
	}
	// 82A19C4C: 812BFFE8  lwz r9, -0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) } as u64;
	// 82A19C50: 38EBFFE8  addi r7, r11, -0x18
	ctx.r[7].s64 = ctx.r[11].s64 + -24;
	// 82A19C54: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A19C58: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A19C5C: 80CBFFEC  lwz r6, -0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82A19C60: 90C30004  stw r6, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A19C64: 808BFFF0  lwz r4, -0x10(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82A19C68: 90830008  stw r4, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82A19C6C: 812BFFF4  lwz r9, -0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82A19C70: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82A19C74: 80EBFFF8  lwz r7, -8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A19C78: 90E30010  stw r7, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 82A19C7C: 80CBFFFC  lwz r6, -4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82A19C80: 90C30014  stw r6, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 82A19C84: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A19C88: 7C8A592E  stwx r4, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[4].u32) };
	// 82A19C8C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19C90: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A19C94: C00B0008  lfs f0, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A19C98: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82A19C9C: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A19CA0: D1A30024  stfs f13, 0x24(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	pc = 0x82A19CA4; continue 'dispatch;
            }
            0x82A19CA4 => {
    //   block [0x82A19CA4..0x82A19CBC)
	// 82A19CA4: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 82A19CA8: 38630028  addi r3, r3, 0x28
	ctx.r[3].s64 = ctx.r[3].s64 + 40;
	// 82A19CAC: 392BFFE8  addi r9, r11, -0x18
	ctx.r[9].s64 = ctx.r[11].s64 + -24;
	// 82A19CB0: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A19CB4: 409AFF90  bne cr6, 0x82a19c44
	if !ctx.cr[6].eq {
	pc = 0x82A19C44; continue 'dispatch;
	}
	// 82A19CB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A19CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A19CC0 size=108
    let mut pc: u32 = 0x82A19CC0;
    'dispatch: loop {
        match pc {
            0x82A19CC0 => {
    //   block [0x82A19CC0..0x82A19CD0)
	// 82A19CC0: 7CAA2B78  mr r10, r5
	ctx.r[10].u64 = ctx.r[5].u64;
	// 82A19CC4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A19CC8: 419A0058  beq cr6, 0x82a19d20
	if ctx.cr[6].eq {
	pc = 0x82A19D20; continue 'dispatch;
	}
	// 82A19CCC: 39640014  addi r11, r4, 0x14
	ctx.r[11].s64 = ctx.r[4].s64 + 20;
	pc = 0x82A19CD0; continue 'dispatch;
            }
            0x82A19CD0 => {
    //   block [0x82A19CD0..0x82A19D14)
	// 82A19CD0: 352BFFEC  addic. r9, r11, -0x14
	ctx.xer.ca = (ctx.r[11].u32 > (!(-20 as u32)));
	ctx.r[9].s64 = ctx.r[11].s64 + -20;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A19CD4: 41820040  beq 0x82a19d14
	if ctx.cr[0].eq {
	pc = 0x82A19D14; continue 'dispatch;
	}
	// 82A19CD8: 81260000  lwz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A19CDC: 390BFFEC  addi r8, r11, -0x14
	ctx.r[8].s64 = ctx.r[11].s64 + -20;
	// 82A19CE0: 912BFFEC  stw r9, -0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-20 as u32), ctx.r[9].u32 ) };
	// 82A19CE4: 80E60004  lwz r7, 4(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19CE8: 90EBFFF0  stw r7, -0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16 as u32), ctx.r[7].u32 ) };
	// 82A19CEC: 80660008  lwz r3, 8(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A19CF0: 906BFFF4  stw r3, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[3].u32 ) };
	// 82A19CF4: 8126000C  lwz r9, 0xc(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A19CF8: 912BFFF8  stw r9, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[9].u32 ) };
	// 82A19CFC: C0060010  lfs f0, 0x10(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A19D00: D00BFFFC  stfs f0, -4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82A19D04: C1A60014  lfs f13, 0x14(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A19D08: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A19D0C: C1860018  lfs f12, 0x18(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A19D10: D18B0004  stfs f12, 4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x82A19D14; continue 'dispatch;
            }
            0x82A19D14 => {
    //   block [0x82A19D14..0x82A19D20)
	// 82A19D14: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A19D18: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 82A19D1C: 4082FFB4  bne 0x82a19cd0
	if !ctx.cr[0].eq {
	pc = 0x82A19CD0; continue 'dispatch;
	}
	pc = 0x82A19D20; continue 'dispatch;
            }
            0x82A19D20 => {
    //   block [0x82A19D20..0x82A19D2C)
	// 82A19D20: 1D65001C  mulli r11, r5, 0x1c
	ctx.r[11].s32 = ((ctx.r[5].s32 as i64 * 28 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A19D24: 7C6B2214  add r3, r11, r4
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82A19D28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A19D30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A19D30 size=80
    let mut pc: u32 = 0x82A19D30;
    'dispatch: loop {
        match pc {
            0x82A19D30 => {
    //   block [0x82A19D30..0x82A19D68)
	// 82A19D30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A19D34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A19D38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A19D3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A19D40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A19D44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A19D48: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A19D4C: 48000035  bl 0x82a19d80
	ctx.lr = 0x82A19D50;
	sub_82A19D80(ctx, base);
	// 82A19D50: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A19D54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A19D58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A19D5C: 419A000C  beq cr6, 0x82a19d68
	if ctx.cr[6].eq {
	pc = 0x82A19D68; continue 'dispatch;
	}
	// 82A19D60: 4B801FD9  bl 0x8221bd38
	ctx.lr = 0x82A19D64;
	sub_8221BD38(ctx, base);
	// 82A19D64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A19D68; continue 'dispatch;
            }
            0x82A19D68 => {
    //   block [0x82A19D68..0x82A19D80)
	// 82A19D68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A19D6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A19D70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A19D74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A19D78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A19D7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A19D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A19D80 size=108
    let mut pc: u32 = 0x82A19D80;
    'dispatch: loop {
        match pc {
            0x82A19D80 => {
    //   block [0x82A19D80..0x82A19DB8)
	// 82A19D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A19D84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A19D88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A19D8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A19D90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A19D94: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A19D98: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A19D9C: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 82A19DA0: 394B2390  addi r10, r11, 0x2390
	ctx.r[10].s64 = ctx.r[11].s64 + 9104;
	// 82A19DA4: 915E002C  stw r10, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82A19DA8: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A19DAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A19DB0: 419A0008  beq cr6, 0x82a19db8
	if ctx.cr[6].eq {
	pc = 0x82A19DB8; continue 'dispatch;
	}
	// 82A19DB4: 4B801F85  bl 0x8221bd38
	ctx.lr = 0x82A19DB8;
	sub_8221BD38(ctx, base);
	pc = 0x82A19DB8; continue 'dispatch;
            }
            0x82A19DB8 => {
    //   block [0x82A19DB8..0x82A19DEC)
	// 82A19DB8: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82A19DBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A19DC0: 392A2B90  addi r9, r10, 0x2b90
	ctx.r[9].s64 = ctx.r[10].s64 + 11152;
	// 82A19DC4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A19DC8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A19DCC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A19DD0: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A19DD4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A19DD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A19DDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A19DE0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A19DE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A19DE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A19DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A19DF0 size=664
    let mut pc: u32 = 0x82A19DF0;
    'dispatch: loop {
        match pc {
            0x82A19DF0 => {
    //   block [0x82A19DF0..0x82A19E58)
	// 82A19DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A19DF4: 4828F611  bl 0x82ca9404
	ctx.lr = 0x82A19DF8;
	sub_82CA93D0(ctx, base);
	// 82A19DF8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A19DFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A19E00: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A19E04: 81060004  lwz r8, 4(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19E08: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82A19E0C: 80E60008  lwz r7, 8(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A19E10: C0060010  lfs f0, 0x10(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A19E14: 80A6000C  lwz r5, 0xc(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A19E18: C1A60014  lfs f13, 0x14(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A19E1C: C1860018  lfs f12, 0x18(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A19E20: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 82A19E24: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19E28: 3B60001C  li r27, 0x1c
	ctx.r[27].s64 = 28;
	// 82A19E2C: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A19E30: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82A19E34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A19E38: 90E90008  stw r7, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82A19E3C: 90A9000C  stw r5, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 82A19E40: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A19E44: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A19E48: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82A19E4C: 409A000C  bne cr6, 0x82a19e58
	if !ctx.cr[6].eq {
	pc = 0x82A19E58; continue 'dispatch;
	}
	// 82A19E50: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A19E54: 48000010  b 0x82a19e64
	pc = 0x82A19E64; continue 'dispatch;
            }
            0x82A19E58 => {
    //   block [0x82A19E58..0x82A19E64)
	// 82A19E58: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A19E5C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A19E60: 7D29DBD6  divw r9, r9, r27
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x82A19E64; continue 'dispatch;
            }
            0x82A19E64 => {
    //   block [0x82A19E64..0x82A19E90)
	// 82A19E64: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A19E68: 3D400924  lis r10, 0x924
	ctx.r[10].s64 = 153354240;
	// 82A19E6C: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82A19E70: 614A9249  ori r10, r10, 0x9249
	ctx.r[10].u64 = ctx.r[10].u64 | 37449;
	// 82A19E74: 7D68DBD6  divw r11, r8, r27
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	// 82A19E78: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A19E7C: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 82A19E80: 40980010  bge cr6, 0x82a19e90
	if !ctx.cr[6].lt {
	pc = 0x82A19E90; continue 'dispatch;
	}
	// 82A19E84: 4802D645  bl 0x82a474c8
	ctx.lr = 0x82A19E88;
	sub_82A474C8(ctx, base);
	// 82A19E88: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A19E8C: 4828F5C8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A19E90 => {
    //   block [0x82A19E90..0x82A19EB4)
	// 82A19E90: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82A19E94: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A19E98: 409800BC  bge cr6, 0x82a19f54
	if !ctx.cr[6].lt {
	pc = 0x82A19F54; continue 'dispatch;
	}
	// 82A19E9C: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A19EA0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A19EA4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A19EA8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A19EAC: 41980008  blt cr6, 0x82a19eb4
	if ctx.cr[6].lt {
	pc = 0x82A19EB4; continue 'dispatch;
	}
	// 82A19EB0: 7FAB4A14  add r29, r11, r9
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A19EB4; continue 'dispatch;
            }
            0x82A19EB4 => {
    //   block [0x82A19EB4..0x82A19EC0)
	// 82A19EB4: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A19EB8: 40980008  bge cr6, 0x82a19ec0
	if !ctx.cr[6].lt {
	pc = 0x82A19EC0; continue 'dispatch;
	}
	// 82A19EBC: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	pc = 0x82A19EC0; continue 'dispatch;
            }
            0x82A19EC0 => {
    //   block [0x82A19EC0..0x82A19F30)
	// 82A19EC0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A19EC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A19EC8: 482286C9  bl 0x82c42590
	ctx.lr = 0x82A19ECC;
	sub_82C42590(ctx, base);
	// 82A19ECC: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A19ED0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A19ED4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19ED8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A19EDC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A19EE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A19EE4: 480001A5  bl 0x82a1a088
	ctx.lr = 0x82A19EE8;
	sub_82A1A088(ctx, base);
	// 82A19EE8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A19EEC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A19EF0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A19EF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A19EF8: 4BFFFDC9  bl 0x82a19cc0
	ctx.lr = 0x82A19EFC;
	sub_82A19CC0(ctx, base);
	// 82A19EFC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A19F00: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A19F04: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A19F08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A19F0C: 4800017D  bl 0x82a1a088
	ctx.lr = 0x82A19F10;
	sub_82A1A088(ctx, base);
	// 82A19F10: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A19F14: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A19F18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A19F1C: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A19F20: 7D6ADBD6  divw r11, r10, r27
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 82A19F24: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	// 82A19F28: 419A0008  beq cr6, 0x82a19f30
	if ctx.cr[6].eq {
	pc = 0x82A19F30; continue 'dispatch;
	}
	// 82A19F2C: 4B801E0D  bl 0x8221bd38
	ctx.lr = 0x82A19F30;
	sub_8221BD38(ctx, base);
	pc = 0x82A19F30; continue 'dispatch;
            }
            0x82A19F30 => {
    //   block [0x82A19F30..0x82A19F54)
	// 82A19F30: 1D7D001C  mulli r11, r29, 0x1c
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * 28 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A19F34: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A19F38: 1D5C001C  mulli r10, r28, 0x1c
	ctx.r[10].s32 = ((ctx.r[28].s32 as i64 * 28 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82A19F3C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A19F40: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A19F44: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A19F48: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A19F4C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A19F50: 4828F504  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A19F54 => {
    //   block [0x82A19F54..0x82A19FB0)
	// 82A19F54: 83C100BC  lwz r30, 0xbc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A19F58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A19F5C: 7D7E2850  subf r11, r30, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[30].s64;
	// 82A19F60: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 82A19F64: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82A19F68: 40980080  bge cr6, 0x82a19fe8
	if !ctx.cr[6].lt {
	pc = 0x82A19FE8; continue 'dispatch;
	}
	// 82A19F6C: 38DE001C  addi r6, r30, 0x1c
	ctx.r[6].s64 = ctx.r[30].s64 + 28;
	// 82A19F70: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A19F74: 48000115  bl 0x82a1a088
	ctx.lr = 0x82A19F78;
	sub_82A1A088(ctx, base);
	// 82A19F78: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A19F7C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82A19F80: 7D7E2050  subf r11, r30, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 82A19F84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A19F88: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 82A19F8C: 20AA0001  subfic r5, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[10].s64;
	// 82A19F90: 4BFFFD31  bl 0x82a19cc0
	ctx.lr = 0x82A19F94;
	sub_82A19CC0(ctx, base);
	// 82A19F94: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A19F98: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82A19F9C: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 82A19FA0: 38EBFFE4  addi r7, r11, -0x1c
	ctx.r[7].s64 = ctx.r[11].s64 + -28;
	// 82A19FA4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A19FA8: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A19FAC: 419A00D4  beq cr6, 0x82a1a080
	if ctx.cr[6].eq {
	pc = 0x82A1A080; continue 'dispatch;
	}
	pc = 0x82A19FB0; continue 'dispatch;
            }
            0x82A19FB0 => {
    //   block [0x82A19FB0..0x82A19FC0)
	// 82A19FB0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A19FB4: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 82A19FB8: 39000007  li r8, 7
	ctx.r[8].s64 = 7;
	// 82A19FBC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x82A19FC0; continue 'dispatch;
            }
            0x82A19FC0 => {
    //   block [0x82A19FC0..0x82A19FE8)
	// 82A19FC0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A19FC4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A19FC8: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A19FCC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A19FD0: 4200FFF0  bdnz 0x82a19fc0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A19FC0; continue 'dispatch;
	}
	// 82A19FD4: 3929001C  addi r9, r9, 0x1c
	ctx.r[9].s64 = ctx.r[9].s64 + 28;
	// 82A19FD8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A19FDC: 409AFFD4  bne cr6, 0x82a19fb0
	if !ctx.cr[6].eq {
	pc = 0x82A19FB0; continue 'dispatch;
	}
	// 82A19FE0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A19FE4: 4828F470  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A19FE8 => {
    //   block [0x82A19FE8..0x82A1A00C)
	// 82A19FE8: 3BA5FFE4  addi r29, r5, -0x1c
	ctx.r[29].s64 = ctx.r[5].s64 + -28;
	// 82A19FEC: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 82A19FF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A19FF4: 48000095  bl 0x82a1a088
	ctx.lr = 0x82A19FF8;
	sub_82A1A088(ctx, base);
	// 82A19FF8: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82A19FFC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82A1A000: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A1A004: 419A003C  beq cr6, 0x82a1a040
	if ctx.cr[6].eq {
	pc = 0x82A1A040; continue 'dispatch;
	}
	// 82A1A008: 390B001C  addi r8, r11, 0x1c
	ctx.r[8].s64 = ctx.r[11].s64 + 28;
	pc = 0x82A1A00C; continue 'dispatch;
            }
            0x82A1A00C => {
    //   block [0x82A1A00C..0x82A1A024)
	// 82A1A00C: 396BFFE4  addi r11, r11, -0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + -28;
	// 82A1A010: 3908FFE4  addi r8, r8, -0x1c
	ctx.r[8].s64 = ctx.r[8].s64 + -28;
	// 82A1A014: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A1A018: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 82A1A01C: 38E00007  li r7, 7
	ctx.r[7].s64 = 7;
	// 82A1A020: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	pc = 0x82A1A024; continue 'dispatch;
            }
            0x82A1A024 => {
    //   block [0x82A1A024..0x82A1A040)
	// 82A1A024: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1A028: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A1A02C: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A1A030: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82A1A034: 4200FFF0  bdnz 0x82a1a024
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A1A024; continue 'dispatch;
	}
	// 82A1A038: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A1A03C: 409AFFD0  bne cr6, 0x82a1a00c
	if !ctx.cr[6].eq {
	pc = 0x82A1A00C; continue 'dispatch;
	}
	pc = 0x82A1A040; continue 'dispatch;
            }
            0x82A1A040 => {
    //   block [0x82A1A040..0x82A1A050)
	// 82A1A040: 38FE001C  addi r7, r30, 0x1c
	ctx.r[7].s64 = ctx.r[30].s64 + 28;
	// 82A1A044: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 82A1A048: 7F1E3840  cmplw cr6, r30, r7
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A1A04C: 419A0034  beq cr6, 0x82a1a080
	if ctx.cr[6].eq {
	pc = 0x82A1A080; continue 'dispatch;
	}
	pc = 0x82A1A050; continue 'dispatch;
            }
            0x82A1A050 => {
    //   block [0x82A1A050..0x82A1A060)
	// 82A1A050: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82A1A054: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A1A058: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 82A1A05C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A1A060; continue 'dispatch;
            }
            0x82A1A060 => {
    //   block [0x82A1A060..0x82A1A080)
	// 82A1A060: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1A064: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A1A068: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A1A06C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82A1A070: 4200FFF0  bdnz 0x82a1a060
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A1A060; continue 'dispatch;
	}
	// 82A1A074: 3908001C  addi r8, r8, 0x1c
	ctx.r[8].s64 = ctx.r[8].s64 + 28;
	// 82A1A078: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A1A07C: 409AFFD4  bne cr6, 0x82a1a050
	if !ctx.cr[6].eq {
	pc = 0x82A1A050; continue 'dispatch;
	}
	pc = 0x82A1A080; continue 'dispatch;
            }
            0x82A1A080 => {
    //   block [0x82A1A080..0x82A1A088)
	// 82A1A080: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1A084: 4828F3D0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A1A088 size=112
    let mut pc: u32 = 0x82A1A088;
    'dispatch: loop {
        match pc {
            0x82A1A088 => {
    //   block [0x82A1A088..0x82A1A09C)
	// 82A1A088: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82A1A08C: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A1A090: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82A1A094: 39640014  addi r11, r4, 0x14
	ctx.r[11].s64 = ctx.r[4].s64 + 20;
	// 82A1A098: 7D441850  subf r10, r4, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	pc = 0x82A1A09C; continue 'dispatch;
            }
            0x82A1A09C => {
    //   block [0x82A1A09C..0x82A1A0E0)
	// 82A1A09C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1A0A0: 419A0040  beq cr6, 0x82a1a0e0
	if ctx.cr[6].eq {
	pc = 0x82A1A0E0; continue 'dispatch;
	}
	// 82A1A0A4: 812BFFEC  lwz r9, -0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82A1A0A8: 390BFFEC  addi r8, r11, -0x14
	ctx.r[8].s64 = ctx.r[11].s64 + -20;
	// 82A1A0AC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A1A0B0: 80EBFFF0  lwz r7, -0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82A1A0B4: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A1A0B8: 80CBFFF4  lwz r6, -0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82A1A0BC: 90C30008  stw r6, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82A1A0C0: 808BFFF8  lwz r4, -8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1A0C4: 9083000C  stw r4, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82A1A0C8: C00BFFFC  lfs f0, -4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1A0CC: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82A1A0D0: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A1A0D4: 7DAA5D2E  stfsx f13, r10, r11
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82A1A0D8: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82A1A0DC: D1830018  stfs f12, 0x18(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	pc = 0x82A1A0E0; continue 'dispatch;
            }
            0x82A1A0E0 => {
    //   block [0x82A1A0E0..0x82A1A0F8)
	// 82A1A0E0: 396B001C  addi r11, r11, 0x1c
	ctx.r[11].s64 = ctx.r[11].s64 + 28;
	// 82A1A0E4: 3863001C  addi r3, r3, 0x1c
	ctx.r[3].s64 = ctx.r[3].s64 + 28;
	// 82A1A0E8: 392BFFEC  addi r9, r11, -0x14
	ctx.r[9].s64 = ctx.r[11].s64 + -20;
	// 82A1A0EC: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A1A0F0: 409AFFAC  bne cr6, 0x82a1a09c
	if !ctx.cr[6].eq {
	pc = 0x82A1A09C; continue 'dispatch;
	}
	// 82A1A0F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1A0F8 size=936
    let mut pc: u32 = 0x82A1A0F8;
    'dispatch: loop {
        match pc {
            0x82A1A0F8 => {
    //   block [0x82A1A0F8..0x82A1A144)
	// 82A1A0F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1A0FC: 4828F30D  bl 0x82ca9408
	ctx.lr = 0x82A1A100;
	sub_82CA93D0(ctx, base);
	// 82A1A100: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1A104: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1A108: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82A1A10C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A1A110: 81060004  lwz r8, 4(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1A114: 80E60008  lwz r7, 8(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1A118: 80C6000C  lwz r6, 0xc(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1A11C: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 82A1A120: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1A124: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1A128: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82A1A12C: 90E90008  stw r7, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82A1A130: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1A134: 90C9000C  stw r6, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 82A1A138: 409A000C  bne cr6, 0x82a1a144
	if !ctx.cr[6].eq {
	pc = 0x82A1A144; continue 'dispatch;
	}
	// 82A1A13C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A1A140: 48000010  b 0x82a1a150
	pc = 0x82A1A150; continue 'dispatch;
            }
            0x82A1A144 => {
    //   block [0x82A1A144..0x82A1A150)
	// 82A1A144: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1A148: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A1A14C: 7D292670  srawi r9, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 4) as i64;
	pc = 0x82A1A150; continue 'dispatch;
            }
            0x82A1A150 => {
    //   block [0x82A1A150..0x82A1A17C)
	// 82A1A150: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1A154: 3D400FFF  lis r10, 0xfff
	ctx.r[10].s64 = 268369920;
	// 82A1A158: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 82A1A15C: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82A1A160: 7CEB2670  srawi r11, r7, 4
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 4) as i64;
	// 82A1A164: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A1A168: 2B060001  cmplwi cr6, r6, 1
	ctx.cr[6].compare_u32(ctx.r[6].u32, 1 as u32, &mut ctx.xer);
	// 82A1A16C: 40980010  bge cr6, 0x82a1a17c
	if !ctx.cr[6].lt {
	pc = 0x82A1A17C; continue 'dispatch;
	}
	// 82A1A170: 4802D359  bl 0x82a474c8
	ctx.lr = 0x82A1A174;
	sub_82A474C8(ctx, base);
	// 82A1A174: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A1A178: 4828F2E0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A1A17C => {
    //   block [0x82A1A17C..0x82A1A1A0)
	// 82A1A17C: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 82A1A180: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A1A184: 40980148  bge cr6, 0x82a1a2cc
	if !ctx.cr[6].lt {
	pc = 0x82A1A2CC; continue 'dispatch;
	}
	// 82A1A188: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1A18C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A1A190: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A1A194: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1A198: 41980008  blt cr6, 0x82a1a1a0
	if ctx.cr[6].lt {
	pc = 0x82A1A1A0; continue 'dispatch;
	}
	// 82A1A19C: 7F8B4A14  add r28, r11, r9
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82A1A1A0; continue 'dispatch;
            }
            0x82A1A1A0 => {
    //   block [0x82A1A1A0..0x82A1A1AC)
	// 82A1A1A0: 7F1C3840  cmplw cr6, r28, r7
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A1A1A4: 40980008  bge cr6, 0x82a1a1ac
	if !ctx.cr[6].lt {
	pc = 0x82A1A1AC; continue 'dispatch;
	}
	// 82A1A1A8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	pc = 0x82A1A1AC; continue 'dispatch;
            }
            0x82A1A1AC => {
    //   block [0x82A1A1AC..0x82A1A1D0)
	// 82A1A1AC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A1A1B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1A1B4: 4BA09085  bl 0x82423238
	ctx.lr = 0x82A1A1B8;
	sub_82423238(ctx, base);
	// 82A1A1B8: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1A1BC: 812100AC  lwz r9, 0xac(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A1A1C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1A1C4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1A1C8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82A1A1CC: 419A003C  beq cr6, 0x82a1a208
	if ctx.cr[6].eq {
	pc = 0x82A1A208; continue 'dispatch;
	}
	pc = 0x82A1A1D0; continue 'dispatch;
            }
            0x82A1A1D0 => {
    //   block [0x82A1A1D0..0x82A1A1F8)
	// 82A1A1D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1A1D4: 419A0024  beq cr6, 0x82a1a1f8
	if ctx.cr[6].eq {
	pc = 0x82A1A1F8; continue 'dispatch;
	}
	// 82A1A1D8: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1A1DC: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A1A1E0: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1A1E4: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A1A1E8: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1A1EC: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82A1A1F0: 80AA000C  lwz r5, 0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1A1F4: 90AB000C  stw r5, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	pc = 0x82A1A1F8; continue 'dispatch;
            }
            0x82A1A1F8 => {
    //   block [0x82A1A1F8..0x82A1A208)
	// 82A1A1F8: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82A1A1FC: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82A1A200: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1A204: 409AFFCC  bne cr6, 0x82a1a1d0
	if !ctx.cr[6].eq {
	pc = 0x82A1A1D0; continue 'dispatch;
	}
	pc = 0x82A1A208; continue 'dispatch;
            }
            0x82A1A208 => {
    //   block [0x82A1A208..0x82A1A234)
	// 82A1A208: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1A20C: 419A0028  beq cr6, 0x82a1a234
	if ctx.cr[6].eq {
	pc = 0x82A1A234; continue 'dispatch;
	}
	// 82A1A210: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A1A214: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1A218: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1A21C: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1A220: 80AA000C  lwz r5, 0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1A224: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A1A228: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A1A22C: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82A1A230: 90AB000C  stw r5, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	pc = 0x82A1A234; continue 'dispatch;
            }
            0x82A1A234 => {
    //   block [0x82A1A234..0x82A1A250)
	// 82A1A234: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1A238: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
	// 82A1A23C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A1A240: 419A0048  beq cr6, 0x82a1a288
	if ctx.cr[6].eq {
	pc = 0x82A1A288; continue 'dispatch;
	}
	// 82A1A244: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82A1A248: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A1A24C: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	pc = 0x82A1A250; continue 'dispatch;
            }
            0x82A1A250 => {
    //   block [0x82A1A250..0x82A1A278)
	// 82A1A250: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1A254: 419A0024  beq cr6, 0x82a1a278
	if ctx.cr[6].eq {
	pc = 0x82A1A278; continue 'dispatch;
	}
	// 82A1A258: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1A25C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A1A260: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1A264: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A1A268: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1A26C: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82A1A270: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1A274: 90AA000C  stw r5, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	pc = 0x82A1A278; continue 'dispatch;
            }
            0x82A1A278 => {
    //   block [0x82A1A278..0x82A1A288)
	// 82A1A278: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82A1A27C: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82A1A280: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A1A284: 409AFFCC  bne cr6, 0x82a1a250
	if !ctx.cr[6].eq {
	pc = 0x82A1A250; continue 'dispatch;
	}
	pc = 0x82A1A288; continue 'dispatch;
            }
            0x82A1A288 => {
    //   block [0x82A1A288..0x82A1A2A8)
	// 82A1A288: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1A28C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1A290: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1A294: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82A1A298: 7D4B2670  srawi r11, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 82A1A29C: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 82A1A2A0: 419A0008  beq cr6, 0x82a1a2a8
	if ctx.cr[6].eq {
	pc = 0x82A1A2A8; continue 'dispatch;
	}
	// 82A1A2A4: 4B801A95  bl 0x8221bd38
	ctx.lr = 0x82A1A2A8;
	sub_8221BD38(ctx, base);
	pc = 0x82A1A2A8; continue 'dispatch;
            }
            0x82A1A2A8 => {
    //   block [0x82A1A2A8..0x82A1A2CC)
	// 82A1A2A8: 578B2036  slwi r11, r28, 4
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1A2AC: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82A1A2B0: 57EA2036  slwi r10, r31, 4
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1A2B4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A1A2B8: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A1A2BC: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A1A2C0: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A1A2C4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A1A2C8: 4828F190  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A1A2CC => {
    //   block [0x82A1A2CC..0x82A1A2F0)
	// 82A1A2CC: 80E100AC  lwz r7, 0xac(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82A1A2D0: 7D674050  subf r11, r7, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82A1A2D4: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 82A1A2D8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82A1A2DC: 409800F0  bge cr6, 0x82a1a3cc
	if !ctx.cr[6].lt {
	pc = 0x82A1A3CC; continue 'dispatch;
	}
	// 82A1A2E0: 39670010  addi r11, r7, 0x10
	ctx.r[11].s64 = ctx.r[7].s64 + 16;
	// 82A1A2E4: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A1A2E8: 419A0040  beq cr6, 0x82a1a328
	if ctx.cr[6].eq {
	pc = 0x82A1A328; continue 'dispatch;
	}
	// 82A1A2EC: 394BFFF0  addi r10, r11, -0x10
	ctx.r[10].s64 = ctx.r[11].s64 + -16;
	pc = 0x82A1A2F0; continue 'dispatch;
            }
            0x82A1A2F0 => {
    //   block [0x82A1A2F0..0x82A1A318)
	// 82A1A2F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1A2F4: 419A0024  beq cr6, 0x82a1a318
	if ctx.cr[6].eq {
	pc = 0x82A1A318; continue 'dispatch;
	}
	// 82A1A2F8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1A2FC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A1A300: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1A304: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A1A308: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1A30C: 90AB0008  stw r5, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82A1A310: 808A000C  lwz r4, 0xc(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1A314: 908B000C  stw r4, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	pc = 0x82A1A318; continue 'dispatch;
            }
            0x82A1A318 => {
    //   block [0x82A1A318..0x82A1A328)
	// 82A1A318: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82A1A31C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82A1A320: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A1A324: 409AFFCC  bne cr6, 0x82a1a2f0
	if !ctx.cr[6].eq {
	pc = 0x82A1A2F0; continue 'dispatch;
	}
	pc = 0x82A1A328; continue 'dispatch;
            }
            0x82A1A328 => {
    //   block [0x82A1A328..0x82A1A340)
	// 82A1A328: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1A32C: 7D475850  subf r10, r7, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 82A1A330: 7D492670  srawi r9, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 82A1A334: 21490001  subfic r10, r9, 1
	ctx.xer.ca = ctx.r[9].u32 <= 1 as u32;
	ctx.r[10].s64 = (1 as i64) - ctx.r[9].s64;
	// 82A1A338: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1A33C: 419A003C  beq cr6, 0x82a1a378
	if ctx.cr[6].eq {
	pc = 0x82A1A378; continue 'dispatch;
	}
	pc = 0x82A1A340; continue 'dispatch;
            }
            0x82A1A340 => {
    //   block [0x82A1A340..0x82A1A36C)
	// 82A1A340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1A344: 419A0028  beq cr6, 0x82a1a36c
	if ctx.cr[6].eq {
	pc = 0x82A1A36C; continue 'dispatch;
	}
	// 82A1A348: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82A1A34C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1A350: 80C90004  lwz r6, 4(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1A354: 80A90008  lwz r5, 8(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1A358: 8089000C  lwz r4, 0xc(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1A35C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A1A360: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82A1A364: 90AB0008  stw r5, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82A1A368: 908B000C  stw r4, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	pc = 0x82A1A36C; continue 'dispatch;
            }
            0x82A1A36C => {
    //   block [0x82A1A36C..0x82A1A378)
	// 82A1A36C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A1A370: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82A1A374: 4082FFCC  bne 0x82a1a340
	if !ctx.cr[0].eq {
	pc = 0x82A1A340; continue 'dispatch;
	}
	pc = 0x82A1A378; continue 'dispatch;
            }
            0x82A1A378 => {
    //   block [0x82A1A378..0x82A1A394)
	// 82A1A378: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1A37C: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82A1A380: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82A1A384: 392AFFF0  addi r9, r10, -0x10
	ctx.r[9].s64 = ctx.r[10].s64 + -16;
	// 82A1A388: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A1A38C: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1A390: 419A0108  beq cr6, 0x82a1a498
	if ctx.cr[6].eq {
	pc = 0x82A1A498; continue 'dispatch;
	}
	pc = 0x82A1A394; continue 'dispatch;
            }
            0x82A1A394 => {
    //   block [0x82A1A394..0x82A1A3CC)
	// 82A1A394: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82A1A398: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1A39C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1A3A0: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1A3A4: 80AA000C  lwz r5, 0xc(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1A3A8: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A1A3AC: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A1A3B0: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82A1A3B4: 90AB000C  stw r5, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 82A1A3B8: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82A1A3BC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1A3C0: 409AFFD4  bne cr6, 0x82a1a394
	if !ctx.cr[6].eq {
	pc = 0x82A1A394; continue 'dispatch;
	}
	// 82A1A3C4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A1A3C8: 4828F090  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A1A3CC => {
    //   block [0x82A1A3CC..0x82A1A3E0)
	// 82A1A3CC: 3968FFF0  addi r11, r8, -0x10
	ctx.r[11].s64 = ctx.r[8].s64 + -16;
	// 82A1A3D0: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82A1A3D4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82A1A3D8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A1A3DC: 419A003C  beq cr6, 0x82a1a418
	if ctx.cr[6].eq {
	pc = 0x82A1A418; continue 'dispatch;
	}
	pc = 0x82A1A3E0; continue 'dispatch;
            }
            0x82A1A3E0 => {
    //   block [0x82A1A3E0..0x82A1A408)
	// 82A1A3E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1A3E4: 419A0024  beq cr6, 0x82a1a408
	if ctx.cr[6].eq {
	pc = 0x82A1A408; continue 'dispatch;
	}
	// 82A1A3E8: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1A3EC: 90CA0000  stw r6, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82A1A3F0: 80A90004  lwz r5, 4(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1A3F4: 90AA0004  stw r5, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82A1A3F8: 80890008  lwz r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1A3FC: 908A0008  stw r4, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82A1A400: 8069000C  lwz r3, 0xc(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1A404: 906A000C  stw r3, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	pc = 0x82A1A408; continue 'dispatch;
            }
            0x82A1A408 => {
    //   block [0x82A1A408..0x82A1A418)
	// 82A1A408: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 82A1A40C: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82A1A410: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A1A414: 409AFFCC  bne cr6, 0x82a1a3e0
	if !ctx.cr[6].eq {
	pc = 0x82A1A3E0; continue 'dispatch;
	}
	pc = 0x82A1A418; continue 'dispatch;
            }
            0x82A1A418 => {
    //   block [0x82A1A418..0x82A1A428)
	// 82A1A418: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A1A41C: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A1A420: 419A0038  beq cr6, 0x82a1a458
	if ctx.cr[6].eq {
	pc = 0x82A1A458; continue 'dispatch;
	}
	// 82A1A424: 394B0010  addi r10, r11, 0x10
	ctx.r[10].s64 = ctx.r[11].s64 + 16;
	pc = 0x82A1A428; continue 'dispatch;
            }
            0x82A1A428 => {
    //   block [0x82A1A428..0x82A1A458)
	// 82A1A428: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 82A1A42C: 394AFFF0  addi r10, r10, -0x10
	ctx.r[10].s64 = ctx.r[10].s64 + -16;
	// 82A1A430: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A1A434: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1A438: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A1A43C: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1A440: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82A1A444: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1A448: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82A1A44C: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1A450: 90AA000C  stw r5, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 82A1A454: 409AFFD4  bne cr6, 0x82a1a428
	if !ctx.cr[6].eq {
	pc = 0x82A1A428; continue 'dispatch;
	}
	pc = 0x82A1A458; continue 'dispatch;
            }
            0x82A1A458 => {
    //   block [0x82A1A458..0x82A1A468)
	// 82A1A458: 39470010  addi r10, r7, 0x10
	ctx.r[10].s64 = ctx.r[7].s64 + 16;
	// 82A1A45C: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82A1A460: 7F075040  cmplw cr6, r7, r10
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A1A464: 419A0034  beq cr6, 0x82a1a498
	if ctx.cr[6].eq {
	pc = 0x82A1A498; continue 'dispatch;
	}
	pc = 0x82A1A468; continue 'dispatch;
            }
            0x82A1A468 => {
    //   block [0x82A1A468..0x82A1A498)
	// 82A1A468: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82A1A46C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1A470: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1A474: 80C90008  lwz r6, 8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1A478: 80A9000C  lwz r5, 0xc(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1A47C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A1A480: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A1A484: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82A1A488: 90AB000C  stw r5, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[5].u32 ) };
	// 82A1A48C: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 82A1A490: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A1A494: 409AFFD4  bne cr6, 0x82a1a468
	if !ctx.cr[6].eq {
	pc = 0x82A1A468; continue 'dispatch;
	}
	pc = 0x82A1A498; continue 'dispatch;
            }
            0x82A1A498 => {
    //   block [0x82A1A498..0x82A1A4A0)
	// 82A1A498: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A1A49C: 4828EFBC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A4A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1A4A0 size=100
    let mut pc: u32 = 0x82A1A4A0;
    'dispatch: loop {
        match pc {
            0x82A1A4A0 => {
    //   block [0x82A1A4A0..0x82A1A4D4)
	// 82A1A4A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1A4A4: 4828EF69  bl 0x82ca940c
	ctx.lr = 0x82A1A4A8;
	sub_82CA93D0(ctx, base);
	// 82A1A4A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1A4AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1A4B0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1A4B4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A1A4B8: 394B2808  addi r10, r11, 0x2808
	ctx.r[10].s64 = ctx.r[11].s64 + 10248;
	// 82A1A4BC: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 82A1A4C0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1A4C4: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1A4C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1A4CC: 419A0008  beq cr6, 0x82a1a4d4
	if ctx.cr[6].eq {
	pc = 0x82A1A4D4; continue 'dispatch;
	}
	// 82A1A4D0: 4B801869  bl 0x8221bd38
	ctx.lr = 0x82A1A4D4;
	sub_8221BD38(ctx, base);
	pc = 0x82A1A4D4; continue 'dispatch;
            }
            0x82A1A4D4 => {
    //   block [0x82A1A4D4..0x82A1A4FC)
	// 82A1A4D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1A4D8: 57AA07FE  clrlwi r10, r29, 0x1f
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 82A1A4DC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A1A4E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1A4E4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A1A4E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1A4EC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82A1A4F0: 419A000C  beq cr6, 0x82a1a4fc
	if ctx.cr[6].eq {
	pc = 0x82A1A4FC; continue 'dispatch;
	}
	// 82A1A4F4: 4B801845  bl 0x8221bd38
	ctx.lr = 0x82A1A4F8;
	sub_8221BD38(ctx, base);
	// 82A1A4F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x82A1A4FC; continue 'dispatch;
            }
            0x82A1A4FC => {
    //   block [0x82A1A4FC..0x82A1A504)
	// 82A1A4FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1A500: 4828EF5C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A1A508 size=8
    let mut pc: u32 = 0x82A1A508;
    'dispatch: loop {
        match pc {
            0x82A1A508 => {
    //   block [0x82A1A508..0x82A1A510)
	// 82A1A508: 38600200  li r3, 0x200
	ctx.r[3].s64 = 512;
	// 82A1A50C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A1A510 size=8
    let mut pc: u32 = 0x82A1A510;
    'dispatch: loop {
        match pc {
            0x82A1A510 => {
    //   block [0x82A1A510..0x82A1A518)
	// 82A1A510: 38602000  li r3, 0x2000
	ctx.r[3].s64 = 8192;
	// 82A1A514: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1A518 size=92
    let mut pc: u32 = 0x82A1A518;
    'dispatch: loop {
        match pc {
            0x82A1A518 => {
    //   block [0x82A1A518..0x82A1A55C)
	// 82A1A518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1A51C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1A520: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1A524: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1A528: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1A52C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1A530: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1A534: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1A538: 394B2950  addi r10, r11, 0x2950
	ctx.r[10].s64 = ctx.r[11].s64 + 10576;
	// 82A1A53C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1A540: 48801A19  bl 0x8321bf58
	ctx.lr = 0x82A1A544;
	sub_8321BF58(ctx, base);
	// 82A1A544: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1A548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1A54C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1A550: 419A000C  beq cr6, 0x82a1a55c
	if ctx.cr[6].eq {
	pc = 0x82A1A55C; continue 'dispatch;
	}
	// 82A1A554: 4B8017E5  bl 0x8221bd38
	ctx.lr = 0x82A1A558;
	sub_8221BD38(ctx, base);
	// 82A1A558: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1A55C; continue 'dispatch;
            }
            0x82A1A55C => {
    //   block [0x82A1A55C..0x82A1A574)
	// 82A1A55C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1A560: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1A564: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1A568: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1A56C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1A570: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A1A578 size=8
    let mut pc: u32 = 0x82A1A578;
    'dispatch: loop {
        match pc {
            0x82A1A578 => {
    //   block [0x82A1A578..0x82A1A580)
	// 82A1A578: 3C600001  lis r3, 1
	ctx.r[3].s64 = 65536;
	// 82A1A57C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A1A580 size=8
    let mut pc: u32 = 0x82A1A580;
    'dispatch: loop {
        match pc {
            0x82A1A580 => {
    //   block [0x82A1A580..0x82A1A588)
	// 82A1A580: 3C600002  lis r3, 2
	ctx.r[3].s64 = 131072;
	// 82A1A584: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1A588 size=80
    let mut pc: u32 = 0x82A1A588;
    'dispatch: loop {
        match pc {
            0x82A1A588 => {
    //   block [0x82A1A588..0x82A1A5C0)
	// 82A1A588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1A58C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1A590: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1A594: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1A598: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1A59C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1A5A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1A5A4: 488019B5  bl 0x8321bf58
	ctx.lr = 0x82A1A5A8;
	sub_8321BF58(ctx, base);
	// 82A1A5A8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1A5AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1A5B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1A5B4: 419A000C  beq cr6, 0x82a1a5c0
	if ctx.cr[6].eq {
	pc = 0x82A1A5C0; continue 'dispatch;
	}
	// 82A1A5B8: 4B801781  bl 0x8221bd38
	ctx.lr = 0x82A1A5BC;
	sub_8221BD38(ctx, base);
	// 82A1A5BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1A5C0; continue 'dispatch;
            }
            0x82A1A5C0 => {
    //   block [0x82A1A5C0..0x82A1A5D8)
	// 82A1A5C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1A5C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1A5C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1A5CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1A5D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1A5D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1A5D8 size=92
    let mut pc: u32 = 0x82A1A5D8;
    'dispatch: loop {
        match pc {
            0x82A1A5D8 => {
    //   block [0x82A1A5D8..0x82A1A61C)
	// 82A1A5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1A5DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1A5E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1A5E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1A5E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1A5EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1A5F0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1A5F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1A5F8: 394B2860  addi r10, r11, 0x2860
	ctx.r[10].s64 = ctx.r[11].s64 + 10336;
	// 82A1A5FC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1A600: 48801959  bl 0x8321bf58
	ctx.lr = 0x82A1A604;
	sub_8321BF58(ctx, base);
	// 82A1A604: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1A608: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1A60C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1A610: 419A000C  beq cr6, 0x82a1a61c
	if ctx.cr[6].eq {
	pc = 0x82A1A61C; continue 'dispatch;
	}
	// 82A1A614: 4B801725  bl 0x8221bd38
	ctx.lr = 0x82A1A618;
	sub_8221BD38(ctx, base);
	// 82A1A618: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1A61C; continue 'dispatch;
            }
            0x82A1A61C => {
    //   block [0x82A1A61C..0x82A1A634)
	// 82A1A61C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1A620: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1A624: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1A628: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1A62C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1A630: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1A638 size=92
    let mut pc: u32 = 0x82A1A638;
    'dispatch: loop {
        match pc {
            0x82A1A638 => {
    //   block [0x82A1A638..0x82A1A67C)
	// 82A1A638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1A63C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1A640: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1A644: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1A648: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1A64C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1A650: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1A654: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1A658: 394B2878  addi r10, r11, 0x2878
	ctx.r[10].s64 = ctx.r[11].s64 + 10360;
	// 82A1A65C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1A660: 488018F9  bl 0x8321bf58
	ctx.lr = 0x82A1A664;
	sub_8321BF58(ctx, base);
	// 82A1A664: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1A668: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1A66C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1A670: 419A000C  beq cr6, 0x82a1a67c
	if ctx.cr[6].eq {
	pc = 0x82A1A67C; continue 'dispatch;
	}
	// 82A1A674: 4B8016C5  bl 0x8221bd38
	ctx.lr = 0x82A1A678;
	sub_8221BD38(ctx, base);
	// 82A1A678: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1A67C; continue 'dispatch;
            }
            0x82A1A67C => {
    //   block [0x82A1A67C..0x82A1A694)
	// 82A1A67C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1A680: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1A684: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1A688: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1A68C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1A690: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1A698 size=92
    let mut pc: u32 = 0x82A1A698;
    'dispatch: loop {
        match pc {
            0x82A1A698 => {
    //   block [0x82A1A698..0x82A1A6DC)
	// 82A1A698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1A69C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1A6A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1A6A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1A6A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1A6AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1A6B0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1A6B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1A6B8: 394B2890  addi r10, r11, 0x2890
	ctx.r[10].s64 = ctx.r[11].s64 + 10384;
	// 82A1A6BC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1A6C0: 48801899  bl 0x8321bf58
	ctx.lr = 0x82A1A6C4;
	sub_8321BF58(ctx, base);
	// 82A1A6C4: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1A6C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1A6CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1A6D0: 419A000C  beq cr6, 0x82a1a6dc
	if ctx.cr[6].eq {
	pc = 0x82A1A6DC; continue 'dispatch;
	}
	// 82A1A6D4: 4B801665  bl 0x8221bd38
	ctx.lr = 0x82A1A6D8;
	sub_8221BD38(ctx, base);
	// 82A1A6D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1A6DC; continue 'dispatch;
            }
            0x82A1A6DC => {
    //   block [0x82A1A6DC..0x82A1A6F4)
	// 82A1A6DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1A6E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1A6E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1A6E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1A6EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1A6F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1A6F8 size=92
    let mut pc: u32 = 0x82A1A6F8;
    'dispatch: loop {
        match pc {
            0x82A1A6F8 => {
    //   block [0x82A1A6F8..0x82A1A73C)
	// 82A1A6F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1A6FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1A700: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1A704: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1A708: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1A70C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1A710: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1A714: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1A718: 394B28A8  addi r10, r11, 0x28a8
	ctx.r[10].s64 = ctx.r[11].s64 + 10408;
	// 82A1A71C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1A720: 48801839  bl 0x8321bf58
	ctx.lr = 0x82A1A724;
	sub_8321BF58(ctx, base);
	// 82A1A724: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1A728: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1A72C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1A730: 419A000C  beq cr6, 0x82a1a73c
	if ctx.cr[6].eq {
	pc = 0x82A1A73C; continue 'dispatch;
	}
	// 82A1A734: 4B801605  bl 0x8221bd38
	ctx.lr = 0x82A1A738;
	sub_8221BD38(ctx, base);
	// 82A1A738: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1A73C; continue 'dispatch;
            }
            0x82A1A73C => {
    //   block [0x82A1A73C..0x82A1A754)
	// 82A1A73C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1A740: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1A744: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1A748: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1A74C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1A750: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1A758 size=92
    let mut pc: u32 = 0x82A1A758;
    'dispatch: loop {
        match pc {
            0x82A1A758 => {
    //   block [0x82A1A758..0x82A1A79C)
	// 82A1A758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1A75C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1A760: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1A764: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1A768: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1A76C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1A770: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1A774: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1A778: 394B28C0  addi r10, r11, 0x28c0
	ctx.r[10].s64 = ctx.r[11].s64 + 10432;
	// 82A1A77C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1A780: 488017D9  bl 0x8321bf58
	ctx.lr = 0x82A1A784;
	sub_8321BF58(ctx, base);
	// 82A1A784: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1A788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1A78C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1A790: 419A000C  beq cr6, 0x82a1a79c
	if ctx.cr[6].eq {
	pc = 0x82A1A79C; continue 'dispatch;
	}
	// 82A1A794: 4B8015A5  bl 0x8221bd38
	ctx.lr = 0x82A1A798;
	sub_8221BD38(ctx, base);
	// 82A1A798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1A79C; continue 'dispatch;
            }
            0x82A1A79C => {
    //   block [0x82A1A79C..0x82A1A7B4)
	// 82A1A79C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1A7A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1A7A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1A7A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1A7AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1A7B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1A7B8 size=92
    let mut pc: u32 = 0x82A1A7B8;
    'dispatch: loop {
        match pc {
            0x82A1A7B8 => {
    //   block [0x82A1A7B8..0x82A1A7FC)
	// 82A1A7B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1A7BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1A7C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1A7C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1A7C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1A7CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1A7D0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1A7D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1A7D8: 394B28D8  addi r10, r11, 0x28d8
	ctx.r[10].s64 = ctx.r[11].s64 + 10456;
	// 82A1A7DC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1A7E0: 48801779  bl 0x8321bf58
	ctx.lr = 0x82A1A7E4;
	sub_8321BF58(ctx, base);
	// 82A1A7E4: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1A7E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1A7EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1A7F0: 419A000C  beq cr6, 0x82a1a7fc
	if ctx.cr[6].eq {
	pc = 0x82A1A7FC; continue 'dispatch;
	}
	// 82A1A7F4: 4B801545  bl 0x8221bd38
	ctx.lr = 0x82A1A7F8;
	sub_8221BD38(ctx, base);
	// 82A1A7F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1A7FC; continue 'dispatch;
            }
            0x82A1A7FC => {
    //   block [0x82A1A7FC..0x82A1A814)
	// 82A1A7FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1A800: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1A804: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1A808: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1A80C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1A810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1A818 size=92
    let mut pc: u32 = 0x82A1A818;
    'dispatch: loop {
        match pc {
            0x82A1A818 => {
    //   block [0x82A1A818..0x82A1A85C)
	// 82A1A818: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1A81C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1A820: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1A824: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1A828: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1A82C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1A830: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1A834: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1A838: 394B28F0  addi r10, r11, 0x28f0
	ctx.r[10].s64 = ctx.r[11].s64 + 10480;
	// 82A1A83C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1A840: 48801719  bl 0x8321bf58
	ctx.lr = 0x82A1A844;
	sub_8321BF58(ctx, base);
	// 82A1A844: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1A848: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1A84C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1A850: 419A000C  beq cr6, 0x82a1a85c
	if ctx.cr[6].eq {
	pc = 0x82A1A85C; continue 'dispatch;
	}
	// 82A1A854: 4B8014E5  bl 0x8221bd38
	ctx.lr = 0x82A1A858;
	sub_8221BD38(ctx, base);
	// 82A1A858: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1A85C; continue 'dispatch;
            }
            0x82A1A85C => {
    //   block [0x82A1A85C..0x82A1A874)
	// 82A1A85C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1A860: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1A864: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1A868: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1A86C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1A870: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1A878 size=92
    let mut pc: u32 = 0x82A1A878;
    'dispatch: loop {
        match pc {
            0x82A1A878 => {
    //   block [0x82A1A878..0x82A1A8BC)
	// 82A1A878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1A87C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1A880: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1A884: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1A888: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1A88C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1A890: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1A894: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1A898: 394B2908  addi r10, r11, 0x2908
	ctx.r[10].s64 = ctx.r[11].s64 + 10504;
	// 82A1A89C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1A8A0: 488016B9  bl 0x8321bf58
	ctx.lr = 0x82A1A8A4;
	sub_8321BF58(ctx, base);
	// 82A1A8A4: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1A8A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1A8AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1A8B0: 419A000C  beq cr6, 0x82a1a8bc
	if ctx.cr[6].eq {
	pc = 0x82A1A8BC; continue 'dispatch;
	}
	// 82A1A8B4: 4B801485  bl 0x8221bd38
	ctx.lr = 0x82A1A8B8;
	sub_8221BD38(ctx, base);
	// 82A1A8B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1A8BC; continue 'dispatch;
            }
            0x82A1A8BC => {
    //   block [0x82A1A8BC..0x82A1A8D4)
	// 82A1A8BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1A8C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1A8C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1A8C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1A8CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1A8D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A8D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1A8D8 size=92
    let mut pc: u32 = 0x82A1A8D8;
    'dispatch: loop {
        match pc {
            0x82A1A8D8 => {
    //   block [0x82A1A8D8..0x82A1A91C)
	// 82A1A8D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1A8DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1A8E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1A8E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1A8E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1A8EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1A8F0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1A8F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1A8F8: 394B2920  addi r10, r11, 0x2920
	ctx.r[10].s64 = ctx.r[11].s64 + 10528;
	// 82A1A8FC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1A900: 48801659  bl 0x8321bf58
	ctx.lr = 0x82A1A904;
	sub_8321BF58(ctx, base);
	// 82A1A904: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1A908: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1A90C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1A910: 419A000C  beq cr6, 0x82a1a91c
	if ctx.cr[6].eq {
	pc = 0x82A1A91C; continue 'dispatch;
	}
	// 82A1A914: 4B801425  bl 0x8221bd38
	ctx.lr = 0x82A1A918;
	sub_8221BD38(ctx, base);
	// 82A1A918: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1A91C; continue 'dispatch;
            }
            0x82A1A91C => {
    //   block [0x82A1A91C..0x82A1A934)
	// 82A1A91C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1A920: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1A924: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1A928: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1A92C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1A930: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1A938 size=92
    let mut pc: u32 = 0x82A1A938;
    'dispatch: loop {
        match pc {
            0x82A1A938 => {
    //   block [0x82A1A938..0x82A1A97C)
	// 82A1A938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1A93C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1A940: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1A944: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1A948: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1A94C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1A950: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1A954: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1A958: 394B2968  addi r10, r11, 0x2968
	ctx.r[10].s64 = ctx.r[11].s64 + 10600;
	// 82A1A95C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1A960: 488015F9  bl 0x8321bf58
	ctx.lr = 0x82A1A964;
	sub_8321BF58(ctx, base);
	// 82A1A964: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1A968: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1A96C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1A970: 419A000C  beq cr6, 0x82a1a97c
	if ctx.cr[6].eq {
	pc = 0x82A1A97C; continue 'dispatch;
	}
	// 82A1A974: 4B8013C5  bl 0x8221bd38
	ctx.lr = 0x82A1A978;
	sub_8221BD38(ctx, base);
	// 82A1A978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1A97C; continue 'dispatch;
            }
            0x82A1A97C => {
    //   block [0x82A1A97C..0x82A1A994)
	// 82A1A97C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1A980: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1A984: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1A988: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1A98C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1A990: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1A998 size=92
    let mut pc: u32 = 0x82A1A998;
    'dispatch: loop {
        match pc {
            0x82A1A998 => {
    //   block [0x82A1A998..0x82A1A9DC)
	// 82A1A998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1A99C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1A9A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1A9A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1A9A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1A9AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1A9B0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1A9B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1A9B8: 394B2980  addi r10, r11, 0x2980
	ctx.r[10].s64 = ctx.r[11].s64 + 10624;
	// 82A1A9BC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1A9C0: 48801599  bl 0x8321bf58
	ctx.lr = 0x82A1A9C4;
	sub_8321BF58(ctx, base);
	// 82A1A9C4: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1A9C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1A9CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1A9D0: 419A000C  beq cr6, 0x82a1a9dc
	if ctx.cr[6].eq {
	pc = 0x82A1A9DC; continue 'dispatch;
	}
	// 82A1A9D4: 4B801365  bl 0x8221bd38
	ctx.lr = 0x82A1A9D8;
	sub_8221BD38(ctx, base);
	// 82A1A9D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1A9DC; continue 'dispatch;
            }
            0x82A1A9DC => {
    //   block [0x82A1A9DC..0x82A1A9F4)
	// 82A1A9DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1A9E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1A9E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1A9E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1A9EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1A9F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1A9F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1A9F8 size=260
    let mut pc: u32 = 0x82A1A9F8;
    'dispatch: loop {
        match pc {
            0x82A1A9F8 => {
    //   block [0x82A1A9F8..0x82A1AA20)
	// 82A1A9F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1A9FC: 4828EA0D  bl 0x82ca9408
	ctx.lr = 0x82A1AA00;
	sub_82CA93D0(ctx, base);
	// 82A1AA00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1AA04: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A1AA08: 839D0004  lwz r28, 4(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1AA0C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1AA10: 894B0011  lbz r10, 0x11(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A1AA14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1AA18: 409A0030  bne cr6, 0x82a1aa48
	if !ctx.cr[6].eq {
	pc = 0x82A1AA48; continue 'dispatch;
	}
	// 82A1AA1C: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1AA20; continue 'dispatch;
            }
            0x82A1AA20 => {
    //   block [0x82A1AA20..0x82A1AA38)
	// 82A1AA20: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1AA24: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1AA28: 40980010  bge cr6, 0x82a1aa38
	if !ctx.cr[6].lt {
	pc = 0x82A1AA38; continue 'dispatch;
	}
	// 82A1AA2C: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 82A1AA30: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1AA34: 48000008  b 0x82a1aa3c
	pc = 0x82A1AA3C; continue 'dispatch;
            }
            0x82A1AA38 => {
    //   block [0x82A1AA38..0x82A1AA3C)
	// 82A1AA38: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A1AA3C; continue 'dispatch;
            }
            0x82A1AA3C => {
    //   block [0x82A1AA3C..0x82A1AA48)
	// 82A1AA3C: 892B0011  lbz r9, 0x11(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A1AA40: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1AA44: 419AFFDC  beq cr6, 0x82a1aa20
	if ctx.cr[6].eq {
	pc = 0x82A1AA20; continue 'dispatch;
	}
	pc = 0x82A1AA48; continue 'dispatch;
            }
            0x82A1AA48 => {
    //   block [0x82A1AA48..0x82A1AA6C)
	// 82A1AA48: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1AA4C: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82A1AA50: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A1AA54: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82A1AA58: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1AA5C: 892B0011  lbz r9, 0x11(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A1AA60: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1AA64: 409A0030  bne cr6, 0x82a1aa94
	if !ctx.cr[6].eq {
	pc = 0x82A1AA94; continue 'dispatch;
	}
	// 82A1AA68: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1AA6C; continue 'dispatch;
            }
            0x82A1AA6C => {
    //   block [0x82A1AA6C..0x82A1AA80)
	// 82A1AA6C: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1AA70: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1AA74: 4098000C  bge cr6, 0x82a1aa80
	if !ctx.cr[6].lt {
	pc = 0x82A1AA80; continue 'dispatch;
	}
	// 82A1AA78: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1AA7C: 4800000C  b 0x82a1aa88
	pc = 0x82A1AA88; continue 'dispatch;
            }
            0x82A1AA80 => {
    //   block [0x82A1AA80..0x82A1AA88)
	// 82A1AA80: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A1AA84: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1AA88; continue 'dispatch;
            }
            0x82A1AA88 => {
    //   block [0x82A1AA88..0x82A1AA94)
	// 82A1AA88: 890B0011  lbz r8, 0x11(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A1AA8C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A1AA90: 419AFFDC  beq cr6, 0x82a1aa6c
	if ctx.cr[6].eq {
	pc = 0x82A1AA6C; continue 'dispatch;
	}
	pc = 0x82A1AA94; continue 'dispatch;
            }
            0x82A1AA94 => {
    //   block [0x82A1AA94..0x82A1AAA8)
	// 82A1AA94: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A1AA98: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A1AA9C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A1AAA0: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A1AAA4: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	pc = 0x82A1AAA8; continue 'dispatch;
            }
            0x82A1AAA8 => {
    //   block [0x82A1AAA8..0x82A1AABC)
	// 82A1AAA8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1AAAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1AAB0: 419A000C  beq cr6, 0x82a1aabc
	if ctx.cr[6].eq {
	pc = 0x82A1AABC; continue 'dispatch;
	}
	// 82A1AAB4: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A1AAB8: 419A0008  beq cr6, 0x82a1aac0
	if ctx.cr[6].eq {
	pc = 0x82A1AAC0; continue 'dispatch;
	}
	pc = 0x82A1AABC; continue 'dispatch;
            }
            0x82A1AABC => {
    //   block [0x82A1AABC..0x82A1AAC0)
	// 82A1AABC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A1AAC0; continue 'dispatch;
            }
            0x82A1AAC0 => {
    //   block [0x82A1AAC0..0x82A1AADC)
	// 82A1AAC0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A1AAC4: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82A1AAC8: 419A0014  beq cr6, 0x82a1aadc
	if ctx.cr[6].eq {
	pc = 0x82A1AADC; continue 'dispatch;
	}
	// 82A1AACC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1AAD0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A1AAD4: 4B8E5655  bl 0x82300128
	ctx.lr = 0x82A1AAD8;
	sub_82300128(ctx, base);
	// 82A1AAD8: 4BFFFFD0  b 0x82a1aaa8
	pc = 0x82A1AAA8; continue 'dispatch;
            }
            0x82A1AADC => {
    //   block [0x82A1AADC..0x82A1AAFC)
	// 82A1AADC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A1AAE0: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A1AAE4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1AAE8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1AAEC: 4B8E7015  bl 0x82301b00
	ctx.lr = 0x82A1AAF0;
	sub_82301B00(ctx, base);
	// 82A1AAF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1AAF4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A1AAF8: 4828E960  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1AB00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1AB00 size=100
    let mut pc: u32 = 0x82A1AB00;
    'dispatch: loop {
        match pc {
            0x82A1AB00 => {
    //   block [0x82A1AB00..0x82A1AB28)
	// 82A1AB00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1AB04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1AB08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1AB0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1AB10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1AB14: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A1AB18: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1AB1C: 897F0011  lbz r11, 0x11(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A1AB20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1AB24: 409A0028  bne cr6, 0x82a1ab4c
	if !ctx.cr[6].eq {
	pc = 0x82A1AB4C; continue 'dispatch;
	}
	pc = 0x82A1AB28; continue 'dispatch;
            }
            0x82A1AB28 => {
    //   block [0x82A1AB28..0x82A1AB4C)
	// 82A1AB28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1AB2C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1AB30: 4BFFFFD1  bl 0x82a1ab00
	ctx.lr = 0x82A1AB34;
	sub_82A1AB00(ctx, base);
	// 82A1AB34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1AB38: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1AB3C: 4B8011FD  bl 0x8221bd38
	ctx.lr = 0x82A1AB40;
	sub_8221BD38(ctx, base);
	// 82A1AB40: 897F0011  lbz r11, 0x11(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A1AB44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1AB48: 419AFFE0  beq cr6, 0x82a1ab28
	if ctx.cr[6].eq {
	pc = 0x82A1AB28; continue 'dispatch;
	}
	pc = 0x82A1AB4C; continue 'dispatch;
            }
            0x82A1AB4C => {
    //   block [0x82A1AB4C..0x82A1AB64)
	// 82A1AB4C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1AB50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1AB54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1AB58: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1AB5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1AB60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1AB68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A1AB68 size=72
    let mut pc: u32 = 0x82A1AB68;
    'dispatch: loop {
        match pc {
            0x82A1AB68 => {
    //   block [0x82A1AB68..0x82A1AB88)
	// 82A1AB68: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1AB6C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1AB70: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A1AB74: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1AB78: 892A0011  lbz r9, 0x11(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(17 as u32) ) } as u64;
	// 82A1AB7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1AB80: 409A0008  bne cr6, 0x82a1ab88
	if !ctx.cr[6].eq {
	pc = 0x82A1AB88; continue 'dispatch;
	}
	// 82A1AB84: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x82A1AB88; continue 'dispatch;
            }
            0x82A1AB88 => {
    //   block [0x82A1AB88..0x82A1ABB0)
	// 82A1AB88: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1AB8C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A1AB90: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1AB94: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1AB98: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1AB9C: 409A0014  bne cr6, 0x82a1abb0
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82A1ABB0);
		return;
	}
	// 82A1ABA0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A1ABA4: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82A1ABA8: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A1ABAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1ABE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1ABE0 size=96
    let mut pc: u32 = 0x82A1ABE0;
    'dispatch: loop {
        match pc {
            0x82A1ABE0 => {
    //   block [0x82A1ABE0..0x82A1AC28)
	// 82A1ABE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1ABE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1ABE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1ABEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1ABF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1ABF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1ABF8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1ABFC: 387F0024  addi r3, r31, 0x24
	ctx.r[3].s64 = ctx.r[31].s64 + 36;
	// 82A1AC00: 4B79CF19  bl 0x821b7b18
	ctx.lr = 0x82A1AC04;
	sub_821B7B18(ctx, base);
	// 82A1AC04: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1AC08: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1AC0C: 392B2B90  addi r9, r11, 0x2b90
	ctx.r[9].s64 = ctx.r[11].s64 + 11152;
	// 82A1AC10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1AC14: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A1AC18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1AC1C: 419A000C  beq cr6, 0x82a1ac28
	if ctx.cr[6].eq {
	pc = 0x82A1AC28; continue 'dispatch;
	}
	// 82A1AC20: 4B801119  bl 0x8221bd38
	ctx.lr = 0x82A1AC24;
	sub_8221BD38(ctx, base);
	// 82A1AC24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1AC28; continue 'dispatch;
            }
            0x82A1AC28 => {
    //   block [0x82A1AC28..0x82A1AC40)
	// 82A1AC28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1AC2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1AC30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1AC34: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1AC38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1AC3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1AC40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1AC40 size=84
    let mut pc: u32 = 0x82A1AC40;
    'dispatch: loop {
        match pc {
            0x82A1AC40 => {
    //   block [0x82A1AC40..0x82A1AC60)
	// 82A1AC40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1AC44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1AC48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1AC4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1AC50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1AC54: 897F002D  lbz r11, 0x2d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 82A1AC58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1AC5C: 409A0024  bne cr6, 0x82a1ac80
	if !ctx.cr[6].eq {
	pc = 0x82A1AC80; continue 'dispatch;
	}
	pc = 0x82A1AC60; continue 'dispatch;
            }
            0x82A1AC60 => {
    //   block [0x82A1AC60..0x82A1AC80)
	// 82A1AC60: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A1AC64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1AC68: 409A0018  bne cr6, 0x82a1ac80
	if !ctx.cr[6].eq {
	pc = 0x82A1AC80; continue 'dispatch;
	}
	// 82A1AC6C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A1AC70: 482A8211  bl 0x82cc2e80
	ctx.lr = 0x82A1AC74;
	sub_82CC2E80(ctx, base);
	// 82A1AC74: 897F002D  lbz r11, 0x2d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 82A1AC78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1AC7C: 419AFFE4  beq cr6, 0x82a1ac60
	if ctx.cr[6].eq {
	pc = 0x82A1AC60; continue 'dispatch;
	}
	pc = 0x82A1AC80; continue 'dispatch;
            }
            0x82A1AC80 => {
    //   block [0x82A1AC80..0x82A1AC94)
	// 82A1AC80: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A1AC84: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1AC88: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1AC8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1AC90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1AC98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1AC98 size=368
    let mut pc: u32 = 0x82A1AC98;
    'dispatch: loop {
        match pc {
            0x82A1AC98 => {
    //   block [0x82A1AC98..0x82A1ADB0)
	// 82A1AC98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1AC9C: 4828E765  bl 0x82ca9400
	ctx.lr = 0x82A1ACA0;
	sub_82CA93D0(ctx, base);
	// 82A1ACA0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1ACA4: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82A1ACA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1ACAC: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 82A1ACB0: 3D008336  lis r8, -0x7cca
	ctx.r[8].s64 = -2093613056;
	// 82A1ACB4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A1ACB8: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82A1ACBC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82A1ACC0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82A1ACC4: 91690300  stw r11, 0x300(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(768 as u32), ctx.r[11].u32 ) };
	// 82A1ACC8: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A1ACCC: 9B9E002D  stb r28, 0x2d(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(45 as u32), ctx.r[28].u8 ) };
	// 82A1ACD0: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82A1ACD4: 91480350  stw r10, 0x350(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(848 as u32), ctx.r[10].u32 ) };
	// 82A1ACD8: 4B804031  bl 0x8221ed08
	ctx.lr = 0x82A1ACDC;
	sub_8221ED08(ctx, base);
	// 82A1ACDC: 3CE08336  lis r7, -0x7cca
	ctx.r[7].s64 = -2093613056;
	// 82A1ACE0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A1ACE4: 3CC08332  lis r6, -0x7cce
	ctx.r[6].s64 = -2093875200;
	// 82A1ACE8: 3866B158  addi r3, r6, -0x4ea8
	ctx.r[3].s64 = ctx.r[6].s64 + -20136;
	// 82A1ACEC: 91670354  stw r11, 0x354(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(852 as u32), ctx.r[11].u32 ) };
	// 82A1ACF0: 48153D11  bl 0x82b6ea00
	ctx.lr = 0x82A1ACF4;
	sub_82B6EA00(ctx, base);
	// 82A1ACF4: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82A1ACF8: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 82A1ACFC: 9BA10079  stb r29, 0x79(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(121 as u32), ctx.r[29].u8 ) };
	// 82A1AD00: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 82A1AD04: 90A10068  stw r5, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[5].u32 ) };
	// 82A1AD08: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82A1AD0C: 9081006C  stw r4, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[4].u32 ) };
	// 82A1AD10: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A1AD14: 9BE10078  stb r31, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u8 ) };
	// 82A1AD18: 93E10084  stw r31, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	// 82A1AD1C: 9361007C  stw r27, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	// 82A1AD20: 9B81007A  stb r28, 0x7a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(122 as u32), ctx.r[28].u8 ) };
	// 82A1AD24: 4889EC91  bl 0x832b99b4
	ctx.lr = 0x82A1AD28;
	// extern call 0x832B99B4  crate::xboxkrnl::XGetVideoMode
	crate::xboxkrnl::XGetVideoMode(ctx, base);
	// 82A1AD28: C00100A4  lfs f0, 0xa4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1AD2C: 39400500  li r10, 0x500
	ctx.r[10].s64 = 1280;
	// 82A1AD30: 392002D0  li r9, 0x2d0
	ctx.r[9].s64 = 720;
	// 82A1AD34: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82A1AD38: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 82A1AD3C: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A1AD40: 93410080  stw r26, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[26].u32 ) };
	// 82A1AD44: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A1AD48: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82A1AD4C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1AD50: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82A1AD54: 91010074  stw r8, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[8].u32 ) };
	// 82A1AD58: 48153D09  bl 0x82b6ea60
	ctx.lr = 0x82A1AD5C;
	sub_82B6EA60(ctx, base);
	// 82A1AD5C: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 82A1AD60: 4B8044F9  bl 0x8221f258
	ctx.lr = 0x82A1AD64;
	sub_8221F258(ctx, base);
	// 82A1AD64: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1AD68: 419A0048  beq cr6, 0x82a1adb0
	if ctx.cr[6].eq {
	pc = 0x82A1ADB0; continue 'dispatch;
	}
	// 82A1AD6C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1AD70: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82A1AD74: 93E3000C  stw r31, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82A1AD78: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A1AD7C: 93E30010  stw r31, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82A1AD80: 394B187C  addi r10, r11, 0x187c
	ctx.r[10].s64 = ctx.r[11].s64 + 6268;
	// 82A1AD84: 93E30018  stw r31, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 82A1AD88: 93E3001C  stw r31, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 82A1AD8C: 93E30020  stw r31, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 82A1AD90: 93E30028  stw r31, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[31].u32 ) };
	// 82A1AD94: 93E3002C  stw r31, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[31].u32 ) };
	// 82A1AD98: 93E30030  stw r31, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[31].u32 ) };
	// 82A1AD9C: 93E30034  stw r31, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[31].u32 ) };
	// 82A1ADA0: 93E30038  stw r31, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[31].u32 ) };
	// 82A1ADA4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1ADA8: 9BE3003C  stb r31, 0x3c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[31].u8 ) };
	// 82A1ADAC: 48000008  b 0x82a1adb4
	pc = 0x82A1ADB4; continue 'dispatch;
            }
            0x82A1ADB0 => {
    //   block [0x82A1ADB0..0x82A1ADB4)
	// 82A1ADB0: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	pc = 0x82A1ADB4; continue 'dispatch;
            }
            0x82A1ADB4 => {
    //   block [0x82A1ADB4..0x82A1ADF8)
	// 82A1ADB4: 3BDE0024  addi r30, r30, 0x24
	ctx.r[30].s64 = ctx.r[30].s64 + 36;
	// 82A1ADB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1ADBC: 4B79CD5D  bl 0x821b7b18
	ctx.lr = 0x82A1ADC0;
	sub_821B7B18(ctx, base);
	// 82A1ADC0: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A1ADC4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A1ADC8: 419A0034  beq cr6, 0x82a1adfc
	if ctx.cr[6].eq {
	pc = 0x82A1ADFC; continue 'dispatch;
	}
	// 82A1ADCC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A1ADD0: 4B804489  bl 0x8221f258
	ctx.lr = 0x82A1ADD4;
	sub_8221F258(ctx, base);
	// 82A1ADD4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1ADD8: 419A0020  beq cr6, 0x82a1adf8
	if ctx.cr[6].eq {
	pc = 0x82A1ADF8; continue 'dispatch;
	}
	// 82A1ADDC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1ADE0: 3D408253  lis r10, -0x7dad
	ctx.r[10].s64 = -2108489728;
	// 82A1ADE4: 93830000  stw r28, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A1ADE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1ADEC: 392A9238  addi r9, r10, -0x6dc8
	ctx.r[9].s64 = ctx.r[10].s64 + -28104;
	// 82A1ADF0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A1ADF4: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82A1ADF8; continue 'dispatch;
            }
            0x82A1ADF8 => {
    //   block [0x82A1ADF8..0x82A1ADFC)
	// 82A1ADF8: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82A1ADFC; continue 'dispatch;
            }
            0x82A1ADFC => {
    //   block [0x82A1ADFC..0x82A1AE08)
	// 82A1ADFC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A1AE00: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82A1AE04: 4828E64C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1AE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1AE18 size=76
    let mut pc: u32 = 0x82A1AE18;
    'dispatch: loop {
        match pc {
            0x82A1AE18 => {
    //   block [0x82A1AE18..0x82A1AE64)
	// 82A1AE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1AE1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1AE20: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1AE24: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82A1AE28: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 82A1AE2C: 3D008336  lis r8, -0x7cca
	ctx.r[8].s64 = -2093613056;
	// 82A1AE30: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82A1AE34: 91690354  stw r11, 0x354(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(852 as u32), ctx.r[11].u32 ) };
	// 82A1AE38: 91480350  stw r10, 0x350(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(848 as u32), ctx.r[10].u32 ) };
	// 82A1AE3C: 4B7E1705  bl 0x821fc540
	ctx.lr = 0x82A1AE40;
	sub_821FC540(ctx, base);
	// 82A1AE40: 4B827391  bl 0x822421d0
	ctx.lr = 0x82A1AE44;
	sub_822421D0(ctx, base);
	// 82A1AE44: 48154B8D  bl 0x82b6f9d0
	ctx.lr = 0x82A1AE48;
	sub_82B6F9D0(ctx, base);
	// 82A1AE48: 3CE08336  lis r7, -0x7cca
	ctx.r[7].s64 = -2093613056;
	// 82A1AE4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1AE50: 916703E4  stw r11, 0x3e4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(996 as u32), ctx.r[11].u32 ) };
	// 82A1AE54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A1AE58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1AE5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1AE60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1AE68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1AE68 size=80
    let mut pc: u32 = 0x82A1AE68;
    'dispatch: loop {
        match pc {
            0x82A1AE68 => {
    //   block [0x82A1AE68..0x82A1AEA4)
	// 82A1AE68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1AE6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1AE70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1AE74: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1AE78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1AE7C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1AE80: 394B2A2C  addi r10, r11, 0x2a2c
	ctx.r[10].s64 = ctx.r[11].s64 + 10796;
	// 82A1AE84: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1AE88: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1AE8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1AE90: 419A0014  beq cr6, 0x82a1aea4
	if ctx.cr[6].eq {
	pc = 0x82A1AEA4; continue 'dispatch;
	}
	// 82A1AE94: 4B7E148D  bl 0x821fc320
	ctx.lr = 0x82A1AE98;
	sub_821FC320(ctx, base);
	// 82A1AE98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1AE9C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A1AEA0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82A1AEA4; continue 'dispatch;
            }
            0x82A1AEA4 => {
    //   block [0x82A1AEA4..0x82A1AEB8)
	// 82A1AEA4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A1AEA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1AEAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1AEB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1AEB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1AEB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1AEB8 size=116
    let mut pc: u32 = 0x82A1AEB8;
    'dispatch: loop {
        match pc {
            0x82A1AEB8 => {
    //   block [0x82A1AEB8..0x82A1AEFC)
	// 82A1AEB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1AEBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1AEC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1AEC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1AEC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1AECC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1AED0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1AED4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1AED8: 394B2A2C  addi r10, r11, 0x2a2c
	ctx.r[10].s64 = ctx.r[11].s64 + 10796;
	// 82A1AEDC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1AEE0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1AEE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1AEE8: 419A0014  beq cr6, 0x82a1aefc
	if ctx.cr[6].eq {
	pc = 0x82A1AEFC; continue 'dispatch;
	}
	// 82A1AEEC: 4B7E1435  bl 0x821fc320
	ctx.lr = 0x82A1AEF0;
	sub_821FC320(ctx, base);
	// 82A1AEF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1AEF4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A1AEF8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82A1AEFC; continue 'dispatch;
            }
            0x82A1AEFC => {
    //   block [0x82A1AEFC..0x82A1AF14)
	// 82A1AEFC: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1AF00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1AF04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1AF08: 419A000C  beq cr6, 0x82a1af14
	if ctx.cr[6].eq {
	pc = 0x82A1AF14; continue 'dispatch;
	}
	// 82A1AF0C: 4B800E2D  bl 0x8221bd38
	ctx.lr = 0x82A1AF10;
	sub_8221BD38(ctx, base);
	// 82A1AF10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1AF14; continue 'dispatch;
            }
            0x82A1AF14 => {
    //   block [0x82A1AF14..0x82A1AF2C)
	// 82A1AF14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1AF18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1AF1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1AF20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1AF24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1AF28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1AF30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1AF30 size=92
    let mut pc: u32 = 0x82A1AF30;
    'dispatch: loop {
        match pc {
            0x82A1AF30 => {
    //   block [0x82A1AF30..0x82A1AF74)
	// 82A1AF30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1AF34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1AF38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1AF3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1AF40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1AF44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1AF48: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1AF4C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1AF50: 394B2A40  addi r10, r11, 0x2a40
	ctx.r[10].s64 = ctx.r[11].s64 + 10816;
	// 82A1AF54: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1AF58: 4B7E10B1  bl 0x821fc008
	ctx.lr = 0x82A1AF5C;
	sub_821FC008(ctx, base);
	// 82A1AF5C: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1AF60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1AF64: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1AF68: 419A000C  beq cr6, 0x82a1af74
	if ctx.cr[6].eq {
	pc = 0x82A1AF74; continue 'dispatch;
	}
	// 82A1AF6C: 4B800DCD  bl 0x8221bd38
	ctx.lr = 0x82A1AF70;
	sub_8221BD38(ctx, base);
	// 82A1AF70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1AF74; continue 'dispatch;
            }
            0x82A1AF74 => {
    //   block [0x82A1AF74..0x82A1AF8C)
	// 82A1AF74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1AF78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1AF7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1AF80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1AF84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1AF88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1AF90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1AF90 size=48
    let mut pc: u32 = 0x82A1AF90;
    'dispatch: loop {
        match pc {
            0x82A1AF90 => {
    //   block [0x82A1AF90..0x82A1AFC0)
	// 82A1AF90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1AF94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1AF98: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1AF9C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1AFA0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1AFA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A1AFA8: 4E800421  bctrl
	ctx.lr = 0x82A1AFAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1AFAC: 38630034  addi r3, r3, 0x34
	ctx.r[3].s64 = ctx.r[3].s64 + 52;
	// 82A1AFB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A1AFB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1AFB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1AFBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1AFC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A1AFC0 size=1112
    let mut pc: u32 = 0x82A1AFC0;
    'dispatch: loop {
        match pc {
            0x82A1AFC0 => {
    //   block [0x82A1AFC0..0x82A1AFE0)
	// 82A1AFC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1AFC4: 4828E40D  bl 0x82ca93d0
	ctx.lr = 0x82A1AFC8;
	sub_82CA93D0(ctx, base);
	// 82A1AFC8: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82A1AFCC: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82A1AFD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A1AFD4: 394A6DDC  addi r10, r10, 0x6ddc
	ctx.r[10].s64 = ctx.r[10].s64 + 28124;
	// 82A1AFD8: 39200100  li r9, 0x100
	ctx.r[9].s64 = 256;
	// 82A1AFDC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x82A1AFE0; continue 'dispatch;
            }
            0x82A1AFE0 => {
    //   block [0x82A1AFE0..0x82A1B418)
	// 82A1AFE0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1AFE4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A1AFE8: 4200FFF8  bdnz 0x82a1afe0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A1AFE0; continue 'dispatch;
	}
	// 82A1AFEC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A1AFF0: 91430080  stw r10, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 82A1AFF4: 396B8DEC  addi r11, r11, -0x7214
	ctx.r[11].s64 = ctx.r[11].s64 + -29204;
	// 82A1AFF8: 394BF7B4  addi r10, r11, -0x84c
	ctx.r[10].s64 = ctx.r[11].s64 + -2124;
	// 82A1AFFC: 9161FEF0  stw r11, -0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-272 as u32), ctx.r[11].u32 ) };
	// 82A1B000: 392BF7B4  addi r9, r11, -0x84c
	ctx.r[9].s64 = ctx.r[11].s64 + -2124;
	// 82A1B004: 390BF7D8  addi r8, r11, -0x828
	ctx.r[8].s64 = ctx.r[11].s64 + -2088;
	// 82A1B008: 91430184  stw r10, 0x184(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(388 as u32), ctx.r[10].u32 ) };
	// 82A1B00C: 38EBF7D8  addi r7, r11, -0x828
	ctx.r[7].s64 = ctx.r[11].s64 + -2088;
	// 82A1B010: 91230104  stw r9, 0x104(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(260 as u32), ctx.r[9].u32 ) };
	// 82A1B014: 38CBF7FC  addi r6, r11, -0x804
	ctx.r[6].s64 = ctx.r[11].s64 + -2052;
	// 82A1B018: 91030188  stw r8, 0x188(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(392 as u32), ctx.r[8].u32 ) };
	// 82A1B01C: 90E30108  stw r7, 0x108(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(264 as u32), ctx.r[7].u32 ) };
	// 82A1B020: 38ABF7FC  addi r5, r11, -0x804
	ctx.r[5].s64 = ctx.r[11].s64 + -2052;
	// 82A1B024: 90C3018C  stw r6, 0x18c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(396 as u32), ctx.r[6].u32 ) };
	// 82A1B028: 388BF820  addi r4, r11, -0x7e0
	ctx.r[4].s64 = ctx.r[11].s64 + -2016;
	// 82A1B02C: 394BF820  addi r10, r11, -0x7e0
	ctx.r[10].s64 = ctx.r[11].s64 + -2016;
	// 82A1B030: 90A3010C  stw r5, 0x10c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(268 as u32), ctx.r[5].u32 ) };
	// 82A1B034: 392BF844  addi r9, r11, -0x7bc
	ctx.r[9].s64 = ctx.r[11].s64 + -1980;
	// 82A1B038: 90830190  stw r4, 0x190(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(400 as u32), ctx.r[4].u32 ) };
	// 82A1B03C: 390BF844  addi r8, r11, -0x7bc
	ctx.r[8].s64 = ctx.r[11].s64 + -1980;
	// 82A1B040: 91430110  stw r10, 0x110(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(272 as u32), ctx.r[10].u32 ) };
	// 82A1B044: 38EBF868  addi r7, r11, -0x798
	ctx.r[7].s64 = ctx.r[11].s64 + -1944;
	// 82A1B048: 91230194  stw r9, 0x194(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(404 as u32), ctx.r[9].u32 ) };
	// 82A1B04C: 38CBF868  addi r6, r11, -0x798
	ctx.r[6].s64 = ctx.r[11].s64 + -1944;
	// 82A1B050: 91030114  stw r8, 0x114(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(276 as u32), ctx.r[8].u32 ) };
	// 82A1B054: 90E30198  stw r7, 0x198(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(408 as u32), ctx.r[7].u32 ) };
	// 82A1B058: 38ABF88C  addi r5, r11, -0x774
	ctx.r[5].s64 = ctx.r[11].s64 + -1908;
	// 82A1B05C: 90C30118  stw r6, 0x118(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(280 as u32), ctx.r[6].u32 ) };
	// 82A1B060: 388BF88C  addi r4, r11, -0x774
	ctx.r[4].s64 = ctx.r[11].s64 + -1908;
	// 82A1B064: 394BF8B0  addi r10, r11, -0x750
	ctx.r[10].s64 = ctx.r[11].s64 + -1872;
	// 82A1B068: 90A3019C  stw r5, 0x19c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(412 as u32), ctx.r[5].u32 ) };
	// 82A1B06C: 392BF8B0  addi r9, r11, -0x750
	ctx.r[9].s64 = ctx.r[11].s64 + -1872;
	// 82A1B070: 9083011C  stw r4, 0x11c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(284 as u32), ctx.r[4].u32 ) };
	// 82A1B074: 390BF8D4  addi r8, r11, -0x72c
	ctx.r[8].s64 = ctx.r[11].s64 + -1836;
	// 82A1B078: 914301A0  stw r10, 0x1a0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(416 as u32), ctx.r[10].u32 ) };
	// 82A1B07C: 38EBF8D4  addi r7, r11, -0x72c
	ctx.r[7].s64 = ctx.r[11].s64 + -1836;
	// 82A1B080: 91230120  stw r9, 0x120(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(288 as u32), ctx.r[9].u32 ) };
	// 82A1B084: 38CBF8F8  addi r6, r11, -0x708
	ctx.r[6].s64 = ctx.r[11].s64 + -1800;
	// 82A1B088: 910301A4  stw r8, 0x1a4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(420 as u32), ctx.r[8].u32 ) };
	// 82A1B08C: 90E30124  stw r7, 0x124(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(292 as u32), ctx.r[7].u32 ) };
	// 82A1B090: 38ABF8F8  addi r5, r11, -0x708
	ctx.r[5].s64 = ctx.r[11].s64 + -1800;
	// 82A1B094: 90C301A8  stw r6, 0x1a8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(424 as u32), ctx.r[6].u32 ) };
	// 82A1B098: 388BF91C  addi r4, r11, -0x6e4
	ctx.r[4].s64 = ctx.r[11].s64 + -1764;
	// 82A1B09C: 394BF91C  addi r10, r11, -0x6e4
	ctx.r[10].s64 = ctx.r[11].s64 + -1764;
	// 82A1B0A0: 90A30128  stw r5, 0x128(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(296 as u32), ctx.r[5].u32 ) };
	// 82A1B0A4: 392BF940  addi r9, r11, -0x6c0
	ctx.r[9].s64 = ctx.r[11].s64 + -1728;
	// 82A1B0A8: 908301AC  stw r4, 0x1ac(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(428 as u32), ctx.r[4].u32 ) };
	// 82A1B0AC: 390BF940  addi r8, r11, -0x6c0
	ctx.r[8].s64 = ctx.r[11].s64 + -1728;
	// 82A1B0B0: 9143012C  stw r10, 0x12c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(300 as u32), ctx.r[10].u32 ) };
	// 82A1B0B4: 38EBF964  addi r7, r11, -0x69c
	ctx.r[7].s64 = ctx.r[11].s64 + -1692;
	// 82A1B0B8: 912301B0  stw r9, 0x1b0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(432 as u32), ctx.r[9].u32 ) };
	// 82A1B0BC: 38CBF988  addi r6, r11, -0x678
	ctx.r[6].s64 = ctx.r[11].s64 + -1656;
	// 82A1B0C0: 91030130  stw r8, 0x130(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(304 as u32), ctx.r[8].u32 ) };
	// 82A1B0C4: 90E301B4  stw r7, 0x1b4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(436 as u32), ctx.r[7].u32 ) };
	// 82A1B0C8: 38ABF964  addi r5, r11, -0x69c
	ctx.r[5].s64 = ctx.r[11].s64 + -1692;
	// 82A1B0CC: 90C1FEF4  stw r6, -0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-268 as u32), ctx.r[6].u32 ) };
	// 82A1B0D0: 388BF988  addi r4, r11, -0x678
	ctx.r[4].s64 = ctx.r[11].s64 + -1656;
	// 82A1B0D4: 394BF9AC  addi r10, r11, -0x654
	ctx.r[10].s64 = ctx.r[11].s64 + -1620;
	// 82A1B0D8: 392BF9AC  addi r9, r11, -0x654
	ctx.r[9].s64 = ctx.r[11].s64 + -1620;
	// 82A1B0DC: 390BF9D0  addi r8, r11, -0x630
	ctx.r[8].s64 = ctx.r[11].s64 + -1584;
	// 82A1B0E0: 38EBF9D0  addi r7, r11, -0x630
	ctx.r[7].s64 = ctx.r[11].s64 + -1584;
	// 82A1B0E4: 38CBF9F4  addi r6, r11, -0x60c
	ctx.r[6].s64 = ctx.r[11].s64 + -1548;
	// 82A1B0E8: 3BEBF9F4  addi r31, r11, -0x60c
	ctx.r[31].s64 = ctx.r[11].s64 + -1548;
	// 82A1B0EC: 3BCBFA18  addi r30, r11, -0x5e8
	ctx.r[30].s64 = ctx.r[11].s64 + -1512;
	// 82A1B0F0: 3BABFA18  addi r29, r11, -0x5e8
	ctx.r[29].s64 = ctx.r[11].s64 + -1512;
	// 82A1B0F4: 3B8BFA3C  addi r28, r11, -0x5c4
	ctx.r[28].s64 = ctx.r[11].s64 + -1476;
	// 82A1B0F8: 3B6BFA3C  addi r27, r11, -0x5c4
	ctx.r[27].s64 = ctx.r[11].s64 + -1476;
	// 82A1B0FC: 3B4BFA60  addi r26, r11, -0x5a0
	ctx.r[26].s64 = ctx.r[11].s64 + -1440;
	// 82A1B100: 3B2BFA60  addi r25, r11, -0x5a0
	ctx.r[25].s64 = ctx.r[11].s64 + -1440;
	// 82A1B104: 3B0BFA84  addi r24, r11, -0x57c
	ctx.r[24].s64 = ctx.r[11].s64 + -1404;
	// 82A1B108: 3AEBFA84  addi r23, r11, -0x57c
	ctx.r[23].s64 = ctx.r[11].s64 + -1404;
	// 82A1B10C: 3ACBFAA8  addi r22, r11, -0x558
	ctx.r[22].s64 = ctx.r[11].s64 + -1368;
	// 82A1B110: 3AABFAA8  addi r21, r11, -0x558
	ctx.r[21].s64 = ctx.r[11].s64 + -1368;
	// 82A1B114: 3A8BFACC  addi r20, r11, -0x534
	ctx.r[20].s64 = ctx.r[11].s64 + -1332;
	// 82A1B118: 3A6BFACC  addi r19, r11, -0x534
	ctx.r[19].s64 = ctx.r[11].s64 + -1332;
	// 82A1B11C: 3A4BFAF0  addi r18, r11, -0x510
	ctx.r[18].s64 = ctx.r[11].s64 + -1296;
	// 82A1B120: 3A2BFAF0  addi r17, r11, -0x510
	ctx.r[17].s64 = ctx.r[11].s64 + -1296;
	// 82A1B124: 3A0BFB14  addi r16, r11, -0x4ec
	ctx.r[16].s64 = ctx.r[11].s64 + -1260;
	// 82A1B128: 39EBFB14  addi r15, r11, -0x4ec
	ctx.r[15].s64 = ctx.r[11].s64 + -1260;
	// 82A1B12C: 556E003E  slwi r14, r11, 0
	ctx.r[14].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[14].u64 = ctx.r[14].u32 as u64;
	// 82A1B130: 91E1FF00  stw r15, -0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-256 as u32), ctx.r[15].u32 ) };
	// 82A1B134: 39EBFB38  addi r15, r11, -0x4c8
	ctx.r[15].s64 = ctx.r[11].s64 + -1224;
	// 82A1B138: 396BFB38  addi r11, r11, -0x4c8
	ctx.r[11].s64 = ctx.r[11].s64 + -1224;
	// 82A1B13C: 9201FEFC  stw r16, -0x104(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-260 as u32), ctx.r[16].u32 ) };
	// 82A1B140: 8201FEF0  lwz r16, -0x110(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-272 as u32) ) } as u64;
	// 82A1B144: 39CEFB5C  addi r14, r14, -0x4a4
	ctx.r[14].s64 = ctx.r[14].s64 + -1188;
	// 82A1B148: 91E1FF08  stw r15, -0xf8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-248 as u32), ctx.r[15].u32 ) };
	// 82A1B14C: 9161FF0C  stw r11, -0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-244 as u32), ctx.r[11].u32 ) };
	// 82A1B150: 81E1FEF4  lwz r15, -0x10c(r1)
	ctx.r[15].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-268 as u32) ) } as u64;
	// 82A1B154: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A1B158: 9221FEF8  stw r17, -0x108(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-264 as u32), ctx.r[17].u32 ) };
	// 82A1B15C: 5611003E  slwi r17, r16, 0
	ctx.r[17].u32 = ctx.r[16].u32.wrapping_shl(0);
	ctx.r[17].u64 = ctx.r[17].u32 as u64;
	// 82A1B160: 9241FEF4  stw r18, -0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-268 as u32), ctx.r[18].u32 ) };
	// 82A1B164: 5612003E  slwi r18, r16, 0
	ctx.r[18].u32 = ctx.r[16].u32.wrapping_shl(0);
	ctx.r[18].u64 = ctx.r[18].u32 as u64;
	// 82A1B168: 3A10FCA0  addi r16, r16, -0x360
	ctx.r[16].s64 = ctx.r[16].s64 + -864;
	// 82A1B16C: 90A30134  stw r5, 0x134(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(308 as u32), ctx.r[5].u32 ) };
	// 82A1B170: 3A31FB80  addi r17, r17, -0x480
	ctx.r[17].s64 = ctx.r[17].s64 + -1152;
	// 82A1B174: 908301B8  stw r4, 0x1b8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(440 as u32), ctx.r[4].u32 ) };
	// 82A1B178: 9201FF10  stw r16, -0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-240 as u32), ctx.r[16].u32 ) };
	// 82A1B17C: 3A52FBA4  addi r18, r18, -0x45c
	ctx.r[18].s64 = ctx.r[18].s64 + -1116;
	// 82A1B180: 8201FEF0  lwz r16, -0x110(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-272 as u32) ) } as u64;
	// 82A1B184: 9221FF14  stw r17, -0xec(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-236 as u32), ctx.r[17].u32 ) };
	// 82A1B188: 9241FF18  stw r18, -0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-232 as u32), ctx.r[18].u32 ) };
	// 82A1B18C: 5611003E  slwi r17, r16, 0
	ctx.r[17].u32 = ctx.r[16].u32.wrapping_shl(0);
	ctx.r[17].u64 = ctx.r[17].u32 as u64;
	// 82A1B190: 5612003E  slwi r18, r16, 0
	ctx.r[18].u32 = ctx.r[16].u32.wrapping_shl(0);
	ctx.r[18].u64 = ctx.r[18].u32 as u64;
	// 82A1B194: 3A10FBC8  addi r16, r16, -0x438
	ctx.r[16].s64 = ctx.r[16].s64 + -1080;
	// 82A1B198: 3A31FBEC  addi r17, r17, -0x414
	ctx.r[17].s64 = ctx.r[17].s64 + -1044;
	// 82A1B19C: 9201FF1C  stw r16, -0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-228 as u32), ctx.r[16].u32 ) };
	// 82A1B1A0: 3A52FC10  addi r18, r18, -0x3f0
	ctx.r[18].s64 = ctx.r[18].s64 + -1008;
	// 82A1B1A4: 8201FEF0  lwz r16, -0x110(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-272 as u32) ) } as u64;
	// 82A1B1A8: 9221FF20  stw r17, -0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-224 as u32), ctx.r[17].u32 ) };
	// 82A1B1AC: 9241FF24  stw r18, -0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-220 as u32), ctx.r[18].u32 ) };
	// 82A1B1B0: 5611003E  slwi r17, r16, 0
	ctx.r[17].u32 = ctx.r[16].u32.wrapping_shl(0);
	ctx.r[17].u64 = ctx.r[17].u32 as u64;
	// 82A1B1B4: 5612003E  slwi r18, r16, 0
	ctx.r[18].u32 = ctx.r[16].u32.wrapping_shl(0);
	ctx.r[18].u64 = ctx.r[18].u32 as u64;
	// 82A1B1B8: 3A10FC34  addi r16, r16, -0x3cc
	ctx.r[16].s64 = ctx.r[16].s64 + -972;
	// 82A1B1BC: 3A31FC58  addi r17, r17, -0x3a8
	ctx.r[17].s64 = ctx.r[17].s64 + -936;
	// 82A1B1C0: 9201FF28  stw r16, -0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-216 as u32), ctx.r[16].u32 ) };
	// 82A1B1C4: 3A52FC7C  addi r18, r18, -0x384
	ctx.r[18].s64 = ctx.r[18].s64 + -900;
	// 82A1B1C8: 8201FEF0  lwz r16, -0x110(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-272 as u32) ) } as u64;
	// 82A1B1CC: 9221FF2C  stw r17, -0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-212 as u32), ctx.r[17].u32 ) };
	// 82A1B1D0: 9241FF30  stw r18, -0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-208 as u32), ctx.r[18].u32 ) };
	// 82A1B1D4: 5611003E  slwi r17, r16, 0
	ctx.r[17].u32 = ctx.r[16].u32.wrapping_shl(0);
	ctx.r[17].u64 = ctx.r[17].u32 as u64;
	// 82A1B1D8: 5612003E  slwi r18, r16, 0
	ctx.r[18].u32 = ctx.r[16].u32.wrapping_shl(0);
	ctx.r[18].u64 = ctx.r[18].u32 as u64;
	// 82A1B1DC: 3A10FCE8  addi r16, r16, -0x318
	ctx.r[16].s64 = ctx.r[16].s64 + -792;
	// 82A1B1E0: 3A31FCC4  addi r17, r17, -0x33c
	ctx.r[17].s64 = ctx.r[17].s64 + -828;
	// 82A1B1E4: 9201FF34  stw r16, -0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-204 as u32), ctx.r[16].u32 ) };
	// 82A1B1E8: 3A52FD0C  addi r18, r18, -0x2f4
	ctx.r[18].s64 = ctx.r[18].s64 + -756;
	// 82A1B1EC: 8201FEF0  lwz r16, -0x110(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-272 as u32) ) } as u64;
	// 82A1B1F0: 9221FF38  stw r17, -0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-200 as u32), ctx.r[17].u32 ) };
	// 82A1B1F4: 9241FF3C  stw r18, -0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-196 as u32), ctx.r[18].u32 ) };
	// 82A1B1F8: 5611003E  slwi r17, r16, 0
	ctx.r[17].u32 = ctx.r[16].u32.wrapping_shl(0);
	ctx.r[17].u64 = ctx.r[17].u32 as u64;
	// 82A1B1FC: 5612003E  slwi r18, r16, 0
	ctx.r[18].u32 = ctx.r[16].u32.wrapping_shl(0);
	ctx.r[18].u64 = ctx.r[18].u32 as u64;
	// 82A1B200: 3A10FD30  addi r16, r16, -0x2d0
	ctx.r[16].s64 = ctx.r[16].s64 + -720;
	// 82A1B204: 3A31FD54  addi r17, r17, -0x2ac
	ctx.r[17].s64 = ctx.r[17].s64 + -684;
	// 82A1B208: 9201FF40  stw r16, -0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-192 as u32), ctx.r[16].u32 ) };
	// 82A1B20C: 3A52FD78  addi r18, r18, -0x288
	ctx.r[18].s64 = ctx.r[18].s64 + -648;
	// 82A1B210: 8201FEF0  lwz r16, -0x110(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-272 as u32) ) } as u64;
	// 82A1B214: 9221FF44  stw r17, -0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-188 as u32), ctx.r[17].u32 ) };
	// 82A1B218: 9241FF48  stw r18, -0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-184 as u32), ctx.r[18].u32 ) };
	// 82A1B21C: 5611003E  slwi r17, r16, 0
	ctx.r[17].u32 = ctx.r[16].u32.wrapping_shl(0);
	ctx.r[17].u64 = ctx.r[17].u32 as u64;
	// 82A1B220: 5612003E  slwi r18, r16, 0
	ctx.r[18].u32 = ctx.r[16].u32.wrapping_shl(0);
	ctx.r[18].u64 = ctx.r[18].u32 as u64;
	// 82A1B224: 3A10FD9C  addi r16, r16, -0x264
	ctx.r[16].s64 = ctx.r[16].s64 + -612;
	// 82A1B228: 3A31FDC0  addi r17, r17, -0x240
	ctx.r[17].s64 = ctx.r[17].s64 + -576;
	// 82A1B22C: 9201FF4C  stw r16, -0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-180 as u32), ctx.r[16].u32 ) };
	// 82A1B230: 3A52FDE4  addi r18, r18, -0x21c
	ctx.r[18].s64 = ctx.r[18].s64 + -540;
	// 82A1B234: 8201FEF0  lwz r16, -0x110(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-272 as u32) ) } as u64;
	// 82A1B238: 9221FF50  stw r17, -0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.r[17].u32 ) };
	// 82A1B23C: 9241FF54  stw r18, -0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-172 as u32), ctx.r[18].u32 ) };
	// 82A1B240: 5611003E  slwi r17, r16, 0
	ctx.r[17].u32 = ctx.r[16].u32.wrapping_shl(0);
	ctx.r[17].u64 = ctx.r[17].u32 as u64;
	// 82A1B244: 5612003E  slwi r18, r16, 0
	ctx.r[18].u32 = ctx.r[16].u32.wrapping_shl(0);
	ctx.r[18].u64 = ctx.r[18].u32 as u64;
	// 82A1B248: 3A10FE08  addi r16, r16, -0x1f8
	ctx.r[16].s64 = ctx.r[16].s64 + -504;
	// 82A1B24C: 3A31FDE4  addi r17, r17, -0x21c
	ctx.r[17].s64 = ctx.r[17].s64 + -540;
	// 82A1B250: 9201FF58  stw r16, -0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.r[16].u32 ) };
	// 82A1B254: 3A52FE08  addi r18, r18, -0x1f8
	ctx.r[18].s64 = ctx.r[18].s64 + -504;
	// 82A1B258: 8201FEF0  lwz r16, -0x110(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-272 as u32) ) } as u64;
	// 82A1B25C: 9221FF5C  stw r17, -0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-164 as u32), ctx.r[17].u32 ) };
	// 82A1B260: 5611003E  slwi r17, r16, 0
	ctx.r[17].u32 = ctx.r[16].u32.wrapping_shl(0);
	ctx.r[17].u64 = ctx.r[17].u32 as u64;
	// 82A1B264: 9241FF60  stw r18, -0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[18].u32 ) };
	// 82A1B268: 5612003E  slwi r18, r16, 0
	ctx.r[18].u32 = ctx.r[16].u32.wrapping_shl(0);
	ctx.r[18].u64 = ctx.r[18].u32 as u64;
	// 82A1B26C: 3A10FE2C  addi r16, r16, -0x1d4
	ctx.r[16].s64 = ctx.r[16].s64 + -468;
	// 82A1B270: 38B1FE50  addi r5, r17, -0x1b0
	ctx.r[5].s64 = ctx.r[17].s64 + -432;
	// 82A1B274: 934B01D0  stw r26, 0x1d0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(464 as u32), ctx.r[26].u32 ) };
	// 82A1B278: 3892FEBC  addi r4, r18, -0x144
	ctx.r[4].s64 = ctx.r[18].s64 + -324;
	// 82A1B27C: 8341FF20  lwz r26, -0xe0(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-224 as u32) ) } as u64;
	// 82A1B280: 914B01BC  stw r10, 0x1bc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(444 as u32), ctx.r[10].u32 ) };
	// 82A1B284: 8141FEF4  lwz r10, -0x10c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-268 as u32) ) } as u64;
	// 82A1B288: 93EB0144  stw r31, 0x144(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(324 as u32), ctx.r[31].u32 ) };
	// 82A1B28C: 83E1FF08  lwz r31, -0xf8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-248 as u32) ) } as u64;
	// 82A1B290: 934B00D4  stw r26, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[26].u32 ) };
	// 82A1B294: 8341FF24  lwz r26, -0xdc(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-220 as u32) ) } as u64;
	// 82A1B298: 910B01C0  stw r8, 0x1c0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(448 as u32), ctx.r[8].u32 ) };
	// 82A1B29C: 8101FEFC  lwz r8, -0x104(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-260 as u32) ) } as u64;
	// 82A1B2A0: 90EB0140  stw r7, 0x140(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(320 as u32), ctx.r[7].u32 ) };
	// 82A1B2A4: 80E1FF00  lwz r7, -0x100(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-256 as u32) ) } as u64;
	// 82A1B2A8: 934B00D8  stw r26, 0xd8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(216 as u32), ctx.r[26].u32 ) };
	// 82A1B2AC: 8341FF28  lwz r26, -0xd8(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-216 as u32) ) } as u64;
	// 82A1B2B0: 914B01E0  stw r10, 0x1e0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(480 as u32), ctx.r[10].u32 ) };
	// 82A1B2B4: 8141FEF0  lwz r10, -0x110(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-272 as u32) ) } as u64;
	// 82A1B2B8: 912B013C  stw r9, 0x13c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(316 as u32), ctx.r[9].u32 ) };
	// 82A1B2BC: 93CB01C8  stw r30, 0x1c8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(456 as u32), ctx.r[30].u32 ) };
	// 82A1B2C0: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82A1B2C4: 934B00DC  stw r26, 0xdc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(220 as u32), ctx.r[26].u32 ) };
	// 82A1B2C8: 8341FF2C  lwz r26, -0xd4(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-212 as u32) ) } as u64;
	// 82A1B2CC: 93AB0148  stw r29, 0x148(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(328 as u32), ctx.r[29].u32 ) };
	// 82A1B2D0: 938B01CC  stw r28, 0x1cc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(460 as u32), ctx.r[28].u32 ) };
	// 82A1B2D4: 936B014C  stw r27, 0x14c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(332 as u32), ctx.r[27].u32 ) };
	// 82A1B2D8: 93EB01E8  stw r31, 0x1e8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(488 as u32), ctx.r[31].u32 ) };
	// 82A1B2DC: 934B00E0  stw r26, 0xe0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(224 as u32), ctx.r[26].u32 ) };
	// 82A1B2E0: 8341FF30  lwz r26, -0xd0(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-208 as u32) ) } as u64;
	// 82A1B2E4: 8121FEF8  lwz r9, -0x108(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-264 as u32) ) } as u64;
	// 82A1B2E8: 83E1FF0C  lwz r31, -0xf4(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-244 as u32) ) } as u64;
	// 82A1B2EC: 83C1FF10  lwz r30, -0xf0(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-240 as u32) ) } as u64;
	// 82A1B2F0: 83A1FF14  lwz r29, -0xec(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-236 as u32) ) } as u64;
	// 82A1B2F4: 934B00E4  stw r26, 0xe4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(228 as u32), ctx.r[26].u32 ) };
	// 82A1B2F8: 8341FF34  lwz r26, -0xcc(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-204 as u32) ) } as u64;
	// 82A1B2FC: 8381FF18  lwz r28, -0xe8(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-232 as u32) ) } as u64;
	// 82A1B300: 8361FF1C  lwz r27, -0xe4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-228 as u32) ) } as u64;
	// 82A1B304: 90CB01C4  stw r6, 0x1c4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(452 as u32), ctx.r[6].u32 ) };
	// 82A1B308: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 82A1B30C: 910B01E4  stw r8, 0x1e4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(484 as u32), ctx.r[8].u32 ) };
	// 82A1B310: 55C8003E  slwi r8, r14, 0
	ctx.r[8].u32 = ctx.r[14].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A1B314: 934B017C  stw r26, 0x17c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(380 as u32), ctx.r[26].u32 ) };
	// 82A1B318: 8341FF38  lwz r26, -0xc8(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-200 as u32) ) } as u64;
	// 82A1B31C: 90EB0164  stw r7, 0x164(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(356 as u32), ctx.r[7].u32 ) };
	// 82A1B320: 38E6FE74  addi r7, r6, -0x18c
	ctx.r[7].s64 = ctx.r[6].s64 + -396;
	// 82A1B324: 912B0160  stw r9, 0x160(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(352 as u32), ctx.r[9].u32 ) };
	// 82A1B328: 38C3FE98  addi r6, r3, -0x168
	ctx.r[6].s64 = ctx.r[3].s64 + -360;
	// 82A1B32C: 93EB0168  stw r31, 0x168(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(360 as u32), ctx.r[31].u32 ) };
	// 82A1B330: 392AFEE0  addi r9, r10, -0x120
	ctx.r[9].s64 = ctx.r[10].s64 + -288;
	// 82A1B334: 93CB00C0  stw r30, 0xc0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 82A1B338: 386AFF04  addi r3, r10, -0xfc
	ctx.r[3].s64 = ctx.r[10].s64 + -252;
	// 82A1B33C: 934B009C  stw r26, 0x9c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), ctx.r[26].u32 ) };
	// 82A1B340: 3BEAFF28  addi r31, r10, -0xd8
	ctx.r[31].s64 = ctx.r[10].s64 + -216;
	// 82A1B344: 8341FF3C  lwz r26, -0xc4(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-196 as u32) ) } as u64;
	// 82A1B348: 3BCAFF4C  addi r30, r10, -0xb4
	ctx.r[30].s64 = ctx.r[10].s64 + -180;
	// 82A1B34C: 93AB00C8  stw r29, 0xc8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(200 as u32), ctx.r[29].u32 ) };
	// 82A1B350: 3BAAFF70  addi r29, r10, -0x90
	ctx.r[29].s64 = ctx.r[10].s64 + -144;
	// 82A1B354: 910B00C4  stw r8, 0xc4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(196 as u32), ctx.r[8].u32 ) };
	// 82A1B358: 390AFF94  addi r8, r10, -0x6c
	ctx.r[8].s64 = ctx.r[10].s64 + -108;
	// 82A1B35C: 938B00CC  stw r28, 0xcc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(204 as u32), ctx.r[28].u32 ) };
	// 82A1B360: 3B8AFFB8  addi r28, r10, -0x48
	ctx.r[28].s64 = ctx.r[10].s64 + -72;
	// 82A1B364: 936B00D0  stw r27, 0xd0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), ctx.r[27].u32 ) };
	// 82A1B368: 3B6AFFDC  addi r27, r10, -0x24
	ctx.r[27].s64 = ctx.r[10].s64 + -36;
	// 82A1B36C: 934B00BC  stw r26, 0xbc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(188 as u32), ctx.r[26].u32 ) };
	// 82A1B370: 8341FF40  lwz r26, -0xc0(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-192 as u32) ) } as u64;
	// 82A1B374: 91C1FF04  stw r14, -0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-252 as u32), ctx.r[14].u32 ) };
	// 82A1B378: 91EB0138  stw r15, 0x138(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(312 as u32), ctx.r[15].u32 ) };
	// 82A1B37C: 932B0150  stw r25, 0x150(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(336 as u32), ctx.r[25].u32 ) };
	// 82A1B380: 930B01D4  stw r24, 0x1d4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(468 as u32), ctx.r[24].u32 ) };
	// 82A1B384: 934B0170  stw r26, 0x170(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(368 as u32), ctx.r[26].u32 ) };
	// 82A1B388: 8341FF44  lwz r26, -0xbc(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-188 as u32) ) } as u64;
	// 82A1B38C: 92EB0154  stw r23, 0x154(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(340 as u32), ctx.r[23].u32 ) };
	// 82A1B390: 92CB01D8  stw r22, 0x1d8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(472 as u32), ctx.r[22].u32 ) };
	// 82A1B394: 92AB0158  stw r21, 0x158(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(344 as u32), ctx.r[21].u32 ) };
	// 82A1B398: 928B01DC  stw r20, 0x1dc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(476 as u32), ctx.r[20].u32 ) };
	// 82A1B39C: 934B00B8  stw r26, 0xb8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), ctx.r[26].u32 ) };
	// 82A1B3A0: 8341FF48  lwz r26, -0xb8(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-184 as u32) ) } as u64;
	// 82A1B3A4: 926B015C  stw r19, 0x15c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(348 as u32), ctx.r[19].u32 ) };
	// 82A1B3A8: 934B00B0  stw r26, 0xb0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), ctx.r[26].u32 ) };
	// 82A1B3AC: 8341FF4C  lwz r26, -0xb4(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-180 as u32) ) } as u64;
	// 82A1B3B0: 934B00E8  stw r26, 0xe8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(232 as u32), ctx.r[26].u32 ) };
	// 82A1B3B4: 8341FF50  lwz r26, -0xb0(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-176 as u32) ) } as u64;
	// 82A1B3B8: 934B00EC  stw r26, 0xec(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(236 as u32), ctx.r[26].u32 ) };
	// 82A1B3BC: 8341FF54  lwz r26, -0xac(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-172 as u32) ) } as u64;
	// 82A1B3C0: 920B016C  stw r16, 0x16c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(364 as u32), ctx.r[16].u32 ) };
	// 82A1B3C4: 90AB0174  stw r5, 0x174(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(372 as u32), ctx.r[5].u32 ) };
	// 82A1B3C8: 908B0088  stw r4, 0x88(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[4].u32 ) };
	// 82A1B3CC: 90EB00B4  stw r7, 0xb4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(180 as u32), ctx.r[7].u32 ) };
	// 82A1B3D0: 934B00A0  stw r26, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[26].u32 ) };
	// 82A1B3D4: 8341FF58  lwz r26, -0xa8(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-168 as u32) ) } as u64;
	// 82A1B3D8: 90CB00AC  stw r6, 0xac(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(172 as u32), ctx.r[6].u32 ) };
	// 82A1B3DC: 914B0094  stw r10, 0x94(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 82A1B3E0: 912B00F4  stw r9, 0xf4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(244 as u32), ctx.r[9].u32 ) };
	// 82A1B3E4: 906B00F0  stw r3, 0xf0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), ctx.r[3].u32 ) };
	// 82A1B3E8: 934B00A4  stw r26, 0xa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), ctx.r[26].u32 ) };
	// 82A1B3EC: 8341FF5C  lwz r26, -0xa4(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-164 as u32) ) } as u64;
	// 82A1B3F0: 93EB00F8  stw r31, 0xf8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(248 as u32), ctx.r[31].u32 ) };
	// 82A1B3F4: 93CB0084  stw r30, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82A1B3F8: 93AB00FC  stw r29, 0xfc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(252 as u32), ctx.r[29].u32 ) };
	// 82A1B3FC: 910B01F0  stw r8, 0x1f0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(496 as u32), ctx.r[8].u32 ) };
	// 82A1B400: 934B01EC  stw r26, 0x1ec(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(492 as u32), ctx.r[26].u32 ) };
	// 82A1B404: 8341FF60  lwz r26, -0xa0(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) } as u64;
	// 82A1B408: 938B0098  stw r28, 0x98(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 82A1B40C: 936B00A8  stw r27, 0xa8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), ctx.r[27].u32 ) };
	// 82A1B410: 934B01F4  stw r26, 0x1f4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(500 as u32), ctx.r[26].u32 ) };
	// 82A1B414: 4828E00C  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1B418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1B418 size=328
    let mut pc: u32 = 0x82A1B418;
    'dispatch: loop {
        match pc {
            0x82A1B418 => {
    //   block [0x82A1B418..0x82A1B440)
	// 82A1B418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1B41C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1B420: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1B424: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1B428: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1B42C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1B430: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 82A1B434: 397F0015  addi r11, r31, 0x15
	ctx.r[11].s64 = ctx.r[31].s64 + 21;
	// 82A1B438: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A1B43C: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	pc = 0x82A1B440; continue 'dispatch;
            }
            0x82A1B440 => {
    //   block [0x82A1B440..0x82A1B4E0)
	// 82A1B440: 994B0001  stb r10, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[10].u8 ) };
	// 82A1B444: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82A1B448: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82A1B44C: 994BFFFF  stb r10, -1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-1 as u32), ctx.r[10].u8 ) };
	// 82A1B450: 992B0002  stb r9, 2(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[9].u8 ) };
	// 82A1B454: 994B0005  stb r10, 5(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(5 as u32), ctx.r[10].u8 ) };
	// 82A1B458: 994B0004  stb r10, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 82A1B45C: 994B0003  stb r10, 3(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(3 as u32), ctx.r[10].u8 ) };
	// 82A1B460: 992B0006  stb r9, 6(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[9].u8 ) };
	// 82A1B464: 994B0009  stb r10, 9(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(9 as u32), ctx.r[10].u8 ) };
	// 82A1B468: 994B0008  stb r10, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82A1B46C: 994B0007  stb r10, 7(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(7 as u32), ctx.r[10].u8 ) };
	// 82A1B470: 992B000A  stb r9, 0xa(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(10 as u32), ctx.r[9].u8 ) };
	// 82A1B474: 994B000D  stb r10, 0xd(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(13 as u32), ctx.r[10].u8 ) };
	// 82A1B478: 994B000C  stb r10, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u8 ) };
	// 82A1B47C: 994B000B  stb r10, 0xb(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(11 as u32), ctx.r[10].u8 ) };
	// 82A1B480: 992B000E  stb r9, 0xe(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(14 as u32), ctx.r[9].u8 ) };
	// 82A1B484: 994B0011  stb r10, 0x11(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(17 as u32), ctx.r[10].u8 ) };
	// 82A1B488: 994B0010  stb r10, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u8 ) };
	// 82A1B48C: 994B000F  stb r10, 0xf(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(15 as u32), ctx.r[10].u8 ) };
	// 82A1B490: 992B0012  stb r9, 0x12(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[9].u8 ) };
	// 82A1B494: 994B0015  stb r10, 0x15(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 82A1B498: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 82A1B49C: 994B0013  stb r10, 0x13(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(19 as u32), ctx.r[10].u8 ) };
	// 82A1B4A0: 992B0016  stb r9, 0x16(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(22 as u32), ctx.r[9].u8 ) };
	// 82A1B4A4: 396B002C  addi r11, r11, 0x2c
	ctx.r[11].s64 = ctx.r[11].s64 + 44;
	// 82A1B4A8: 4080FF98  bge 0x82a1b440
	if !ctx.cr[0].lt {
	pc = 0x82A1B440; continue 'dispatch;
	}
	// 82A1B4AC: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 82A1B4B0: 915F00DC  stw r10, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[10].u32 ) };
	// 82A1B4B4: 915F00E0  stw r10, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[10].u32 ) };
	// 82A1B4B8: 397F011A  addi r11, r31, 0x11a
	ctx.r[11].s64 = ctx.r[31].s64 + 282;
	// 82A1B4BC: 39092A30  addi r8, r9, 0x2a30
	ctx.r[8].s64 = ctx.r[9].s64 + 10800;
	// 82A1B4C0: 915F00E8  stw r10, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[10].u32 ) };
	// 82A1B4C4: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 82A1B4C8: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 82A1B4CC: 915F00EC  stw r10, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[10].u32 ) };
	// 82A1B4D0: 915F0104  stw r10, 0x104(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[10].u32 ) };
	// 82A1B4D4: 915F0108  stw r10, 0x108(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(264 as u32), ctx.r[10].u32 ) };
	// 82A1B4D8: 995F010C  stb r10, 0x10c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[10].u8 ) };
	// 82A1B4DC: 995F0128  stb r10, 0x128(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[10].u8 ) };
	pc = 0x82A1B4E0; continue 'dispatch;
            }
            0x82A1B4E0 => {
    //   block [0x82A1B4E0..0x82A1B528)
	// 82A1B4E0: B14BFFF8  sth r10, -8(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[10].u16 ) };
	// 82A1B4E4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A1B4E8: B14B0000  sth r10, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 82A1B4EC: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82A1B4F0: 4082FFF0  bne 0x82a1b4e0
	if !ctx.cr[0].eq {
	pc = 0x82A1B4E0; continue 'dispatch;
	}
	// 82A1B4F4: 38600400  li r3, 0x400
	ctx.r[3].s64 = 1024;
	// 82A1B4F8: 4B803DC9  bl 0x8221f2c0
	ctx.lr = 0x82A1B4FC;
	sub_8221F2C0(ctx, base);
	// 82A1B4FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1B500: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A1B504: 409A0028  bne cr6, 0x82a1b52c
	if !ctx.cr[6].eq {
	pc = 0x82A1B52C; continue 'dispatch;
	}
	// 82A1B508: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A1B50C: 814B6F6C  lwz r10, 0x6f6c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82A1B510: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1B514: 419A0014  beq cr6, 0x82a1b528
	if ctx.cr[6].eq {
	pc = 0x82A1B528; continue 'dispatch;
	}
	// 82A1B518: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1B51C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A1B520: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1B524: 4E800421  bctrl
	ctx.lr = 0x82A1B528;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A1B528 => {
    //   block [0x82A1B528..0x82A1B52C)
	// 82A1B528: 482A6E81  bl 0x82cc23a8
	ctx.lr = 0x82A1B52C;
	sub_82CC23A8(ctx, base);
	pc = 0x82A1B52C; continue 'dispatch;
            }
            0x82A1B52C => {
    //   block [0x82A1B52C..0x82A1B560)
	// 82A1B52C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1B530: 93DF0100  stw r30, 0x100(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[30].u32 ) };
	// 82A1B534: 4BFFFA8D  bl 0x82a1afc0
	ctx.lr = 0x82A1B538;
	sub_82A1AFC0(ctx, base);
	// 82A1B538: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A1B53C: 482A78DD  bl 0x82cc2e18
	ctx.lr = 0x82A1B540;
	sub_82CC2E18(ctx, base);
	// 82A1B540: 907F0124  stw r3, 0x124(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(292 as u32), ctx.r[3].u32 ) };
	// 82A1B544: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1B548: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1B54C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1B550: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1B554: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1B558: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1B55C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1B560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1B560 size=1304
    let mut pc: u32 = 0x82A1B560;
    'dispatch: loop {
        match pc {
            0x82A1B560 => {
    //   block [0x82A1B560..0x82A1B5D0)
	// 82A1B560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1B564: 4828DE6D  bl 0x82ca93d0
	ctx.lr = 0x82A1B568;
	sub_82CA93D0(ctx, base);
	// 82A1B568: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1B56C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1B570: 7C8E2378  mr r14, r4
	ctx.r[14].u64 = ctx.r[4].u64;
	// 82A1B574: 7CB22B78  mr r18, r5
	ctx.r[18].u64 = ctx.r[5].u64;
	// 82A1B578: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 82A1B57C: 4815380D  bl 0x82b6ed88
	ctx.lr = 0x82A1B580;
	sub_82B6ED88(ctx, base);
	// 82A1B580: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1B584: 4B803785  bl 0x8221ed08
	ctx.lr = 0x82A1B588;
	sub_8221ED08(ctx, base);
	// 82A1B588: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A1B58C: 7D5E1850  subf r10, r30, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[30].s64;
	// 82A1B590: 39EB5E3C  addi r15, r11, 0x5e3c
	ctx.r[15].s64 = ctx.r[11].s64 + 24124;
	// 82A1B594: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82A1B598: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 82A1B59C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A1B5A0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1B5A4: 553CDFFE  rlwinm r28, r9, 0x1b, 0x1f, 0x1f
	ctx.r[28].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 82A1B5A8: 4B7E51C9  bl 0x82200770
	ctx.lr = 0x82A1B5AC;
	sub_82200770(ctx, base);
	// 82A1B5AC: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 82A1B5B0: 88C10074  lbz r6, 0x74(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1B5B4: 39685E58  addi r11, r8, 0x5e58
	ctx.r[11].s64 = ctx.r[8].s64 + 24152;
	// 82A1B5B8: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82A1B5BC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1B5C0: 7FD458AE  lbzx r30, r20, r11
	ctx.r[30].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A1B5C4: 419A000C  beq cr6, 0x82a1b5d0
	if ctx.cr[6].eq {
	pc = 0x82A1B5D0; continue 'dispatch;
	}
	// 82A1B5C8: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A1B5CC: 4889E389  bl 0x832b9954
	ctx.lr = 0x82A1B5D0;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x82A1B5D0; continue 'dispatch;
            }
            0x82A1B5D0 => {
    //   block [0x82A1B5D0..0x82A1B5EC)
	// 82A1B5D0: 9BDF010E  stb r30, 0x10e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(270 as u32), ctx.r[30].u8 ) };
	// 82A1B5D4: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 82A1B5D8: 48122791  bl 0x82b3dd68
	ctx.lr = 0x82A1B5DC;
	sub_82B3DD68(ctx, base);
	// 82A1B5DC: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82A1B5E0: 987F010F  stb r3, 0x10f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(271 as u32), ctx.r[3].u8 ) };
	// 82A1B5E4: 3BBF011A  addi r29, r31, 0x11a
	ctx.r[29].s64 = ctx.r[31].s64 + 282;
	// 82A1B5E8: 7EDEB378  mr r30, r22
	ctx.r[30].u64 = ctx.r[22].u64;
	pc = 0x82A1B5EC; continue 'dispatch;
            }
            0x82A1B5EC => {
    //   block [0x82A1B5EC..0x82A1B614)
	// 82A1B5EC: B2DDFFF8  sth r22, -8(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(-8 as u32), ctx.r[22].u16 ) };
	// 82A1B5F0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A1B5F4: B2DD0000  sth r22, 0(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[22].u16 ) };
	// 82A1B5F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1B5FC: 4B89792D  bl 0x822b2f28
	ctx.lr = 0x82A1B600;
	sub_822B2F28(ctx, base);
	// 82A1B600: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1B604: 409A0010  bne cr6, 0x82a1b614
	if !ctx.cr[6].eq {
	pc = 0x82A1B614; continue 'dispatch;
	}
	// 82A1B608: A1610074  lhz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1B60C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1B610: 409A0018  bne cr6, 0x82a1b628
	if !ctx.cr[6].eq {
	pc = 0x82A1B628; continue 'dispatch;
	}
	pc = 0x82A1B614; continue 'dispatch;
            }
            0x82A1B614 => {
    //   block [0x82A1B614..0x82A1B628)
	// 82A1B614: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82A1B618: 3BBD0002  addi r29, r29, 2
	ctx.r[29].s64 = ctx.r[29].s64 + 2;
	// 82A1B61C: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 82A1B620: 4198FFCC  blt cr6, 0x82a1b5ec
	if ctx.cr[6].lt {
	pc = 0x82A1B5EC; continue 'dispatch;
	}
	// 82A1B624: 48000010  b 0x82a1b634
	pc = 0x82A1B634; continue 'dispatch;
            }
            0x82A1B628 => {
    //   block [0x82A1B628..0x82A1B634)
	// 82A1B628: 395E008D  addi r10, r30, 0x8d
	ctx.r[10].s64 = ctx.r[30].s64 + 141;
	// 82A1B62C: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A1B630: 7D69FB2E  sthx r11, r9, r31
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u16) };
	pc = 0x82A1B634; continue 'dispatch;
            }
            0x82A1B634 => {
    //   block [0x82A1B634..0x82A1B670)
	// 82A1B634: 5790063E  clrlwi r16, r28, 0x18
	ctx.r[16].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82A1B638: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A1B63C: 3E208336  lis r17, -0x7cca
	ctx.r[17].s64 = -2093613056;
	// 82A1B640: 2B100000  cmplwi cr6, r16, 0
	ctx.cr[6].compare_u32(ctx.r[16].u32, 0 as u32, &mut ctx.xer);
	// 82A1B644: 3A6B5FF0  addi r19, r11, 0x5ff0
	ctx.r[19].s64 = ctx.r[11].s64 + 24560;
	// 82A1B648: 409A007C  bne cr6, 0x82a1b6c4
	if !ctx.cr[6].eq {
	pc = 0x82A1B6C4; continue 'dispatch;
	}
	// 82A1B64C: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82A1B650: 4889E315  bl 0x832b9964
	ctx.lr = 0x82A1B654;
	// extern call 0x832B9964  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82A1B654: 4B8036B5  bl 0x8221ed08
	ctx.lr = 0x82A1B658;
	sub_8221ED08(ctx, base);
	// 82A1B658: 3FC08336  lis r30, -0x7cca
	ctx.r[30].s64 = -2093613056;
	// 82A1B65C: 817E0354  lwz r11, 0x354(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(852 as u32) ) } as u64;
	// 82A1B660: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A1B664: 419A000C  beq cr6, 0x82a1b670
	if ctx.cr[6].eq {
	pc = 0x82A1B670; continue 'dispatch;
	}
	// 82A1B668: 4B8036A1  bl 0x8221ed08
	ctx.lr = 0x82A1B66C;
	sub_8221ED08(ctx, base);
	// 82A1B66C: 90710350  stw r3, 0x350(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(848 as u32), ctx.r[3].u32 ) };
	pc = 0x82A1B670; continue 'dispatch;
            }
            0x82A1B670 => {
    //   block [0x82A1B670..0x82A1B678)
	// 82A1B670: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82A1B674: 4889E2E1  bl 0x832b9954
	ctx.lr = 0x82A1B678;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x82A1B678; continue 'dispatch;
            }
            0x82A1B678 => {
    //   block [0x82A1B678..0x82A1B6A0)
	// 82A1B678: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82A1B67C: 4889E2E9  bl 0x832b9964
	ctx.lr = 0x82A1B680;
	// extern call 0x832B9964  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82A1B680: 4B803689  bl 0x8221ed08
	ctx.lr = 0x82A1B684;
	sub_8221ED08(ctx, base);
	// 82A1B684: 81710350  lwz r11, 0x350(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(848 as u32) ) } as u64;
	// 82A1B688: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A1B68C: 409A0014  bne cr6, 0x82a1b6a0
	if !ctx.cr[6].eq {
	pc = 0x82A1B6A0; continue 'dispatch;
	}
	// 82A1B690: 817E0354  lwz r11, 0x354(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(852 as u32) ) } as u64;
	// 82A1B694: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82A1B698: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A1B69C: 419A0008  beq cr6, 0x82a1b6a4
	if ctx.cr[6].eq {
	pc = 0x82A1B6A4; continue 'dispatch;
	}
	pc = 0x82A1B6A0; continue 'dispatch;
            }
            0x82A1B6A0 => {
    //   block [0x82A1B6A0..0x82A1B6A4)
	// 82A1B6A0: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x82A1B6A4; continue 'dispatch;
            }
            0x82A1B6A4 => {
    //   block [0x82A1B6A4..0x82A1B6C0)
	// 82A1B6A4: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82A1B6A8: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A1B6AC: 4889E2A9  bl 0x832b9954
	ctx.lr = 0x82A1B6B0;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82A1B6B0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A1B6B4: 409A000C  bne cr6, 0x82a1b6c0
	if !ctx.cr[6].eq {
	pc = 0x82A1B6C0; continue 'dispatch;
	}
	// 82A1B6B8: 482A8231  bl 0x82cc38e8
	ctx.lr = 0x82A1B6BC;
	sub_82CC38E8(ctx, base);
	// 82A1B6BC: 4BFFFFBC  b 0x82a1b678
	pc = 0x82A1B678; continue 'dispatch;
            }
            0x82A1B6C0 => {
    //   block [0x82A1B6C0..0x82A1B6C4)
	// 82A1B6C0: 48153651  bl 0x82b6ed10
	ctx.lr = 0x82A1B6C4;
	sub_82B6ED10(ctx, base);
	pc = 0x82A1B6C4; continue 'dispatch;
            }
            0x82A1B6C4 => {
    //   block [0x82A1B6C4..0x82A1B710)
	// 82A1B6C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1B6C8: 480003B1  bl 0x82a1ba78
	ctx.lr = 0x82A1B6CC;
	sub_82A1BA78(ctx, base);
	// 82A1B6CC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82A1B6D0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A1B6D4: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 82A1B6D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A1B6DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1B6E0: 4B8117F1  bl 0x8222ced0
	ctx.lr = 0x82A1B6E4;
	sub_8222CED0(ctx, base);
	// 82A1B6E4: 1D74002C  mulli r11, r20, 0x2c
	ctx.r[11].s32 = ((ctx.r[20].s32 as i64 * 44 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A1B6E8: 7EABFA14  add r21, r11, r31
	ctx.r[21].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A1B6EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A1B6F0: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82A1B6F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1B6F8: 48000831  bl 0x82a1bf28
	ctx.lr = 0x82A1B6FC;
	sub_82A1BF28(ctx, base);
	// 82A1B6FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1B700: 4B7AB069  bl 0x821c6768
	ctx.lr = 0x82A1B704;
	sub_821C6768(ctx, base);
	// 82A1B704: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A1B708: 3AEB7088  addi r23, r11, 0x7088
	ctx.r[23].s64 = ctx.r[11].s64 + 28808;
	// 82A1B70C: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	pc = 0x82A1B710; continue 'dispatch;
            }
            0x82A1B710 => {
    //   block [0x82A1B710..0x82A1B748)
	// 82A1B710: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1B714: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1B718: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1B71C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A1B720: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1B724: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1B728: 4082FFE8  bne 0x82a1b710
	if !ctx.cr[0].eq {
	pc = 0x82A1B710; continue 'dispatch;
	}
	// 82A1B72C: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82A1B730: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 82A1B734: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A1B738: 3F40834C  lis r26, -0x7cb4
	ctx.r[26].s64 = -2092171264;
	// 82A1B73C: 3B8A2A40  addi r28, r10, 0x2a40
	ctx.r[28].s64 = ctx.r[10].s64 + 10816;
	// 82A1B740: 3B692A30  addi r27, r9, 0x2a30
	ctx.r[27].s64 = ctx.r[9].s64 + 10800;
	// 82A1B744: 3B2BB138  addi r25, r11, -0x4ec8
	ctx.r[25].s64 = ctx.r[11].s64 + -20168;
	pc = 0x82A1B748; continue 'dispatch;
            }
            0x82A1B748 => {
    //   block [0x82A1B748..0x82A1B77C)
	// 82A1B748: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A1B74C: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 82A1B750: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1B754: 4B81177D  bl 0x8222ced0
	ctx.lr = 0x82A1B758;
	sub_8222CED0(ctx, base);
	// 82A1B758: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82A1B75C: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 82A1B760: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1B764: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1B768: 48000669  bl 0x82a1bdd0
	ctx.lr = 0x82A1B76C;
	sub_82A1BDD0(ctx, base);
	// 82A1B76C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82A1B770: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1B774: 4B7AAFF5  bl 0x821c6768
	ctx.lr = 0x82A1B778;
	sub_821C6768(ctx, base);
	// 82A1B778: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	pc = 0x82A1B77C; continue 'dispatch;
            }
            0x82A1B77C => {
    //   block [0x82A1B77C..0x82A1B7F8)
	// 82A1B77C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A1B780: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1B784: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A1B788: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A1B78C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1B790: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1B794: 4082FFE8  bne 0x82a1b77c
	if !ctx.cr[0].eq {
	pc = 0x82A1B77C; continue 'dispatch;
	}
	// 82A1B798: 92C10050  stw r22, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[22].u32 ) };
	// 82A1B79C: 482A814D  bl 0x82cc38e8
	ctx.lr = 0x82A1B7A0;
	sub_82CC38E8(ctx, base);
	// 82A1B7A0: 92C10058  stw r22, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[22].u32 ) };
	// 82A1B7A4: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82A1B7A8: 92C1005C  stw r22, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[22].u32 ) };
	// 82A1B7AC: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82A1B7B0: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 82A1B7B4: 807F0124  lwz r3, 0x124(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(292 as u32) ) } as u64;
	// 82A1B7B8: 4889E15D  bl 0x832b9914
	ctx.lr = 0x82A1B7BC;
	// extern call 0x832B9914  crate::xboxkrnl::XNotifyGetNext
	crate::xboxkrnl::XNotifyGetNext(ctx, base);
	// 82A1B7BC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A1B7C0: 419A00A8  beq cr6, 0x82a1b868
	if ctx.cr[6].eq {
	pc = 0x82A1B868; continue 'dispatch;
	}
	// 82A1B7C4: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A1B7C8: 815F00E8  lwz r10, 0xe8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A1B7CC: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 82A1B7D0: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 82A1B7D4: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82A1B7D8: 98FF0128  stb r7, 0x128(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(296 as u32), ctx.r[7].u8 ) };
	// 82A1B7DC: 80CA0020  lwz r6, 0x20(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1B7E0: 81190004  lwz r8, 4(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1B7E4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A1B7E8: 54DE0026  rlwinm r30, r6, 0, 0, 0x13
	ctx.r[30].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1B7EC: 9101006C  stw r8, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[8].u32 ) };
	// 82A1B7F0: 419A0054  beq cr6, 0x82a1b844
	if ctx.cr[6].eq {
	pc = 0x82A1B844; continue 'dispatch;
	}
	// 82A1B7F4: 39680004  addi r11, r8, 4
	ctx.r[11].s64 = ctx.r[8].s64 + 4;
	pc = 0x82A1B7F8; continue 'dispatch;
            }
            0x82A1B7F8 => {
    //   block [0x82A1B7F8..0x82A1B844)
	// 82A1B7F8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1B7FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1B800: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1B804: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1B808: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1B80C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1B810: 4082FFE8  bne 0x82a1b7f8
	if !ctx.cr[0].eq {
	pc = 0x82A1B7F8; continue 'dispatch;
	}
	// 82A1B814: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A1B818: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A1B81C: 409A0028  bne cr6, 0x82a1b844
	if !ctx.cr[6].eq {
	pc = 0x82A1B844; continue 'dispatch;
	}
	// 82A1B820: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1B824: 556A073E  clrlwi r10, r11, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82A1B828: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 82A1B82C: 409A0018  bne cr6, 0x82a1b844
	if !ctx.cr[6].eq {
	pc = 0x82A1B844; continue 'dispatch;
	}
	// 82A1B830: 556B0042  rlwinm r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1B834: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1B838: 419A000C  beq cr6, 0x82a1b844
	if ctx.cr[6].eq {
	pc = 0x82A1B844; continue 'dispatch;
	}
	// 82A1B83C: 80680018  lwz r3, 0x18(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A1B840: 4B7E0939  bl 0x821fc178
	ctx.lr = 0x82A1B844;
	sub_821FC178(ctx, base);
	pc = 0x82A1B844; continue 'dispatch;
            }
            0x82A1B844 => {
    //   block [0x82A1B844..0x82A1B868)
	// 82A1B844: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 82A1B848: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1B84C: 81680020  lwz r11, 0x20(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1B850: 557D0026  rlwinm r29, r11, 0, 0, 0x13
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1B854: 4B7E07B5  bl 0x821fc008
	ctx.lr = 0x82A1B858;
	sub_821FC008(ctx, base);
	// 82A1B858: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82A1B85C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1B860: 4B7E07A9  bl 0x821fc008
	ctx.lr = 0x82A1B864;
	sub_821FC008(ctx, base);
	// 82A1B864: 480000F4  b 0x82a1b958
	pc = 0x82A1B958; continue 'dispatch;
            }
            0x82A1B868 => {
    //   block [0x82A1B868..0x82A1B888)
	// 82A1B868: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A1B86C: 81190004  lwz r8, 4(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1B870: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A1B874: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1B878: 91010074  stw r8, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[8].u32 ) };
	// 82A1B87C: 555D0026  rlwinm r29, r10, 0, 0, 0x13
	ctx.r[29].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1B880: 419A0054  beq cr6, 0x82a1b8d4
	if ctx.cr[6].eq {
	pc = 0x82A1B8D4; continue 'dispatch;
	}
	// 82A1B884: 39680004  addi r11, r8, 4
	ctx.r[11].s64 = ctx.r[8].s64 + 4;
	pc = 0x82A1B888; continue 'dispatch;
            }
            0x82A1B888 => {
    //   block [0x82A1B888..0x82A1B8D4)
	// 82A1B888: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1B88C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1B890: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1B894: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1B898: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1B89C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1B8A0: 4082FFE8  bne 0x82a1b888
	if !ctx.cr[0].eq {
	pc = 0x82A1B888; continue 'dispatch;
	}
	// 82A1B8A4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82A1B8A8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A1B8AC: 409A0028  bne cr6, 0x82a1b8d4
	if !ctx.cr[6].eq {
	pc = 0x82A1B8D4; continue 'dispatch;
	}
	// 82A1B8B0: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1B8B4: 556A073E  clrlwi r10, r11, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82A1B8B8: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 82A1B8BC: 409A0018  bne cr6, 0x82a1b8d4
	if !ctx.cr[6].eq {
	pc = 0x82A1B8D4; continue 'dispatch;
	}
	// 82A1B8C0: 556B0042  rlwinm r11, r11, 0, 1, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1B8C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1B8C8: 419A000C  beq cr6, 0x82a1b8d4
	if ctx.cr[6].eq {
	pc = 0x82A1B8D4; continue 'dispatch;
	}
	// 82A1B8CC: 80680018  lwz r3, 0x18(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A1B8D0: 4B7E08A9  bl 0x821fc178
	ctx.lr = 0x82A1B8D4;
	sub_821FC178(ctx, base);
	pc = 0x82A1B8D4; continue 'dispatch;
            }
            0x82A1B8D4 => {
    //   block [0x82A1B8D4..0x82A1B92C)
	// 82A1B8D4: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82A1B8D8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1B8DC: 81680020  lwz r11, 0x20(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1B8E0: 557E0026  rlwinm r30, r11, 0, 0, 0x13
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1B8E4: 4B7E0725  bl 0x821fc008
	ctx.lr = 0x82A1B8E8;
	sub_821FC008(ctx, base);
	// 82A1B8E8: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 82A1B8EC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1B8F0: 4B7E0719  bl 0x821fc008
	ctx.lr = 0x82A1B8F4;
	sub_821FC008(ctx, base);
	// 82A1B8F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1B8F8: 48000A21  bl 0x82a1c318
	ctx.lr = 0x82A1B8FC;
	sub_82A1C318(ctx, base);
	// 82A1B8FC: 817AEC40  lwz r11, -0x13c0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-5056 as u32) ) } as u64;
	// 82A1B900: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1B904: 1D6B24A1  mulli r11, r11, 0x24a1
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 9377 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A1B908: 394B24DF  addi r10, r11, 0x24df
	ctx.r[10].s64 = ctx.r[11].s64 + 9439;
	// 82A1B90C: 554B983E  rotlwi r11, r10, 0x13
	ctx.r[11].u64 = ((ctx.r[10].u32).rotate_left(19)) as u64;
	// 82A1B910: 917AEC40  stw r11, -0x13c0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(-5056 as u32), ctx.r[11].u32 ) };
	// 82A1B914: 419A0018  beq cr6, 0x82a1b92c
	if ctx.cr[6].eq {
	pc = 0x82A1B92C; continue 'dispatch;
	}
	// 82A1B918: 7D4B1B96  divwu r10, r11, r3
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[3].u32;
	// 82A1B91C: 0CC30000  twi 6, r3, 0
	// 82A1B920: 7D2A19D6  mullw r9, r10, r3
	ctx.r[9].s32 = ((ctx.r[10].s32 as i64 * ctx.r[3].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82A1B924: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A1B928: 48000008  b 0x82a1b930
	pc = 0x82A1B930; continue 'dispatch;
            }
            0x82A1B92C => {
    //   block [0x82A1B92C..0x82A1B930)
	// 82A1B92C: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x82A1B930; continue 'dispatch;
            }
            0x82A1B930 => {
    //   block [0x82A1B930..0x82A1B958)
	// 82A1B930: 7D5E58AE  lbzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A1B934: 7D2BE8AE  lbzx r9, r11, r29
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82A1B938: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1B93C: 419A0034  beq cr6, 0x82a1b970
	if ctx.cr[6].eq {
	pc = 0x82A1B970; continue 'dispatch;
	}
	// 82A1B940: 817F00E8  lwz r11, 0xe8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A1B944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1B948: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1B94C: 555E0026  rlwinm r30, r10, 0, 0, 0x13
	ctx.r[30].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1B950: 48000A81  bl 0x82a1c3d0
	ctx.lr = 0x82A1B954;
	sub_82A1C3D0(ctx, base);
	// 82A1B954: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	pc = 0x82A1B958; continue 'dispatch;
            }
            0x82A1B958 => {
    //   block [0x82A1B958..0x82A1B970)
	// 82A1B958: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1B95C: 480009BD  bl 0x82a1c318
	ctx.lr = 0x82A1B960;
	sub_82A1C318(ctx, base);
	// 82A1B960: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A1B964: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1B968: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1B96C: 4828DB15  bl 0x82ca9480
	ctx.lr = 0x82A1B970;
	sub_82CA9480(ctx, base);
	pc = 0x82A1B970; continue 'dispatch;
            }
            0x82A1B970 => {
    //   block [0x82A1B970..0x82A1B984)
	// 82A1B970: 897F0128  lbz r11, 0x128(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(296 as u32) ) } as u64;
	// 82A1B974: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1B978: 419A000C  beq cr6, 0x82a1b984
	if ctx.cr[6].eq {
	pc = 0x82A1B984; continue 'dispatch;
	}
	// 82A1B97C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A1B980: 481540C9  bl 0x82b6fa48
	ctx.lr = 0x82A1B984;
	sub_82B6FA48(ctx, base);
	pc = 0x82A1B984; continue 'dispatch;
            }
            0x82A1B984 => {
    //   block [0x82A1B984..0x82A1B9B0)
	// 82A1B984: 570B063E  clrlwi r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 82A1B988: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1B98C: 419AFDBC  beq cr6, 0x82a1b748
	if ctx.cr[6].eq {
	pc = 0x82A1B748; continue 'dispatch;
	}
	// 82A1B990: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 82A1B994: 8BDF010E  lbz r30, 0x10e(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(270 as u32) ) } as u64;
	// 82A1B998: 4889DFCD  bl 0x832b9964
	ctx.lr = 0x82A1B99C;
	// extern call 0x832B9964  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82A1B99C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A1B9A0: 894B6F71  lbz r10, 0x6f71(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28529 as u32) ) } as u64;
	// 82A1B9A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1B9A8: 409A0008  bne cr6, 0x82a1b9b0
	if !ctx.cr[6].eq {
	pc = 0x82A1B9B0; continue 'dispatch;
	}
	// 82A1B9AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A1B9B0; continue 'dispatch;
            }
            0x82A1B9B0 => {
    //   block [0x82A1B9B0..0x82A1B9E4)
	// 82A1B9B0: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A1B9B4: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 82A1B9B8: 7FD459AE  stbx r30, r20, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[20].u32.wrapping_add(ctx.r[11].u32), ctx.r[30].u8) };
	// 82A1B9BC: 4889DF99  bl 0x832b9954
	ctx.lr = 0x82A1B9C0;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 82A1B9C0: 895F010F  lbz r10, 0x10f(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(271 as u32) ) } as u64;
	// 82A1B9C4: 91C10058  stw r14, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[14].u32 ) };
	// 82A1B9C8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A1B9CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1B9D0: 419A0014  beq cr6, 0x82a1b9e4
	if ctx.cr[6].eq {
	pc = 0x82A1B9E4; continue 'dispatch;
	}
	// 82A1B9D4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A1B9D8: 386B5E60  addi r3, r11, 0x5e60
	ctx.r[3].s64 = ctx.r[11].s64 + 24160;
	// 82A1B9DC: 4BA3A265  bl 0x82455c40
	ctx.lr = 0x82A1B9E0;
	sub_82455C40(ctx, base);
	// 82A1B9E0: 48000014  b 0x82a1b9f4
	pc = 0x82A1B9F4; continue 'dispatch;
            }
            0x82A1B9E4 => {
    //   block [0x82A1B9E4..0x82A1B9F4)
	// 82A1B9E4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A1B9E8: 388B5E60  addi r4, r11, 0x5e60
	ctx.r[4].s64 = ctx.r[11].s64 + 24160;
	// 82A1B9EC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1B9F0: 4BC6C7A9  bl 0x82688198
	ctx.lr = 0x82A1B9F4;
	sub_82688198(ctx, base);
	pc = 0x82A1B9F4; continue 'dispatch;
            }
            0x82A1B9F4 => {
    //   block [0x82A1B9F4..0x82A1BA1C)
	// 82A1B9F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A1B9F8: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 82A1B9FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1BA00: 4B8114D1  bl 0x8222ced0
	ctx.lr = 0x82A1BA04;
	sub_8222CED0(ctx, base);
	// 82A1BA04: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A1BA08: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82A1BA0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1BA10: 480005A9  bl 0x82a1bfb8
	ctx.lr = 0x82A1BA14;
	sub_82A1BFB8(ctx, base);
	// 82A1BA14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1BA18: 4B7AAD51  bl 0x821c6768
	ctx.lr = 0x82A1BA1C;
	sub_821C6768(ctx, base);
	pc = 0x82A1BA1C; continue 'dispatch;
            }
            0x82A1BA1C => {
    //   block [0x82A1BA1C..0x82A1BA64)
	// 82A1BA1C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A1BA20: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1BA24: 7D60B828  lwarx r11, 0, r23
	// lwarx
	let ea = ctx.r[23].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A1BA28: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A1BA2C: 7D60B92D  stwcx. r11, 0, r23
	// stwcx.
	let addr = ctx.r[23].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1BA30: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1BA34: 4082FFE8  bne 0x82a1ba1c
	if !ctx.cr[0].eq {
	pc = 0x82A1BA1C; continue 'dispatch;
	}
	// 82A1BA38: 2B100000  cmplwi cr6, r16, 0
	ctx.cr[6].compare_u32(ctx.r[16].u32, 0 as u32, &mut ctx.xer);
	// 82A1BA3C: 409A0030  bne cr6, 0x82a1ba6c
	if !ctx.cr[6].eq {
	pc = 0x82A1BA6C; continue 'dispatch;
	}
	// 82A1BA40: 48153269  bl 0x82b6eca8
	ctx.lr = 0x82A1BA44;
	sub_82B6ECA8(ctx, base);
	// 82A1BA44: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82A1BA48: 4889DF1D  bl 0x832b9964
	ctx.lr = 0x82A1BA4C;
	// extern call 0x832B9964  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 82A1BA4C: 4B8032BD  bl 0x8221ed08
	ctx.lr = 0x82A1BA50;
	sub_8221ED08(ctx, base);
	// 82A1BA50: 81710350  lwz r11, 0x350(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(848 as u32) ) } as u64;
	// 82A1BA54: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A1BA58: 409A000C  bne cr6, 0x82a1ba64
	if !ctx.cr[6].eq {
	pc = 0x82A1BA64; continue 'dispatch;
	}
	// 82A1BA5C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82A1BA60: 91710350  stw r11, 0x350(r17)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[17].u32.wrapping_add(848 as u32), ctx.r[11].u32 ) };
	pc = 0x82A1BA64; continue 'dispatch;
            }
            0x82A1BA64 => {
    //   block [0x82A1BA64..0x82A1BA6C)
	// 82A1BA64: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 82A1BA68: 4889DEED  bl 0x832b9954
	ctx.lr = 0x82A1BA6C;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x82A1BA6C; continue 'dispatch;
            }
            0x82A1BA6C => {
    //   block [0x82A1BA6C..0x82A1BA78)
	// 82A1BA6C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A1BA70: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82A1BA74: 4828D9AC  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1BA78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1BA78 size=856
    let mut pc: u32 = 0x82A1BA78;
    'dispatch: loop {
        match pc {
            0x82A1BA78 => {
    //   block [0x82A1BA78..0x82A1BAD0)
	// 82A1BA78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1BA7C: 4828D975  bl 0x82ca93f0
	ctx.lr = 0x82A1BA80;
	sub_82CA93D0(ctx, base);
	// 82A1BA80: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1BA84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1BA88: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A1BA8C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A1BA90: 38EA5FE8  addi r7, r10, 0x5fe8
	ctx.r[7].s64 = ctx.r[10].s64 + 24552;
	// 82A1BA94: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82A1BA98: 893F010C  lbz r9, 0x10c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(268 as u32) ) } as u64;
	// 82A1BA9C: 814A5FE8  lwz r10, 0x5fe8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24552 as u32) ) } as u64;
	// 82A1BAA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1BAA4: 81270004  lwz r9, 4(r7)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1BAA8: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82A1BAAC: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 82A1BAB0: 419A0044  beq cr6, 0x82a1baf4
	if ctx.cr[6].eq {
	pc = 0x82A1BAF4; continue 'dispatch;
	}
	// 82A1BAB4: 80FF0104  lwz r7, 0x104(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A1BAB8: 7F0A3800  cmpw cr6, r10, r7
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82A1BABC: 409A0014  bne cr6, 0x82a1bad0
	if !ctx.cr[6].eq {
	pc = 0x82A1BAD0; continue 'dispatch;
	}
	// 82A1BAC0: 815F0108  lwz r10, 0x108(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 82A1BAC4: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A1BAC8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A1BACC: 419A0008  beq cr6, 0x82a1bad4
	if ctx.cr[6].eq {
	pc = 0x82A1BAD4; continue 'dispatch;
	}
	pc = 0x82A1BAD0; continue 'dispatch;
            }
            0x82A1BAD0 => {
    //   block [0x82A1BAD0..0x82A1BAD4)
	// 82A1BAD0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82A1BAD4; continue 'dispatch;
            }
            0x82A1BAD4 => {
    //   block [0x82A1BAD4..0x82A1BAF4)
	// 82A1BAD4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A1BAD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1BADC: 419A0018  beq cr6, 0x82a1baf4
	if ctx.cr[6].eq {
	pc = 0x82A1BAF4; continue 'dispatch;
	}
	// 82A1BAE0: 813F00EC  lwz r9, 0xec(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A1BAE4: 814B6068  lwz r10, 0x6068(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24680 as u32) ) } as u64;
	// 82A1BAE8: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82A1BAEC: 409A0008  bne cr6, 0x82a1baf4
	if !ctx.cr[6].eq {
	pc = 0x82A1BAF4; continue 'dispatch;
	}
	// 82A1BAF0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x82A1BAF4; continue 'dispatch;
            }
            0x82A1BAF4 => {
    //   block [0x82A1BAF4..0x82A1BDC8)
	// 82A1BAF4: 550A063E  clrlwi r10, r8, 0x18
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 82A1BAF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1BAFC: 419A02CC  beq cr6, 0x82a1bdc8
	if ctx.cr[6].eq {
	pc = 0x82A1BDC8; continue 'dispatch;
	}
	// 82A1BB00: E8E10070  ld r7, 0x70(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A1BB04: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A1BB08: 38DF00EC  addi r6, r31, 0xec
	ctx.r[6].s64 = ctx.r[31].s64 + 236;
	// 82A1BB0C: 98BF010C  stb r5, 0x10c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(268 as u32), ctx.r[5].u8 ) };
	// 82A1BB10: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A1BB14: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82A1BB18: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1BB1C: F8FF0104  std r7, 0x104(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(260 as u32), ctx.r[7].u64 ) };
	// 82A1BB20: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82A1BB24: 816B6068  lwz r11, 0x6068(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24680 as u32) ) } as u64;
	// 82A1BB28: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A1BB2C: 917F00EC  stw r11, 0xec(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82A1BB30: 387F00E4  addi r3, r31, 0xe4
	ctx.r[3].s64 = ctx.r[31].s64 + 228;
	// 82A1BB34: 48165FF5  bl 0x82b81b28
	ctx.lr = 0x82A1BB38;
	sub_82B81B28(ctx, base);
	// 82A1BB38: 3B4000C8  li r26, 0xc8
	ctx.r[26].s64 = 200;
	// 82A1BB3C: 3AC0001E  li r22, 0x1e
	ctx.r[22].s64 = 30;
	// 82A1BB40: 9AC10054  stb r22, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[22].u8 ) };
	// 82A1BB44: 3BC000FF  li r30, 0xff
	ctx.r[30].s64 = 255;
	// 82A1BB48: 93410068  stw r26, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[26].u32 ) };
	// 82A1BB4C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 82A1BB50: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A1BB54: 3B800014  li r28, 0x14
	ctx.r[28].s64 = 20;
	// 82A1BB58: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82A1BB5C: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 82A1BB60: 3AE00096  li r23, 0x96
	ctx.r[23].s64 = 150;
	// 82A1BB64: 9B410056  stb r26, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[26].u8 ) };
	// 82A1BB68: 3B600046  li r27, 0x46
	ctx.r[27].s64 = 70;
	// 82A1BB6C: 9AC10055  stb r22, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[22].u8 ) };
	// 82A1BB70: 3B00009B  li r24, 0x9b
	ctx.r[24].s64 = 155;
	// 82A1BB74: 9BC10057  stb r30, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[30].u8 ) };
	// 82A1BB78: 3BA00064  li r29, 0x64
	ctx.r[29].s64 = 100;
	// 82A1BB7C: 9BC10052  stb r30, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[30].u8 ) };
	// 82A1BB80: 39600019  li r11, 0x19
	ctx.r[11].s64 = 25;
	// 82A1BB84: 9AE10051  stb r23, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[23].u8 ) };
	// 82A1BB88: 3B3F002C  addi r25, r31, 0x2c
	ctx.r[25].s64 = ctx.r[31].s64 + 44;
	// 82A1BB8C: 9BC1005A  stb r30, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[30].u8 ) };
	// 82A1BB90: 387F0058  addi r3, r31, 0x58
	ctx.r[3].s64 = ctx.r[31].s64 + 88;
	// 82A1BB94: 9BC10059  stb r30, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[30].u8 ) };
	// 82A1BB98: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A1BB9C: 9BC1005E  stb r30, 0x5e(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(94 as u32), ctx.r[30].u8 ) };
	// 82A1BBA0: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82A1BBA4: 9B61005D  stb r27, 0x5d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(93 as u32), ctx.r[27].u8 ) };
	// 82A1BBA8: 9B010062  stb r24, 0x62(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[24].u8 ) };
	// 82A1BBAC: 9BC10053  stb r30, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[30].u8 ) };
	// 82A1BBB0: 9AE10050  stb r23, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u8 ) };
	// 82A1BBB4: 9BC10058  stb r30, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82A1BBB8: 9BC1005B  stb r30, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[30].u8 ) };
	// 82A1BBBC: 9B61005C  stb r27, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u8 ) };
	// 82A1BBC0: 9BC1005F  stb r30, 0x5f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(95 as u32), ctx.r[30].u8 ) };
	// 82A1BBC4: 9B810061  stb r28, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[28].u8 ) };
	// 82A1BBC8: 9B810060  stb r28, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u8 ) };
	// 82A1BBCC: E9210070  ld r9, 0x70(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A1BBD0: E9010068  ld r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A1BBD4: 9BC10063  stb r30, 0x63(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(99 as u32), ctx.r[30].u8 ) };
	// 82A1BBD8: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82A1BBDC: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A1BBE0: F93F0034  std r9, 0x34(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[9].u64 ) };
	// 82A1BBE4: F91F002C  std r8, 0x2c(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[8].u64 ) };
	// 82A1BBE8: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1BBEC: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A1BBF0: 90FF0040  stw r7, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[7].u32 ) };
	// 82A1BBF4: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A1BBF8: 80E10060  lwz r7, 0x60(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A1BBFC: 9BC10052  stb r30, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[30].u8 ) };
	// 82A1BC00: 9BA10051  stb r29, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[29].u8 ) };
	// 82A1BC04: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82A1BC08: 9BC10053  stb r30, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[30].u8 ) };
	// 82A1BC0C: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1BC10: 90DF0054  stw r6, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[6].u32 ) };
	// 82A1BC14: 913F0044  stw r9, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[9].u32 ) };
	// 82A1BC18: 915F004C  stw r10, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 82A1BC1C: 90FF0050  stw r7, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 82A1BC20: 911F0048  stw r8, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[8].u32 ) };
	// 82A1BC24: 4828D85D  bl 0x82ca9480
	ctx.lr = 0x82A1BC28;
	sub_82CA9480(ctx, base);
	// 82A1BC28: 387F0084  addi r3, r31, 0x84
	ctx.r[3].s64 = ctx.r[31].s64 + 132;
	// 82A1BC2C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A1BC30: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82A1BC34: 4828D84D  bl 0x82ca9480
	ctx.lr = 0x82A1BC38;
	sub_82CA9480(ctx, base);
	// 82A1BC38: 387F00B0  addi r3, r31, 0xb0
	ctx.r[3].s64 = ctx.r[31].s64 + 176;
	// 82A1BC3C: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82A1BC40: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A1BC44: 4828D83D  bl 0x82ca9480
	ctx.lr = 0x82A1BC48;
	sub_82CA9480(ctx, base);
	// 82A1BC48: 39600032  li r11, 0x32
	ctx.r[11].s64 = 50;
	// 82A1BC4C: 392000AA  li r9, 0xaa
	ctx.r[9].s64 = 170;
	// 82A1BC50: 9BA10062  stb r29, 0x62(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[29].u8 ) };
	// 82A1BC54: 99610056  stb r11, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[11].u8 ) };
	// 82A1BC58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1BC5C: 99610055  stb r11, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[11].u8 ) };
	// 82A1BC60: 394000F0  li r10, 0xf0
	ctx.r[10].s64 = 240;
	// 82A1BC64: 99610054  stb r11, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u8 ) };
	// 82A1BC68: 39600028  li r11, 0x28
	ctx.r[11].s64 = 40;
	// 82A1BC6C: 9921005E  stb r9, 0x5e(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(94 as u32), ctx.r[9].u8 ) };
	// 82A1BC70: 9921005D  stb r9, 0x5d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(93 as u32), ctx.r[9].u8 ) };
	// 82A1BC74: 9921005C  stb r9, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u8 ) };
	// 82A1BC78: 99610071  stb r11, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[11].u8 ) };
	// 82A1BC7C: 98C10065  stb r6, 0x65(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(101 as u32), ctx.r[6].u8 ) };
	// 82A1BC80: 9B410072  stb r26, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[26].u8 ) };
	// 82A1BC84: 9941005A  stb r10, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[10].u8 ) };
	// 82A1BC88: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 82A1BC8C: 99410058  stb r10, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u8 ) };
	// 82A1BC90: 3940008C  li r10, 0x8c
	ctx.r[10].s64 = 140;
	// 82A1BC94: 99610069  stb r11, 0x69(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(105 as u32), ctx.r[11].u8 ) };
	// 82A1BC98: 9941006A  stb r10, 0x6a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(106 as u32), ctx.r[10].u8 ) };
	// 82A1BC9C: 99410068  stb r10, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u8 ) };
	// 82A1BCA0: 9BA10061  stb r29, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[29].u8 ) };
	// 82A1BCA4: 9BA10060  stb r29, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u8 ) };
	// 82A1BCA8: 9BC10063  stb r30, 0x63(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(99 as u32), ctx.r[30].u8 ) };
	// 82A1BCAC: 9BC1005F  stb r30, 0x5f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(95 as u32), ctx.r[30].u8 ) };
	// 82A1BCB0: 9BC1006B  stb r30, 0x6b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(107 as u32), ctx.r[30].u8 ) };
	// 82A1BCB4: 80A10060  lwz r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A1BCB8: 9AE10066  stb r23, 0x66(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(102 as u32), ctx.r[23].u8 ) };
	// 82A1BCBC: 9AE10064  stb r23, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[23].u8 ) };
	// 82A1BCC0: 9BC10067  stb r30, 0x67(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(103 as u32), ctx.r[30].u8 ) };
	// 82A1BCC4: 9B410070  stb r26, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u8 ) };
	// 82A1BCC8: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A1BCCC: 9BC10073  stb r30, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[30].u8 ) };
	// 82A1BCD0: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1BCD4: 80E10070  lwz r7, 0x70(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A1BCD8: 9BC1005B  stb r30, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[30].u8 ) };
	// 82A1BCDC: 9BC10057  stb r30, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[30].u8 ) };
	// 82A1BCE0: 9BA10052  stb r29, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[29].u8 ) };
	// 82A1BCE4: 9BA10051  stb r29, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[29].u8 ) };
	// 82A1BCE8: 9BA10050  stb r29, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u8 ) };
	// 82A1BCEC: 9BC10053  stb r30, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[30].u8 ) };
	// 82A1BCF0: 9B010062  stb r24, 0x62(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[24].u8 ) };
	// 82A1BCF4: 9B810061  stb r28, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[28].u8 ) };
	// 82A1BCF8: 9B010060  stb r24, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u8 ) };
	// 82A1BCFC: 9BC10063  stb r30, 0x63(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(99 as u32), ctx.r[30].u8 ) };
	// 82A1BD00: 81010068  lwz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A1BD04: 9BA1006A  stb r29, 0x6a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(106 as u32), ctx.r[29].u8 ) };
	// 82A1BD08: 9B810069  stb r28, 0x69(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(105 as u32), ctx.r[28].u8 ) };
	// 82A1BD0C: 9BA10068  stb r29, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u8 ) };
	// 82A1BD10: 9BC1006B  stb r30, 0x6b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(107 as u32), ctx.r[30].u8 ) };
	// 82A1BD14: 9AC10072  stb r22, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[22].u8 ) };
	// 82A1BD18: 9AC10071  stb r22, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[22].u8 ) };
	// 82A1BD1C: 9B410070  stb r26, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u8 ) };
	// 82A1BD20: 9BC10073  stb r30, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[30].u8 ) };
	// 82A1BD24: 9B610066  stb r27, 0x66(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(102 as u32), ctx.r[27].u8 ) };
	// 82A1BD28: 9B610065  stb r27, 0x65(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(101 as u32), ctx.r[27].u8 ) };
	// 82A1BD2C: 9BC10064  stb r30, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u8 ) };
	// 82A1BD30: 9BC10067  stb r30, 0x67(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(103 as u32), ctx.r[30].u8 ) };
	// 82A1BD34: 9B61005E  stb r27, 0x5e(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(94 as u32), ctx.r[27].u8 ) };
	// 82A1BD38: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A1BD3C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A1BD40: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1BD44: 9B61005D  stb r27, 0x5d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(93 as u32), ctx.r[27].u8 ) };
	// 82A1BD48: 9BC1005C  stb r30, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u8 ) };
	// 82A1BD4C: 907F0078  stw r3, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 82A1BD50: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A1BD54: 90BF006C  stw r5, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[5].u32 ) };
	// 82A1BD58: 915F0080  stw r10, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 82A1BD5C: 9BC1005F  stb r30, 0x5f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(95 as u32), ctx.r[30].u8 ) };
	// 82A1BD60: 80C10060  lwz r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A1BD64: 80A10068  lwz r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A1BD68: 909F0074  stw r4, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[4].u32 ) };
	// 82A1BD6C: 911F00CC  stw r8, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[8].u32 ) };
	// 82A1BD70: 80810070  lwz r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A1BD74: 913F00C4  stw r9, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[9].u32 ) };
	// 82A1BD78: 90FF00D0  stw r7, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[7].u32 ) };
	// 82A1BD7C: 9BC1005B  stb r30, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[30].u8 ) };
	// 82A1BD80: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1BD84: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82A1BD88: 9B810071  stb r28, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[28].u8 ) };
	// 82A1BD8C: 9B010070  stb r24, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[24].u8 ) };
	// 82A1BD90: 9B810072  stb r28, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[28].u8 ) };
	// 82A1BD94: 9BA1005A  stb r29, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[29].u8 ) };
	// 82A1BD98: 9BA10059  stb r29, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[29].u8 ) };
	// 82A1BD9C: 9BC10058  stb r30, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82A1BDA0: 9BC10073  stb r30, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[30].u8 ) };
	// 82A1BDA4: 90DF00D4  stw r6, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[6].u32 ) };
	// 82A1BDA8: 90BF00D8  stw r5, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[5].u32 ) };
	// 82A1BDAC: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A1BDB0: 909F0098  stw r4, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[4].u32 ) };
	// 82A1BDB4: 907F00A0  stw r3, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[3].u32 ) };
	// 82A1BDB8: 917F00A4  stw r11, 0xa4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82A1BDBC: 913F00AC  stw r9, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[9].u32 ) };
	// 82A1BDC0: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A1BDC4: 915F00A8  stw r10, 0xa8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), ctx.r[10].u32 ) };
	pc = 0x82A1BDC8; continue 'dispatch;
            }
            0x82A1BDC8 => {
    //   block [0x82A1BDC8..0x82A1BDD0)
	// 82A1BDC8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A1BDCC: 4828D674  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1BDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1BDD0 size=340
    let mut pc: u32 = 0x82A1BDD0;
    'dispatch: loop {
        match pc {
            0x82A1BDD0 => {
    //   block [0x82A1BDD0..0x82A1BE04)
	// 82A1BDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1BDD4: 4828D61D  bl 0x82ca93f0
	ctx.lr = 0x82A1BDD8;
	sub_82CA93D0(ctx, base);
	// 82A1BDD8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1BDDC: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82A1BDE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1BDE4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82A1BDE8: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A1BDEC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82A1BDF0: 3BDF0112  addi r30, r31, 0x112
	ctx.r[30].s64 = ctx.r[31].s64 + 274;
	// 82A1BDF4: 7EDDB378  mr r29, r22
	ctx.r[29].u64 = ctx.r[22].u64;
	// 82A1BDF8: 7ED8B378  mr r24, r22
	ctx.r[24].u64 = ctx.r[22].u64;
	// 82A1BDFC: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 82A1BE00: 3AE00002  li r23, 2
	ctx.r[23].s64 = 2;
	pc = 0x82A1BE04; continue 'dispatch;
            }
            0x82A1BE04 => {
    //   block [0x82A1BE04..0x82A1BE4C)
	// 82A1BE04: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1BE08: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A1BE0C: 4B89711D  bl 0x822b2f28
	ctx.lr = 0x82A1BE10;
	sub_822B2F28(ctx, base);
	// 82A1BE10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1BE14: 409A00F4  bne cr6, 0x82a1bf08
	if !ctx.cr[6].eq {
	pc = 0x82A1BF08; continue 'dispatch;
	}
	// 82A1BE18: A1610054  lhz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A1BE1C: A15E0000  lhz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1BE20: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A1BE24: 419A00E4  beq cr6, 0x82a1bf08
	if ctx.cr[6].eq {
	pc = 0x82A1BF08; continue 'dispatch;
	}
	// 82A1BE28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1BE2C: 409A00D4  bne cr6, 0x82a1bf00
	if !ctx.cr[6].eq {
	pc = 0x82A1BF00; continue 'dispatch;
	}
	// 82A1BE30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1BE34: 419A00CC  beq cr6, 0x82a1bf00
	if ctx.cr[6].eq {
	pc = 0x82A1BF00; continue 'dispatch;
	}
	// 82A1BE38: A17E0008  lhz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1BE3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1BE40: 419A000C  beq cr6, 0x82a1be4c
	if ctx.cr[6].eq {
	pc = 0x82A1BE4C; continue 'dispatch;
	}
	// 82A1BE44: B2DE0008  sth r22, 8(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[22].u16 ) };
	// 82A1BE48: 480000B8  b 0x82a1bf00
	pc = 0x82A1BF00; continue 'dispatch;
            }
            0x82A1BE4C => {
    //   block [0x82A1BE4C..0x82A1BE7C)
	// 82A1BE4C: 554B04E6  rlwinm r11, r10, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1BE50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1BE54: 419A0028  beq cr6, 0x82a1be7c
	if ctx.cr[6].eq {
	pc = 0x82A1BE7C; continue 'dispatch;
	}
	// 82A1BE58: 895F010E  lbz r10, 0x10e(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(270 as u32) ) } as u64;
	// 82A1BE5C: 1D7A002C  mulli r11, r26, 0x2c
	ctx.r[11].s32 = ((ctx.r[26].s32 as i64 * 44 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A1BE60: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82A1BE64: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A1BE68: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 82A1BE6C: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A1BE70: 991F010E  stb r8, 0x10e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(270 as u32), ctx.r[8].u8 ) };
	// 82A1BE74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1BE78: 480000B1  bl 0x82a1bf28
	ctx.lr = 0x82A1BE7C;
	sub_82A1BF28(ctx, base);
	pc = 0x82A1BE7C; continue 'dispatch;
            }
            0x82A1BE7C => {
    //   block [0x82A1BE7C..0x82A1BEB0)
	// 82A1BE7C: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1BE80: 556A04A4  rlwinm r10, r11, 0, 0x12, 0x12
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1BE84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1BE88: 419A0028  beq cr6, 0x82a1beb0
	if ctx.cr[6].eq {
	pc = 0x82A1BEB0; continue 'dispatch;
	}
	// 82A1BE8C: 895F010F  lbz r10, 0x10f(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(271 as u32) ) } as u64;
	// 82A1BE90: 1D7A002C  mulli r11, r26, 0x2c
	ctx.r[11].s32 = ((ctx.r[26].s32 as i64 * 44 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82A1BE94: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82A1BE98: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A1BE9C: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 82A1BEA0: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82A1BEA4: 991F010F  stb r8, 0x10f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(271 as u32), ctx.r[8].u8 ) };
	// 82A1BEA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1BEAC: 4800007D  bl 0x82a1bf28
	ctx.lr = 0x82A1BEB0;
	sub_82A1BF28(ctx, base);
	pc = 0x82A1BEB0; continue 'dispatch;
            }
            0x82A1BEB0 => {
    //   block [0x82A1BEB0..0x82A1BEC8)
	// 82A1BEB0: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1BEB4: 556A0020  rlwinm r10, r11, 0, 0, 0x10
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1BEB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1BEBC: 419A000C  beq cr6, 0x82a1bec8
	if ctx.cr[6].eq {
	pc = 0x82A1BEC8; continue 'dispatch;
	}
	// 82A1BEC0: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82A1BEC4: 933C0000  stw r25, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	pc = 0x82A1BEC8; continue 'dispatch;
            }
            0x82A1BEC8 => {
    //   block [0x82A1BEC8..0x82A1BEDC)
	// 82A1BEC8: 556A06B4  rlwinm r10, r11, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1BECC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1BED0: 419A000C  beq cr6, 0x82a1bedc
	if ctx.cr[6].eq {
	pc = 0x82A1BEDC; continue 'dispatch;
	}
	// 82A1BED4: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82A1BED8: 92FC0000  stw r23, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[23].u32 ) };
	pc = 0x82A1BEDC; continue 'dispatch;
            }
            0x82A1BEDC => {
    //   block [0x82A1BEDC..0x82A1BF00)
	// 82A1BEDC: 556B06F6  rlwinm r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1BEE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1BEE4: 419A001C  beq cr6, 0x82a1bf00
	if ctx.cr[6].eq {
	pc = 0x82A1BF00; continue 'dispatch;
	}
	// 82A1BEE8: 897F010F  lbz r11, 0x10f(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(271 as u32) ) } as u64;
	// 82A1BEEC: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82A1BEF0: 933C0000  stw r25, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82A1BEF4: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A1BEF8: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82A1BEFC: 993F010F  stb r9, 0x10f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(271 as u32), ctx.r[9].u8 ) };
	pc = 0x82A1BF00; continue 'dispatch;
            }
            0x82A1BF00 => {
    //   block [0x82A1BF00..0x82A1BF08)
	// 82A1BF00: A1610054  lhz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A1BF04: B17E0000  sth r11, 0(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	pc = 0x82A1BF08; continue 'dispatch;
            }
            0x82A1BF08 => {
    //   block [0x82A1BF08..0x82A1BF24)
	// 82A1BF08: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 82A1BF0C: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 82A1BF10: 2F180003  cmpwi cr6, r24, 3
	ctx.cr[6].compare_i32(ctx.r[24].s32, 3, &mut ctx.xer);
	// 82A1BF14: 4198FEF0  blt cr6, 0x82a1be04
	if ctx.cr[6].lt {
	pc = 0x82A1BE04; continue 'dispatch;
	}
	// 82A1BF18: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1BF1C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A1BF20: 4828D520  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1BF28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1BF28 size=140
    let mut pc: u32 = 0x82A1BF28;
    'dispatch: loop {
        match pc {
            0x82A1BF28 => {
    //   block [0x82A1BF28..0x82A1BFB4)
	// 82A1BF28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1BF2C: 4828D4E1  bl 0x82ca940c
	ctx.lr = 0x82A1BF30;
	sub_82CA93D0(ctx, base);
	// 82A1BF30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1BF34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1BF38: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1BF3C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A1BF40: 48000371  bl 0x82a1c2b0
	ctx.lr = 0x82A1BF44;
	sub_82A1C2B0(ctx, base);
	// 82A1BF44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1BF48: 48000501  bl 0x82a1c448
	ctx.lr = 0x82A1BF4C;
	sub_82A1C448(ctx, base);
	// 82A1BF4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1BF50: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1BF54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1BF58: 48000161  bl 0x82a1c0b8
	ctx.lr = 0x82A1BF5C;
	sub_82A1C0B8(ctx, base);
	// 82A1BF5C: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A1BF60: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A1BF64: 81430020  lwz r10, 0x20(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1BF68: 55650026  rlwinm r5, r11, 0, 0, 0x13
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1BF6C: 55440026  rlwinm r4, r10, 0, 0, 0x13
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1BF70: 4B8A66C1  bl 0x822c2630
	ctx.lr = 0x82A1BF74;
	sub_822C2630(ctx, base);
	// 82A1BF74: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82A1BF78: 811F00E8  lwz r8, 0xe8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A1BF7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1BF80: 993F010D  stb r9, 0x10d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(269 as u32), ctx.r[9].u8 ) };
	// 82A1BF84: 80E80020  lwz r7, 0x20(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1BF88: 54FE0026  rlwinm r30, r7, 0, 0, 0x13
	ctx.r[30].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1BF8C: 48000445  bl 0x82a1c3d0
	ctx.lr = 0x82A1BF90;
	sub_82A1C3D0(ctx, base);
	// 82A1BF90: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A1BF94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1BF98: 48000381  bl 0x82a1c318
	ctx.lr = 0x82A1BF9C;
	sub_82A1C318(ctx, base);
	// 82A1BF9C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A1BFA0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1BFA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1BFA8: 4828D4D9  bl 0x82ca9480
	ctx.lr = 0x82A1BFAC;
	sub_82CA9480(ctx, base);
	// 82A1BFAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1BFB0: 4828D4AC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1BFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1BFB8 size=252
    let mut pc: u32 = 0x82A1BFB8;
    'dispatch: loop {
        match pc {
            0x82A1BFB8 => {
    //   block [0x82A1BFB8..0x82A1C028)
	// 82A1BFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1BFBC: 4828D441  bl 0x82ca93fc
	ctx.lr = 0x82A1BFC0;
	sub_82CA93D0(ctx, base);
	// 82A1BFC0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1BFC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1BFC8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A1BFCC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A1BFD0: 480002E1  bl 0x82a1c2b0
	ctx.lr = 0x82A1BFD4;
	sub_82A1C2B0(ctx, base);
	// 82A1BFD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1BFD8: 48000471  bl 0x82a1c448
	ctx.lr = 0x82A1BFDC;
	sub_82A1C448(ctx, base);
	// 82A1BFDC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1BFE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1BFE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1BFE8: 480000D1  bl 0x82a1c0b8
	ctx.lr = 0x82A1BFEC;
	sub_82A1C0B8(ctx, base);
	// 82A1BFEC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A1BFF0: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 82A1BFF4: 9B210052  stb r25, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[25].u8 ) };
	// 82A1BFF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1BFFC: 9B210051  stb r25, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[25].u8 ) };
	// 82A1C000: 387E00EC  addi r3, r30, 0xec
	ctx.r[3].s64 = ctx.r[30].s64 + 236;
	// 82A1C004: 9B210050  stb r25, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u8 ) };
	// 82A1C008: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 82A1C00C: 839E0104  lwz r28, 0x104(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A1C010: 835E0108  lwz r26, 0x108(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(264 as u32) ) } as u64;
	// 82A1C014: 481543F5  bl 0x82b70408
	ctx.lr = 0x82A1C018;
	sub_82B70408(ctx, base);
	// 82A1C018: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A1C01C: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82A1C020: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82A1C024: 4198003C  blt cr6, 0x82a1c060
	if ctx.cr[6].lt {
	pc = 0x82A1C060; continue 'dispatch;
	}
	pc = 0x82A1C028; continue 'dispatch;
            }
            0x82A1C028 => {
    //   block [0x82A1C028..0x82A1C034)
	// 82A1C028: 57BF07FE  clrlwi r31, r29, 0x1f
	ctx.r[31].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 82A1C02C: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82A1C030: 41990024  bgt cr6, 0x82a1c054
	if ctx.cr[6].gt {
	pc = 0x82A1C054; continue 'dispatch;
	}
	pc = 0x82A1C034; continue 'dispatch;
            }
            0x82A1C034 => {
    //   block [0x82A1C034..0x82A1C054)
	// 82A1C034: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A1C038: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1C03C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1C040: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1C044: 48000855  bl 0x82a1c898
	ctx.lr = 0x82A1C048;
	sub_82A1C898(ctx, base);
	// 82A1C048: 3BFF0002  addi r31, r31, 2
	ctx.r[31].s64 = ctx.r[31].s64 + 2;
	// 82A1C04C: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82A1C050: 4099FFE4  ble cr6, 0x82a1c034
	if !ctx.cr[6].gt {
	pc = 0x82A1C034; continue 'dispatch;
	}
	pc = 0x82A1C054; continue 'dispatch;
            }
            0x82A1C054 => {
    //   block [0x82A1C054..0x82A1C060)
	// 82A1C054: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82A1C058: 7F1DD000  cmpw cr6, r29, r26
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[26].s32, &mut ctx.xer);
	// 82A1C05C: 4099FFCC  ble cr6, 0x82a1c028
	if !ctx.cr[6].gt {
	pc = 0x82A1C028; continue 'dispatch;
	}
	pc = 0x82A1C060; continue 'dispatch;
            }
            0x82A1C060 => {
    //   block [0x82A1C060..0x82A1C0B4)
	// 82A1C060: 807E00E8  lwz r3, 0xe8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A1C064: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A1C068: 81430020  lwz r10, 0x20(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1C06C: 55650026  rlwinm r5, r11, 0, 0, 0x13
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1C070: 55440026  rlwinm r4, r10, 0, 0, 0x13
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1C074: 4B8A65BD  bl 0x822c2630
	ctx.lr = 0x82A1C078;
	sub_822C2630(ctx, base);
	// 82A1C078: 9B3E010D  stb r25, 0x10d(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(269 as u32), ctx.r[25].u8 ) };
	// 82A1C07C: 813E00E8  lwz r9, 0xe8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A1C080: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1C084: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1C088: 551F0026  rlwinm r31, r8, 0, 0, 0x13
	ctx.r[31].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1C08C: 48000345  bl 0x82a1c3d0
	ctx.lr = 0x82A1C090;
	sub_82A1C3D0(ctx, base);
	// 82A1C090: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A1C094: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1C098: 48000281  bl 0x82a1c318
	ctx.lr = 0x82A1C09C;
	sub_82A1C318(ctx, base);
	// 82A1C09C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A1C0A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1C0A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1C0A8: 4828D3D9  bl 0x82ca9480
	ctx.lr = 0x82A1C0AC;
	sub_82CA9480(ctx, base);
	// 82A1C0AC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1C0B0: 4828D39C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1C0B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1C0B8 size=504
    let mut pc: u32 = 0x82A1C0B8;
    'dispatch: loop {
        match pc {
            0x82A1C0B8 => {
    //   block [0x82A1C0B8..0x82A1C1F0)
	// 82A1C0B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1C0BC: 4828D345  bl 0x82ca9400
	ctx.lr = 0x82A1C0C0;
	sub_82CA93D0(ctx, base);
	// 82A1C0C0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1C0C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1C0C8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1C0CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1C0D0: 91010090  stw r8, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[8].u32 ) };
	// 82A1C0D4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A1C0D8: 91010094  stw r8, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[8].u32 ) };
	// 82A1C0DC: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 82A1C0E0: 813F0104  lwz r9, 0x104(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A1C0E4: 3BBE0024  addi r29, r30, 0x24
	ctx.r[29].s64 = ctx.r[30].s64 + 36;
	// 82A1C0E8: 817F0108  lwz r11, 0x108(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(264 as u32) ) } as u64;
	// 82A1C0EC: 3B9E0020  addi r28, r30, 0x20
	ctx.r[28].s64 = ctx.r[30].s64 + 32;
	// 82A1C0F0: 3949FFFF  addi r10, r9, -1
	ctx.r[10].s64 = ctx.r[9].s64 + -1;
	// 82A1C0F4: 906100AC  stw r3, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[3].u32 ) };
	// 82A1C0F8: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 82A1C0FC: 90610084  stw r3, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 82A1C100: 91410098  stw r10, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 82A1C104: 394BFF6A  addi r10, r11, -0x96
	ctx.r[10].s64 = ctx.r[11].s64 + -150;
	// 82A1C108: 90E1009C  stw r7, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[7].u32 ) };
	// 82A1C10C: 7D260E70  srawi r6, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 82A1C110: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1C114: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C118: 7CE60194  addze r7, r6
	tmp.s64 = ctx.r[6].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[6].u32);
	ctx.r[7].s64 = tmp.s64;
	// 82A1C11C: 912100A8  stw r9, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[9].u32 ) };
	// 82A1C120: 5565083C  slwi r5, r11, 1
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A1C124: 91210088  stw r9, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[9].u32 ) };
	// 82A1C128: 5566083C  slwi r6, r11, 1
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A1C12C: 9141008C  stw r10, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 82A1C130: 7C8B2A14  add r4, r11, r5
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82A1C134: 910100A0  stw r8, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[8].u32 ) };
	// 82A1C138: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A1C13C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1C140: 7D275A14  add r9, r7, r11
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82A1C144: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A1C148: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82A1C14C: 7D665214  add r11, r6, r10
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	// 82A1C150: 7F445214  add r26, r4, r10
	ctx.r[26].u64 = ctx.r[4].u64 + ctx.r[10].u64;
	// 82A1C154: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 82A1C158: 90A10064  stw r5, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[5].u32 ) };
	// 82A1C15C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A1C160: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82A1C164: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A1C168: 38BE001C  addi r5, r30, 0x1c
	ctx.r[5].s64 = ctx.r[30].s64 + 28;
	// 82A1C16C: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 82A1C170: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82A1C174: 910100A4  stw r8, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[8].u32 ) };
	// 82A1C178: 91010080  stw r8, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[8].u32 ) };
	// 82A1C17C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A1C180: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82A1C184: 93410074  stw r26, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[26].u32 ) };
	// 82A1C188: 48000329  bl 0x82a1c4b0
	ctx.lr = 0x82A1C18C;
	sub_82A1C4B0(ctx, base);
	// 82A1C18C: 38FE0018  addi r7, r30, 0x18
	ctx.r[7].s64 = ctx.r[30].s64 + 24;
	// 82A1C190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C194: 38BE0014  addi r5, r30, 0x14
	ctx.r[5].s64 = ctx.r[30].s64 + 20;
	// 82A1C198: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 82A1C19C: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82A1C1A0: 48000311  bl 0x82a1c4b0
	ctx.lr = 0x82A1C1A4;
	sub_82A1C4B0(ctx, base);
	// 82A1C1A4: 3CA0820F  lis r5, -0x7df1
	ctx.r[5].s64 = -2112946176;
	// 82A1C1A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C1AC: 38C529C8  addi r6, r5, 0x29c8
	ctx.r[6].s64 = ctx.r[5].s64 + 10696;
	// 82A1C1B0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A1C1B4: 38A00036  li r5, 0x36
	ctx.r[5].s64 = 54;
	// 82A1C1B8: 38800036  li r4, 0x36
	ctx.r[4].s64 = 54;
	// 82A1C1BC: 480008C5  bl 0x82a1ca80
	ctx.lr = 0x82A1C1C0;
	sub_82A1CA80(ctx, base);
	// 82A1C1C0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A1C1C4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A1C1C8: 38BE0028  addi r5, r30, 0x28
	ctx.r[5].s64 = ctx.r[30].s64 + 40;
	// 82A1C1CC: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82A1C1D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C1D4: 480002DD  bl 0x82a1c4b0
	ctx.lr = 0x82A1C1D8;
	sub_82A1C4B0(ctx, base);
	// 82A1C1D8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C1DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1C1E0: 409A0010  bne cr6, 0x82a1c1f0
	if !ctx.cr[6].eq {
	pc = 0x82A1C1F0; continue 'dispatch;
	}
	// 82A1C1E4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A1C1E8: 38CBFFDF  addi r6, r11, -0x21
	ctx.r[6].s64 = ctx.r[11].s64 + -33;
	// 82A1C1EC: 48000008  b 0x82a1c1f4
	pc = 0x82A1C1F4; continue 'dispatch;
            }
            0x82A1C1F0 => {
    //   block [0x82A1C1F0..0x82A1C1F4)
	// 82A1C1F0: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1C1F4; continue 'dispatch;
            }
            0x82A1C1F4 => {
    //   block [0x82A1C1F4..0x82A1C2B0)
	// 82A1C1F4: 815F00DC  lwz r10, 0xdc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 82A1C1F8: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 82A1C1FC: 817F00E0  lwz r11, 0xe0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) } as u64;
	// 82A1C200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C204: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A1C208: 216B000A  subfic r11, r11, 0xa
	ctx.xer.ca = ctx.r[11].u32 <= 10 as u32;
	ctx.r[11].s64 = (10 as i64) - ctx.r[11].s64;
	// 82A1C20C: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82A1C210: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1C214: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A1C218: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A1C21C: 20880028  subfic r4, r8, 0x28
	ctx.xer.ca = ctx.r[8].u32 <= 40 as u32;
	ctx.r[4].s64 = (40 as i64) - ctx.r[8].s64;
	// 82A1C220: 54A5103A  slwi r5, r5, 2
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A1C224: 4800085D  bl 0x82a1ca80
	ctx.lr = 0x82A1C228;
	sub_82A1CA80(ctx, base);
	// 82A1C228: 3C80820F  lis r4, -0x7df1
	ctx.r[4].s64 = -2112946176;
	// 82A1C22C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A1C230: 88DF010E  lbz r6, 0x10e(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(270 as u32) ) } as u64;
	// 82A1C234: 38E429D0  addi r7, r4, 0x29d0
	ctx.r[7].s64 = ctx.r[4].s64 + 10704;
	// 82A1C238: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1C23C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C240: 48000421  bl 0x82a1c660
	ctx.lr = 0x82A1C244;
	sub_82A1C660(ctx, base);
	// 82A1C244: 3C60820F  lis r3, -0x7df1
	ctx.r[3].s64 = -2112946176;
	// 82A1C248: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A1C24C: 88DF010F  lbz r6, 0x10f(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(271 as u32) ) } as u64;
	// 82A1C250: 38E329E0  addi r7, r3, 0x29e0
	ctx.r[7].s64 = ctx.r[3].s64 + 10720;
	// 82A1C254: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1C258: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C25C: 48000405  bl 0x82a1c660
	ctx.lr = 0x82A1C260;
	sub_82A1C660(ctx, base);
	// 82A1C260: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1C264: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A1C268: 38CB29F4  addi r6, r11, 0x29f4
	ctx.r[6].s64 = ctx.r[11].s64 + 10740;
	// 82A1C26C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1C270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C274: 48000545  bl 0x82a1c7b8
	ctx.lr = 0x82A1C278;
	sub_82A1C7B8(ctx, base);
	// 82A1C278: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82A1C27C: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82A1C280: 38CA2A04  addi r6, r10, 0x2a04
	ctx.r[6].s64 = ctx.r[10].s64 + 10756;
	// 82A1C284: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1C288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C28C: 4800052D  bl 0x82a1c7b8
	ctx.lr = 0x82A1C290;
	sub_82A1C7B8(ctx, base);
	// 82A1C290: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 82A1C294: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82A1C298: 38C92A10  addi r6, r9, 0x2a10
	ctx.r[6].s64 = ctx.r[9].s64 + 10768;
	// 82A1C29C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1C2A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C2A4: 48000515  bl 0x82a1c7b8
	ctx.lr = 0x82A1C2A8;
	sub_82A1C7B8(ctx, base);
	// 82A1C2A8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A1C2AC: 4828D1A4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1C2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1C2B0 size=100
    let mut pc: u32 = 0x82A1C2B0;
    'dispatch: loop {
        match pc {
            0x82A1C2B0 => {
    //   block [0x82A1C2B0..0x82A1C314)
	// 82A1C2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1C2B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1C2B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1C2BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1C2C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1C2C4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1C2C8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A1C2CC: 389F00E4  addi r4, r31, 0xe4
	ctx.r[4].s64 = ctx.r[31].s64 + 228;
	// 82A1C2D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1C2D4: 4B874115  bl 0x822903e8
	ctx.lr = 0x82A1C2D8;
	sub_822903E8(ctx, base);
	// 82A1C2D8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C2DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A1C2E0: 915F00F0  stw r10, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 82A1C2E4: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1C2E8: 913F00F4  stw r9, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[9].u32 ) };
	// 82A1C2EC: 81030008  lwz r8, 8(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1C2F0: 911F00F8  stw r8, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[8].u32 ) };
	// 82A1C2F4: 80E3000C  lwz r7, 0xc(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1C2F8: 90FF00FC  stw r7, 0xfc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(252 as u32), ctx.r[7].u32 ) };
	// 82A1C2FC: 997F010D  stb r11, 0x10d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(269 as u32), ctx.r[11].u8 ) };
	// 82A1C300: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1C304: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1C308: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1C30C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1C310: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1C318(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1C318 size=184
    let mut pc: u32 = 0x82A1C318;
    'dispatch: loop {
        match pc {
            0x82A1C318 => {
    //   block [0x82A1C318..0x82A1C3D0)
	// 82A1C318: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1C31C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1C320: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1C324: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1C328: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1C32C: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 82A1C330: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A1C334: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A1C338: 4B7DE899  bl 0x821fabd0
	ctx.lr = 0x82A1C33C;
	sub_821FABD0(ctx, base);
	// 82A1C33C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A1C340: 807F00E8  lwz r3, 0xe8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A1C344: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A1C348: 4B7DE889  bl 0x821fabd0
	ctx.lr = 0x82A1C34C;
	sub_821FABD0(ctx, base);
	// 82A1C34C: 389F00E4  addi r4, r31, 0xe4
	ctx.r[4].s64 = ctx.r[31].s64 + 228;
	// 82A1C350: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1C354: 4B86B38D  bl 0x822876e0
	ctx.lr = 0x82A1C358;
	sub_822876E0(ctx, base);
	// 82A1C358: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A1C35C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C360: 396BDAD8  addi r11, r11, -0x2528
	ctx.r[11].s64 = ctx.r[11].s64 + -9512;
	// 82A1C364: 8121007C  lwz r9, 0x7c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A1C368: 1D0A0070  mulli r8, r10, 0x70
	ctx.r[8].s32 = ((ctx.r[10].s32 as i64 * 112 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82A1C36C: 80E10098  lwz r7, 0x98(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 82A1C370: 38CB0004  addi r6, r11, 4
	ctx.r[6].s64 = ctx.r[11].s64 + 4;
	// 82A1C374: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 82A1C378: 7C88302E  lwzx r4, r8, r6
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82A1C37C: 7C68282E  lwzx r3, r8, r5
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 82A1C380: 0CC40000  twi 6, r4, 0
	// 82A1C384: 7D4323D6  divw r10, r3, r4
	ctx.r[10].s32 = ctx.r[3].s32 / ctx.r[4].s32;
	// 82A1C388: 546B083E  rotlwi r11, r3, 1
	ctx.r[11].u64 = ((ctx.r[3].u32).rotate_left(1)) as u64;
	// 82A1C38C: 7D0A23D6  divw r8, r10, r4
	ctx.r[8].s32 = ctx.r[10].s32 / ctx.r[4].s32;
	// 82A1C390: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82A1C394: 7C6849D6  mullw r3, r8, r9
	ctx.r[3].s32 = ((ctx.r[8].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82A1C398: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 82A1C39C: 38AAFFFF  addi r5, r10, -1
	ctx.r[5].s64 = ctx.r[10].s64 + -1;
	// 82A1C3A0: 7C8B3078  andc r11, r4, r6
	ctx.r[11].u64 = ctx.r[4].u64 & !ctx.r[6].u64;
	// 82A1C3A4: 7C8A2878  andc r10, r4, r5
	ctx.r[10].u64 = ctx.r[4].u64 & !ctx.r[5].u64;
	// 82A1C3A8: 7D2339D6  mullw r9, r3, r7
	ctx.r[9].s32 = ((ctx.r[3].s32 as i64 * ctx.r[7].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82A1C3AC: 0CC40000  twi 6, r4, 0
	// 82A1C3B0: 0CABFFFF  twi 5, r11, -1
	// 82A1C3B4: 0CAAFFFF  twi 5, r10, -1
	// 82A1C3B8: 5523E8FE  srwi r3, r9, 3
	ctx.r[3].u32 = ctx.r[9].u32.wrapping_shr(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A1C3BC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A1C3C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1C3C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1C3C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1C3CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1C3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1C3D0 size=120
    let mut pc: u32 = 0x82A1C3D0;
    'dispatch: loop {
        match pc {
            0x82A1C3D0 => {
    //   block [0x82A1C3D0..0x82A1C400)
	// 82A1C3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1C3D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1C3D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1C3DC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1C3E0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82A1C3E4: 394BB138  addi r10, r11, -0x4ec8
	ctx.r[10].s64 = ctx.r[11].s64 + -20168;
	// 82A1C3E8: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1C3EC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A1C3F0: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82A1C3F4: 419A000C  beq cr6, 0x82a1c400
	if ctx.cr[6].eq {
	pc = 0x82A1C400; continue 'dispatch;
	}
	// 82A1C3F8: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 82A1C3FC: 4B7DFD7D  bl 0x821fc178
	ctx.lr = 0x82A1C400;
	sub_821FC178(ctx, base);
	pc = 0x82A1C400; continue 'dispatch;
            }
            0x82A1C400 => {
    //   block [0x82A1C400..0x82A1C448)
	// 82A1C400: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1C404: 81480020  lwz r10, 0x20(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1C408: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1C40C: 392B2A30  addi r9, r11, 0x2a30
	ctx.r[9].s64 = ctx.r[11].s64 + 10800;
	// 82A1C410: 555F0026  rlwinm r31, r10, 0, 0, 0x13
	ctx.r[31].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1C414: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A1C418: 4B7DFBF1  bl 0x821fc008
	ctx.lr = 0x82A1C41C;
	sub_821FC008(ctx, base);
	// 82A1C41C: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 82A1C420: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1C424: 38E82A40  addi r7, r8, 0x2a40
	ctx.r[7].s64 = ctx.r[8].s64 + 10816;
	// 82A1C428: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 82A1C42C: 4B7DFBDD  bl 0x821fc008
	ctx.lr = 0x82A1C430;
	sub_821FC008(ctx, base);
	// 82A1C430: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C434: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1C438: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1C43C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1C440: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1C444: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1C448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1C448 size=100
    let mut pc: u32 = 0x82A1C448;
    'dispatch: loop {
        match pc {
            0x82A1C448 => {
    //   block [0x82A1C448..0x82A1C498)
	// 82A1C448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1C44C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1C450: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1C454: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1C458: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A1C45C: 806300E8  lwz r3, 0xe8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(232 as u32) ) } as u64;
	// 82A1C460: 4817C401  bl 0x82b98860
	ctx.lr = 0x82A1C464;
	sub_82B98860(ctx, base);
	// 82A1C464: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1C468: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1C46C: 394B2A2C  addi r10, r11, 0x2a2c
	ctx.r[10].s64 = ctx.r[11].s64 + 10796;
	// 82A1C470: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 82A1C474: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A1C478: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A1C47C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1C480: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 82A1C484: 48165DDD  bl 0x82b82260
	ctx.lr = 0x82A1C488;
	sub_82B82260(ctx, base);
	// 82A1C488: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A1C48C: 419A000C  beq cr6, 0x82a1c498
	if ctx.cr[6].eq {
	pc = 0x82A1C498; continue 'dispatch;
	}
	// 82A1C490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C494: 4B7DFE8D  bl 0x821fc320
	ctx.lr = 0x82A1C498;
	sub_821FC320(ctx, base);
	pc = 0x82A1C498; continue 'dispatch;
            }
            0x82A1C498 => {
    //   block [0x82A1C498..0x82A1C4AC)
	// 82A1C498: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1C49C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1C4A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1C4A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1C4A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1C4B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1C4B0 size=280
    let mut pc: u32 = 0x82A1C4B0;
    'dispatch: loop {
        match pc {
            0x82A1C4B0 => {
    //   block [0x82A1C4B0..0x82A1C5C8)
	// 82A1C4B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1C4B4: 4828CF55  bl 0x82ca9408
	ctx.lr = 0x82A1C4B8;
	sub_82CA93D0(ctx, base);
	// 82A1C4B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1C4BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1C4C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1C4C4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A1C4C8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82A1C4CC: 48000475  bl 0x82a1c940
	ctx.lr = 0x82A1C4D0;
	sub_82A1C940(ctx, base);
	// 82A1C4D0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C4D4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A1C4D8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1C4DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C4E0: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1C4E4: 7CC45850  subf r6, r4, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 82A1C4E8: 480004D9  bl 0x82a1c9c0
	ctx.lr = 0x82A1C4EC;
	sub_82A1C9C0(ctx, base);
	// 82A1C4EC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1C4F0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C4F4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A1C4F8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1C4FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C500: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 82A1C504: 7CC45050  subf r6, r4, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[4].s64;
	// 82A1C508: 480004B9  bl 0x82a1c9c0
	ctx.lr = 0x82A1C50C;
	sub_82A1C9C0(ctx, base);
	// 82A1C50C: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1C510: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1C514: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A1C518: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C51C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C520: 7CC54850  subf r6, r5, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[5].s64;
	// 82A1C524: 480004FD  bl 0x82a1ca20
	ctx.lr = 0x82A1C528;
	sub_82A1CA20(ctx, base);
	// 82A1C528: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C52C: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1C530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C534: 811E000C  lwz r8, 0xc(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1C538: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A1C53C: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82A1C540: 7CC54050  subf r6, r5, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[5].s64;
	// 82A1C544: 480004DD  bl 0x82a1ca20
	ctx.lr = 0x82A1C548;
	sub_82A1CA20(ctx, base);
	// 82A1C548: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C54C: 80DE0008  lwz r6, 8(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1C550: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A1C554: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C558: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1C55C: 7CC43050  subf r6, r4, r6
	ctx.r[6].s64 = ctx.r[6].s64 - ctx.r[4].s64;
	// 82A1C560: 48000461  bl 0x82a1c9c0
	ctx.lr = 0x82A1C564;
	sub_82A1C9C0(ctx, base);
	// 82A1C564: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1C568: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C56C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A1C570: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 82A1C574: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C578: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1C57C: 7CC45850  subf r6, r4, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 82A1C580: 48000441  bl 0x82a1c9c0
	ctx.lr = 0x82A1C584;
	sub_82A1C9C0(ctx, base);
	// 82A1C584: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1C588: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1C58C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A1C590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C594: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1C598: 7CC55050  subf r6, r5, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[5].s64;
	// 82A1C59C: 48000485  bl 0x82a1ca20
	ctx.lr = 0x82A1C5A0;
	sub_82A1CA20(ctx, base);
	// 82A1C5A0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1C5A4: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1C5A8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A1C5AC: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1C5B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C5B4: 388BFFFF  addi r4, r11, -1
	ctx.r[4].s64 = ctx.r[11].s64 + -1;
	// 82A1C5B8: 7CC54850  subf r6, r5, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[5].s64;
	// 82A1C5BC: 48000465  bl 0x82a1ca20
	ctx.lr = 0x82A1C5C0;
	sub_82A1CA20(ctx, base);
	// 82A1C5C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1C5C4: 4828CE94  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1C5C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1C5C8 size=152
    let mut pc: u32 = 0x82A1C5C8;
    'dispatch: loop {
        match pc {
            0x82A1C5C8 => {
    //   block [0x82A1C5C8..0x82A1C660)
	// 82A1C5C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1C5CC: 4828CE3D  bl 0x82ca9408
	ctx.lr = 0x82A1C5D0;
	sub_82CA93D0(ctx, base);
	// 82A1C5D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1C5D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1C5D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1C5DC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A1C5E0: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82A1C5E4: 4800035D  bl 0x82a1c940
	ctx.lr = 0x82A1C5E8;
	sub_82A1C940(ctx, base);
	// 82A1C5E8: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C5EC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A1C5F0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1C5F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C5F8: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1C5FC: 7CC45850  subf r6, r4, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 82A1C600: 480003C1  bl 0x82a1c9c0
	ctx.lr = 0x82A1C604;
	sub_82A1C9C0(ctx, base);
	// 82A1C604: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1C608: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1C60C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C610: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82A1C614: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C618: 7CC55050  subf r6, r5, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[5].s64;
	// 82A1C61C: 48000405  bl 0x82a1ca20
	ctx.lr = 0x82A1C620;
	sub_82A1CA20(ctx, base);
	// 82A1C620: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C624: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1C628: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A1C62C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C630: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1C634: 7CC44850  subf r6, r4, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[4].s64;
	// 82A1C638: 48000389  bl 0x82a1c9c0
	ctx.lr = 0x82A1C63C;
	sub_82A1C9C0(ctx, base);
	// 82A1C63C: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1C640: 811E000C  lwz r8, 0xc(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1C644: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82A1C648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C64C: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1C650: 7CC54050  subf r6, r5, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[5].s64;
	// 82A1C654: 480003CD  bl 0x82a1ca20
	ctx.lr = 0x82A1C658;
	sub_82A1CA20(ctx, base);
	// 82A1C658: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1C65C: 4828CDFC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1C660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1C660 size=344
    let mut pc: u32 = 0x82A1C660;
    'dispatch: loop {
        match pc {
            0x82A1C660 => {
    //   block [0x82A1C660..0x82A1C790)
	// 82A1C660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1C664: 4828CD99  bl 0x82ca93fc
	ctx.lr = 0x82A1C668;
	sub_82CA93D0(ctx, base);
	// 82A1C668: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1C66C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A1C670: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1C674: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A1C678: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82A1C67C: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 82A1C680: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C684: 39400096  li r10, 0x96
	ctx.r[10].s64 = 150;
	// 82A1C688: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1C68C: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 82A1C690: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1C694: 38C00032  li r6, 0x32
	ctx.r[6].s64 = 50;
	// 82A1C698: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1C69C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82A1C6A0: 7F444A14  add r26, r4, r9
	ctx.r[26].u64 = ctx.r[4].u64 + ctx.r[9].u64;
	// 82A1C6A4: 98A10052  stb r5, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[5].u8 ) };
	// 82A1C6A8: 7F234214  add r25, r3, r8
	ctx.r[25].u64 = ctx.r[3].u64 + ctx.r[8].u64;
	// 82A1C6AC: 98A10051  stb r5, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[5].u8 ) };
	// 82A1C6B0: 98A10050  stb r5, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u8 ) };
	// 82A1C6B4: 38E000C8  li r7, 0xc8
	ctx.r[7].s64 = 200;
	// 82A1C6B8: 98C10056  stb r6, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[6].u8 ) };
	// 82A1C6BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A1C6C0: 98C10055  stb r6, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[6].u8 ) };
	// 82A1C6C4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A1C6C8: 98C10054  stb r6, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[6].u8 ) };
	// 82A1C6CC: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82A1C6D0: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 82A1C6D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1C6D8: 99610057  stb r11, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[11].u8 ) };
	// 82A1C6DC: 9941005A  stb r10, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[10].u8 ) };
	// 82A1C6E0: 99410059  stb r10, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[10].u8 ) };
	// 82A1C6E4: 99410058  stb r10, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u8 ) };
	// 82A1C6E8: 9961005B  stb r11, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[11].u8 ) };
	// 82A1C6EC: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 82A1C6F0: 91010074  stw r8, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[8].u32 ) };
	// 82A1C6F4: 93410078  stw r26, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[26].u32 ) };
	// 82A1C6F8: 9321007C  stw r25, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[25].u32 ) };
	// 82A1C6FC: 98E10066  stb r7, 0x66(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(102 as u32), ctx.r[7].u8 ) };
	// 82A1C700: 98E10065  stb r7, 0x65(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(101 as u32), ctx.r[7].u8 ) };
	// 82A1C704: 98E10064  stb r7, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u8 ) };
	// 82A1C708: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82A1C70C: 99610067  stb r11, 0x67(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(103 as u32), ctx.r[11].u8 ) };
	// 82A1C710: 99610062  stb r11, 0x62(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[11].u8 ) };
	// 82A1C714: 99610061  stb r11, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[11].u8 ) };
	// 82A1C718: 99610060  stb r11, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 82A1C71C: 99610063  stb r11, 0x63(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(99 as u32), ctx.r[11].u8 ) };
	// 82A1C720: 9941005E  stb r10, 0x5e(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(94 as u32), ctx.r[10].u8 ) };
	// 82A1C724: 9941005D  stb r10, 0x5d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(93 as u32), ctx.r[10].u8 ) };
	// 82A1C728: 9941005C  stb r10, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u8 ) };
	// 82A1C72C: 9961005F  stb r11, 0x5f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(95 as u32), ctx.r[11].u8 ) };
	// 82A1C730: 4BFFFE99  bl 0x82a1c5c8
	ctx.lr = 0x82A1C734;
	sub_82A1C5C8(ctx, base);
	// 82A1C734: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 82A1C738: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1C73C: 419A0054  beq cr6, 0x82a1c790
	if ctx.cr[6].eq {
	pc = 0x82A1C790; continue 'dispatch;
	}
	// 82A1C740: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C744: 38E1005C  addi r7, r1, 0x5c
	ctx.r[7].s64 = ctx.r[1].s64 + 92;
	// 82A1C748: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1C74C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82A1C750: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1C754: 38AA0002  addi r5, r10, 2
	ctx.r[5].s64 = ctx.r[10].s64 + 2;
	// 82A1C758: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1C75C: 388B0002  addi r4, r11, 2
	ctx.r[4].s64 = ctx.r[11].s64 + 2;
	// 82A1C760: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A1C764: 90A10070  stw r5, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[5].u32 ) };
	// 82A1C768: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82A1C76C: 90810074  stw r4, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[4].u32 ) };
	// 82A1C770: 386AFFFE  addi r3, r10, -2
	ctx.r[3].s64 = ctx.r[10].s64 + -2;
	// 82A1C774: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 82A1C778: 90610078  stw r3, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 82A1C77C: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 82A1C780: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82A1C784: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A1C788: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1C78C: 4BFFFE3D  bl 0x82a1c5c8
	ctx.lr = 0x82A1C790;
	sub_82A1C5C8(ctx, base);
	pc = 0x82A1C790; continue 'dispatch;
            }
            0x82A1C790 => {
    //   block [0x82A1C790..0x82A1C7B8)
	// 82A1C790: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C794: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A1C798: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1C79C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82A1C7A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1C7A4: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1C7A8: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A1C7AC: 480002D5  bl 0x82a1ca80
	ctx.lr = 0x82A1C7B0;
	sub_82A1CA80(ctx, base);
	// 82A1C7B0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82A1C7B4: 4828CC98  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1C7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1C7B8 size=224
    let mut pc: u32 = 0x82A1C7B8;
    'dispatch: loop {
        match pc {
            0x82A1C7B8 => {
    //   block [0x82A1C7B8..0x82A1C898)
	// 82A1C7B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1C7BC: 4828CC21  bl 0x82ca93dc
	ctx.lr = 0x82A1C7C0;
	sub_82CA93D0(ctx, base);
	// 82A1C7C0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1C7C4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1C7C8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A1C7CC: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82A1C7D0: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 82A1C7D4: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 82A1C7D8: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C7DC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A1C7E0: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1C7E4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A1C7E8: 8B7E001E  lbz r27, 0x1e(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(30 as u32) ) } as u64;
	// 82A1C7EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1C7F0: 8B5E001D  lbz r26, 0x1d(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(29 as u32) ) } as u64;
	// 82A1C7F4: 8B3E001C  lbz r25, 0x1c(r30)
	ctx.r[25].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A1C7F8: 8B1E001F  lbz r24, 0x1f(r30)
	ctx.r[24].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(31 as u32) ) } as u64;
	// 82A1C7FC: 8AFE0022  lbz r23, 0x22(r30)
	ctx.r[23].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(34 as u32) ) } as u64;
	// 82A1C800: 8ADE0021  lbz r22, 0x21(r30)
	ctx.r[22].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(33 as u32) ) } as u64;
	// 82A1C804: 8ABE0020  lbz r21, 0x20(r30)
	ctx.r[21].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A1C808: 8A9E0023  lbz r20, 0x23(r30)
	ctx.r[20].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(35 as u32) ) } as u64;
	// 82A1C80C: 8A7E0026  lbz r19, 0x26(r30)
	ctx.r[19].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(38 as u32) ) } as u64;
	// 82A1C810: 8A5E0025  lbz r18, 0x25(r30)
	ctx.r[18].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(37 as u32) ) } as u64;
	// 82A1C814: 8A3E0024  lbz r17, 0x24(r30)
	ctx.r[17].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A1C818: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C81C: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1C820: 8BDE0027  lbz r30, 0x27(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(39 as u32) ) } as u64;
	// 82A1C824: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82A1C828: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82A1C82C: 9B610052  stb r27, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[27].u8 ) };
	// 82A1C830: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 82A1C834: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82A1C838: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A1C83C: 9B410051  stb r26, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[26].u8 ) };
	// 82A1C840: 9101006C  stw r8, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[8].u32 ) };
	// 82A1C844: 9B210050  stb r25, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u8 ) };
	// 82A1C848: 9B010053  stb r24, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[24].u8 ) };
	// 82A1C84C: 9AE10056  stb r23, 0x56(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[23].u8 ) };
	// 82A1C850: 9AC10055  stb r22, 0x55(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(85 as u32), ctx.r[22].u8 ) };
	// 82A1C854: 9AA10054  stb r21, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[21].u8 ) };
	// 82A1C858: 9A810057  stb r20, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[20].u8 ) };
	// 82A1C85C: 9A61005A  stb r19, 0x5a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[19].u8 ) };
	// 82A1C860: 9A410059  stb r18, 0x59(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(89 as u32), ctx.r[18].u8 ) };
	// 82A1C864: 9A210058  stb r17, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[17].u8 ) };
	// 82A1C868: 9BC1005B  stb r30, 0x5b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(91 as u32), ctx.r[30].u8 ) };
	// 82A1C86C: 4BFFFD5D  bl 0x82a1c5c8
	ctx.lr = 0x82A1C870;
	sub_82A1C5C8(ctx, base);
	// 82A1C870: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1C874: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C878: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A1C87C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82A1C880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1C884: 38AB0002  addi r5, r11, 2
	ctx.r[5].s64 = ctx.r[11].s64 + 2;
	// 82A1C888: 388A0002  addi r4, r10, 2
	ctx.r[4].s64 = ctx.r[10].s64 + 2;
	// 82A1C88C: 480001F5  bl 0x82a1ca80
	ctx.lr = 0x82A1C890;
	sub_82A1CA80(ctx, base);
	// 82A1C890: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A1C894: 4828CB98  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1C898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82A1C898 size=168
    let mut pc: u32 = 0x82A1C898;
    'dispatch: loop {
        match pc {
            0x82A1C898 => {
    //   block [0x82A1C898..0x82A1C900)
	// 82A1C898: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82A1C89C: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 82A1C8A0: 81630104  lwz r11, 0x104(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A1C8A4: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A1C8A8: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82A1C8AC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82A1C8B0: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 82A1C8B4: 81630108  lwz r11, 0x108(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(264 as u32) ) } as u64;
	// 82A1C8B8: 7F055800  cmpw cr6, r5, r11
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A1C8BC: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82A1C8C0: 54AA07FE  clrlwi r10, r5, 0x1f
	ctx.r[10].u64 = ctx.r[5].u32 as u64 & 0x00000001u64;
	// 82A1C8C4: 54AB1E36  rlwinm r11, r5, 3, 0x18, 0x1b
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x1FFFFFFFu64;
	// 82A1C8C8: 5489073A  rlwinm r9, r4, 0, 0x1c, 0x1d
	ctx.r[9].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1C8CC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A1C8D0: 548A07BE  clrlwi r10, r4, 0x1e
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000003u64;
	// 82A1C8D4: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1C8D8: 54A80738  rlwinm r8, r5, 0, 0x1c, 0x1c
	ctx.r[8].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1C8DC: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82A1C8E0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82A1C8E4: 54EB083C  slwi r11, r7, 1
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1C8E8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A1C8EC: 419A0014  beq cr6, 0x82a1c900
	if ctx.cr[6].eq {
	pc = 0x82A1C900; continue 'dispatch;
	}
	// 82A1C8F0: 548A06F6  rlwinm r10, r4, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1C8F4: 212A0010  subfic r9, r10, 0x10
	ctx.xer.ca = ctx.r[10].u32 <= 16 as u32;
	ctx.r[9].s64 = (16 as i64) - ctx.r[10].s64;
	// 82A1C8F8: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1C8FC: 48000008  b 0x82a1c904
	pc = 0x82A1C904; continue 'dispatch;
            }
            0x82A1C900 => {
    //   block [0x82A1C900..0x82A1C904)
	// 82A1C900: 548A0EB4  rlwinm r10, r4, 1, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x7FFFFFFFu64;
	pc = 0x82A1C904; continue 'dispatch;
            }
            0x82A1C904 => {
    //   block [0x82A1C904..0x82A1C940)
	// 82A1C904: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A1C908: 814300F8  lwz r10, 0xf8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(248 as u32) ) } as u64;
	// 82A1C90C: 7CA92E70  srawi r9, r5, 5
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[5].s32 >> 5) as i64;
	// 82A1C910: 810300FC  lwz r8, 0xfc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(252 as u32) ) } as u64;
	// 82A1C914: 7CEA49D6  mullw r7, r10, r9
	ctx.r[7].s32 = ((ctx.r[10].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 82A1C918: 7CE51670  srawi r5, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[7].s32 >> 2) as i64;
	// 82A1C91C: 7D450194  addze r10, r5
	tmp.s64 = ctx.r[5].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[5].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82A1C920: 7C842E70  srawi r4, r4, 5
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[4].s32 >> 5) as i64;
	// 82A1C924: 54892834  slwi r9, r4, 5
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A1C928: 7C6A4A14  add r3, r10, r9
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82A1C92C: 546A2834  slwi r10, r3, 5
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1C930: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A1C934: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1C938: 7CCA412E  stwx r6, r10, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32), ctx.r[6].u32) };
	// 82A1C93C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1C940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1C940 size=128
    let mut pc: u32 = 0x82A1C940;
    'dispatch: loop {
        match pc {
            0x82A1C940 => {
    //   block [0x82A1C940..0x82A1C978)
	// 82A1C940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1C944: 4828CAC1  bl 0x82ca9404
	ctx.lr = 0x82A1C948;
	sub_82CA93D0(ctx, base);
	// 82A1C948: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1C94C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A1C950: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1C954: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82A1C958: 387C00EC  addi r3, r28, 0xec
	ctx.r[3].s64 = ctx.r[28].s64 + 236;
	// 82A1C95C: 48153AAD  bl 0x82b70408
	ctx.lr = 0x82A1C960;
	sub_82B70408(ctx, base);
	// 82A1C960: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1C964: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1C968: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A1C96C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A1C970: 40980048  bge cr6, 0x82a1c9b8
	if !ctx.cr[6].lt {
	pc = 0x82A1C9B8; continue 'dispatch;
	}
	// 82A1C974: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A1C978; continue 'dispatch;
            }
            0x82A1C978 => {
    //   block [0x82A1C978..0x82A1C984)
	// 82A1C978: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1C97C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A1C980: 40980028  bge cr6, 0x82a1c9a8
	if !ctx.cr[6].lt {
	pc = 0x82A1C9A8; continue 'dispatch;
	}
	pc = 0x82A1C984; continue 'dispatch;
            }
            0x82A1C984 => {
    //   block [0x82A1C984..0x82A1C9A8)
	// 82A1C984: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A1C988: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1C98C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1C990: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1C994: 4BFFFF05  bl 0x82a1c898
	ctx.lr = 0x82A1C998;
	sub_82A1C898(ctx, base);
	// 82A1C998: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1C99C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A1C9A0: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A1C9A4: 4198FFE0  blt cr6, 0x82a1c984
	if ctx.cr[6].lt {
	pc = 0x82A1C984; continue 'dispatch;
	}
	pc = 0x82A1C9A8; continue 'dispatch;
            }
            0x82A1C9A8 => {
    //   block [0x82A1C9A8..0x82A1C9B8)
	// 82A1C9A8: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1C9AC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82A1C9B0: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A1C9B4: 4198FFC4  blt cr6, 0x82a1c978
	if ctx.cr[6].lt {
	pc = 0x82A1C978; continue 'dispatch;
	}
	pc = 0x82A1C9B8; continue 'dispatch;
            }
            0x82A1C9B8 => {
    //   block [0x82A1C9B8..0x82A1C9C0)
	// 82A1C9B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1C9BC: 4828CA98  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1C9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1C9C0 size=96
    let mut pc: u32 = 0x82A1C9C0;
    'dispatch: loop {
        match pc {
            0x82A1C9C0 => {
    //   block [0x82A1C9C0..0x82A1C9F8)
	// 82A1C9C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1C9C4: 4828CA41  bl 0x82ca9404
	ctx.lr = 0x82A1C9C8;
	sub_82CA93D0(ctx, base);
	// 82A1C9C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1C9CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1C9D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A1C9D4: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82A1C9D8: 387E00EC  addi r3, r30, 0xec
	ctx.r[3].s64 = ctx.r[30].s64 + 236;
	// 82A1C9DC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A1C9E0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A1C9E4: 48153A25  bl 0x82b70408
	ctx.lr = 0x82A1C9E8;
	sub_82B70408(ctx, base);
	// 82A1C9E8: 7FBFEA14  add r29, r31, r29
	ctx.r[29].u64 = ctx.r[31].u64 + ctx.r[29].u64;
	// 82A1C9EC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A1C9F0: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82A1C9F4: 41990024  bgt cr6, 0x82a1ca18
	if ctx.cr[6].gt {
	pc = 0x82A1CA18; continue 'dispatch;
	}
	pc = 0x82A1C9F8; continue 'dispatch;
            }
            0x82A1C9F8 => {
    //   block [0x82A1C9F8..0x82A1CA18)
	// 82A1C9F8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A1C9FC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A1CA00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1CA04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1CA08: 4BFFFE91  bl 0x82a1c898
	ctx.lr = 0x82A1CA0C;
	sub_82A1C898(ctx, base);
	// 82A1CA0C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A1CA10: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82A1CA14: 4099FFE4  ble cr6, 0x82a1c9f8
	if !ctx.cr[6].gt {
	pc = 0x82A1C9F8; continue 'dispatch;
	}
	pc = 0x82A1CA18; continue 'dispatch;
            }
            0x82A1CA18 => {
    //   block [0x82A1CA18..0x82A1CA20)
	// 82A1CA18: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1CA1C: 4828CA38  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1CA20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1CA20 size=96
    let mut pc: u32 = 0x82A1CA20;
    'dispatch: loop {
        match pc {
            0x82A1CA20 => {
    //   block [0x82A1CA20..0x82A1CA58)
	// 82A1CA20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1CA24: 4828C9E1  bl 0x82ca9404
	ctx.lr = 0x82A1CA28;
	sub_82CA93D0(ctx, base);
	// 82A1CA28: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1CA2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1CA30: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A1CA34: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82A1CA38: 387E00EC  addi r3, r30, 0xec
	ctx.r[3].s64 = ctx.r[30].s64 + 236;
	// 82A1CA3C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A1CA40: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A1CA44: 481539C5  bl 0x82b70408
	ctx.lr = 0x82A1CA48;
	sub_82B70408(ctx, base);
	// 82A1CA48: 7FBFEA14  add r29, r31, r29
	ctx.r[29].u64 = ctx.r[31].u64 + ctx.r[29].u64;
	// 82A1CA4C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A1CA50: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82A1CA54: 41990024  bgt cr6, 0x82a1ca78
	if ctx.cr[6].gt {
	pc = 0x82A1CA78; continue 'dispatch;
	}
	pc = 0x82A1CA58; continue 'dispatch;
            }
            0x82A1CA58 => {
    //   block [0x82A1CA58..0x82A1CA78)
	// 82A1CA58: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A1CA5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A1CA60: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A1CA64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1CA68: 4BFFFE31  bl 0x82a1c898
	ctx.lr = 0x82A1CA6C;
	sub_82A1C898(ctx, base);
	// 82A1CA6C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A1CA70: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82A1CA74: 4099FFE4  ble cr6, 0x82a1ca58
	if !ctx.cr[6].gt {
	pc = 0x82A1CA58; continue 'dispatch;
	}
	pc = 0x82A1CA78; continue 'dispatch;
            }
            0x82A1CA78 => {
    //   block [0x82A1CA78..0x82A1CA80)
	// 82A1CA78: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1CA7C: 4828C9D8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1CA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1CA80 size=592
    let mut pc: u32 = 0x82A1CA80;
    'dispatch: loop {
        match pc {
            0x82A1CA80 => {
    //   block [0x82A1CA80..0x82A1CAE8)
	// 82A1CA80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1CA84: 4828C94D  bl 0x82ca93d0
	ctx.lr = 0x82A1CA88;
	sub_82CA93D0(ctx, base);
	// 82A1CA88: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1CA8C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A1CA90: 39C00000  li r14, 0
	ctx.r[14].s64 = 0;
	// 82A1CA94: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82A1CA98: 7DD27378  mr r18, r14
	ctx.r[18].u64 = ctx.r[14].u64;
	// 82A1CA9C: 91C10064  stw r14, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[14].u32 ) };
	// 82A1CAA0: 7C8F2378  mr r15, r4
	ctx.r[15].u64 = ctx.r[4].u64;
	// 82A1CAA4: 93A1013C  stw r29, 0x13c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), ctx.r[29].u32 ) };
	// 82A1CAA8: 817A0104  lwz r11, 0x104(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(260 as u32) ) } as u64;
	// 82A1CAAC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A1CAB0: 815A0108  lwz r10, 0x108(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(264 as u32) ) } as u64;
	// 82A1CAB4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A1CAB8: 3A8BFFFF  addi r20, r11, -1
	ctx.r[20].s64 = ctx.r[11].s64 + -1;
	// 82A1CABC: 92410060  stw r18, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[18].u32 ) };
	// 82A1CAC0: 3A0AFFFF  addi r16, r10, -1
	ctx.r[16].s64 = ctx.r[10].s64 + -1;
	// 82A1CAC4: 92810068  stw r20, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[20].u32 ) };
	// 82A1CAC8: 9201006C  stw r16, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[16].u32 ) };
	// 82A1CACC: 419A001C  beq cr6, 0x82a1cae8
	if ctx.cr[6].eq {
	pc = 0x82A1CAE8; continue 'dispatch;
	}
	// 82A1CAD0: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82A1CAD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1CAD8: 4B848FE9  bl 0x82265ac0
	ctx.lr = 0x82A1CADC;
	sub_82265AC0(ctx, base);
	// 82A1CADC: 8201006C  lwz r16, 0x6c(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A1CAE0: 82810068  lwz r20, 0x68(r1)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A1CAE4: 82410060  lwz r18, 0x60(r1)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	pc = 0x82A1CAE8; continue 'dispatch;
            }
            0x82A1CAE8 => {
    //   block [0x82A1CAE8..0x82A1CAEC)
	// 82A1CAE8: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x82A1CAEC; continue 'dispatch;
            }
            0x82A1CAEC => {
    //   block [0x82A1CAEC..0x82A1CB44)
	// 82A1CAEC: 896A0000  lbz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CAF0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1CAF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1CAF8: 409AFFF4  bne cr6, 0x82a1caec
	if !ctx.cr[6].eq {
	pc = 0x82A1CAEC; continue 'dispatch;
	}
	// 82A1CAFC: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 82A1CB00: 7D5D5050  subf r10, r29, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[29].s64;
	// 82A1CB04: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82A1CB08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1CB0C: 99610051  stb r11, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 82A1CB10: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A1CB14: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82A1CB18: 387A00EC  addi r3, r26, 0xec
	ctx.r[3].s64 = ctx.r[26].s64 + 236;
	// 82A1CB1C: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 82A1CB20: 555E003E  slwi r30, r10, 0
	ctx.r[30].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82A1CB24: 7DF87B78  mr r24, r15
	ctx.r[24].u64 = ctx.r[15].u64;
	// 82A1CB28: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82A1CB2C: 7FF3FB78  mr r19, r31
	ctx.r[19].u64 = ctx.r[31].u64;
	// 82A1CB30: 481538D9  bl 0x82b70408
	ctx.lr = 0x82A1CB34;
	sub_82B70408(ctx, base);
	// 82A1CB34: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A1CB38: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82A1CB3C: 4099018C  ble cr6, 0x82a1ccc8
	if !ctx.cr[6].gt {
	pc = 0x82A1CCC8; continue 'dispatch;
	}
	// 82A1CB40: 3A3F0006  addi r17, r31, 6
	ctx.r[17].s64 = ctx.r[31].s64 + 6;
	pc = 0x82A1CB44; continue 'dispatch;
            }
            0x82A1CB44 => {
    //   block [0x82A1CB44..0x82A1CB60)
	// 82A1CB44: 7D6EE8AE  lbzx r11, r14, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[14].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82A1CB48: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 82A1CB4C: 409A0014  bne cr6, 0x82a1cb60
	if !ctx.cr[6].eq {
	pc = 0x82A1CB60; continue 'dispatch;
	}
	// 82A1CB50: 3A73000D  addi r19, r19, 0xd
	ctx.r[19].s64 = ctx.r[19].s64 + 13;
	// 82A1CB54: 3A31000D  addi r17, r17, 0xd
	ctx.r[17].s64 = ctx.r[17].s64 + 13;
	// 82A1CB58: 7DF87B78  mr r24, r15
	ctx.r[24].u64 = ctx.r[15].u64;
	// 82A1CB5C: 48000160  b 0x82a1ccbc
	pc = 0x82A1CCBC; continue 'dispatch;
            }
            0x82A1CB60 => {
    //   block [0x82A1CB60..0x82A1CB78)
	// 82A1CB60: 3958000C  addi r10, r24, 0xc
	ctx.r[10].s64 = ctx.r[24].s64 + 12;
	// 82A1CB64: 7F0AA000  cmpw cr6, r10, r20
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[20].s32, &mut ctx.xer);
	// 82A1CB68: 40990010  ble cr6, 0x82a1cb78
	if !ctx.cr[6].gt {
	pc = 0x82A1CB78; continue 'dispatch;
	}
	// 82A1CB6C: 3A73000D  addi r19, r19, 0xd
	ctx.r[19].s64 = ctx.r[19].s64 + 13;
	// 82A1CB70: 3A31000D  addi r17, r17, 0xd
	ctx.r[17].s64 = ctx.r[17].s64 + 13;
	// 82A1CB74: 7DF87B78  mr r24, r15
	ctx.r[24].u64 = ctx.r[15].u64;
	pc = 0x82A1CB78; continue 'dispatch;
            }
            0x82A1CB78 => {
    //   block [0x82A1CB78..0x82A1CBBC)
	// 82A1CB78: 39580006  addi r10, r24, 6
	ctx.r[10].s64 = ctx.r[24].s64 + 6;
	// 82A1CB7C: 7F0A9000  cmpw cr6, r10, r18
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[18].s32, &mut ctx.xer);
	// 82A1CB80: 40990138  ble cr6, 0x82a1ccb8
	if !ctx.cr[6].gt {
	pc = 0x82A1CCB8; continue 'dispatch;
	}
	// 82A1CB84: 7F18A000  cmpw cr6, r24, r20
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[20].s32, &mut ctx.xer);
	// 82A1CB88: 41990130  bgt cr6, 0x82a1ccb8
	if ctx.cr[6].gt {
	pc = 0x82A1CCB8; continue 'dispatch;
	}
	// 82A1CB8C: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1CB90: 7F115000  cmpw cr6, r17, r10
	ctx.cr[6].compare_i32(ctx.r[17].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A1CB94: 40990124  ble cr6, 0x82a1ccb8
	if !ctx.cr[6].gt {
	pc = 0x82A1CCB8; continue 'dispatch;
	}
	// 82A1CB98: 7F138000  cmpw cr6, r19, r16
	ctx.cr[6].compare_i32(ctx.r[19].s32, ctx.r[16].s32, &mut ctx.xer);
	// 82A1CB9C: 4199011C  bgt cr6, 0x82a1ccb8
	if ctx.cr[6].gt {
	pc = 0x82A1CCB8; continue 'dispatch;
	}
	// 82A1CBA0: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A1CBA4: 815A0100  lwz r10, 0x100(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(256 as u32) ) } as u64;
	// 82A1CBA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1CBAC: 40990010  ble cr6, 0x82a1cbbc
	if !ctx.cr[6].gt {
	pc = 0x82A1CBBC; continue 'dispatch;
	}
	// 82A1CBB0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1CBB4: 7EAB5214  add r21, r11, r10
	ctx.r[21].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A1CBB8: 48000008  b 0x82a1cbc0
	pc = 0x82A1CBC0; continue 'dispatch;
            }
            0x82A1CBBC => {
    //   block [0x82A1CBBC..0x82A1CBC0)
	// 82A1CBBC: 3AAA00FC  addi r21, r10, 0xfc
	ctx.r[21].s64 = ctx.r[10].s64 + 252;
	pc = 0x82A1CBC0; continue 'dispatch;
            }
            0x82A1CBC0 => {
    //   block [0x82A1CBC0..0x82A1CBC8)
	// 82A1CBC0: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82A1CBC4: 7E7B9B78  mr r27, r19
	ctx.r[27].u64 = ctx.r[19].u64;
	pc = 0x82A1CBC8; continue 'dispatch;
            }
            0x82A1CBC8 => {
    //   block [0x82A1CBC8..0x82A1CBE0)
	// 82A1CBC8: 7ECB0E70  srawi r11, r22, 1
	ctx.xer.ca = (ctx.r[22].s32 < 0) && ((ctx.r[22].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[22].s32 >> 1) as i64;
	// 82A1CBCC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A1CBD0: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82A1CBD4: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1CBD8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A1CBDC: 5557083C  slwi r23, r10, 1
	ctx.r[23].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[23].u64 = ctx.r[23].u32 as u64;
	pc = 0x82A1CBE0; continue 'dispatch;
            }
            0x82A1CBE0 => {
    //   block [0x82A1CBE0..0x82A1CC04)
	// 82A1CBE0: 81550000  lwz r10, 0(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CBE4: 578BF87E  srwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1CBE8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A1CBEC: 7D4BB8AE  lbzx r10, r11, r23
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 82A1CBF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A1CBF4: 7D490774  extsb r9, r10
	ctx.r[9].s64 = ctx.r[10].s8 as i64;
	// 82A1CBF8: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A1CBFC: 41990008  bgt cr6, 0x82a1cc04
	if ctx.cr[6].gt {
	pc = 0x82A1CC04; continue 'dispatch;
	}
	// 82A1CC00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82A1CC04; continue 'dispatch;
            }
            0x82A1CC04 => {
    //   block [0x82A1CC04..0x82A1CC94)
	// 82A1CC04: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A1CC08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1CC0C: 419A0088  beq cr6, 0x82a1cc94
	if ctx.cr[6].eq {
	pc = 0x82A1CC94; continue 'dispatch;
	}
	// 82A1CC10: 7FBCC214  add r29, r28, r24
	ctx.r[29].u64 = ctx.r[28].u64 + ctx.r[24].u64;
	// 82A1CC14: 7F1D9000  cmpw cr6, r29, r18
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[18].s32, &mut ctx.xer);
	// 82A1CC18: 4198007C  blt cr6, 0x82a1cc94
	if ctx.cr[6].lt {
	pc = 0x82A1CC94; continue 'dispatch;
	}
	// 82A1CC1C: 7D7CC214  add r11, r28, r24
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[24].u64;
	// 82A1CC20: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 82A1CC24: 7F1EA000  cmpw cr6, r30, r20
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[20].s32, &mut ctx.xer);
	// 82A1CC28: 4199006C  bgt cr6, 0x82a1cc94
	if ctx.cr[6].gt {
	pc = 0x82A1CC94; continue 'dispatch;
	}
	// 82A1CC2C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1CC30: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A1CC34: 41980060  blt cr6, 0x82a1cc94
	if ctx.cr[6].lt {
	pc = 0x82A1CC94; continue 'dispatch;
	}
	// 82A1CC38: 3BFB0001  addi r31, r27, 1
	ctx.r[31].s64 = ctx.r[27].s64 + 1;
	// 82A1CC3C: 7F1F8000  cmpw cr6, r31, r16
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[16].s32, &mut ctx.xer);
	// 82A1CC40: 41990054  bgt cr6, 0x82a1cc94
	if ctx.cr[6].gt {
	pc = 0x82A1CC94; continue 'dispatch;
	}
	// 82A1CC44: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82A1CC48: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A1CC4C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1CC50: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A1CC54: 4BFFFC45  bl 0x82a1c898
	ctx.lr = 0x82A1CC58;
	sub_82A1C898(ctx, base);
	// 82A1CC58: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82A1CC5C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A1CC60: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1CC64: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A1CC68: 4BFFFC31  bl 0x82a1c898
	ctx.lr = 0x82A1CC6C;
	sub_82A1C898(ctx, base);
	// 82A1CC6C: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82A1CC70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A1CC74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1CC78: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A1CC7C: 4BFFFC1D  bl 0x82a1c898
	ctx.lr = 0x82A1CC80;
	sub_82A1C898(ctx, base);
	// 82A1CC80: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 82A1CC84: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A1CC88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1CC8C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A1CC90: 4BFFFC09  bl 0x82a1c898
	ctx.lr = 0x82A1CC94;
	sub_82A1C898(ctx, base);
	pc = 0x82A1CC94; continue 'dispatch;
            }
            0x82A1CC94 => {
    //   block [0x82A1CC94..0x82A1CCB8)
	// 82A1CC94: 3B9C0002  addi r28, r28, 2
	ctx.r[28].s64 = ctx.r[28].s64 + 2;
	// 82A1CC98: 2F1C000C  cmpwi cr6, r28, 0xc
	ctx.cr[6].compare_i32(ctx.r[28].s32, 12, &mut ctx.xer);
	// 82A1CC9C: 4198FF44  blt cr6, 0x82a1cbe0
	if ctx.cr[6].lt {
	pc = 0x82A1CBE0; continue 'dispatch;
	}
	// 82A1CCA0: 3AD60002  addi r22, r22, 2
	ctx.r[22].s64 = ctx.r[22].s64 + 2;
	// 82A1CCA4: 3B7B0002  addi r27, r27, 2
	ctx.r[27].s64 = ctx.r[27].s64 + 2;
	// 82A1CCA8: 2F16000C  cmpwi cr6, r22, 0xc
	ctx.cr[6].compare_i32(ctx.r[22].s32, 12, &mut ctx.xer);
	// 82A1CCAC: 4198FF1C  blt cr6, 0x82a1cbc8
	if ctx.cr[6].lt {
	pc = 0x82A1CBC8; continue 'dispatch;
	}
	// 82A1CCB0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A1CCB4: 83A1013C  lwz r29, 0x13c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	pc = 0x82A1CCB8; continue 'dispatch;
            }
            0x82A1CCB8 => {
    //   block [0x82A1CCB8..0x82A1CCBC)
	// 82A1CCB8: 3B18000C  addi r24, r24, 0xc
	ctx.r[24].s64 = ctx.r[24].s64 + 12;
	pc = 0x82A1CCBC; continue 'dispatch;
            }
            0x82A1CCBC => {
    //   block [0x82A1CCBC..0x82A1CCC8)
	// 82A1CCBC: 39CE0001  addi r14, r14, 1
	ctx.r[14].s64 = ctx.r[14].s64 + 1;
	// 82A1CCC0: 7F0EF000  cmpw cr6, r14, r30
	ctx.cr[6].compare_i32(ctx.r[14].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82A1CCC4: 4198FE80  blt cr6, 0x82a1cb44
	if ctx.cr[6].lt {
	pc = 0x82A1CB44; continue 'dispatch;
	}
	pc = 0x82A1CCC8; continue 'dispatch;
            }
            0x82A1CCC8 => {
    //   block [0x82A1CCC8..0x82A1CCD0)
	// 82A1CCC8: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82A1CCCC: 4828C754  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1CCD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1CCD0 size=80
    let mut pc: u32 = 0x82A1CCD0;
    'dispatch: loop {
        match pc {
            0x82A1CCD0 => {
    //   block [0x82A1CCD0..0x82A1CD00)
	// 82A1CCD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1CCD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1CCD8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1CCDC: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82A1CCE0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1CCE4: 394B2A40  addi r10, r11, 0x2a40
	ctx.r[10].s64 = ctx.r[11].s64 + 10816;
	// 82A1CCE8: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1CCEC: 80640004  lwz r3, 4(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1CCF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1CCF4: 90680004  stw r3, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82A1CCF8: 419A0008  beq cr6, 0x82a1cd00
	if ctx.cr[6].eq {
	pc = 0x82A1CD00; continue 'dispatch;
	}
	// 82A1CCFC: 4B7DF47D  bl 0x821fc178
	ctx.lr = 0x82A1CD00;
	sub_821FC178(ctx, base);
	pc = 0x82A1CD00; continue 'dispatch;
            }
            0x82A1CD00 => {
    //   block [0x82A1CD00..0x82A1CD20)
	// 82A1CD00: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1CD04: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 82A1CD08: 394B2A30  addi r10, r11, 0x2a30
	ctx.r[10].s64 = ctx.r[11].s64 + 10800;
	// 82A1CD0C: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1CD10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82A1CD14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1CD18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1CD1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1CD20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A1CD20 size=8
    let mut pc: u32 = 0x82A1CD20;
    'dispatch: loop {
        match pc {
            0x82A1CD20 => {
    //   block [0x82A1CD20..0x82A1CD28)
	// 82A1CD20: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1CD24: 4BFFE83C  b 0x82a1b560
	sub_82A1B560(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1CD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1CD30 size=152
    let mut pc: u32 = 0x82A1CD30;
    'dispatch: loop {
        match pc {
            0x82A1CD30 => {
    //   block [0x82A1CD30..0x82A1CDC8)
	// 82A1CD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1CD34: 4828C6D9  bl 0x82ca940c
	ctx.lr = 0x82A1CD38;
	sub_82CA93D0(ctx, base);
	// 82A1CD38: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1CD3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1CD40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1CD44: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1CD48: 482711E9  bl 0x82c8df30
	ctx.lr = 0x82A1CD4C;
	sub_82C8DF30(ctx, base);
	// 82A1CD4C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A1CD50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1CD54: 48270A55  bl 0x82c8d7a8
	ctx.lr = 0x82A1CD58;
	sub_82C8D7A8(ctx, base);
	// 82A1CD58: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1CD5C: 48271155  bl 0x82c8deb0
	ctx.lr = 0x82A1CD60;
	sub_82C8DEB0(ctx, base);
	// 82A1CD60: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CD64: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82A1CD68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1CD6C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1CD70: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 82A1CD74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1CD78: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1CD7C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A1CD80: 4E800421  bctrl
	ctx.lr = 0x82A1CD84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1CD84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1CD88: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CD8C: 48271125  bl 0x82c8deb0
	ctx.lr = 0x82A1CD90;
	sub_82C8DEB0(ctx, base);
	// 82A1CD90: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A1CD94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1CD98: 48271109  bl 0x82c8dea0
	ctx.lr = 0x82A1CD9C;
	sub_82C8DEA0(ctx, base);
	// 82A1CD9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1CDA0: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1CDA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1CDA8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1CDAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1CDB0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82A1CDB4: 4E800421  bctrl
	ctx.lr = 0x82A1CDB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1CDB8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1CDBC: 48271355  bl 0x82c8e110
	ctx.lr = 0x82A1CDC0;
	sub_82C8E110(ctx, base);
	// 82A1CDC0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1CDC4: 4828C698  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1CDC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1CDC8 size=124
    let mut pc: u32 = 0x82A1CDC8;
    'dispatch: loop {
        match pc {
            0x82A1CDC8 => {
    //   block [0x82A1CDC8..0x82A1CE44)
	// 82A1CDC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1CDCC: 4828C63D  bl 0x82ca9408
	ctx.lr = 0x82A1CDD0;
	sub_82CA93D0(ctx, base);
	// 82A1CDD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1CDD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1CDD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1CDDC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A1CDE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1CDE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1CDE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1CDEC: 4BC424DD  bl 0x8265f2c8
	ctx.lr = 0x82A1CDF0;
	sub_8265F2C8(ctx, base);
	// 82A1CDF0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CDF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1CDF8: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A1CDFC: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1CE00: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82A1CE04: 4E800421  bctrl
	ctx.lr = 0x82A1CE08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1CE08: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A1CE0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1CE10: 48251CC9  bl 0x82c6ead8
	ctx.lr = 0x82A1CE14;
	sub_82C6EAD8(ctx, base);
	// 82A1CE14: 7C9C1A14  add r4, r28, r3
	ctx.r[4].u64 = ctx.r[28].u64 + ctx.r[3].u64;
	// 82A1CE18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1CE1C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1CE20: 4826F961  bl 0x82c8c780
	ctx.lr = 0x82A1CE24;
	sub_82C8C780(ctx, base);
	// 82A1CE24: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CE28: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1CE2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1CE30: 80E80018  lwz r7, 0x18(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(24 as u32) ) } as u64;
	// 82A1CE34: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82A1CE38: 4E800421  bctrl
	ctx.lr = 0x82A1CE3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1CE3C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1CE40: 4828C618  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1CE48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1CE48 size=156
    let mut pc: u32 = 0x82A1CE48;
    'dispatch: loop {
        match pc {
            0x82A1CE48 => {
    //   block [0x82A1CE48..0x82A1CE7C)
	// 82A1CE48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1CE4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1CE50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1CE54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1CE58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1CE5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CE60: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A1CE64: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A1CE68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1CE6C: 409A0010  bne cr6, 0x82a1ce7c
	if !ctx.cr[6].eq {
	pc = 0x82A1CE7C; continue 'dispatch;
	}
	// 82A1CE70: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A1CE74: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 82A1CE78: 48000008  b 0x82a1ce80
	pc = 0x82A1CE80; continue 'dispatch;
            }
            0x82A1CE7C => {
    //   block [0x82A1CE7C..0x82A1CE80)
	// 82A1CE7C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1CE80; continue 'dispatch;
            }
            0x82A1CE80 => {
    //   block [0x82A1CE80..0x82A1CECC)
	// 82A1CE80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CE84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1CE88: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1CE8C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A1CE90: 4E800421  bctrl
	ctx.lr = 0x82A1CE94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1CE94: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1CE98: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1CE9C: 419A0030  beq cr6, 0x82a1cecc
	if ctx.cr[6].eq {
	pc = 0x82A1CECC; continue 'dispatch;
	}
	// 82A1CEA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CEA4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1CEA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1CEAC: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A1CEB0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A1CEB4: 4E800421  bctrl
	ctx.lr = 0x82A1CEB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1CEB8: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CEBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1CEC0: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1CEC4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A1CEC8: 4E800421  bctrl
	ctx.lr = 0x82A1CECC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A1CECC => {
    //   block [0x82A1CECC..0x82A1CEE4)
	// 82A1CECC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1CED0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1CED4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1CED8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1CEDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1CEE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1CEE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1CEE8 size=184
    let mut pc: u32 = 0x82A1CEE8;
    'dispatch: loop {
        match pc {
            0x82A1CEE8 => {
    //   block [0x82A1CEE8..0x82A1CF1C)
	// 82A1CEE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1CEEC: 4828C51D  bl 0x82ca9408
	ctx.lr = 0x82A1CEF0;
	sub_82CA93D0(ctx, base);
	// 82A1CEF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1CEF4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A1CEF8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 82A1CEFC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A1CF00: 3BCAFFDF  addi r30, r10, -0x21
	ctx.r[30].s64 = ctx.r[10].s64 + -33;
	// 82A1CF04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1CF08: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CF0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1CF10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1CF14: 419A0008  beq cr6, 0x82a1cf1c
	if ctx.cr[6].eq {
	pc = 0x82A1CF1C; continue 'dispatch;
	}
	// 82A1CF18: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1CF1C; continue 'dispatch;
            }
            0x82A1CF1C => {
    //   block [0x82A1CF1C..0x82A1CF38)
	// 82A1CF1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1CF20: 4826BDB9  bl 0x82c88cd8
	ctx.lr = 0x82A1CF24;
	sub_82C88CD8(ctx, base);
	// 82A1CF24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CF28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1CF2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1CF30: 419A0008  beq cr6, 0x82a1cf38
	if ctx.cr[6].eq {
	pc = 0x82A1CF38; continue 'dispatch;
	}
	// 82A1CF34: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1CF38; continue 'dispatch;
            }
            0x82A1CF38 => {
    //   block [0x82A1CF38..0x82A1CF84)
	// 82A1CF38: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CF3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1CF40: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1CF44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A1CF48: 4E800421  bctrl
	ctx.lr = 0x82A1CF4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1CF4C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1CF50: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1CF54: 419A0030  beq cr6, 0x82a1cf84
	if ctx.cr[6].eq {
	pc = 0x82A1CF84; continue 'dispatch;
	}
	// 82A1CF58: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CF5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1CF60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1CF64: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1CF68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A1CF6C: 4E800421  bctrl
	ctx.lr = 0x82A1CF70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1CF70: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CF74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1CF78: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1CF7C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A1CF80: 4E800421  bctrl
	ctx.lr = 0x82A1CF84;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A1CF84 => {
    //   block [0x82A1CF84..0x82A1CFA0)
	// 82A1CF84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1CF88: 4826B7D1  bl 0x82c88758
	ctx.lr = 0x82A1CF8C;
	sub_82C88758(ctx, base);
	// 82A1CF8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1CF90: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1CF94: 4B8584A5  bl 0x82275438
	ctx.lr = 0x82A1CF98;
	sub_82275438(ctx, base);
	// 82A1CF98: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1CF9C: 4828C4BC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1CFA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1CFA0 size=264
    let mut pc: u32 = 0x82A1CFA0;
    'dispatch: loop {
        match pc {
            0x82A1CFA0 => {
    //   block [0x82A1CFA0..0x82A1CFD0)
	// 82A1CFA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1CFA4: 4828C469  bl 0x82ca940c
	ctx.lr = 0x82A1CFA8;
	sub_82CA93D0(ctx, base);
	// 82A1CFA8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1CFAC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82A1CFB0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1CFB4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1CFB8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CFBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1CFC0: 409A0010  bne cr6, 0x82a1cfd0
	if !ctx.cr[6].eq {
	pc = 0x82A1CFD0; continue 'dispatch;
	}
	// 82A1CFC4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A1CFC8: 388B9218  addi r4, r11, -0x6de8
	ctx.r[4].s64 = ctx.r[11].s64 + -28136;
	// 82A1CFCC: 48000008  b 0x82a1cfd4
	pc = 0x82A1CFD4; continue 'dispatch;
            }
            0x82A1CFD0 => {
    //   block [0x82A1CFD0..0x82A1CFD4)
	// 82A1CFD0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1CFD4; continue 'dispatch;
            }
            0x82A1CFD4 => {
    //   block [0x82A1CFD4..0x82A1D004)
	// 82A1CFD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1CFD8: 4B9C24D9  bl 0x823df4b0
	ctx.lr = 0x82A1CFDC;
	sub_823DF4B0(ctx, base);
	// 82A1CFDC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A1CFE0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1CFE4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1CFE8: 4826BCF1  bl 0x82c88cd8
	ctx.lr = 0x82A1CFEC;
	sub_82C88CD8(ctx, base);
	// 82A1CFEC: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1CFF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1CFF4: 419A0010  beq cr6, 0x82a1d004
	if ctx.cr[6].eq {
	pc = 0x82A1D004; continue 'dispatch;
	}
	// 82A1CFF8: 4B7FED41  bl 0x8221bd38
	ctx.lr = 0x82A1CFFC;
	sub_8221BD38(ctx, base);
	// 82A1CFFC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1D000: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82A1D004; continue 'dispatch;
            }
            0x82A1D004 => {
    //   block [0x82A1D004..0x82A1D01C)
	// 82A1D004: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1D00C: 409A0010  bne cr6, 0x82a1d01c
	if !ctx.cr[6].eq {
	pc = 0x82A1D01C; continue 'dispatch;
	}
	// 82A1D010: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A1D014: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 82A1D018: 48000008  b 0x82a1d020
	pc = 0x82A1D020; continue 'dispatch;
            }
            0x82A1D01C => {
    //   block [0x82A1D01C..0x82A1D020)
	// 82A1D01C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1D020; continue 'dispatch;
            }
            0x82A1D020 => {
    //   block [0x82A1D020..0x82A1D06C)
	// 82A1D020: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D024: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D028: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1D02C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A1D030: 4E800421  bctrl
	ctx.lr = 0x82A1D034;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1D034: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1D038: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1D03C: 419A0030  beq cr6, 0x82a1d06c
	if ctx.cr[6].eq {
	pc = 0x82A1D06C; continue 'dispatch;
	}
	// 82A1D040: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D044: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A1D048: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D04C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1D050: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A1D054: 4E800421  bctrl
	ctx.lr = 0x82A1D058;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1D058: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D05C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D060: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1D064: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A1D068: 4E800421  bctrl
	ctx.lr = 0x82A1D06C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A1D06C => {
    //   block [0x82A1D06C..0x82A1D0A0)
	// 82A1D06C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1D070: 4826B6E9  bl 0x82c88758
	ctx.lr = 0x82A1D074;
	sub_82C88758(ctx, base);
	// 82A1D074: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D078: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1D07C: 4B9C24FD  bl 0x823df578
	ctx.lr = 0x82A1D080;
	sub_823DF578(ctx, base);
	// 82A1D080: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82A1D084: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1D088: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D08C: 48121C65  bl 0x82b3ecf0
	ctx.lr = 0x82A1D090;
	sub_82B3ECF0(ctx, base);
	// 82A1D090: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A1D094: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1D098: 419A0008  beq cr6, 0x82a1d0a0
	if ctx.cr[6].eq {
	pc = 0x82A1D0A0; continue 'dispatch;
	}
	// 82A1D09C: 4B7FEC9D  bl 0x8221bd38
	ctx.lr = 0x82A1D0A0;
	sub_8221BD38(ctx, base);
	pc = 0x82A1D0A0; continue 'dispatch;
            }
            0x82A1D0A0 => {
    //   block [0x82A1D0A0..0x82A1D0A8)
	// 82A1D0A0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1D0A4: 4828C3B8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D0A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D0A8 size=192
    let mut pc: u32 = 0x82A1D0A8;
    'dispatch: loop {
        match pc {
            0x82A1D0A8 => {
    //   block [0x82A1D0A8..0x82A1D0DC)
	// 82A1D0A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D0AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1D0B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1D0B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1D0B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D0BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D0C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A1D0C4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A1D0C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1D0CC: 409A0010  bne cr6, 0x82a1d0dc
	if !ctx.cr[6].eq {
	pc = 0x82A1D0DC; continue 'dispatch;
	}
	// 82A1D0D0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A1D0D4: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 82A1D0D8: 48000008  b 0x82a1d0e0
	pc = 0x82A1D0E0; continue 'dispatch;
            }
            0x82A1D0DC => {
    //   block [0x82A1D0DC..0x82A1D0E0)
	// 82A1D0DC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1D0E0; continue 'dispatch;
            }
            0x82A1D0E0 => {
    //   block [0x82A1D0E0..0x82A1D150)
	// 82A1D0E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D0E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D0E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1D0EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A1D0F0: 4E800421  bctrl
	ctx.lr = 0x82A1D0F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1D0F4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1D0F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1D0FC: 419A0054  beq cr6, 0x82a1d150
	if ctx.cr[6].eq {
	pc = 0x82A1D150; continue 'dispatch;
	}
	// 82A1D100: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1D104: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A1D108: 388B06D4  addi r4, r11, 0x6d4
	ctx.r[4].s64 = ctx.r[11].s64 + 1748;
	// 82A1D10C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D110: 4BA63741  bl 0x82480850
	ctx.lr = 0x82A1D114;
	sub_82480850(ctx, base);
	// 82A1D114: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A1D118: 38BE0004  addi r5, r30, 4
	ctx.r[5].s64 = ctx.r[30].s64 + 4;
	// 82A1D11C: 388A06D8  addi r4, r10, 0x6d8
	ctx.r[4].s64 = ctx.r[10].s64 + 1752;
	// 82A1D120: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D124: 4BA6372D  bl 0x82480850
	ctx.lr = 0x82A1D128;
	sub_82480850(ctx, base);
	// 82A1D128: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82A1D12C: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 82A1D130: 3889C2C8  addi r4, r9, -0x3d38
	ctx.r[4].s64 = ctx.r[9].s64 + -15672;
	// 82A1D134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D138: 4BA63719  bl 0x82480850
	ctx.lr = 0x82A1D13C;
	sub_82480850(ctx, base);
	// 82A1D13C: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D144: 80E8000C  lwz r7, 0xc(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1D148: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82A1D14C: 4E800421  bctrl
	ctx.lr = 0x82A1D150;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A1D150 => {
    //   block [0x82A1D150..0x82A1D168)
	// 82A1D150: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1D154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1D158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1D15C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1D160: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1D164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D168 size=212
    let mut pc: u32 = 0x82A1D168;
    'dispatch: loop {
        match pc {
            0x82A1D168 => {
    //   block [0x82A1D168..0x82A1D19C)
	// 82A1D168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D16C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1D170: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1D174: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1D178: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D17C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D180: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A1D184: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A1D188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1D18C: 409A0010  bne cr6, 0x82a1d19c
	if !ctx.cr[6].eq {
	pc = 0x82A1D19C; continue 'dispatch;
	}
	// 82A1D190: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A1D194: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 82A1D198: 48000008  b 0x82a1d1a0
	pc = 0x82A1D1A0; continue 'dispatch;
            }
            0x82A1D19C => {
    //   block [0x82A1D19C..0x82A1D1A0)
	// 82A1D19C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1D1A0; continue 'dispatch;
            }
            0x82A1D1A0 => {
    //   block [0x82A1D1A0..0x82A1D224)
	// 82A1D1A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D1A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D1A8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1D1AC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A1D1B0: 4E800421  bctrl
	ctx.lr = 0x82A1D1B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1D1B4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1D1B8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1D1BC: 419A0068  beq cr6, 0x82a1d224
	if ctx.cr[6].eq {
	pc = 0x82A1D224; continue 'dispatch;
	}
	// 82A1D1C0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1D1C4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A1D1C8: 388B06D4  addi r4, r11, 0x6d4
	ctx.r[4].s64 = ctx.r[11].s64 + 1748;
	// 82A1D1CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D1D0: 4BA63681  bl 0x82480850
	ctx.lr = 0x82A1D1D4;
	sub_82480850(ctx, base);
	// 82A1D1D4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A1D1D8: 38BE0004  addi r5, r30, 4
	ctx.r[5].s64 = ctx.r[30].s64 + 4;
	// 82A1D1DC: 388A06D8  addi r4, r10, 0x6d8
	ctx.r[4].s64 = ctx.r[10].s64 + 1752;
	// 82A1D1E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D1E4: 4BA6366D  bl 0x82480850
	ctx.lr = 0x82A1D1E8;
	sub_82480850(ctx, base);
	// 82A1D1E8: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 82A1D1EC: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 82A1D1F0: 3889C2C8  addi r4, r9, -0x3d38
	ctx.r[4].s64 = ctx.r[9].s64 + -15672;
	// 82A1D1F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D1F8: 4BA63659  bl 0x82480850
	ctx.lr = 0x82A1D1FC;
	sub_82480850(ctx, base);
	// 82A1D1FC: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 82A1D200: 38BE000C  addi r5, r30, 0xc
	ctx.r[5].s64 = ctx.r[30].s64 + 12;
	// 82A1D204: 388821B8  addi r4, r8, 0x21b8
	ctx.r[4].s64 = ctx.r[8].s64 + 8632;
	// 82A1D208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D20C: 4BA63645  bl 0x82480850
	ctx.lr = 0x82A1D210;
	sub_82480850(ctx, base);
	// 82A1D210: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D214: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D218: 80C7000C  lwz r6, 0xc(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1D21C: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82A1D220: 4E800421  bctrl
	ctx.lr = 0x82A1D224;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A1D224 => {
    //   block [0x82A1D224..0x82A1D23C)
	// 82A1D224: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1D228: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1D22C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1D230: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1D234: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1D238: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D240 size=240
    let mut pc: u32 = 0x82A1D240;
    'dispatch: loop {
        match pc {
            0x82A1D240 => {
    //   block [0x82A1D240..0x82A1D274)
	// 82A1D240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D244: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1D248: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1D24C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1D250: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D254: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D258: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A1D25C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A1D260: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1D264: 409A0010  bne cr6, 0x82a1d274
	if !ctx.cr[6].eq {
	pc = 0x82A1D274; continue 'dispatch;
	}
	// 82A1D268: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A1D26C: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 82A1D270: 48000008  b 0x82a1d278
	pc = 0x82A1D278; continue 'dispatch;
            }
            0x82A1D274 => {
    //   block [0x82A1D274..0x82A1D278)
	// 82A1D274: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1D278; continue 'dispatch;
            }
            0x82A1D278 => {
    //   block [0x82A1D278..0x82A1D318)
	// 82A1D278: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D27C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D280: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1D284: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A1D288: 4E800421  bctrl
	ctx.lr = 0x82A1D28C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1D28C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1D290: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1D294: 419A0084  beq cr6, 0x82a1d318
	if ctx.cr[6].eq {
	pc = 0x82A1D318; continue 'dispatch;
	}
	// 82A1D298: 897E0002  lbz r11, 2(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 82A1D29C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A1D2A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A1D2A4: 388AABCC  addi r4, r10, -0x5434
	ctx.r[4].s64 = ctx.r[10].s64 + -21556;
	// 82A1D2A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D2AC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A1D2B0: 4BA63519  bl 0x824807c8
	ctx.lr = 0x82A1D2B4;
	sub_824807C8(ctx, base);
	// 82A1D2B4: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1D2B8: 88FE0001  lbz r7, 1(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1 as u32) ) } as u64;
	// 82A1D2BC: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82A1D2C0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A1D2C4: 3889ABD0  addi r4, r9, -0x5430
	ctx.r[4].s64 = ctx.r[9].s64 + -21552;
	// 82A1D2C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D2CC: 991E0002  stb r8, 2(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(2 as u32), ctx.r[8].u8 ) };
	// 82A1D2D0: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 82A1D2D4: 4BA634F5  bl 0x824807c8
	ctx.lr = 0x82A1D2D8;
	sub_824807C8(ctx, base);
	// 82A1D2D8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A1D2DC: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D2E0: 3C80820B  lis r4, -0x7df5
	ctx.r[4].s64 = -2113208320;
	// 82A1D2E4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A1D2E8: 3884ABD8  addi r4, r4, -0x5428
	ctx.r[4].s64 = ctx.r[4].s64 + -21544;
	// 82A1D2EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D2F0: 997E0001  stb r11, 1(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82A1D2F4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82A1D2F8: 4BA634D1  bl 0x824807c8
	ctx.lr = 0x82A1D2FC;
	sub_824807C8(ctx, base);
	// 82A1D2FC: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A1D300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D304: 991E0000  stb r8, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 82A1D308: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D30C: 80A6000C  lwz r5, 0xc(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1D310: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 82A1D314: 4E800421  bctrl
	ctx.lr = 0x82A1D318;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A1D318 => {
    //   block [0x82A1D318..0x82A1D330)
	// 82A1D318: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1D31C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1D320: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1D324: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1D328: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1D32C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D330 size=168
    let mut pc: u32 = 0x82A1D330;
    'dispatch: loop {
        match pc {
            0x82A1D330 => {
    //   block [0x82A1D330..0x82A1D364)
	// 82A1D330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1D338: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1D33C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1D340: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D344: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D348: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A1D34C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A1D350: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1D354: 409A0010  bne cr6, 0x82a1d364
	if !ctx.cr[6].eq {
	pc = 0x82A1D364; continue 'dispatch;
	}
	// 82A1D358: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A1D35C: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 82A1D360: 48000008  b 0x82a1d368
	pc = 0x82A1D368; continue 'dispatch;
            }
            0x82A1D364 => {
    //   block [0x82A1D364..0x82A1D368)
	// 82A1D364: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1D368; continue 'dispatch;
            }
            0x82A1D368 => {
    //   block [0x82A1D368..0x82A1D3C0)
	// 82A1D368: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D36C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D370: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1D374: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A1D378: 4E800421  bctrl
	ctx.lr = 0x82A1D37C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1D37C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1D380: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1D384: 419A003C  beq cr6, 0x82a1d3c0
	if ctx.cr[6].eq {
	pc = 0x82A1D3C0; continue 'dispatch;
	}
	// 82A1D388: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D38C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A1D390: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A1D394: 388A9A68  addi r4, r10, -0x6598
	ctx.r[4].s64 = ctx.r[10].s64 + -26008;
	// 82A1D398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D39C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A1D3A0: 4B972CE9  bl 0x82390088
	ctx.lr = 0x82A1D3A4;
	sub_82390088(ctx, base);
	// 82A1D3A4: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1D3A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D3AC: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A1D3B0: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D3B4: 80E8000C  lwz r7, 0xc(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1D3B8: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82A1D3BC: 4E800421  bctrl
	ctx.lr = 0x82A1D3C0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A1D3C0 => {
    //   block [0x82A1D3C0..0x82A1D3D8)
	// 82A1D3C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1D3C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1D3C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1D3CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1D3D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1D3D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1D3D8 size=220
    let mut pc: u32 = 0x82A1D3D8;
    'dispatch: loop {
        match pc {
            0x82A1D3D8 => {
    //   block [0x82A1D3D8..0x82A1D43C)
	// 82A1D3D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D3DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1D3E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1D3E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1D3E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D3EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D3F0: 48002AE9  bl 0x82a1fed8
	ctx.lr = 0x82A1D3F4;
	sub_82A1FED8(ctx, base);
	// 82A1D3F4: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1D3F8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A1D3FC: 394B2A74  addi r10, r11, 0x2a74
	ctx.r[10].s64 = ctx.r[11].s64 + 10868;
	// 82A1D400: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82A1D404: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 82A1D408: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1D40C: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82A1D410: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82A1D414: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82A1D418: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 82A1D41C: 4B90376D  bl 0x82320b88
	ctx.lr = 0x82A1D420;
	sub_82320B88(ctx, base);
	// 82A1D420: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82A1D424: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82A1D428: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 82A1D42C: 38A97088  addi r5, r9, 0x7088
	ctx.r[5].s64 = ctx.r[9].s64 + 28808;
	// 82A1D430: 90DF004C  stw r6, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[6].u32 ) };
	// 82A1D434: 93DF0050  stw r30, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82A1D438: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	pc = 0x82A1D43C; continue 'dispatch;
            }
            0x82A1D43C => {
    //   block [0x82A1D43C..0x82A1D45C)
	// 82A1D43C: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 82A1D440: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1D444: 7D002028  lwarx r8, 0, r4
	// lwarx
	let ea = ctx.r[4].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 82A1D448: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82A1D44C: 7D00212D  stwcx. r8, 0, r4
	// stwcx.
	let addr = ctx.r[4].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1D450: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1D454: 4082FFE8  bne 0x82a1d43c
	if !ctx.cr[0].eq {
	pc = 0x82A1D43C; continue 'dispatch;
	}
	// 82A1D458: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x82A1D45C; continue 'dispatch;
            }
            0x82A1D45C => {
    //   block [0x82A1D45C..0x82A1D4B4)
	// 82A1D45C: 7D6000A6  mfmsr r11
	ctx.r[11].u64 = ctx.msr;
	// 82A1D460: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1D464: 7C602828  lwarx r3, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[3].u64 = ctx.reserved.u32 as u64;
	// 82A1D468: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 82A1D46C: 7C60292D  stwcx. r3, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[3].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1D470: 7D610164  mtmsrd r11, 1
	ctx.msr = (ctx.r[11].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1D474: 4082FFE8  bne 0x82a1d45c
	if !ctx.cr[0].eq {
	pc = 0x82A1D45C; continue 'dispatch;
	}
	// 82A1D478: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A1D47C: 9BDF0058  stb r30, 0x58(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u8 ) };
	// 82A1D480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D484: 392A9484  addi r9, r10, -0x6b7c
	ctx.r[9].s64 = ctx.r[10].s64 + -27516;
	// 82A1D488: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A1D48C: C1A9000C  lfs f13, 0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82A1D490: D1BF005C  stfs f13, 0x5c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82A1D494: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82A1D498: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82A1D49C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1D4A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1D4A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1D4A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1D4AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1D4B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D4B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D4B8 size=132
    let mut pc: u32 = 0x82A1D4B8;
    'dispatch: loop {
        match pc {
            0x82A1D4B8 => {
    //   block [0x82A1D4B8..0x82A1D524)
	// 82A1D4B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D4BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1D4C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1D4C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1D4C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D4CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D4D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1D4D4: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 82A1D4D8: 4B7F7901  bl 0x82214dd8
	ctx.lr = 0x82A1D4DC;
	sub_82214DD8(ctx, base);
	// 82A1D4DC: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82A1D4E0: 4B7F78F9  bl 0x82214dd8
	ctx.lr = 0x82A1D4E4;
	sub_82214DD8(ctx, base);
	// 82A1D4E4: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 82A1D4E8: 4B905301  bl 0x823227e8
	ctx.lr = 0x82A1D4EC;
	sub_823227E8(ctx, base);
	// 82A1D4EC: 807F0040  lwz r3, 0x40(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82A1D4F0: 4B7FE849  bl 0x8221bd38
	ctx.lr = 0x82A1D4F4;
	sub_8221BD38(ctx, base);
	// 82A1D4F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A1D4F8: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82A1D4FC: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82A1D500: 48001B51  bl 0x82a1f050
	ctx.lr = 0x82A1D504;
	sub_82A1F050(ctx, base);
	// 82A1D504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D508: 48002BB9  bl 0x82a200c0
	ctx.lr = 0x82A1D50C;
	sub_82A200C0(ctx, base);
	// 82A1D50C: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A1D510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D514: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1D518: 419A000C  beq cr6, 0x82a1d524
	if ctx.cr[6].eq {
	pc = 0x82A1D524; continue 'dispatch;
	}
	// 82A1D51C: 4B7FE81D  bl 0x8221bd38
	ctx.lr = 0x82A1D520;
	sub_8221BD38(ctx, base);
	// 82A1D520: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A1D524; continue 'dispatch;
            }
            0x82A1D524 => {
    //   block [0x82A1D524..0x82A1D53C)
	// 82A1D524: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1D528: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1D52C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1D530: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1D534: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1D538: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1D540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1D540 size=3308
    let mut pc: u32 = 0x82A1D540;
    'dispatch: loop {
        match pc {
            0x82A1D540 => {
    //   block [0x82A1D540..0x82A1D5F0)
	// 82A1D540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1D544: 4828BE91  bl 0x82ca93d4
	ctx.lr = 0x82A1D548;
	sub_82CA93D0(ctx, base);
	// 82A1D548: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1D54C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A1D550: 3A200000  li r17, 0
	ctx.r[17].s64 = 0;
	// 82A1D554: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82A1D558: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1D55C: 7E3B8B78  mr r27, r17
	ctx.r[27].u64 = ctx.r[17].u64;
	// 82A1D560: 816BE9EC  lwz r11, -0x1614(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5652 as u32) ) } as u64;
	// 82A1D564: 7E3A8B78  mr r26, r17
	ctx.r[26].u64 = ctx.r[17].u64;
	// 82A1D568: 7E3D8B78  mr r29, r17
	ctx.r[29].u64 = ctx.r[17].u64;
	// 82A1D56C: 7E3C8B78  mr r28, r17
	ctx.r[28].u64 = ctx.r[17].u64;
	// 82A1D570: 806B0024  lwz r3, 0x24(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A1D574: 4BFE1DBD  bl 0x829ff330
	ctx.lr = 0x82A1D578;
	sub_829FF330(ctx, base);
	// 82A1D578: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1D57C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A1D580: 419A0070  beq cr6, 0x82a1d5f0
	if ctx.cr[6].eq {
	pc = 0x82A1D5F0; continue 'dispatch;
	}
	// 82A1D584: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D588: 3880001D  li r4, 0x1d
	ctx.r[4].s64 = 29;
	// 82A1D58C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A1D590: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A1D594: 4E800421  bctrl
	ctx.lr = 0x82A1D598;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1D598: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D59C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A1D5A0: 38800067  li r4, 0x67
	ctx.r[4].s64 = 103;
	// 82A1D5A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D5A8: 8109001C  lwz r8, 0x1c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A1D5AC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A1D5B0: 4E800421  bctrl
	ctx.lr = 0x82A1D5B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1D5B4: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D5B8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82A1D5BC: 38800038  li r4, 0x38
	ctx.r[4].s64 = 56;
	// 82A1D5C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D5C4: 80C7001C  lwz r6, 0x1c(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A1D5C8: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82A1D5CC: 4E800421  bctrl
	ctx.lr = 0x82A1D5D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1D5D0: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D5D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A1D5D8: 3880006B  li r4, 0x6b
	ctx.r[4].s64 = 107;
	// 82A1D5DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1D5E0: 8165001C  lwz r11, 0x1c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A1D5E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1D5E8: 4E800421  bctrl
	ctx.lr = 0x82A1D5EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1D5EC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
            }
            0x82A1D5F0 => {
    //   block [0x82A1D5F0..0x82A1D618)
	// 82A1D5F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1D5F4: 7E2F8B78  mr r15, r17
	ctx.r[15].u64 = ctx.r[17].u64;
	// 82A1D5F8: 2F1E006D  cmpwi cr6, r30, 0x6d
	ctx.cr[6].compare_i32(ctx.r[30].s32, 109, &mut ctx.xer);
	// 82A1D5FC: 3A0B0CA0  addi r16, r11, 0xca0
	ctx.r[16].s64 = ctx.r[11].s64 + 3232;
	// 82A1D600: 409A0018  bne cr6, 0x82a1d618
	if !ctx.cr[6].eq {
	pc = 0x82A1D618; continue 'dispatch;
	}
	// 82A1D604: 8178004C  lwz r11, 0x4c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A1D608: 39E00001  li r15, 1
	ctx.r[15].s64 = 1;
	// 82A1D60C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A1D610: 9178004C  stw r11, 0x4c(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82A1D614: 48000AD8  b 0x82a1e0ec
	pc = 0x82A1E0EC; continue 'dispatch;
            }
            0x82A1D618 => {
    //   block [0x82A1D618..0x82A1D634)
	// 82A1D618: 2F1E0072  cmpwi cr6, r30, 0x72
	ctx.cr[6].compare_i32(ctx.r[30].s32, 114, &mut ctx.xer);
	// 82A1D61C: 409A0018  bne cr6, 0x82a1d634
	if !ctx.cr[6].eq {
	pc = 0x82A1D634; continue 'dispatch;
	}
	// 82A1D620: 8178004C  lwz r11, 0x4c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A1D624: 39E00001  li r15, 1
	ctx.r[15].s64 = 1;
	// 82A1D628: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A1D62C: 9178004C  stw r11, 0x4c(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82A1D630: 48000ABC  b 0x82a1e0ec
	pc = 0x82A1E0EC; continue 'dispatch;
            }
            0x82A1D634 => {
    //   block [0x82A1D634..0x82A1D670)
	// 82A1D634: 2F1E000F  cmpwi cr6, r30, 0xf
	ctx.cr[6].compare_i32(ctx.r[30].s32, 15, &mut ctx.xer);
	// 82A1D638: 409A0644  bne cr6, 0x82a1dc7c
	if !ctx.cr[6].eq {
	pc = 0x82A1DC7C; continue 'dispatch;
	}
	// 82A1D63C: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1D640: 7E338B78  mr r19, r17
	ctx.r[19].u64 = ctx.r[17].u64;
	// 82A1D644: 81580048  lwz r10, 0x48(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(72 as u32) ) } as u64;
	// 82A1D648: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A1D64C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1D650: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1D654: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82A1D658: 7CF21E70  srawi r18, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[18].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 82A1D65C: 409A0014  bne cr6, 0x82a1d670
	if !ctx.cr[6].eq {
	pc = 0x82A1D670; continue 'dispatch;
	}
	// 82A1D660: 38980008  addi r4, r24, 8
	ctx.r[4].s64 = ctx.r[24].s64 + 8;
	// 82A1D664: 38780050  addi r3, r24, 0x50
	ctx.r[3].s64 = ctx.r[24].s64 + 80;
	// 82A1D668: 4B847B39  bl 0x822651a0
	ctx.lr = 0x82A1D66C;
	sub_822651A0(ctx, base);
	// 82A1D66C: 3A600001  li r19, 1
	ctx.r[19].s64 = 1;
	pc = 0x82A1D670; continue 'dispatch;
            }
            0x82A1D670 => {
    //   block [0x82A1D670..0x82A1D688)
	// 82A1D670: 81780050  lwz r11, 0x50(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1D674: 3AD80050  addi r22, r24, 0x50
	ctx.r[22].s64 = ctx.r[24].s64 + 80;
	// 82A1D678: 7E3D8B78  mr r29, r17
	ctx.r[29].u64 = ctx.r[17].u64;
	// 82A1D67C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1D680: 419A0008  beq cr6, 0x82a1d688
	if ctx.cr[6].eq {
	pc = 0x82A1D688; continue 'dispatch;
	}
	// 82A1D684: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A1D688; continue 'dispatch;
            }
            0x82A1D688 => {
    //   block [0x82A1D688..0x82A1D6A0)
	// 82A1D688: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A1D68C: 9221005C  stw r17, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[17].u32 ) };
	// 82A1D690: 7E3A8B78  mr r26, r17
	ctx.r[26].u64 = ctx.r[17].u64;
	// 82A1D694: 3A8B7088  addi r20, r11, 0x7088
	ctx.r[20].s64 = ctx.r[11].s64 + 28808;
	// 82A1D698: 7E398B78  mr r25, r17
	ctx.r[25].u64 = ctx.r[17].u64;
	// 82A1D69C: 7E88A378  mr r8, r20
	ctx.r[8].u64 = ctx.r[20].u64;
	pc = 0x82A1D6A0; continue 'dispatch;
            }
            0x82A1D6A0 => {
    //   block [0x82A1D6A0..0x82A1D6E0)
	// 82A1D6A0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1D6A4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1D6A8: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1D6AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1D6B0: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1D6B4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1D6B8: 4082FFE8  bne 0x82a1d6a0
	if !ctx.cr[0].eq {
	pc = 0x82A1D6A0; continue 'dispatch;
	}
	// 82A1D6BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1D6C0: 7FB7EB78  mr r23, r29
	ctx.r[23].u64 = ctx.r[29].u64;
	// 82A1D6C4: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82A1D6C8: 4B9034C1  bl 0x82320b88
	ctx.lr = 0x82A1D6CC;
	sub_82320B88(ctx, base);
	// 82A1D6CC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A1D6D0: 37FDFFFF  addic. r31, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A1D6D4: 3AABFFDF  addi r21, r11, -0x21
	ctx.r[21].s64 = ctx.r[11].s64 + -33;
	// 82A1D6D8: 418001E0  blt 0x82a1d8b8
	if ctx.cr[0].lt {
	pc = 0x82A1D8B8; continue 'dispatch;
	}
	// 82A1D6DC: 3B7F0001  addi r27, r31, 1
	ctx.r[27].s64 = ctx.r[31].s64 + 1;
	pc = 0x82A1D6E0; continue 'dispatch;
            }
            0x82A1D6E0 => {
    //   block [0x82A1D6E0..0x82A1D6F4)
	// 82A1D6E0: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D6E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1D6E8: 409A000C  bne cr6, 0x82a1d6f4
	if !ctx.cr[6].eq {
	pc = 0x82A1D6F4; continue 'dispatch;
	}
	// 82A1D6EC: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 82A1D6F0: 48000008  b 0x82a1d6f8
	pc = 0x82A1D6F8; continue 'dispatch;
            }
            0x82A1D6F4 => {
    //   block [0x82A1D6F4..0x82A1D6F8)
	// 82A1D6F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1D6F8; continue 'dispatch;
            }
            0x82A1D6F8 => {
    //   block [0x82A1D6F8..0x82A1D7B4)
	// 82A1D6F8: 7D6BF8AE  lbzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82A1D6FC: 574A063E  clrlwi r10, r26, 0x18
	ctx.r[10].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 82A1D700: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1D704: 7D7E0774  extsb r30, r11
	ctx.r[30].s64 = ctx.r[11].s8 as i64;
	// 82A1D708: 409A00E0  bne cr6, 0x82a1d7e8
	if !ctx.cr[6].eq {
	pc = 0x82A1D7E8; continue 'dispatch;
	}
	// 82A1D70C: 2F1E002E  cmpwi cr6, r30, 0x2e
	ctx.cr[6].compare_i32(ctx.r[30].s32, 46, &mut ctx.xer);
	// 82A1D710: 419A00A4  beq cr6, 0x82a1d7b4
	if ctx.cr[6].eq {
	pc = 0x82A1D7B4; continue 'dispatch;
	}
	// 82A1D714: 2F1E003A  cmpwi cr6, r30, 0x3a
	ctx.cr[6].compare_i32(ctx.r[30].s32, 58, &mut ctx.xer);
	// 82A1D718: 419A009C  beq cr6, 0x82a1d7b4
	if ctx.cr[6].eq {
	pc = 0x82A1D7B4; continue 'dispatch;
	}
	// 82A1D71C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D720: 4828FBC1  bl 0x82cad2e0
	ctx.lr = 0x82A1D724;
	sub_82CAD2E0(ctx, base);
	// 82A1D724: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A1D728: 409A013C  bne cr6, 0x82a1d864
	if !ctx.cr[6].eq {
	pc = 0x82A1D864; continue 'dispatch;
	}
	// 82A1D72C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D730: 4828FC11  bl 0x82cad340
	ctx.lr = 0x82A1D734;
	sub_82CAD340(ctx, base);
	// 82A1D734: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A1D738: 409A012C  bne cr6, 0x82a1d864
	if !ctx.cr[6].eq {
	pc = 0x82A1D864; continue 'dispatch;
	}
	// 82A1D73C: 2F1E005F  cmpwi cr6, r30, 0x5f
	ctx.cr[6].compare_i32(ctx.r[30].s32, 95, &mut ctx.xer);
	// 82A1D740: 419A0124  beq cr6, 0x82a1d864
	if ctx.cr[6].eq {
	pc = 0x82A1D864; continue 'dispatch;
	}
	// 82A1D744: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A1D748: 38BF0001  addi r5, r31, 1
	ctx.r[5].s64 = ctx.r[31].s64 + 1;
	// 82A1D74C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82A1D750: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D754: 4B7C663D  bl 0x821e3d90
	ctx.lr = 0x82A1D758;
	sub_821E3D90(ctx, base);
	// 82A1D758: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D75C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A1D760: 4B847A41  bl 0x822651a0
	ctx.lr = 0x82A1D764;
	sub_822651A0(ctx, base);
	// 82A1D764: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D768: 4B7F7671  bl 0x82214dd8
	ctx.lr = 0x82A1D76C;
	sub_82214DD8(ctx, base);
	// 82A1D76C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1D770: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A1D774: 388BE454  addi r4, r11, -0x1bac
	ctx.r[4].s64 = ctx.r[11].s64 + -7084;
	// 82A1D778: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D77C: 4B80F755  bl 0x8222ced0
	ctx.lr = 0x82A1D780;
	sub_8222CED0(ctx, base);
	// 82A1D780: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1D784: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82A1D788: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A1D78C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1D790: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82A1D794: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D798: 9101006C  stw r8, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[8].u32 ) };
	// 82A1D79C: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A1D7A0: 4B903FA9  bl 0x82321748
	ctx.lr = 0x82A1D7A4;
	sub_82321748(ctx, base);
	// 82A1D7A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D7A8: 4B7F7631  bl 0x82214dd8
	ctx.lr = 0x82A1D7AC;
	sub_82214DD8(ctx, base);
	// 82A1D7AC: 7FF7FB78  mr r23, r31
	ctx.r[23].u64 = ctx.r[31].u64;
	// 82A1D7B0: 48000104  b 0x82a1d8b4
	pc = 0x82A1D8B4; continue 'dispatch;
            }
            0x82A1D7B4 => {
    //   block [0x82A1D7B4..0x82A1D7E8)
	// 82A1D7B4: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A1D7B8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A1D7BC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82A1D7C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D7C4: 4B7C65CD  bl 0x821e3d90
	ctx.lr = 0x82A1D7C8;
	sub_821E3D90(ctx, base);
	// 82A1D7C8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D7CC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A1D7D0: 4B8479D1  bl 0x822651a0
	ctx.lr = 0x82A1D7D4;
	sub_822651A0(ctx, base);
	// 82A1D7D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D7D8: 4B7F7601  bl 0x82214dd8
	ctx.lr = 0x82A1D7DC;
	sub_82214DD8(ctx, base);
	// 82A1D7DC: 7FF7FB78  mr r23, r31
	ctx.r[23].u64 = ctx.r[31].u64;
	// 82A1D7E0: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82A1D7E4: 4800007C  b 0x82a1d860
	pc = 0x82A1D860; continue 'dispatch;
            }
            0x82A1D7E8 => {
    //   block [0x82A1D7E8..0x82A1D820)
	// 82A1D7E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D7EC: 4828FAF5  bl 0x82cad2e0
	ctx.lr = 0x82A1D7F0;
	sub_82CAD2E0(ctx, base);
	// 82A1D7F0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A1D7F4: 409A0070  bne cr6, 0x82a1d864
	if !ctx.cr[6].eq {
	pc = 0x82A1D864; continue 'dispatch;
	}
	// 82A1D7F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1D7FC: 4828FB45  bl 0x82cad340
	ctx.lr = 0x82A1D800;
	sub_82CAD340(ctx, base);
	// 82A1D800: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A1D804: 409A0060  bne cr6, 0x82a1d864
	if !ctx.cr[6].eq {
	pc = 0x82A1D864; continue 'dispatch;
	}
	// 82A1D808: 2F1E005F  cmpwi cr6, r30, 0x5f
	ctx.cr[6].compare_i32(ctx.r[30].s32, 95, &mut ctx.xer);
	// 82A1D80C: 419A0058  beq cr6, 0x82a1d864
	if ctx.cr[6].eq {
	pc = 0x82A1D864; continue 'dispatch;
	}
	// 82A1D810: 2F1E002E  cmpwi cr6, r30, 0x2e
	ctx.cr[6].compare_i32(ctx.r[30].s32, 46, &mut ctx.xer);
	// 82A1D814: 419A000C  beq cr6, 0x82a1d820
	if ctx.cr[6].eq {
	pc = 0x82A1D820; continue 'dispatch;
	}
	// 82A1D818: 2F1E003A  cmpwi cr6, r30, 0x3a
	ctx.cr[6].compare_i32(ctx.r[30].s32, 58, &mut ctx.xer);
	// 82A1D81C: 409A0058  bne cr6, 0x82a1d874
	if !ctx.cr[6].eq {
	pc = 0x82A1D874; continue 'dispatch;
	}
	pc = 0x82A1D820; continue 'dispatch;
            }
            0x82A1D820 => {
    //   block [0x82A1D820..0x82A1D860)
	// 82A1D820: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82A1D824: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A1D828: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82A1D82C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1D830: 4B7C6561  bl 0x821e3d90
	ctx.lr = 0x82A1D834;
	sub_821E3D90(ctx, base);
	// 82A1D834: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1D838: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82A1D83C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A1D840: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1D844: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82A1D848: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D84C: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 82A1D850: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A1D854: 4B903EF5  bl 0x82321748
	ctx.lr = 0x82A1D858;
	sub_82321748(ctx, base);
	// 82A1D858: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1D85C: 4B7F757D  bl 0x82214dd8
	ctx.lr = 0x82A1D860;
	sub_82214DD8(ctx, base);
	pc = 0x82A1D860; continue 'dispatch;
            }
            0x82A1D860 => {
    //   block [0x82A1D860..0x82A1D864)
	// 82A1D860: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	pc = 0x82A1D864; continue 'dispatch;
            }
            0x82A1D864 => {
    //   block [0x82A1D864..0x82A1D874)
	// 82A1D864: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A1D868: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 82A1D86C: 4080FE74  bge 0x82a1d6e0
	if !ctx.cr[0].lt {
	pc = 0x82A1D6E0; continue 'dispatch;
	}
	// 82A1D870: 48000048  b 0x82a1d8b8
	pc = 0x82A1D8B8; continue 'dispatch;
            }
            0x82A1D874 => {
    //   block [0x82A1D874..0x82A1D8B4)
	// 82A1D874: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82A1D878: 38BF0001  addi r5, r31, 1
	ctx.r[5].s64 = ctx.r[31].s64 + 1;
	// 82A1D87C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82A1D880: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D884: 4B7C650D  bl 0x821e3d90
	ctx.lr = 0x82A1D888;
	sub_821E3D90(ctx, base);
	// 82A1D888: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82A1D88C: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1D890: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A1D894: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82A1D898: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1D89C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D8A0: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 82A1D8A4: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A1D8A8: 4B903EA1  bl 0x82321748
	ctx.lr = 0x82A1D8AC;
	sub_82321748(ctx, base);
	// 82A1D8AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D8B0: 4B7F7529  bl 0x82214dd8
	ctx.lr = 0x82A1D8B4;
	sub_82214DD8(ctx, base);
	pc = 0x82A1D8B4; continue 'dispatch;
            }
            0x82A1D8B4 => {
    //   block [0x82A1D8B4..0x82A1D8B8)
	// 82A1D8B4: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	pc = 0x82A1D8B8; continue 'dispatch;
            }
            0x82A1D8B8 => {
    //   block [0x82A1D8B8..0x82A1D904)
	// 82A1D8B8: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 82A1D8BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1D8C0: 409A0044  bne cr6, 0x82a1d904
	if !ctx.cr[6].eq {
	pc = 0x82A1D904; continue 'dispatch;
	}
	// 82A1D8C4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82A1D8C8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A1D8CC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82A1D8D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D8D4: 4B7C64BD  bl 0x821e3d90
	ctx.lr = 0x82A1D8D8;
	sub_821E3D90(ctx, base);
	// 82A1D8D8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1D8DC: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82A1D8E0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A1D8E4: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82A1D8E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1D8EC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D8F0: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 82A1D8F4: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A1D8F8: 4B903E51  bl 0x82321748
	ctx.lr = 0x82A1D8FC;
	sub_82321748(ctx, base);
	// 82A1D8FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1D900: 4B7F74D9  bl 0x82214dd8
	ctx.lr = 0x82A1D904;
	sub_82214DD8(ctx, base);
	pc = 0x82A1D904; continue 'dispatch;
            }
            0x82A1D904 => {
    //   block [0x82A1D904..0x82A1D91C)
	// 82A1D904: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1D908: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A1D90C: 3BA0D8EE  li r29, -0x2712
	ctx.r[29].s64 = -10002;
	// 82A1D910: 7E3C8B78  mr r28, r17
	ctx.r[28].u64 = ctx.r[17].u64;
	// 82A1D914: 3BCA9700  addi r30, r10, -0x6900
	ctx.r[30].s64 = ctx.r[10].s64 + -26880;
	// 82A1D918: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1D91C; continue 'dispatch;
            }
            0x82A1D91C => {
    //   block [0x82A1D91C..0x82A1D938)
	// 82A1D91C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A1D920: 419A00D4  beq cr6, 0x82a1d9f4
	if ctx.cr[6].eq {
	pc = 0x82A1D9F4; continue 'dispatch;
	}
	// 82A1D924: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1D928: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82A1D92C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1D930: 419A0008  beq cr6, 0x82a1d938
	if ctx.cr[6].eq {
	pc = 0x82A1D938; continue 'dispatch;
	}
	// 82A1D934: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1D938; continue 'dispatch;
            }
            0x82A1D938 => {
    //   block [0x82A1D938..0x82A1D95C)
	// 82A1D938: 80780004  lwz r3, 4(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1D93C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A1D940: 409A001C  bne cr6, 0x82a1d95c
	if !ctx.cr[6].eq {
	pc = 0x82A1D95C; continue 'dispatch;
	}
	// 82A1D944: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1D948: 922B0004  stw r17, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[17].u32 ) };
	// 82A1D94C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1D950: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 82A1D954: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82A1D958: 48000028  b 0x82a1d980
	pc = 0x82A1D980; continue 'dispatch;
            }
            0x82A1D95C => {
    //   block [0x82A1D95C..0x82A1D960)
	// 82A1D95C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x82A1D960; continue 'dispatch;
            }
            0x82A1D960 => {
    //   block [0x82A1D960..0x82A1D980)
	// 82A1D960: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D964: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A1D968: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1D96C: 409AFFF4  bne cr6, 0x82a1d960
	if !ctx.cr[6].eq {
	pc = 0x82A1D960; continue 'dispatch;
	}
	// 82A1D970: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 82A1D974: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A1D978: 5565003E  slwi r5, r11, 0
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82A1D97C: 48006B5D  bl 0x82a244d8
	ctx.lr = 0x82A1D980;
	sub_82A244D8(ctx, base);
	pc = 0x82A1D980; continue 'dispatch;
            }
            0x82A1D980 => {
    //   block [0x82A1D980..0x82A1D9E8)
	// 82A1D980: 80B80004  lwz r5, 4(r24)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1D984: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1D988: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82A1D98C: 48006755  bl 0x82a240e0
	ctx.lr = 0x82A1D990;
	sub_82A240E0(ctx, base);
	// 82A1D990: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1D994: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1D998: 38CBFFF8  addi r6, r11, -8
	ctx.r[6].s64 = ctx.r[11].s64 + -8;
	// 82A1D99C: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82A1D9A0: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82A1D9A4: 4B80AC2D  bl 0x822285d0
	ctx.lr = 0x82A1D9A8;
	sub_822285D0(ctx, base);
	// 82A1D9A8: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1D9AC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1D9B0: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 82A1D9B4: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A1D9B8: 419A0038  beq cr6, 0x82a1d9f0
	if ctx.cr[6].eq {
	pc = 0x82A1D9F0; continue 'dispatch;
	}
	// 82A1D9BC: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1D9C0: 2F0A0005  cmpwi cr6, r10, 5
	ctx.cr[6].compare_i32(ctx.r[10].s32, 5, &mut ctx.xer);
	// 82A1D9C4: 409A002C  bne cr6, 0x82a1d9f0
	if !ctx.cr[6].eq {
	pc = 0x82A1D9F0; continue 'dispatch;
	}
	// 82A1D9C8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1D9CC: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1D9D0: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1D9D4: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82A1D9D8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A1D9DC: 7D1D1E70  srawi r29, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82A1D9E0: 409A0008  bne cr6, 0x82a1d9e8
	if !ctx.cr[6].eq {
	pc = 0x82A1D9E8; continue 'dispatch;
	}
	// 82A1D9E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A1D9E8; continue 'dispatch;
            }
            0x82A1D9E8 => {
    //   block [0x82A1D9E8..0x82A1D9F0)
	// 82A1D9E8: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1D9EC: 4BFFFF30  b 0x82a1d91c
	pc = 0x82A1D91C; continue 'dispatch;
            }
            0x82A1D9F0 => {
    //   block [0x82A1D9F0..0x82A1D9F4)
	// 82A1D9F0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x82A1D9F4; continue 'dispatch;
            }
            0x82A1D9F4 => {
    //   block [0x82A1D9F4..0x82A1D9FC)
	// 82A1D9F4: 7E89A378  mr r9, r20
	ctx.r[9].u64 = ctx.r[20].u64;
	// 82A1D9F8: 92210060  stw r17, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[17].u32 ) };
	pc = 0x82A1D9FC; continue 'dispatch;
            }
            0x82A1D9FC => {
    //   block [0x82A1D9FC..0x82A1DA20)
	// 82A1D9FC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A1DA00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1DA04: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A1DA08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A1DA0C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1DA10: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1DA14: 4082FFE8  bne 0x82a1d9fc
	if !ctx.cr[0].eq {
	pc = 0x82A1D9FC; continue 'dispatch;
	}
	// 82A1DA18: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 82A1DA1C: 92210058  stw r17, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[17].u32 ) };
	pc = 0x82A1DA20; continue 'dispatch;
            }
            0x82A1DA20 => {
    //   block [0x82A1DA20..0x82A1DA58)
	// 82A1DA20: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 82A1DA24: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1DA28: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 82A1DA2C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82A1DA30: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1DA34: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1DA38: 4082FFE8  bne 0x82a1da20
	if !ctx.cr[0].eq {
	pc = 0x82A1DA20; continue 'dispatch;
	}
	// 82A1DA3C: 5785063E  clrlwi r5, r28, 0x18
	ctx.r[5].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82A1DA40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1DA44: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A1DA48: 419A0010  beq cr6, 0x82a1da58
	if ctx.cr[6].eq {
	pc = 0x82A1DA58; continue 'dispatch;
	}
	// 82A1DA4C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82A1DA50: 4B847751  bl 0x822651a0
	ctx.lr = 0x82A1DA54;
	sub_822651A0(ctx, base);
	// 82A1DA54: 48000034  b 0x82a1da88
	pc = 0x82A1DA88; continue 'dispatch;
            }
            0x82A1DA58 => {
    //   block [0x82A1DA58..0x82A1DA88)
	// 82A1DA58: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82A1DA5C: 4B847745  bl 0x822651a0
	ctx.lr = 0x82A1DA60;
	sub_822651A0(ctx, base);
	// 82A1DA60: 38D70001  addi r6, r23, 1
	ctx.r[6].s64 = ctx.r[23].s64 + 1;
	// 82A1DA64: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A1DA68: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82A1DA6C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1DA70: 4B7C6321  bl 0x821e3d90
	ctx.lr = 0x82A1DA74;
	sub_821E3D90(ctx, base);
	// 82A1DA74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1DA78: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1DA7C: 4B847725  bl 0x822651a0
	ctx.lr = 0x82A1DA80;
	sub_822651A0(ctx, base);
	// 82A1DA80: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1DA84: 4B7F7355  bl 0x82214dd8
	ctx.lr = 0x82A1DA88;
	sub_82214DD8(ctx, base);
	pc = 0x82A1DA88; continue 'dispatch;
            }
            0x82A1DA88 => {
    //   block [0x82A1DA88..0x82A1DAB4)
	// 82A1DA88: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82A1DA8C: 80F80048  lwz r7, 0x48(r24)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(72 as u32) ) } as u64;
	// 82A1DA90: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1DA94: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A1DA98: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1DA9C: 4800083D  bl 0x82a1e2d8
	ctx.lr = 0x82A1DAA0;
	sub_82A1E2D8(ctx, base);
	// 82A1DAA0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A1DAA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DAA8: 409A0038  bne cr6, 0x82a1dae0
	if !ctx.cr[6].eq {
	pc = 0x82A1DAE0; continue 'dispatch;
	}
	// 82A1DAAC: 7E0A8378  mr r10, r16
	ctx.r[10].u64 = ctx.r[16].u64;
	// 82A1DAB0: 7E0B8378  mr r11, r16
	ctx.r[11].u64 = ctx.r[16].u64;
	pc = 0x82A1DAB4; continue 'dispatch;
            }
            0x82A1DAB4 => {
    //   block [0x82A1DAB4..0x82A1DAD8)
	// 82A1DAB4: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1DAB8: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1DABC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A1DAC0: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82A1DAC4: 419A0014  beq cr6, 0x82a1dad8
	if ctx.cr[6].eq {
	pc = 0x82A1DAD8; continue 'dispatch;
	}
	// 82A1DAC8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A1DACC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1DAD0: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82A1DAD4: 419AFFE0  beq cr6, 0x82a1dab4
	if ctx.cr[6].eq {
	pc = 0x82A1DAB4; continue 'dispatch;
	}
	pc = 0x82A1DAD8; continue 'dispatch;
            }
            0x82A1DAD8 => {
    //   block [0x82A1DAD8..0x82A1DAE0)
	// 82A1DAD8: 7D2B0034  cntlzw r11, r9
	ctx.r[11].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 82A1DADC: 48000014  b 0x82a1daf0
	pc = 0x82A1DAF0; continue 'dispatch;
            }
            0x82A1DAE0 => {
    //   block [0x82A1DAE0..0x82A1DAF0)
	// 82A1DAE0: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 82A1DAE4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1DAE8: 4B84FD11  bl 0x8226d7f8
	ctx.lr = 0x82A1DAEC;
	sub_8226D7F8(ctx, base);
	// 82A1DAEC: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	pc = 0x82A1DAF0; continue 'dispatch;
            }
            0x82A1DAF0 => {
    //   block [0x82A1DAF0..0x82A1DB3C)
	// 82A1DAF0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82A1DAF4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A1DAF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DAFC: 419A0040  beq cr6, 0x82a1db3c
	if ctx.cr[6].eq {
	pc = 0x82A1DB3C; continue 'dispatch;
	}
	// 82A1DB00: 81780048  lwz r11, 0x48(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(72 as u32) ) } as u64;
	// 82A1DB04: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1DB08: 419A0034  beq cr6, 0x82a1db3c
	if ctx.cr[6].eq {
	pc = 0x82A1DB3C; continue 'dispatch;
	}
	// 82A1DB0C: 92380048  stw r17, 0x48(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(72 as u32), ctx.r[17].u32 ) };
	// 82A1DB10: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A1DB14: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82A1DB18: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1DB1C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A1DB20: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1DB24: 480007B5  bl 0x82a1e2d8
	ctx.lr = 0x82A1DB28;
	sub_82A1E2D8(ctx, base);
	// 82A1DB28: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1DB2C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1DB30: 4B847671  bl 0x822651a0
	ctx.lr = 0x82A1DB34;
	sub_822651A0(ctx, base);
	// 82A1DB34: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1DB38: 4B7F72A1  bl 0x82214dd8
	ctx.lr = 0x82A1DB3C;
	sub_82214DD8(ctx, base);
	pc = 0x82A1DB3C; continue 'dispatch;
            }
            0x82A1DB3C => {
    //   block [0x82A1DB3C..0x82A1DB6C)
	// 82A1DB3C: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 82A1DB40: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1DB44: 4B87D675  bl 0x8229b1b8
	ctx.lr = 0x82A1DB48;
	sub_8229B1B8(ctx, base);
	// 82A1DB48: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1DB4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DB50: 419A0060  beq cr6, 0x82a1dbb0
	if ctx.cr[6].eq {
	pc = 0x82A1DBB0; continue 'dispatch;
	}
	// 82A1DB54: 566B063E  clrlwi r11, r19, 0x18
	ctx.r[11].u64 = ctx.r[19].u32 as u64 & 0x000000FFu64;
	// 82A1DB58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DB5C: 419A0010  beq cr6, 0x82a1db6c
	if ctx.cr[6].eq {
	pc = 0x82A1DB6C; continue 'dispatch;
	}
	// 82A1DB60: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82A1DB64: 38780054  addi r3, r24, 0x54
	ctx.r[3].s64 = ctx.r[24].s64 + 84;
	// 82A1DB68: 4B847639  bl 0x822651a0
	ctx.lr = 0x82A1DB6C;
	sub_822651A0(ctx, base);
	pc = 0x82A1DB6C; continue 'dispatch;
            }
            0x82A1DB6C => {
    //   block [0x82A1DB6C..0x82A1DBA0)
	// 82A1DB6C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82A1DB70: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A1DB74: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1DB78: 4B7C5591  bl 0x821e3108
	ctx.lr = 0x82A1DB7C;
	sub_821E3108(ctx, base);
	// 82A1DB7C: 3BF80008  addi r31, r24, 8
	ctx.r[31].s64 = ctx.r[24].s64 + 8;
	// 82A1DB80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1DB84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1DB88: 4B847619  bl 0x822651a0
	ctx.lr = 0x82A1DB8C;
	sub_822651A0(ctx, base);
	// 82A1DB8C: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1DB90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DB94: 409A000C  bne cr6, 0x82a1dba0
	if !ctx.cr[6].eq {
	pc = 0x82A1DBA0; continue 'dispatch;
	}
	// 82A1DB98: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 82A1DB9C: 48000008  b 0x82a1dba4
	pc = 0x82A1DBA4; continue 'dispatch;
            }
            0x82A1DBA0 => {
    //   block [0x82A1DBA0..0x82A1DBA4)
	// 82A1DBA0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A1DBA4; continue 'dispatch;
            }
            0x82A1DBA4 => {
    //   block [0x82A1DBA4..0x82A1DBB0)
	// 82A1DBA4: 91780010  stw r11, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A1DBA8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1DBAC: 4B7F722D  bl 0x82214dd8
	ctx.lr = 0x82A1DBB0;
	sub_82214DD8(ctx, base);
	pc = 0x82A1DBB0; continue 'dispatch;
            }
            0x82A1DBB0 => {
    //   block [0x82A1DBB0..0x82A1DBD4)
	// 82A1DBB0: 81780048  lwz r11, 0x48(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(72 as u32) ) } as u64;
	// 82A1DBB4: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 82A1DBB8: 80780004  lwz r3, 4(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1DBBC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A1DBC0: 91780048  stw r11, 0x48(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82A1DBC4: 481AE145  bl 0x82bcbd08
	ctx.lr = 0x82A1DBC8;
	sub_82BCBD08(ctx, base);
	// 82A1DBC8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1DBCC: 4B7A8B9D  bl 0x821c6768
	ctx.lr = 0x82A1DBD0;
	sub_821C6768(ctx, base);
	// 82A1DBD0: 7E88A378  mr r8, r20
	ctx.r[8].u64 = ctx.r[20].u64;
	pc = 0x82A1DBD4; continue 'dispatch;
            }
            0x82A1DBD4 => {
    //   block [0x82A1DBD4..0x82A1DBFC)
	// 82A1DBD4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1DBD8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1DBDC: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1DBE0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A1DBE4: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1DBE8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1DBEC: 4082FFE8  bne 0x82a1dbd4
	if !ctx.cr[0].eq {
	pc = 0x82A1DBD4; continue 'dispatch;
	}
	// 82A1DBF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1DBF4: 4B7A8B75  bl 0x821c6768
	ctx.lr = 0x82A1DBF8;
	sub_821C6768(ctx, base);
	// 82A1DBF8: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	pc = 0x82A1DBFC; continue 'dispatch;
            }
            0x82A1DBFC => {
    //   block [0x82A1DBFC..0x82A1DC24)
	// 82A1DBFC: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 82A1DC00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1DC04: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 82A1DC08: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 82A1DC0C: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1DC10: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1DC14: 4082FFE8  bne 0x82a1dbfc
	if !ctx.cr[0].eq {
	pc = 0x82A1DBFC; continue 'dispatch;
	}
	// 82A1DC18: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1DC1C: 4B7A8B4D  bl 0x821c6768
	ctx.lr = 0x82A1DC20;
	sub_821C6768(ctx, base);
	// 82A1DC20: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	pc = 0x82A1DC24; continue 'dispatch;
            }
            0x82A1DC24 => {
    //   block [0x82A1DC24..0x82A1DC5C)
	// 82A1DC24: 7C6000A6  mfmsr r3
	ctx.r[3].u64 = ctx.msr;
	// 82A1DC28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1DC2C: 7C805828  lwarx r4, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[4].u64 = ctx.reserved.u32 as u64;
	// 82A1DC30: 3884FFFF  addi r4, r4, -1
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	// 82A1DC34: 7C80592D  stwcx. r4, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[4].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1DC38: 7C610164  mtmsrd r3, 1
	ctx.msr = (ctx.r[3].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1DC3C: 4082FFE8  bne 0x82a1dc24
	if !ctx.cr[0].eq {
	pc = 0x82A1DC24; continue 'dispatch;
	}
	// 82A1DC40: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1DC44: 4B904BA5  bl 0x823227e8
	ctx.lr = 0x82A1DC48;
	sub_823227E8(ctx, base);
	// 82A1DC48: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1DC4C: 4B7FE0ED  bl 0x8221bd38
	ctx.lr = 0x82A1DC50;
	sub_8221BD38(ctx, base);
	// 82A1DC50: 92210074  stw r17, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[17].u32 ) };
	// 82A1DC54: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A1DC58: 4B7A8B11  bl 0x821c6768
	ctx.lr = 0x82A1DC5C;
	sub_821C6768(ctx, base);
	pc = 0x82A1DC5C; continue 'dispatch;
            }
            0x82A1DC5C => {
    //   block [0x82A1DC5C..0x82A1DC7C)
	// 82A1DC5C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1DC60: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1DC64: 7D40A028  lwarx r10, 0, r20
	// lwarx
	let ea = ctx.r[20].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1DC68: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A1DC6C: 7D40A12D  stwcx. r10, 0, r20
	// stwcx.
	let addr = ctx.r[20].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1DC70: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1DC74: 4082FFE8  bne 0x82a1dc5c
	if !ctx.cr[0].eq {
	pc = 0x82A1DC5C; continue 'dispatch;
	}
	// 82A1DC78: 48000474  b 0x82a1e0ec
	pc = 0x82A1E0EC; continue 'dispatch;
            }
            0x82A1DC7C => {
    //   block [0x82A1DC7C..0x82A1DC9C)
	// 82A1DC7C: 2F1E0075  cmpwi cr6, r30, 0x75
	ctx.cr[6].compare_i32(ctx.r[30].s32, 117, &mut ctx.xer);
	// 82A1DC80: 409A0038  bne cr6, 0x82a1dcb8
	if !ctx.cr[6].eq {
	pc = 0x82A1DCB8; continue 'dispatch;
	}
	// 82A1DC84: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1DC88: 38780008  addi r3, r24, 8
	ctx.r[3].s64 = ctx.r[24].s64 + 8;
	// 82A1DC8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DC90: 409A000C  bne cr6, 0x82a1dc9c
	if !ctx.cr[6].eq {
	pc = 0x82A1DC9C; continue 'dispatch;
	}
	// 82A1DC94: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 82A1DC98: 48000008  b 0x82a1dca0
	pc = 0x82A1DCA0; continue 'dispatch;
            }
            0x82A1DC9C => {
    //   block [0x82A1DC9C..0x82A1DCA0)
	// 82A1DC9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A1DCA0; continue 'dispatch;
            }
            0x82A1DCA0 => {
    //   block [0x82A1DCA0..0x82A1DCB8)
	// 82A1DCA0: 80980010  lwz r4, 0x10(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1DCA4: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A1DCA8: 40980444  bge cr6, 0x82a1e0ec
	if !ctx.cr[6].lt {
	pc = 0x82A1E0EC; continue 'dispatch;
	}
	// 82A1DCAC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A1DCB0: 48120271  bl 0x82b3df20
	ctx.lr = 0x82A1DCB4;
	sub_82B3DF20(ctx, base);
	// 82A1DCB4: 48000438  b 0x82a1e0ec
	pc = 0x82A1E0EC; continue 'dispatch;
            }
            0x82A1DCB8 => {
    //   block [0x82A1DCB8..0x82A1DCF8)
	// 82A1DCB8: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 82A1DCBC: 409A0054  bne cr6, 0x82a1dd10
	if !ctx.cr[6].eq {
	pc = 0x82A1DD10; continue 'dispatch;
	}
	// 82A1DCC0: 92380048  stw r17, 0x48(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(72 as u32), ctx.r[17].u32 ) };
	// 82A1DCC4: 3BD80054  addi r30, r24, 0x54
	ctx.r[30].s64 = ctx.r[24].s64 + 84;
	// 82A1DCC8: 38780008  addi r3, r24, 8
	ctx.r[3].s64 = ctx.r[24].s64 + 8;
	// 82A1DCCC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1DCD0: 4B8474D1  bl 0x822651a0
	ctx.lr = 0x82A1DCD4;
	sub_822651A0(ctx, base);
	// 82A1DCD4: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1DCD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DCDC: 409A001C  bne cr6, 0x82a1dcf8
	if !ctx.cr[6].eq {
	pc = 0x82A1DCF8; continue 'dispatch;
	}
	// 82A1DCE0: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 82A1DCE4: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 82A1DCE8: 91780010  stw r11, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A1DCEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1DCF0: 4B857749  bl 0x82275438
	ctx.lr = 0x82A1DCF4;
	sub_82275438(ctx, base);
	// 82A1DCF4: 480003F8  b 0x82a1e0ec
	pc = 0x82A1E0EC; continue 'dispatch;
            }
            0x82A1DCF8 => {
    //   block [0x82A1DCF8..0x82A1DD10)
	// 82A1DCF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1DCFC: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 82A1DD00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1DD04: 91780010  stw r11, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A1DD08: 4B857731  bl 0x82275438
	ctx.lr = 0x82A1DD0C;
	sub_82275438(ctx, base);
	// 82A1DD0C: 480003E0  b 0x82a1e0ec
	pc = 0x82A1E0EC; continue 'dispatch;
            }
            0x82A1DD10 => {
    //   block [0x82A1DD10..0x82A1DD3C)
	// 82A1DD10: 2F1E006F  cmpwi cr6, r30, 0x6f
	ctx.cr[6].compare_i32(ctx.r[30].s32, 111, &mut ctx.xer);
	// 82A1DD14: 409A00D0  bne cr6, 0x82a1dde4
	if !ctx.cr[6].eq {
	pc = 0x82A1DDE4; continue 'dispatch;
	}
	// 82A1DD18: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1DD1C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1DD20: 409903CC  ble cr6, 0x82a1e0ec
	if !ctx.cr[6].gt {
	pc = 0x82A1E0EC; continue 'dispatch;
	}
	// 82A1DD24: 576A063E  clrlwi r10, r27, 0x18
	ctx.r[10].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 82A1DD28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1DD2C: 409A0010  bne cr6, 0x82a1dd3c
	if !ctx.cr[6].eq {
	pc = 0x82A1DD3C; continue 'dispatch;
	}
	// 82A1DD30: 574A063E  clrlwi r10, r26, 0x18
	ctx.r[10].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 82A1DD34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1DD38: 419A00A0  beq cr6, 0x82a1ddd8
	if ctx.cr[6].eq {
	pc = 0x82A1DDD8; continue 'dispatch;
	}
	pc = 0x82A1DD3C; continue 'dispatch;
            }
            0x82A1DD3C => {
    //   block [0x82A1DD3C..0x82A1DD6C)
	// 82A1DD3C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A1DD40: 40990098  ble cr6, 0x82a1ddd8
	if !ctx.cr[6].gt {
	pc = 0x82A1DDD8; continue 'dispatch;
	}
	// 82A1DD44: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 82A1DD48: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A1DD4C: 91580010  stw r10, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82A1DD50: 3BF80008  addi r31, r24, 8
	ctx.r[31].s64 = ctx.r[24].s64 + 8;
	// 82A1DD54: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 82A1DD58: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1DD5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DD60: 409A000C  bne cr6, 0x82a1dd6c
	if !ctx.cr[6].eq {
	pc = 0x82A1DD6C; continue 'dispatch;
	}
	// 82A1DD64: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82A1DD68: 48000008  b 0x82a1dd70
	pc = 0x82A1DD70; continue 'dispatch;
            }
            0x82A1DD6C => {
    //   block [0x82A1DD6C..0x82A1DD70)
	// 82A1DD6C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1DD70; continue 'dispatch;
            }
            0x82A1DD70 => {
    //   block [0x82A1DD70..0x82A1DD7C)
	// 82A1DD70: 7C6A58AE  lbzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A1DD74: 4812F78D  bl 0x82b4d500
	ctx.lr = 0x82A1DD78;
	sub_82B4D500(ctx, base);
	// 82A1DD78: 547E063E  clrlwi r30, r3, 0x18
	ctx.r[30].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	pc = 0x82A1DD7C; continue 'dispatch;
            }
            0x82A1DD7C => {
    //   block [0x82A1DD7C..0x82A1DD9C)
	// 82A1DD7C: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1DD80: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 82A1DD84: 91580010  stw r10, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82A1DD88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1DD8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DD90: 409A000C  bne cr6, 0x82a1dd9c
	if !ctx.cr[6].eq {
	pc = 0x82A1DD9C; continue 'dispatch;
	}
	// 82A1DD94: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82A1DD98: 48000008  b 0x82a1dda0
	pc = 0x82A1DDA0; continue 'dispatch;
            }
            0x82A1DD9C => {
    //   block [0x82A1DD9C..0x82A1DDA0)
	// 82A1DD9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1DDA0; continue 'dispatch;
            }
            0x82A1DDA0 => {
    //   block [0x82A1DDA0..0x82A1DDC0)
	// 82A1DDA0: 7C6A58AE  lbzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A1DDA4: 4812F75D  bl 0x82b4d500
	ctx.lr = 0x82A1DDA8;
	sub_82B4D500(ctx, base);
	// 82A1DDA8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1DDAC: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A1DDB0: 409A0010  bne cr6, 0x82a1ddc0
	if !ctx.cr[6].eq {
	pc = 0x82A1DDC0; continue 'dispatch;
	}
	// 82A1DDB4: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1DDB8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1DDBC: 4199FFC0  bgt cr6, 0x82a1dd7c
	if ctx.cr[6].gt {
	pc = 0x82A1DD7C; continue 'dispatch;
	}
	pc = 0x82A1DDC0; continue 'dispatch;
            }
            0x82A1DDC0 => {
    //   block [0x82A1DDC0..0x82A1DDD8)
	// 82A1DDC0: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1DDC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1DDC8: 40990324  ble cr6, 0x82a1e0ec
	if !ctx.cr[6].gt {
	pc = 0x82A1E0EC; continue 'dispatch;
	}
	// 82A1DDCC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A1DDD0: 91780010  stw r11, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A1DDD4: 48000318  b 0x82a1e0ec
	pc = 0x82A1E0EC; continue 'dispatch;
            }
            0x82A1DDD8 => {
    //   block [0x82A1DDD8..0x82A1DDE4)
	// 82A1DDD8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A1DDDC: 91780010  stw r11, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A1DDE0: 4800030C  b 0x82a1e0ec
	pc = 0x82A1E0EC; continue 'dispatch;
            }
            0x82A1DDE4 => {
    //   block [0x82A1DDE4..0x82A1DE04)
	// 82A1DDE4: 2F1E0070  cmpwi cr6, r30, 0x70
	ctx.cr[6].compare_i32(ctx.r[30].s32, 112, &mut ctx.xer);
	// 82A1DDE8: 409A0100  bne cr6, 0x82a1dee8
	if !ctx.cr[6].eq {
	pc = 0x82A1DEE8; continue 'dispatch;
	}
	// 82A1DDEC: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1DDF0: 3BF80008  addi r31, r24, 8
	ctx.r[31].s64 = ctx.r[24].s64 + 8;
	// 82A1DDF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DDF8: 409A000C  bne cr6, 0x82a1de04
	if !ctx.cr[6].eq {
	pc = 0x82A1DE04; continue 'dispatch;
	}
	// 82A1DDFC: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 82A1DE00: 48000008  b 0x82a1de08
	pc = 0x82A1DE08; continue 'dispatch;
            }
            0x82A1DE04 => {
    //   block [0x82A1DE04..0x82A1DE08)
	// 82A1DE04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A1DE08; continue 'dispatch;
            }
            0x82A1DE08 => {
    //   block [0x82A1DE08..0x82A1DE2C)
	// 82A1DE08: 81380010  lwz r9, 0x10(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1DE0C: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A1DE10: 409802DC  bge cr6, 0x82a1e0ec
	if !ctx.cr[6].lt {
	pc = 0x82A1E0EC; continue 'dispatch;
	}
	// 82A1DE14: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 82A1DE18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DE1C: 409A0010  bne cr6, 0x82a1de2c
	if !ctx.cr[6].eq {
	pc = 0x82A1DE2C; continue 'dispatch;
	}
	// 82A1DE20: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 82A1DE24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DE28: 419A00B4  beq cr6, 0x82a1dedc
	if ctx.cr[6].eq {
	pc = 0x82A1DEDC; continue 'dispatch;
	}
	pc = 0x82A1DE2C; continue 'dispatch;
            }
            0x82A1DE2C => {
    //   block [0x82A1DE2C..0x82A1DE40)
	// 82A1DE2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1DE30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DE34: 409A000C  bne cr6, 0x82a1de40
	if !ctx.cr[6].eq {
	pc = 0x82A1DE40; continue 'dispatch;
	}
	// 82A1DE38: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 82A1DE3C: 48000008  b 0x82a1de44
	pc = 0x82A1DE44; continue 'dispatch;
            }
            0x82A1DE40 => {
    //   block [0x82A1DE40..0x82A1DE44)
	// 82A1DE40: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A1DE44; continue 'dispatch;
            }
            0x82A1DE44 => {
    //   block [0x82A1DE44..0x82A1DE6C)
	// 82A1DE44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A1DE48: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A1DE4C: 40980090  bge cr6, 0x82a1dedc
	if !ctx.cr[6].lt {
	pc = 0x82A1DEDC; continue 'dispatch;
	}
	// 82A1DE50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1DE54: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 82A1DE58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DE5C: 3BAAFFDF  addi r29, r10, -0x21
	ctx.r[29].s64 = ctx.r[10].s64 + -33;
	// 82A1DE60: 409A000C  bne cr6, 0x82a1de6c
	if !ctx.cr[6].eq {
	pc = 0x82A1DE6C; continue 'dispatch;
	}
	// 82A1DE64: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82A1DE68: 48000008  b 0x82a1de70
	pc = 0x82A1DE70; continue 'dispatch;
            }
            0x82A1DE6C => {
    //   block [0x82A1DE6C..0x82A1DE70)
	// 82A1DE6C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1DE70; continue 'dispatch;
            }
            0x82A1DE70 => {
    //   block [0x82A1DE70..0x82A1DE7C)
	// 82A1DE70: 7C6958AE  lbzx r3, r9, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A1DE74: 4812F68D  bl 0x82b4d500
	ctx.lr = 0x82A1DE78;
	sub_82B4D500(ctx, base);
	// 82A1DE78: 547E063E  clrlwi r30, r3, 0x18
	ctx.r[30].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	pc = 0x82A1DE7C; continue 'dispatch;
            }
            0x82A1DE7C => {
    //   block [0x82A1DE7C..0x82A1DE9C)
	// 82A1DE7C: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1DE80: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82A1DE84: 91580010  stw r10, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82A1DE88: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1DE8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DE90: 409A000C  bne cr6, 0x82a1de9c
	if !ctx.cr[6].eq {
	pc = 0x82A1DE9C; continue 'dispatch;
	}
	// 82A1DE94: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82A1DE98: 48000008  b 0x82a1dea0
	pc = 0x82A1DEA0; continue 'dispatch;
            }
            0x82A1DE9C => {
    //   block [0x82A1DE9C..0x82A1DEA0)
	// 82A1DE9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1DEA0; continue 'dispatch;
            }
            0x82A1DEA0 => {
    //   block [0x82A1DEA0..0x82A1DEC8)
	// 82A1DEA0: 7C6A58AE  lbzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A1DEA4: 4812F65D  bl 0x82b4d500
	ctx.lr = 0x82A1DEA8;
	sub_82B4D500(ctx, base);
	// 82A1DEA8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1DEAC: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A1DEB0: 409A023C  bne cr6, 0x82a1e0ec
	if !ctx.cr[6].eq {
	pc = 0x82A1E0EC; continue 'dispatch;
	}
	// 82A1DEB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1DEB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DEBC: 409A000C  bne cr6, 0x82a1dec8
	if !ctx.cr[6].eq {
	pc = 0x82A1DEC8; continue 'dispatch;
	}
	// 82A1DEC0: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 82A1DEC4: 48000008  b 0x82a1decc
	pc = 0x82A1DECC; continue 'dispatch;
            }
            0x82A1DEC8 => {
    //   block [0x82A1DEC8..0x82A1DECC)
	// 82A1DEC8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A1DECC; continue 'dispatch;
            }
            0x82A1DECC => {
    //   block [0x82A1DECC..0x82A1DEDC)
	// 82A1DECC: 81580010  lwz r10, 0x10(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1DED0: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82A1DED4: 4198FFA8  blt cr6, 0x82a1de7c
	if ctx.cr[6].lt {
	pc = 0x82A1DE7C; continue 'dispatch;
	}
	// 82A1DED8: 48000214  b 0x82a1e0ec
	pc = 0x82A1E0EC; continue 'dispatch;
            }
            0x82A1DEDC => {
    //   block [0x82A1DEDC..0x82A1DEE8)
	// 82A1DEDC: 39690001  addi r11, r9, 1
	ctx.r[11].s64 = ctx.r[9].s64 + 1;
	// 82A1DEE0: 91780010  stw r11, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A1DEE4: 48000208  b 0x82a1e0ec
	pc = 0x82A1E0EC; continue 'dispatch;
            }
            0x82A1DEE8 => {
    //   block [0x82A1DEE8..0x82A1DEF8)
	// 82A1DEE8: 2F1E006C  cmpwi cr6, r30, 0x6c
	ctx.cr[6].compare_i32(ctx.r[30].s32, 108, &mut ctx.xer);
	// 82A1DEEC: 409A000C  bne cr6, 0x82a1def8
	if !ctx.cr[6].eq {
	pc = 0x82A1DEF8; continue 'dispatch;
	}
	// 82A1DEF0: 92380010  stw r17, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[17].u32 ) };
	// 82A1DEF4: 480001F8  b 0x82a1e0ec
	pc = 0x82A1E0EC; continue 'dispatch;
            }
            0x82A1DEF8 => {
    //   block [0x82A1DEF8..0x82A1DF18)
	// 82A1DEF8: 2F1E0071  cmpwi cr6, r30, 0x71
	ctx.cr[6].compare_i32(ctx.r[30].s32, 113, &mut ctx.xer);
	// 82A1DEFC: 409A0028  bne cr6, 0x82a1df24
	if !ctx.cr[6].eq {
	pc = 0x82A1DF24; continue 'dispatch;
	}
	// 82A1DF00: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1DF04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DF08: 409A0010  bne cr6, 0x82a1df18
	if !ctx.cr[6].eq {
	pc = 0x82A1DF18; continue 'dispatch;
	}
	// 82A1DF0C: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 82A1DF10: 91780010  stw r11, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A1DF14: 480001D8  b 0x82a1e0ec
	pc = 0x82A1E0EC; continue 'dispatch;
            }
            0x82A1DF18 => {
    //   block [0x82A1DF18..0x82A1DF24)
	// 82A1DF18: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1DF1C: 91780010  stw r11, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A1DF20: 480001CC  b 0x82a1e0ec
	pc = 0x82A1E0EC; continue 'dispatch;
            }
            0x82A1DF24 => {
    //   block [0x82A1DF24..0x82A1DF54)
	// 82A1DF24: 576B063E  clrlwi r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 82A1DF28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DF2C: 409A01BC  bne cr6, 0x82a1e0e8
	if !ctx.cr[6].eq {
	pc = 0x82A1E0E8; continue 'dispatch;
	}
	// 82A1DF30: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 82A1DF34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DF38: 409A01B0  bne cr6, 0x82a1e0e8
	if !ctx.cr[6].eq {
	pc = 0x82A1E0E8; continue 'dispatch;
	}
	// 82A1DF3C: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82A1DF40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DF44: 409A0010  bne cr6, 0x82a1df54
	if !ctx.cr[6].eq {
	pc = 0x82A1DF54; continue 'dispatch;
	}
	// 82A1DF48: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82A1DF4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DF50: 419A0198  beq cr6, 0x82a1e0e8
	if ctx.cr[6].eq {
	pc = 0x82A1E0E8; continue 'dispatch;
	}
	pc = 0x82A1DF54; continue 'dispatch;
            }
            0x82A1DF54 => {
    //   block [0x82A1DF54..0x82A1DF88)
	// 82A1DF54: 7FDE0774  extsb r30, r30
	ctx.r[30].s64 = ctx.r[30].s8 as i64;
	// 82A1DF58: 3BF80018  addi r31, r24, 0x18
	ctx.r[31].s64 = ctx.r[24].s64 + 24;
	// 82A1DF5C: 9BC10050  stb r30, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u8 ) };
	// 82A1DF60: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A1DF64: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1DF68: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1DF6C: 48000E15  bl 0x82a1ed80
	ctx.lr = 0x82A1DF70;
	sub_82A1ED80(ctx, base);
	// 82A1DF70: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A1DF74: 8158001C  lwz r10, 0x1c(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A1DF78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DF7C: 419A000C  beq cr6, 0x82a1df88
	if ctx.cr[6].eq {
	pc = 0x82A1DF88; continue 'dispatch;
	}
	// 82A1DF80: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A1DF84: 419A0008  beq cr6, 0x82a1df8c
	if ctx.cr[6].eq {
	pc = 0x82A1DF8C; continue 'dispatch;
	}
	pc = 0x82A1DF88; continue 'dispatch;
            }
            0x82A1DF88 => {
    //   block [0x82A1DF88..0x82A1DF8C)
	// 82A1DF88: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A1DF8C; continue 'dispatch;
            }
            0x82A1DF8C => {
    //   block [0x82A1DF8C..0x82A1DFB4)
	// 82A1DF8C: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A1DF90: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A1DF94: 419A0034  beq cr6, 0x82a1dfc8
	if ctx.cr[6].eq {
	pc = 0x82A1DFC8; continue 'dispatch;
	}
	// 82A1DF98: 896B000C  lbz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1DF9C: 7FC90774  extsb r9, r30
	ctx.r[9].s64 = ctx.r[30].s8 as i64;
	// 82A1DFA0: 7D680774  extsb r8, r11
	ctx.r[8].s64 = ctx.r[11].s8 as i64;
	// 82A1DFA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A1DFA8: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82A1DFAC: 41980008  blt cr6, 0x82a1dfb4
	if ctx.cr[6].lt {
	pc = 0x82A1DFB4; continue 'dispatch;
	}
	// 82A1DFB0: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	pc = 0x82A1DFB4; continue 'dispatch;
            }
            0x82A1DFB4 => {
    //   block [0x82A1DFB4..0x82A1DFC8)
	// 82A1DFB4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A1DFB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1DFBC: 409A000C  bne cr6, 0x82a1dfc8
	if !ctx.cr[6].eq {
	pc = 0x82A1DFC8; continue 'dispatch;
	}
	// 82A1DFC0: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 82A1DFC4: 48000010  b 0x82a1dfd4
	pc = 0x82A1DFD4; continue 'dispatch;
            }
            0x82A1DFC8 => {
    //   block [0x82A1DFC8..0x82A1DFD4)
	// 82A1DFC8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82A1DFCC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82A1DFD0: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	pc = 0x82A1DFD4; continue 'dispatch;
            }
            0x82A1DFD4 => {
    //   block [0x82A1DFD4..0x82A1DFF4)
	// 82A1DFD4: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82A1DFD8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1DFDC: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 82A1DFE0: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A1DFE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1DFE8: 419A000C  beq cr6, 0x82a1dff4
	if ctx.cr[6].eq {
	pc = 0x82A1DFF4; continue 'dispatch;
	}
	// 82A1DFEC: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A1DFF0: 419A0008  beq cr6, 0x82a1dff8
	if ctx.cr[6].eq {
	pc = 0x82A1DFF8; continue 'dispatch;
	}
	pc = 0x82A1DFF4; continue 'dispatch;
            }
            0x82A1DFF4 => {
    //   block [0x82A1DFF4..0x82A1DFF8)
	// 82A1DFF4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A1DFF8; continue 'dispatch;
            }
            0x82A1DFF8 => {
    //   block [0x82A1DFF8..0x82A1E010)
	// 82A1DFF8: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A1DFFC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1E000: 419A00E8  beq cr6, 0x82a1e0e8
	if ctx.cr[6].eq {
	pc = 0x82A1E0E8; continue 'dispatch;
	}
	// 82A1E004: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1E008: 409A0008  bne cr6, 0x82a1e010
	if !ctx.cr[6].eq {
	pc = 0x82A1E010; continue 'dispatch;
	}
	// 82A1E00C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A1E010; continue 'dispatch;
            }
            0x82A1E010 => {
    //   block [0x82A1E010..0x82A1E020)
	// 82A1E010: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E014: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A1E018: 409A0008  bne cr6, 0x82a1e020
	if !ctx.cr[6].eq {
	pc = 0x82A1E020; continue 'dispatch;
	}
	// 82A1E01C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A1E020; continue 'dispatch;
            }
            0x82A1E020 => {
    //   block [0x82A1E020..0x82A1E044)
	// 82A1E020: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 82A1E024: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1E028: 4B7D2219  bl 0x821f0240
	ctx.lr = 0x82A1E02C;
	sub_821F0240(ctx, base);
	// 82A1E02C: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1E030: 3BF80008  addi r31, r24, 8
	ctx.r[31].s64 = ctx.r[24].s64 + 8;
	// 82A1E034: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1E038: 7E268B78  mr r6, r17
	ctx.r[6].u64 = ctx.r[17].u64;
	// 82A1E03C: 419A0008  beq cr6, 0x82a1e044
	if ctx.cr[6].eq {
	pc = 0x82A1E044; continue 'dispatch;
	}
	// 82A1E040: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A1E044; continue 'dispatch;
            }
            0x82A1E044 => {
    //   block [0x82A1E044..0x82A1E0D0)
	// 82A1E044: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1E048: 80B80010  lwz r5, 0x10(r24)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1E04C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1E050: 4B7C5D41  bl 0x821e3d90
	ctx.lr = 0x82A1E054;
	sub_821E3D90(ctx, base);
	// 82A1E054: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1E058: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A1E05C: 80D80010  lwz r6, 0x10(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1E060: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1E064: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1E068: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	// 82A1E06C: 4B7C5D25  bl 0x821e3d90
	ctx.lr = 0x82A1E070;
	sub_821E3D90(ctx, base);
	// 82A1E070: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1E074: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A1E078: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82A1E07C: 4B7C508D  bl 0x821e3108
	ctx.lr = 0x82A1E080;
	sub_821E3108(ctx, base);
	// 82A1E080: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1E084: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1E088: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A1E08C: 4B7C507D  bl 0x821e3108
	ctx.lr = 0x82A1E090;
	sub_821E3108(ctx, base);
	// 82A1E090: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1E094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E098: 4B847109  bl 0x822651a0
	ctx.lr = 0x82A1E09C;
	sub_822651A0(ctx, base);
	// 82A1E09C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1E0A0: 4B7F6D39  bl 0x82214dd8
	ctx.lr = 0x82A1E0A4;
	sub_82214DD8(ctx, base);
	// 82A1E0A4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A1E0A8: 4B7F6D31  bl 0x82214dd8
	ctx.lr = 0x82A1E0AC;
	sub_82214DD8(ctx, base);
	// 82A1E0AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1E0B0: 4B7F6D29  bl 0x82214dd8
	ctx.lr = 0x82A1E0B4;
	sub_82214DD8(ctx, base);
	// 82A1E0B4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1E0B8: 4B7F6D21  bl 0x82214dd8
	ctx.lr = 0x82A1E0BC;
	sub_82214DD8(ctx, base);
	// 82A1E0BC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82A1E0C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1E0C4: 409A000C  bne cr6, 0x82a1e0d0
	if !ctx.cr[6].eq {
	pc = 0x82A1E0D0; continue 'dispatch;
	}
	// 82A1E0C8: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 82A1E0CC: 48000008  b 0x82a1e0d4
	pc = 0x82A1E0D4; continue 'dispatch;
            }
            0x82A1E0D0 => {
    //   block [0x82A1E0D0..0x82A1E0D4)
	// 82A1E0D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A1E0D4; continue 'dispatch;
            }
            0x82A1E0D4 => {
    //   block [0x82A1E0D4..0x82A1E0E8)
	// 82A1E0D4: 81580010  lwz r10, 0x10(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1E0D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1E0DC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A1E0E0: 91780010  stw r11, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A1E0E4: 4B7F6CF5  bl 0x82214dd8
	ctx.lr = 0x82A1E0E8;
	sub_82214DD8(ctx, base);
	pc = 0x82A1E0E8; continue 'dispatch;
            }
            0x82A1E0E8 => {
    //   block [0x82A1E0E8..0x82A1E0EC)
	// 82A1E0E8: 92380048  stw r17, 0x48(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(72 as u32), ctx.r[17].u32 ) };
	pc = 0x82A1E0EC; continue 'dispatch;
            }
            0x82A1E0EC => {
    //   block [0x82A1E0EC..0x82A1E178)
	// 82A1E0EC: 55EB063E  clrlwi r11, r15, 0x18
	ctx.r[11].u64 = ctx.r[15].u32 as u64 & 0x000000FFu64;
	// 82A1E0F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1E0F4: 419A0130  beq cr6, 0x82a1e224
	if ctx.cr[6].eq {
	pc = 0x82A1E224; continue 'dispatch;
	}
	// 82A1E0F8: 81580038  lwz r10, 0x38(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(56 as u32) ) } as u64;
	// 82A1E0FC: 3978004C  addi r11, r24, 0x4c
	ctx.r[11].s64 = ctx.r[24].s64 + 76;
	// 82A1E100: 8138004C  lwz r9, 0x4c(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(76 as u32) ) } as u64;
	// 82A1E104: 390AFFFF  addi r8, r10, -1
	ctx.r[8].s64 = ctx.r[10].s64 + -1;
	// 82A1E108: 39490001  addi r10, r9, 1
	ctx.r[10].s64 = ctx.r[9].s64 + 1;
	// 82A1E10C: 7D4BFE70  srawi r11, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 82A1E110: 7D6A5038  and r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 & ctx.r[10].u64;
	// 82A1E114: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82A1E118: 7D2A4050  subf r9, r10, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 82A1E11C: 7D28FE70  srawi r8, r9, 0x1f
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 31) as i64;
	// 82A1E120: 7D094838  and r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 82A1E124: 7CE95214  add r7, r9, r10
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82A1E128: 54EA003E  slwi r10, r7, 0
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1E12C: 90F8004C  stw r7, 0x4c(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(76 as u32), ctx.r[7].u32 ) };
	// 82A1E130: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 82A1E134: 409A005C  bne cr6, 0x82a1e190
	if !ctx.cr[6].eq {
	pc = 0x82A1E190; continue 'dispatch;
	}
	// 82A1E138: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 82A1E13C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A1E140: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1E144: 4B80ED8D  bl 0x8222ced0
	ctx.lr = 0x82A1E148;
	sub_8222CED0(ctx, base);
	// 82A1E148: 38780008  addi r3, r24, 8
	ctx.r[3].s64 = ctx.r[24].s64 + 8;
	// 82A1E14C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A1E150: 4B847051  bl 0x822651a0
	ctx.lr = 0x82A1E154;
	sub_822651A0(ctx, base);
	// 82A1E154: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1E158: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1E15C: 409A001C  bne cr6, 0x82a1e178
	if !ctx.cr[6].eq {
	pc = 0x82A1E178; continue 'dispatch;
	}
	// 82A1E160: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 82A1E164: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1E168: 91780010  stw r11, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A1E16C: 4B7F6C6D  bl 0x82214dd8
	ctx.lr = 0x82A1E170;
	sub_82214DD8(ctx, base);
	// 82A1E170: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82A1E174: 4828B2B0  b 0x82ca9424
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A1E178 => {
    //   block [0x82A1E178..0x82A1E190)
	// 82A1E178: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E17C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1E180: 91780010  stw r11, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A1E184: 4B7F6C55  bl 0x82214dd8
	ctx.lr = 0x82A1E188;
	sub_82214DD8(ctx, base);
	// 82A1E188: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82A1E18C: 4828B298  b 0x82ca9424
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A1E190 => {
    //   block [0x82A1E190..0x82A1E1A8)
	// 82A1E190: 81780034  lwz r11, 0x34(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A1E194: 81380038  lwz r9, 0x38(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(56 as u32) ) } as u64;
	// 82A1E198: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82A1E19C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1E1A0: 40990008  ble cr6, 0x82a1e1a8
	if !ctx.cr[6].gt {
	pc = 0x82A1E1A8; continue 'dispatch;
	}
	// 82A1E1A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A1E1A8; continue 'dispatch;
            }
            0x82A1E1A8 => {
    //   block [0x82A1E1A8..0x82A1E1BC)
	// 82A1E1A8: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A1E1AC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1E1B0: 4199000C  bgt cr6, 0x82a1e1bc
	if ctx.cr[6].gt {
	pc = 0x82A1E1BC; continue 'dispatch;
	}
	// 82A1E1B4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A1E1B8: 40980008  bge cr6, 0x82a1e1c0
	if !ctx.cr[6].lt {
	pc = 0x82A1E1C0; continue 'dispatch;
	}
	pc = 0x82A1E1BC; continue 'dispatch;
            }
            0x82A1E1BC => {
    //   block [0x82A1E1BC..0x82A1E1C0)
	// 82A1E1BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A1E1C0; continue 'dispatch;
            }
            0x82A1E1C0 => {
    //   block [0x82A1E1C0..0x82A1E1D4)
	// 82A1E1C0: 554BF0BE  srwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1E1C4: 554807BE  clrlwi r8, r10, 0x1e
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 82A1E1C8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1E1CC: 41980008  blt cr6, 0x82a1e1d4
	if ctx.cr[6].lt {
	pc = 0x82A1E1D4; continue 'dispatch;
	}
	// 82A1E1D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A1E1D4; continue 'dispatch;
            }
            0x82A1E1D4 => {
    //   block [0x82A1E1D4..0x82A1E1E4)
	// 82A1E1D4: 81580030  lwz r10, 0x30(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(48 as u32) ) } as u64;
	// 82A1E1D8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A1E1DC: 41990008  bgt cr6, 0x82a1e1e4
	if ctx.cr[6].gt {
	pc = 0x82A1E1E4; continue 'dispatch;
	}
	// 82A1E1E0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	pc = 0x82A1E1E4; continue 'dispatch;
            }
            0x82A1E1E4 => {
    //   block [0x82A1E1E4..0x82A1E21C)
	// 82A1E1E4: 8158002C  lwz r10, 0x2c(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(44 as u32) ) } as u64;
	// 82A1E1E8: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A1E1EC: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1E1F0: 38780008  addi r3, r24, 8
	ctx.r[3].s64 = ctx.r[24].s64 + 8;
	// 82A1E1F4: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82A1E1F8: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A1E1FC: 4B846FA5  bl 0x822651a0
	ctx.lr = 0x82A1E200;
	sub_822651A0(ctx, base);
	// 82A1E200: 81780008  lwz r11, 8(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1E204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1E208: 409A0014  bne cr6, 0x82a1e21c
	if !ctx.cr[6].eq {
	pc = 0x82A1E21C; continue 'dispatch;
	}
	// 82A1E20C: 7E2B8B78  mr r11, r17
	ctx.r[11].u64 = ctx.r[17].u64;
	// 82A1E210: 91780010  stw r11, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A1E214: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82A1E218: 4828B20C  b 0x82ca9424
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A1E21C => {
    //   block [0x82A1E21C..0x82A1E224)
	// 82A1E21C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E220: 91780010  stw r11, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x82A1E224; continue 'dispatch;
            }
            0x82A1E224 => {
    //   block [0x82A1E224..0x82A1E22C)
	// 82A1E224: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82A1E228: 4828B1FC  b 0x82ca9424
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1E230 size=164
    let mut pc: u32 = 0x82A1E230;
    'dispatch: loop {
        match pc {
            0x82A1E230 => {
    //   block [0x82A1E230..0x82A1E270)
	// 82A1E230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1E234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1E238: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1E23C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1E240: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1E244: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1E248: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1E24C: 4B7D097D  bl 0x821eebc8
	ctx.lr = 0x82A1E250;
	sub_821EEBC8(ctx, base);
	// 82A1E250: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1E254: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1E258: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E25C: 4B7D096D  bl 0x821eebc8
	ctx.lr = 0x82A1E260;
	sub_821EEBC8(ctx, base);
	// 82A1E260: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E264: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E268: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A1E26C: 409A000C  bne cr6, 0x82a1e278
	if !ctx.cr[6].eq {
	pc = 0x82A1E278; continue 'dispatch;
	}
	pc = 0x82A1E270; continue 'dispatch;
            }
            0x82A1E270 => {
    //   block [0x82A1E270..0x82A1E278)
	// 82A1E270: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A1E274: 48000034  b 0x82a1e2a8
	pc = 0x82A1E2A8; continue 'dispatch;
            }
            0x82A1E278 => {
    //   block [0x82A1E278..0x82A1E288)
	// 82A1E278: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1E27C: 409A000C  bne cr6, 0x82a1e288
	if !ctx.cr[6].eq {
	pc = 0x82A1E288; continue 'dispatch;
	}
	// 82A1E280: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82A1E284: 48000024  b 0x82a1e2a8
	pc = 0x82A1E2A8; continue 'dispatch;
            }
            0x82A1E288 => {
    //   block [0x82A1E288..0x82A1E2A8)
	// 82A1E288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1E28C: 419AFFE4  beq cr6, 0x82a1e270
	if ctx.cr[6].eq {
	pc = 0x82A1E270; continue 'dispatch;
	}
	// 82A1E290: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E294: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E298: 4B84F561  bl 0x8226d7f8
	ctx.lr = 0x82A1E29C;
	sub_8226D7F8(ctx, base);
	// 82A1E29C: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82A1E2A0: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82A1E2A4: 555FDFFE  rlwinm r31, r10, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x82A1E2A8; continue 'dispatch;
            }
            0x82A1E2A8 => {
    //   block [0x82A1E2A8..0x82A1E2D4)
	// 82A1E2A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E2AC: 4B7F6B2D  bl 0x82214dd8
	ctx.lr = 0x82A1E2B0;
	sub_82214DD8(ctx, base);
	// 82A1E2B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1E2B4: 4B7F6B25  bl 0x82214dd8
	ctx.lr = 0x82A1E2B8;
	sub_82214DD8(ctx, base);
	// 82A1E2B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E2BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A1E2C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1E2C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1E2C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1E2CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1E2D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E2D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1E2D8 size=788
    let mut pc: u32 = 0x82A1E2D8;
    'dispatch: loop {
        match pc {
            0x82A1E2D8 => {
    //   block [0x82A1E2D8..0x82A1E380)
	// 82A1E2D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1E2DC: 4828B10D  bl 0x82ca93e8
	ctx.lr = 0x82A1E2E0;
	sub_82CA93D0(ctx, base);
	// 82A1E2E0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1E2E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A1E2E8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1E2EC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A1E2F0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A1E2F4: 388B2A50  addi r4, r11, 0x2a50
	ctx.r[4].s64 = ctx.r[11].s64 + 10832;
	// 82A1E2F8: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 82A1E2FC: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 82A1E300: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 82A1E304: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 82A1E308: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E30C: 7CD53378  mr r21, r6
	ctx.r[21].u64 = ctx.r[6].u64;
	// 82A1E310: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 82A1E314: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 82A1E318: 480061C1  bl 0x82a244d8
	ctx.lr = 0x82A1E31C;
	sub_82A244D8(ctx, base);
	// 82A1E31C: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E320: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A1E324: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82A1E328: 48005DB9  bl 0x82a240e0
	ctx.lr = 0x82A1E32C;
	sub_82A240E0(ctx, base);
	// 82A1E32C: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1E330: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1E334: 38CBFFF8  addi r6, r11, -8
	ctx.r[6].s64 = ctx.r[11].s64 + -8;
	// 82A1E338: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 82A1E33C: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82A1E340: 4B80A291  bl 0x822285d0
	ctx.lr = 0x82A1E344;
	sub_822285D0(ctx, base);
	// 82A1E344: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A1E348: 3BAB9700  addi r29, r11, -0x6900
	ctx.r[29].s64 = ctx.r[11].s64 + -26880;
	// 82A1E34C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E350: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1E354: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 82A1E358: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A1E35C: 419A0024  beq cr6, 0x82a1e380
	if ctx.cr[6].eq {
	pc = 0x82A1E380; continue 'dispatch;
	}
	// 82A1E360: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E364: 2F0A0005  cmpwi cr6, r10, 5
	ctx.cr[6].compare_i32(ctx.r[10].s32, 5, &mut ctx.xer);
	// 82A1E368: 409A0018  bne cr6, 0x82a1e380
	if !ctx.cr[6].eq {
	pc = 0x82A1E380; continue 'dispatch;
	}
	// 82A1E36C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1E370: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1E374: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82A1E378: 7D1B1E70  srawi r27, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82A1E37C: 48000010  b 0x82a1e38c
	pc = 0x82A1E38C; continue 'dispatch;
            }
            0x82A1E380 => {
    //   block [0x82A1E380..0x82A1E38C)
	// 82A1E380: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1E384: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 82A1E388: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82A1E38C; continue 'dispatch;
            }
            0x82A1E38C => {
    //   block [0x82A1E38C..0x82A1E3C4)
	// 82A1E38C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E390: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1E394: 93890004  stw r28, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A1E398: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A1E39C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1E3A0: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 82A1E3A4: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A1E3A8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A1E3AC: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 82A1E3B0: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 82A1E3B4: 3B2B7088  addi r25, r11, 0x7088
	ctx.r[25].s64 = ctx.r[11].s64 + 28808;
	// 82A1E3B8: 3B4AFFDF  addi r26, r10, -0x21
	ctx.r[26].s64 = ctx.r[10].s64 + -33;
	// 82A1E3BC: 3B094A04  addi r24, r9, 0x4a04
	ctx.r[24].s64 = ctx.r[9].s64 + 18948;
	// 82A1E3C0: 3AE82A64  addi r23, r8, 0x2a64
	ctx.r[23].s64 = ctx.r[8].s64 + 10852;
	pc = 0x82A1E3C4; continue 'dispatch;
            }
            0x82A1E3C4 => {
    //   block [0x82A1E3C4..0x82A1E44C)
	// 82A1E3C4: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E3C8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A1E3CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E3D0: 48005D11  bl 0x82a240e0
	ctx.lr = 0x82A1E3D4;
	sub_82A240E0(ctx, base);
	// 82A1E3D4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82A1E3D8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1E3DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E3E0: 38ABFFF8  addi r5, r11, -8
	ctx.r[5].s64 = ctx.r[11].s64 + -8;
	// 82A1E3E4: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E3E8: 4B80ABD9  bl 0x82228fc0
	ctx.lr = 0x82A1E3EC;
	sub_82228FC0(ctx, base);
	// 82A1E3EC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A1E3F0: 419A0168  beq cr6, 0x82a1e558
	if ctx.cr[6].eq {
	pc = 0x82A1E558; continue 'dispatch;
	}
	// 82A1E3F4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1E3F8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A1E3FC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A1E400: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E404: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1E408: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 82A1E40C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A1E410: 419A0134  beq cr6, 0x82a1e544
	if ctx.cr[6].eq {
	pc = 0x82A1E544; continue 'dispatch;
	}
	// 82A1E414: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E418: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A1E41C: 409A0128  bne cr6, 0x82a1e544
	if !ctx.cr[6].eq {
	pc = 0x82A1E544; continue 'dispatch;
	}
	// 82A1E420: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1E424: 388BFFF0  addi r4, r11, -0x10
	ctx.r[4].s64 = ctx.r[11].s64 + -16;
	// 82A1E428: 816BFFF4  lwz r11, -0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82A1E42C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A1E430: 419A0040  beq cr6, 0x82a1e470
	if ctx.cr[6].eq {
	pc = 0x82A1E470; continue 'dispatch;
	}
	// 82A1E434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E438: 4B880921  bl 0x8229ed58
	ctx.lr = 0x82A1E43C;
	sub_8229ED58(ctx, base);
	// 82A1E43C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A1E440: 409A000C  bne cr6, 0x82a1e44c
	if !ctx.cr[6].eq {
	pc = 0x82A1E44C; continue 'dispatch;
	}
	// 82A1E444: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A1E448: 48000030  b 0x82a1e478
	pc = 0x82A1E478; continue 'dispatch;
            }
            0x82A1E44C => {
    //   block [0x82A1E44C..0x82A1E468)
	// 82A1E44C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1E450: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82A1E454: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82A1E458: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1E45C: 4198000C  blt cr6, 0x82a1e468
	if ctx.cr[6].lt {
	pc = 0x82A1E468; continue 'dispatch;
	}
	// 82A1E460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E464: 4B75B11D  bl 0x82179580
	ctx.lr = 0x82A1E468;
	sub_82179580(ctx, base);
	pc = 0x82A1E468; continue 'dispatch;
            }
            0x82A1E468 => {
    //   block [0x82A1E468..0x82A1E470)
	// 82A1E468: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1E46C: 388BFFF0  addi r4, r11, -0x10
	ctx.r[4].s64 = ctx.r[11].s64 + -16;
	pc = 0x82A1E470; continue 'dispatch;
            }
            0x82A1E470 => {
    //   block [0x82A1E470..0x82A1E478)
	// 82A1E470: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E474: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	pc = 0x82A1E478; continue 'dispatch;
            }
            0x82A1E478 => {
    //   block [0x82A1E478..0x82A1E49C)
	// 82A1E478: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A1E47C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E480: 4B80EA51  bl 0x8222ced0
	ctx.lr = 0x82A1E484;
	sub_8222CED0(ctx, base);
	// 82A1E484: 81750000  lwz r11, 0(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E488: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A1E48C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1E490: 419A000C  beq cr6, 0x82a1e49c
	if ctx.cr[6].eq {
	pc = 0x82A1E49C; continue 'dispatch;
	}
	// 82A1E494: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E498: 409A000C  bne cr6, 0x82a1e4a4
	if !ctx.cr[6].eq {
	pc = 0x82A1E4A4; continue 'dispatch;
	}
	pc = 0x82A1E49C; continue 'dispatch;
            }
            0x82A1E49C => {
    //   block [0x82A1E49C..0x82A1E4A4)
	// 82A1E49C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A1E4A0: 48000008  b 0x82a1e4a8
	pc = 0x82A1E4A8; continue 'dispatch;
            }
            0x82A1E4A4 => {
    //   block [0x82A1E4A4..0x82A1E4A8)
	// 82A1E4A4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1E4A8; continue 'dispatch;
            }
            0x82A1E4A8 => {
    //   block [0x82A1E4A8..0x82A1E4BC)
	// 82A1E4A8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1E4AC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A1E4B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1E4B4: 419A0008  beq cr6, 0x82a1e4bc
	if ctx.cr[6].eq {
	pc = 0x82A1E4BC; continue 'dispatch;
	}
	// 82A1E4B8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1E4BC; continue 'dispatch;
            }
            0x82A1E4BC => {
    //   block [0x82A1E4BC..0x82A1E50C)
	// 82A1E4BC: 482937CD  bl 0x82cb1c88
	ctx.lr = 0x82A1E4C0;
	sub_82CB1C88(ctx, base);
	// 82A1E4C0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A1E4C4: 409A0054  bne cr6, 0x82a1e518
	if !ctx.cr[6].eq {
	pc = 0x82A1E518; continue 'dispatch;
	}
	// 82A1E4C8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82A1E4CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E4D0: 4B87CCE9  bl 0x8229b1b8
	ctx.lr = 0x82A1E4D4;
	sub_8229B1B8(ctx, base);
	// 82A1E4D4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1E4D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1E4DC: 419A003C  beq cr6, 0x82a1e518
	if ctx.cr[6].eq {
	pc = 0x82A1E518; continue 'dispatch;
	}
	// 82A1E4E0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E4E4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1E4E8: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 82A1E4EC: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A1E4F0: 419A001C  beq cr6, 0x82a1e50c
	if ctx.cr[6].eq {
	pc = 0x82A1E50C; continue 'dispatch;
	}
	// 82A1E4F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E4F8: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82A1E4FC: 409A0010  bne cr6, 0x82a1e50c
	if !ctx.cr[6].eq {
	pc = 0x82A1E50C; continue 'dispatch;
	}
	// 82A1E500: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A1E504: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E508: 4B7BC4B9  bl 0x821da9c0
	ctx.lr = 0x82A1E50C;
	sub_821DA9C0(ctx, base);
	pc = 0x82A1E50C; continue 'dispatch;
            }
            0x82A1E50C => {
    //   block [0x82A1E50C..0x82A1E518)
	// 82A1E50C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1E510: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1E514: 4B902DF5  bl 0x82321308
	ctx.lr = 0x82A1E518;
	sub_82321308(ctx, base);
	pc = 0x82A1E518; continue 'dispatch;
            }
            0x82A1E518 => {
    //   block [0x82A1E518..0x82A1E524)
	// 82A1E518: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E51C: 4B7A824D  bl 0x821c6768
	ctx.lr = 0x82A1E520;
	sub_821C6768(ctx, base);
	// 82A1E520: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	pc = 0x82A1E524; continue 'dispatch;
            }
            0x82A1E524 => {
    //   block [0x82A1E524..0x82A1E544)
	// 82A1E524: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A1E528: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E52C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A1E530: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A1E534: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1E538: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E53C: 4082FFE8  bne 0x82a1e524
	if !ctx.cr[0].eq {
	pc = 0x82A1E524; continue 'dispatch;
	}
	// 82A1E540: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	pc = 0x82A1E544; continue 'dispatch;
            }
            0x82A1E544 => {
    //   block [0x82A1E544..0x82A1E558)
	// 82A1E544: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E548: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1E54C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 82A1E550: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82A1E554: 4BFFFE70  b 0x82a1e3c4
	pc = 0x82A1E3C4; continue 'dispatch;
            }
            0x82A1E558 => {
    //   block [0x82A1E558..0x82A1E5C4)
	// 82A1E558: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1E55C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82A1E560: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1E564: 7D3E5850  subf r9, r30, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82A1E568: 390AFFF8  addi r8, r10, -8
	ctx.r[8].s64 = ctx.r[10].s64 + -8;
	// 82A1E56C: 7D251670  srawi r5, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 82A1E570: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A1E574: 7F162840  cmplw cr6, r22, r5
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A1E578: 4098004C  bge cr6, 0x82a1e5c4
	if !ctx.cr[6].lt {
	pc = 0x82A1E5C4; continue 'dispatch;
	}
	// 82A1E57C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82A1E580: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82A1E584: 3D6082A2  lis r11, -0x7d5e
	ctx.r[11].s64 = -2103312384;
	// 82A1E588: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82A1E58C: 38CBE230  addi r6, r11, -0x1dd0
	ctx.r[6].s64 = ctx.r[11].s64 + -7632;
	// 82A1E590: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 82A1E594: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A1E598: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A1E59C: 48000BBD  bl 0x82a1f158
	ctx.lr = 0x82A1E5A0;
	sub_82A1F158(ctx, base);
	// 82A1E5A0: 56CB103A  slwi r11, r22, 2
	ctx.r[11].u32 = ctx.r[22].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1E5A4: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82A1E5A8: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A1E5AC: 4B7D1C95  bl 0x821f0240
	ctx.lr = 0x82A1E5B0;
	sub_821F0240(ctx, base);
	// 82A1E5B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1E5B4: 4B8FC5A5  bl 0x8231ab58
	ctx.lr = 0x82A1E5B8;
	sub_8231AB58(ctx, base);
	// 82A1E5B8: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82A1E5BC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A1E5C0: 4828AE78  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A1E5C4 => {
    //   block [0x82A1E5C4..0x82A1E5EC)
	// 82A1E5C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1E5C8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A1E5CC: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 82A1E5D0: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82A1E5D4: 4B80E8FD  bl 0x8222ced0
	ctx.lr = 0x82A1E5D8;
	sub_8222CED0(ctx, base);
	// 82A1E5D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1E5DC: 4B8FC57D  bl 0x8231ab58
	ctx.lr = 0x82A1E5E0;
	sub_8231AB58(ctx, base);
	// 82A1E5E0: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82A1E5E4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82A1E5E8: 4828AE50  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1E5F0 size=804
    let mut pc: u32 = 0x82A1E5F0;
    'dispatch: loop {
        match pc {
            0x82A1E5F0 => {
    //   block [0x82A1E5F0..0x82A1E618)
	// 82A1E5F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1E5F4: 4828AE05  bl 0x82ca93f8
	ctx.lr = 0x82A1E5F8;
	sub_82CA93D0(ctx, base);
	// 82A1E5F8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1E5FC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A1E600: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A1E604: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A1E608: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 82A1E60C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A1E610: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82A1E614: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	pc = 0x82A1E618; continue 'dispatch;
            }
            0x82A1E618 => {
    //   block [0x82A1E618..0x82A1E68C)
	// 82A1E618: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1E61C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E620: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1E624: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1E628: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1E62C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E630: 4082FFE8  bne 0x82a1e618
	if !ctx.cr[0].eq {
	pc = 0x82A1E618; continue 'dispatch;
	}
	// 82A1E634: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82A1E638: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A1E63C: 38870CA0  addi r4, r7, 0xca0
	ctx.r[4].s64 = ctx.r[7].s64 + 3232;
	// 82A1E640: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1E644: 4B80E88D  bl 0x8222ced0
	ctx.lr = 0x82A1E648;
	sub_8222CED0(ctx, base);
	// 82A1E648: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A1E64C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A1E650: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A1E654: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1E658: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A1E65C: 4B8FA9AD  bl 0x82319008
	ctx.lr = 0x82A1E660;
	sub_82319008(ctx, base);
	// 82A1E660: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1E664: 4B7F6775  bl 0x82214dd8
	ctx.lr = 0x82A1E668;
	sub_82214DD8(ctx, base);
	// 82A1E668: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A1E66C: 4B7D0545  bl 0x821eebb0
	ctx.lr = 0x82A1E670;
	sub_821EEBB0(ctx, base);
	// 82A1E670: 83E10094  lwz r31, 0x94(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A1E674: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A1E678: 40980238  bge cr6, 0x82a1e8b0
	if !ctx.cr[6].lt {
	pc = 0x82A1E8B0; continue 'dispatch;
	}
	// 82A1E67C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A1E680: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82A1E684: 3B4B4A00  addi r26, r11, 0x4a00
	ctx.r[26].s64 = ctx.r[11].s64 + 18944;
	// 82A1E688: 3B2AABAC  addi r25, r10, -0x5454
	ctx.r[25].s64 = ctx.r[10].s64 + -21588;
	pc = 0x82A1E68C; continue 'dispatch;
            }
            0x82A1E68C => {
    //   block [0x82A1E68C..0x82A1E694)
	// 82A1E68C: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82A1E690: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	pc = 0x82A1E694; continue 'dispatch;
            }
            0x82A1E694 => {
    //   block [0x82A1E694..0x82A1E6E0)
	// 82A1E694: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A1E698: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E69C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A1E6A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A1E6A4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1E6A8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E6AC: 4082FFE8  bne 0x82a1e694
	if !ctx.cr[0].eq {
	pc = 0x82A1E694; continue 'dispatch;
	}
	// 82A1E6B0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A1E6B4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A1E6B8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1E6BC: 4B80E815  bl 0x8222ced0
	ctx.lr = 0x82A1E6C0;
	sub_8222CED0(ctx, base);
	// 82A1E6C0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82A1E6C4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A1E6C8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1E6CC: 4812DC6D  bl 0x82b4c338
	ctx.lr = 0x82A1E6D0;
	sub_82B4C338(ctx, base);
	// 82A1E6D0: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82A1E6D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1E6D8: 4B7A8091  bl 0x821c6768
	ctx.lr = 0x82A1E6DC;
	sub_821C6768(ctx, base);
	// 82A1E6DC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	pc = 0x82A1E6E0; continue 'dispatch;
            }
            0x82A1E6E0 => {
    //   block [0x82A1E6E0..0x82A1E73C)
	// 82A1E6E0: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 82A1E6E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E6E8: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 82A1E6EC: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82A1E6F0: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1E6F4: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E6F8: 4082FFE8  bne 0x82a1e6e0
	if !ctx.cr[0].eq {
	pc = 0x82A1E6E0; continue 'dispatch;
	}
	// 82A1E6FC: 5705063E  clrlwi r5, r24, 0x18
	ctx.r[5].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 82A1E700: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82A1E704: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82A1E708: 419A0114  beq cr6, 0x82a1e81c
	if ctx.cr[6].eq {
	pc = 0x82A1E81C; continue 'dispatch;
	}
	// 82A1E70C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A1E710: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1E714: 4B7CE0E5  bl 0x821ec7f8
	ctx.lr = 0x82A1E718;
	sub_821EC7F8(ctx, base);
	// 82A1E718: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1E71C: 4B7D0495  bl 0x821eebb0
	ctx.lr = 0x82A1E720;
	sub_821EEBB0(ctx, base);
	// 82A1E720: 7C6B1670  srawi r11, r3, 2
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[3].s32 >> 2) as i64;
	// 82A1E724: 7D4B0194  addze r10, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82A1E728: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A1E72C: 7D091850  subf r8, r9, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[9].s64;
	// 82A1E730: 23E80004  subfic r31, r8, 4
	ctx.xer.ca = ctx.r[8].u32 <= 4 as u32;
	ctx.r[31].s64 = (4 as i64) - ctx.r[8].s64;
	// 82A1E734: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A1E738: 40990018  ble cr6, 0x82a1e750
	if !ctx.cr[6].gt {
	pc = 0x82A1E750; continue 'dispatch;
	}
	pc = 0x82A1E73C; continue 'dispatch;
            }
            0x82A1E73C => {
    //   block [0x82A1E73C..0x82A1E750)
	// 82A1E73C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A1E740: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1E744: 4B7BC27D  bl 0x821da9c0
	ctx.lr = 0x82A1E748;
	sub_821DA9C0(ctx, base);
	// 82A1E748: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A1E74C: 4082FFF0  bne 0x82a1e73c
	if !ctx.cr[0].eq {
	pc = 0x82A1E73C; continue 'dispatch;
	}
	pc = 0x82A1E750; continue 'dispatch;
            }
            0x82A1E750 => {
    //   block [0x82A1E750..0x82A1E7B0)
	// 82A1E750: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82A1E754: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A1E758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E75C: 4B80E775  bl 0x8222ced0
	ctx.lr = 0x82A1E760;
	sub_8222CED0(ctx, base);
	// 82A1E760: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1E764: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1E768: 4812E329  bl 0x82b4ca90
	ctx.lr = 0x82A1E76C;
	sub_82B4CA90(ctx, base);
	// 82A1E76C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1E770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1E774: 419A0078  beq cr6, 0x82a1e7ec
	if ctx.cr[6].eq {
	pc = 0x82A1E7EC; continue 'dispatch;
	}
	// 82A1E778: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A1E77C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1E780: 419A006C  beq cr6, 0x82a1e7ec
	if ctx.cr[6].eq {
	pc = 0x82A1E7EC; continue 'dispatch;
	}
	// 82A1E784: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E788: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82A1E78C: 419A0060  beq cr6, 0x82a1e7ec
	if ctx.cr[6].eq {
	pc = 0x82A1E7EC; continue 'dispatch;
	}
	// 82A1E790: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A1E794: 81010094  lwz r8, 0x94(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A1E798: 7D4B3214  add r10, r11, r6
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 82A1E79C: 88E10090  lbz r7, 0x90(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82A1E7A0: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82A1E7A4: 7D2A4214  add r9, r10, r8
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82A1E7A8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1E7AC: 419A0034  beq cr6, 0x82a1e7e0
	if ctx.cr[6].eq {
	pc = 0x82A1E7E0; continue 'dispatch;
	}
	pc = 0x82A1E7B0; continue 'dispatch;
            }
            0x82A1E7B0 => {
    //   block [0x82A1E7B0..0x82A1E7C8)
	// 82A1E7B0: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E7B4: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 82A1E7B8: 2F0A0022  cmpwi cr6, r10, 0x22
	ctx.cr[6].compare_i32(ctx.r[10].s32, 34, &mut ctx.xer);
	// 82A1E7BC: 419A000C  beq cr6, 0x82a1e7c8
	if ctx.cr[6].eq {
	pc = 0x82A1E7C8; continue 'dispatch;
	}
	// 82A1E7C0: 2F0A0027  cmpwi cr6, r10, 0x27
	ctx.cr[6].compare_i32(ctx.r[10].s32, 39, &mut ctx.xer);
	// 82A1E7C4: 409A0010  bne cr6, 0x82a1e7d4
	if !ctx.cr[6].eq {
	pc = 0x82A1E7D4; continue 'dispatch;
	}
	pc = 0x82A1E7C8; continue 'dispatch;
            }
            0x82A1E7C8 => {
    //   block [0x82A1E7C8..0x82A1E7D4)
	// 82A1E7C8: 54EA063E  clrlwi r10, r7, 0x18
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82A1E7CC: 7D470034  cntlzw r7, r10
	ctx.r[7].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82A1E7D0: 54E7DFFE  rlwinm r7, r7, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	pc = 0x82A1E7D4; continue 'dispatch;
            }
            0x82A1E7D4 => {
    //   block [0x82A1E7D4..0x82A1E7E0)
	// 82A1E7D4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A1E7D8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1E7DC: 409AFFD4  bne cr6, 0x82a1e7b0
	if !ctx.cr[6].eq {
	pc = 0x82A1E7B0; continue 'dispatch;
	}
	pc = 0x82A1E7E0; continue 'dispatch;
            }
            0x82A1E7E0 => {
    //   block [0x82A1E7E0..0x82A1E7EC)
	// 82A1E7E0: 7D664214  add r11, r6, r8
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[8].u64;
	// 82A1E7E4: 98E10090  stb r7, 0x90(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[7].u8 ) };
	// 82A1E7E8: 91610094  stw r11, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	pc = 0x82A1E7EC; continue 'dispatch;
            }
            0x82A1E7EC => {
    //   block [0x82A1E7EC..0x82A1E7F8)
	// 82A1E7EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E7F0: 4B7A7F79  bl 0x821c6768
	ctx.lr = 0x82A1E7F4;
	sub_821C6768(ctx, base);
	// 82A1E7F4: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	pc = 0x82A1E7F8; continue 'dispatch;
            }
            0x82A1E7F8 => {
    //   block [0x82A1E7F8..0x82A1E81C)
	// 82A1E7F8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A1E7FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E800: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A1E804: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A1E808: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1E80C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E810: 4082FFE8  bne 0x82a1e7f8
	if !ctx.cr[0].eq {
	pc = 0x82A1E7F8; continue 'dispatch;
	}
	// 82A1E814: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82A1E818: 48000058  b 0x82a1e870
	pc = 0x82A1E870; continue 'dispatch;
            }
            0x82A1E81C => {
    //   block [0x82A1E81C..0x82A1E850)
	// 82A1E81C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A1E820: 4B7D0391  bl 0x821eebb0
	ctx.lr = 0x82A1E824;
	sub_821EEBB0(ctx, base);
	// 82A1E824: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A1E828: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A1E82C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A1E830: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1E834: 4B7C555D  bl 0x821e3d90
	ctx.lr = 0x82A1E838;
	sub_821E3D90(ctx, base);
	// 82A1E838: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1E83C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1E840: 4B7CDFB9  bl 0x821ec7f8
	ctx.lr = 0x82A1E844;
	sub_821EC7F8(ctx, base);
	// 82A1E844: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1E848: 4B7A7F21  bl 0x821c6768
	ctx.lr = 0x82A1E84C;
	sub_821C6768(ctx, base);
	// 82A1E84C: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	pc = 0x82A1E850; continue 'dispatch;
            }
            0x82A1E850 => {
    //   block [0x82A1E850..0x82A1E870)
	// 82A1E850: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A1E854: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E858: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A1E85C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A1E860: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1E864: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E868: 4082FFE8  bne 0x82a1e850
	if !ctx.cr[0].eq {
	pc = 0x82A1E850; continue 'dispatch;
	}
	// 82A1E86C: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	pc = 0x82A1E870; continue 'dispatch;
            }
            0x82A1E870 => {
    //   block [0x82A1E870..0x82A1E87C)
	// 82A1E870: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1E874: 4B7A7EF5  bl 0x821c6768
	ctx.lr = 0x82A1E878;
	sub_821C6768(ctx, base);
	// 82A1E878: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	pc = 0x82A1E87C; continue 'dispatch;
            }
            0x82A1E87C => {
    //   block [0x82A1E87C..0x82A1E8B0)
	// 82A1E87C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A1E880: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E884: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A1E888: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A1E88C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1E890: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E894: 4082FFE8  bne 0x82a1e87c
	if !ctx.cr[0].eq {
	pc = 0x82A1E87C; continue 'dispatch;
	}
	// 82A1E898: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A1E89C: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82A1E8A0: 4B7D0311  bl 0x821eebb0
	ctx.lr = 0x82A1E8A4;
	sub_821EEBB0(ctx, base);
	// 82A1E8A4: 83E10094  lwz r31, 0x94(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A1E8A8: 7F1F1840  cmplw cr6, r31, r3
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82A1E8AC: 4198FDE0  blt cr6, 0x82a1e68c
	if ctx.cr[6].lt {
	pc = 0x82A1E68C; continue 'dispatch;
	}
	pc = 0x82A1E8B0; continue 'dispatch;
            }
            0x82A1E8B0 => {
    //   block [0x82A1E8B0..0x82A1E8C4)
	// 82A1E8B0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A1E8B4: 4BC1BDD5  bl 0x8263a688
	ctx.lr = 0x82A1E8B8;
	sub_8263A688(ctx, base);
	// 82A1E8B8: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82A1E8BC: 4B7A7EAD  bl 0x821c6768
	ctx.lr = 0x82A1E8C0;
	sub_821C6768(ctx, base);
	// 82A1E8C0: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	pc = 0x82A1E8C4; continue 'dispatch;
            }
            0x82A1E8C4 => {
    //   block [0x82A1E8C4..0x82A1E8EC)
	// 82A1E8C4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A1E8C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E8CC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A1E8D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A1E8D4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1E8D8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E8DC: 4082FFE8  bne 0x82a1e8c4
	if !ctx.cr[0].eq {
	pc = 0x82A1E8C4; continue 'dispatch;
	}
	// 82A1E8E0: 93A1007C  stw r29, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	// 82A1E8E4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A1E8E8: 4B7A7E81  bl 0x821c6768
	ctx.lr = 0x82A1E8EC;
	sub_821C6768(ctx, base);
	pc = 0x82A1E8EC; continue 'dispatch;
            }
            0x82A1E8EC => {
    //   block [0x82A1E8EC..0x82A1E914)
	// 82A1E8EC: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 82A1E8F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E8F4: 7D00F028  lwarx r8, 0, r30
	// lwarx
	let ea = ctx.r[30].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 82A1E8F8: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82A1E8FC: 7D00F12D  stwcx. r8, 0, r30
	// stwcx.
	let addr = ctx.r[30].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1E900: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E904: 4082FFE8  bne 0x82a1e8ec
	if !ctx.cr[0].eq {
	pc = 0x82A1E8EC; continue 'dispatch;
	}
	// 82A1E908: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1E90C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A1E910: 4828AB38  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1E918 size=168
    let mut pc: u32 = 0x82A1E918;
    'dispatch: loop {
        match pc {
            0x82A1E918 => {
    //   block [0x82A1E918..0x82A1E998)
	// 82A1E918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1E91C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1E920: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1E924: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1E928: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1E92C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1E930: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82A1E934: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1E938: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E93C: 4BFFFCB5  bl 0x82a1e5f0
	ctx.lr = 0x82A1E940;
	sub_82A1E5F0(ctx, base);
	// 82A1E940: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82A1E944: 3BFE003C  addi r31, r30, 0x3c
	ctx.r[31].s64 = ctx.r[30].s64 + 60;
	// 82A1E948: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A1E94C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1E950: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82A1E954: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1E958: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A1E95C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A1E960: 4B902DE9  bl 0x82321748
	ctx.lr = 0x82A1E964;
	sub_82321748(ctx, base);
	// 82A1E964: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1E968: 4B7F6471  bl 0x82214dd8
	ctx.lr = 0x82A1E96C;
	sub_82214DD8(ctx, base);
	// 82A1E96C: 813E0044  lwz r9, 0x44(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 82A1E970: 2B0903E8  cmplwi cr6, r9, 0x3e8
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1000 as u32, &mut ctx.xer);
	// 82A1E974: 40990034  ble cr6, 0x82a1e9a8
	if !ctx.cr[6].gt {
	pc = 0x82A1E9A8; continue 'dispatch;
	}
	// 82A1E978: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E97C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82A1E980: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1E984: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1E988: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A1E98C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A1E990: 409A0008  bne cr6, 0x82a1e998
	if !ctx.cr[6].eq {
	pc = 0x82A1E998; continue 'dispatch;
	}
	// 82A1E994: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A1E998; continue 'dispatch;
            }
            0x82A1E998 => {
    //   block [0x82A1E998..0x82A1E9A8)
	// 82A1E998: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1E99C: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A1E9A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1E9A4: 4B904955  bl 0x823232f8
	ctx.lr = 0x82A1E9A8;
	sub_823232F8(ctx, base);
	pc = 0x82A1E9A8; continue 'dispatch;
            }
            0x82A1E9A8 => {
    //   block [0x82A1E9A8..0x82A1E9C0)
	// 82A1E9A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1E9AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1E9B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A1E9B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A1E9B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A1E9BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1E9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1E9C0 size=960
    let mut pc: u32 = 0x82A1E9C0;
    'dispatch: loop {
        match pc {
            0x82A1E9C0 => {
    //   block [0x82A1E9C0..0x82A1E9E8)
	// 82A1E9C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1E9C4: 4828AA1D  bl 0x82ca93e0
	ctx.lr = 0x82A1E9C8;
	sub_82CA93D0(ctx, base);
	// 82A1E9C8: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1E9CC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A1E9D0: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 82A1E9D4: 3AEB7088  addi r23, r11, 0x7088
	ctx.r[23].s64 = ctx.r[11].s64 + 28808;
	// 82A1E9D8: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 82A1E9DC: 92C1005C  stw r22, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[22].u32 ) };
	// 82A1E9E0: 7C922378  mr r18, r4
	ctx.r[18].u64 = ctx.r[4].u64;
	// 82A1E9E4: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	pc = 0x82A1E9E8; continue 'dispatch;
            }
            0x82A1E9E8 => {
    //   block [0x82A1E9E8..0x82A1EA24)
	// 82A1E9E8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1E9EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1E9F0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1E9F4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1E9F8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1E9FC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1EA00: 4082FFE8  bne 0x82a1e9e8
	if !ctx.cr[0].eq {
	pc = 0x82A1E9E8; continue 'dispatch;
	}
	// 82A1EA04: 54A7063E  clrlwi r7, r5, 0x18
	ctx.r[7].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82A1EA08: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A1EA0C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82A1EA10: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1EA14: 419A0010  beq cr6, 0x82a1ea24
	if ctx.cr[6].eq {
	pc = 0x82A1EA24; continue 'dispatch;
	}
	// 82A1EA18: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1EA1C: 388B2A6C  addi r4, r11, 0x2a6c
	ctx.r[4].s64 = ctx.r[11].s64 + 10860;
	// 82A1EA20: 4800000C  b 0x82a1ea2c
	pc = 0x82A1EA2C; continue 'dispatch;
            }
            0x82A1EA24 => {
    //   block [0x82A1EA24..0x82A1EA2C)
	// 82A1EA24: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1EA28: 388B2A70  addi r4, r11, 0x2a70
	ctx.r[4].s64 = ctx.r[11].s64 + 10864;
	pc = 0x82A1EA2C; continue 'dispatch;
            }
            0x82A1EA2C => {
    //   block [0x82A1EA2C..0x82A1EA80)
	// 82A1EA2C: 4B80E4A5  bl 0x8222ced0
	ctx.lr = 0x82A1EA30;
	sub_8222CED0(ctx, base);
	// 82A1EA30: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 82A1EA34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1EA38: 4B7CDDC1  bl 0x821ec7f8
	ctx.lr = 0x82A1EA3C;
	sub_821EC7F8(ctx, base);
	// 82A1EA3C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A1EA40: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A1EA44: 4B84675D  bl 0x822651a0
	ctx.lr = 0x82A1EA48;
	sub_822651A0(ctx, base);
	// 82A1EA48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1EA4C: 4B7F638D  bl 0x82214dd8
	ctx.lr = 0x82A1EA50;
	sub_82214DD8(ctx, base);
	// 82A1EA50: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1EA54: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A1EA58: 388B0C88  addi r4, r11, 0xc88
	ctx.r[4].s64 = ctx.r[11].s64 + 3208;
	// 82A1EA5C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1EA60: 4B80E471  bl 0x8222ced0
	ctx.lr = 0x82A1EA64;
	sub_8222CED0(ctx, base);
	// 82A1EA64: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A1EA68: 386BFFDF  addi r3, r11, -0x21
	ctx.r[3].s64 = ctx.r[11].s64 + -33;
	// 82A1EA6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A1EA70: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82A1EA74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1EA78: 419A0008  beq cr6, 0x82a1ea80
	if ctx.cr[6].eq {
	pc = 0x82A1EA80; continue 'dispatch;
	}
	// 82A1EA7C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1EA80; continue 'dispatch;
            }
            0x82A1EA80 => {
    //   block [0x82A1EA80..0x82A1EA90)
	// 82A1EA80: 81720000  lwz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1EA84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1EA88: 419A0008  beq cr6, 0x82a1ea90
	if ctx.cr[6].eq {
	pc = 0x82A1EA90; continue 'dispatch;
	}
	// 82A1EA8C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1EA90; continue 'dispatch;
            }
            0x82A1EA90 => {
    //   block [0x82A1EA90..0x82A1EB20)
	// 82A1EA90: 4B7C7D39  bl 0x821e67c8
	ctx.lr = 0x82A1EA94;
	sub_821E67C8(ctx, base);
	// 82A1EA94: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82A1EA98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1EA9C: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82A1EAA0: 695F0001  xori r31, r10, 1
	ctx.r[31].u64 = ctx.r[10].u64 ^ 1;
	// 82A1EAA4: 4B7F6335  bl 0x82214dd8
	ctx.lr = 0x82A1EAA8;
	sub_82214DD8(ctx, base);
	// 82A1EAA8: 57E9063E  clrlwi r9, r31, 0x18
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 82A1EAAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1EAB0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A1EAB4: 419A01DC  beq cr6, 0x82a1ec90
	if ctx.cr[6].eq {
	pc = 0x82A1EC90; continue 'dispatch;
	}
	// 82A1EAB8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A1EABC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A1EAC0: 3AAB0CA0  addi r21, r11, 0xca0
	ctx.r[21].s64 = ctx.r[11].s64 + 3232;
	// 82A1EAC4: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82A1EAC8: 4B80E409  bl 0x8222ced0
	ctx.lr = 0x82A1EACC;
	sub_8222CED0(ctx, base);
	// 82A1EACC: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A1EAD0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A1EAD4: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 82A1EAD8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1EADC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A1EAE0: 4B8FA529  bl 0x82319008
	ctx.lr = 0x82A1EAE4;
	sub_82319008(ctx, base);
	// 82A1EAE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1EAE8: 4B7F62F1  bl 0x82214dd8
	ctx.lr = 0x82A1EAEC;
	sub_82214DD8(ctx, base);
	// 82A1EAEC: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82A1EAF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1EAF4: 4812DB1D  bl 0x82b4c610
	ctx.lr = 0x82A1EAF8;
	sub_82B4C610(ctx, base);
	// 82A1EAF8: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82A1EAFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1EB00: 4B87C6B9  bl 0x8229b1b8
	ctx.lr = 0x82A1EB04;
	sub_8229B1B8(ctx, base);
	// 82A1EB04: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1EB08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1EB0C: 419A0164  beq cr6, 0x82a1ec70
	if ctx.cr[6].eq {
	pc = 0x82A1EC70; continue 'dispatch;
	}
	// 82A1EB10: 83210094  lwz r25, 0x94(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A1EB14: 3B53003C  addi r26, r19, 0x3c
	ctx.r[26].s64 = ctx.r[19].s64 + 60;
	// 82A1EB18: 83010070  lwz r24, 0x70(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A1EB1C: 3E808349  lis r20, -0x7cb7
	ctx.r[20].s64 = -2092367872;
	pc = 0x82A1EB20; continue 'dispatch;
            }
            0x82A1EB20 => {
    //   block [0x82A1EB20..0x82A1EB78)
	// 82A1EB20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1EB24: 4811F72D  bl 0x82b3e250
	ctx.lr = 0x82A1EB28;
	sub_82B3E250(ctx, base);
	// 82A1EB28: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A1EB2C: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 82A1EB30: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1EB34: 4BFFFABD  bl 0x82a1e5f0
	ctx.lr = 0x82A1EB38;
	sub_82A1E5F0(ctx, base);
	// 82A1EB38: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1EB3C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A1EB40: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A1EB44: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1EB48: 839E0004  lwz r28, 4(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1EB4C: 4B800775  bl 0x8221f2c0
	ctx.lr = 0x82A1EB50;
	sub_8221F2C0(ctx, base);
	// 82A1EB50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1EB54: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A1EB58: 409A0028  bne cr6, 0x82a1eb80
	if !ctx.cr[6].eq {
	pc = 0x82A1EB80; continue 'dispatch;
	}
	// 82A1EB5C: 81746F6C  lwz r11, 0x6f6c(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(28524 as u32) ) } as u64;
	// 82A1EB60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1EB64: 419A0014  beq cr6, 0x82a1eb78
	if ctx.cr[6].eq {
	pc = 0x82A1EB78; continue 'dispatch;
	}
	// 82A1EB68: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1EB6C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A1EB70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A1EB74: 4E800421  bctrl
	ctx.lr = 0x82A1EB78;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A1EB78 => {
    //   block [0x82A1EB78..0x82A1EB80)
	// 82A1EB78: 482A3831  bl 0x82cc23a8
	ctx.lr = 0x82A1EB7C;
	sub_82CC23A8(ctx, base);
	// 82A1EB7C: 48000008  b 0x82a1eb84
	pc = 0x82A1EB84; continue 'dispatch;
            }
            0x82A1EB80 => {
    //   block [0x82A1EB80..0x82A1EB84)
	// 82A1EB80: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x82A1EB84; continue 'dispatch;
            }
            0x82A1EB84 => {
    //   block [0x82A1EB84..0x82A1EB94)
	// 82A1EB84: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 82A1EB88: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A1EB8C: 419A0008  beq cr6, 0x82a1eb94
	if ctx.cr[6].eq {
	pc = 0x82A1EB94; continue 'dispatch;
	}
	// 82A1EB90: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82A1EB94; continue 'dispatch;
            }
            0x82A1EB94 => {
    //   block [0x82A1EB94..0x82A1EBA4)
	// 82A1EB94: 347F0008  addic. r3, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A1EB98: 4182000C  beq 0x82a1eba4
	if ctx.cr[0].eq {
	pc = 0x82A1EBA4; continue 'dispatch;
	}
	// 82A1EB9C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A1EBA0: 4B7D16A1  bl 0x821f0240
	ctx.lr = 0x82A1EBA4;
	sub_821F0240(ctx, base);
	pc = 0x82A1EBA4; continue 'dispatch;
            }
            0x82A1EBA4 => {
    //   block [0x82A1EBA4..0x82A1EBC8)
	// 82A1EBA4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A1EBA8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A1EBAC: 4B903CCD  bl 0x82322878
	ctx.lr = 0x82A1EBB0;
	sub_82322878(ctx, base);
	// 82A1EBB0: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A1EBB4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1EBB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1EBBC: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A1EBC0: 4B7A7BA9  bl 0x821c6768
	ctx.lr = 0x82A1EBC4;
	sub_821C6768(ctx, base);
	// 82A1EBC4: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	pc = 0x82A1EBC8; continue 'dispatch;
            }
            0x82A1EBC8 => {
    //   block [0x82A1EBC8..0x82A1EC14)
	// 82A1EBC8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1EBCC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1EBD0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1EBD4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A1EBD8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1EBDC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1EBE0: 4082FFE8  bne 0x82a1ebc8
	if !ctx.cr[0].eq {
	pc = 0x82A1EBC8; continue 'dispatch;
	}
	// 82A1EBE4: 92C10060  stw r22, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[22].u32 ) };
	// 82A1EBE8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A1EBEC: 7C99C214  add r4, r25, r24
	ctx.r[4].u64 = ctx.r[25].u64 + ctx.r[24].u64;
	// 82A1EBF0: 4812E1C1  bl 0x82b4cdb0
	ctx.lr = 0x82A1EBF4;
	sub_82B4CDB0(ctx, base);
	// 82A1EBF4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A1EBF8: 83210094  lwz r25, 0x94(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A1EBFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1EC00: 83010070  lwz r24, 0x70(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82A1EC04: 419A0010  beq cr6, 0x82a1ec14
	if ctx.cr[6].eq {
	pc = 0x82A1EC14; continue 'dispatch;
	}
	// 82A1EC08: 7D64C850  subf r11, r4, r25
	ctx.r[11].s64 = ctx.r[25].s64 - ctx.r[4].s64;
	// 82A1EC0C: 7CABC214  add r5, r11, r24
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 82A1EC10: 4800000C  b 0x82a1ec1c
	pc = 0x82A1EC1C; continue 'dispatch;
            }
            0x82A1EC14 => {
    //   block [0x82A1EC14..0x82A1EC1C)
	// 82A1EC14: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82A1EC18: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	pc = 0x82A1EC1C; continue 'dispatch;
            }
            0x82A1EC1C => {
    //   block [0x82A1EC1C..0x82A1EC38)
	// 82A1EC1C: 4B80E2B5  bl 0x8222ced0
	ctx.lr = 0x82A1EC20;
	sub_8222CED0(ctx, base);
	// 82A1EC20: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A1EC24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1EC28: 4B846579  bl 0x822651a0
	ctx.lr = 0x82A1EC2C;
	sub_822651A0(ctx, base);
	// 82A1EC2C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1EC30: 4B7A7B39  bl 0x821c6768
	ctx.lr = 0x82A1EC34;
	sub_821C6768(ctx, base);
	// 82A1EC34: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	pc = 0x82A1EC38; continue 'dispatch;
            }
            0x82A1EC38 => {
    //   block [0x82A1EC38..0x82A1EC70)
	// 82A1EC38: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A1EC3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1EC40: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A1EC44: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A1EC48: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1EC4C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1EC50: 4082FFE8  bne 0x82a1ec38
	if !ctx.cr[0].eq {
	pc = 0x82A1EC38; continue 'dispatch;
	}
	// 82A1EC54: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82A1EC58: 92C10058  stw r22, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[22].u32 ) };
	// 82A1EC5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1EC60: 4B87C559  bl 0x8229b1b8
	ctx.lr = 0x82A1EC64;
	sub_8229B1B8(ctx, base);
	// 82A1EC64: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1EC68: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82A1EC6C: 409AFEB4  bne cr6, 0x82a1eb20
	if !ctx.cr[6].eq {
	pc = 0x82A1EB20; continue 'dispatch;
	}
	pc = 0x82A1EC70; continue 'dispatch;
            }
            0x82A1EC70 => {
    //   block [0x82A1EC70..0x82A1EC90)
	// 82A1EC70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1EC74: 4B7F6165  bl 0x82214dd8
	ctx.lr = 0x82A1EC78;
	sub_82214DD8(ctx, base);
	// 82A1EC78: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A1EC7C: 4BC1BA0D  bl 0x8263a688
	ctx.lr = 0x82A1EC80;
	sub_8263A688(ctx, base);
	// 82A1EC80: 3861007C  addi r3, r1, 0x7c
	ctx.r[3].s64 = ctx.r[1].s64 + 124;
	// 82A1EC84: 4B7F6155  bl 0x82214dd8
	ctx.lr = 0x82A1EC88;
	sub_82214DD8(ctx, base);
	// 82A1EC88: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82A1EC8C: 48000038  b 0x82a1ecc4
	pc = 0x82A1ECC4; continue 'dispatch;
            }
            0x82A1EC90 => {
    //   block [0x82A1EC90..0x82A1ECC4)
	// 82A1EC90: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82A1EC94: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 82A1EC98: 4BFFF959  bl 0x82a1e5f0
	ctx.lr = 0x82A1EC9C;
	sub_82A1E5F0(ctx, base);
	// 82A1EC9C: 81530040  lwz r10, 0x40(r19)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(64 as u32) ) } as u64;
	// 82A1ECA0: 3973003C  addi r11, r19, 0x3c
	ctx.r[11].s64 = ctx.r[19].s64 + 60;
	// 82A1ECA4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A1ECA8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A1ECAC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82A1ECB0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1ECB4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82A1ECB8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A1ECBC: 4B902A8D  bl 0x82321748
	ctx.lr = 0x82A1ECC0;
	sub_82321748(ctx, base);
	// 82A1ECC0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	pc = 0x82A1ECC4; continue 'dispatch;
            }
            0x82A1ECC4 => {
    //   block [0x82A1ECC4..0x82A1ED00)
	// 82A1ECC4: 4B7F6115  bl 0x82214dd8
	ctx.lr = 0x82A1ECC8;
	sub_82214DD8(ctx, base);
	// 82A1ECC8: 81730034  lwz r11, 0x34(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(52 as u32) ) } as u64;
	// 82A1ECCC: 3BF30028  addi r31, r19, 0x28
	ctx.r[31].s64 = ctx.r[19].s64 + 40;
	// 82A1ECD0: 556A07BE  clrlwi r10, r11, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 82A1ECD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1ECD8: 409A0028  bne cr6, 0x82a1ed00
	if !ctx.cr[6].eq {
	pc = 0x82A1ED00; continue 'dispatch;
	}
	// 82A1ECDC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1ECE0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1ECE4: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 82A1ECE8: 5528F0BE  srwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A1ECEC: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A1ECF0: 41990010  bgt cr6, 0x82a1ed00
	if ctx.cr[6].gt {
	pc = 0x82A1ED00; continue 'dispatch;
	}
	// 82A1ECF4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A1ECF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1ECFC: 480000ED  bl 0x82a1ede8
	ctx.lr = 0x82A1ED00;
	sub_82A1EDE8(ctx, base);
	pc = 0x82A1ED00; continue 'dispatch;
            }
            0x82A1ED00 => {
    //   block [0x82A1ED00..0x82A1ED14)
	// 82A1ED00: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1ED04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1ED08: 409A000C  bne cr6, 0x82a1ed14
	if !ctx.cr[6].eq {
	pc = 0x82A1ED14; continue 'dispatch;
	}
	// 82A1ED0C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1ED10: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x82A1ED14; continue 'dispatch;
            }
            0x82A1ED14 => {
    //   block [0x82A1ED14..0x82A1ED3C)
	// 82A1ED14: 3BABFFFF  addi r29, r11, -1
	ctx.r[29].s64 = ctx.r[11].s64 + -1;
	// 82A1ED18: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1ED1C: 57BE003A  rlwinm r30, r29, 0, 0, 0x1d
	ctx.r[30].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1ED20: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A1ED24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1ED28: 409A0014  bne cr6, 0x82a1ed3c
	if !ctx.cr[6].eq {
	pc = 0x82A1ED3C; continue 'dispatch;
	}
	// 82A1ED2C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82A1ED30: 4B800529  bl 0x8221f258
	ctx.lr = 0x82A1ED34;
	sub_8221F258(ctx, base);
	// 82A1ED34: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1ED38: 7C7E592E  stwx r3, r30, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	pc = 0x82A1ED3C; continue 'dispatch;
            }
            0x82A1ED3C => {
    //   block [0x82A1ED3C..0x82A1ED58)
	// 82A1ED3C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1ED40: 57AA173A  rlwinm r10, r29, 2, 0x1c, 0x1d
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x3FFFFFFFu64;
	// 82A1ED44: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A1ED48: 7C6B5215  add. r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A1ED4C: 4182000C  beq 0x82a1ed58
	if ctx.cr[0].eq {
	pc = 0x82A1ED58; continue 'dispatch;
	}
	// 82A1ED50: 7E449378  mr r4, r18
	ctx.r[4].u64 = ctx.r[18].u64;
	// 82A1ED54: 4B7D14ED  bl 0x821f0240
	ctx.lr = 0x82A1ED58;
	sub_821F0240(ctx, base);
	pc = 0x82A1ED58; continue 'dispatch;
            }
            0x82A1ED58 => {
    //   block [0x82A1ED58..0x82A1ED80)
	// 82A1ED58: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1ED5C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82A1ED60: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82A1ED64: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A1ED68: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82A1ED6C: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82A1ED70: 9153004C  stw r10, 0x4c(r19)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[19].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 82A1ED74: 4B7F6065  bl 0x82214dd8
	ctx.lr = 0x82A1ED78;
	sub_82214DD8(ctx, base);
	// 82A1ED78: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 82A1ED7C: 4828A6B4  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1ED80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A1ED80 size=104
    let mut pc: u32 = 0x82A1ED80;
    'dispatch: loop {
        match pc {
            0x82A1ED80 => {
    //   block [0x82A1ED80..0x82A1ED9C)
	// 82A1ED80: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1ED84: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1ED88: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A1ED8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1ED90: 409A004C  bne cr6, 0x82a1eddc
	if !ctx.cr[6].eq {
	pc = 0x82A1EDDC; continue 'dispatch;
	}
	// 82A1ED94: 89450000  lbz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1ED98: 7D480774  extsb r8, r10
	ctx.r[8].s64 = ctx.r[10].s8 as i64;
	pc = 0x82A1ED9C; continue 'dispatch;
            }
            0x82A1ED9C => {
    //   block [0x82A1ED9C..0x82A1EDB4)
	// 82A1ED9C: 894B000C  lbz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1EDA0: 7D470774  extsb r7, r10
	ctx.r[7].s64 = ctx.r[10].s8 as i64;
	// 82A1EDA4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82A1EDA8: 7F074000  cmpw cr6, r7, r8
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82A1EDAC: 41980008  blt cr6, 0x82a1edb4
	if ctx.cr[6].lt {
	pc = 0x82A1EDB4; continue 'dispatch;
	}
	// 82A1EDB0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82A1EDB4; continue 'dispatch;
            }
            0x82A1EDB4 => {
    //   block [0x82A1EDB4..0x82A1EDC8)
	// 82A1EDB4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82A1EDB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1EDBC: 419A000C  beq cr6, 0x82a1edc8
	if ctx.cr[6].eq {
	pc = 0x82A1EDC8; continue 'dispatch;
	}
	// 82A1EDC0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1EDC4: 4800000C  b 0x82a1edd0
	pc = 0x82A1EDD0; continue 'dispatch;
            }
            0x82A1EDC8 => {
    //   block [0x82A1EDC8..0x82A1EDD0)
	// 82A1EDC8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82A1EDCC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A1EDD0; continue 'dispatch;
            }
            0x82A1EDD0 => {
    //   block [0x82A1EDD0..0x82A1EDDC)
	// 82A1EDD0: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82A1EDD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1EDD8: 419AFFC4  beq cr6, 0x82a1ed9c
	if ctx.cr[6].eq {
	pc = 0x82A1ED9C; continue 'dispatch;
	}
	pc = 0x82A1EDDC; continue 'dispatch;
            }
            0x82A1EDDC => {
    //   block [0x82A1EDDC..0x82A1EDE8)
	// 82A1EDDC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A1EDE0: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82A1EDE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1EDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1EDE8 size=616
    let mut pc: u32 = 0x82A1EDE8;
    'dispatch: loop {
        match pc {
            0x82A1EDE8 => {
    //   block [0x82A1EDE8..0x82A1EE68)
	// 82A1EDE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1EDEC: 4828A611  bl 0x82ca93fc
	ctx.lr = 0x82A1EDF0;
	sub_82CA93D0(ctx, base);
	// 82A1EDF0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1EDF4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A1EDF8: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 82A1EDFC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A1EE00: 617FFFFF  ori r31, r11, 0xffff
	ctx.r[31].u64 = ctx.r[11].u64 | 65535;
	// 82A1EE04: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82A1EE08: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1EE0C: 7D2AF850  subf r9, r10, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82A1EE10: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82A1EE14: 40980064  bge cr6, 0x82a1ee78
	if !ctx.cr[6].lt {
	pc = 0x82A1EE78; continue 'dispatch;
	}
	// 82A1EE18: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A1EE1C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1EE20: 388B2DA8  addi r4, r11, 0x2da8
	ctx.r[4].s64 = ctx.r[11].s64 + 11688;
	// 82A1EE24: 4B8D311D  bl 0x822f1f40
	ctx.lr = 0x82A1EE28;
	sub_822F1F40(ctx, base);
	// 82A1EE28: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A1EE2C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A1EE30: 4B8D2F81  bl 0x822f1db0
	ctx.lr = 0x82A1EE34;
	sub_822F1DB0(ctx, base);
	// 82A1EE34: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A1EE38: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A1EE3C: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 82A1EE40: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 82A1EE44: 4B8D2FDD  bl 0x822f1e20
	ctx.lr = 0x82A1EE48;
	sub_822F1E20(ctx, base);
	// 82A1EE48: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 82A1EE4C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82A1EE50: 4BC5C991  bl 0x8267b7e0
	ctx.lr = 0x82A1EE54;
	sub_8267B7E0(ctx, base);
	// 82A1EE54: 81210078  lwz r9, 0x78(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82A1EE58: 2B090010  cmplwi cr6, r9, 0x10
	ctx.cr[6].compare_u32(ctx.r[9].u32, 16 as u32, &mut ctx.xer);
	// 82A1EE5C: 4198000C  blt cr6, 0x82a1ee68
	if ctx.cr[6].lt {
	pc = 0x82A1EE68; continue 'dispatch;
	}
	// 82A1EE60: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1EE64: 4B7FCED5  bl 0x8221bd38
	ctx.lr = 0x82A1EE68;
	sub_8221BD38(ctx, base);
	pc = 0x82A1EE68; continue 'dispatch;
            }
            0x82A1EE68 => {
    //   block [0x82A1EE68..0x82A1EE78)
	// 82A1EE68: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 82A1EE6C: 93210074  stw r25, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[25].u32 ) };
	// 82A1EE70: 9B210064  stb r25, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u8 ) };
	// 82A1EE74: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	pc = 0x82A1EE78; continue 'dispatch;
            }
            0x82A1EE78 => {
    //   block [0x82A1EE78..0x82A1EE90)
	// 82A1EE78: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1EE7C: 554BF87E  srwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1EE80: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 82A1EE84: 4098000C  bge cr6, 0x82a1ee90
	if !ctx.cr[6].lt {
	pc = 0x82A1EE90; continue 'dispatch;
	}
	// 82A1EE88: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 82A1EE8C: 4800000C  b 0x82a1ee98
	pc = 0x82A1EE98; continue 'dispatch;
            }
            0x82A1EE90 => {
    //   block [0x82A1EE90..0x82A1EE98)
	// 82A1EE90: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82A1EE94: 40990014  ble cr6, 0x82a1eea8
	if !ctx.cr[6].gt {
	pc = 0x82A1EEA8; continue 'dispatch;
	}
	pc = 0x82A1EE98; continue 'dispatch;
            }
            0x82A1EE98 => {
    //   block [0x82A1EE98..0x82A1EEA8)
	// 82A1EE98: 7D2BF850  subf r9, r11, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 82A1EE9C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1EEA0: 41990008  bgt cr6, 0x82a1eea8
	if ctx.cr[6].gt {
	pc = 0x82A1EEA8; continue 'dispatch;
	}
	// 82A1EEA4: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	pc = 0x82A1EEA8; continue 'dispatch;
            }
            0x82A1EEA8 => {
    //   block [0x82A1EEA8..0x82A1EEC0)
	// 82A1EEA8: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1EEAC: 7FEAD215  add. r31, r10, r26
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A1EEB0: 557EF0BE  srwi r30, r11, 2
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82A1EEB4: 4082000C  bne 0x82a1eec0
	if !ctx.cr[0].eq {
	pc = 0x82A1EEC0; continue 'dispatch;
	}
	// 82A1EEB8: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 82A1EEBC: 4800003C  b 0x82a1eef8
	pc = 0x82A1EEF8; continue 'dispatch;
            }
            0x82A1EEC0 => {
    //   block [0x82A1EEC0..0x82A1EEF8)
	// 82A1EEC0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82A1EEC4: 0CDF0000  twi 6, r31, 0
	// 82A1EEC8: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 82A1EECC: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 82A1EED0: 40980028  bge cr6, 0x82a1eef8
	if !ctx.cr[6].lt {
	pc = 0x82A1EEF8; continue 'dispatch;
	}
	// 82A1EED4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A1EED8: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 82A1EEDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1EEE0: 394B1714  addi r10, r11, 0x1714
	ctx.r[10].s64 = ctx.r[11].s64 + 5908;
	// 82A1EEE4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82A1EEE8: 4B8D2F39  bl 0x822f1e20
	ctx.lr = 0x82A1EEEC;
	sub_822F1E20(ctx, base);
	// 82A1EEEC: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82A1EEF0: 39091708  addi r8, r9, 0x1708
	ctx.r[8].s64 = ctx.r[9].s64 + 5896;
	// 82A1EEF4: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	pc = 0x82A1EEF8; continue 'dispatch;
            }
            0x82A1EEF8 => {
    //   block [0x82A1EEF8..0x82A1EF3C)
	// 82A1EEF8: 57E3103A  slwi r3, r31, 2
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A1EEFC: 4B80035D  bl 0x8221f258
	ctx.lr = 0x82A1EF00;
	sub_8221F258(ctx, base);
	// 82A1EF00: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1EF04: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1EF08: 57DF103A  slwi r31, r30, 2
	ctx.r[31].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82A1EF0C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A1EF10: 7CBF5A14  add r5, r31, r11
	ctx.r[5].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A1EF14: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82A1EF18: 7C7FDA14  add r3, r31, r27
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[27].u64;
	// 82A1EF1C: 7D454850  subf r10, r5, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[5].s64;
	// 82A1EF20: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A1EF24: 7D0B1671  srawi. r11, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1EF28: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A1EF2C: 7F861A14  add r28, r6, r3
	ctx.r[28].u64 = ctx.r[6].u64 + ctx.r[3].u64;
	// 82A1EF30: 4182000C  beq 0x82a1ef3c
	if ctx.cr[0].eq {
	pc = 0x82A1EF3C; continue 'dispatch;
	}
	// 82A1EF34: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A1EF38: 4828B0F1  bl 0x82caa028
	ctx.lr = 0x82A1EF3C;
	sub_82CAA028(ctx, base);
	pc = 0x82A1EF3C; continue 'dispatch;
            }
            0x82A1EF3C => {
    //   block [0x82A1EF3C..0x82A1EF6C)
	// 82A1EF3C: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1EF40: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82A1EF44: 41990074  bgt cr6, 0x82a1efb8
	if ctx.cr[6].gt {
	pc = 0x82A1EFB8; continue 'dispatch;
	}
	// 82A1EF48: 7D65F850  subf r11, r5, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 82A1EF4C: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82A1EF50: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1EF54: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A1EF58: 7FE6E214  add r31, r6, r28
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[28].u64;
	// 82A1EF5C: 41820010  beq 0x82a1ef6c
	if ctx.cr[0].eq {
	pc = 0x82A1EF6C; continue 'dispatch;
	}
	// 82A1EF60: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A1EF64: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1EF68: 4828B0C1  bl 0x82caa028
	ctx.lr = 0x82A1EF6C;
	sub_82CAA028(ctx, base);
	pc = 0x82A1EF6C; continue 'dispatch;
            }
            0x82A1EF6C => {
    //   block [0x82A1EF6C..0x82A1EF88)
	// 82A1EF6C: 7D5ED051  subf. r10, r30, r26
	ctx.r[10].s64 = ctx.r[26].s64 - ctx.r[30].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A1EF70: 41820024  beq 0x82a1ef94
	if ctx.cr[0].eq {
	pc = 0x82A1EF94; continue 'dispatch;
	}
	// 82A1EF74: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82A1EF78: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 82A1EF7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1EF80: 419A0014  beq cr6, 0x82a1ef94
	if ctx.cr[6].eq {
	pc = 0x82A1EF94; continue 'dispatch;
	}
	// 82A1EF84: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82A1EF88; continue 'dispatch;
            }
            0x82A1EF88 => {
    //   block [0x82A1EF88..0x82A1EF94)
	// 82A1EF88: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A1EF8C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A1EF90: 4200FFF8  bdnz 0x82a1ef88
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A1EF88; continue 'dispatch;
	}
	pc = 0x82A1EF94; continue 'dispatch;
            }
            0x82A1EF94 => {
    //   block [0x82A1EF94..0x82A1EFA8)
	// 82A1EF94: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A1EF98: 419A0090  beq cr6, 0x82a1f028
	if ctx.cr[6].eq {
	pc = 0x82A1F028; continue 'dispatch;
	}
	// 82A1EF9C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82A1EFA0: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 82A1EFA4: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	pc = 0x82A1EFA8; continue 'dispatch;
            }
            0x82A1EFA8 => {
    //   block [0x82A1EFA8..0x82A1EFB8)
	// 82A1EFA8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1EFAC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A1EFB0: 4200FFF8  bdnz 0x82a1efa8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A1EFA8; continue 'dispatch;
	}
	// 82A1EFB4: 48000074  b 0x82a1f028
	pc = 0x82A1F028; continue 'dispatch;
            }
            0x82A1EFB8 => {
    //   block [0x82A1EFB8..0x82A1EFDC)
	// 82A1EFB8: 575E103A  slwi r30, r26, 2
	ctx.r[30].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82A1EFBC: 7D65F050  subf r11, r5, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[5].s64;
	// 82A1EFC0: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82A1EFC4: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1EFC8: 41820014  beq 0x82a1efdc
	if ctx.cr[0].eq {
	pc = 0x82A1EFDC; continue 'dispatch;
	}
	// 82A1EFCC: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82A1EFD0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1EFD4: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 82A1EFD8: 4828B051  bl 0x82caa028
	ctx.lr = 0x82A1EFDC;
	sub_82CAA028(ctx, base);
	pc = 0x82A1EFDC; continue 'dispatch;
            }
            0x82A1EFDC => {
    //   block [0x82A1EFDC..0x82A1F008)
	// 82A1EFDC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1EFE0: 7CBE5A14  add r5, r30, r11
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82A1EFE4: 7D45F850  subf r10, r5, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[5].s64;
	// 82A1EFE8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A1EFEC: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1EFF0: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82A1EFF4: 7FE6DA14  add r31, r6, r27
	ctx.r[31].u64 = ctx.r[6].u64 + ctx.r[27].u64;
	// 82A1EFF8: 41820010  beq 0x82a1f008
	if ctx.cr[0].eq {
	pc = 0x82A1F008; continue 'dispatch;
	}
	// 82A1EFFC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82A1F000: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A1F004: 4828B025  bl 0x82caa028
	ctx.lr = 0x82A1F008;
	sub_82CAA028(ctx, base);
	pc = 0x82A1F008; continue 'dispatch;
            }
            0x82A1F008 => {
    //   block [0x82A1F008..0x82A1F01C)
	// 82A1F008: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82A1F00C: 419A001C  beq cr6, 0x82a1f028
	if ctx.cr[6].eq {
	pc = 0x82A1F028; continue 'dispatch;
	}
	// 82A1F010: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82A1F014: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 82A1F018: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	pc = 0x82A1F01C; continue 'dispatch;
            }
            0x82A1F01C => {
    //   block [0x82A1F01C..0x82A1F028)
	// 82A1F01C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1F020: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82A1F024: 4200FFF8  bdnz 0x82a1f01c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82A1F01C; continue 'dispatch;
	}
	pc = 0x82A1F028; continue 'dispatch;
            }
            0x82A1F028 => {
    //   block [0x82A1F028..0x82A1F038)
	// 82A1F028: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1F02C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1F030: 419A0008  beq cr6, 0x82a1f038
	if ctx.cr[6].eq {
	pc = 0x82A1F038; continue 'dispatch;
	}
	// 82A1F034: 4B7FCD05  bl 0x8221bd38
	ctx.lr = 0x82A1F038;
	sub_8221BD38(ctx, base);
	pc = 0x82A1F038; continue 'dispatch;
            }
            0x82A1F038 => {
    //   block [0x82A1F038..0x82A1F050)
	// 82A1F038: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1F03C: 937D0004  stw r27, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82A1F040: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 82A1F044: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A1F048: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82A1F04C: 4828A400  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1F050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1F050 size=264
    let mut pc: u32 = 0x82A1F050;
    'dispatch: loop {
        match pc {
            0x82A1F050 => {
    //   block [0x82A1F050..0x82A1F078)
	// 82A1F050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1F054: 4828A3B5  bl 0x82ca9408
	ctx.lr = 0x82A1F058;
	sub_82CA93D0(ctx, base);
	// 82A1F058: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1F05C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1F060: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82A1F064: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1F068: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F06C: 419A0094  beq cr6, 0x82a1f100
	if ctx.cr[6].eq {
	pc = 0x82A1F100; continue 'dispatch;
	}
	// 82A1F070: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82A1F074: 3BAA7088  addi r29, r10, 0x7088
	ctx.r[29].s64 = ctx.r[10].s64 + 28808;
	pc = 0x82A1F078; continue 'dispatch;
            }
            0x82A1F078 => {
    //   block [0x82A1F078..0x82A1F0A0)
	// 82A1F078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F07C: 419A0078  beq cr6, 0x82a1f0f4
	if ctx.cr[6].eq {
	pc = 0x82A1F0F4; continue 'dispatch;
	}
	// 82A1F080: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1F084: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1F088: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A1F08C: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 82A1F090: 554BF0BE  srwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1F094: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A1F098: 41990008  bgt cr6, 0x82a1f0a0
	if ctx.cr[6].gt {
	pc = 0x82A1F0A0; continue 'dispatch;
	}
	// 82A1F09C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	pc = 0x82A1F0A0; continue 'dispatch;
            }
            0x82A1F0A0 => {
    //   block [0x82A1F0A0..0x82A1F0C0)
	// 82A1F0A0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1F0A4: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A1F0A8: 554A173A  rlwinm r10, r10, 2, 0x1c, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x3FFFFFFFu64;
	// 82A1F0AC: 7D68482E  lwzx r11, r8, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82A1F0B0: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82A1F0B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1F0B8: 4B7A76B1  bl 0x821c6768
	ctx.lr = 0x82A1F0BC;
	sub_821C6768(ctx, base);
	// 82A1F0BC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	pc = 0x82A1F0C0; continue 'dispatch;
            }
            0x82A1F0C0 => {
    //   block [0x82A1F0C0..0x82A1F0F4)
	// 82A1F0C0: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 82A1F0C4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F0C8: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 82A1F0CC: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 82A1F0D0: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1F0D4: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F0D8: 4082FFE8  bne 0x82a1f0c0
	if !ctx.cr[0].eq {
	pc = 0x82A1F0C0; continue 'dispatch;
	}
	// 82A1F0DC: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82A1F0E0: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1F0E4: 3564FFFF  addic. r11, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1F0E8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A1F0EC: 40820008  bne 0x82a1f0f4
	if !ctx.cr[0].eq {
	pc = 0x82A1F0F4; continue 'dispatch;
	}
	// 82A1F0F0: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	pc = 0x82A1F0F4; continue 'dispatch;
            }
            0x82A1F0F4 => {
    //   block [0x82A1F0F4..0x82A1F100)
	// 82A1F0F4: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1F0F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1F0FC: 409AFF7C  bne cr6, 0x82a1f078
	if !ctx.cr[6].eq {
	pc = 0x82A1F078; continue 'dispatch;
	}
	pc = 0x82A1F100; continue 'dispatch;
            }
            0x82A1F100 => {
    //   block [0x82A1F100..0x82A1F110)
	// 82A1F100: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1F104: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A1F108: 419A0030  beq cr6, 0x82a1f138
	if ctx.cr[6].eq {
	pc = 0x82A1F138; continue 'dispatch;
	}
	// 82A1F10C: 57BE103A  slwi r30, r29, 2
	ctx.r[30].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	pc = 0x82A1F110; continue 'dispatch;
            }
            0x82A1F110 => {
    //   block [0x82A1F110..0x82A1F130)
	// 82A1F110: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1F114: 3BDEFFFC  addi r30, r30, -4
	ctx.r[30].s64 = ctx.r[30].s64 + -4;
	// 82A1F118: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 82A1F11C: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82A1F120: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A1F124: 419A000C  beq cr6, 0x82a1f130
	if ctx.cr[6].eq {
	pc = 0x82A1F130; continue 'dispatch;
	}
	// 82A1F128: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A1F12C: 4B7FCC0D  bl 0x8221bd38
	ctx.lr = 0x82A1F130;
	sub_8221BD38(ctx, base);
	pc = 0x82A1F130; continue 'dispatch;
            }
            0x82A1F130 => {
    //   block [0x82A1F130..0x82A1F138)
	// 82A1F130: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A1F134: 409AFFDC  bne cr6, 0x82a1f110
	if !ctx.cr[6].eq {
	pc = 0x82A1F110; continue 'dispatch;
	}
	pc = 0x82A1F138; continue 'dispatch;
            }
            0x82A1F138 => {
    //   block [0x82A1F138..0x82A1F148)
	// 82A1F138: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1F13C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1F140: 419A0008  beq cr6, 0x82a1f148
	if ctx.cr[6].eq {
	pc = 0x82A1F148; continue 'dispatch;
	}
	// 82A1F144: 4B7FCBF5  bl 0x8221bd38
	ctx.lr = 0x82A1F148;
	sub_8221BD38(ctx, base);
	pc = 0x82A1F148; continue 'dispatch;
            }
            0x82A1F148 => {
    //   block [0x82A1F148..0x82A1F158)
	// 82A1F148: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82A1F14C: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82A1F150: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1F154: 4828A304  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1F158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1F158 size=368
    let mut pc: u32 = 0x82A1F158;
    'dispatch: loop {
        match pc {
            0x82A1F158 => {
    //   block [0x82A1F158..0x82A1F194)
	// 82A1F158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1F15C: 4828A2A5  bl 0x82ca9400
	ctx.lr = 0x82A1F160;
	sub_82CA93D0(ctx, base);
	// 82A1F160: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1F164: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A1F168: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82A1F16C: FB8100C0  std r28, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u64 ) };
	// 82A1F170: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82A1F174: FB4100C8  std r26, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[26].u64 ) };
	// 82A1F178: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82A1F17C: 83A100C4  lwz r29, 0xc4(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A1F180: 836100CC  lwz r27, 0xcc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A1F184: 7D7DD850  subf r11, r29, r27
	ctx.r[11].s64 = ctx.r[27].s64 - ctx.r[29].s64;
	// 82A1F188: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82A1F18C: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82A1F190: 409900A0  ble cr6, 0x82a1f230
	if !ctx.cr[6].gt {
	pc = 0x82A1F230; continue 'dispatch;
	}
	pc = 0x82A1F194; continue 'dispatch;
            }
            0x82A1F194 => {
    //   block [0x82A1F194..0x82A1F208)
	// 82A1F194: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A1F198: 409900B8  ble cr6, 0x82a1f250
	if !ctx.cr[6].gt {
	pc = 0x82A1F250; continue 'dispatch;
	}
	// 82A1F19C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A1F1A0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82A1F1A4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A1F1A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1F1AC: 4800011D  bl 0x82a1f2c8
	ctx.lr = 0x82A1F1B0;
	sub_82A1F2C8(ctx, base);
	// 82A1F1B0: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 82A1F1B4: 8121006C  lwz r9, 0x6c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82A1F1B8: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82A1F1BC: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1F1C0: 7CE9D850  subf r7, r9, r27
	ctx.r[7].s64 = ctx.r[27].s64 - ctx.r[9].s64;
	// 82A1F1C4: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A1F1C8: 7CDD4050  subf r6, r29, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[29].s64;
	// 82A1F1CC: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82A1F1D0: 54E5003A  rlwinm r5, r7, 0, 0, 0x1d
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1F1D4: 54C4003A  rlwinm r4, r6, 0, 0, 0x1d
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 82A1F1D8: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82A1F1DC: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 82A1F1E0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82A1F1E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A1F1E8: 40980020  bge cr6, 0x82a1f208
	if !ctx.cr[6].lt {
	pc = 0x82A1F208; continue 'dispatch;
	}
	// 82A1F1EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1F1F0: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A1F1F4: 4BFFFF65  bl 0x82a1f158
	ctx.lr = 0x82A1F1F8;
	sub_82A1F158(ctx, base);
	// 82A1F1F8: EB810068  ld r28, 0x68(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A1F1FC: FB8100C0  std r28, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u64 ) };
	// 82A1F200: 83A100C4  lwz r29, 0xc4(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A1F204: 4800001C  b 0x82a1f220
	pc = 0x82A1F220; continue 'dispatch;
            }
            0x82A1F208 => {
    //   block [0x82A1F208..0x82A1F220)
	// 82A1F208: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A1F20C: E8610068  ld r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82A1F210: 4BFFFF49  bl 0x82a1f158
	ctx.lr = 0x82A1F214;
	sub_82A1F158(ctx, base);
	// 82A1F214: EB410060  ld r26, 0x60(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82A1F218: FB4100C8  std r26, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[26].u64 ) };
	// 82A1F21C: 836100CC  lwz r27, 0xcc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	pc = 0x82A1F220; continue 'dispatch;
            }
            0x82A1F220 => {
    //   block [0x82A1F220..0x82A1F230)
	// 82A1F220: 7D7DD850  subf r11, r29, r27
	ctx.r[11].s64 = ctx.r[27].s64 - ctx.r[29].s64;
	// 82A1F224: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82A1F228: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82A1F22C: 4199FF68  bgt cr6, 0x82a1f194
	if ctx.cr[6].gt {
	pc = 0x82A1F194; continue 'dispatch;
	}
	pc = 0x82A1F230; continue 'dispatch;
            }
            0x82A1F230 => {
    //   block [0x82A1F230..0x82A1F248)
	// 82A1F230: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A1F234: 40990014  ble cr6, 0x82a1f248
	if !ctx.cr[6].gt {
	pc = 0x82A1F248; continue 'dispatch;
	}
	// 82A1F238: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A1F23C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A1F240: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1F244: 4800056D  bl 0x82a1f7b0
	ctx.lr = 0x82A1F248;
	sub_82A1F7B0(ctx, base);
	pc = 0x82A1F248; continue 'dispatch;
            }
            0x82A1F248 => {
    //   block [0x82A1F248..0x82A1F250)
	// 82A1F248: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A1F24C: 4828A204  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A1F250 => {
    //   block [0x82A1F250..0x82A1F27C)
	// 82A1F250: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 82A1F254: 4099FFDC  ble cr6, 0x82a1f230
	if !ctx.cr[6].gt {
	pc = 0x82A1F230; continue 'dispatch;
	}
	// 82A1F258: 7D7DD850  subf r11, r29, r27
	ctx.r[11].s64 = ctx.r[27].s64 - ctx.r[29].s64;
	// 82A1F25C: 7D7B1670  srawi r27, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82A1F260: 2F1B0001  cmpwi cr6, r27, 1
	ctx.cr[6].compare_i32(ctx.r[27].s32, 1, &mut ctx.xer);
	// 82A1F264: 4099004C  ble cr6, 0x82a1f2b0
	if !ctx.cr[6].gt {
	pc = 0x82A1F2B0; continue 'dispatch;
	}
	// 82A1F268: 7F6B0E70  srawi r11, r27, 1
	ctx.xer.ca = (ctx.r[27].s32 < 0) && ((ctx.r[27].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[27].s32 >> 1) as i64;
	// 82A1F26C: 7FEB0195  addze. r31, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[31].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A1F270: 40810040  ble 0x82a1f2b0
	if !ctx.cr[0].gt {
	pc = 0x82A1F2B0; continue 'dispatch;
	}
	// 82A1F274: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1F278: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	pc = 0x82A1F27C; continue 'dispatch;
            }
            0x82A1F27C => {
    //   block [0x82A1F27C..0x82A1F2B0)
	// 82A1F27C: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 82A1F280: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1F284: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1F288: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 82A1F28C: 4B7D0FB5  bl 0x821f0240
	ctx.lr = 0x82A1F290;
	sub_821F0240(ctx, base);
	// 82A1F290: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A1F294: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82A1F298: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82A1F29C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1F2A0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1F2A4: 480008CD  bl 0x82a1fb70
	ctx.lr = 0x82A1F2A8;
	sub_82A1FB70(ctx, base);
	// 82A1F2A8: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A1F2AC: 4199FFD0  bgt cr6, 0x82a1f27c
	if ctx.cr[6].gt {
	pc = 0x82A1F27C; continue 'dispatch;
	}
	pc = 0x82A1F2B0; continue 'dispatch;
            }
            0x82A1F2B0 => {
    //   block [0x82A1F2B0..0x82A1F2C8)
	// 82A1F2B0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82A1F2B4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A1F2B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1F2BC: 4800073D  bl 0x82a1f9f8
	ctx.lr = 0x82A1F2C0;
	sub_82A1F9F8(ctx, base);
	// 82A1F2C0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A1F2C4: 4828A18C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1F2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1F2C8 size=1252
    let mut pc: u32 = 0x82A1F2C8;
    'dispatch: loop {
        match pc {
            0x82A1F2C8 => {
    //   block [0x82A1F2C8..0x82A1F350)
	// 82A1F2C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1F2CC: 4828A11D  bl 0x82ca93e8
	ctx.lr = 0x82A1F2D0;
	sub_82CA93D0(ctx, base);
	// 82A1F2D0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1F2D4: F8810118  std r4, 0x118(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[4].u64 ) };
	// 82A1F2D8: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 82A1F2DC: F8A10120  std r5, 0x120(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[5].u64 ) };
	// 82A1F2E0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82A1F2E4: 82A10124  lwz r21, 0x124(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	// 82A1F2E8: 3975FFFC  addi r11, r21, -4
	ctx.r[11].s64 = ctx.r[21].s64 + -4;
	// 82A1F2EC: F8A10080  std r5, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 82A1F2F0: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82A1F2F4: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82A1F2F8: E8A10080  ld r5, 0x80(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82A1F2FC: 82C1011C  lwz r22, 0x11c(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 82A1F300: 7D56A850  subf r10, r22, r21
	ctx.r[10].s64 = ctx.r[21].s64 - ctx.r[22].s64;
	// 82A1F304: 7D491670  srawi r9, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 82A1F308: F8810078  std r4, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[4].u64 ) };
	// 82A1F30C: 7D280E70  srawi r8, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 82A1F310: 7CE80194  addze r7, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[7].s64 = tmp.s64;
	// 82A1F314: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1F318: 7FEBB214  add r31, r11, r22
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[22].u64;
	// 82A1F31C: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 82A1F320: EBC10078  ld r30, 0x78(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82A1F324: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1F328: 480005B9  bl 0x82a1f8e0
	ctx.lr = 0x82A1F32C;
	sub_82A1F8E0(ctx, base);
	// 82A1F32C: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 82A1F330: FBC10080  std r30, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u64 ) };
	// 82A1F334: 7F16F840  cmplw cr6, r22, r31
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A1F338: 93A10084  stw r29, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	// 82A1F33C: E8C10080  ld r6, 0x80(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82A1F340: FBC10070  std r30, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u64 ) };
	// 82A1F344: 83E10074  lwz r31, 0x74(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82A1F348: F8C10078  std r6, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[6].u64 ) };
	// 82A1F34C: 40980050  bge cr6, 0x82a1f39c
	if !ctx.cr[6].lt {
	pc = 0x82A1F39C; continue 'dispatch;
	}
	pc = 0x82A1F350; continue 'dispatch;
            }
            0x82A1F350 => {
    //   block [0x82A1F350..0x82A1F39C)
	// 82A1F350: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 82A1F354: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1F358: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1F35C: 7EE903A6  mtctr r23
	ctx.ctr.u64 = ctx.r[23].u64;
	// 82A1F360: 4E800421  bctrl
	ctx.lr = 0x82A1F364;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1F364: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1F368: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F36C: 409A0030  bne cr6, 0x82a1f39c
	if !ctx.cr[6].eq {
	pc = 0x82A1F39C; continue 'dispatch;
	}
	// 82A1F370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F374: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1F378: 7EE903A6  mtctr r23
	ctx.ctr.u64 = ctx.r[23].u64;
	// 82A1F37C: 4E800421  bctrl
	ctx.lr = 0x82A1F380;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1F380: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1F384: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F388: 409A0014  bne cr6, 0x82a1f39c
	if !ctx.cr[6].eq {
	pc = 0x82A1F39C; continue 'dispatch;
	}
	// 82A1F38C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82A1F390: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82A1F394: 7F16F840  cmplw cr6, r22, r31
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A1F398: 4198FFB8  blt cr6, 0x82a1f350
	if ctx.cr[6].lt {
	pc = 0x82A1F350; continue 'dispatch;
	}
            }
            0x82A1F39C => {
    //   block [0x82A1F39C..0x82A1F3A8)
	// 82A1F39C: 8361007C  lwz r27, 0x7c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82A1F3A0: 7F1DA840  cmplw cr6, r29, r21
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82A1F3A4: 4098004C  bge cr6, 0x82a1f3f0
	if !ctx.cr[6].lt {
	pc = 0x82A1F3F0; continue 'dispatch;
	}
	pc = 0x82A1F3A8; continue 'dispatch;
            }
            0x82A1F3A8 => {
    //   block [0x82A1F3A8..0x82A1F3F0)
	// 82A1F3A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1F3AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A1F3B0: 7EE903A6  mtctr r23
	ctx.ctr.u64 = ctx.r[23].u64;
	// 82A1F3B4: 4E800421  bctrl
	ctx.lr = 0x82A1F3B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1F3B8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1F3BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F3C0: 409A0030  bne cr6, 0x82a1f3f0
	if !ctx.cr[6].eq {
	pc = 0x82A1F3F0; continue 'dispatch;
	}
	// 82A1F3C4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A1F3C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F3CC: 7EE903A6  mtctr r23
	ctx.ctr.u64 = ctx.r[23].u64;
	// 82A1F3D0: 4E800421  bctrl
	ctx.lr = 0x82A1F3D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1F3D4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1F3D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F3DC: 409A0014  bne cr6, 0x82a1f3f0
	if !ctx.cr[6].eq {
	pc = 0x82A1F3F0; continue 'dispatch;
	}
	// 82A1F3E0: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82A1F3E4: 9361007C  stw r27, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	// 82A1F3E8: 7F1BA840  cmplw cr6, r27, r21
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82A1F3EC: 4198FFBC  blt cr6, 0x82a1f3a8
	if ctx.cr[6].lt {
	pc = 0x82A1F3A8; continue 'dispatch;
	}
            }
            0x82A1F3F0 => {
    //   block [0x82A1F3F0..0x82A1F414)
	// 82A1F3F0: E9610078  ld r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82A1F3F4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A1F3F8: E9410070  ld r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A1F3FC: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 82A1F400: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A1F404: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 82A1F408: 83A10084  lwz r29, 0x84(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82A1F40C: 3B4B7088  addi r26, r11, 0x7088
	ctx.r[26].s64 = ctx.r[11].s64 + 28808;
	// 82A1F410: 8301006C  lwz r24, 0x6c(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	pc = 0x82A1F414; continue 'dispatch;
            }
            0x82A1F414 => {
    //   block [0x82A1F414..0x82A1F41C)
	// 82A1F414: 7F1DA840  cmplw cr6, r29, r21
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82A1F418: 409800B0  bge cr6, 0x82a1f4c8
	if !ctx.cr[6].lt {
	pc = 0x82A1F4C8; continue 'dispatch;
	}
	pc = 0x82A1F41C; continue 'dispatch;
            }
            0x82A1F41C => {
    //   block [0x82A1F41C..0x82A1F498)
	// 82A1F41C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1F420: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F424: 7EE903A6  mtctr r23
	ctx.ctr.u64 = ctx.r[23].u64;
	// 82A1F428: 4E800421  bctrl
	ctx.lr = 0x82A1F42C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1F42C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1F430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F434: 409A0084  bne cr6, 0x82a1f4b8
	if !ctx.cr[6].eq {
	pc = 0x82A1F4B8; continue 'dispatch;
	}
	// 82A1F438: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1F43C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1F440: 7EE903A6  mtctr r23
	ctx.ctr.u64 = ctx.r[23].u64;
	// 82A1F444: 4E800421  bctrl
	ctx.lr = 0x82A1F448;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1F448: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1F44C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F450: 409A0078  bne cr6, 0x82a1f4c8
	if !ctx.cr[6].eq {
	pc = 0x82A1F4C8; continue 'dispatch;
	}
	// 82A1F454: E9610078  ld r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82A1F458: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82A1F45C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1F460: 9361007C  stw r27, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	// 82A1F464: F9610088  std r11, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u64 ) };
	// 82A1F468: 83C1008C  lwz r30, 0x8c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A1F46C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1F470: 4B7D0DD1  bl 0x821f0240
	ctx.lr = 0x82A1F474;
	sub_821F0240(ctx, base);
	// 82A1F474: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1F478: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1F47C: 4B845D25  bl 0x822651a0
	ctx.lr = 0x82A1F480;
	sub_822651A0(ctx, base);
	// 82A1F480: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A1F484: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1F488: 4B845D19  bl 0x822651a0
	ctx.lr = 0x82A1F48C;
	sub_822651A0(ctx, base);
	// 82A1F48C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1F490: 4B7A72D9  bl 0x821c6768
	ctx.lr = 0x82A1F494;
	sub_821C6768(ctx, base);
	// 82A1F494: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
            }
            0x82A1F498 => {
    //   block [0x82A1F498..0x82A1F4B8)
	// 82A1F498: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1F49C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F4A0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1F4A4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A1F4A8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1F4AC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F4B0: 4082FFE8  bne 0x82a1f498
	if !ctx.cr[0].eq {
	pc = 0x82A1F498; continue 'dispatch;
	}
	// 82A1F4B4: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	pc = 0x82A1F4B8; continue 'dispatch;
            }
            0x82A1F4B8 => {
    //   block [0x82A1F4B8..0x82A1F4C8)
	// 82A1F4B8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82A1F4BC: 93A10084  stw r29, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	// 82A1F4C0: 7F1DA840  cmplw cr6, r29, r21
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82A1F4C4: 4198FF58  blt cr6, 0x82a1f41c
	if ctx.cr[6].lt {
	pc = 0x82A1F41C; continue 'dispatch;
	}
	pc = 0x82A1F4C8; continue 'dispatch;
            }
            0x82A1F4C8 => {
    //   block [0x82A1F4C8..0x82A1F4D0)
	// 82A1F4C8: 7F18B040  cmplw cr6, r24, r22
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[22].u32, &mut ctx.xer);
	// 82A1F4CC: 409900AC  ble cr6, 0x82a1f578
	if !ctx.cr[6].gt {
	pc = 0x82A1F578; continue 'dispatch;
	}
	pc = 0x82A1F4D0; continue 'dispatch;
            }
            0x82A1F4D0 => {
    //   block [0x82A1F4D0..0x82A1F548)
	// 82A1F4D0: 3BD8FFFC  addi r30, r24, -4
	ctx.r[30].s64 = ctx.r[24].s64 + -4;
	// 82A1F4D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1F4D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1F4DC: 7EE903A6  mtctr r23
	ctx.ctr.u64 = ctx.r[23].u64;
	// 82A1F4E0: 4E800421  bctrl
	ctx.lr = 0x82A1F4E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1F4E4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1F4E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F4EC: 409A007C  bne cr6, 0x82a1f568
	if !ctx.cr[6].eq {
	pc = 0x82A1F568; continue 'dispatch;
	}
	// 82A1F4F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F4F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1F4F8: 7EE903A6  mtctr r23
	ctx.ctr.u64 = ctx.r[23].u64;
	// 82A1F4FC: 4E800421  bctrl
	ctx.lr = 0x82A1F500;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1F500: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1F504: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F508: 409A006C  bne cr6, 0x82a1f574
	if !ctx.cr[6].eq {
	pc = 0x82A1F574; continue 'dispatch;
	}
	// 82A1F50C: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 82A1F510: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1F514: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1F518: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82A1F51C: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82A1F520: 4B7D0D21  bl 0x821f0240
	ctx.lr = 0x82A1F524;
	sub_821F0240(ctx, base);
	// 82A1F524: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A1F528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F52C: 4B845C75  bl 0x822651a0
	ctx.lr = 0x82A1F530;
	sub_822651A0(ctx, base);
	// 82A1F530: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A1F534: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1F538: 4B845C69  bl 0x822651a0
	ctx.lr = 0x82A1F53C;
	sub_822651A0(ctx, base);
	// 82A1F53C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1F540: 4B7A7229  bl 0x821c6768
	ctx.lr = 0x82A1F544;
	sub_821C6768(ctx, base);
	// 82A1F544: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
            }
            0x82A1F548 => {
    //   block [0x82A1F548..0x82A1F568)
	// 82A1F548: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A1F54C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F550: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A1F554: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A1F558: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1F55C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F560: 4082FFE8  bne 0x82a1f548
	if !ctx.cr[0].eq {
	pc = 0x82A1F548; continue 'dispatch;
	}
	// 82A1F564: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	pc = 0x82A1F568; continue 'dispatch;
            }
            0x82A1F568 => {
    //   block [0x82A1F568..0x82A1F574)
	// 82A1F568: 7FD8F378  mr r24, r30
	ctx.r[24].u64 = ctx.r[30].u64;
	// 82A1F56C: 7F16C040  cmplw cr6, r22, r24
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A1F570: 4198FF60  blt cr6, 0x82a1f4d0
	if ctx.cr[6].lt {
	pc = 0x82A1F4D0; continue 'dispatch;
	}
	pc = 0x82A1F574; continue 'dispatch;
            }
            0x82A1F574 => {
    //   block [0x82A1F574..0x82A1F578)
	// 82A1F574: 7F18B040  cmplw cr6, r24, r22
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[22].u32, &mut ctx.xer);
	pc = 0x82A1F578; continue 'dispatch;
            }
            0x82A1F578 => {
    //   block [0x82A1F578..0x82A1F5BC)
	// 82A1F578: 409A00E8  bne cr6, 0x82a1f660
	if !ctx.cr[6].eq {
	pc = 0x82A1F660; continue 'dispatch;
	}
	// 82A1F57C: 7F1DA840  cmplw cr6, r29, r21
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82A1F580: 419A0210  beq cr6, 0x82a1f790
	if ctx.cr[6].eq {
	pc = 0x82A1F790; continue 'dispatch;
	}
	// 82A1F584: 7F1BE840  cmplw cr6, r27, r29
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A1F588: 419A0054  beq cr6, 0x82a1f5dc
	if ctx.cr[6].eq {
	pc = 0x82A1F5DC; continue 'dispatch;
	}
	// 82A1F58C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1F590: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1F594: 4B7D0CAD  bl 0x821f0240
	ctx.lr = 0x82A1F598;
	sub_821F0240(ctx, base);
	// 82A1F598: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A1F59C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F5A0: 4B845C01  bl 0x822651a0
	ctx.lr = 0x82A1F5A4;
	sub_822651A0(ctx, base);
	// 82A1F5A4: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A1F5A8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A1F5AC: 4B845BF5  bl 0x822651a0
	ctx.lr = 0x82A1F5B0;
	sub_822651A0(ctx, base);
	// 82A1F5B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A1F5B4: 4B7A71B5  bl 0x821c6768
	ctx.lr = 0x82A1F5B8;
	sub_821C6768(ctx, base);
	// 82A1F5B8: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x82A1F5BC; continue 'dispatch;
            }
            0x82A1F5BC => {
    //   block [0x82A1F5BC..0x82A1F5DC)
	// 82A1F5BC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A1F5C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F5C4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A1F5C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A1F5CC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1F5D0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F5D4: 4082FFE8  bne 0x82a1f5bc
	if !ctx.cr[0].eq {
	pc = 0x82A1F5BC; continue 'dispatch;
	}
	// 82A1F5D8: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	pc = 0x82A1F5DC; continue 'dispatch;
            }
            0x82A1F5DC => {
    //   block [0x82A1F5DC..0x82A1F63C)
	// 82A1F5DC: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A1F5E0: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82A1F5E4: E9410080  ld r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82A1F5E8: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82A1F5EC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82A1F5F0: 9361007C  stw r27, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	// 82A1F5F4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A1F5F8: 93A10084  stw r29, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	// 82A1F5FC: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82A1F600: F9610088  std r11, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u64 ) };
	// 82A1F604: 83C1008C  lwz r30, 0x8c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 82A1F608: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1F60C: F9410090  std r10, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u64 ) };
	// 82A1F610: 4B7D0C31  bl 0x821f0240
	ctx.lr = 0x82A1F614;
	sub_821F0240(ctx, base);
	// 82A1F614: 83810094  lwz r28, 0x94(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A1F618: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1F61C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A1F620: 4B845B81  bl 0x822651a0
	ctx.lr = 0x82A1F624;
	sub_822651A0(ctx, base);
	// 82A1F624: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82A1F628: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1F62C: 4B845B75  bl 0x822651a0
	ctx.lr = 0x82A1F630;
	sub_822651A0(ctx, base);
	// 82A1F630: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A1F634: 4B7A7135  bl 0x821c6768
	ctx.lr = 0x82A1F638;
	sub_821C6768(ctx, base);
	// 82A1F638: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x82A1F63C; continue 'dispatch;
            }
            0x82A1F63C => {
    //   block [0x82A1F63C..0x82A1F660)
	// 82A1F63C: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 82A1F640: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F644: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 82A1F648: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82A1F64C: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1F650: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F654: 4082FFE8  bne 0x82a1f63c
	if !ctx.cr[0].eq {
	pc = 0x82A1F63C; continue 'dispatch;
	}
	// 82A1F658: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 82A1F65C: 4BFFFDB8  b 0x82a1f414
	pc = 0x82A1F414; continue 'dispatch;
            }
            0x82A1F660 => {
    //   block [0x82A1F660..0x82A1F6AC)
	// 82A1F660: 7F1DA840  cmplw cr6, r29, r21
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82A1F664: 3B18FFFC  addi r24, r24, -4
	ctx.r[24].s64 = ctx.r[24].s64 + -4;
	// 82A1F668: 409A00C0  bne cr6, 0x82a1f728
	if !ctx.cr[6].eq {
	pc = 0x82A1F728; continue 'dispatch;
	}
	// 82A1F66C: 3BFFFFFC  addi r31, r31, -4
	ctx.r[31].s64 = ctx.r[31].s64 + -4;
	// 82A1F670: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 82A1F674: 7F18F840  cmplw cr6, r24, r31
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A1F678: 419A0054  beq cr6, 0x82a1f6cc
	if ctx.cr[6].eq {
	pc = 0x82A1F6CC; continue 'dispatch;
	}
	// 82A1F67C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A1F680: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1F684: 4B7D0BBD  bl 0x821f0240
	ctx.lr = 0x82A1F688;
	sub_821F0240(ctx, base);
	// 82A1F688: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1F68C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A1F690: 4B845B11  bl 0x822651a0
	ctx.lr = 0x82A1F694;
	sub_822651A0(ctx, base);
	// 82A1F694: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82A1F698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F69C: 4B845B05  bl 0x822651a0
	ctx.lr = 0x82A1F6A0;
	sub_822651A0(ctx, base);
	// 82A1F6A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1F6A4: 4B7A70C5  bl 0x821c6768
	ctx.lr = 0x82A1F6A8;
	sub_821C6768(ctx, base);
	// 82A1F6A8: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x82A1F6AC; continue 'dispatch;
            }
            0x82A1F6AC => {
    //   block [0x82A1F6AC..0x82A1F6CC)
	// 82A1F6AC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A1F6B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F6B4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A1F6B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A1F6BC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1F6C0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F6C4: 4082FFE8  bne 0x82a1f6ac
	if !ctx.cr[0].eq {
	pc = 0x82A1F6AC; continue 'dispatch;
	}
	// 82A1F6C8: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	pc = 0x82A1F6CC; continue 'dispatch;
            }
            0x82A1F6CC => {
    //   block [0x82A1F6CC..0x82A1F704)
	// 82A1F6CC: 3B7BFFFC  addi r27, r27, -4
	ctx.r[27].s64 = ctx.r[27].s64 + -4;
	// 82A1F6D0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1F6D4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82A1F6D8: 9361007C  stw r27, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[27].u32 ) };
	// 82A1F6DC: 4B7D0B65  bl 0x821f0240
	ctx.lr = 0x82A1F6E0;
	sub_821F0240(ctx, base);
	// 82A1F6E0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A1F6E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F6E8: 4B845AB9  bl 0x822651a0
	ctx.lr = 0x82A1F6EC;
	sub_822651A0(ctx, base);
	// 82A1F6EC: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82A1F6F0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A1F6F4: 4B845AAD  bl 0x822651a0
	ctx.lr = 0x82A1F6F8;
	sub_822651A0(ctx, base);
	// 82A1F6F8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82A1F6FC: 4B7A706D  bl 0x821c6768
	ctx.lr = 0x82A1F700;
	sub_821C6768(ctx, base);
	// 82A1F700: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x82A1F704; continue 'dispatch;
            }
            0x82A1F704 => {
    //   block [0x82A1F704..0x82A1F728)
	// 82A1F704: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A1F708: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F70C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A1F710: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A1F714: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1F718: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F71C: 4082FFE8  bne 0x82a1f704
	if !ctx.cr[0].eq {
	pc = 0x82A1F704; continue 'dispatch;
	}
	// 82A1F720: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 82A1F724: 4BFFFCF0  b 0x82a1f414
	pc = 0x82A1F414; continue 'dispatch;
            }
            0x82A1F728 => {
    //   block [0x82A1F728..0x82A1F76C)
	// 82A1F728: E9610080  ld r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 82A1F72C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82A1F730: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1F734: 93A10084  stw r29, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	// 82A1F738: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 82A1F73C: 83C10094  lwz r30, 0x94(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A1F740: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1F744: 4B7D0AFD  bl 0x821f0240
	ctx.lr = 0x82A1F748;
	sub_821F0240(ctx, base);
	// 82A1F748: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A1F74C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A1F750: 4B845A51  bl 0x822651a0
	ctx.lr = 0x82A1F754;
	sub_822651A0(ctx, base);
	// 82A1F754: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82A1F758: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A1F75C: 4B845A45  bl 0x822651a0
	ctx.lr = 0x82A1F760;
	sub_822651A0(ctx, base);
	// 82A1F760: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82A1F764: 4B7A7005  bl 0x821c6768
	ctx.lr = 0x82A1F768;
	sub_821C6768(ctx, base);
	// 82A1F768: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x82A1F76C; continue 'dispatch;
            }
            0x82A1F76C => {
    //   block [0x82A1F76C..0x82A1F790)
	// 82A1F76C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1F770: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F774: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1F778: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A1F77C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1F780: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1F784: 4082FFE8  bne 0x82a1f76c
	if !ctx.cr[0].eq {
	pc = 0x82A1F76C; continue 'dispatch;
	}
	// 82A1F788: 93210068  stw r25, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 82A1F78C: 4BFFFC88  b 0x82a1f414
	pc = 0x82A1F414; continue 'dispatch;
            }
            0x82A1F790 => {
    //   block [0x82A1F790..0x82A1F7AC)
	// 82A1F790: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 82A1F794: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 82A1F798: E9410078  ld r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 82A1F79C: F9740000  std r11, 0(r20)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82A1F7A0: F9540008  std r10, 8(r20)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[20].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82A1F7A4: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82A1F7A8: 48289C90  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1F7B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1F7B0 size=300
    let mut pc: u32 = 0x82A1F7B0;
    'dispatch: loop {
        match pc {
            0x82A1F7B0 => {
    //   block [0x82A1F7B0..0x82A1F7F0)
	// 82A1F7B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1F7B4: 48289C45  bl 0x82ca93f8
	ctx.lr = 0x82A1F7B8;
	sub_82CA93D0(ctx, base);
	// 82A1F7B8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1F7BC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82A1F7C0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A1F7C4: FB2100C0  std r25, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[25].u64 ) };
	// 82A1F7C8: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 82A1F7CC: 834100C4  lwz r26, 0xc4(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A1F7D0: 830100CC  lwz r24, 0xcc(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A1F7D4: 7F1AC040  cmplw cr6, r26, r24
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A1F7D8: 419A00FC  beq cr6, 0x82a1f8d4
	if ctx.cr[6].eq {
	pc = 0x82A1F8D4; continue 'dispatch;
	}
	// 82A1F7DC: 3BFA0004  addi r31, r26, 4
	ctx.r[31].s64 = ctx.r[26].s64 + 4;
	// 82A1F7E0: FB210050  std r25, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u64 ) };
	// 82A1F7E4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A1F7E8: 7F1FC040  cmplw cr6, r31, r24
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A1F7EC: 419A00E8  beq cr6, 0x82a1f8d4
	if ctx.cr[6].eq {
	pc = 0x82A1F8D4; continue 'dispatch;
	}
	pc = 0x82A1F7F0; continue 'dispatch;
            }
            0x82A1F7F0 => {
    //   block [0x82A1F7F0..0x82A1F834)
	// 82A1F7F0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A1F7F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F7F8: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 82A1F7FC: 4E800421  bctrl
	ctx.lr = 0x82A1F800;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1F800: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1F804: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F808: 419A002C  beq cr6, 0x82a1f834
	if ctx.cr[6].eq {
	pc = 0x82A1F834; continue 'dispatch;
	}
	// 82A1F80C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A1F810: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A1F814: 7F1AF840  cmplw cr6, r26, r31
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A1F818: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 82A1F81C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A1F820: 419A00A4  beq cr6, 0x82a1f8c4
	if ctx.cr[6].eq {
	pc = 0x82A1F8C4; continue 'dispatch;
	}
	// 82A1F824: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A1F828: 419A009C  beq cr6, 0x82a1f8c4
	if ctx.cr[6].eq {
	pc = 0x82A1F8C4; continue 'dispatch;
	}
	// 82A1F82C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82A1F830: 48000084  b 0x82a1f8b4
	pc = 0x82A1F8B4; continue 'dispatch;
            }
            0x82A1F834 => {
    //   block [0x82A1F834..0x82A1F860)
	// 82A1F834: EB810050  ld r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A1F838: 3BDFFFFC  addi r30, r31, -4
	ctx.r[30].s64 = ctx.r[31].s64 + -4;
	// 82A1F83C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F840: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1F844: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 82A1F848: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82A1F84C: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 82A1F850: 4E800421  bctrl
	ctx.lr = 0x82A1F854;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1F854: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1F858: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F85C: 419A0068  beq cr6, 0x82a1f8c4
	if ctx.cr[6].eq {
	pc = 0x82A1F8C4; continue 'dispatch;
	}
            }
            0x82A1F860 => {
    //   block [0x82A1F860..0x82A1F8B4)
	// 82A1F860: EBA10058  ld r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A1F864: 3BDEFFFC  addi r30, r30, -4
	ctx.r[30].s64 = ctx.r[30].s64 + -4;
	// 82A1F868: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1F86C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82A1F870: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1F874: FBA10060  std r29, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u64 ) };
	// 82A1F878: 7F6903A6  mtctr r27
	ctx.ctr.u64 = ctx.r[27].u64;
	// 82A1F87C: 4E800421  bctrl
	ctx.lr = 0x82A1F880;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1F880: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1F884: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1F888: 409AFFD8  bne cr6, 0x82a1f860
	if !ctx.cr[6].eq {
	pc = 0x82A1F860; continue 'dispatch;
	}
	// 82A1F88C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82A1F890: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A1F894: 419A0030  beq cr6, 0x82a1f8c4
	if ctx.cr[6].eq {
	pc = 0x82A1F8C4; continue 'dispatch;
	}
	// 82A1F898: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82A1F89C: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 82A1F8A0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A1F8A4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A1F8A8: 419A001C  beq cr6, 0x82a1f8c4
	if ctx.cr[6].eq {
	pc = 0x82A1F8C4; continue 'dispatch;
	}
	// 82A1F8AC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A1F8B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
            }
            0x82A1F8B4 => {
    //   block [0x82A1F8B4..0x82A1F8C4)
	// 82A1F8B4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A1F8B8: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A1F8BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82A1F8C0: 4BC578E9  bl 0x826771a8
	ctx.lr = 0x82A1F8C4;
	sub_826771A8(ctx, base);
	pc = 0x82A1F8C4; continue 'dispatch;
            }
            0x82A1F8C4 => {
    //   block [0x82A1F8C4..0x82A1F8D4)
	// 82A1F8C4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82A1F8C8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82A1F8CC: 7F1FC040  cmplw cr6, r31, r24
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[24].u32, &mut ctx.xer);
	// 82A1F8D0: 409AFF20  bne cr6, 0x82a1f7f0
	if !ctx.cr[6].eq {
	pc = 0x82A1F7F0; continue 'dispatch;
	}
	pc = 0x82A1F8D4; continue 'dispatch;
            }
            0x82A1F8D4 => {
    //   block [0x82A1F8D4..0x82A1F8DC)
	// 82A1F8D4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A1F8D8: 48289B70  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1F8E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1F8E0 size=276
    let mut pc: u32 = 0x82A1F8E0;
    'dispatch: loop {
        match pc {
            0x82A1F8E0 => {
    //   block [0x82A1F8E0..0x82A1F9E0)
	// 82A1F8E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1F8E4: 48289B15  bl 0x82ca93f8
	ctx.lr = 0x82A1F8E8;
	sub_82CA93D0(ctx, base);
	// 82A1F8E8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1F8EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A1F8F0: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A1F8F4: FBC100C0  std r30, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u64 ) };
	// 82A1F8F8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A1F8FC: FB8100D0  std r28, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[28].u64 ) };
	// 82A1F900: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82A1F904: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82A1F908: 830100D4  lwz r24, 0xd4(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 82A1F90C: 7D6AC050  subf r11, r10, r24
	ctx.r[11].s64 = ctx.r[24].s64 - ctx.r[10].s64;
	// 82A1F910: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82A1F914: FBA100C8  std r29, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[29].u64 ) };
	// 82A1F918: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 82A1F91C: 409900C4  ble cr6, 0x82a1f9e0
	if !ctx.cr[6].gt {
	pc = 0x82A1F9E0; continue 'dispatch;
	}
	// 82A1F920: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A1F924: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 82A1F928: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 82A1F92C: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A1F930: 7D690194  addze r11, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82A1F934: 557F103A  slwi r31, r11, 2
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82A1F938: 55791838  slwi r25, r11, 3
	ctx.r[25].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 82A1F93C: 7F5F5214  add r26, r31, r10
	ctx.r[26].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 82A1F940: 7D195214  add r8, r25, r10
	ctx.r[8].u64 = ctx.r[25].u64 + ctx.r[10].u64;
	// 82A1F944: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82A1F948: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82A1F94C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A1F950: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A1F954: 48000175  bl 0x82a1fac8
	ctx.lr = 0x82A1F958;
	sub_82A1FAC8(ctx, base);
	// 82A1F958: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82A1F95C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A1F960: FBA10058  std r29, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u64 ) };
	// 82A1F964: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1F968: 7CBF5850  subf r5, r31, r11
	ctx.r[5].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 82A1F96C: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 82A1F970: 7CFF5A14  add r7, r31, r11
	ctx.r[7].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82A1F974: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 82A1F978: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 82A1F97C: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A1F980: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A1F984: 48000145  bl 0x82a1fac8
	ctx.lr = 0x82A1F988;
	sub_82A1FAC8(ctx, base);
	// 82A1F988: 7C99C050  subf r4, r25, r24
	ctx.r[4].s64 = ctx.r[24].s64 - ctx.r[25].s64;
	// 82A1F98C: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 82A1F990: 7FFFC050  subf r31, r31, r24
	ctx.r[31].s64 = ctx.r[24].s64 - ctx.r[31].s64;
	// 82A1F994: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 82A1F998: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A1F99C: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 82A1F9A0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A1F9A4: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A1F9A8: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A1F9AC: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A1F9B0: 48000119  bl 0x82a1fac8
	ctx.lr = 0x82A1F9B4;
	sub_82A1FAC8(ctx, base);
	// 82A1F9B4: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 82A1F9B8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82A1F9BC: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 82A1F9C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1F9C4: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82A1F9C8: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 82A1F9CC: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A1F9D0: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A1F9D4: 480000F5  bl 0x82a1fac8
	ctx.lr = 0x82A1F9D8;
	sub_82A1FAC8(ctx, base);
	// 82A1F9D8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A1F9DC: 48289A6C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A1F9E0 => {
    //   block [0x82A1F9E0..0x82A1F9F4)
	// 82A1F9E0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82A1F9E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1F9E8: 480000E1  bl 0x82a1fac8
	ctx.lr = 0x82A1F9EC;
	sub_82A1FAC8(ctx, base);
	// 82A1F9EC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82A1F9F0: 48289A58  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1F9F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1F9F8 size=208
    let mut pc: u32 = 0x82A1F9F8;
    'dispatch: loop {
        match pc {
            0x82A1F9F8 => {
    //   block [0x82A1F9F8..0x82A1FA38)
	// 82A1F9F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1F9FC: 482899FD  bl 0x82ca93f8
	ctx.lr = 0x82A1FA00;
	sub_82CA93D0(ctx, base);
	// 82A1FA00: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1FA04: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A1FA08: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82A1FA0C: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 82A1FA10: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 82A1FA14: 83C100B4  lwz r30, 0xb4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A1FA18: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82A1FA1C: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82A1FA20: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82A1FA24: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A1FA28: 40990098  ble cr6, 0x82a1fac0
	if !ctx.cr[6].gt {
	pc = 0x82A1FAC0; continue 'dispatch;
	}
	// 82A1FA2C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82A1FA30: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82A1FA34: 3B8A7088  addi r28, r10, 0x7088
	ctx.r[28].s64 = ctx.r[10].s64 + 28808;
	pc = 0x82A1FA38; continue 'dispatch;
            }
            0x82A1FA38 => {
    //   block [0x82A1FA38..0x82A1FA8C)
	// 82A1FA38: 3BFDFFFC  addi r31, r29, -4
	ctx.r[31].s64 = ctx.r[29].s64 + -4;
	// 82A1FA3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1FA40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1FA44: 4B7D07FD  bl 0x821f0240
	ctx.lr = 0x82A1FA48;
	sub_821F0240(ctx, base);
	// 82A1FA48: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82A1FA4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1FA50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FA54: 4B84574D  bl 0x822651a0
	ctx.lr = 0x82A1FA58;
	sub_822651A0(ctx, base);
	// 82A1FA58: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A1FA5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A1FA60: 4B7D07E1  bl 0x821f0240
	ctx.lr = 0x82A1FA64;
	sub_821F0240(ctx, base);
	// 82A1FA64: 7D7EF850  subf r11, r30, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[30].s64;
	// 82A1FA68: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82A1FA6C: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82A1FA70: 7D651670  srawi r5, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82A1FA74: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82A1FA78: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A1FA7C: 480000F5  bl 0x82a1fb70
	ctx.lr = 0x82A1FA80;
	sub_82A1FB70(ctx, base);
	// 82A1FA80: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A1FA84: 4B7A6CE5  bl 0x821c6768
	ctx.lr = 0x82A1FA88;
	sub_821C6768(ctx, base);
	// 82A1FA88: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	pc = 0x82A1FA8C; continue 'dispatch;
            }
            0x82A1FA8C => {
    //   block [0x82A1FA8C..0x82A1FAC0)
	// 82A1FA8C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1FA90: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1FA94: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1FA98: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A1FA9C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1FAA0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1FAA4: 4082FFE8  bne 0x82a1fa8c
	if !ctx.cr[0].eq {
	pc = 0x82A1FA8C; continue 'dispatch;
	}
	// 82A1FAA8: 3BBDFFFC  addi r29, r29, -4
	ctx.r[29].s64 = ctx.r[29].s64 + -4;
	// 82A1FAAC: 93380000  stw r25, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 82A1FAB0: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82A1FAB4: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 82A1FAB8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82A1FABC: 4199FF7C  bgt cr6, 0x82a1fa38
	if ctx.cr[6].gt {
	pc = 0x82A1FA38; continue 'dispatch;
	}
	pc = 0x82A1FAC0; continue 'dispatch;
            }
            0x82A1FAC0 => {
    //   block [0x82A1FAC0..0x82A1FAC8)
	// 82A1FAC0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1FAC4: 48289984  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1FAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1FAC8 size=168
    let mut pc: u32 = 0x82A1FAC8;
    'dispatch: loop {
        match pc {
            0x82A1FAC8 => {
    //   block [0x82A1FAC8..0x82A1FB14)
	// 82A1FAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1FACC: 4828993D  bl 0x82ca9408
	ctx.lr = 0x82A1FAD0;
	sub_82CA93D0(ctx, base);
	// 82A1FAD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1FAD4: F8610090  std r3, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[3].u64 ) };
	// 82A1FAD8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82A1FADC: F8810098  std r4, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[4].u64 ) };
	// 82A1FAE0: 83E1009C  lwz r31, 0x9c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 82A1FAE4: 83810094  lwz r28, 0x94(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 82A1FAE8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A1FAEC: F8A100A0  std r5, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[5].u64 ) };
	// 82A1FAF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FAF4: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 82A1FAF8: 4E800421  bctrl
	ctx.lr = 0x82A1FAFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1FAFC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1FB00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1FB04: 419A0010  beq cr6, 0x82a1fb14
	if ctx.cr[6].eq {
	pc = 0x82A1FB14; continue 'dispatch;
	}
	// 82A1FB08: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A1FB0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FB10: 4B906B19  bl 0x82326628
	ctx.lr = 0x82A1FB14;
	sub_82326628(ctx, base);
            }
            0x82A1FB14 => {
    //   block [0x82A1FB14..0x82A1FB40)
	// 82A1FB14: 83A100A4  lwz r29, 0xa4(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 82A1FB18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1FB1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1FB20: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 82A1FB24: 4E800421  bctrl
	ctx.lr = 0x82A1FB28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1FB28: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1FB2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1FB30: 419A0010  beq cr6, 0x82a1fb40
	if ctx.cr[6].eq {
	pc = 0x82A1FB40; continue 'dispatch;
	}
	// 82A1FB34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A1FB38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82A1FB3C: 4B906AED  bl 0x82326628
	ctx.lr = 0x82A1FB40;
	sub_82326628(ctx, base);
            }
            0x82A1FB40 => {
    //   block [0x82A1FB40..0x82A1FB68)
	// 82A1FB40: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A1FB44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FB48: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 82A1FB4C: 4E800421  bctrl
	ctx.lr = 0x82A1FB50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1FB50: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1FB54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1FB58: 419A0010  beq cr6, 0x82a1fb68
	if ctx.cr[6].eq {
	pc = 0x82A1FB68; continue 'dispatch;
	}
	// 82A1FB5C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A1FB60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FB64: 4B906AC5  bl 0x82326628
	ctx.lr = 0x82A1FB68;
	sub_82326628(ctx, base);
            }
            0x82A1FB68 => {
    //   block [0x82A1FB68..0x82A1FB70)
	// 82A1FB68: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A1FB6C: 482898EC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1FB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A1FB70 size=400
    let mut pc: u32 = 0x82A1FB70;
    'dispatch: loop {
        match pc {
            0x82A1FB70 => {
    //   block [0x82A1FB70..0x82A1FBA8)
	// 82A1FB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1FB74: 48289885  bl 0x82ca93f8
	ctx.lr = 0x82A1FB78;
	sub_82CA93D0(ctx, base);
	// 82A1FB78: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1FB7C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82A1FB80: F86100B0  std r3, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[3].u64 ) };
	// 82A1FB84: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82A1FB88: 83C100B4  lwz r30, 0xb4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82A1FB8C: 397D0001  addi r11, r29, 1
	ctx.r[11].s64 = ctx.r[29].s64 + 1;
	// 82A1FB90: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82A1FB94: 557F083C  slwi r31, r11, 1
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82A1FB98: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82A1FB9C: 7FB9EB78  mr r25, r29
	ctx.r[25].u64 = ctx.r[29].u64;
	// 82A1FBA0: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82A1FBA4: 40980054  bge cr6, 0x82a1fbf8
	if !ctx.cr[6].lt {
	pc = 0x82A1FBF8; continue 'dispatch;
	}
	pc = 0x82A1FBA8; continue 'dispatch;
            }
            0x82A1FBA8 => {
    //   block [0x82A1FBA8..0x82A1FBCC)
	// 82A1FBA8: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1FBAC: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A1FBB0: 3883FFFC  addi r4, r3, -4
	ctx.r[4].s64 = ctx.r[3].s64 + -4;
	// 82A1FBB4: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	// 82A1FBB8: 4E800421  bctrl
	ctx.lr = 0x82A1FBBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1FBBC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1FBC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1FBC4: 419A0008  beq cr6, 0x82a1fbcc
	if ctx.cr[6].eq {
	pc = 0x82A1FBCC; continue 'dispatch;
	}
	// 82A1FBC8: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
            }
            0x82A1FBCC => {
    //   block [0x82A1FBCC..0x82A1FBF8)
	// 82A1FBCC: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1FBD0: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1FBD4: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A1FBD8: 7C6AF214  add r3, r10, r30
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A1FBDC: 4B8455C5  bl 0x822651a0
	ctx.lr = 0x82A1FBE0;
	sub_822651A0(ctx, base);
	// 82A1FBE0: 397F0001  addi r11, r31, 1
	ctx.r[11].s64 = ctx.r[31].s64 + 1;
	// 82A1FBE4: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82A1FBE8: 557F083C  slwi r31, r11, 1
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82A1FBEC: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82A1FBF0: 4198FFB8  blt cr6, 0x82a1fba8
	if ctx.cr[6].lt {
	pc = 0x82A1FBA8; continue 'dispatch;
	}
	// 82A1FBF4: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	pc = 0x82A1FBF8; continue 'dispatch;
            }
            0x82A1FBF8 => {
    //   block [0x82A1FBF8..0x82A1FC18)
	// 82A1FBF8: 409A0020  bne cr6, 0x82a1fc18
	if !ctx.cr[6].eq {
	pc = 0x82A1FC18; continue 'dispatch;
	}
	// 82A1FBFC: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1FC00: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82A1FC04: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A1FC08: 7C6AF214  add r3, r10, r30
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82A1FC0C: 388BFFFC  addi r4, r11, -4
	ctx.r[4].s64 = ctx.r[11].s64 + -4;
	// 82A1FC10: 4B845591  bl 0x822651a0
	ctx.lr = 0x82A1FC14;
	sub_822651A0(ctx, base);
	// 82A1FC14: 3BBCFFFF  addi r29, r28, -1
	ctx.r[29].s64 = ctx.r[28].s64 + -1;
	pc = 0x82A1FC18; continue 'dispatch;
            }
            0x82A1FC18 => {
    //   block [0x82A1FC18..0x82A1FC3C)
	// 82A1FC18: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82A1FC1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A1FC20: 4B7D0621  bl 0x821f0240
	ctx.lr = 0x82A1FC24;
	sub_821F0240(ctx, base);
	// 82A1FC24: 397DFFFF  addi r11, r29, -1
	ctx.r[11].s64 = ctx.r[29].s64 + -1;
	// 82A1FC28: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82A1FC2C: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A1FC30: 7F19E800  cmpw cr6, r25, r29
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82A1FC34: 7FEA0194  addze r31, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[31].s64 = tmp.s64;
	// 82A1FC38: 40980050  bge cr6, 0x82a1fc88
	if !ctx.cr[6].lt {
	pc = 0x82A1FC88; continue 'dispatch;
	}
	pc = 0x82A1FC3C; continue 'dispatch;
            }
            0x82A1FC3C => {
    //   block [0x82A1FC3C..0x82A1FC88)
	// 82A1FC3C: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1FC40: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A1FC44: 7F8BF214  add r28, r11, r30
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A1FC48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A1FC4C: 7F4903A6  mtctr r26
	ctx.ctr.u64 = ctx.r[26].u64;
	// 82A1FC50: 4E800421  bctrl
	ctx.lr = 0x82A1FC54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A1FC54: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A1FC58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A1FC5C: 419A002C  beq cr6, 0x82a1fc88
	if ctx.cr[6].eq {
	pc = 0x82A1FC88; continue 'dispatch;
	}
	// 82A1FC60: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1FC64: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A1FC68: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A1FC6C: 4B845535  bl 0x822651a0
	ctx.lr = 0x82A1FC70;
	sub_822651A0(ctx, base);
	// 82A1FC70: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 82A1FC74: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82A1FC78: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82A1FC7C: 7F19E800  cmpw cr6, r25, r29
	ctx.cr[6].compare_i32(ctx.r[25].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82A1FC80: 7FEA0194  addze r31, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[31].s64 = tmp.s64;
	// 82A1FC84: 4198FFB8  blt cr6, 0x82a1fc3c
	if ctx.cr[6].lt {
	pc = 0x82A1FC3C; continue 'dispatch;
	}
            }
            0x82A1FC88 => {
    //   block [0x82A1FC88..0x82A1FCAC)
	// 82A1FC88: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A1FC8C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A1FC90: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82A1FC94: 4B84550D  bl 0x822651a0
	ctx.lr = 0x82A1FC98;
	sub_822651A0(ctx, base);
	// 82A1FC98: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A1FC9C: 4B7A6ACD  bl 0x821c6768
	ctx.lr = 0x82A1FCA0;
	sub_821C6768(ctx, base);
	// 82A1FCA0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A1FCA4: 3BCB7088  addi r30, r11, 0x7088
	ctx.r[30].s64 = ctx.r[11].s64 + 28808;
	// 82A1FCA8: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	pc = 0x82A1FCAC; continue 'dispatch;
            }
            0x82A1FCAC => {
    //   block [0x82A1FCAC..0x82A1FCD8)
	// 82A1FCAC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1FCB0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1FCB4: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1FCB8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A1FCBC: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1FCC0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1FCC4: 4082FFE8  bne 0x82a1fcac
	if !ctx.cr[0].eq {
	pc = 0x82A1FCAC; continue 'dispatch;
	}
	// 82A1FCC8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82A1FCCC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82A1FCD0: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A1FCD4: 4B7A6A95  bl 0x821c6768
	ctx.lr = 0x82A1FCD8;
	sub_821C6768(ctx, base);
	pc = 0x82A1FCD8; continue 'dispatch;
            }
            0x82A1FCD8 => {
    //   block [0x82A1FCD8..0x82A1FD00)
	// 82A1FCD8: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 82A1FCDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1FCE0: 7CE0F028  lwarx r7, 0, r30
	// lwarx
	let ea = ctx.r[30].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 82A1FCE4: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 82A1FCE8: 7CE0F12D  stwcx. r7, 0, r30
	// stwcx.
	let addr = ctx.r[30].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1FCEC: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1FCF0: 4082FFE8  bne 0x82a1fcd8
	if !ctx.cr[0].eq {
	pc = 0x82A1FCD8; continue 'dispatch;
	}
	// 82A1FCF4: 93F80000  stw r31, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A1FCF8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1FCFC: 4828974C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1FD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1FD00 size=472
    let mut pc: u32 = 0x82A1FD00;
    'dispatch: loop {
        match pc {
            0x82A1FD00 => {
    //   block [0x82A1FD00..0x82A1FD24)
	// 82A1FD00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1FD04: 482896FD  bl 0x82ca9400
	ctx.lr = 0x82A1FD08;
	sub_82CA93D0(ctx, base);
	// 82A1FD08: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1FD0C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A1FD10: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82A1FD14: 3B6B7088  addi r27, r11, 0x7088
	ctx.r[27].s64 = ctx.r[11].s64 + 28808;
	// 82A1FD18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1FD1C: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 82A1FD20: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x82A1FD24; continue 'dispatch;
            }
            0x82A1FD24 => {
    //   block [0x82A1FD24..0x82A1FD78)
	// 82A1FD24: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1FD28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1FD2C: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1FD30: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1FD34: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1FD38: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1FD3C: 4082FFE8  bne 0x82a1fd24
	if !ctx.cr[0].eq {
	pc = 0x82A1FD24; continue 'dispatch;
	}
	// 82A1FD40: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1FD44: 3C60820F  lis r3, -0x7df1
	ctx.r[3].s64 = -2112946176;
	// 82A1FD48: 80DF000C  lwz r6, 0xc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A1FD4C: 3880D8EE  li r4, -0x2712
	ctx.r[4].s64 = -10002;
	// 82A1FD50: 7D662850  subf r11, r6, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[6].s64;
	// 82A1FD54: 38A32A80  addi r5, r3, 0x2a80
	ctx.r[5].s64 = ctx.r[3].s64 + 10880;
	// 82A1FD58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FD5C: 7D7C1E70  srawi r28, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A1FD60: 4B808629  bl 0x82228388
	ctx.lr = 0x82A1FD64;
	sub_82228388(ctx, base);
	// 82A1FD64: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82A1FD68: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 82A1FD6C: 419800F8  blt cr6, 0x82a1fe64
	if ctx.cr[6].lt {
	pc = 0x82A1FE64; continue 'dispatch;
	}
	// 82A1FD70: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A1FD74: 3B4BABAC  addi r26, r11, -0x5454
	ctx.r[26].s64 = ctx.r[11].s64 + -21588;
	pc = 0x82A1FD78; continue 'dispatch;
            }
            0x82A1FD78 => {
    //   block [0x82A1FD78..0x82A1FE18)
	// 82A1FD78: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1FD7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A1FD80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FD84: 814BFFF8  lwz r10, -8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A1FD88: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A1FD8C: 812BFFFC  lwz r9, -4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82A1FD90: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A1FD94: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1FD98: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 82A1FD9C: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A1FDA0: 48004341  bl 0x82a240e0
	ctx.lr = 0x82A1FDA4;
	sub_82A240E0(ctx, base);
	// 82A1FDA4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82A1FDA8: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1FDAC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A1FDB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FDB4: 80870000  lwz r4, 0(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1FDB8: 90860000  stw r4, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82A1FDBC: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1FDC0: 91660004  stw r11, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A1FDC4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1FDC8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82A1FDCC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A1FDD0: 388BFFF0  addi r4, r11, -0x10
	ctx.r[4].s64 = ctx.r[11].s64 + -16;
	// 82A1FDD4: 4B808D9D  bl 0x82228b70
	ctx.lr = 0x82A1FDD8;
	sub_82228B70(ctx, base);
	// 82A1FDD8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1FDDC: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 82A1FDE0: 814BFFFC  lwz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82A1FDE4: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 82A1FDE8: 419A0038  beq cr6, 0x82a1fe20
	if ctx.cr[6].eq {
	pc = 0x82A1FE20; continue 'dispatch;
	}
	// 82A1FDEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FDF0: 4B87EF69  bl 0x8229ed58
	ctx.lr = 0x82A1FDF4;
	sub_8229ED58(ctx, base);
	// 82A1FDF4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A1FDF8: 419A009C  beq cr6, 0x82a1fe94
	if ctx.cr[6].eq {
	pc = 0x82A1FE94; continue 'dispatch;
	}
	// 82A1FDFC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A1FE00: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82A1FE04: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82A1FE08: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A1FE0C: 4198000C  blt cr6, 0x82a1fe18
	if ctx.cr[6].lt {
	pc = 0x82A1FE18; continue 'dispatch;
	}
	// 82A1FE10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FE14: 4B75976D  bl 0x82179580
	ctx.lr = 0x82A1FE18;
	sub_82179580(ctx, base);
	pc = 0x82A1FE18; continue 'dispatch;
            }
            0x82A1FE18 => {
    //   block [0x82A1FE18..0x82A1FE20)
	// 82A1FE18: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1FE1C: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	pc = 0x82A1FE20; continue 'dispatch;
            }
            0x82A1FE20 => {
    //   block [0x82A1FE20..0x82A1FE40)
	// 82A1FE20: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A1FE24: 37AB0010  addic. r29, r11, 0x10
	ctx.xer.ca = (ctx.r[11].u32 > (!(16 as u32)));
	ctx.r[29].s64 = ctx.r[11].s64 + 16;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A1FE28: 4182006C  beq 0x82a1fe94
	if ctx.cr[0].eq {
	pc = 0x82A1FE94; continue 'dispatch;
	}
	// 82A1FE2C: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 82A1FE30: 40990010  ble cr6, 0x82a1fe40
	if !ctx.cr[6].gt {
	pc = 0x82A1FE40; continue 'dispatch;
	}
	// 82A1FE34: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82A1FE38: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1FE3C: 4B7BAB85  bl 0x821da9c0
	ctx.lr = 0x82A1FE40;
	sub_821DA9C0(ctx, base);
	pc = 0x82A1FE40; continue 'dispatch;
            }
            0x82A1FE40 => {
    //   block [0x82A1FE40..0x82A1FE64)
	// 82A1FE40: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A1FE44: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1FE48: 4B7BAB79  bl 0x821da9c0
	ctx.lr = 0x82A1FE4C;
	sub_821DA9C0(ctx, base);
	// 82A1FE4C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A1FE50: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82A1FE54: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 82A1FE58: 7F1EE000  cmpw cr6, r30, r28
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82A1FE5C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A1FE60: 4099FF18  ble cr6, 0x82a1fd78
	if !ctx.cr[6].gt {
	pc = 0x82A1FD78; continue 'dispatch;
	}
	pc = 0x82A1FE64; continue 'dispatch;
            }
            0x82A1FE64 => {
    //   block [0x82A1FE64..0x82A1FE6C)
	// 82A1FE64: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1FE68: 4B7A6901  bl 0x821c6768
	ctx.lr = 0x82A1FE6C;
	sub_821C6768(ctx, base);
	pc = 0x82A1FE6C; continue 'dispatch;
            }
            0x82A1FE6C => {
    //   block [0x82A1FE6C..0x82A1FE94)
	// 82A1FE6C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82A1FE70: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1FE74: 7D60D828  lwarx r11, 0, r27
	// lwarx
	let ea = ctx.r[27].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82A1FE78: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A1FE7C: 7D60D92D  stwcx. r11, 0, r27
	// stwcx.
	let addr = ctx.r[27].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1FE80: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1FE84: 4082FFE8  bne 0x82a1fe6c
	if !ctx.cr[0].eq {
	pc = 0x82A1FE6C; continue 'dispatch;
	}
	// 82A1FE88: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A1FE8C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1FE90: 482895C0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A1FE94 => {
    //   block [0x82A1FE94..0x82A1FEB0)
	// 82A1FE94: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1FE98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FE9C: 388B2A8C  addi r4, r11, 0x2a8c
	ctx.r[4].s64 = ctx.r[11].s64 + 10892;
	// 82A1FEA0: 48005019  bl 0x82a24eb8
	ctx.lr = 0x82A1FEA4;
	sub_82A24EB8(ctx, base);
	// 82A1FEA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1FEA8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82A1FEAC: 4B7A68BD  bl 0x821c6768
	ctx.lr = 0x82A1FEB0;
	sub_821C6768(ctx, base);
	pc = 0x82A1FEB0; continue 'dispatch;
            }
            0x82A1FEB0 => {
    //   block [0x82A1FEB0..0x82A1FED8)
	// 82A1FEB0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1FEB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1FEB8: 7D40D828  lwarx r10, 0, r27
	// lwarx
	let ea = ctx.r[27].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1FEBC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A1FEC0: 7D40D92D  stwcx. r10, 0, r27
	// stwcx.
	let addr = ctx.r[27].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1FEC4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1FEC8: 4082FFE8  bne 0x82a1feb0
	if !ctx.cr[0].eq {
	pc = 0x82A1FEB0; continue 'dispatch;
	}
	// 82A1FECC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A1FED0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A1FED4: 4828957C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A1FED8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A1FED8 size=408
    let mut pc: u32 = 0x82A1FED8;
    'dispatch: loop {
        match pc {
            0x82A1FED8 => {
    //   block [0x82A1FED8..0x82A1FF14)
	// 82A1FED8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A1FEDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A1FEE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A1FEE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A1FEE8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A1FEEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A1FEF0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1FEF4: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 82A1FEF8: 38EB2AE0  addi r7, r11, 0x2ae0
	ctx.r[7].s64 = ctx.r[11].s64 + 10976;
	// 82A1FEFC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82A1FF00: 38C87088  addi r6, r8, 0x7088
	ctx.r[6].s64 = ctx.r[8].s64 + 28808;
	// 82A1FF04: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82A1FF08: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82A1FF0C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82A1FF10: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	pc = 0x82A1FF14; continue 'dispatch;
            }
            0x82A1FF14 => {
    //   block [0x82A1FF14..0x82A1FF34)
	// 82A1FF14: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A1FF18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1FF1C: 7D402828  lwarx r10, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A1FF20: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82A1FF24: 7D40292D  stwcx. r10, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1FF28: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1FF2C: 4082FFE8  bne 0x82a1ff14
	if !ctx.cr[0].eq {
	pc = 0x82A1FF14; continue 'dispatch;
	}
	// 82A1FF30: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	pc = 0x82A1FF34; continue 'dispatch;
            }
            0x82A1FF34 => {
    //   block [0x82A1FF34..0x82A1FF6C)
	// 82A1FF34: 7C6000A6  mfmsr r3
	ctx.r[3].u64 = ctx.msr;
	// 82A1FF38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1FF3C: 7C803028  lwarx r4, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[4].u64 = ctx.reserved.u32 as u64;
	// 82A1FF40: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82A1FF44: 7C80312D  stwcx. r4, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[4].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A1FF48: 7C610164  mtmsrd r3, 1
	ctx.msr = (ctx.r[3].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A1FF4C: 4082FFE8  bne 0x82a1ff34
	if !ctx.cr[0].eq {
	pc = 0x82A1FF34; continue 'dispatch;
	}
	// 82A1FF50: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82A1FF54: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82A1FF58: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82A1FF5C: 4B7FF2FD  bl 0x8221f258
	ctx.lr = 0x82A1FF60;
	sub_8221F258(ctx, base);
	// 82A1FF60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A1FF64: 419A0008  beq cr6, 0x82a1ff6c
	if ctx.cr[6].eq {
	pc = 0x82A1FF6C; continue 'dispatch;
	}
	// 82A1FF68: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x82A1FF6C; continue 'dispatch;
            }
            0x82A1FF6C => {
    //   block [0x82A1FF6C..0x82A1FF78)
	// 82A1FF6C: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1FF70: 41820008  beq 0x82a1ff78
	if ctx.cr[0].eq {
	pc = 0x82A1FF78; continue 'dispatch;
	}
	// 82A1FF74: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x82A1FF78; continue 'dispatch;
            }
            0x82A1FF78 => {
    //   block [0x82A1FF78..0x82A1FF84)
	// 82A1FF78: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A1FF7C: 41820008  beq 0x82a1ff84
	if ctx.cr[0].eq {
	pc = 0x82A1FF84; continue 'dispatch;
	}
	// 82A1FF80: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x82A1FF84; continue 'dispatch;
            }
            0x82A1FF84 => {
    //   block [0x82A1FF84..0x82A20070)
	// 82A1FF84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A1FF88: 9BC30015  stb r30, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[30].u8 ) };
	// 82A1FF8C: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A1FF90: 99630014  stb r11, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82A1FF94: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A1FF98: 907F001C  stw r3, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 82A1FF9C: 388AFD00  addi r4, r10, -0x300
	ctx.r[4].s64 = ctx.r[10].s64 + -768;
	// 82A1FFA0: 99630015  stb r11, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[11].u8 ) };
	// 82A1FFA4: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A1FFA8: 91290004  stw r9, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82A1FFAC: 811F001C  lwz r8, 0x1c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A1FFB0: 91080000  stw r8, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82A1FFB4: 80FF001C  lwz r7, 0x1c(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A1FFB8: 90E70008  stw r7, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82A1FFBC: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82A1FFC0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1FFC4: 4B77AABD  bl 0x8219aa80
	ctx.lr = 0x82A1FFC8;
	sub_8219AA80(ctx, base);
	// 82A1FFC8: 3CC0820B  lis r6, -0x7df5
	ctx.r[6].s64 = -2113208320;
	// 82A1FFCC: 38A66C08  addi r5, r6, 0x6c08
	ctx.r[5].s64 = ctx.r[6].s64 + 27656;
	// 82A1FFD0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1FFD4: 3880D8EE  li r4, -0x2712
	ctx.r[4].s64 = -10002;
	// 82A1FFD8: 480046F1  bl 0x82a246c8
	ctx.lr = 0x82A1FFDC;
	sub_82A246C8(ctx, base);
	// 82A1FFDC: 3C8082A2  lis r4, -0x7d5e
	ctx.r[4].s64 = -2103312384;
	// 82A1FFE0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A1FFE4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1FFE8: 3884FD00  addi r4, r4, -0x300
	ctx.r[4].s64 = ctx.r[4].s64 + -768;
	// 82A1FFEC: 4B77AA95  bl 0x8219aa80
	ctx.lr = 0x82A1FFF0;
	sub_8219AA80(ctx, base);
	// 82A1FFF0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A1FFF4: 3880D8EE  li r4, -0x2712
	ctx.r[4].s64 = -10002;
	// 82A1FFF8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A1FFFC: 38AB2AB8  addi r5, r11, 0x2ab8
	ctx.r[5].s64 = ctx.r[11].s64 + 10936;
	// 82A20000: 480046C9  bl 0x82a246c8
	ctx.lr = 0x82A20004;
	sub_82A246C8(ctx, base);
	// 82A20004: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A20008: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A2000C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20010: 388AFD00  addi r4, r10, -0x300
	ctx.r[4].s64 = ctx.r[10].s64 + -768;
	// 82A20014: 4B77AA6D  bl 0x8219aa80
	ctx.lr = 0x82A20018;
	sub_8219AA80(ctx, base);
	// 82A20018: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 82A2001C: 3880D8EE  li r4, -0x2712
	ctx.r[4].s64 = -10002;
	// 82A20020: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20024: 38A92AC0  addi r5, r9, 0x2ac0
	ctx.r[5].s64 = ctx.r[9].s64 + 10944;
	// 82A20028: 480046A1  bl 0x82a246c8
	ctx.lr = 0x82A2002C;
	sub_82A246C8(ctx, base);
	// 82A2002C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A20030: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 82A20034: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A20038: 38E8E9F4  addi r7, r8, -0x160c
	ctx.r[7].s64 = ctx.r[8].s64 + -5644;
	// 82A2003C: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82A20040: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 82A20044: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20048: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A2004C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82A20050: 480009D9  bl 0x82a20a28
	ctx.lr = 0x82A20054;
	sub_82A20A28(ctx, base);
	// 82A20054: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20058: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A2005C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A20060: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A20064: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A20068: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A2006C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A20070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A20070 size=80
    let mut pc: u32 = 0x82A20070;
    'dispatch: loop {
        match pc {
            0x82A20070 => {
    //   block [0x82A20070..0x82A200A8)
	// 82A20070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A20074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A20078: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82A2007C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A20080: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A20084: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A20088: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82A2008C: 48000035  bl 0x82a200c0
	ctx.lr = 0x82A20090;
	sub_82A200C0(ctx, base);
	// 82A20090: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82A20094: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2009C: 419A000C  beq cr6, 0x82a200a8
	if ctx.cr[6].eq {
	pc = 0x82A200A8; continue 'dispatch;
	}
	// 82A200A0: 4B7FBC99  bl 0x8221bd38
	ctx.lr = 0x82A200A4;
	sub_8221BD38(ctx, base);
	// 82A200A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82A200A8; continue 'dispatch;
            }
            0x82A200A8 => {
    //   block [0x82A200A8..0x82A200C0)
	// 82A200A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A200AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A200B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A200B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82A200B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A200BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A200C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A200C0 size=132
    let mut pc: u32 = 0x82A200C0;
    'dispatch: loop {
        match pc {
            0x82A200C0 => {
    //   block [0x82A200C0..0x82A200FC)
	// 82A200C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A200C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82A200C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82A200CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A200D0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A200D4: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82A200D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A200DC: 396BEA00  addi r11, r11, -0x1600
	ctx.r[11].s64 = ctx.r[11].s64 + -5632;
	// 82A200E0: 392A2AE0  addi r9, r10, 0x2ae0
	ctx.r[9].s64 = ctx.r[10].s64 + 10976;
	// 82A200E4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82A200E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A200EC: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A200F0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A200F4: 419A0008  beq cr6, 0x82a200fc
	if ctx.cr[6].eq {
	pc = 0x82A200FC; continue 'dispatch;
	}
	// 82A200F8: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82A200FC; continue 'dispatch;
            }
            0x82A200FC => {
    //   block [0x82A200FC..0x82A20144)
	// 82A200FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82A20100: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82A20104: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82A20108: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82A2010C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A20110: 386AE9F4  addi r3, r10, -0x160c
	ctx.r[3].s64 = ctx.r[10].s64 + -5644;
	// 82A20114: 4800081D  bl 0x82a20930
	ctx.lr = 0x82A20118;
	sub_82A20930(ctx, base);
	// 82A20118: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82A2011C: 4BB3664D  bl 0x82556768
	ctx.lr = 0x82A20120;
	sub_82556768(ctx, base);
	// 82A20120: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 82A20124: 4B7F4CB5  bl 0x82214dd8
	ctx.lr = 0x82A20128;
	sub_82214DD8(ctx, base);
	// 82A20128: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82A2012C: 4B7F4CAD  bl 0x82214dd8
	ctx.lr = 0x82A20130;
	sub_82214DD8(ctx, base);
	// 82A20130: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82A20134: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82A20138: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82A2013C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82A20140: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A20148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A20148 size=576
    let mut pc: u32 = 0x82A20148;
    'dispatch: loop {
        match pc {
            0x82A20148 => {
    //   block [0x82A20148..0x82A201B8)
	// 82A20148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2014C: 482892B5  bl 0x82ca9400
	ctx.lr = 0x82A20150;
	sub_82CA93D0(ctx, base);
	// 82A20150: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A20154: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A20158: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82A2015C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A20160: 549B063E  clrlwi r27, r4, 0x18
	ctx.r[27].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82A20164: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82A20168: 816BE9EC  lwz r11, -0x1614(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5652 as u32) ) } as u64;
	// 82A2016C: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 82A20170: 806B0024  lwz r3, 0x24(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82A20174: 4BFDF1BD  bl 0x829ff330
	ctx.lr = 0x82A20178;
	sub_829FF330(ctx, base);
	// 82A20178: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A2017C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82A20180: 419A0038  beq cr6, 0x82a201b8
	if ctx.cr[6].eq {
	pc = 0x82A201B8; continue 'dispatch;
	}
	// 82A20184: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20188: 3880001D  li r4, 0x1d
	ctx.r[4].s64 = 29;
	// 82A2018C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A20190: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A20194: 4E800421  bctrl
	ctx.lr = 0x82A20198;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A20198: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A2019C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82A201A0: 38800038  li r4, 0x38
	ctx.r[4].s64 = 56;
	// 82A201A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A201A8: 8109001C  lwz r8, 0x1c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 82A201AC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82A201B0: 4E800421  bctrl
	ctx.lr = 0x82A201B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A201B4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
            }
            0x82A201B8 => {
    //   block [0x82A201B8..0x82A20204)
	// 82A201B8: 7F7E0774  extsb r30, r27
	ctx.r[30].s64 = ctx.r[27].s8 as i64;
	// 82A201BC: 2F1E0008  cmpwi cr6, r30, 8
	ctx.cr[6].compare_i32(ctx.r[30].s32, 8, &mut ctx.xer);
	// 82A201C0: 409A0044  bne cr6, 0x82a20204
	if !ctx.cr[6].eq {
	pc = 0x82A20204; continue 'dispatch;
	}
	// 82A201C4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A201C8: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82A201CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A201D0: 419A01B0  beq cr6, 0x82a20380
	if ctx.cr[6].eq {
	pc = 0x82A20380; continue 'dispatch;
	}
	// 82A201D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A201D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A201DC: 409901A4  ble cr6, 0x82a20380
	if !ctx.cr[6].gt {
	pc = 0x82A20380; continue 'dispatch;
	}
	// 82A201E0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A201E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A201E8: 40990198  ble cr6, 0x82a20380
	if !ctx.cr[6].gt {
	pc = 0x82A20380; continue 'dispatch;
	}
	// 82A201EC: 388BFFFF  addi r4, r11, -1
	ctx.r[4].s64 = ctx.r[11].s64 + -1;
	// 82A201F0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A201F4: 909F0010  stw r4, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 82A201F8: 4811DD29  bl 0x82b3df20
	ctx.lr = 0x82A201FC;
	sub_82B3DF20(ctx, base);
	// 82A201FC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A20200: 48289250  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A20204 => {
    //   block [0x82A20204..0x82A20290)
	// 82A20204: 2F1E000D  cmpwi cr6, r30, 0xd
	ctx.cr[6].compare_i32(ctx.r[30].s32, 13, &mut ctx.xer);
	// 82A20208: 419A00A4  beq cr6, 0x82a202ac
	if ctx.cr[6].eq {
	pc = 0x82A202AC; continue 'dispatch;
	}
	// 82A2020C: 2F1E000A  cmpwi cr6, r30, 0xa
	ctx.cr[6].compare_i32(ctx.r[30].s32, 10, &mut ctx.xer);
	// 82A20210: 419A009C  beq cr6, 0x82a202ac
	if ctx.cr[6].eq {
	pc = 0x82A202AC; continue 'dispatch;
	}
	// 82A20214: 5763063E  clrlwi r3, r27, 0x18
	ctx.r[3].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 82A20218: 4828D219  bl 0x82cad430
	ctx.lr = 0x82A2021C;
	sub_82CAD430(ctx, base);
	// 82A2021C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A20220: 419A0160  beq cr6, 0x82a20380
	if ctx.cr[6].eq {
	pc = 0x82A20380; continue 'dispatch;
	}
	// 82A20224: 2F1E0009  cmpwi cr6, r30, 9
	ctx.cr[6].compare_i32(ctx.r[30].s32, 9, &mut ctx.xer);
	// 82A20228: 419A0158  beq cr6, 0x82a20380
	if ctx.cr[6].eq {
	pc = 0x82A20380; continue 'dispatch;
	}
	// 82A2022C: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 82A20230: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A20234: 409A014C  bne cr6, 0x82a20380
	if !ctx.cr[6].eq {
	pc = 0x82A20380; continue 'dispatch;
	}
	// 82A20238: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A2023C: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 82A20240: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 82A20244: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20248: 4B87AF71  bl 0x8229b1b8
	ctx.lr = 0x82A2024C;
	sub_8229B1B8(ctx, base);
	// 82A2024C: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82A20250: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20254: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A20258: 419A0038  beq cr6, 0x82a20290
	if ctx.cr[6].eq {
	pc = 0x82A20290; continue 'dispatch;
	}
	// 82A2025C: 839F0010  lwz r28, 0x10(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A20260: 4811DD21  bl 0x82b3df80
	ctx.lr = 0x82A20264;
	sub_82B3DF80(ctx, base);
	// 82A20264: 9B610050  stb r27, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u8 ) };
	// 82A20268: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82A2026C: 9BA10051  stb r29, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[29].u8 ) };
	// 82A20270: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A20274: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20278: 4811E731  bl 0x82b3e9a8
	ctx.lr = 0x82A2027C;
	sub_82B3E9A8(ctx, base);
	// 82A2027C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A20280: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A20284: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A20288: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A2028C: 482891C4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A20290 => {
    //   block [0x82A20290..0x82A202AC)
	// 82A20290: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A20294: 4B776FDD  bl 0x82197270
	ctx.lr = 0x82A20298;
	sub_82197270(ctx, base);
	// 82A20298: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A2029C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A202A0: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82A202A4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A202A8: 482891A8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A202AC => {
    //   block [0x82A202AC..0x82A202CC)
	// 82A202AC: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82A202B0: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 82A202B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A202B8: 419A00A8  beq cr6, 0x82a20360
	if ctx.cr[6].eq {
	pc = 0x82A20360; continue 'dispatch;
	}
	// 82A202BC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A202C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A202C4: 419A0008  beq cr6, 0x82a202cc
	if ctx.cr[6].eq {
	pc = 0x82A202CC; continue 'dispatch;
	}
	// 82A202C8: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A202CC; continue 'dispatch;
            }
            0x82A202CC => {
    //   block [0x82A202CC..0x82A20360)
	// 82A202CC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A202D0: 80DF0010  lwz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A202D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A202D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A202DC: 4B7C3AB5  bl 0x821e3d90
	ctx.lr = 0x82A202E0;
	sub_821E3D90(ctx, base);
	// 82A202E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A202E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A202E8: 4B7CFF59  bl 0x821f0240
	ctx.lr = 0x82A202EC;
	sub_821F0240(ctx, base);
	// 82A202EC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A202F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A202F4: 388BD400  addi r4, r11, -0x2c00
	ctx.r[4].s64 = ctx.r[11].s64 + -11264;
	// 82A202F8: 4B7BA6C9  bl 0x821da9c0
	ctx.lr = 0x82A202FC;
	sub_821DA9C0(ctx, base);
	// 82A202FC: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82A20300: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A20304: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A20308: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A2030C: 4B7C3A85  bl 0x821e3d90
	ctx.lr = 0x82A20310;
	sub_821E3D90(ctx, base);
	// 82A20310: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82A20314: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A20318: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A2031C: 4B7C2DED  bl 0x821e3108
	ctx.lr = 0x82A20320;
	sub_821E3108(ctx, base);
	// 82A20320: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82A20324: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20328: 4B844E79  bl 0x822651a0
	ctx.lr = 0x82A2032C;
	sub_822651A0(ctx, base);
	// 82A2032C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A20330: 4B7F4AA9  bl 0x82214dd8
	ctx.lr = 0x82A20334;
	sub_82214DD8(ctx, base);
	// 82A20334: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A20338: 4B7F4AA1  bl 0x82214dd8
	ctx.lr = 0x82A2033C;
	sub_82214DD8(ctx, base);
	// 82A2033C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A20340: 4B7F4A99  bl 0x82214dd8
	ctx.lr = 0x82A20344;
	sub_82214DD8(ctx, base);
	// 82A20344: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82A20348: 4B7F4A91  bl 0x82214dd8
	ctx.lr = 0x82A2034C;
	sub_82214DD8(ctx, base);
	// 82A2034C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A20350: 394B0002  addi r10, r11, 2
	ctx.r[10].s64 = ctx.r[11].s64 + 2;
	// 82A20354: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82A20358: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A2035C: 482890F4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A20360 => {
    //   block [0x82A20360..0x82A20380)
	// 82A20360: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20364: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82A20368: 48000021  bl 0x82a20388
	ctx.lr = 0x82A2036C;
	sub_82A20388(ctx, base);
	// 82A2036C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A20370: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20374: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 82A20378: 4B8550C1  bl 0x82275438
	ctx.lr = 0x82A2037C;
	sub_82275438(ctx, base);
	// 82A2037C: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	pc = 0x82A20380; continue 'dispatch;
            }
            0x82A20380 => {
    //   block [0x82A20380..0x82A20388)
	// 82A20380: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A20384: 482890CC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A20388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A20388 size=1028
    let mut pc: u32 = 0x82A20388;
    'dispatch: loop {
        match pc {
            0x82A20388 => {
    //   block [0x82A20388..0x82A2040C)
	// 82A20388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A2038C: 48289075  bl 0x82ca9400
	ctx.lr = 0x82A20390;
	sub_82CA93D0(ctx, base);
	// 82A20390: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A20394: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82A20398: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82A2039C: 3B7E000C  addi r27, r30, 0xc
	ctx.r[27].s64 = ctx.r[30].s64 + 12;
	// 82A203A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A203A4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82A203A8: 4B7CFE99  bl 0x821f0240
	ctx.lr = 0x82A203AC;
	sub_821F0240(ctx, base);
	// 82A203AC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82A203B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A203B4: 388BD400  addi r4, r11, -0x2c00
	ctx.r[4].s64 = ctx.r[11].s64 + -11264;
	// 82A203B8: 4B7BA609  bl 0x821da9c0
	ctx.lr = 0x82A203BC;
	sub_821DA9C0(ctx, base);
	// 82A203BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82A203C0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A203C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A203C8: 4B7C2D41  bl 0x821e3108
	ctx.lr = 0x82A203CC;
	sub_821E3108(ctx, base);
	// 82A203CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82A203D0: 4B7F4A09  bl 0x82214dd8
	ctx.lr = 0x82A203D4;
	sub_82214DD8(ctx, base);
	// 82A203D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82A203D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A203DC: 4B7CFE65  bl 0x821f0240
	ctx.lr = 0x82A203E0;
	sub_821F0240(ctx, base);
	// 82A203E0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82A203E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A203E8: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 82A203EC: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82A203F0: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 82A203F4: 4B7CE7BD  bl 0x821eebb0
	ctx.lr = 0x82A203F8;
	sub_821EEBB0(ctx, base);
	// 82A203F8: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82A203FC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82A20400: 4099003C  ble cr6, 0x82a2043c
	if !ctx.cr[6].gt {
	pc = 0x82A2043C; continue 'dispatch;
	}
	// 82A20404: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A20408: 4B807961  bl 0x82227d68
	ctx.lr = 0x82A2040C;
	sub_82227D68(ctx, base);
	pc = 0x82A2040C; continue 'dispatch;
            }
            0x82A2040C => {
    //   block [0x82A2040C..0x82A20424)
	// 82A2040C: 7D63F8AE  lbzx r11, r3, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82A20410: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82A20414: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 82A20418: 409A000C  bne cr6, 0x82a20424
	if !ctx.cr[6].eq {
	pc = 0x82A20424; continue 'dispatch;
	}
	// 82A2041C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82A20420: 48000010  b 0x82a20430
	pc = 0x82A20430; continue 'dispatch;
            }
            0x82A20424 => {
    //   block [0x82A20424..0x82A20430)
	// 82A20424: 2F0B0029  cmpwi cr6, r11, 0x29
	ctx.cr[6].compare_i32(ctx.r[11].s32, 41, &mut ctx.xer);
	// 82A20428: 409A0008  bne cr6, 0x82a20430
	if !ctx.cr[6].eq {
	pc = 0x82A20430; continue 'dispatch;
	}
	// 82A2042C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	pc = 0x82A20430; continue 'dispatch;
            }
            0x82A20430 => {
    //   block [0x82A20430..0x82A2043C)
	// 82A20430: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82A20434: 7F1F5000  cmpw cr6, r31, r10
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82A20438: 4198FFD4  blt cr6, 0x82a2040c
	if ctx.cr[6].lt {
	pc = 0x82A2040C; continue 'dispatch;
	}
	pc = 0x82A2043C; continue 'dispatch;
            }
            0x82A2043C => {
    //   block [0x82A2043C..0x82A2044C)
	// 82A2043C: 7FFDE051  subf. r31, r29, r28
	ctx.r[31].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A20440: 4081002C  ble 0x82a2046c
	if !ctx.cr[0].gt {
	pc = 0x82A2046C; continue 'dispatch;
	}
	// 82A20444: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A20448: 3BAB4A08  addi r29, r11, 0x4a08
	ctx.r[29].s64 = ctx.r[11].s64 + 18952;
	pc = 0x82A2044C; continue 'dispatch;
            }
            0x82A2044C => {
    //   block [0x82A2044C..0x82A2046C)
	// 82A2044C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A20450: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A20454: 4B7BA56D  bl 0x821da9c0
	ctx.lr = 0x82A20458;
	sub_821DA9C0(ctx, base);
	// 82A20458: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A2045C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A20460: 4B7BA561  bl 0x821da9c0
	ctx.lr = 0x82A20464;
	sub_821DA9C0(ctx, base);
	// 82A20464: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82A20468: 4082FFE4  bne 0x82a2044c
	if !ctx.cr[0].eq {
	pc = 0x82A2044C; continue 'dispatch;
	}
	pc = 0x82A2046C; continue 'dispatch;
            }
            0x82A2046C => {
    //   block [0x82A2046C..0x82A20488)
	// 82A2046C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A20470: 814B6E00  lwz r10, 0x6e00(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28160 as u32) ) } as u64;
	// 82A20474: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A20478: 419A0010  beq cr6, 0x82a20488
	if ctx.cr[6].eq {
	pc = 0x82A20488; continue 'dispatch;
	}
	// 82A2047C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A20480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A20484: 4E800421  bctrl
	ctx.lr = 0x82A20488;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A20488 => {
    //   block [0x82A20488..0x82A204A4)
	// 82A20488: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A2048C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A20490: 409A0014  bne cr6, 0x82a204a4
	if !ctx.cr[6].eq {
	pc = 0x82A204A4; continue 'dispatch;
	}
	// 82A20494: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A20498: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82A2049C: 396BFFDF  addi r11, r11, -0x21
	ctx.r[11].s64 = ctx.r[11].s64 + -33;
	// 82A204A0: 4800000C  b 0x82a204ac
	pc = 0x82A204AC; continue 'dispatch;
            }
            0x82A204A4 => {
    //   block [0x82A204A4..0x82A204AC)
	// 82A204A4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A204A8: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A204AC; continue 'dispatch;
            }
            0x82A204AC => {
    //   block [0x82A204AC..0x82A20544)
	// 82A204AC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A204B0: 3D2082BD  lis r9, -0x7d43
	ctx.r[9].s64 = -2101542912;
	// 82A204B4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A204B8: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82A204BC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A204C0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A204C4: 3889E1F8  addi r4, r9, -0x1e08
	ctx.r[4].s64 = ctx.r[9].s64 + -7688;
	// 82A204C8: 48004409  bl 0x82a248d0
	ctx.lr = 0x82A204CC;
	sub_82A248D0(ctx, base);
	// 82A204CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A204D0: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82A204D4: 409A00FC  bne cr6, 0x82a205d0
	if !ctx.cr[6].eq {
	pc = 0x82A205D0; continue 'dispatch;
	}
	// 82A204D8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A204DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A204E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A204E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A204E8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A204EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A204F0: 4E800421  bctrl
	ctx.lr = 0x82A204F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A204F4: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 82A204F8: 3D0082A2  lis r8, -0x7d5e
	ctx.r[8].s64 = -2103312384;
	// 82A204FC: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82A20500: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A20504: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A20508: 38884808  addi r4, r8, 0x4808
	ctx.r[4].s64 = ctx.r[8].s64 + 18440;
	// 82A2050C: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20514: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A20518: 80DF0020  lwz r6, 0x20(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A2051C: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 82A20520: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A20524: 7CC65850  subf r6, r6, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 82A20528: 4B77A319  bl 0x8219a840
	ctx.lr = 0x82A2052C;
	sub_8219A840(ctx, base);
	// 82A2052C: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A20530: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A20534: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A20538: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82A2053C: 41980008  blt cr6, 0x82a20544
	if ctx.cr[6].lt {
	pc = 0x82A20544; continue 'dispatch;
	}
	// 82A20540: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
            }
            0x82A20544 => {
    //   block [0x82A20544..0x82A205D0)
	// 82A20544: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82A20548: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A2054C: 409A0084  bne cr6, 0x82a205d0
	if !ctx.cr[6].eq {
	pc = 0x82A205D0; continue 'dispatch;
	}
	// 82A20550: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20554: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A20558: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A2055C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A20560: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82A20564: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82A20568: 419A0194  beq cr6, 0x82a206fc
	if ctx.cr[6].eq {
	pc = 0x82A206FC; continue 'dispatch;
	}
	// 82A2056C: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A20570: 3880D8EE  li r4, -0x2712
	ctx.r[4].s64 = -10002;
	// 82A20574: 38AB2AB8  addi r5, r11, 0x2ab8
	ctx.r[5].s64 = ctx.r[11].s64 + 10936;
	// 82A20578: 4B807E11  bl 0x82228388
	ctx.lr = 0x82A2057C;
	sub_82228388(ctx, base);
	// 82A2057C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A20580: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20584: 4B7C5025  bl 0x821e55a8
	ctx.lr = 0x82A20588;
	sub_821E55A8(ctx, base);
	// 82A20588: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2058C: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82A20590: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A20594: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A20598: 388A4808  addi r4, r10, 0x4808
	ctx.r[4].s64 = ctx.r[10].s64 + 18440;
	// 82A2059C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A205A0: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A205A4: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A205A8: 7D264B78  mr r6, r9
	ctx.r[6].u64 = ctx.r[9].u64;
	// 82A205AC: 7D684850  subf r11, r8, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82A205B0: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82A205B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82A205B8: 7D683050  subf r11, r8, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[8].s64;
	// 82A205BC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A205C0: 81430020  lwz r10, 0x20(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A205C4: 7CCA5850  subf r6, r10, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82A205C8: 4B77A279  bl 0x8219a840
	ctx.lr = 0x82A205CC;
	sub_8219A840(ctx, base);
	// 82A205CC: 48000130  b 0x82a206fc
	pc = 0x82A206FC; continue 'dispatch;
            }
            0x82A205D0 => {
    //   block [0x82A205D0..0x82A20600)
	// 82A205D0: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A205D4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A205D8: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 82A205DC: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82A205E0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82A205E4: 419A0040  beq cr6, 0x82a20624
	if ctx.cr[6].eq {
	pc = 0x82A20624; continue 'dispatch;
	}
	// 82A205E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A205EC: 4B87E76D  bl 0x8229ed58
	ctx.lr = 0x82A205F0;
	sub_8229ED58(ctx, base);
	// 82A205F0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A205F4: 409A000C  bne cr6, 0x82a20600
	if !ctx.cr[6].eq {
	pc = 0x82A20600; continue 'dispatch;
	}
	// 82A205F8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82A205FC: 48000030  b 0x82a2062c
	pc = 0x82A2062C; continue 'dispatch;
            }
            0x82A20600 => {
    //   block [0x82A20600..0x82A2061C)
	// 82A20600: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82A20604: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82A20608: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82A2060C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82A20610: 4198000C  blt cr6, 0x82a2061c
	if ctx.cr[6].lt {
	pc = 0x82A2061C; continue 'dispatch;
	}
	// 82A20614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82A20618: 4B758F69  bl 0x82179580
	ctx.lr = 0x82A2061C;
	sub_82179580(ctx, base);
	pc = 0x82A2061C; continue 'dispatch;
            }
            0x82A2061C => {
    //   block [0x82A2061C..0x82A20624)
	// 82A2061C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A20620: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	pc = 0x82A20624; continue 'dispatch;
            }
            0x82A20624 => {
    //   block [0x82A20624..0x82A2062C)
	// 82A20624: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20628: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	pc = 0x82A2062C; continue 'dispatch;
            }
            0x82A2062C => {
    //   block [0x82A2062C..0x82A2064C)
	// 82A2062C: 2F1D0003  cmpwi cr6, r29, 3
	ctx.cr[6].compare_i32(ctx.r[29].s32, 3, &mut ctx.xer);
	// 82A20630: 409A001C  bne cr6, 0x82a2064c
	if !ctx.cr[6].eq {
	pc = 0x82A2064C; continue 'dispatch;
	}
	// 82A20634: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 82A20638: 388B2AD0  addi r4, r11, 0x2ad0
	ctx.r[4].s64 = ctx.r[11].s64 + 10960;
	// 82A2063C: 4B7C618D  bl 0x821e67c8
	ctx.lr = 0x82A20640;
	sub_821E67C8(ctx, base);
	// 82A20640: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A20644: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82A20648: 409A0008  bne cr6, 0x82a20650
	if !ctx.cr[6].eq {
	pc = 0x82A20650; continue 'dispatch;
	}
	pc = 0x82A2064C; continue 'dispatch;
            }
            0x82A2064C => {
    //   block [0x82A2064C..0x82A20650)
	// 82A2064C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82A20650; continue 'dispatch;
            }
            0x82A20650 => {
    //   block [0x82A20650..0x82A20698)
	// 82A20650: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82A20654: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A20658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A2065C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20660: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82A20664: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A20668: 419A0030  beq cr6, 0x82a20698
	if ctx.cr[6].eq {
	pc = 0x82A20698; continue 'dispatch;
	}
	// 82A2066C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82A20670: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A20674: 4E800421  bctrl
	ctx.lr = 0x82A20678;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A20678: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82A2067C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A20680: 4B844B21  bl 0x822651a0
	ctx.lr = 0x82A20684;
	sub_822651A0(ctx, base);
	// 82A20684: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20688: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A2068C: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 82A20690: 91090008  stw r8, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82A20694: 48000078  b 0x82a2070c
	pc = 0x82A2070C; continue 'dispatch;
            }
            0x82A20698 => {
    //   block [0x82A20698..0x82A206FC)
	// 82A20698: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A2069C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82A206A0: 4E800421  bctrl
	ctx.lr = 0x82A206A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82A206A4: 3D20820F  lis r9, -0x7df1
	ctx.r[9].s64 = -2112946176;
	// 82A206A8: 3880D8EE  li r4, -0x2712
	ctx.r[4].s64 = -10002;
	// 82A206AC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A206B0: 38A92AB8  addi r5, r9, 0x2ab8
	ctx.r[5].s64 = ctx.r[9].s64 + 10936;
	// 82A206B4: 4B807CD5  bl 0x82228388
	ctx.lr = 0x82A206B8;
	sub_82228388(ctx, base);
	// 82A206B8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A206BC: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82A206C0: 38E89700  addi r7, r8, -0x6900
	ctx.r[7].s64 = ctx.r[8].s64 + -26880;
	// 82A206C4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A206C8: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 82A206CC: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82A206D0: 419A002C  beq cr6, 0x82a206fc
	if ctx.cr[6].eq {
	pc = 0x82A206FC; continue 'dispatch;
	}
	// 82A206D4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A206D8: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82A206DC: 409A0020  bne cr6, 0x82a206fc
	if !ctx.cr[6].eq {
	pc = 0x82A206FC; continue 'dispatch;
	}
	// 82A206E0: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 82A206E4: 4B7C4EC5  bl 0x821e55a8
	ctx.lr = 0x82A206E8;
	sub_821E55A8(ctx, base);
	// 82A206E8: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A206EC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82A206F0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A206F4: 388BFFF0  addi r4, r11, -0x10
	ctx.r[4].s64 = ctx.r[11].s64 + -16;
	// 82A206F8: 4B808479  bl 0x82228b70
	ctx.lr = 0x82A206FC;
	sub_82228B70(ctx, base);
            }
            0x82A206FC => {
    //   block [0x82A206FC..0x82A2070C)
	// 82A206FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82A20700: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82A20704: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 82A20708: 4B854D31  bl 0x82275438
	ctx.lr = 0x82A2070C;
	sub_82275438(ctx, base);
	pc = 0x82A2070C; continue 'dispatch;
            }
            0x82A2070C => {
    //   block [0x82A2070C..0x82A20728)
	// 82A2070C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A20710: 814B6E04  lwz r10, 0x6e04(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28164 as u32) ) } as u64;
	// 82A20714: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82A20718: 419A0010  beq cr6, 0x82a20728
	if ctx.cr[6].eq {
	pc = 0x82A20728; continue 'dispatch;
	}
	// 82A2071C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A20720: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82A20724: 4E800421  bctrl
	ctx.lr = 0x82A20728;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82A20728 => {
    //   block [0x82A20728..0x82A2073C)
	// 82A20728: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2072C: 4B7A603D  bl 0x821c6768
	ctx.lr = 0x82A20730;
	sub_821C6768(ctx, base);
	// 82A20730: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82A20734: 3BEB7088  addi r31, r11, 0x7088
	ctx.r[31].s64 = ctx.r[11].s64 + 28808;
	// 82A20738: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	pc = 0x82A2073C; continue 'dispatch;
            }
            0x82A2073C => {
    //   block [0x82A2073C..0x82A20764)
	// 82A2073C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82A20740: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A20744: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82A20748: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82A2074C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A20750: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A20754: 4082FFE8  bne 0x82a2073c
	if !ctx.cr[0].eq {
	pc = 0x82A2073C; continue 'dispatch;
	}
	// 82A20758: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 82A2075C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82A20760: 4B7A6009  bl 0x821c6768
	ctx.lr = 0x82A20764;
	sub_821C6768(ctx, base);
	pc = 0x82A20764; continue 'dispatch;
            }
            0x82A20764 => {
    //   block [0x82A20764..0x82A2078C)
	// 82A20764: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 82A20768: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2076C: 7CE0F828  lwarx r7, 0, r31
	// lwarx
	let ea = ctx.r[31].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 82A20770: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 82A20774: 7CE0F92D  stwcx. r7, 0, r31
	// stwcx.
	let addr = ctx.r[31].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82A20778: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82A2077C: 4082FFE8  bne 0x82a20764
	if !ctx.cr[0].eq {
	pc = 0x82A20764; continue 'dispatch;
	}
	// 82A20780: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A20784: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82A20788: 48288CC8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A20790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82A20790 size=412
    let mut pc: u32 = 0x82A20790;
    'dispatch: loop {
        match pc {
            0x82A20790 => {
    //   block [0x82A20790..0x82A207F8)
	// 82A20790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A20794: 48288C75  bl 0x82ca9408
	ctx.lr = 0x82A20798;
	sub_82CA93D0(ctx, base);
	// 82A20798: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2079C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A207A0: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 82A207A4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82A207A8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82A207AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82A207B0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A207B4: 388A2AC8  addi r4, r10, 0x2ac8
	ctx.r[4].s64 = ctx.r[10].s64 + 10952;
	// 82A207B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A207BC: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A207C0: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A207C4: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 82A207C8: 7CFD1E70  srawi r29, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[7].s32 >> 3) as i64;
	// 82A207CC: 4B80C705  bl 0x8222ced0
	ctx.lr = 0x82A207D0;
	sub_8222CED0(ctx, base);
	// 82A207D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82A207D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A207D8: 4B7CC021  bl 0x821ec7f8
	ctx.lr = 0x82A207DC;
	sub_821EC7F8(ctx, base);
	// 82A207DC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A207E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A207E4: 409A0014  bne cr6, 0x82a207f8
	if !ctx.cr[6].eq {
	pc = 0x82A207F8; continue 'dispatch;
	}
	// 82A207E8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 82A207EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A207F0: 38CBFFDF  addi r6, r11, -0x21
	ctx.r[6].s64 = ctx.r[11].s64 + -33;
	// 82A207F4: 4800000C  b 0x82a20800
	pc = 0x82A20800; continue 'dispatch;
            }
            0x82A207F8 => {
    //   block [0x82A207F8..0x82A20800)
	// 82A207F8: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A207FC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82A20800; continue 'dispatch;
            }
            0x82A20800 => {
    //   block [0x82A20800..0x82A20878)
	// 82A20800: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82A20804: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82A20808: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A2080C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20810: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A20814: 3D6082BD  lis r11, -0x7d43
	ctx.r[11].s64 = -2101542912;
	// 82A20818: 388BE1F8  addi r4, r11, -0x1e08
	ctx.r[4].s64 = ctx.r[11].s64 + -7688;
	// 82A2081C: 480040B5  bl 0x82a248d0
	ctx.lr = 0x82A20820;
	sub_82A248D0(ctx, base);
	// 82A20820: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A20824: 409A00DC  bne cr6, 0x82a20900
	if !ctx.cr[6].eq {
	pc = 0x82A20900; continue 'dispatch;
	}
	// 82A20828: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2082C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82A20830: 3D4082A2  lis r10, -0x7d5e
	ctx.r[10].s64 = -2103312384;
	// 82A20834: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82A20838: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82A2083C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82A20840: 388A4808  addi r4, r10, 0x4808
	ctx.r[4].s64 = ctx.r[10].s64 + 18440;
	// 82A20844: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A20848: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82A2084C: 813C0020  lwz r9, 0x20(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 82A20850: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 82A20854: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82A20858: 7CC95850  subf r6, r9, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82A2085C: 4B779FE5  bl 0x8219a840
	ctx.lr = 0x82A20860;
	sub_8219A840(ctx, base);
	// 82A20860: 815C0014  lwz r10, 0x14(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82A20864: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A20868: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A2086C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A20870: 41980008  blt cr6, 0x82a20878
	if ctx.cr[6].lt {
	pc = 0x82A20878; continue 'dispatch;
	}
	// 82A20874: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82A20878; continue 'dispatch;
            }
            0x82A20878 => {
    //   block [0x82A20878..0x82A208B4)
	// 82A20878: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82A2087C: 409A0084  bne cr6, 0x82a20900
	if !ctx.cr[6].eq {
	pc = 0x82A20900; continue 'dispatch;
	}
	// 82A20880: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20884: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A20888: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82A2088C: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82A20890: 55070038  rlwinm r7, r8, 0, 0, 0x1c
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 82A20894: 2F070008  cmpwi cr6, r7, 8
	ctx.cr[6].compare_i32(ctx.r[7].s32, 8, &mut ctx.xer);
	// 82A20898: 41980068  blt cr6, 0x82a20900
	if ctx.cr[6].lt {
	pc = 0x82A20900; continue 'dispatch;
	}
	// 82A2089C: 5523003E  slwi r3, r9, 0
	ctx.r[3].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82A208A0: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A208A4: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82A208A8: 4198000C  blt cr6, 0x82a208b4
	if ctx.cr[6].lt {
	pc = 0x82A208B4; continue 'dispatch;
	}
	// 82A208AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A208B0: 386B9700  addi r3, r11, -0x6900
	ctx.r[3].s64 = ctx.r[11].s64 + -26880;
	pc = 0x82A208B4; continue 'dispatch;
            }
            0x82A208B4 => {
    //   block [0x82A208B4..0x82A208D0)
	// 82A208B4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A208B8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82A208BC: 419A0014  beq cr6, 0x82a208d0
	if ctx.cr[6].eq {
	pc = 0x82A208D0; continue 'dispatch;
	}
	// 82A208C0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82A208C4: 4B80CC75  bl 0x8222d538
	ctx.lr = 0x82A208C8;
	sub_8222D538(ctx, base);
	// 82A208C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82A208CC: 419A0034  beq cr6, 0x82a20900
	if ctx.cr[6].eq {
	pc = 0x82A20900; continue 'dispatch;
	}
	pc = 0x82A208D0; continue 'dispatch;
            }
            0x82A208D0 => {
    //   block [0x82A208D0..0x82A20900)
	// 82A208D0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82A208D4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A208D8: 4B807121  bl 0x822279f8
	ctx.lr = 0x82A208DC;
	sub_822279F8(ctx, base);
	// 82A208DC: D03E0000  stfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A208E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A208E4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A208E8: 481AB421  bl 0x82bcbd08
	ctx.lr = 0x82A208EC;
	sub_82BCBD08(ctx, base);
	// 82A208EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A208F0: 4B7F44E9  bl 0x82214dd8
	ctx.lr = 0x82A208F4;
	sub_82214DD8(ctx, base);
	// 82A208F4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82A208F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A208FC: 48288B5C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82A20900 => {
    //   block [0x82A20900..0x82A2092C)
	// 82A20900: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A20904: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20908: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82A2090C: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82A20910: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82A20914: 481AB3F5  bl 0x82bcbd08
	ctx.lr = 0x82A20918;
	sub_82BCBD08(ctx, base);
	// 82A20918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A2091C: 4B7F44BD  bl 0x82214dd8
	ctx.lr = 0x82A20920;
	sub_82214DD8(ctx, base);
	// 82A20920: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82A20924: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82A20928: 48288B30  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A20930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A20930 size=244
    let mut pc: u32 = 0x82A20930;
    'dispatch: loop {
        match pc {
            0x82A20930 => {
    //   block [0x82A20930..0x82A2095C)
	// 82A20930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A20934: 48288AD9  bl 0x82ca940c
	ctx.lr = 0x82A20938;
	sub_82CA93D0(ctx, base);
	// 82A20938: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A2093C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A20940: 83C40000  lwz r30, 0(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20944: 3BEBE9F4  addi r31, r11, -0x160c
	ctx.r[31].s64 = ctx.r[11].s64 + -5644;
	// 82A20948: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 82A2094C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82A20950: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20954: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 82A20958: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82A2095C; continue 'dispatch;
            }
            0x82A2095C => {
    //   block [0x82A2095C..0x82A20960)
	// 82A2095C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x82A20960; continue 'dispatch;
            }
            0x82A20960 => {
    //   block [0x82A20960..0x82A20970)
	// 82A20960: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A20964: 419A000C  beq cr6, 0x82a20970
	if ctx.cr[6].eq {
	pc = 0x82A20970; continue 'dispatch;
	}
	// 82A20968: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82A2096C: 419A0008  beq cr6, 0x82a20974
	if ctx.cr[6].eq {
	pc = 0x82A20974; continue 'dispatch;
	}
	pc = 0x82A20970; continue 'dispatch;
            }
            0x82A20970 => {
    //   block [0x82A20970..0x82A20974)
	// 82A20970: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A20974; continue 'dispatch;
            }
            0x82A20974 => {
    //   block [0x82A20974..0x82A20988)
	// 82A20974: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82A20978: 419A00A4  beq cr6, 0x82a20a1c
	if ctx.cr[6].eq {
	pc = 0x82A20A1C; continue 'dispatch;
	}
	// 82A2097C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82A20980: 409A0008  bne cr6, 0x82a20988
	if !ctx.cr[6].eq {
	pc = 0x82A20988; continue 'dispatch;
	}
	// 82A20984: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A20988; continue 'dispatch;
            }
            0x82A20988 => {
    //   block [0x82A20988..0x82A20998)
	// 82A20988: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A2098C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A20990: 409A0008  bne cr6, 0x82a20998
	if !ctx.cr[6].eq {
	pc = 0x82A20998; continue 'dispatch;
	}
	// 82A20994: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A20998; continue 'dispatch;
            }
            0x82A20998 => {
    //   block [0x82A20998..0x82A209B8)
	// 82A20998: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A2099C: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82A209A0: 409A0068  bne cr6, 0x82a20a08
	if !ctx.cr[6].eq {
	pc = 0x82A20A08; continue 'dispatch;
	}
	// 82A209A4: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A209A8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A209AC: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82A209B0: 409A0008  bne cr6, 0x82a209b8
	if !ctx.cr[6].eq {
	pc = 0x82A209B8; continue 'dispatch;
	}
	// 82A209B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A209B8; continue 'dispatch;
            }
            0x82A209B8 => {
    //   block [0x82A209B8..0x82A209F4)
	// 82A209B8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A209BC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82A209C0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82A209C4: 419A0030  beq cr6, 0x82a209f4
	if ctx.cr[6].eq {
	pc = 0x82A209F4; continue 'dispatch;
	}
	// 82A209C8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A209CC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82A209D0: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82A209D4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A209D8: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A209DC: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82A209E0: 4B7FB359  bl 0x8221bd38
	ctx.lr = 0x82A209E4;
	sub_8221BD38(ctx, base);
	// 82A209E4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A209E8: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A209EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82A209F0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82A209F4; continue 'dispatch;
            }
            0x82A209F4 => {
    //   block [0x82A209F4..0x82A20A08)
	// 82A209F4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82A209F8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82A209FC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82A20A00: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82A20A04: 4BFFFF5C  b 0x82a20960
	pc = 0x82A20960; continue 'dispatch;
            }
            0x82A20A08 => {
    //   block [0x82A20A08..0x82A20A14)
	// 82A20A08: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A20A0C: 409A0008  bne cr6, 0x82a20a14
	if !ctx.cr[6].eq {
	pc = 0x82A20A14; continue 'dispatch;
	}
	// 82A20A10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82A20A14; continue 'dispatch;
            }
            0x82A20A14 => {
    //   block [0x82A20A14..0x82A20A1C)
	// 82A20A14: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20A18: 4BFFFF44  b 0x82a2095c
	pc = 0x82A2095C; continue 'dispatch;
            }
            0x82A20A1C => {
    //   block [0x82A20A1C..0x82A20A24)
	// 82A20A1C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82A20A20: 48288A3C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A20A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82A20A28 size=216
    let mut pc: u32 = 0x82A20A28;
    'dispatch: loop {
        match pc {
            0x82A20A28 => {
    //   block [0x82A20A28..0x82A20A5C)
	// 82A20A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82A20A2C: 482889D9  bl 0x82ca9404
	ctx.lr = 0x82A20A30;
	sub_82CA93D0(ctx, base);
	// 82A20A30: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82A20A34: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 82A20A38: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82A20A3C: 838100EC  lwz r28, 0xec(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 82A20A40: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82A20A44: 83DC0004  lwz r30, 4(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20A48: 4B7FE811  bl 0x8221f258
	ctx.lr = 0x82A20A4C;
	sub_8221F258(ctx, base);
	// 82A20A4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82A20A50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82A20A54: 419A0008  beq cr6, 0x82a20a5c
	if ctx.cr[6].eq {
	pc = 0x82A20A5C; continue 'dispatch;
	}
	// 82A20A58: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82A20A5C; continue 'dispatch;
            }
            0x82A20A5C => {
    //   block [0x82A20A5C..0x82A20A6C)
	// 82A20A5C: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 82A20A60: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82A20A64: 419A0008  beq cr6, 0x82a20a6c
	if ctx.cr[6].eq {
	pc = 0x82A20A6C; continue 'dispatch;
	}
	// 82A20A68: 93DD0000  stw r30, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x82A20A6C; continue 'dispatch;
            }
            0x82A20A6C => {
    //   block [0x82A20A6C..0x82A20A7C)
	// 82A20A6C: 357F0008  addic. r11, r31, 8
	ctx.xer.ca = (ctx.r[31].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82A20A70: 4182000C  beq 0x82a20a7c
	if ctx.cr[0].eq {
	pc = 0x82A20A7C; continue 'dispatch;
	}
	// 82A20A74: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20A78: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82A20A7C; continue 'dispatch;
            }
            0x82A20A7C => {
    //   block [0x82A20A7C..0x82A20AE4)
	// 82A20A7C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82A20A80: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 82A20A84: 3BCBE9F4  addi r30, r11, -0x160c
	ctx.r[30].s64 = ctx.r[11].s64 + -5644;
	// 82A20A88: 6149FFFF  ori r9, r10, 0xffff
	ctx.r[9].u64 = ctx.r[10].u64 | 65535;
	// 82A20A8C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A20A90: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82A20A94: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 82A20A98: 4098004C  bge cr6, 0x82a20ae4
	if !ctx.cr[6].lt {
	pc = 0x82A20AE4; continue 'dispatch;
	}
	// 82A20A9C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82A20AA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A20AA4: 388B2D94  addi r4, r11, 0x2d94
	ctx.r[4].s64 = ctx.r[11].s64 + 11668;
	// 82A20AA8: 4B8D1499  bl 0x822f1f40
	ctx.lr = 0x82A20AAC;
	sub_822F1F40(ctx, base);
	// 82A20AAC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82A20AB0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A20AB4: 4B8D12FD  bl 0x822f1db0
	ctx.lr = 0x82A20AB8;
	sub_822F1DB0(ctx, base);
	// 82A20AB8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82A20ABC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A20AC0: 3B6A1720  addi r27, r10, 0x1720
	ctx.r[27].s64 = ctx.r[10].s64 + 5920;
	// 82A20AC4: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82A20AC8: 4B8D1359  bl 0x822f1e20
	ctx.lr = 0x82A20ACC;
	sub_822F1E20(ctx, base);
	// 82A20ACC: 93610070  stw r27, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 82A20AD0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82A20AD4: 4BC5AD0D  bl 0x8267b7e0
	ctx.lr = 0x82A20AD8;
	sub_8267B7E0(ctx, base);
	// 82A20AD8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82A20ADC: 4B750D35  bl 0x82171810
	ctx.lr = 0x82A20AE0;
	sub_82171810(ctx, base);
	// 82A20AE0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82A20AE4; continue 'dispatch;
            }
            0x82A20AE4 => {
    //   block [0x82A20AE4..0x82A20B00)
	// 82A20AE4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A20AE8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A20AEC: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82A20AF0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20AF4: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82A20AF8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82A20AFC: 48288958  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A20B00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A20B00 size=60
    let mut pc: u32 = 0x82A20B00;
    'dispatch: loop {
        match pc {
            0x82A20B00 => {
    //   block [0x82A20B00..0x82A20B3C)
	// 82A20B00: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82A20B04: 409A0050  bne cr6, 0x82a20b54
	if !ctx.cr[6].eq {
		sub_82A20B54(ctx, base);
		return;
	}
	// 82A20B08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20B0C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82A20B10: 91450004  stw r10, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82A20B14: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A20B18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20B1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A20B20: 419A001C  beq cr6, 0x82a20b3c
	if ctx.cr[6].eq {
		sub_82A20B3C(ctx, base);
		return;
	}
	// 82A20B24: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82A20B28: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A20B2C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A20B30: 90A30000  stw r5, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82A20B34: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A20B38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A20B3C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A20B3C size=24
    let mut pc: u32 = 0x82A20B3C;
    'dispatch: loop {
        match pc {
            0x82A20B3C => {
    //   block [0x82A20B3C..0x82A20B54)
	// 82A20B3C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A20B40: 90A30000  stw r5, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82A20B44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A20B48: 90A30004  stw r5, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82A20B4C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A20B50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82A20B54(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82A20B54 size=68
    let mut pc: u32 = 0x82A20B54;
    'dispatch: loop {
        match pc {
            0x82A20B54 => {
    //   block [0x82A20B54..0x82A20B70)
	// 82A20B54: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82A20B58: 90850004  stw r4, 4(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82A20B5C: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82A20B60: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82A20B64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82A20B68: 419A0008  beq cr6, 0x82a20b70
	if ctx.cr[6].eq {
	pc = 0x82A20B70; continue 'dispatch;
	}
	// 82A20B6C: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	pc = 0x82A20B70; continue 'dispatch;
            }
            0x82A20B70 => {
    //   block [0x82A20B70..0x82A20B88)
	// 82A20B70: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20B74: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82A20B78: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82A20B7C: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82A20B80: 409A0008  bne cr6, 0x82a20b88
	if !ctx.cr[6].eq {
	pc = 0x82A20B88; continue 'dispatch;
	}
	// 82A20B84: 90A30004  stw r5, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	pc = 0x82A20B88; continue 'dispatch;
            }
            0x82A20B88 => {
    //   block [0x82A20B88..0x82A20B98)
	// 82A20B88: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82A20B8C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82A20B90: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82A20B94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


