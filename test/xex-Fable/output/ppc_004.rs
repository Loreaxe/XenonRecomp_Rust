pub fn sub_821D5F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D5F08 size=60
    let mut pc: u32 = 0x821D5F08;
    'dispatch: loop {
        match pc {
            0x821D5F08 => {
    //   block [0x821D5F08..0x821D5F44)
	// 821D5F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D5F0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D5F10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D5F14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D5F18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D5F1C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 821D5F20: 480218E1  bl 0x821f7800
	ctx.lr = 0x821D5F24;
	sub_821F7800(ctx, base);
	// 821D5F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D5F28: 4809F459  bl 0x82275380
	ctx.lr = 0x821D5F2C;
	sub_82275380(ctx, base);
	// 821D5F2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D5F30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821D5F34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D5F38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D5F3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D5F40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D5F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D5F48 size=112
    let mut pc: u32 = 0x821D5F48;
    'dispatch: loop {
        match pc {
            0x821D5F48 => {
    //   block [0x821D5F48..0x821D5F94)
	// 821D5F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D5F4C: 48AD34B9  bl 0x82ca9404
	ctx.lr = 0x821D5F50;
	sub_82CA93D0(ctx, base);
	// 821D5F50: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D5F54: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 821D5F58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D5F5C: 3BCB4BD8  addi r30, r11, 0x4bd8
	ctx.r[30].s64 = ctx.r[11].s64 + 19416;
	// 821D5F60: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821D5F64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821D5F68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D5F6C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821D5F70: 48068A01  bl 0x8223e970
	ctx.lr = 0x821D5F74;
	sub_8223E970(ctx, base);
	// 821D5F74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D5F78: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821D5F7C: 419A0018  beq cr6, 0x821d5f94
	if ctx.cr[6].eq {
	pc = 0x821D5F94; continue 'dispatch;
	}
	// 821D5F80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D5F84: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 821D5F88: 394B1198  addi r10, r11, 0x1198
	ctx.r[10].s64 = ctx.r[11].s64 + 4504;
	// 821D5F8C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821D5F90: 4BFFFF79  bl 0x821d5f08
	ctx.lr = 0x821D5F94;
	sub_821D5F08(ctx, base);
	pc = 0x821D5F94; continue 'dispatch;
            }
            0x821D5F94 => {
    //   block [0x821D5F94..0x821D5FB8)
	// 821D5F94: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821D5F98: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821D5F9C: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 821D5FA0: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 821D5FA4: 4BFFF345  bl 0x821d52e8
	ctx.lr = 0x821D5FA8;
	sub_821D52E8(ctx, base);
	// 821D5FA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D5FAC: 4806888D  bl 0x8223e838
	ctx.lr = 0x821D5FB0;
	sub_8223E838(ctx, base);
	// 821D5FB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D5FB4: 48AD34A0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D5FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D5FB8 size=192
    let mut pc: u32 = 0x821D5FB8;
    'dispatch: loop {
        match pc {
            0x821D5FB8 => {
    //   block [0x821D5FB8..0x821D600C)
	// 821D5FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D5FBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D5FC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D5FC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D5FC8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D5FCC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821D5FD0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D5FD4: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D5FD8: 556A0630  rlwinm r10, r11, 0, 0x18, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D5FDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D5FE0: 419A004C  beq cr6, 0x821d602c
	if ctx.cr[6].eq {
	pc = 0x821D602C; continue 'dispatch;
	}
	// 821D5FE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D5FE8: 48000091  bl 0x821d6078
	ctx.lr = 0x821D5FEC;
	sub_821D6078(ctx, base);
	// 821D5FEC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821D5FF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D5FF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821D5FF8: 48009111  bl 0x821df108
	ctx.lr = 0x821D5FFC;
	sub_821DF108(ctx, base);
	// 821D5FFC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821D6000: 395F00EC  addi r10, r31, 0xec
	ctx.r[10].s64 = ctx.r[31].s64 + 236;
	// 821D6004: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 821D6008: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821D600C; continue 'dispatch;
            }
            0x821D600C => {
    //   block [0x821D600C..0x821D602C)
	// 821D600C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D6010: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821D6014: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D6018: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821D601C: 4200FFF0  bdnz 0x821d600c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821D600C; continue 'dispatch;
	}
	// 821D6020: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D6024: 556A066E  rlwinm r10, r11, 0, 0x19, 0x17
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D6028: 915F0048  stw r10, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	pc = 0x821D602C; continue 'dispatch;
            }
            0x821D602C => {
    //   block [0x821D602C..0x821D6078)
	// 821D602C: C01F00EC  lfs f0, 0xec(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D6030: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D6034: C1BF00F0  lfs f13, 0xf0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D6038: C19F00F4  lfs f12, 0xf4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(244 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821D603C: C17F00F8  lfs f11, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821D6040: C15F00FC  lfs f10, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821D6044: C13F0100  lfs f9, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821D6048: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821D604C: D1BE0004  stfs f13, 4(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821D6050: D19E0008  stfs f12, 8(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821D6054: D17E000C  stfs f11, 0xc(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821D6058: D15E0010  stfs f10, 0x10(r30)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821D605C: D13E0014  stfs f9, 0x14(r30)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821D6060: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821D6064: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D6068: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D606C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D6070: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D6074: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D6078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D6078 size=380
    let mut pc: u32 = 0x821D6078;
    'dispatch: loop {
        match pc {
            0x821D6078 => {
    //   block [0x821D6078..0x821D60BC)
	// 821D6078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D607C: 48AD3391  bl 0x82ca940c
	ctx.lr = 0x821D6080;
	sub_82CA93D0(ctx, base);
	// 821D6080: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D6084: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821D6088: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D608C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D6090: 556A05EE  rlwinm r10, r11, 0, 0x17, 0x17
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D6094: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D6098: 419A0130  beq cr6, 0x821d61c8
	if ctx.cr[6].eq {
	pc = 0x821D61C8; continue 'dispatch;
	}
	// 821D609C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D60A0: 480A2229  bl 0x822782c8
	ctx.lr = 0x821D60A4;
	sub_822782C8(ctx, base);
	// 821D60A4: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 821D60A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D60AC: 409A0010  bne cr6, 0x821d60bc
	if !ctx.cr[6].eq {
	pc = 0x821D60BC; continue 'dispatch;
	}
	// 821D60B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D60B4: 3BCB9218  addi r30, r11, -0x6de8
	ctx.r[30].s64 = ctx.r[11].s64 + -28136;
	// 821D60B8: 48000008  b 0x821d60c0
	pc = 0x821D60C0; continue 'dispatch;
            }
            0x821D60BC => {
    //   block [0x821D60BC..0x821D60C0)
	// 821D60BC: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821D60C0; continue 'dispatch;
            }
            0x821D60C0 => {
    //   block [0x821D60C0..0x821D61C8)
	// 821D60C0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821D60C4: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821D60C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D60CC: 38AA803C  addi r5, r10, -0x7fc4
	ctx.r[5].s64 = ctx.r[10].s64 + -32708;
	// 821D60D0: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821D60D4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D60D8: 80890060  lwz r4, 0x60(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(96 as u32) ) } as u64;
	// 821D60DC: 4801FBE5  bl 0x821f5cc0
	ctx.lr = 0x821D60E0;
	sub_821F5CC0(ctx, base);
	// 821D60E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D60E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821D60E8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821D60EC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821D60F0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821D60F4: 4899B3AD  bl 0x82b714a0
	ctx.lr = 0x821D60F8;
	sub_82B714A0(ctx, base);
	// 821D60F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D60FC: 4805BBBD  bl 0x82231cb8
	ctx.lr = 0x821D6100;
	sub_82231CB8(ctx, base);
	// 821D6100: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D6104: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D6108: 48101FE1  bl 0x822d80e8
	ctx.lr = 0x821D610C;
	sub_822D80E8(ctx, base);
	// 821D610C: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821D6110: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D6114: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821D6118: 7D0707B4  extsw r7, r8
	ctx.r[7].s64 = ctx.r[8].s32 as i64;
	// 821D611C: C1A10070  lfs f13, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D6120: ECA0682A  fadds f5, f0, f13
	ctx.f[5].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821D6124: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 821D6128: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D612C: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 821D6130: D0A10050  stfs f5, 0x50(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821D6134: FC805818  frsp f4, f11
	ctx.f[4].f64 = (ctx.f[11].f64 as f32) as f64;
	// 821D6138: 48101FB1  bl 0x822d80e8
	ctx.lr = 0x821D613C;
	sub_822D80E8(ctx, base);
	// 821D613C: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 821D6140: C0630004  lfs f3, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821D6144: 80C10058  lwz r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821D6148: C0410074  lfs f2, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821D614C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821D6150: D0A10060  stfs f5, 0x60(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821D6154: 7CC307B4  extsw r3, r6
	ctx.r[3].s64 = ctx.r[6].s32 as i64;
	// 821D6158: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D615C: C00592D4  lfs f0, -0x6d2c(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D6160: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 821D6164: EDA40032  fmuls f13, f4, f0
	ctx.f[13].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	// 821D6168: C8210058  lfd f1, 0x58(r1)
	ctx.f[1].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821D616C: FD600E9C  fcfid f11, f1
	ctx.f[11].f64 = (ctx.f[1].s64 as f64);
	// 821D6170: 556A062C  rlwinm r10, r11, 0, 0x18, 0x16
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821D6174: ED836838  fmsubs f12, f3, f0, f13
	ctx.f[12].f64 = (((ctx.f[3].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821D6178: 915F0048  stw r10, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[10].u32 ) };
	// 821D617C: FD005818  frsp f8, f11
	ctx.f[8].f64 = (ctx.f[11].f64 as f32) as f64;
	// 821D6180: EC0C102A  fadds f0, f12, f2
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[2].f64) as f32) as f64;
	// 821D6184: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821D6188: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D618C: ECE8282A  fadds f7, f8, f5
	ctx.f[7].f64 = ((ctx.f[8].f64 + ctx.f[5].f64) as f32) as f64;
	// 821D6190: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 821D6194: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821D6198: C141005C  lfs f10, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821D619C: ED24502A  fadds f9, f4, f10
	ctx.f[9].f64 = ((ctx.f[4].f64 + ctx.f[10].f64) as f32) as f64;
	// 821D61A0: D121006C  stfs f9, 0x6c(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821D61A4: D0E10068  stfs f7, 0x68(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821D61A8: 80E4000C  lwz r7, 0xc(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D61AC: 80C40000  lwz r6, 0(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D61B0: 80A40004  lwz r5, 4(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D61B4: 81040008  lwz r8, 8(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D61B8: 911F00E4  stw r8, 0xe4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), ctx.r[8].u32 ) };
	// 821D61BC: 90BF00E0  stw r5, 0xe0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), ctx.r[5].u32 ) };
	// 821D61C0: 90DF00DC  stw r6, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[6].u32 ) };
	// 821D61C4: 90FF00E8  stw r7, 0xe8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), ctx.r[7].u32 ) };
	pc = 0x821D61C8; continue 'dispatch;
            }
            0x821D61C8 => {
    //   block [0x821D61C8..0x821D61F4)
	// 821D61C8: C01F00DC  lfs f0, 0xdc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D61CC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D61D0: C1BF00E0  lfs f13, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D61D4: C19F00E4  lfs f12, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821D61D8: C17F00E8  lfs f11, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821D61DC: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821D61E0: D1BD0004  stfs f13, 4(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821D61E4: D19D0008  stfs f12, 8(r29)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821D61E8: D17D000C  stfs f11, 0xc(r29)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821D61EC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821D61F0: 48AD326C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D61F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D61F8 size=3444
    let mut pc: u32 = 0x821D61F8;
    'dispatch: loop {
        match pc {
            0x821D61F8 => {
    //   block [0x821D61F8..0x821D6F6C)
	// 821D61F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D61FC: 48AD31F5  bl 0x82ca93f0
	ctx.lr = 0x821D6200;
	sub_82CA93D0(ctx, base);
	// 821D6200: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 821D6204: 48AD7ACD  bl 0x82cadcd0
	ctx.lr = 0x821D6208;
	sub_82CADCA0(ctx, base);
	// 821D6208: 3980FF50  li r12, -0xb0
	ctx.r[12].s64 = -176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D6F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D6F70 size=1504
    let mut pc: u32 = 0x821D6F70;
    'dispatch: loop {
        match pc {
            0x821D6F70 => {
    //   block [0x821D6F70..0x821D6FD0)
	// 821D6F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D6F74: 48AD2481  bl 0x82ca93f4
	ctx.lr = 0x821D6F78;
	sub_82CA93D0(ctx, base);
	// 821D6F78: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 821D6F7C: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D6F80: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D6F84: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 821D6F88: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821D6F8C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 821D6F90: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D6F94: 93DD033C  stw r30, 0x33c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(828 as u32), ctx.r[30].u32 ) };
	// 821D6F98: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D6F9C: 554927FE  rlwinm r9, r10, 4, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0FFFFFFFu64;
	// 821D6FA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D6FA4: 419A00E8  beq cr6, 0x821d708c
	if ctx.cr[6].eq {
	pc = 0x821D708C; continue 'dispatch;
	}
	// 821D6FA8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D6FAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D6FB0: 419A0020  beq cr6, 0x821d6fd0
	if ctx.cr[6].eq {
	pc = 0x821D6FD0; continue 'dispatch;
	}
	// 821D6FB4: 894A003C  lbz r10, 0x3c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 821D6FB8: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D6FBC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D6FC0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D6FC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D6FC8: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D6FCC: 480000C4  b 0x821d7090
	pc = 0x821D7090; continue 'dispatch;
            }
            0x821D6FD0 => {
    //   block [0x821D6FD0..0x821D6FEC)
	// 821D6FD0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D6FD4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D6FD8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821D6FDC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D6FE0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D6FE4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D6FE8: 40810054  ble 0x821d703c
	if !ctx.cr[0].gt {
	pc = 0x821D703C; continue 'dispatch;
	}
	pc = 0x821D6FEC; continue 'dispatch;
            }
            0x821D6FEC => {
    //   block [0x821D6FEC..0x821D700C)
	// 821D6FEC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D6FF0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D6FF4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D6FF8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D6FFC: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 821D7000: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D7004: 41980008  blt cr6, 0x821d700c
	if ctx.cr[6].lt {
	pc = 0x821D700C; continue 'dispatch;
	}
	// 821D7008: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x821D700C; continue 'dispatch;
            }
            0x821D700C => {
    //   block [0x821D700C..0x821D7028)
	// 821D700C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D7010: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D7014: 419A0014  beq cr6, 0x821d7028
	if ctx.cr[6].eq {
	pc = 0x821D7028; continue 'dispatch;
	}
	// 821D7018: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D701C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D7020: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D7024: 4800000C  b 0x821d7030
	pc = 0x821D7030; continue 'dispatch;
            }
            0x821D7028 => {
    //   block [0x821D7028..0x821D7030)
	// 821D7028: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D702C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821D7030; continue 'dispatch;
            }
            0x821D7030 => {
    //   block [0x821D7030..0x821D703C)
	// 821D7030: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D7034: 4199FFB8  bgt cr6, 0x821d6fec
	if ctx.cr[6].gt {
	pc = 0x821D6FEC; continue 'dispatch;
	}
	// 821D7038: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821D703C; continue 'dispatch;
            }
            0x821D703C => {
    //   block [0x821D703C..0x821D7058)
	// 821D703C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D7040: 419A003C  beq cr6, 0x821d707c
	if ctx.cr[6].eq {
	pc = 0x821D707C; continue 'dispatch;
	}
	// 821D7044: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D7048: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 821D704C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D7050: 41990008  bgt cr6, 0x821d7058
	if ctx.cr[6].gt {
	pc = 0x821D7058; continue 'dispatch;
	}
	// 821D7054: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821D7058; continue 'dispatch;
            }
            0x821D7058 => {
    //   block [0x821D7058..0x821D707C)
	// 821D7058: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D705C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7060: 409A001C  bne cr6, 0x821d707c
	if !ctx.cr[6].eq {
	pc = 0x821D707C; continue 'dispatch;
	}
	// 821D7064: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D7068: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D706C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D7070: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7074: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D7078: 48000018  b 0x821d7090
	pc = 0x821D7090; continue 'dispatch;
            }
            0x821D707C => {
    //   block [0x821D707C..0x821D708C)
	// 821D707C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D7080: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7084: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D7088: 48000008  b 0x821d7090
	pc = 0x821D7090; continue 'dispatch;
            }
            0x821D708C => {
    //   block [0x821D708C..0x821D7090)
	// 821D708C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821D7090; continue 'dispatch;
            }
            0x821D7090 => {
    //   block [0x821D7090..0x821D7118)
	// 821D7090: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D7094: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7098: 419A0480  beq cr6, 0x821d7518
	if ctx.cr[6].eq {
	pc = 0x821D7518; continue 'dispatch;
	}
	// 821D709C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821D70A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D70A4: 48010EB5  bl 0x821e7f58
	ctx.lr = 0x821D70A8;
	sub_821E7F58(ctx, base);
	// 821D70A8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D70AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D70B0: 419A0078  beq cr6, 0x821d7128
	if ctx.cr[6].eq {
	pc = 0x821D7128; continue 'dispatch;
	}
	// 821D70B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D70B8: 4BF9BA71  bl 0x82172b28
	ctx.lr = 0x821D70BC;
	sub_82172B28(ctx, base);
	// 821D70BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D70C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D70C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D70C8: 419A0050  beq cr6, 0x821d7118
	if ctx.cr[6].eq {
	pc = 0x821D7118; continue 'dispatch;
	}
	// 821D70CC: 4BFF90C5  bl 0x821d0190
	ctx.lr = 0x821D70D0;
	sub_821D0190(ctx, base);
	// 821D70D0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D70D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D70D8: 409A046C  bne cr6, 0x821d7544
	if !ctx.cr[6].eq {
	pc = 0x821D7544; continue 'dispatch;
	}
	// 821D70DC: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 821D70E0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821D70E4: 409A0044  bne cr6, 0x821d7128
	if !ctx.cr[6].eq {
	pc = 0x821D7128; continue 'dispatch;
	}
	// 821D70E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821D70EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D70F0: 48010E69  bl 0x821e7f58
	ctx.lr = 0x821D70F4;
	sub_821E7F58(ctx, base);
	// 821D70F4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D70F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D70FC: 419A002C  beq cr6, 0x821d7128
	if ctx.cr[6].eq {
	pc = 0x821D7128; continue 'dispatch;
	}
	// 821D7100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D7104: 4848D335  bl 0x82664438
	ctx.lr = 0x821D7108;
	sub_82664438(ctx, base);
	// 821D7108: 93DD033C  stw r30, 0x33c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(828 as u32), ctx.r[30].u32 ) };
	// 821D710C: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 821D7110: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821D7114: 48AD2330  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x821D7118 => {
    //   block [0x821D7118..0x821D7128)
	// 821D7118: 4BFF9079  bl 0x821d0190
	ctx.lr = 0x821D711C;
	sub_821D0190(ctx, base);
	// 821D711C: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 821D7120: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821D7124: 48AD2320  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x821D7128 => {
    //   block [0x821D7128..0x821D719C)
	// 821D7128: 897F00BA  lbz r11, 0xba(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(186 as u32) ) } as u64;
	// 821D712C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7130: 409A03E8  bne cr6, 0x821d7518
	if !ctx.cr[6].eq {
	pc = 0x821D7518; continue 'dispatch;
	}
	// 821D7134: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 821D7138: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821D713C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D7140: 4BFF8CC9  bl 0x821cfe08
	ctx.lr = 0x821D7144;
	sub_821CFE08(ctx, base);
	// 821D7144: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D7148: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D714C: 419A03CC  beq cr6, 0x821d7518
	if ctx.cr[6].eq {
	pc = 0x821D7518; continue 'dispatch;
	}
	// 821D7150: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 821D7154: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7158: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821D715C: 913D033C  stw r9, 0x33c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(828 as u32), ctx.r[9].u32 ) };
	// 821D7160: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821D7164: 55079FFE  rlwinm r7, r8, 0x13, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x00001FFFu64;
	// 821D7168: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D716C: 419A00F4  beq cr6, 0x821d7260
	if ctx.cr[6].eq {
	pc = 0x821D7260; continue 'dispatch;
	}
	// 821D7170: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D7174: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D7178: 419A0024  beq cr6, 0x821d719c
	if ctx.cr[6].eq {
	pc = 0x821D719C; continue 'dispatch;
	}
	// 821D717C: 894A006D  lbz r10, 0x6d(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(109 as u32) ) } as u64;
	// 821D7180: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D7184: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D7188: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D718C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7190: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D7194: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D7198: 480000CC  b 0x821d7264
	pc = 0x821D7264; continue 'dispatch;
            }
            0x821D719C => {
    //   block [0x821D719C..0x821D71B8)
	// 821D719C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D71A0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D71A4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821D71A8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D71AC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D71B0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D71B4: 40810054  ble 0x821d7208
	if !ctx.cr[0].gt {
	pc = 0x821D7208; continue 'dispatch;
	}
	pc = 0x821D71B8; continue 'dispatch;
            }
            0x821D71B8 => {
    //   block [0x821D71B8..0x821D71D8)
	// 821D71B8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D71BC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D71C0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D71C4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D71C8: 2F07006D  cmpwi cr6, r7, 0x6d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 109, &mut ctx.xer);
	// 821D71CC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D71D0: 41980008  blt cr6, 0x821d71d8
	if ctx.cr[6].lt {
	pc = 0x821D71D8; continue 'dispatch;
	}
	// 821D71D4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x821D71D8; continue 'dispatch;
            }
            0x821D71D8 => {
    //   block [0x821D71D8..0x821D71F4)
	// 821D71D8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D71DC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D71E0: 419A0014  beq cr6, 0x821d71f4
	if ctx.cr[6].eq {
	pc = 0x821D71F4; continue 'dispatch;
	}
	// 821D71E4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D71E8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D71EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D71F0: 4800000C  b 0x821d71fc
	pc = 0x821D71FC; continue 'dispatch;
            }
            0x821D71F4 => {
    //   block [0x821D71F4..0x821D71FC)
	// 821D71F4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D71F8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821D71FC; continue 'dispatch;
            }
            0x821D71FC => {
    //   block [0x821D71FC..0x821D7208)
	// 821D71FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D7200: 4199FFB8  bgt cr6, 0x821d71b8
	if ctx.cr[6].gt {
	pc = 0x821D71B8; continue 'dispatch;
	}
	// 821D7204: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821D7208; continue 'dispatch;
            }
            0x821D7208 => {
    //   block [0x821D7208..0x821D7224)
	// 821D7208: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D720C: 419A0040  beq cr6, 0x821d724c
	if ctx.cr[6].eq {
	pc = 0x821D724C; continue 'dispatch;
	}
	// 821D7210: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D7214: 2F0B006D  cmpwi cr6, r11, 0x6d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 109, &mut ctx.xer);
	// 821D7218: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D721C: 41990008  bgt cr6, 0x821d7224
	if ctx.cr[6].gt {
	pc = 0x821D7224; continue 'dispatch;
	}
	// 821D7220: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821D7224; continue 'dispatch;
            }
            0x821D7224 => {
    //   block [0x821D7224..0x821D724C)
	// 821D7224: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D7228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D722C: 409A0020  bne cr6, 0x821d724c
	if !ctx.cr[6].eq {
	pc = 0x821D724C; continue 'dispatch;
	}
	// 821D7230: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D7234: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D7238: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D723C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7240: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D7244: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D7248: 4800001C  b 0x821d7264
	pc = 0x821D7264; continue 'dispatch;
            }
            0x821D724C => {
    //   block [0x821D724C..0x821D7260)
	// 821D724C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D7250: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7254: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821D7258: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D725C: 48000008  b 0x821d7264
	pc = 0x821D7264; continue 'dispatch;
            }
            0x821D7260 => {
    //   block [0x821D7260..0x821D7264)
	// 821D7260: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821D7264; continue 'dispatch;
            }
            0x821D7264 => {
    //   block [0x821D7264..0x821D7274)
	// 821D7264: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D7268: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D726C: 419A0008  beq cr6, 0x821d7274
	if ctx.cr[6].eq {
	pc = 0x821D7274; continue 'dispatch;
	}
	// 821D7270: 9B8A0024  stb r28, 0x24(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), ctx.r[28].u8 ) };
	pc = 0x821D7274; continue 'dispatch;
            }
            0x821D7274 => {
    //   block [0x821D7274..0x821D72B0)
	// 821D7274: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7278: 480B0B71  bl 0x82287de8
	ctx.lr = 0x821D727C;
	sub_82287DE8(ctx, base);
	// 821D727C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821D7280: 480E16B9  bl 0x822b8938
	ctx.lr = 0x821D7284;
	sub_822B8938(ctx, base);
	// 821D7284: 815D0590  lwz r10, 0x590(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1424 as u32) ) } as u64;
	// 821D7288: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D728C: 3BFD0580  addi r31, r29, 0x580
	ctx.r[31].s64 = ctx.r[29].s64 + 1408;
	// 821D7290: 3BCB92CC  addi r30, r11, -0x6d34
	ctx.r[30].s64 = ctx.r[11].s64 + -27956;
	// 821D7294: C1AA0018  lfs f13, 0x18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D7298: C00A001C  lfs f0, 0x1c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D729C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821D72A0: C1AB92CC  lfs f13, -0x6d34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27956 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D72A4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821D72A8: 40980008  bge cr6, 0x821d72b0
	if !ctx.cr[6].lt {
	pc = 0x821D72B0; continue 'dispatch;
	}
	// 821D72AC: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x821D72B0; continue 'dispatch;
            }
            0x821D72B0 => {
    //   block [0x821D72B0..0x821D7328)
	// 821D72B0: 817D0590  lwz r11, 0x590(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1424 as u32) ) } as u64;
	// 821D72B4: C1BD07AC  lfs f13, 0x7ac(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1964 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D72B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D72BC: EFED002A  fadds f31, f13, f0
	ctx.f[31].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821D72C0: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 821D72C4: 3B6100B0  addi r27, r1, 0xb0
	ctx.r[27].s64 = ctx.r[1].s64 + 176;
	// 821D72C8: 3B410060  addi r26, r1, 0x60
	ctx.r[26].s64 = ctx.r[1].s64 + 96;
	// 821D72CC: 832B000C  lwz r25, 0xc(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D72D0: 830B0014  lwz r24, 0x14(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D72D4: 4BFBA4CD  bl 0x821917a0
	ctx.lr = 0x821D72D8;
	sub_821917A0(ctx, base);
	// 821D72D8: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 821D72DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D72E0: 38610150  addi r3, r1, 0x150
	ctx.r[3].s64 = ctx.r[1].s64 + 336;
	// 821D72E4: 4BFBA675  bl 0x82191958
	ctx.lr = 0x821D72E8;
	sub_82191958(ctx, base);
	// 821D72E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D72EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D72F0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D72F4: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 821D72F8: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 821D72FC: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 821D7300: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 821D7304: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 821D7308: 480E1709  bl 0x822b8a10
	ctx.lr = 0x821D730C;
	sub_822B8A10(ctx, base);
	// 821D730C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821D7310: 419A0018  beq cr6, 0x821d7328
	if ctx.cr[6].eq {
	pc = 0x821D7328; continue 'dispatch;
	}
	// 821D7314: C01E2524  lfs f0, 0x2524(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(9508 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D7318: D01D0834  stfs f0, 0x834(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(2100 as u32), tmp.u32 ) };
	// 821D731C: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 821D7320: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821D7324: 48AD2120  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x821D7328 => {
    //   block [0x821D7328..0x821D7380)
	// 821D7328: 817D07CC  lwz r11, 0x7cc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1996 as u32) ) } as u64;
	// 821D732C: 3BFD07CC  addi r31, r29, 0x7cc
	ctx.r[31].s64 = ctx.r[29].s64 + 1996;
	// 821D7330: 894B009D  lbz r10, 0x9d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(157 as u32) ) } as u64;
	// 821D7334: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D7338: 419A0048  beq cr6, 0x821d7380
	if ctx.cr[6].eq {
	pc = 0x821D7380; continue 'dispatch;
	}
	// 821D733C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821D7340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D7344: 4BFF9175  bl 0x821d04b8
	ctx.lr = 0x821D7348;
	sub_821D04B8(ctx, base);
	// 821D7348: C01E2494  lfs f0, 0x2494(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(9364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D734C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821D7350: 41990030  bgt cr6, 0x821d7380
	if ctx.cr[6].gt {
	pc = 0x821D7380; continue 'dispatch;
	}
	// 821D7354: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D7358: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D735C: 480101AD  bl 0x821e7508
	ctx.lr = 0x821D7360;
	sub_821E7508(ctx, base);
	// 821D7360: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821D7364: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821D7368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x821D7380; continue 'dispatch;
            }
            0x821D7380 => {
    //   block [0x821D7380..0x821D7518)
	// 821D7380: 817D033C  lwz r11, 0x33c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(828 as u32) ) } as u64;
	// 821D7384: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821D7388: 409A01BC  bne cr6, 0x821d7544
	if !ctx.cr[6].eq {
	pc = 0x821D7544; continue 'dispatch;
	}
	// 821D738C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7390: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 821D7394: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821D7398: 55499FFE  rlwinm r9, r10, 0x13, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00001FFFu64;
	// 821D739C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D73A0: 419A00E8  beq cr6, 0x821d7488
	if ctx.cr[6].eq {
	pc = 0x821D7488; continue 'dispatch;
	}
	// 821D73A4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D73A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D73AC: 419A0020  beq cr6, 0x821d73cc
	if ctx.cr[6].eq {
	pc = 0x821D73CC; continue 'dispatch;
	}
	// 821D73B0: 894A006D  lbz r10, 0x6d(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(109 as u32) ) } as u64;
	// 821D73B4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D73B8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D73BC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D73C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D73C4: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D73C8: 480000C4  b 0x821d748c
	pc = 0x821D748C; continue 'dispatch;
	// 821D73CC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D73D0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D73D4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821D73D8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D73DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D73E0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D73E4: 40810054  ble 0x821d7438
	if !ctx.cr[0].gt {
	pc = 0x821D7438; continue 'dispatch;
	}
	// 821D73E8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D73EC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D73F0: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821D73F4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D73F8: 2F07006D  cmpwi cr6, r7, 0x6d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 109, &mut ctx.xer);
	// 821D73FC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D7400: 41980008  blt cr6, 0x821d7408
	if ctx.cr[6].lt {
	pc = 0x821D7408; continue 'dispatch;
	}
	// 821D7404: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 821D7408: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D740C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D7410: 419A0014  beq cr6, 0x821d7424
	if ctx.cr[6].eq {
	pc = 0x821D7424; continue 'dispatch;
	}
	// 821D7414: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D7418: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D741C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D7420: 4800000C  b 0x821d742c
	pc = 0x821D742C; continue 'dispatch;
	// 821D7424: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D7428: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821D742C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D7430: 4199FFB8  bgt cr6, 0x821d73e8
	if ctx.cr[6].gt {
	pc = 0x821D73E8; continue 'dispatch;
	}
	// 821D7434: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D7438: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D743C: 419A003C  beq cr6, 0x821d7478
	if ctx.cr[6].eq {
	pc = 0x821D7478; continue 'dispatch;
	}
	// 821D7440: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D7444: 2F0B006D  cmpwi cr6, r11, 0x6d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 109, &mut ctx.xer);
	// 821D7448: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D744C: 41990008  bgt cr6, 0x821d7454
	if ctx.cr[6].gt {
	pc = 0x821D7454; continue 'dispatch;
	}
	// 821D7450: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821D7454: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D7458: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D745C: 409A001C  bne cr6, 0x821d7478
	if !ctx.cr[6].eq {
	pc = 0x821D7478; continue 'dispatch;
	}
	// 821D7460: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D7464: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D7468: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D746C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7470: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D7474: 48000018  b 0x821d748c
	pc = 0x821D748C; continue 'dispatch;
	// 821D7478: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D747C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7480: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D7484: 48000008  b 0x821d748c
	pc = 0x821D748C; continue 'dispatch;
	// 821D7488: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821D748C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D7490: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7494: 419A00B0  beq cr6, 0x821d7544
	if ctx.cr[6].eq {
	pc = 0x821D7544; continue 'dispatch;
	}
	// 821D7498: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D749C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D74A0: 419A00A4  beq cr6, 0x821d7544
	if ctx.cr[6].eq {
	pc = 0x821D7544; continue 'dispatch;
	}
	// 821D74A4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D74A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D74AC: 4BFD798D  bl 0x821aee38
	ctx.lr = 0x821D74B0;
	sub_821AEE38(ctx, base);
	// 821D74B0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 821D74B4: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D74B8: 48010051  bl 0x821e7508
	ctx.lr = 0x821D74BC;
	sub_821E7508(ctx, base);
	// 821D74BC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            0x821D7518 => {
    //   block [0x821D7518..0x821D7544)
	// 821D7518: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D751C: 4BFF8C75  bl 0x821d0190
	ctx.lr = 0x821D7520;
	sub_821D0190(ctx, base);
	// 821D7520: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D7524: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7528: 409A001C  bne cr6, 0x821d7544
	if !ctx.cr[6].eq {
	pc = 0x821D7544; continue 'dispatch;
	}
	// 821D752C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D7530: 4BFC6E81  bl 0x8219e3b0
	ctx.lr = 0x821D7534;
	sub_8219E3B0(ctx, base);
	// 821D7534: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D7538: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D753C: 409A0008  bne cr6, 0x821d7544
	if !ctx.cr[6].eq {
	pc = 0x821D7544; continue 'dispatch;
	}
	// 821D7540: 93DD033C  stw r30, 0x33c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(828 as u32), ctx.r[30].u32 ) };
	pc = 0x821D7544; continue 'dispatch;
            }
            0x821D7544 => {
    //   block [0x821D7544..0x821D7550)
	// 821D7544: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 821D7548: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821D754C: 48AD1EF8  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D7550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D7550 size=284
    let mut pc: u32 = 0x821D7550;
    'dispatch: loop {
        match pc {
            0x821D7550 => {
    //   block [0x821D7550..0x821D7580)
	// 821D7550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D7554: 48AD1EB9  bl 0x82ca940c
	ctx.lr = 0x821D7558;
	sub_82CA93D0(ctx, base);
	// 821D7558: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D755C: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821D7560: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821D7564: 390B7DA0  addi r8, r11, 0x7da0
	ctx.r[8].s64 = ctx.r[11].s64 + 32160;
	// 821D7568: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D756C: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	// 821D7570: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D7574: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821D7578: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 821D757C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	pc = 0x821D7580; continue 'dispatch;
            }
            0x821D7580 => {
    //   block [0x821D7580..0x821D75A4)
	// 821D7580: 7C8A2B96  divwu r4, r10, r5
	ctx.r[4].u32 = ctx.r[10].u32 / ctx.r[5].u32;
	// 821D7584: 7CC32030  slw r3, r6, r4
	if (ctx.r[4].u8 & 0x20) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = ((ctx.r[6].u32) << ((ctx.r[4].u8 & 0x1F) as u32)) as u64;
	}
	// 821D7588: 7C643838  and r4, r3, r7
	ctx.r[4].u64 = ctx.r[3].u64 & ctx.r[7].u64;
	// 821D758C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821D7590: 419A0014  beq cr6, 0x821d75a4
	if ctx.cr[6].eq {
	pc = 0x821D75A4; continue 'dispatch;
	}
	// 821D7594: A08B0000  lhz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D7598: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 821D759C: B0890000  sth r4, 0(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[4].u16 ) };
	// 821D75A0: 39290002  addi r9, r9, 2
	ctx.r[9].s64 = ctx.r[9].s64 + 2;
	pc = 0x821D75A4; continue 'dispatch;
            }
            0x821D75A4 => {
    //   block [0x821D75A4..0x821D7664)
	// 821D75A4: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 821D75A8: 38880060  addi r4, r8, 0x60
	ctx.r[4].s64 = ctx.r[8].s64 + 96;
	// 821D75AC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821D75B0: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 821D75B4: 4198FFCC  blt cr6, 0x821d7580
	if ctx.cr[6].lt {
	pc = 0x821D7580; continue 'dispatch;
	}
	// 821D75B8: 3FA08336  lis r29, -0x7cca
	ctx.r[29].s64 = -2093613056;
	// 821D75BC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821D75C0: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821D75C4: 817D0364  lwz r11, 0x364(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(868 as u32) ) } as u64;
	// 821D75C8: 814A5144  lwz r10, 0x5144(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20804 as u32) ) } as u64;
	// 821D75CC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 821D75D0: 914B2E2C  stw r10, 0x2e2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11820 as u32), ctx.r[10].u32 ) };
	// 821D75D4: E8E80010  ld r7, 0x10(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) };
	// 821D75D8: 64E60008  oris r6, r7, 8
	ctx.r[6].u64 = ctx.r[7].u64 | 524288;
	// 821D75DC: 914970B8  stw r10, 0x70b8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28856 as u32), ctx.r[10].u32 ) };
	// 821D75E0: F8C80010  std r6, 0x10(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 821D75E4: 48046EBD  bl 0x8221e4a0
	ctx.lr = 0x821D75E8;
	sub_8221E4A0(ctx, base);
	// 821D75E8: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821D75EC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821D75F0: 7D7F2BD6  divw r11, r31, r5
	ctx.r[11].s32 = ctx.r[31].s32 / ctx.r[5].s32;
	// 821D75F4: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 821D75F8: 39410064  addi r10, r1, 0x64
	ctx.r[10].s64 = ctx.r[1].s64 + 100;
	// 821D75FC: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D7600: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 821D7604: 7FCB4214  add r30, r11, r8
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 821D7608: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821D760C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821D7610: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 821D7614: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D7618: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821D761C: 83FD0364  lwz r31, 0x364(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(868 as u32) ) } as u64;
	// 821D7620: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D7624: 48040795  bl 0x82217db8
	ctx.lr = 0x821D7628;
	sub_82217DB8(ctx, base);
	// 821D7628: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821D762C: 409A0038  bne cr6, 0x821d7664
	if !ctx.cr[6].eq {
	pc = 0x821D7664; continue 'dispatch;
	}
	// 821D7630: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821D7634: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821D7638: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 821D763C: 388B7E00  addi r4, r11, 0x7e00
	ctx.r[4].s64 = ctx.r[11].s64 + 32256;
	// 821D7640: 48AD1E41  bl 0x82ca9480
	ctx.lr = 0x821D7644;
	sub_82CA9480(ctx, base);
	// 821D7644: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D7648: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821D764C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821D7650: 394B0003  addi r10, r11, 3
	ctx.r[10].s64 = ctx.r[11].s64 + 3;
	// 821D7654: 5545003A  rlwinm r5, r10, 0, 0, 0x1d
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821D7658: 48AD1E29  bl 0x82ca9480
	ctx.lr = 0x821D765C;
	sub_82CA9480(ctx, base);
	// 821D765C: 813F3484  lwz r9, 0x3484(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13444 as u32) ) } as u64;
	// 821D7660: 913F0030  stw r9, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[9].u32 ) };
	pc = 0x821D7664; continue 'dispatch;
            }
            0x821D7664 => {
    //   block [0x821D7664..0x821D766C)
	// 821D7664: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 821D7668: 48AD1DF4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D7670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D7670 size=240
    let mut pc: u32 = 0x821D7670;
    'dispatch: loop {
        match pc {
            0x821D7670 => {
    //   block [0x821D7670..0x821D76A4)
	// 821D7670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D7674: 48AD1D91  bl 0x82ca9404
	ctx.lr = 0x821D7678;
	sub_82CA93D0(ctx, base);
	// 821D7678: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D767C: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D7680: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821D7684: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 821D7688: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 821D768C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D7690: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 821D7694: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821D7698: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 821D769C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D76A0: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821D76A4; continue 'dispatch;
            }
            0x821D76A4 => {
    //   block [0x821D76A4..0x821D76B4)
	// 821D76A4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D76A8: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821D76AC: 419A0008  beq cr6, 0x821d76b4
	if ctx.cr[6].eq {
	pc = 0x821D76B4; continue 'dispatch;
	}
	// 821D76B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D76B4; continue 'dispatch;
            }
            0x821D76B4 => {
    //   block [0x821D76B4..0x821D76CC)
	// 821D76B4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D76B8: 419A007C  beq cr6, 0x821d7734
	if ctx.cr[6].eq {
	pc = 0x821D7734; continue 'dispatch;
	}
	// 821D76BC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D76C0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D76C4: 409A0008  bne cr6, 0x821d76cc
	if !ctx.cr[6].eq {
	pc = 0x821D76CC; continue 'dispatch;
	}
	// 821D76C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D76CC; continue 'dispatch;
            }
            0x821D76CC => {
    //   block [0x821D76CC..0x821D76FC)
	// 821D76CC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D76D0: 395F0008  addi r10, r31, 8
	ctx.r[10].s64 = ctx.r[31].s64 + 8;
	// 821D76D4: 7F0BD800  cmpw cr6, r11, r27
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[27].s32, &mut ctx.xer);
	// 821D76D8: 4099005C  ble cr6, 0x821d7734
	if !ctx.cr[6].gt {
	pc = 0x821D7734; continue 'dispatch;
	}
	// 821D76DC: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D76E0: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D76E4: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821D76E8: 41980014  blt cr6, 0x821d76fc
	if ctx.cr[6].lt {
	pc = 0x821D76FC; continue 'dispatch;
	}
	// 821D76EC: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D76F0: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821D76F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D76F8: 41980008  blt cr6, 0x821d7700
	if ctx.cr[6].lt {
	pc = 0x821D7700; continue 'dispatch;
	}
	pc = 0x821D76FC; continue 'dispatch;
            }
            0x821D76FC => {
    //   block [0x821D76FC..0x821D7700)
	// 821D76FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821D7700; continue 'dispatch;
            }
            0x821D7700 => {
    //   block [0x821D7700..0x821D771C)
	// 821D7700: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D7704: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7708: 419A0014  beq cr6, 0x821d771c
	if ctx.cr[6].eq {
	pc = 0x821D771C; continue 'dispatch;
	}
	// 821D770C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821D7710: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821D7714: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821D7718: 48972039  bl 0x82b49750
	ctx.lr = 0x821D771C;
	sub_82B49750(ctx, base);
	pc = 0x821D771C; continue 'dispatch;
            }
            0x821D771C => {
    //   block [0x821D771C..0x821D772C)
	// 821D771C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7720: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D7724: 409A0008  bne cr6, 0x821d772c
	if !ctx.cr[6].eq {
	pc = 0x821D772C; continue 'dispatch;
	}
	// 821D7728: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D772C; continue 'dispatch;
            }
            0x821D772C => {
    //   block [0x821D772C..0x821D7734)
	// 821D772C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D7730: 4BFFFF74  b 0x821d76a4
	pc = 0x821D76A4; continue 'dispatch;
            }
            0x821D7734 => {
    //   block [0x821D7734..0x821D774C)
	// 821D7734: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7738: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D773C: 409A0010  bne cr6, 0x821d774c
	if !ctx.cr[6].eq {
	pc = 0x821D774C; continue 'dispatch;
	}
	// 821D7740: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D7744: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821D7748: 48AD1D0C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x821D774C => {
    //   block [0x821D774C..0x821D7760)
	// 821D774C: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D7750: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D7754: 7D231670  srawi r3, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 821D7758: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821D775C: 48AD1CF8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D7760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D7760 size=596
    let mut pc: u32 = 0x821D7760;
    'dispatch: loop {
        match pc {
            0x821D7760 => {
    //   block [0x821D7760..0x821D77AC)
	// 821D7760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D7764: 48AD1CA1  bl 0x82ca9404
	ctx.lr = 0x821D7768;
	sub_82CA93D0(ctx, base);
	// 821D7768: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D776C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821D7770: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 821D7774: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D7778: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D777C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D7780: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821D7784: 4BFBF5ED  bl 0x82196d70
	ctx.lr = 0x821D7788;
	sub_82196D70(ctx, base);
	// 821D7788: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D778C: 813D000C  lwz r9, 0xc(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D7790: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7794: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7798: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821D779C: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 821D77A0: 409A000C  bne cr6, 0x821d77ac
	if !ctx.cr[6].eq {
	pc = 0x821D77AC; continue 'dispatch;
	}
	// 821D77A4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821D77A8: 48000010  b 0x821d77b8
	pc = 0x821D77B8; continue 'dispatch;
            }
            0x821D77AC => {
    //   block [0x821D77AC..0x821D77B8)
	// 821D77AC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D77B0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D77B4: 7D292670  srawi r9, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 4) as i64;
	pc = 0x821D77B8; continue 'dispatch;
            }
            0x821D77B8 => {
    //   block [0x821D77B8..0x821D77E8)
	// 821D77B8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821D77BC: 419A01DC  beq cr6, 0x821d7998
	if ctx.cr[6].eq {
	pc = 0x821D7998; continue 'dispatch;
	}
	// 821D77C0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D77C4: 3D400FFF  lis r10, 0xfff
	ctx.r[10].s64 = 268369920;
	// 821D77C8: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821D77CC: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 821D77D0: 7D0B2670  srawi r11, r8, 4
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 4) as i64;
	// 821D77D4: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D77D8: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821D77DC: 4098000C  bge cr6, 0x821d77e8
	if !ctx.cr[6].lt {
	pc = 0x821D77E8; continue 'dispatch;
	}
	// 821D77E0: 4886FCE9  bl 0x82a474c8
	ctx.lr = 0x821D77E4;
	sub_82A474C8(ctx, base);
	// 821D77E4: 480001B4  b 0x821d7998
	pc = 0x821D7998; continue 'dispatch;
            }
            0x821D77E8 => {
    //   block [0x821D77E8..0x821D780C)
	// 821D77E8: 7D0BF214  add r8, r11, r30
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821D77EC: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821D77F0: 409800C4  bge cr6, 0x821d78b4
	if !ctx.cr[6].lt {
	pc = 0x821D78B4; continue 'dispatch;
	}
	// 821D77F4: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D77F8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821D77FC: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D7800: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821D7804: 41980008  blt cr6, 0x821d780c
	if ctx.cr[6].lt {
	pc = 0x821D780C; continue 'dispatch;
	}
	// 821D7808: 7F8B4A14  add r28, r11, r9
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x821D780C; continue 'dispatch;
            }
            0x821D780C => {
    //   block [0x821D780C..0x821D7818)
	// 821D780C: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821D7810: 40980008  bge cr6, 0x821d7818
	if !ctx.cr[6].lt {
	pc = 0x821D7818; continue 'dispatch;
	}
	// 821D7814: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	pc = 0x821D7818; continue 'dispatch;
            }
            0x821D7818 => {
    //   block [0x821D7818..0x821D7894)
	// 821D7818: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821D781C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D7820: 4824BA19  bl 0x82423238
	ctx.lr = 0x821D7824;
	sub_82423238(ctx, base);
	// 821D7824: 836100AC  lwz r27, 0xac(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 821D7828: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D782C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7830: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821D7834: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821D7838: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D783C: 4850DEBD  bl 0x826e56f8
	ctx.lr = 0x821D7840;
	sub_826E56F8(ctx, base);
	// 821D7840: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D7844: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821D7848: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821D784C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D7850: 4BFFDC69  bl 0x821d54b8
	ctx.lr = 0x821D7854;
	sub_821D54B8(ctx, base);
	// 821D7854: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 821D7858: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821D785C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D7860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D7864: 4850DE95  bl 0x826e56f8
	ctx.lr = 0x821D7868;
	sub_826E56F8(ctx, base);
	// 821D7868: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D786C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D7870: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821D7874: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 821D7878: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 821D787C: 7FCBF214  add r30, r11, r30
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821D7880: 419A0014  beq cr6, 0x821d7894
	if ctx.cr[6].eq {
	pc = 0x821D7894; continue 'dispatch;
	}
	// 821D7884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D7888: 4821DD81  bl 0x823f5608
	ctx.lr = 0x821D788C;
	sub_823F5608(ctx, base);
	// 821D788C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7890: 480444A9  bl 0x8221bd38
	ctx.lr = 0x821D7894;
	sub_8221BD38(ctx, base);
	pc = 0x821D7894; continue 'dispatch;
            }
            0x821D7894 => {
    //   block [0x821D7894..0x821D78B4)
	// 821D7894: 578B2036  slwi r11, r28, 4
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D7898: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821D789C: 57CA2036  slwi r10, r30, 4
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D78A0: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821D78A4: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 821D78A8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 821D78AC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821D78B0: 480000E8  b 0x821d7998
	pc = 0x821D7998; continue 'dispatch;
            }
            0x821D78B4 => {
    //   block [0x821D78B4..0x821D790C)
	// 821D78B4: 838100AC  lwz r28, 0xac(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 821D78B8: 57DD2036  slwi r29, r30, 4
	ctx.r[29].u32 = ctx.r[30].u32.wrapping_shl(4);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821D78BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D78C0: 7D7C2850  subf r11, r28, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[28].s64;
	// 821D78C4: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 821D78C8: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821D78CC: 40980040  bge cr6, 0x821d790c
	if !ctx.cr[6].lt {
	pc = 0x821D790C; continue 'dispatch;
	}
	// 821D78D0: 7CDDE214  add r6, r29, r28
	ctx.r[6].u64 = ctx.r[29].u64 + ctx.r[28].u64;
	// 821D78D4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821D78D8: 4850DE21  bl 0x826e56f8
	ctx.lr = 0x821D78DC;
	sub_826E56F8(ctx, base);
	// 821D78DC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D78E0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821D78E4: 7D7C2050  subf r11, r28, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[28].s64;
	// 821D78E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D78EC: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 821D78F0: 7CAAF050  subf r5, r10, r30
	ctx.r[5].s64 = ctx.r[30].s64 - ctx.r[10].s64;
	// 821D78F4: 4BFFDBC5  bl 0x821d54b8
	ctx.lr = 0x821D78F8;
	sub_821D54B8(ctx, base);
	// 821D78F8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D78FC: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821D7900: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821D7904: 7C9D5850  subf r4, r29, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 821D7908: 48000084  b 0x821d798c
	pc = 0x821D798C; continue 'dispatch;
            }
            0x821D790C => {
    //   block [0x821D790C..0x821D7934)
	// 821D790C: 7FDD2850  subf r30, r29, r5
	ctx.r[30].s64 = ctx.r[5].s64 - ctx.r[29].s64;
	// 821D7910: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 821D7914: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D7918: 4850DDE1  bl 0x826e56f8
	ctx.lr = 0x821D791C;
	sub_826E56F8(ctx, base);
	// 821D791C: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 821D7920: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 821D7924: 7F1CF040  cmplw cr6, r28, r30
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821D7928: 419A0060  beq cr6, 0x821d7988
	if ctx.cr[6].eq {
	pc = 0x821D7988; continue 'dispatch;
	}
	// 821D792C: 7D7DFA14  add r11, r29, r31
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[31].u64;
	// 821D7930: 3BCB000C  addi r30, r11, 0xc
	ctx.r[30].s64 = ctx.r[11].s64 + 12;
	pc = 0x821D7934; continue 'dispatch;
            }
            0x821D7934 => {
    //   block [0x821D7934..0x821D795C)
	// 821D7934: 3BFFFFF0  addi r31, r31, -0x10
	ctx.r[31].s64 = ctx.r[31].s64 + -16;
	// 821D7938: 3BDEFFF0  addi r30, r30, -0x10
	ctx.r[30].s64 = ctx.r[30].s64 + -16;
	// 821D793C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7940: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7944: 419A0020  beq cr6, 0x821d7964
	if ctx.cr[6].eq {
	pc = 0x821D7964; continue 'dispatch;
	}
	// 821D7948: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D794C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D7950: 419A000C  beq cr6, 0x821d795c
	if ctx.cr[6].eq {
	pc = 0x821D795C; continue 'dispatch;
	}
	// 821D7954: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821D7958: 48000010  b 0x821d7968
	pc = 0x821D7968; continue 'dispatch;
            }
            0x821D795C => {
    //   block [0x821D795C..0x821D7964)
	// 821D795C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D7960: 4BFBC4D9  bl 0x82193e38
	ctx.lr = 0x821D7964;
	sub_82193E38(ctx, base);
	pc = 0x821D7964; continue 'dispatch;
            }
            0x821D7964 => {
    //   block [0x821D7964..0x821D7968)
	// 821D7964: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x821D7968; continue 'dispatch;
            }
            0x821D7968 => {
    //   block [0x821D7968..0x821D7988)
	// 821D7968: 387EFFF4  addi r3, r30, -0xc
	ctx.r[3].s64 = ctx.r[30].s64 + -12;
	// 821D796C: 4803CF2D  bl 0x82214898
	ctx.lr = 0x821D7970;
	sub_82214898(ctx, base);
	// 821D7970: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D7974: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821D7978: 917EFFFC  stw r11, -4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 821D797C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D7980: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821D7984: 409AFFB0  bne cr6, 0x821d7934
	if !ctx.cr[6].eq {
	pc = 0x821D7934; continue 'dispatch;
	}
	pc = 0x821D7988; continue 'dispatch;
            }
            0x821D7988 => {
    //   block [0x821D7988..0x821D798C)
	// 821D7988: 7C9DE214  add r4, r29, r28
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[28].u64;
	pc = 0x821D798C; continue 'dispatch;
            }
            0x821D798C => {
    //   block [0x821D798C..0x821D7998)
	// 821D798C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D7990: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821D7994: 4850DDCD  bl 0x826e5760
	ctx.lr = 0x821D7998;
	sub_826E5760(ctx, base);
	pc = 0x821D7998; continue 'dispatch;
            }
            0x821D7998 => {
    //   block [0x821D7998..0x821D79B4)
	// 821D7998: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D799C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D79A0: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 821D79A4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821D79A8: 4BFBC491  bl 0x82193e38
	ctx.lr = 0x821D79AC;
	sub_82193E38(ctx, base);
	// 821D79AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821D79B0: 48AD1AA4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D79B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D79B8 size=220
    let mut pc: u32 = 0x821D79B8;
    'dispatch: loop {
        match pc {
            0x821D79B8 => {
    //   block [0x821D79B8..0x821D79FC)
	// 821D79B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D79BC: 48AD1A2D  bl 0x82ca93e8
	ctx.lr = 0x821D79C0;
	sub_82CA93D0(ctx, base);
	// 821D79C0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D79C4: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 821D79C8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821D79CC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821D79D0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821D79D4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821D79D8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D79DC: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 821D79E0: 7D364B78  mr r22, r9
	ctx.r[22].u64 = ctx.r[9].u64;
	// 821D79E4: 7D555378  mr r21, r10
	ctx.r[21].u64 = ctx.r[10].u64;
	// 821D79E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D79EC: 409A0010  bne cr6, 0x821d79fc
	if !ctx.cr[6].eq {
	pc = 0x821D79FC; continue 'dispatch;
	}
	// 821D79F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D79F4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821D79F8: 48AD1A40  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            0x821D79FC => {
    //   block [0x821D79FC..0x821D7A0C)
	// 821D79FC: 8B210127  lbz r25, 0x127(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(295 as u32) ) } as u64;
	// 821D7A00: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 821D7A04: 8301011C  lwz r24, 0x11c(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(284 as u32) ) } as u64;
	// 821D7A08: 82E10114  lwz r23, 0x114(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	pc = 0x821D7A0C; continue 'dispatch;
            }
            0x821D7A0C => {
    //   block [0x821D7A0C..0x821D7A54)
	// 821D7A0C: 7F1FB040  cmplw cr6, r31, r22
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[22].u32, &mut ctx.xer);
	// 821D7A10: 41980078  blt cr6, 0x821d7a88
	if ctx.cr[6].lt {
	pc = 0x821D7A88; continue 'dispatch;
	}
	// 821D7A14: 7F1EA840  cmplw cr6, r30, r21
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[21].u32, &mut ctx.xer);
	// 821D7A18: 41980070  blt cr6, 0x821d7a88
	if ctx.cr[6].lt {
	pc = 0x821D7A88; continue 'dispatch;
	}
	// 821D7A1C: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 821D7A20: 7F09C378  mr r9, r24
	ctx.r[9].u64 = ctx.r[24].u64;
	// 821D7A24: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 821D7A28: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821D7A2C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821D7A30: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821D7A34: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821D7A38: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821D7A3C: 480092E5  bl 0x821e0d20
	ctx.lr = 0x821D7A40;
	sub_821E0D20(ctx, base);
	// 821D7A40: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D7A44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7A48: 419A000C  beq cr6, 0x821d7a54
	if ctx.cr[6].eq {
	pc = 0x821D7A54; continue 'dispatch;
	}
	// 821D7A4C: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 821D7A50: 4800002C  b 0x821d7a7c
	pc = 0x821D7A7C; continue 'dispatch;
            }
            0x821D7A54 => {
    //   block [0x821D7A54..0x821D7A68)
	// 821D7A54: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 821D7A58: 419A0010  beq cr6, 0x821d7a68
	if ctx.cr[6].eq {
	pc = 0x821D7A68; continue 'dispatch;
	}
	// 821D7A5C: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D7A60: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D7A64: 91770000  stw r11, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x821D7A68; continue 'dispatch;
            }
            0x821D7A68 => {
    //   block [0x821D7A68..0x821D7A74)
	// 821D7A68: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 821D7A6C: 40990008  ble cr6, 0x821d7a74
	if !ctx.cr[6].gt {
	pc = 0x821D7A74; continue 'dispatch;
	}
	// 821D7A70: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	pc = 0x821D7A74; continue 'dispatch;
            }
            0x821D7A74 => {
    //   block [0x821D7A74..0x821D7A7C)
	// 821D7A74: 57FFF87E  srwi r31, r31, 1
	ctx.r[31].u32 = ctx.r[31].u32.wrapping_shr(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 821D7A78: 57DEF87E  srwi r30, r30, 1
	ctx.r[30].u32 = ctx.r[30].u32.wrapping_shr(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	pc = 0x821D7A7C; continue 'dispatch;
            }
            0x821D7A7C => {
    //   block [0x821D7A7C..0x821D7A88)
	// 821D7A7C: 568B063E  clrlwi r11, r20, 0x18
	ctx.r[11].u64 = ctx.r[20].u32 as u64 & 0x000000FFu64;
	// 821D7A80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7A84: 419AFF88  beq cr6, 0x821d7a0c
	if ctx.cr[6].eq {
	pc = 0x821D7A0C; continue 'dispatch;
	}
	pc = 0x821D7A88; continue 'dispatch;
            }
            0x821D7A88 => {
    //   block [0x821D7A88..0x821D7A94)
	// 821D7A88: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 821D7A8C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821D7A90: 48AD19A8  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D7A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D7A98 size=1348
    let mut pc: u32 = 0x821D7A98;
    'dispatch: loop {
        match pc {
            0x821D7A98 => {
    //   block [0x821D7A98..0x821D7ACC)
	// 821D7A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D7A9C: 48AD1945  bl 0x82ca93e0
	ctx.lr = 0x821D7AA0;
	sub_82CA93D0(ctx, base);
	// 821D7AA0: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D7AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D7AA8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821D7AAC: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 821D7AB0: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D7AB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7AB8: 419A0020  beq cr6, 0x821d7ad8
	if ctx.cr[6].eq {
	pc = 0x821D7AD8; continue 'dispatch;
	}
	// 821D7ABC: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821D7AC0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821D7AC4: 419A0008  beq cr6, 0x821d7acc
	if ctx.cr[6].eq {
	pc = 0x821D7ACC; continue 'dispatch;
	}
	// 821D7AC8: 48045631  bl 0x8221d0f8
	ctx.lr = 0x821D7ACC;
	sub_8221D0F8(ctx, base);
	pc = 0x821D7ACC; continue 'dispatch;
            }
            0x821D7ACC => {
    //   block [0x821D7ACC..0x821D7AD8)
	// 821D7ACC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D7AD0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821D7AD4: 48AD195C  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            0x821D7AD8 => {
    //   block [0x821D7AD8..0x821D7B04)
	// 821D7AD8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821D7ADC: 894B6E72  lbz r10, 0x6e72(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28274 as u32) ) } as u64;
	// 821D7AE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D7AE4: 419A0020  beq cr6, 0x821d7b04
	if ctx.cr[6].eq {
	pc = 0x821D7B04; continue 'dispatch;
	}
	// 821D7AE8: 3D607FFF  lis r11, 0x7fff
	ctx.r[11].s64 = 2147418112;
	// 821D7AEC: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D7AF0: 6169FFFF  ori r9, r11, 0xffff
	ctx.r[9].u64 = ctx.r[11].u64 | 65535;
	// 821D7AF4: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821D7AF8: 409A000C  bne cr6, 0x821d7b04
	if !ctx.cr[6].eq {
	pc = 0x821D7B04; continue 'dispatch;
	}
	// 821D7AFC: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D7B00: 48A914A9  bl 0x82c68fa8
	ctx.lr = 0x821D7B04;
	sub_82C68FA8(ctx, base);
	pc = 0x821D7B04; continue 'dispatch;
            }
            0x821D7B04 => {
    //   block [0x821D7B04..0x821D7B70)
	// 821D7B04: 56D5063E  clrlwi r21, r22, 0x18
	ctx.r[21].u64 = ctx.r[22].u32 as u64 & 0x000000FFu64;
	// 821D7B08: 815F009C  lwz r10, 0x9c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 821D7B0C: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D7B10: 3A800000  li r20, 0
	ctx.r[20].s64 = 0;
	// 821D7B14: 7EA80034  cntlzw r8, r21
	ctx.r[8].u64 = if ctx.r[21].u32 == 0 { 32 } else { ctx.r[21].u32.leading_zeros() as u64 };
	// 821D7B18: 813F00A0  lwz r9, 0xa0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 821D7B1C: 83DF0094  lwz r30, 0x94(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 821D7B20: 7E93A378  mr r19, r20
	ctx.r[19].u64 = ctx.r[20].u64;
	// 821D7B24: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 821D7B28: 811F0098  lwz r8, 0x98(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 821D7B2C: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 821D7B30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D7B34: 68EA0001  xori r10, r7, 1
	ctx.r[10].u64 = ctx.r[7].u64 ^ 1;
	// 821D7B38: 3A4A0001  addi r18, r10, 1
	ctx.r[18].s64 = ctx.r[10].s64 + 1;
	// 821D7B3C: 419A0280  beq cr6, 0x821d7dbc
	if ctx.cr[6].eq {
	pc = 0x821D7DBC; continue 'dispatch;
	}
	// 821D7B40: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821D7B44: 409A048C  bne cr6, 0x821d7fd0
	if !ctx.cr[6].eq {
	pc = 0x821D7FD0; continue 'dispatch;
	}
	// 821D7B48: 7D7E4050  subf r11, r30, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[30].s64;
	// 821D7B4C: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821D7B50: 7D6AFE70  srawi r10, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 821D7B54: 7D4B5838  and r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 & ctx.r[11].u64;
	// 821D7B58: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821D7B5C: 7CE61670  srawi r6, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 2) as i64;
	// 821D7B60: 7D660195  addze. r11, r6
	tmp.s64 = ctx.r[6].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[6].u32);
	ctx.r[11].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D7B64: 4082000C  bne 0x821d7b70
	if !ctx.cr[0].eq {
	pc = 0x821D7B70; continue 'dispatch;
	}
	// 821D7B68: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821D7B6C: 4800008C  b 0x821d7bf8
	pc = 0x821D7BF8; continue 'dispatch;
            }
            0x821D7B70 => {
    //   block [0x821D7B70..0x821D7B84)
	// 821D7B70: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 821D7B74: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D7B78: 4198000C  blt cr6, 0x821d7b84
	if ctx.cr[6].lt {
	pc = 0x821D7B84; continue 'dispatch;
	}
	// 821D7B7C: 3960001F  li r11, 0x1f
	ctx.r[11].s64 = 31;
	// 821D7B80: 48000078  b 0x821d7bf8
	pc = 0x821D7BF8; continue 'dispatch;
            }
            0x821D7B84 => {
    //   block [0x821D7B84..0x821D7BF8)
	// 821D7B84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D7B88: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821D7B8C: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D7B90: 7CE6FE70  srawi r6, r7, 0x1f
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 31) as i64;
	// 821D7B94: 54CA06F6  rlwinm r10, r6, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 821D7B98: 38AA0008  addi r5, r10, 8
	ctx.r[5].s64 = ctx.r[10].s64 + 8;
	// 821D7B9C: 7F442830  slw r4, r26, r5
	if (ctx.r[5].u8 & 0x20) != 0 {
		ctx.r[4].u64 = 0;
	} else {
		ctx.r[4].u64 = ((ctx.r[26].u32) << ((ctx.r[5].u8 & 0x1F) as u32)) as u64;
	}
	// 821D7BA0: 7C6B2050  subf r3, r11, r4
	ctx.r[3].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 821D7BA4: 7C67FE70  srawi r7, r3, 0x1f
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[3].s32 >> 31) as i64;
	// 821D7BA8: 54E70738  rlwinm r7, r7, 0, 0x1c, 0x1c
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821D7BAC: 7D475214  add r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 821D7BB0: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 821D7BB4: 7F453030  slw r5, r26, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = ((ctx.r[26].u32) << ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 821D7BB8: 7C8B2850  subf r4, r11, r5
	ctx.r[4].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821D7BBC: 7C83FE70  srawi r3, r4, 0x1f
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[4].s32 >> 31) as i64;
	// 821D7BC0: 5467077A  rlwinm r7, r3, 0, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 821D7BC4: 7D475214  add r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 821D7BC8: 38EA0002  addi r7, r10, 2
	ctx.r[7].s64 = ctx.r[10].s64 + 2;
	// 821D7BCC: 7F463830  slw r6, r26, r7
	if (ctx.r[7].u8 & 0x20) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = ((ctx.r[26].u32) << ((ctx.r[7].u8 & 0x1F) as u32)) as u64;
	}
	// 821D7BD0: 7CAB3050  subf r5, r11, r6
	ctx.r[5].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 821D7BD4: 7CA4FE70  srawi r4, r5, 0x1f
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[5].s32 >> 31) as i64;
	// 821D7BD8: 548707BC  rlwinm r7, r4, 0, 0x1e, 0x1e
	ctx.r[7].u64 = ctx.r[4].u32 as u64 & 0xFFFFFFFFu64;
	// 821D7BDC: 7D475214  add r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 821D7BE0: 386A0001  addi r3, r10, 1
	ctx.r[3].s64 = ctx.r[10].s64 + 1;
	// 821D7BE4: 7F471830  slw r7, r26, r3
	if (ctx.r[3].u8 & 0x20) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = ((ctx.r[26].u32) << ((ctx.r[3].u8 & 0x1F) as u32)) as u64;
	}
	// 821D7BE8: 7CCB3850  subf r6, r11, r7
	ctx.r[6].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 821D7BEC: 7CC5FE70  srawi r5, r6, 0x1f
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[6].s32 >> 31) as i64;
	// 821D7BF0: 54AB07FE  clrlwi r11, r5, 0x1f
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x00000001u64;
	// 821D7BF4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x821D7BF8; continue 'dispatch;
            }
            0x821D7BF8 => {
    //   block [0x821D7BF8..0x821D7C44)
	// 821D7BF8: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 821D7BFC: 817F0044  lwz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 821D7C00: 7D174378  mr r23, r8
	ctx.r[23].u64 = ctx.r[8].u64;
	// 821D7C04: 7D495050  subf r10, r9, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821D7C08: 7FD8F378  mr r24, r30
	ctx.r[24].u64 = ctx.r[30].u64;
	// 821D7C0C: 7D48FE70  srawi r8, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 821D7C10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7C14: 7D0A5038  and r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 & ctx.r[10].u64;
	// 821D7C18: 7FAA4A14  add r29, r10, r9
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821D7C1C: 419A0028  beq cr6, 0x821d7c44
	if ctx.cr[6].eq {
	pc = 0x821D7C44; continue 'dispatch;
	}
	// 821D7C20: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D7C24: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 821D7C28: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821D7C2C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7C30: 48022FA1  bl 0x821fabd0
	ctx.lr = 0x821D7C34;
	sub_821FABD0(ctx, base);
	// 821D7C34: 81410098  lwz r10, 0x98(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 821D7C38: 8121009C  lwz r9, 0x9c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 821D7C3C: 5558083C  slwi r24, r10, 1
	ctx.r[24].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[24].u64 = ctx.r[24].u32 as u64;
	// 821D7C40: 5537083C  slwi r23, r9, 1
	ctx.r[23].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[23].u64 = ctx.r[23].u32 as u64;
	pc = 0x821D7C44; continue 'dispatch;
            }
            0x821D7C44 => {
    //   block [0x821D7C44..0x821D7C54)
	// 821D7C44: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821D7C48: 3B9F0014  addi r28, r31, 0x14
	ctx.r[28].s64 = ctx.r[31].s64 + 20;
	// 821D7C4C: 7E99A378  mr r25, r20
	ctx.r[25].u64 = ctx.r[20].u64;
	// 821D7C50: 836BFA0C  lwz r27, -0x5f4(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1524 as u32) ) } as u64;
	pc = 0x821D7C54; continue 'dispatch;
            }
            0x821D7C54 => {
    //   block [0x821D7C54..0x821D7C98)
	// 821D7C54: 7F1EC040  cmplw cr6, r30, r24
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[24].u32, &mut ctx.xer);
	// 821D7C58: 4198005C  blt cr6, 0x821d7cb4
	if ctx.cr[6].lt {
	pc = 0x821D7CB4; continue 'dispatch;
	}
	// 821D7C5C: 7F1EB840  cmplw cr6, r30, r23
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[23].u32, &mut ctx.xer);
	// 821D7C60: 41980054  blt cr6, 0x821d7cb4
	if ctx.cr[6].lt {
	pc = 0x821D7CB4; continue 'dispatch;
	}
	// 821D7C64: 7EC9B378  mr r9, r22
	ctx.r[9].u64 = ctx.r[22].u64;
	// 821D7C68: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 821D7C6C: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 821D7C70: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821D7C74: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821D7C78: 389F0048  addi r4, r31, 0x48
	ctx.r[4].s64 = ctx.r[31].s64 + 72;
	// 821D7C7C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821D7C80: 48988F59  bl 0x82b60bd8
	ctx.lr = 0x821D7C84;
	sub_82B60BD8(ctx, base);
	// 821D7C84: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D7C88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7C8C: 419A000C  beq cr6, 0x821d7c98
	if ctx.cr[6].eq {
	pc = 0x821D7C98; continue 'dispatch;
	}
	// 821D7C90: 7F59D378  mr r25, r26
	ctx.r[25].u64 = ctx.r[26].u64;
	// 821D7C94: 48000014  b 0x821d7ca8
	pc = 0x821D7CA8; continue 'dispatch;
            }
            0x821D7C98 => {
    //   block [0x821D7C98..0x821D7CA4)
	// 821D7C98: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 821D7C9C: 419A0008  beq cr6, 0x821d7ca4
	if ctx.cr[6].eq {
	pc = 0x821D7CA4; continue 'dispatch;
	}
	// 821D7CA0: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	pc = 0x821D7CA4; continue 'dispatch;
            }
            0x821D7CA4 => {
    //   block [0x821D7CA4..0x821D7CA8)
	// 821D7CA4: 57DEF87E  srwi r30, r30, 1
	ctx.r[30].u32 = ctx.r[30].u32.wrapping_shr(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	pc = 0x821D7CA8; continue 'dispatch;
            }
            0x821D7CA8 => {
    //   block [0x821D7CA8..0x821D7CB4)
	// 821D7CA8: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 821D7CAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7CB0: 419AFFA4  beq cr6, 0x821d7c54
	if ctx.cr[6].eq {
	pc = 0x821D7C54; continue 'dispatch;
	}
	pc = 0x821D7CB4; continue 'dispatch;
            }
            0x821D7CB4 => {
    //   block [0x821D7CB4..0x821D7CE8)
	// 821D7CB4: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 821D7CB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D7CBC: 419A00E0  beq cr6, 0x821d7d9c
	if ctx.cr[6].eq {
	pc = 0x821D7D9C; continue 'dispatch;
	}
	// 821D7CC0: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D7CC4: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	// 821D7CC8: 92810074  stw r20, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[20].u32 ) };
	// 821D7CCC: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 821D7CD0: 83CB002C  lwz r30, 0x2c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D7CD4: 838B0028  lwz r28, 0x28(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D7CD8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821D7CDC: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 821D7CE0: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 821D7CE4: 419A0040  beq cr6, 0x821d7d24
	if ctx.cr[6].eq {
	pc = 0x821D7D24; continue 'dispatch;
	}
	pc = 0x821D7CE8; continue 'dispatch;
            }
            0x821D7CE8 => {
    //   block [0x821D7CE8..0x821D7D24)
	// 821D7CE8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821D7CEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D7CF0: 7D60F028  lwarx r11, 0, r30
	// lwarx
	let ea = ctx.r[30].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821D7CF4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D7CF8: 7D60F12D  stwcx. r11, 0, r30
	// stwcx.
	let addr = ctx.r[30].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821D7CFC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D7D00: 4082FFE8  bne 0x821d7ce8
	if !ctx.cr[0].eq {
	pc = 0x821D7CE8; continue 'dispatch;
	}
	// 821D7D04: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D7D08: 4BFDFE11  bl 0x821b7b18
	ctx.lr = 0x821D7D0C;
	sub_821B7B18(ctx, base);
	// 821D7D0C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D7D10: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 821D7D14: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 821D7D18: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 821D7D1C: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 821D7D20: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x821D7D24; continue 'dispatch;
            }
            0x821D7D24 => {
    //   block [0x821D7D24..0x821D7D9C)
	// 821D7D24: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821D7D28: 4BFDFDF1  bl 0x821b7b18
	ctx.lr = 0x821D7D2C;
	sub_821B7B18(ctx, base);
	// 821D7D2C: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 821D7D30: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821D7D34: 38FF0084  addi r7, r31, 0x84
	ctx.r[7].s64 = ctx.r[31].s64 + 132;
	// 821D7D38: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821D7D3C: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 821D7D40: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D7D44: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 821D7D48: 489948D1  bl 0x82b6c618
	ctx.lr = 0x821D7D4C;
	sub_82B6C618(ctx, base);
	// 821D7D4C: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 821D7D50: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D7D54: 4BFDFDC5  bl 0x821b7b18
	ctx.lr = 0x821D7D58;
	sub_821B7B18(ctx, base);
	// 821D7D58: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 821D7D5C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821D7D60: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821D7D64: 394BF9F0  addi r10, r11, -0x610
	ctx.r[10].s64 = ctx.r[11].s64 + -1552;
	// 821D7D68: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 821D7D6C: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 821D7D70: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7D74: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821D7D78: E8810078  ld r4, 0x78(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 821D7D7C: 4887B2C5  bl 0x82a53040
	ctx.lr = 0x821D7D80;
	sub_82A53040(ctx, base);
	// 821D7D80: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821D7D84: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 821D7D88: 81696E78  lwz r11, 0x6e78(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28280 as u32) ) } as u64;
	// 821D7D8C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D7D90: 91696E78  stw r11, 0x6e78(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28280 as u32), ctx.r[11].u32 ) };
	// 821D7D94: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821D7D98: 48AD1698  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            0x821D7D9C => {
    //   block [0x821D7D9C..0x821D7DBC)
	// 821D7D9C: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 821D7DA0: 419A0230  beq cr6, 0x821d7fd0
	if ctx.cr[6].eq {
	pc = 0x821D7FD0; continue 'dispatch;
	}
	// 821D7DA4: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821D7DA8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821D7DAC: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 821D7DB0: 996A6E33  stb r11, 0x6e33(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28211 as u32), ctx.r[11].u8 ) };
	// 821D7DB4: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821D7DB8: 48AD1678  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            0x821D7DBC => {
    //   block [0x821D7DBC..0x821D7E58)
	// 821D7DBC: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 821D7DC0: 38E9FFFF  addi r7, r9, -1
	ctx.r[7].s64 = ctx.r[9].s64 + -1;
	// 821D7DC4: 815F0098  lwz r10, 0x98(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 821D7DC8: 809F0044  lwz r4, 0x44(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 821D7DCC: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D7DD0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821D7DD4: 7CC5FE70  srawi r5, r6, 0x1f
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[6].s32 >> 31) as i64;
	// 821D7DD8: 7CAA3038  and r10, r5, r6
	ctx.r[10].u64 = ctx.r[5].u64 & ctx.r[6].u64;
	// 821D7DDC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D7DE0: 7D633E70  srawi r3, r11, 7
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 7) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[11].s32 >> 7) as i64;
	// 821D7DE4: 7D630194  addze r11, r3
	tmp.s64 = ctx.r[3].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[3].u32);
	ctx.r[11].s64 = tmp.s64;
	// 821D7DE8: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 821D7DEC: 7D46FE70  srawi r6, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 821D7DF0: 7CC55038  and r5, r6, r10
	ctx.r[5].u64 = ctx.r[6].u64 & ctx.r[10].u64;
	// 821D7DF4: 7C655850  subf r3, r5, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 821D7DF8: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821D7DFC: 216B001F  subfic r11, r11, 0x1f
	ctx.xer.ca = ctx.r[11].u32 <= 31 as u32;
	ctx.r[11].s64 = (31 as i64) - ctx.r[11].s64;
	// 821D7E00: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 821D7E04: 7D47FE70  srawi r7, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 821D7E08: 7FA6FE70  srawi r6, r29, 0x1f
	ctx.xer.ca = (ctx.r[29].s32 < 0) && ((ctx.r[29].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[29].s32 >> 31) as i64;
	// 821D7E0C: 7CEA5038  and r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 & ctx.r[10].u64;
	// 821D7E10: 7CC5E838  and r5, r6, r29
	ctx.r[5].u64 = ctx.r[6].u64 & ctx.r[29].u64;
	// 821D7E14: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D7E18: 7D45E850  subf r10, r5, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[5].s64;
	// 821D7E1C: 7C6A5850  subf r3, r10, r11
	ctx.r[3].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D7E20: 7C67FE70  srawi r7, r3, 0x1f
	ctx.xer.ca = (ctx.r[3].s32 < 0) && ((ctx.r[3].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[3].s32 >> 31) as i64;
	// 821D7E24: 7CE71838  and r7, r7, r3
	ctx.r[7].u64 = ctx.r[7].u64 & ctx.r[3].u64;
	// 821D7E28: 7D475214  add r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 821D7E2C: 7D065630  sraw r6, r8, r10
	tmp.u32 = ctx.r[10].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[8].s32 >> tmp.u32) as i64;
	// 821D7E30: 7FC55630  sraw r5, r30, r10
	tmp.u32 = ctx.r[10].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[30].s32 < 0) && ((ctx.r[30].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[30].s32 >> tmp.u32) as i64;
	// 821D7E34: 7D085E30  sraw r8, r8, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> tmp.u32) as i64;
	// 821D7E38: 7CEA4850  subf r7, r10, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 821D7E3C: 7FC95E30  sraw r9, r30, r11
	tmp.u32 = ctx.r[11].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[30].s32 < 0) && ((ctx.r[30].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[30].s32 >> tmp.u32) as i64;
	// 821D7E40: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 821D7E44: 419A0014  beq cr6, 0x821d7e58
	if ctx.cr[6].eq {
	pc = 0x821D7E58; continue 'dispatch;
	}
	// 821D7E48: A1640020  lhz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D7E4C: A1440022  lhz r10, 0x22(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(34 as u32) ) } as u64;
	// 821D7E50: 5569083E  rotlwi r9, r11, 1
	ctx.r[9].u64 = ((ctx.r[11].u32).rotate_left(1)) as u64;
	// 821D7E54: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	pc = 0x821D7E58; continue 'dispatch;
            }
            0x821D7E58 => {
    //   block [0x821D7E58..0x821D7EB4)
	// 821D7E58: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821D7E5C: 9AC10067  stb r22, 0x67(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(103 as u32), ctx.r[22].u8 ) };
	// 821D7E60: 391F0014  addi r8, r31, 0x14
	ctx.r[8].s64 = ctx.r[31].s64 + 20;
	// 821D7E64: 92810054  stw r20, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[20].u32 ) };
	// 821D7E68: 3BBF0048  addi r29, r31, 0x48
	ctx.r[29].s64 = ctx.r[31].s64 + 72;
	// 821D7E6C: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 821D7E70: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 821D7E74: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D7E78: 806BFA0C  lwz r3, -0x5f4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1524 as u32) ) } as u64;
	// 821D7E7C: 4BFFFB3D  bl 0x821d79b8
	ctx.lr = 0x821D7E80;
	sub_821D79B8(ctx, base);
	// 821D7E80: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D7E84: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D7E88: 419A00E4  beq cr6, 0x821d7f6c
	if ctx.cr[6].eq {
	pc = 0x821D7F6C; continue 'dispatch;
	}
	// 821D7E8C: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D7E90: 7E9CA378  mr r28, r20
	ctx.r[28].u64 = ctx.r[20].u64;
	// 821D7E94: 92810074  stw r20, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[20].u32 ) };
	// 821D7E98: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 821D7E9C: 83CB002C  lwz r30, 0x2c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D7EA0: 836B0028  lwz r27, 0x28(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D7EA4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821D7EA8: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 821D7EAC: 93610078  stw r27, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[27].u32 ) };
	// 821D7EB0: 419A0040  beq cr6, 0x821d7ef0
	if ctx.cr[6].eq {
	pc = 0x821D7EF0; continue 'dispatch;
	}
	pc = 0x821D7EB4; continue 'dispatch;
            }
            0x821D7EB4 => {
    //   block [0x821D7EB4..0x821D7EF0)
	// 821D7EB4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821D7EB8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D7EBC: 7D60F028  lwarx r11, 0, r30
	// lwarx
	let ea = ctx.r[30].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821D7EC0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D7EC4: 7D60F12D  stwcx. r11, 0, r30
	// stwcx.
	let addr = ctx.r[30].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821D7EC8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D7ECC: 4082FFE8  bne 0x821d7eb4
	if !ctx.cr[0].eq {
	pc = 0x821D7EB4; continue 'dispatch;
	}
	// 821D7ED0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D7ED4: 4BFDFC45  bl 0x821b7b18
	ctx.lr = 0x821D7ED8;
	sub_821B7B18(ctx, base);
	// 821D7ED8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D7EDC: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 821D7EE0: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 821D7EE4: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 821D7EE8: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 821D7EEC: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x821D7EF0; continue 'dispatch;
            }
            0x821D7EF0 => {
    //   block [0x821D7EF0..0x821D7F34)
	// 821D7EF0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821D7EF4: 4BFDFC25  bl 0x821b7b18
	ctx.lr = 0x821D7EF8;
	sub_821B7B18(ctx, base);
	// 821D7EF8: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 821D7EFC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821D7F00: 38FF0084  addi r7, r31, 0x84
	ctx.r[7].s64 = ctx.r[31].s64 + 132;
	// 821D7F04: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821D7F08: 7E459378  mr r5, r18
	ctx.r[5].u64 = ctx.r[18].u64;
	// 821D7F0C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821D7F10: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 821D7F14: 48994705  bl 0x82b6c618
	ctx.lr = 0x821D7F18;
	sub_82B6C618(ctx, base);
	// 821D7F18: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 821D7F1C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821D7F20: 4BFDFBF9  bl 0x821b7b18
	ctx.lr = 0x821D7F24;
	sub_821B7B18(ctx, base);
	// 821D7F24: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7F28: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821D7F2C: 419A0008  beq cr6, 0x821d7f34
	if ctx.cr[6].eq {
	pc = 0x821D7F34; continue 'dispatch;
	}
	// 821D7F30: 480451C9  bl 0x8221d0f8
	ctx.lr = 0x821D7F34;
	sub_8221D0F8(ctx, base);
	pc = 0x821D7F34; continue 'dispatch;
            }
            0x821D7F34 => {
    //   block [0x821D7F34..0x821D7F6C)
	// 821D7F34: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 821D7F38: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821D7F3C: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821D7F40: 386BF9F0  addi r3, r11, -0x610
	ctx.r[3].s64 = ctx.r[11].s64 + -1552;
	// 821D7F44: 90610078  stw r3, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 821D7F48: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7F4C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821D7F50: E8810078  ld r4, 0x78(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 821D7F54: 4887B0ED  bl 0x82a53040
	ctx.lr = 0x821D7F58;
	sub_82A53040(ctx, base);
	// 821D7F58: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821D7F5C: 816A6E78  lwz r11, 0x6e78(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28280 as u32) ) } as u64;
	// 821D7F60: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821D7F64: 916A6E78  stw r11, 0x6e78(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28280 as u32), ctx.r[11].u32 ) };
	// 821D7F68: 48000018  b 0x821d7f80
	pc = 0x821D7F80; continue 'dispatch;
            }
            0x821D7F6C => {
    //   block [0x821D7F6C..0x821D7F80)
	// 821D7F6C: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 821D7F70: 419A0010  beq cr6, 0x821d7f80
	if ctx.cr[6].eq {
	pc = 0x821D7F80; continue 'dispatch;
	}
	// 821D7F74: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821D7F78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D7F7C: 996A6E33  stb r11, 0x6e33(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28211 as u32), ctx.r[11].u8 ) };
	pc = 0x821D7F80; continue 'dispatch;
            }
            0x821D7F80 => {
    //   block [0x821D7F80..0x821D7F94)
	// 821D7F80: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 821D7F84: 807F4364  lwz r3, 0x4364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(17252 as u32) ) } as u64;
	// 821D7F88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D7F8C: 419A003C  beq cr6, 0x821d7fc8
	if ctx.cr[6].eq {
	pc = 0x821D7FC8; continue 'dispatch;
	}
	// 821D7F90: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821D7F94; continue 'dispatch;
            }
            0x821D7F94 => {
    //   block [0x821D7F94..0x821D7FC8)
	// 821D7F94: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821D7F98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D7F9C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821D7FA0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D7FA4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821D7FA8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D7FAC: 4082FFE8  bne 0x821d7f94
	if !ctx.cr[0].eq {
	pc = 0x821D7F94; continue 'dispatch;
	}
	// 821D7FB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D7FB4: 409A0014  bne cr6, 0x821d7fc8
	if !ctx.cr[6].eq {
	pc = 0x821D7FC8; continue 'dispatch;
	}
	// 821D7FB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D7FBC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D7FC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D7FC4: 4E800421  bctrl
	ctx.lr = 0x821D7FC8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821D7FC8 => {
    //   block [0x821D7FC8..0x821D7FD0)
	// 821D7FC8: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 821D7FCC: 917F4364  stw r11, 0x4364(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(17252 as u32), ctx.r[11].u32 ) };
	pc = 0x821D7FD0; continue 'dispatch;
            }
            0x821D7FD0 => {
    //   block [0x821D7FD0..0x821D7FDC)
	// 821D7FD0: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 821D7FD4: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821D7FD8: 48AD1458  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D7FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D7FE0 size=172
    let mut pc: u32 = 0x821D7FE0;
    'dispatch: loop {
        match pc {
            0x821D7FE0 => {
    //   block [0x821D7FE0..0x821D8034)
	// 821D7FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D7FE4: 48AD1429  bl 0x82ca940c
	ctx.lr = 0x821D7FE8;
	sub_82CA93D0(ctx, base);
	// 821D7FE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D7FEC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821D7FF0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D7FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D7FF8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821D7FFC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821D8000: 48052BE1  bl 0x8222abe0
	ctx.lr = 0x821D8004;
	sub_8222ABE0(ctx, base);
	// 821D8004: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D8008: 3D60F0F0  lis r11, -0xf10
	ctx.r[11].s64 = -252706816;
	// 821D800C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821D8010: 616AF0F0  ori r10, r11, 0xf0f0
	ctx.r[10].u64 = ctx.r[11].u64 | 61680;
	// 821D8014: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821D8018: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821D801C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D8020: 48052BC1  bl 0x8222abe0
	ctx.lr = 0x821D8024;
	sub_8222ABE0(ctx, base);
	// 821D8024: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D8028: 419A000C  beq cr6, 0x821d8034
	if ctx.cr[6].eq {
	pc = 0x821D8034; continue 'dispatch;
	}
	// 821D802C: 39600010  li r11, 0x10
	ctx.r[11].s64 = 16;
	// 821D8030: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x821D8034; continue 'dispatch;
            }
            0x821D8034 => {
    //   block [0x821D8034..0x821D807C)
	// 821D8034: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 821D8038: 38800050  li r4, 0x50
	ctx.r[4].s64 = 80;
	// 821D803C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D8040: 48052BA1  bl 0x8222abe0
	ctx.lr = 0x821D8044;
	sub_8222ABE0(ctx, base);
	// 821D8044: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D8048: 419A0034  beq cr6, 0x821d807c
	if ctx.cr[6].eq {
	pc = 0x821D807C; continue 'dispatch;
	}
	// 821D804C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D8050: 39430010  addi r10, r3, 0x10
	ctx.r[10].s64 = ctx.r[3].s64 + 16;
	// 821D8054: 392B11A4  addi r9, r11, 0x11a4
	ctx.r[9].s64 = ctx.r[11].s64 + 4516;
	// 821D8058: 389D0010  addi r4, r29, 0x10
	ctx.r[4].s64 = ctx.r[29].s64 + 16;
	// 821D805C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D8060: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 821D8064: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 821D8068: 48AD1419  bl 0x82ca9480
	ctx.lr = 0x821D806C;
	sub_82CA9480(ctx, base);
	// 821D806C: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D8070: 911E0000  stw r8, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821D8074: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D8078: 48AD13E4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821D807C => {
    //   block [0x821D807C..0x821D808C)
	// 821D807C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D8080: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D8084: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D8088: 48AD13D4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D8090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D8090 size=208
    let mut pc: u32 = 0x821D8090;
    'dispatch: loop {
        match pc {
            0x821D8090 => {
    //   block [0x821D8090..0x821D8160)
	// 821D8090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D8094: 48AD1375  bl 0x82ca9408
	ctx.lr = 0x821D8098;
	sub_82CA93D0(ctx, base);
	// 821D8098: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821D809C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D80A0: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 821D80A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D80A8: 48050051  bl 0x822280f8
	ctx.lr = 0x821D80AC;
	sub_822280F8(ctx, base);
	// 821D80AC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821D80B0: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 821D80B4: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821D80B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D80BC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821D80C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D80C4: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 821D80C8: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 821D80CC: 83C80004  lwz r30, 4(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D80D0: 83A80000  lwz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D80D4: 48050025  bl 0x822280f8
	ctx.lr = 0x821D80D8;
	sub_822280F8(ctx, base);
	// 821D80D8: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D80DC: 4804F485  bl 0x82227560
	ctx.lr = 0x821D80E0;
	sub_82227560(ctx, base);
	// 821D80E0: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821D80E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D80E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821D80EC: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D80F0: 48129E09  bl 0x82301ef8
	ctx.lr = 0x821D80F4;
	sub_82301EF8(ctx, base);
	// 821D80F4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 821D80F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D80FC: 88610051  lbz r3, 0x51(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 821D8100: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821D8104: 485FEDBD  bl 0x827d6ec0
	ctx.lr = 0x821D8108;
	sub_827D6EC0(ctx, base);
	// 821D8108: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821D810C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821D8110: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D8114: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D8118: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 821D811C: 4E800421  bctrl
	ctx.lr = 0x821D8120;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D8120: 7C6707B4  extsw r7, r3
	ctx.r[7].s64 = ctx.r[3].s32 as i64;
	// 821D8124: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D8128: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821D812C: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 821D8130: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821D8134: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821D8138: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821D813C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821D8140: D1860000  stfs f12, 0(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821D8144: 90A60004  stw r5, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 821D8148: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D814C: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 821D8150: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 821D8154: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821D8158: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821D815C: 48AD12FC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D8160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D8160 size=128
    let mut pc: u32 = 0x821D8160;
    'dispatch: loop {
        match pc {
            0x821D8160 => {
    //   block [0x821D8160..0x821D81E0)
	// 821D8160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D8164: 48AD12A9  bl 0x82ca940c
	ctx.lr = 0x821D8168;
	sub_82CA93D0(ctx, base);
	// 821D8168: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D816C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 821D8170: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D8174: 4804FF85  bl 0x822280f8
	ctx.lr = 0x821D8178;
	sub_822280F8(ctx, base);
	// 821D8178: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821D817C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821D8180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D8184: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D8188: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D818C: 4804FF6D  bl 0x822280f8
	ctx.lr = 0x821D8190;
	sub_822280F8(ctx, base);
	// 821D8190: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D8194: 4804F3CD  bl 0x82227560
	ctx.lr = 0x821D8198;
	sub_82227560(ctx, base);
	// 821D8198: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821D819C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D81A0: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 821D81A4: 4E800421  bctrl
	ctx.lr = 0x821D81A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D81A8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D81AC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D81B0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821D81B4: 7D470034  cntlzw r7, r10
	ctx.r[7].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 821D81B8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821D81BC: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 821D81C0: 68C50001  xori r5, r6, 1
	ctx.r[5].u64 = ctx.r[6].u64 ^ 1;
	// 821D81C4: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821D81C8: 90A90000  stw r5, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 821D81CC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D81D0: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 821D81D4: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 821D81D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D81DC: 48AD1280  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D81E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D81E0 size=428
    let mut pc: u32 = 0x821D81E0;
    'dispatch: loop {
        match pc {
            0x821D81E0 => {
    //   block [0x821D81E0..0x821D823C)
	// 821D81E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D81E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D81E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D81EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D81F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D81F4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D81F8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821D81FC: 419A017C  beq cr6, 0x821d8378
	if ctx.cr[6].eq {
	pc = 0x821D8378; continue 'dispatch;
	}
	// 821D8200: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D8204: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D8208: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821D820C: 5528EFFE  rlwinm r8, r9, 0x1d, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 821D8210: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821D8214: 419A00DC  beq cr6, 0x821d82f0
	if ctx.cr[6].eq {
	pc = 0x821D82F0; continue 'dispatch;
	}
	// 821D8218: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D821C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D8220: 419A001C  beq cr6, 0x821d823c
	if ctx.cr[6].eq {
	pc = 0x821D823C; continue 'dispatch;
	}
	// 821D8224: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 821D8228: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D822C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D8230: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D8234: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D8238: 480000B4  b 0x821d82ec
	pc = 0x821D82EC; continue 'dispatch;
            }
            0x821D823C => {
    //   block [0x821D823C..0x821D825C)
	// 821D823C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D8240: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821D8244: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D8248: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821D824C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D8250: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D8254: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D8258: 40810054  ble 0x821d82ac
	if !ctx.cr[0].gt {
	pc = 0x821D82AC; continue 'dispatch;
	}
	pc = 0x821D825C; continue 'dispatch;
            }
            0x821D825C => {
    //   block [0x821D825C..0x821D827C)
	// 821D825C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D8260: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D8264: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D8268: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D826C: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 821D8270: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D8274: 41980008  blt cr6, 0x821d827c
	if ctx.cr[6].lt {
	pc = 0x821D827C; continue 'dispatch;
	}
	// 821D8278: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821D827C; continue 'dispatch;
            }
            0x821D827C => {
    //   block [0x821D827C..0x821D8298)
	// 821D827C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D8280: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D8284: 419A0014  beq cr6, 0x821d8298
	if ctx.cr[6].eq {
	pc = 0x821D8298; continue 'dispatch;
	}
	// 821D8288: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D828C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D8290: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D8294: 4800000C  b 0x821d82a0
	pc = 0x821D82A0; continue 'dispatch;
            }
            0x821D8298 => {
    //   block [0x821D8298..0x821D82A0)
	// 821D8298: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D829C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821D82A0; continue 'dispatch;
            }
            0x821D82A0 => {
    //   block [0x821D82A0..0x821D82AC)
	// 821D82A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D82A4: 4199FFB8  bgt cr6, 0x821d825c
	if ctx.cr[6].gt {
	pc = 0x821D825C; continue 'dispatch;
	}
	// 821D82A8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821D82AC; continue 'dispatch;
            }
            0x821D82AC => {
    //   block [0x821D82AC..0x821D82C8)
	// 821D82AC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D82B0: 419A0034  beq cr6, 0x821d82e4
	if ctx.cr[6].eq {
	pc = 0x821D82E4; continue 'dispatch;
	}
	// 821D82B4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D82B8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821D82BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D82C0: 41990008  bgt cr6, 0x821d82c8
	if ctx.cr[6].gt {
	pc = 0x821D82C8; continue 'dispatch;
	}
	// 821D82C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821D82C8; continue 'dispatch;
            }
            0x821D82C8 => {
    //   block [0x821D82C8..0x821D82E4)
	// 821D82C8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D82CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D82D0: 409A0014  bne cr6, 0x821d82e4
	if !ctx.cr[6].eq {
	pc = 0x821D82E4; continue 'dispatch;
	}
	// 821D82D4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D82D8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D82DC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D82E0: 48000008  b 0x821d82e8
	pc = 0x821D82E8; continue 'dispatch;
            }
            0x821D82E4 => {
    //   block [0x821D82E4..0x821D82E8)
	// 821D82E4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x821D82E8; continue 'dispatch;
            }
            0x821D82E8 => {
    //   block [0x821D82E8..0x821D82EC)
	// 821D82E8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x821D82EC; continue 'dispatch;
            }
            0x821D82EC => {
    //   block [0x821D82EC..0x821D82F0)
	// 821D82EC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x821D82F0; continue 'dispatch;
            }
            0x821D82F0 => {
    //   block [0x821D82F0..0x821D832C)
	// 821D82F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D82F4: C02A0028  lfs f1, 0x28(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821D82F8: 48017D49  bl 0x821f0040
	ctx.lr = 0x821D82FC;
	sub_821F0040(ctx, base);
	// 821D82FC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D8300: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D8304: 419A003C  beq cr6, 0x821d8340
	if ctx.cr[6].eq {
	pc = 0x821D8340; continue 'dispatch;
	}
	// 821D8308: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D830C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821D8310: 41980028  blt cr6, 0x821d8338
	if ctx.cr[6].lt {
	pc = 0x821D8338; continue 'dispatch;
	}
	// 821D8314: 419A0018  beq cr6, 0x821d832c
	if ctx.cr[6].eq {
	pc = 0x821D832C; continue 'dispatch;
	}
	// 821D8318: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 821D831C: 40980024  bge cr6, 0x821d8340
	if !ctx.cr[6].lt {
	pc = 0x821D8340; continue 'dispatch;
	}
	// 821D8320: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D8324: 4876A715  bl 0x82942a38
	ctx.lr = 0x821D8328;
	sub_82942A38(ctx, base);
	// 821D8328: 48000018  b 0x821d8340
	pc = 0x821D8340; continue 'dispatch;
            }
            0x821D832C => {
    //   block [0x821D832C..0x821D8338)
	// 821D832C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D8330: 4876A4C9  bl 0x829427f8
	ctx.lr = 0x821D8334;
	sub_829427F8(ctx, base);
	// 821D8334: 4800000C  b 0x821d8340
	pc = 0x821D8340; continue 'dispatch;
            }
            0x821D8338 => {
    //   block [0x821D8338..0x821D8340)
	// 821D8338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D833C: 4BFE291D  bl 0x821bac58
	ctx.lr = 0x821D8340;
	sub_821BAC58(ctx, base);
	pc = 0x821D8340; continue 'dispatch;
            }
            0x821D8340 => {
    //   block [0x821D8340..0x821D8370)
	// 821D8340: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D8344: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821D8348: 419A0028  beq cr6, 0x821d8370
	if ctx.cr[6].eq {
	pc = 0x821D8370; continue 'dispatch;
	}
	// 821D834C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821D8350: 409A0028  bne cr6, 0x821d8378
	if !ctx.cr[6].eq {
	pc = 0x821D8378; continue 'dispatch;
	}
	// 821D8354: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D8358: 4BFD0221  bl 0x821a8578
	ctx.lr = 0x821D835C;
	sub_821A8578(ctx, base);
	// 821D835C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D8360: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D8364: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D8368: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D836C: 4E800020  blr
	return;
            }
            0x821D8370 => {
    //   block [0x821D8370..0x821D8378)
	// 821D8370: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D8374: 4876A6C5  bl 0x82942a38
	ctx.lr = 0x821D8378;
	sub_82942A38(ctx, base);
	pc = 0x821D8378; continue 'dispatch;
            }
            0x821D8378 => {
    //   block [0x821D8378..0x821D838C)
	// 821D8378: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D837C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D8380: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D8384: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D8388: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D8390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D8390 size=136
    let mut pc: u32 = 0x821D8390;
    'dispatch: loop {
        match pc {
            0x821D8390 => {
    //   block [0x821D8390..0x821D8418)
	// 821D8390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D8394: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D8398: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D839C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D83A0: C0030034  lfs f0, 0x34(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D83A4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821D83A8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821D83AC: 8063003C  lwz r3, 0x3c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 821D83B0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D83B4: EC200072  fmuls f1, f0, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 821D83B8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821D83BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D83C0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821D83C4: 481092E5  bl 0x822e16a8
	ctx.lr = 0x821D83C8;
	sub_822E16A8(ctx, base);
	// 821D83C8: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821D83CC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821D83D0: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821D83D4: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D8418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D8418 size=240
    let mut pc: u32 = 0x821D8418;
    'dispatch: loop {
        match pc {
            0x821D8418 => {
    //   block [0x821D8418..0x821D849C)
	// 821D8418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D841C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D8420: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D8424: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D8428: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821D842C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D8430: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D8434: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D8438: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821D843C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821D8440: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D8444: 4E800421  bctrl
	ctx.lr = 0x821D8448;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D8448: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821D844C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821D8450: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 821D8454: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 821D8458: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821D845C: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 821D8460: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D8464: 80C70020  lwz r6, 0x20(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D8468: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 821D846C: 4E800421  bctrl
	ctx.lr = 0x821D8470;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D8470: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D8474: 48027E6D  bl 0x822002e0
	ctx.lr = 0x821D8478;
	sub_822002E0(ctx, base);
	// 821D8478: 5465063E  clrlwi r5, r3, 0x18
	ctx.r[5].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D847C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D8480: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821D8484: 419A0018  beq cr6, 0x821d849c
	if ctx.cr[6].eq {
	pc = 0x821D849C; continue 'dispatch;
	}
	// 821D8488: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D848C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D8490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D8494: 4BFFFEFD  bl 0x821d8390
	ctx.lr = 0x821D8498;
	sub_821D8390(ctx, base);
	// 821D8498: 4800000C  b 0x821d84a4
	pc = 0x821D84A4; continue 'dispatch;
            }
            0x821D849C => {
    //   block [0x821D849C..0x821D84A4)
	// 821D849C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D84A0: 48063911  bl 0x8223bdb0
	ctx.lr = 0x821D84A4;
	sub_8223BDB0(ctx, base);
	pc = 0x821D84A4; continue 'dispatch;
            }
            0x821D84A4 => {
    //   block [0x821D84A4..0x821D84B0)
	// 821D84A4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821D84A8: 419A0044  beq cr6, 0x821d84ec
	if ctx.cr[6].eq {
	pc = 0x821D84EC; continue 'dispatch;
	}
	// 821D84AC: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x821D84B0; continue 'dispatch;
            }
            0x821D84B0 => {
    //   block [0x821D84B0..0x821D84EC)
	// 821D84B0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821D84B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D84B8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821D84BC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821D84C0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821D84C4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821D84C8: 4082FFE8  bne 0x821d84b0
	if !ctx.cr[0].eq {
	pc = 0x821D84B0; continue 'dispatch;
	}
	// 821D84CC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821D84D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D84D4: 409A0018  bne cr6, 0x821d84ec
	if !ctx.cr[6].eq {
	pc = 0x821D84EC; continue 'dispatch;
	}
	// 821D84D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D84DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D84E0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D84E4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D84E8: 4E800421  bctrl
	ctx.lr = 0x821D84EC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821D84EC => {
    //   block [0x821D84EC..0x821D8508)
	// 821D84EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D84F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D84F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D84F8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821D84FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D8500: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D8504: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D8508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D8508 size=104
    let mut pc: u32 = 0x821D8508;
    'dispatch: loop {
        match pc {
            0x821D8508 => {
    //   block [0x821D8508..0x821D8570)
	// 821D8508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D850C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D8510: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D8514: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D8518: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D851C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D8520: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D8524: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D8528: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D852C: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821D8530: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D8534: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821D8538: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821D853C: 4E800421  bctrl
	ctx.lr = 0x821D8540;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D8540: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821D8544: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D8548: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D854C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D8570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D8570 size=20
    let mut pc: u32 = 0x821D8570;
    'dispatch: loop {
        match pc {
            0x821D8570 => {
    //   block [0x821D8570..0x821D8584)
	// 821D8570: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D8574: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D8588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D8588 size=208
    let mut pc: u32 = 0x821D8588;
    'dispatch: loop {
        match pc {
            0x821D8588 => {
    //   block [0x821D8588..0x821D85C0)
	// 821D8588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D858C: 48AD0E79  bl 0x82ca9404
	ctx.lr = 0x821D8590;
	sub_82CA93D0(ctx, base);
	// 821D8590: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 821D8594: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821D8598: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D859C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D85A0: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821D85A4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D85A8: D3C100C4  stfs f30, 0xc4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 821D85AC: 3B60000F  li r27, 0xf
	ctx.r[27].s64 = 15;
	// 821D85B0: 3BFD1028  addi r31, r29, 0x1028
	ctx.r[31].s64 = ctx.r[29].s64 + 4136;
	// 821D85B4: 3BDD0F38  addi r30, r29, 0xf38
	ctx.r[30].s64 = ctx.r[29].s64 + 3896;
	// 821D85B8: C3EB9490  lfs f31, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821D85BC: 7F9D2050  subf r28, r29, r4
	ctx.r[28].s64 = ctx.r[4].s64 - ctx.r[29].s64;
	pc = 0x821D85C0; continue 'dispatch;
            }
            0x821D85C0 => {
    //   block [0x821D85C0..0x821D8658)
	// 821D85C0: 7C1CFC2E  lfsx f0, r28, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D85C4: 7CDCF214  add r6, r28, r30
	ctx.r[6].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 821D85C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D85CC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821D85D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D85D4: EC20FFBC  fnmsubs f1, f0, f30, f31
	ctx.f[1].f64 = -(((ctx.f[0].f64 * ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 821D85D8: 48062D09  bl 0x8223b2e0
	ctx.lr = 0x821D85DC;
	sub_8223B2E0(ctx, base);
	// 821D85DC: D3FF0000  stfs f31, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821D85E0: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 821D85E4: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821D85E8: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 821D85EC: 4082FFD4  bne 0x821d85c0
	if !ctx.cr[0].eq {
	pc = 0x821D85C0; continue 'dispatch;
	}
	// 821D85F0: 395D0C30  addi r10, r29, 0xc30
	ctx.r[10].s64 = ctx.r[29].s64 + 3120;
	// 821D85F4: 397D0010  addi r11, r29, 0x10
	ctx.r[11].s64 = ctx.r[29].s64 + 16;
	// 821D85F8: 392000C2  li r9, 0xc2
	ctx.r[9].s64 = 194;
	// 821D85FC: 390100C4  addi r8, r1, 0xc4
	ctx.r[8].s64 = ctx.r[1].s64 + 196;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D8658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D8658 size=2128
    let mut pc: u32 = 0x821D8658;
    'dispatch: loop {
        match pc {
            0x821D8658 => {
    //   block [0x821D8658..0x821D8EA8)
	// 821D8658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D865C: 48AD0D9D  bl 0x82ca93f8
	ctx.lr = 0x821D8660;
	sub_82CA93D0(ctx, base);
	// 821D8660: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 821D8664: 48AD5675  bl 0x82cadcd8
	ctx.lr = 0x821D8668;
	sub_82CADCA0(ctx, base);
	// 821D8668: 3980FF80  li r12, -0x80
	ctx.r[12].s64 = -128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D8EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D8EA8 size=844
    let mut pc: u32 = 0x821D8EA8;
    'dispatch: loop {
        match pc {
            0x821D8EA8 => {
    //   block [0x821D8EA8..0x821D8EE8)
	// 821D8EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D8EAC: 48AD0545  bl 0x82ca93f0
	ctx.lr = 0x821D8EB0;
	sub_82CA93D0(ctx, base);
	// 821D8EB0: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 821D8EB4: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 821D8EB8: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D8EBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D8EC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D8EC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D8EC8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D8ECC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D8ED0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D8ED4: 4E800421  bctrl
	ctx.lr = 0x821D8ED8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D8ED8: 2F030006  cmpwi cr6, r3, 6
	ctx.cr[6].compare_i32(ctx.r[3].s32, 6, &mut ctx.xer);
	// 821D8EDC: 419A000C  beq cr6, 0x821d8ee8
	if ctx.cr[6].eq {
	pc = 0x821D8EE8; continue 'dispatch;
	}
	// 821D8EE0: 2F030024  cmpwi cr6, r3, 0x24
	ctx.cr[6].compare_i32(ctx.r[3].s32, 36, &mut ctx.xer);
	// 821D8EE4: 409A0300  bne cr6, 0x821d91e4
	if !ctx.cr[6].eq {
	pc = 0x821D91E4; continue 'dispatch;
	}
            }
            0x821D8EE8 => {
    //   block [0x821D8EE8..0x821D8F04)
	// 821D8EE8: 815F00F0  lwz r10, 0xf0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 821D8EEC: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 821D8EF0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D8EF4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821D8EF8: 419A000C  beq cr6, 0x821d8f04
	if ctx.cr[6].eq {
	pc = 0x821D8F04; continue 'dispatch;
	}
	// 821D8EFC: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 821D8F00: 917F00F0  stw r11, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	pc = 0x821D8F04; continue 'dispatch;
            }
            0x821D8F04 => {
    //   block [0x821D8F04..0x821D8F30)
	// 821D8F04: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D8F08: 917F00F4  stw r11, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 821D8F0C: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D8F10: 915F00B0  stw r10, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 821D8F14: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D8F18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D8F1C: 409A0024  bne cr6, 0x821d8f40
	if !ctx.cr[6].eq {
	pc = 0x821D8F40; continue 'dispatch;
	}
	// 821D8F20: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D8F24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D8F28: 419A0008  beq cr6, 0x821d8f30
	if ctx.cr[6].eq {
	pc = 0x821D8F30; continue 'dispatch;
	}
	// 821D8F2C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x821D8F30; continue 'dispatch;
            }
            0x821D8F30 => {
    //   block [0x821D8F30..0x821D8F40)
	// 821D8F30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D8F34: 409A000C  bne cr6, 0x821d8f40
	if !ctx.cr[6].eq {
	pc = 0x821D8F40; continue 'dispatch;
	}
	// 821D8F38: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821D8F3C: 48000054  b 0x821d8f90
	pc = 0x821D8F90; continue 'dispatch;
            }
            0x821D8F40 => {
    //   block [0x821D8F40..0x821D8F60)
	// 821D8F40: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D8F44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D8F48: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821D8F4C: 419A0024  beq cr6, 0x821d8f70
	if ctx.cr[6].eq {
	pc = 0x821D8F70; continue 'dispatch;
	}
	// 821D8F50: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821D8F54: 419A000C  beq cr6, 0x821d8f60
	if ctx.cr[6].eq {
	pc = 0x821D8F60; continue 'dispatch;
	}
	// 821D8F58: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 821D8F5C: 409A0024  bne cr6, 0x821d8f80
	if !ctx.cr[6].eq {
	pc = 0x821D8F80; continue 'dispatch;
	}
	pc = 0x821D8F60; continue 'dispatch;
            }
            0x821D8F60 => {
    //   block [0x821D8F60..0x821D8F70)
	// 821D8F60: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D8F64: 396B0003  addi r11, r11, 3
	ctx.r[11].s64 = ctx.r[11].s64 + 3;
	// 821D8F68: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821D8F6C: 48000014  b 0x821d8f80
	pc = 0x821D8F80; continue 'dispatch;
            }
            0x821D8F70 => {
    //   block [0x821D8F70..0x821D8F80)
	// 821D8F70: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 821D8F74: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D8F78: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821D8F7C: 556B2036  slwi r11, r11, 4
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	pc = 0x821D8F80; continue 'dispatch;
            }
            0x821D8F80 => {
    //   block [0x821D8F80..0x821D8F90)
	// 821D8F80: 7D6B00D0  neg r11, r11
	ctx.r[11].s64 = -ctx.r[11].s64;
	// 821D8F84: 7D6AFE70  srawi r10, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 821D8F88: 7D495838  and r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 & ctx.r[11].u64;
	// 821D8F8C: 7D4900D0  neg r10, r9
	ctx.r[10].s64 = -ctx.r[9].s64;
	pc = 0x821D8F90; continue 'dispatch;
            }
            0x821D8F90 => {
    //   block [0x821D8F90..0x821D91E4)
	// 821D8F90: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821D8F94: 915F00F8  stw r10, 0xf8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), ctx.r[10].u32 ) };
	// 821D8F98: 3BBE0020  addi r29, r30, 0x20
	ctx.r[29].s64 = ctx.r[30].s64 + 32;
	// 821D8F9C: 3B8B92D4  addi r28, r11, -0x6d2c
	ctx.r[28].s64 = ctx.r[11].s64 + -27948;
	// 821D8FA0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821D8FA4: 3B7D0010  addi r27, r29, 0x10
	ctx.r[27].s64 = ctx.r[29].s64 + 16;
	// 821D8FA8: 3B5D0004  addi r26, r29, 4
	ctx.r[26].s64 = ctx.r[29].s64 + 4;
	// 821D8FAC: 397F0050  addi r11, r31, 0x50
	ctx.r[11].s64 = ctx.r[31].s64 + 80;
	// 821D8FB0: C3FC01B0  lfs f31, 0x1b0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(432 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821D8FB4: 39210054  addi r9, r1, 0x54
	ctx.r[9].s64 = ctx.r[1].s64 + 84;
	// 821D8FB8: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821D8FBC: 3B1D000C  addi r24, r29, 0xc
	ctx.r[24].s64 = ctx.r[29].s64 + 12;
	pc = 0x821D91E4; continue 'dispatch;
            }
            0x821D91E4 => {
    //   block [0x821D91E4..0x821D91F4)
	// 821D91E4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821D91E8: CBC1FF98  lfd f30, -0x68(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 821D91EC: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 821D91F0: 48AD0250  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D91F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D91F8 size=12
    let mut pc: u32 = 0x821D91F8;
    'dispatch: loop {
        match pc {
            0x821D91F8 => {
    //   block [0x821D91F8..0x821D9204)
	// 821D91F8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821D91FC: 386BC7F0  addi r3, r11, -0x3810
	ctx.r[3].s64 = ctx.r[11].s64 + -14352;
	// 821D9200: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D9208 size=100
    let mut pc: u32 = 0x821D9208;
    'dispatch: loop {
        match pc {
            0x821D9208 => {
    //   block [0x821D9208..0x821D9260)
	// 821D9208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D920C: 48AD0201  bl 0x82ca940c
	ctx.lr = 0x821D9210;
	sub_82CA93D0(ctx, base);
	// 821D9210: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9214: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D9218: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D921C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D9220: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9224: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D9228: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821D922C: 4E800421  bctrl
	ctx.lr = 0x821D9230;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D9230: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9234: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D9238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D923C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D9240: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821D9244: 4E800421  bctrl
	ctx.lr = 0x821D9248;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D9248: 7F1D1840  cmplw cr6, r29, r3
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821D924C: 409A0014  bne cr6, 0x821d9260
	if !ctx.cr[6].eq {
	pc = 0x821D9260; continue 'dispatch;
	}
	// 821D9250: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D9254: C01E0008  lfs f0, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D9258: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821D925C: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
            }
            0x821D9260 => {
    //   block [0x821D9260..0x821D926C)
	// 821D9260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D9264: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D9268: 48AD01F4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9270 size=916
    let mut pc: u32 = 0x821D9270;
    'dispatch: loop {
        match pc {
            0x821D9270 => {
    //   block [0x821D9270..0x821D92A8)
	// 821D9270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9274: 48AD0189  bl 0x82ca93fc
	ctx.lr = 0x821D9278;
	sub_82CA93D0(ctx, base);
	// 821D9278: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D927C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821D9280: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821D9284: 387C0028  addi r3, r28, 0x28
	ctx.r[3].s64 = ctx.r[28].s64 + 40;
	// 821D9288: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 821D928C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821D9290: 4BFD9269  bl 0x821b24f8
	ctx.lr = 0x821D9294;
	sub_821B24F8(ctx, base);
	// 821D9294: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821D9298: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821D929C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821D92A0: 419A0008  beq cr6, 0x821d92a8
	if ctx.cr[6].eq {
	pc = 0x821D92A8; continue 'dispatch;
	}
	// 821D92A4: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x821D92A8; continue 'dispatch;
            }
            0x821D92A8 => {
    //   block [0x821D92A8..0x821D92E8)
	// 821D92A8: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D92AC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 821D92B0: 8145002C  lwz r10, 0x2c(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D92B4: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 821D92B8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821D92BC: 419A00E8  beq cr6, 0x821d93a4
	if ctx.cr[6].eq {
	pc = 0x821D93A4; continue 'dispatch;
	}
	// 821D92C0: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 821D92C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D92C8: 419A0020  beq cr6, 0x821d92e8
	if ctx.cr[6].eq {
	pc = 0x821D92E8; continue 'dispatch;
	}
	// 821D92CC: 894B005B  lbz r10, 0x5b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(91 as u32) ) } as u64;
	// 821D92D0: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D92D4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821D92D8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D92DC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821D92E0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D92E4: 480000C4  b 0x821d93a8
	pc = 0x821D93A8; continue 'dispatch;
            }
            0x821D92E8 => {
    //   block [0x821D92E8..0x821D9304)
	// 821D92E8: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D92EC: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 821D92F0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821D92F4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821D92F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821D92FC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D9300: 40810054  ble 0x821d9354
	if !ctx.cr[0].gt {
	pc = 0x821D9354; continue 'dispatch;
	}
	pc = 0x821D9304; continue 'dispatch;
            }
            0x821D9304 => {
    //   block [0x821D9304..0x821D9324)
	// 821D9304: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821D9308: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821D930C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821D9310: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9314: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 821D9318: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821D931C: 41980008  blt cr6, 0x821d9324
	if ctx.cr[6].lt {
	pc = 0x821D9324; continue 'dispatch;
	}
	// 821D9320: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x821D9324; continue 'dispatch;
            }
            0x821D9324 => {
    //   block [0x821D9324..0x821D9340)
	// 821D9324: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821D9328: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D932C: 419A0014  beq cr6, 0x821d9340
	if ctx.cr[6].eq {
	pc = 0x821D9340; continue 'dispatch;
	}
	// 821D9330: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821D9334: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D9338: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821D933C: 4800000C  b 0x821d9348
	pc = 0x821D9348; continue 'dispatch;
            }
            0x821D9340 => {
    //   block [0x821D9340..0x821D9348)
	// 821D9340: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821D9344: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821D9348; continue 'dispatch;
            }
            0x821D9348 => {
    //   block [0x821D9348..0x821D9354)
	// 821D9348: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D934C: 4199FFB8  bgt cr6, 0x821d9304
	if ctx.cr[6].gt {
	pc = 0x821D9304; continue 'dispatch;
	}
	// 821D9350: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821D9354; continue 'dispatch;
            }
            0x821D9354 => {
    //   block [0x821D9354..0x821D9370)
	// 821D9354: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821D9358: 419A003C  beq cr6, 0x821d9394
	if ctx.cr[6].eq {
	pc = 0x821D9394; continue 'dispatch;
	}
	// 821D935C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9360: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 821D9364: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821D9368: 41990008  bgt cr6, 0x821d9370
	if ctx.cr[6].gt {
	pc = 0x821D9370; continue 'dispatch;
	}
	// 821D936C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821D9370; continue 'dispatch;
            }
            0x821D9370 => {
    //   block [0x821D9370..0x821D9394)
	// 821D9370: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821D9374: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D9378: 409A001C  bne cr6, 0x821d9394
	if !ctx.cr[6].eq {
	pc = 0x821D9394; continue 'dispatch;
	}
	// 821D937C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D9380: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821D9384: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821D9388: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D938C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9390: 48000018  b 0x821d93a8
	pc = 0x821D93A8; continue 'dispatch;
            }
            0x821D9394 => {
    //   block [0x821D9394..0x821D93A4)
	// 821D9394: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821D9398: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821D939C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D93A0: 48000008  b 0x821d93a8
	pc = 0x821D93A8; continue 'dispatch;
            }
            0x821D93A4 => {
    //   block [0x821D93A4..0x821D93A8)
	// 821D93A4: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x821D93A8; continue 'dispatch;
            }
            0x821D93A8 => {
    //   block [0x821D93A8..0x821D940C)
	// 821D93A8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821D93AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D93B0: 419A012C  beq cr6, 0x821d94dc
	if ctx.cr[6].eq {
	pc = 0x821D94DC; continue 'dispatch;
	}
	// 821D93B4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821D93B8: 4803B741  bl 0x82214af8
	ctx.lr = 0x821D93BC;
	sub_82214AF8(ctx, base);
	// 821D93BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D93C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D93C4: 409A0118  bne cr6, 0x821d94dc
	if !ctx.cr[6].eq {
	pc = 0x821D94DC; continue 'dispatch;
	}
	// 821D93C8: 81650028  lwz r11, 0x28(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) } as u64;
	// 821D93CC: 556A07FE  clrlwi r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821D93D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D93D4: 409A0108  bne cr6, 0x821d94dc
	if !ctx.cr[6].eq {
	pc = 0x821D94DC; continue 'dispatch;
	}
	// 821D93D8: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 821D93DC: 397C0048  addi r11, r28, 0x48
	ctx.r[11].s64 = ctx.r[28].s64 + 72;
	// 821D93E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D93E4: 419A0040  beq cr6, 0x821d9424
	if ctx.cr[6].eq {
	pc = 0x821D9424; continue 'dispatch;
	}
	// 821D93E8: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D93EC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821D93F0: 419A0034  beq cr6, 0x821d9424
	if ctx.cr[6].eq {
	pc = 0x821D9424; continue 'dispatch;
	}
	// 821D93F4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D93F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D93FC: 409A0010  bne cr6, 0x821d940c
	if !ctx.cr[6].eq {
	pc = 0x821D940C; continue 'dispatch;
	}
	// 821D9400: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821D9404: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 821D9408: 48000008  b 0x821d9410
	pc = 0x821D9410; continue 'dispatch;
            }
            0x821D940C => {
    //   block [0x821D940C..0x821D9410)
	// 821D940C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821D9410; continue 'dispatch;
            }
            0x821D9410 => {
    //   block [0x821D9410..0x821D9424)
	// 821D9410: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821D9414: 480D05D5  bl 0x822a99e8
	ctx.lr = 0x821D9418;
	sub_822A99E8(ctx, base);
	// 821D9418: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D941C: 419A0008  beq cr6, 0x821d9424
	if ctx.cr[6].eq {
	pc = 0x821D9424; continue 'dispatch;
	}
	// 821D9420: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	pc = 0x821D9424; continue 'dispatch;
            }
            0x821D9424 => {
    //   block [0x821D9424..0x821D944C)
	// 821D9424: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821D9428: 419A0094  beq cr6, 0x821d94bc
	if ctx.cr[6].eq {
	pc = 0x821D94BC; continue 'dispatch;
	}
	// 821D942C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 821D9430: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D9434: 389C0044  addi r4, r28, 0x44
	ctx.r[4].s64 = ctx.r[28].s64 + 68;
	// 821D9438: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821D943C: 4867BFE5  bl 0x82855420
	ctx.lr = 0x821D9440;
	sub_82855420(ctx, base);
	// 821D9440: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D9444: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821D9448: 409A0088  bne cr6, 0x821d94d0
	if !ctx.cr[6].eq {
	pc = 0x821D94D0; continue 'dispatch;
	}
	pc = 0x821D944C; continue 'dispatch;
            }
            0x821D944C => {
    //   block [0x821D944C..0x821D94BC)
	// 821D944C: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 821D9450: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D9454: 419A007C  beq cr6, 0x821d94d0
	if ctx.cr[6].eq {
	pc = 0x821D94D0; continue 'dispatch;
	}
	// 821D9458: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D945C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821D9460: 3BCB0E20  addi r30, r11, 0xe20
	ctx.r[30].s64 = ctx.r[11].s64 + 3616;
	// 821D9464: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D9468: 480C1D51  bl 0x8229b1b8
	ctx.lr = 0x821D946C;
	sub_8229B1B8(ctx, base);
	// 821D946C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D9470: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D9474: 419A005C  beq cr6, 0x821d94d0
	if ctx.cr[6].eq {
	pc = 0x821D94D0; continue 'dispatch;
	}
	// 821D9478: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D947C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821D9480: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D9484: 48053A4D  bl 0x8222ced0
	ctx.lr = 0x821D9488;
	sub_8222CED0(ctx, base);
	// 821D9488: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 821D948C: 419A0038  beq cr6, 0x821d94c4
	if ctx.cr[6].eq {
	pc = 0x821D94C4; continue 'dispatch;
	}
	// 821D9490: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 821D9494: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D9498: 389C0044  addi r4, r28, 0x44
	ctx.r[4].s64 = ctx.r[28].s64 + 68;
	// 821D949C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D94A0: 4867BF81  bl 0x82855420
	ctx.lr = 0x821D94A4;
	sub_82855420(ctx, base);
	// 821D94A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D94A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D94AC: 4803B92D  bl 0x82214dd8
	ctx.lr = 0x821D94B0;
	sub_82214DD8(ctx, base);
	// 821D94B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D94B4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821D94B8: 48ACFF94  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821D94BC => {
    //   block [0x821D94BC..0x821D94C4)
	// 821D94BC: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821D94C0: 4BFFFF8C  b 0x821d944c
	pc = 0x821D944C; continue 'dispatch;
            }
            0x821D94C4 => {
    //   block [0x821D94C4..0x821D94D0)
	// 821D94C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D94C8: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821D94CC: 4803B90D  bl 0x82214dd8
	ctx.lr = 0x821D94D0;
	sub_82214DD8(ctx, base);
	pc = 0x821D94D0; continue 'dispatch;
            }
            0x821D94D0 => {
    //   block [0x821D94D0..0x821D94DC)
	// 821D94D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D94D4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821D94D8: 48ACFF74  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821D94DC => {
    //   block [0x821D94DC..0x821D9508)
	// 821D94DC: 38A00009  li r5, 9
	ctx.r[5].s64 = 9;
	// 821D94E0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821D94E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D94E8: 4805CCF1  bl 0x822361d8
	ctx.lr = 0x821D94EC;
	sub_822361D8(ctx, base);
	// 821D94EC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821D94F0: 813C0018  lwz r9, 0x18(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 821D94F4: 397C0014  addi r11, r28, 0x14
	ctx.r[11].s64 = ctx.r[28].s64 + 20;
	// 821D94F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D94FC: 419A000C  beq cr6, 0x821d9508
	if ctx.cr[6].eq {
	pc = 0x821D9508; continue 'dispatch;
	}
	// 821D9500: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D9504: 419A0008  beq cr6, 0x821d950c
	if ctx.cr[6].eq {
	pc = 0x821D950C; continue 'dispatch;
	}
	pc = 0x821D9508; continue 'dispatch;
            }
            0x821D9508 => {
    //   block [0x821D9508..0x821D950C)
	// 821D9508: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D950C; continue 'dispatch;
            }
            0x821D950C => {
    //   block [0x821D950C..0x821D9524)
	// 821D950C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D9510: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821D9514: 419A0054  beq cr6, 0x821d9568
	if ctx.cr[6].eq {
	pc = 0x821D9568; continue 'dispatch;
	}
	// 821D9518: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D951C: 409A0008  bne cr6, 0x821d9524
	if !ctx.cr[6].eq {
	pc = 0x821D9524; continue 'dispatch;
	}
	// 821D9520: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D9524; continue 'dispatch;
            }
            0x821D9524 => {
    //   block [0x821D9524..0x821D9534)
	// 821D9524: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9528: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D952C: 409A0008  bne cr6, 0x821d9534
	if !ctx.cr[6].eq {
	pc = 0x821D9534; continue 'dispatch;
	}
	// 821D9530: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D9534; continue 'dispatch;
            }
            0x821D9534 => {
    //   block [0x821D9534..0x821D9550)
	// 821D9534: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D9538: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D953C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D9540: 409A0010  bne cr6, 0x821d9550
	if !ctx.cr[6].eq {
	pc = 0x821D9550; continue 'dispatch;
	}
	// 821D9544: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821D9548: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 821D954C: 48000008  b 0x821d9554
	pc = 0x821D9554; continue 'dispatch;
            }
            0x821D9550 => {
    //   block [0x821D9550..0x821D9554)
	// 821D9550: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821D9554; continue 'dispatch;
            }
            0x821D9554 => {
    //   block [0x821D9554..0x821D9568)
	// 821D9554: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821D9558: 480D0491  bl 0x822a99e8
	ctx.lr = 0x821D955C;
	sub_822A99E8(ctx, base);
	// 821D955C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D9560: 419A0008  beq cr6, 0x821d9568
	if ctx.cr[6].eq {
	pc = 0x821D9568; continue 'dispatch;
	}
	// 821D9564: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	pc = 0x821D9568; continue 'dispatch;
            }
            0x821D9568 => {
    //   block [0x821D9568..0x821D959C)
	// 821D9568: 807C0020  lwz r3, 0x20(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D956C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D9570: 419A002C  beq cr6, 0x821d959c
	if ctx.cr[6].eq {
	pc = 0x821D959C; continue 'dispatch;
	}
	// 821D9574: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9578: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821D957C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821D9580: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821D9584: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9588: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D958C: 4E800421  bctrl
	ctx.lr = 0x821D9590;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D9590: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D9594: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821D9598: 409A0060  bne cr6, 0x821d95f8
	if !ctx.cr[6].eq {
	pc = 0x821D95F8; continue 'dispatch;
	}
            }
            0x821D959C => {
    //   block [0x821D959C..0x821D95F8)
	// 821D959C: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 821D95A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D95A4: 419A0054  beq cr6, 0x821d95f8
	if ctx.cr[6].eq {
	pc = 0x821D95F8; continue 'dispatch;
	}
	// 821D95A8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D95AC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821D95B0: 3BEB0E20  addi r31, r11, 0xe20
	ctx.r[31].s64 = ctx.r[11].s64 + 3616;
	// 821D95B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D95B8: 480C1C01  bl 0x8229b1b8
	ctx.lr = 0x821D95BC;
	sub_8229B1B8(ctx, base);
	// 821D95BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D95C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D95C4: 419A0034  beq cr6, 0x821d95f8
	if ctx.cr[6].eq {
	pc = 0x821D95F8; continue 'dispatch;
	}
	// 821D95C8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D95CC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821D95D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D95D4: 480538FD  bl 0x8222ced0
	ctx.lr = 0x821D95D8;
	sub_8222CED0(ctx, base);
	// 821D95D8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821D95DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D95E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821D95E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821D95E8: 4BFFFC89  bl 0x821d9270
	ctx.lr = 0x821D95EC;
	sub_821D9270(ctx, base);
	// 821D95EC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821D95F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D95F4: 4803B7E5  bl 0x82214dd8
	ctx.lr = 0x821D95F8;
	sub_82214DD8(ctx, base);
	pc = 0x821D95F8; continue 'dispatch;
            }
            0x821D95F8 => {
    //   block [0x821D95F8..0x821D9604)
	// 821D95F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821D95FC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821D9600: 48ACFE4C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9608 size=248
    let mut pc: u32 = 0x821D9608;
    'dispatch: loop {
        match pc {
            0x821D9608 => {
    //   block [0x821D9608..0x821D9668)
	// 821D9608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D960C: 48ACFDF5  bl 0x82ca9400
	ctx.lr = 0x821D9610;
	sub_82CA93D0(ctx, base);
	// 821D9610: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9614: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821D9618: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D961C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821D9620: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 821D9624: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 821D9628: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D962C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D9630: 409A0038  bne cr6, 0x821d9668
	if !ctx.cr[6].eq {
	pc = 0x821D9668; continue 'dispatch;
	}
	// 821D9634: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9638: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D963C: 837C6D9C  lwz r27, 0x6d9c(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28060 as u32) ) } as u64;
	// 821D9640: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821D9644: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9648: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821D964C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821D9650: 4E800421  bctrl
	ctx.lr = 0x821D9654;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D9654: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821D9658: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
            }
            0x821D9668 => {
    //   block [0x821D9668..0x821D9700)
	// 821D9668: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D966C: 554B07BC  rlwinm r11, r10, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821D9670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D9674: 419A0074  beq cr6, 0x821d96e8
	if ctx.cr[6].eq {
	pc = 0x821D96E8; continue 'dispatch;
	}
	// 821D9678: 817C6D9C  lwz r11, 0x6d9c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28060 as u32) ) } as u64;
	// 821D967C: 555C07FE  clrlwi r28, r10, 0x1f
	ctx.r[28].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821D9680: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D9684: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D9688: 480AE759  bl 0x82287de0
	ctx.lr = 0x821D968C;
	sub_82287DE0(ctx, base);
	// 821D968C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D9690: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D9694: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 821D9698: 419A003C  beq cr6, 0x821d96d4
	if ctx.cr[6].eq {
	pc = 0x821D96D4; continue 'dispatch;
	}
	// 821D969C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D96A0: 419A0010  beq cr6, 0x821d96b0
	if ctx.cr[6].eq {
	pc = 0x821D96B0; continue 'dispatch;
	}
	// 821D96A4: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821D96A8: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 821D96AC: 4BFE6F9D  bl 0x821c0648
	ctx.lr = 0x821D96B0;
	sub_821C0648(ctx, base);
	// 821D96B0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821D96B4: 809D002C  lwz r4, 0x2c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 821D96B8: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 821D96BC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821D96C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D96C4: 48007885  bl 0x821e0f48
	ctx.lr = 0x821D96C8;
	sub_821E0F48(ctx, base);
	// 821D96C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D96CC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821D96D0: 48ACFD80  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
	// 821D96D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D96D8: 419A0010  beq cr6, 0x821d96e8
	if ctx.cr[6].eq {
	pc = 0x821D96E8; continue 'dispatch;
	}
	// 821D96DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821D96E0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 821D96E4: 4BFE6F65  bl 0x821c0648
	ctx.lr = 0x821D96E8;
	sub_821C0648(ctx, base);
	// 821D96E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D96EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D96F0: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821D96F4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821D96F8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821D96FC: 48ACFD54  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9700 size=128
    let mut pc: u32 = 0x821D9700;
    'dispatch: loop {
        match pc {
            0x821D9700 => {
    //   block [0x821D9700..0x821D9768)
	// 821D9700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9704: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D9708: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D970C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D9710: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9714: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D9718: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821D971C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821D9720: 392B0DC0  addi r9, r11, 0xdc0
	ctx.r[9].s64 = ctx.r[11].s64 + 3520;
	// 821D9724: 386A6354  addi r3, r10, 0x6354
	ctx.r[3].s64 = ctx.r[10].s64 + 25428;
	// 821D9728: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D972C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D9730: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D9734: 809F0010  lwz r4, 0x10(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D9738: 480001F9  bl 0x821d9930
	ctx.lr = 0x821D973C;
	sub_821D9930(ctx, base);
	// 821D973C: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 821D9740: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821D9744: 38C80FD0  addi r6, r8, 0xfd0
	ctx.r[6].s64 = ctx.r[8].s64 + 4048;
	// 821D9748: 57C507FE  clrlwi r5, r30, 0x1f
	ctx.r[5].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 821D974C: 90FF0010  stw r7, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 821D9750: 90DF0000  stw r6, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 821D9754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D9758: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821D975C: 419A000C  beq cr6, 0x821d9768
	if ctx.cr[6].eq {
	pc = 0x821D9768; continue 'dispatch;
	}
	// 821D9760: 480425D9  bl 0x8221bd38
	ctx.lr = 0x821D9764;
	sub_8221BD38(ctx, base);
	// 821D9764: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x821D9768; continue 'dispatch;
            }
            0x821D9768 => {
    //   block [0x821D9768..0x821D9780)
	// 821D9768: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D976C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D9770: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D9774: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D9778: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D977C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9780 size=312
    let mut pc: u32 = 0x821D9780;
    'dispatch: loop {
        match pc {
            0x821D9780 => {
    //   block [0x821D9780..0x821D98B8)
	// 821D9780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D9788: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D978C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821D9790: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 821D9794: 48E2D241  bl 0x830069d4
	ctx.lr = 0x821D9798;
	sub_83006760(ctx, base);
	// 821D9798: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D979C: 1002084A  vsubfp v0, v2, v1
	ctx.fpscr.enable_flush_mode_unconditional();
	for i in 0..4 {
		ctx.v[0].f32[i] = ctx.v[2].f32[i] - ctx.v[1].f32[i];
	}
	// 821D97A0: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821D97A4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D98B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D98B8 size=76
    let mut pc: u32 = 0x821D98B8;
    'dispatch: loop {
        match pc {
            0x821D98B8 => {
    //   block [0x821D98B8..0x821D9904)
	// 821D98B8: 39630070  addi r11, r3, 0x70
	ctx.r[11].s64 = ctx.r[3].s64 + 112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D9908 size=32
    let mut pc: u32 = 0x821D9908;
    'dispatch: loop {
        match pc {
            0x821D9908 => {
    //   block [0x821D9908..0x821D9928)
	// 821D9908: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 821D990C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821D9910: 409A0018  bne cr6, 0x821d9928
	if !ctx.cr[6].eq {
		sub_821D9928(ctx, base);
		return;
	}
	// 821D9914: 80630038  lwz r3, 0x38(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 821D9918: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D991C: 814B0034  lwz r10, 0x34(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821D9920: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D9924: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821D9928 size=8
    let mut pc: u32 = 0x821D9928;
    'dispatch: loop {
        match pc {
            0x821D9928 => {
    //   block [0x821D9928..0x821D9930)
	// 821D9928: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821D992C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9930 size=360
    let mut pc: u32 = 0x821D9930;
    'dispatch: loop {
        match pc {
            0x821D9930 => {
    //   block [0x821D9930..0x821D99CC)
	// 821D9930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9934: 48ACFACD  bl 0x82ca9400
	ctx.lr = 0x821D9938;
	sub_82CA93D0(ctx, base);
	// 821D9938: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D993C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821D9940: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821D9944: 3BEB6354  addi r31, r11, 0x6354
	ctx.r[31].s64 = ctx.r[11].s64 + 25428;
	// 821D9948: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821D994C: 934100CC  stw r26, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[26].u32 ) };
	// 821D9950: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D9954: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821D9958: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 821D995C: 48026E15  bl 0x82200770
	ctx.lr = 0x821D9960;
	sub_82200770(ctx, base);
	// 821D9960: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9964: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D9968: 395B0007  addi r10, r27, 7
	ctx.r[10].s64 = ctx.r[27].s64 + 7;
	// 821D996C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821D9970: 7D2B2850  subf r9, r11, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821D9974: 555DE8FE  srwi r29, r10, 3
	ctx.r[29].u32 = ctx.r[10].u32.wrapping_shr(3);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821D9978: 7D282670  srawi r8, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 821D997C: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821D9980: 41980080  blt cr6, 0x821d9a00
	if ctx.cr[6].lt {
	pc = 0x821D9A00; continue 'dispatch;
	}
	// 821D9984: 7D2B2850  subf r9, r11, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821D9988: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 821D998C: 395D0001  addi r10, r29, 1
	ctx.r[10].s64 = ctx.r[29].s64 + 1;
	// 821D9990: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 821D9994: 7D282670  srawi r8, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 821D9998: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 821D999C: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D99A0: 4098002C  bge cr6, 0x821d99cc
	if !ctx.cr[6].lt {
	pc = 0x821D99CC; continue 'dispatch;
	}
	// 821D99A4: 7D6B2850  subf r11, r11, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821D99A8: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 821D99AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D99B0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821D99B4: 7D692670  srawi r9, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 821D99B8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D99BC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 821D99C0: 7CA95050  subf r5, r9, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821D99C4: 48999F1D  bl 0x82b738e0
	ctx.lr = 0x821D99C8;
	sub_82B738E0(ctx, base);
	// 821D99C8: 48000034  b 0x821d99fc
	pc = 0x821D99FC; continue 'dispatch;
            }
            0x821D99CC => {
    //   block [0x821D99CC..0x821D99FC)
	// 821D99CC: 7D2B2850  subf r9, r11, r5
	ctx.r[9].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821D99D0: 7D282670  srawi r8, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 821D99D4: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821D99D8: 40980028  bge cr6, 0x821d9a00
	if !ctx.cr[6].lt {
	pc = 0x821D9A00; continue 'dispatch;
	}
	// 821D99DC: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D99E0: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D99E4: 7F1E2840  cmplw cr6, r30, r5
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821D99E8: 419A0018  beq cr6, 0x821d9a00
	if ctx.cr[6].eq {
	pc = 0x821D9A00; continue 'dispatch;
	}
	// 821D99EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D99F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D99F4: 4894E365  bl 0x82b27d58
	ctx.lr = 0x821D99F8;
	sub_82B27D58(ctx, base);
	// 821D99F8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x821D99FC; continue 'dispatch;
            }
            0x821D99FC => {
    //   block [0x821D99FC..0x821D9A00)
	// 821D99FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x821D9A00; continue 'dispatch;
            }
            0x821D9A00 => {
    //   block [0x821D9A00..0x821D9A1C)
	// 821D9A00: 57AA2036  slwi r10, r29, 4
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D9A04: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821D9A08: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9A0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821D9A10: 409A000C  bne cr6, 0x821d9a1c
	if !ctx.cr[6].eq {
	pc = 0x821D9A1C; continue 'dispatch;
	}
	// 821D9A14: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 821D9A18: 48000010  b 0x821d9a28
	pc = 0x821D9A28; continue 'dispatch;
            }
            0x821D9A1C => {
    //   block [0x821D9A1C..0x821D9A28)
	// 821D9A1C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D9A20: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D9A24: 7D291670  srawi r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x821D9A28; continue 'dispatch;
            }
            0x821D9A28 => {
    //   block [0x821D9A28..0x821D9A4C)
	// 821D9A28: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D9A2C: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821D9A30: 7D481670  srawi r8, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 821D9A34: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821D9A38: 40980014  bge cr6, 0x821d9a4c
	if !ctx.cr[6].lt {
	pc = 0x821D9A4C; continue 'dispatch;
	}
	// 821D9A3C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 821D9A40: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 821D9A44: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821D9A48: 4800001C  b 0x821d9a64
	pc = 0x821D9A64; continue 'dispatch;
            }
            0x821D9A4C => {
    //   block [0x821D9A4C..0x821D9A64)
	// 821D9A4C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821D9A50: 38C100CC  addi r6, r1, 0xcc
	ctx.r[6].s64 = ctx.r[1].s64 + 204;
	// 821D9A54: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821D9A58: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821D9A5C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821D9A60: 489A67E1  bl 0x82b80240
	ctx.lr = 0x821D9A64;
	sub_82B80240(ctx, base);
	pc = 0x821D9A64; continue 'dispatch;
            }
            0x821D9A64 => {
    //   block [0x821D9A64..0x821D9A90)
	// 821D9A64: 576A083C  slwi r10, r27, 1
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D9A68: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821D9A6C: 88E1005C  lbz r7, 0x5c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821D9A70: 7D1B5214  add r8, r27, r10
	ctx.r[8].u64 = ctx.r[27].u64 + ctx.r[10].u64;
	// 821D9A74: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821D9A78: 55062036  slwi r6, r8, 4
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821D9A7C: 7D665850  subf r11, r6, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 821D9A80: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 821D9A84: 419A000C  beq cr6, 0x821d9a90
	if ctx.cr[6].eq {
	pc = 0x821D9A90; continue 'dispatch;
	}
	// 821D9A88: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821D9A8C: 490DFEC9  bl 0x832b9954
	ctx.lr = 0x821D9A90;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x821D9A90; continue 'dispatch;
            }
            0x821D9A90 => {
    //   block [0x821D9A90..0x821D9A98)
	// 821D9A90: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821D9A94: 48ACF9BC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9A98 size=340
    let mut pc: u32 = 0x821D9A98;
    'dispatch: loop {
        match pc {
            0x821D9A98 => {
    //   block [0x821D9A98..0x821D9BEC)
	// 821D9A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9A9C: 48ACF959  bl 0x82ca93f4
	ctx.lr = 0x821D9AA0;
	sub_82CA93D0(ctx, base);
	// 821D9AA0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9AA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D9AA8: 4BFDD5B9  bl 0x821b7060
	ctx.lr = 0x821D9AAC;
	sub_821B7060(ctx, base);
	// 821D9AAC: 3FC0834A  lis r30, -0x7cb6
	ctx.r[30].s64 = -2092302336;
	// 821D9AB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D9AB4: 809EF848  lwz r4, -0x7b8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1976 as u32) ) } as u64;
	// 821D9AB8: 480126E1  bl 0x821ec198
	ctx.lr = 0x821D9ABC;
	sub_821EC198(ctx, base);
	// 821D9ABC: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821D9AC0: 807EF848  lwz r3, -0x7b8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1976 as u32) ) } as u64;
	// 821D9AC4: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821D9AC8: 396B2390  addi r11, r11, 0x2390
	ctx.r[11].s64 = ctx.r[11].s64 + 9104;
	// 821D9ACC: 38AA7E70  addi r5, r10, 0x7e70
	ctx.r[5].s64 = ctx.r[10].s64 + 32368;
	// 821D9AD0: 3C808349  lis r4, -0x7cb7
	ctx.r[4].s64 = -2092367872;
	// 821D9AD4: 3D008332  lis r8, -0x7cce
	ctx.r[8].s64 = -2093875200;
	// 821D9AD8: 3BEB2008  addi r31, r11, 0x2008
	ctx.r[31].s64 = ctx.r[11].s64 + 8200;
	// 821D9ADC: 3B08A978  addi r24, r8, -0x5688
	ctx.r[24].s64 = ctx.r[8].s64 + -22152;
	// 821D9AE0: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821D9AE4: 3F608332  lis r27, -0x7cce
	ctx.r[27].s64 = -2093875200;
	// 821D9AE8: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 821D9AEC: 3FC08332  lis r30, -0x7cce
	ctx.r[30].s64 = -2093875200;
	// 821D9AF0: 3FA08332  lis r29, -0x7cce
	ctx.r[29].s64 = -2093875200;
	// 821D9AF4: 3F808332  lis r28, -0x7cce
	ctx.r[28].s64 = -2093875200;
	// 821D9AF8: 3F408332  lis r26, -0x7cce
	ctx.r[26].s64 = -2093875200;
	// 821D9AFC: 3F208332  lis r25, -0x7cce
	ctx.r[25].s64 = -2093875200;
	// 821D9B00: 3BDEA9CC  addi r30, r30, -0x5634
	ctx.r[30].s64 = ctx.r[30].s64 + -22068;
	// 821D9B04: 3BBDA9A8  addi r29, r29, -0x5658
	ctx.r[29].s64 = ctx.r[29].s64 + -22104;
	// 821D9B08: 3B9CAA38  addi r28, r28, -0x55c8
	ctx.r[28].s64 = ctx.r[28].s64 + -21960;
	// 821D9B0C: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 821D9B10: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 821D9B14: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821D9B18: 89296E22  lbz r9, 0x6e22(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(28194 as u32) ) } as u64;
	// 821D9B1C: 55471838  slwi r7, r10, 3
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821D9B20: 89446E23  lbz r10, 0x6e23(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(28195 as u32) ) } as u64;
	// 821D9B24: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 821D9B28: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821D9B2C: 9921007C  stb r9, 0x7c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[9].u8 ) };
	// 821D9B30: 7CA7592E  stwx r5, r7, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32), ctx.r[5].u32) };
	// 821D9B34: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821D9B38: 80CB2000  lwz r6, 0x2000(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821D9B3C: 810B400C  lwz r8, 0x400c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821D9B40: 55171838  slwi r23, r8, 3
	ctx.r[23].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[23].u64 = ctx.r[23].u32 as u64;
	// 821D9B44: 9941007D  stb r10, 0x7d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(125 as u32), ctx.r[10].u8 ) };
	// 821D9B48: 39070001  addi r8, r7, 1
	ctx.r[8].s64 = ctx.r[7].s64 + 1;
	// 821D9B4C: 54CA083C  slwi r10, r6, 1
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D9B50: 910B2004  stw r8, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	// 821D9B54: 391BA980  addi r8, r27, -0x5680
	ctx.r[8].s64 = ctx.r[27].s64 + -22144;
	// 821D9B58: 914B2000  stw r10, 0x2000(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8192 as u32), ctx.r[10].u32 ) };
	// 821D9B5C: 38FAA988  addi r7, r26, -0x5678
	ctx.r[7].s64 = ctx.r[26].s64 + -22136;
	// 821D9B60: 7CB7F92E  stwx r5, r23, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[23].u32.wrapping_add(ctx.r[31].u32), ctx.r[5].u32) };
	// 821D9B64: 3B79AA14  addi r27, r25, -0x55ec
	ctx.r[27].s64 = ctx.r[25].s64 + -21996;
	// 821D9B68: 814B400C  lwz r10, 0x400c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821D9B6C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821D9B70: 812B4008  lwz r9, 0x4008(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16392 as u32) ) } as u64;
	// 821D9B74: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821D9B78: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821D9B7C: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 821D9B80: 91010064  stw r8, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[8].u32 ) };
	// 821D9B84: 90E10068  stw r7, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[7].u32 ) };
	// 821D9B88: 914B400C  stw r10, 0x400c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16396 as u32), ctx.r[10].u32 ) };
	// 821D9B8C: 912B4008  stw r9, 0x4008(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16392 as u32), ctx.r[9].u32 ) };
	// 821D9B90: 98C10050  stb r6, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u8 ) };
	// 821D9B94: 4809CC4D  bl 0x822767e0
	ctx.lr = 0x821D9B98;
	sub_822767E0(ctx, base);
	// 821D9B98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D9B9C: 48045745  bl 0x8221f2e0
	ctx.lr = 0x821D9BA0;
	sub_8221F2E0(ctx, base);
	// 821D9BA0: 3FE0834A  lis r31, -0x7cb6
	ctx.r[31].s64 = -2092302336;
	// 821D9BA4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821D9BA8: 807FF9C0  lwz r3, -0x640(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821D9BAC: 4805D475  bl 0x82237020
	ctx.lr = 0x821D9BB0;
	sub_82237020(ctx, base);
	// 821D9BB0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821D9BB4: 807FF9C0  lwz r3, -0x640(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821D9BB8: 4805D469  bl 0x82237020
	ctx.lr = 0x821D9BBC;
	sub_82237020(ctx, base);
	// 821D9BBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D9BC0: 807FF9C0  lwz r3, -0x640(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821D9BC4: 4805D45D  bl 0x82237020
	ctx.lr = 0x821D9BC8;
	sub_82237020(ctx, base);
	// 821D9BC8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D9BCC: 807FF9C0  lwz r3, -0x640(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-1600 as u32) ) } as u64;
	// 821D9BD0: 4805D451  bl 0x82237020
	ctx.lr = 0x821D9BD4;
	sub_82237020(ctx, base);
	// 821D9BD4: 3CA08349  lis r5, -0x7cb7
	ctx.r[5].s64 = -2092367872;
	// 821D9BD8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D9BDC: 99656F24  stb r11, 0x6f24(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(28452 as u32), ctx.r[11].u8 ) };
	// 821D9BE0: 4BFDD481  bl 0x821b7060
	ctx.lr = 0x821D9BE4;
	sub_821B7060(ctx, base);
	// 821D9BE4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821D9BE8: 48ACF85C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9BF0 size=108
    let mut pc: u32 = 0x821D9BF0;
    'dispatch: loop {
        match pc {
            0x821D9BF0 => {
    //   block [0x821D9BF0..0x821D9C54)
	// 821D9BF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9BF4: 48ACF819  bl 0x82ca940c
	ctx.lr = 0x821D9BF8;
	sub_82CA93D0(ctx, base);
	// 821D9BF8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9BFC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821D9C00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D9C04: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9C08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821D9C0C: 419A0048  beq cr6, 0x821d9c54
	if ctx.cr[6].eq {
	pc = 0x821D9C54; continue 'dispatch;
	}
	// 821D9C10: 480225E1  bl 0x821fc1f0
	ctx.lr = 0x821D9C14;
	sub_821FC1F0(ctx, base);
	// 821D9C14: 387E0020  addi r3, r30, 0x20
	ctx.r[3].s64 = ctx.r[30].s64 + 32;
	// 821D9C18: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9C1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821D9C20: 4800EFE9  bl 0x821e8c08
	ctx.lr = 0x821D9C24;
	sub_821E8C08(ctx, base);
	// 821D9C24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D9C28: 480223E1  bl 0x821fc008
	ctx.lr = 0x821D9C2C;
	sub_821FC008(ctx, base);
	// 821D9C2C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821D9C30: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821D9C34: 419A0020  beq cr6, 0x821d9c54
	if ctx.cr[6].eq {
	pc = 0x821D9C54; continue 'dispatch;
	}
	// 821D9C38: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 821D9C3C: 387E0034  addi r3, r30, 0x34
	ctx.r[3].s64 = ctx.r[30].s64 + 52;
	// 821D9C40: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821D9C44: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 821D9C48: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821D9C4C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821D9C50: 488BD719  bl 0x82a97368
	ctx.lr = 0x821D9C54;
	sub_82A97368(ctx, base);
	pc = 0x821D9C54; continue 'dispatch;
            }
            0x821D9C54 => {
    //   block [0x821D9C54..0x821D9C5C)
	// 821D9C54: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D9C58: 48ACF804  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9C98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9C98 size=168
    let mut pc: u32 = 0x821D9C98;
    'dispatch: loop {
        match pc {
            0x821D9C98 => {
    //   block [0x821D9C98..0x821D9CD0)
	// 821D9C98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9C9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D9CA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D9CA4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9CA8: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821D9CAC: 80A30010  lwz r5, 0x10(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D9CB0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821D9CB4: 388B0D54  addi r4, r11, 0xd54
	ctx.r[4].s64 = ctx.r[11].s64 + 3412;
	// 821D9CB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D9CBC: 4801A7C5  bl 0x821f4480
	ctx.lr = 0x821D9CC0;
	sub_821F4480(ctx, base);
	// 821D9CC0: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821D9CC4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821D9CC8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821D9CCC: 419A0060  beq cr6, 0x821d9d2c
	if ctx.cr[6].eq {
	pc = 0x821D9D2C; continue 'dispatch;
	}
	pc = 0x821D9CD0; continue 'dispatch;
            }
            0x821D9CD0 => {
    //   block [0x821D9CD0..0x821D9CF4)
	// 821D9CD0: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821D9CD4: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D9CD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D9CDC: 419A0018  beq cr6, 0x821d9cf4
	if ctx.cr[6].eq {
	pc = 0x821D9CF4; continue 'dispatch;
	}
	// 821D9CE0: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821D9CE4: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821D9CE8: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821D9CEC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D9CF0: 41980008  blt cr6, 0x821d9cf8
	if ctx.cr[6].lt {
	pc = 0x821D9CF8; continue 'dispatch;
	}
	pc = 0x821D9CF4; continue 'dispatch;
            }
            0x821D9CF4 => {
    //   block [0x821D9CF4..0x821D9CF8)
	// 821D9CF4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D9CF8; continue 'dispatch;
            }
            0x821D9CF8 => {
    //   block [0x821D9CF8..0x821D9D2C)
	// 821D9CF8: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821D9CFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821D9D00: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821D9D04: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9D08: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D9D0C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821D9D10: 4E800421  bctrl
	ctx.lr = 0x821D9D14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D9D14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821D9D18: 48026061  bl 0x821ffd78
	ctx.lr = 0x821D9D1C;
	sub_821FFD78(ctx, base);
	// 821D9D1C: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821D9D20: 80E10064  lwz r7, 0x64(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821D9D24: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821D9D28: 409AFFA8  bne cr6, 0x821d9cd0
	if !ctx.cr[6].eq {
	pc = 0x821D9CD0; continue 'dispatch;
	}
            }
            0x821D9D2C => {
    //   block [0x821D9D2C..0x821D9D40)
	// 821D9D2C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D9D30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D9D34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D9D38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D9D3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D9D40 size=244
    let mut pc: u32 = 0x821D9D40;
    'dispatch: loop {
        match pc {
            0x821D9D40 => {
    //   block [0x821D9D40..0x821D9D90)
	// 821D9D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D9D48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D9D4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D9D50: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821D9D54: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9D58: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821D9D5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D9D60: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D9D64: 397F00D8  addi r11, r31, 0xd8
	ctx.r[11].s64 = ctx.r[31].s64 + 216;
	// 821D9D68: C81F00E0  lfd f0, 0xe0(r31)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	// 821D9D6C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821D9D70: 40990020  ble cr6, 0x821d9d90
	if !ctx.cr[6].gt {
	pc = 0x821D9D90; continue 'dispatch;
	}
	// 821D9D74: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821D9D78: D80B0000  stfd f0, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.f[0].u64 ) };
	// 821D9D7C: DBEB0008  stfd f31, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.f[31].u64 ) };
	// 821D9D80: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821D9D84: C009D5C8  lfs f0, -0x2a38(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D9D88: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821D9D8C: 48000008  b 0x821d9d94
	pc = 0x821D9D94; continue 'dispatch;
            }
            0x821D9D90 => {
    //   block [0x821D9D90..0x821D9D94)
	// 821D9D90: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821D9D94; continue 'dispatch;
            }
            0x821D9D94 => {
    //   block [0x821D9D94..0x821D9DD0)
	// 821D9D94: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821D9D98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D9D9C: 419A007C  beq cr6, 0x821d9e18
	if ctx.cr[6].eq {
	pc = 0x821D9E18; continue 'dispatch;
	}
	// 821D9DA0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9DA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D9DA8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9DAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821D9DB0: 4E800421  bctrl
	ctx.lr = 0x821D9DB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D9DB4: 2F030005  cmpwi cr6, r3, 5
	ctx.cr[6].compare_i32(ctx.r[3].s32, 5, &mut ctx.xer);
	// 821D9DB8: 419A0018  beq cr6, 0x821d9dd0
	if ctx.cr[6].eq {
	pc = 0x821D9DD0; continue 'dispatch;
	}
	// 821D9DBC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821D9DC0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D9DC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D9DC8: 4889F771  bl 0x82a79538
	ctx.lr = 0x821D9DCC;
	sub_82A79538(ctx, base);
	// 821D9DCC: 4800004C  b 0x821d9e18
	pc = 0x821D9E18; continue 'dispatch;
            }
            0x821D9DD0 => {
    //   block [0x821D9DD0..0x821D9DE4)
	// 821D9DD0: 395F0140  addi r10, r31, 0x140
	ctx.r[10].s64 = ctx.r[31].s64 + 320;
	// 821D9DD4: 393F0100  addi r9, r31, 0x100
	ctx.r[9].s64 = ctx.r[31].s64 + 256;
	// 821D9DD8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821D9DDC: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 821D9DE0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x821D9DE4; continue 'dispatch;
            }
            0x821D9DE4 => {
    //   block [0x821D9DE4..0x821D9E04)
	// 821D9DE4: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821D9DE8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821D9DEC: F9090000  std r8, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 821D9DF0: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 821D9DF4: 4200FFF0  bdnz 0x821d9de4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821D9DE4; continue 'dispatch;
	}
	// 821D9DF8: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 821D9DFC: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821D9E00: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821D9E04; continue 'dispatch;
            }
            0x821D9E04 => {
    //   block [0x821D9E04..0x821D9E18)
	// 821D9E04: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821D9E08: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821D9E0C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821D9E10: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821D9E14: 4200FFF0  bdnz 0x821d9e04
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821D9E04; continue 'dispatch;
	}
	pc = 0x821D9E18; continue 'dispatch;
            }
            0x821D9E18 => {
    //   block [0x821D9E18..0x821D9E34)
	// 821D9E18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D9E1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D9E20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D9E24: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821D9E28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D9E2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D9E30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9E38 size=100
    let mut pc: u32 = 0x821D9E38;
    'dispatch: loop {
        match pc {
            0x821D9E38 => {
    //   block [0x821D9E38..0x821D9E7C)
	// 821D9E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9E3C: 48ACF5D1  bl 0x82ca940c
	ctx.lr = 0x821D9E40;
	sub_82CA93D0(ctx, base);
	// 821D9E40: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821D9E44: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9E48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D9E4C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821D9E50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821D9E54: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821D9E58: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821D9E5C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821D9E60: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821D9E64: 997F0060  stb r11, 0x60(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u8 ) };
	// 821D9E68: 4808E119  bl 0x82267f80
	ctx.lr = 0x821D9E6C;
	sub_82267F80(ctx, base);
	// 821D9E6C: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821D9E70: 4082000C  bne 0x821d9e7c
	if !ctx.cr[0].eq {
	pc = 0x821D9E7C; continue 'dispatch;
	}
	// 821D9E74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821D9E78: 48000018  b 0x821d9e90
	pc = 0x821D9E90; continue 'dispatch;
            }
            0x821D9E7C => {
    //   block [0x821D9E7C..0x821D9E90)
	// 821D9E7C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821D9E80: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821D9E84: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821D9E88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D9E8C: 480AE975  bl 0x82288800
	ctx.lr = 0x821D9E90;
	sub_82288800(ctx, base);
	pc = 0x821D9E90; continue 'dispatch;
            }
            0x821D9E90 => {
    //   block [0x821D9E90..0x821D9E9C)
	// 821D9E90: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821D9E94: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821D9E98: 48ACF5C4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9EA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9EA0 size=72
    let mut pc: u32 = 0x821D9EA0;
    'dispatch: loop {
        match pc {
            0x821D9EA0 => {
    //   block [0x821D9EA0..0x821D9EC8)
	// 821D9EA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9EA4: 48ACF569  bl 0x82ca940c
	ctx.lr = 0x821D9EA8;
	sub_82CA93D0(ctx, base);
	// 821D9EA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9EAC: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9EB0: 817F03B8  lwz r11, 0x3b8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(952 as u32) ) } as u64;
	// 821D9EB4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821D9EB8: 917F03B8  stw r11, 0x3b8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(952 as u32), ctx.r[11].u32 ) };
	// 821D9EBC: 40820024  bne 0x821d9ee0
	if !ctx.cr[0].eq {
	pc = 0x821D9EE0; continue 'dispatch;
	}
	// 821D9EC0: 3BC00011  li r30, 0x11
	ctx.r[30].s64 = 17;
	// 821D9EC4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x821D9EC8; continue 'dispatch;
            }
            0x821D9EC8 => {
    //   block [0x821D9EC8..0x821D9EE0)
	// 821D9EC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821D9ECC: 4805FD7D  bl 0x82239c48
	ctx.lr = 0x821D9ED0;
	sub_82239C48(ctx, base);
	// 821D9ED0: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 821D9ED4: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821D9ED8: 3BFF0038  addi r31, r31, 0x38
	ctx.r[31].s64 = ctx.r[31].s64 + 56;
	// 821D9EDC: 4082FFEC  bne 0x821d9ec8
	if !ctx.cr[0].eq {
	pc = 0x821D9EC8; continue 'dispatch;
	}
	pc = 0x821D9EE0; continue 'dispatch;
            }
            0x821D9EE0 => {
    //   block [0x821D9EE0..0x821D9EE8)
	// 821D9EE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D9EE4: 48ACF578  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821D9EE8 size=188
    let mut pc: u32 = 0x821D9EE8;
    'dispatch: loop {
        match pc {
            0x821D9EE8 => {
    //   block [0x821D9EE8..0x821D9F1C)
	// 821D9EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9EEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D9EF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821D9EF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D9EF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9EFC: F8A10090  std r5, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[5].u64 ) };
	// 821D9F00: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821D9F04: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 821D9F08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821D9F0C: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 821D9F10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821D9F14: 409A0008  bne cr6, 0x821d9f1c
	if !ctx.cr[6].eq {
	pc = 0x821D9F1C; continue 'dispatch;
	}
	// 821D9F18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D9F1C; continue 'dispatch;
            }
            0x821D9F1C => {
    //   block [0x821D9F1C..0x821D9F30)
	// 821D9F1C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9F20: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 821D9F24: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821D9F28: 409A0008  bne cr6, 0x821d9f30
	if !ctx.cr[6].eq {
	pc = 0x821D9F30; continue 'dispatch;
	}
	// 821D9F2C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821D9F30; continue 'dispatch;
            }
            0x821D9F30 => {
    //   block [0x821D9F30..0x821D9F80)
	// 821D9F30: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9F34: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821D9F38: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9F3C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821D9F40: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 821D9F44: 419A003C  beq cr6, 0x821d9f80
	if ctx.cr[6].eq {
	pc = 0x821D9F80; continue 'dispatch;
	}
	// 821D9F48: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9F4C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821D9F50: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9F54: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821D9F58: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9F5C: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9F60: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821D9F64: 48041DD5  bl 0x8221bd38
	ctx.lr = 0x821D9F68;
	sub_8221BD38(ctx, base);
	// 821D9F68: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821D9F6C: E8C10090  ld r6, 0x90(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821D9F70: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 821D9F74: 90BF0008  stw r5, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 821D9F78: F8DE0000  std r6, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 821D9F7C: 4800000C  b 0x821d9f88
	pc = 0x821D9F88; continue 'dispatch;
            }
            0x821D9F80 => {
    //   block [0x821D9F80..0x821D9F88)
	// 821D9F80: E9610090  ld r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821D9F84: F97E0000  std r11, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	pc = 0x821D9F88; continue 'dispatch;
            }
            0x821D9F88 => {
    //   block [0x821D9F88..0x821D9FA4)
	// 821D9F88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821D9F8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821D9F90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821D9F94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821D9F98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821D9F9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821D9FA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821D9FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821D9FA8 size=452
    let mut pc: u32 = 0x821D9FA8;
    'dispatch: loop {
        match pc {
            0x821D9FA8 => {
    //   block [0x821D9FA8..0x821DA018)
	// 821D9FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821D9FAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821D9FB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821D9FB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821D9FB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821D9FBC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821D9FC0: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821D9FC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821D9FC8: 4E800421  bctrl
	ctx.lr = 0x821D9FCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821D9FCC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821D9FD0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821D9FD4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821D9FD8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821D9FDC: 409A003C  bne cr6, 0x821da018
	if !ctx.cr[6].eq {
	pc = 0x821DA018; continue 'dispatch;
	}
	// 821D9FE0: C16B0034  lfs f11, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821D9FE4: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821D9FE8: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 821D9FEC: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821D9FF0: C14B0038  lfs f10, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821D9FF4: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 821D9FF8: C19F00E8  lfs f12, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821D9FFC: C16B003C  lfs f11, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821DA000: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 821DA004: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 821DA008: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821DA00C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 821DA010: EC20002C  fsqrts f1, f0
	ctx.f[1].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 821DA014: 48000144  b 0x821da158
	pc = 0x821DA158; continue 'dispatch;
            }
            0x821DA018 => {
    //   block [0x821DA018..0x821DA080)
	// 821DA018: C17F00F8  lfs f11, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821DA01C: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DA020: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 821DA024: C15F00FC  lfs f10, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821DA028: C1AB0038  lfs f13, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DA02C: EDAD5028  fsubs f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[10].f64) as f32) as f64);
	// 821DA030: C17F0100  lfs f11, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821DA034: C18B003C  lfs f12, 0x3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821DA038: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821DA03C: C15F00E0  lfs f10, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821DA040: C17F00F8  lfs f11, 0xf8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(248 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821DA044: FF0B5000  fcmpu cr6, f11, f10
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[10].f64);
	// 821DA048: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 821DA04C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821DA050: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 821DA054: EC20002C  fsqrts f1, f0
	ctx.f[1].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 821DA058: 409A0028  bne cr6, 0x821da080
	if !ctx.cr[6].eq {
	pc = 0x821DA080; continue 'dispatch;
	}
	// 821DA05C: C01F00FC  lfs f0, 0xfc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DA060: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DA064: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821DA068: 409A0018  bne cr6, 0x821da080
	if !ctx.cr[6].eq {
	pc = 0x821DA080; continue 'dispatch;
	}
	// 821DA06C: C01F0100  lfs f0, 0x100(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DA070: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DA074: C1BF00E8  lfs f13, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DA078: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821DA07C: 419A0008  beq cr6, 0x821da084
	if ctx.cr[6].eq {
	pc = 0x821DA084; continue 'dispatch;
	}
	pc = 0x821DA080; continue 'dispatch;
            }
            0x821DA080 => {
    //   block [0x821DA080..0x821DA084)
	// 821DA080: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x821DA084; continue 'dispatch;
            }
            0x821DA084 => {
    //   block [0x821DA084..0x821DA0BC)
	// 821DA084: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DA088: 418200D0  beq 0x821da158
	if ctx.cr[0].eq {
	pc = 0x821DA158; continue 'dispatch;
	}
	// 821DA08C: 813F013C  lwz r9, 0x13c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(316 as u32) ) } as u64;
	// 821DA090: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 821DA094: 419A0074  beq cr6, 0x821da108
	if ctx.cr[6].eq {
	pc = 0x821DA108; continue 'dispatch;
	}
	// 821DA098: 811F007C  lwz r8, 0x7c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821DA09C: 39490001  addi r10, r9, 1
	ctx.r[10].s64 = ctx.r[9].s64 + 1;
	// 821DA0A0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821DA0A4: 40980064  bge cr6, 0x821da108
	if !ctx.cr[6].lt {
	pc = 0x821DA108; continue 'dispatch;
	}
	// 821DA0A8: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 821DA0AC: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 12 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821DA0B0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821DA0B4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821DA0B8: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	pc = 0x821DA0BC; continue 'dispatch;
            }
            0x821DA0BC => {
    //   block [0x821DA0BC..0x821DA108)
	// 821DA0BC: C1A90000  lfs f13, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DA0C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821DA0C4: C00BFFFC  lfs f0, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DA0C8: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 821DA0CC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821DA0D0: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821DA0D4: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DA0D8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821DA0DC: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 821DA0E0: C16BFFF8  lfs f11, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821DA0E4: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821DA0E8: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 821DA0EC: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821DA0F0: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 821DA0F4: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821DA0F8: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 821DA0FC: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 821DA100: EC20082A  fadds f1, f0, f1
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 821DA104: 4198FFB8  blt cr6, 0x821da0bc
	if ctx.cr[6].lt {
	pc = 0x821DA0BC; continue 'dispatch;
	}
	pc = 0x821DA108; continue 'dispatch;
            }
            0x821DA108 => {
    //   block [0x821DA108..0x821DA158)
	// 821DA108: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 821DA10C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DA110: 41820048  beq 0x821da158
	if ctx.cr[0].eq {
	pc = 0x821DA158; continue 'dispatch;
	}
	// 821DA114: 815F0088  lwz r10, 0x88(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 821DA118: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821DA11C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821DA120: C01F00E0  lfs f0, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DA124: C17F00E8  lfs f11, 0xe8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(232 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821DA128: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DA12C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821DA130: C18BFFF8  lfs f12, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821DA134: C1BF00E4  lfs f13, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DA138: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 821DA13C: C18BFFFC  lfs f12, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821DA140: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821DA144: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 821DA148: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821DA14C: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 821DA150: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 821DA154: EC20082A  fadds f1, f0, f1
	ctx.f[1].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	pc = 0x821DA158; continue 'dispatch;
            }
            0x821DA158 => {
    //   block [0x821DA158..0x821DA16C)
	// 821DA158: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821DA15C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DA160: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DA164: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821DA168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DA170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DA170 size=36
    let mut pc: u32 = 0x821DA170;
    'dispatch: loop {
        match pc {
            0x821DA170 => {
    //   block [0x821DA170..0x821DA18C)
	// 821DA170: 896300BC  lbz r11, 0xbc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(188 as u32) ) } as u64;
	// 821DA174: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821DA178: 409A0014  bne cr6, 0x821da18c
	if !ctx.cr[6].eq {
	pc = 0x821DA18C; continue 'dispatch;
	}
	// 821DA17C: 896300BE  lbz r11, 0xbe(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(190 as u32) ) } as u64;
	// 821DA180: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821DA184: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DA188: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	pc = 0x821DA18C; continue 'dispatch;
            }
            0x821DA18C => {
    //   block [0x821DA18C..0x821DA194)
	// 821DA18C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821DA190: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DA198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DA198 size=236
    let mut pc: u32 = 0x821DA198;
    'dispatch: loop {
        match pc {
            0x821DA198 => {
    //   block [0x821DA198..0x821DA1E4)
	// 821DA198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DA19C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DA1A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821DA1A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DA1A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DA1AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DA1B0: 897F00B0  lbz r11, 0xb0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821DA1B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA1B8: 409A002C  bne cr6, 0x821da1e4
	if !ctx.cr[6].eq {
	pc = 0x821DA1E4; continue 'dispatch;
	}
	// 821DA1BC: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 821DA1C0: 815F00B8  lwz r10, 0xb8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 821DA1C4: 812B00B0  lwz r9, 0xb0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) } as u64;
	// 821DA1C8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821DA1CC: 409A0018  bne cr6, 0x821da1e4
	if !ctx.cr[6].eq {
	pc = 0x821DA1E4; continue 'dispatch;
	}
	// 821DA1D0: 812B00AC  lwz r9, 0xac(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 821DA1D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DA1D8: 815F00B4  lwz r10, 0xb4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 821DA1DC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821DA1E0: 419A0008  beq cr6, 0x821da1e8
	if ctx.cr[6].eq {
	pc = 0x821DA1E8; continue 'dispatch;
	}
	pc = 0x821DA1E4; continue 'dispatch;
            }
            0x821DA1E4 => {
    //   block [0x821DA1E4..0x821DA1E8)
	// 821DA1E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x821DA1E8; continue 'dispatch;
            }
            0x821DA1E8 => {
    //   block [0x821DA1E8..0x821DA268)
	// 821DA1E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DA1EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA1F0: 419A0078  beq cr6, 0x821da268
	if ctx.cr[6].eq {
	pc = 0x821DA268; continue 'dispatch;
	}
	// 821DA1F4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DA1F8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA1FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DA200: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DA204: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DA208: 812A0044  lwz r9, 0x44(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 821DA20C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821DA210: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821DA214: 4E800421  bctrl
	ctx.lr = 0x821DA218;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DA218: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821DA21C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DA220: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821DA224: 4904ED55  bl 0x83228f78
	ctx.lr = 0x821DA228;
	sub_83228F78(ctx, base);
	// 821DA228: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821DA22C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
            }
            0x821DA268 => {
    //   block [0x821DA268..0x821DA284)
	// 821DA268: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 821DA26C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821DA270: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DA274: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DA278: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821DA27C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821DA280: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DA288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DA288 size=192
    let mut pc: u32 = 0x821DA288;
    'dispatch: loop {
        match pc {
            0x821DA288 => {
    //   block [0x821DA288..0x821DA2D4)
	// 821DA288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DA28C: 48ACF181  bl 0x82ca940c
	ctx.lr = 0x821DA290;
	sub_82CA93D0(ctx, base);
	// 821DA290: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DA294: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821DA298: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821DA29C: 389E0018  addi r4, r30, 0x18
	ctx.r[4].s64 = ctx.r[30].s64 + 24;
	// 821DA2A0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821DA2A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA2A8: 483A5231  bl 0x8257f4d8
	ctx.lr = 0x821DA2AC;
	sub_8257F4D8(ctx, base);
	// 821DA2AC: 83BE0020  lwz r29, 0x20(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DA2B0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821DA2B4: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821DA2B8: 419A0068  beq cr6, 0x821da320
	if ctx.cr[6].eq {
	pc = 0x821DA320; continue 'dispatch;
	}
	// 821DA2BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA2C0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA2C4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DA2C8: 409A000C  bne cr6, 0x821da2d4
	if !ctx.cr[6].eq {
	pc = 0x821DA2D4; continue 'dispatch;
	}
	// 821DA2CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DA2D0: 48000034  b 0x821da304
	pc = 0x821DA304; continue 'dispatch;
            }
            0x821DA2D4 => {
    //   block [0x821DA2D4..0x821DA2E4)
	// 821DA2D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DA2D8: 409A000C  bne cr6, 0x821da2e4
	if !ctx.cr[6].eq {
	pc = 0x821DA2E4; continue 'dispatch;
	}
	// 821DA2DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DA2E0: 48000024  b 0x821da304
	pc = 0x821DA304; continue 'dispatch;
            }
            0x821DA2E4 => {
    //   block [0x821DA2E4..0x821DA304)
	// 821DA2E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA2E8: 419A001C  beq cr6, 0x821da304
	if ctx.cr[6].eq {
	pc = 0x821DA304; continue 'dispatch;
	}
	// 821DA2EC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA2F0: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA2F4: 48093505  bl 0x8226d7f8
	ctx.lr = 0x821DA2F8;
	sub_8226D7F8(ctx, base);
	// 821DA2F8: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821DA2FC: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821DA300: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x821DA304; continue 'dispatch;
            }
            0x821DA304 => {
    //   block [0x821DA304..0x821DA320)
	// 821DA304: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DA308: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA30C: 409A0014  bne cr6, 0x821da320
	if !ctx.cr[6].eq {
	pc = 0x821DA320; continue 'dispatch;
	}
	// 821DA310: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DA314: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821DA318: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821DA31C: 48000008  b 0x821da324
	pc = 0x821DA324; continue 'dispatch;
            }
            0x821DA320 => {
    //   block [0x821DA320..0x821DA324)
	// 821DA320: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821DA324; continue 'dispatch;
            }
            0x821DA324 => {
    //   block [0x821DA324..0x821DA33C)
	// 821DA324: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DA328: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DA32C: 419A0010  beq cr6, 0x821da33c
	if ctx.cr[6].eq {
	pc = 0x821DA33C; continue 'dispatch;
	}
	// 821DA330: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA334: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DA338: 48ACF124  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821DA33C => {
    //   block [0x821DA33C..0x821DA348)
	// 821DA33C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821DA340: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DA344: 48ACF118  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DA348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DA348 size=104
    let mut pc: u32 = 0x821DA348;
    'dispatch: loop {
        match pc {
            0x821DA348 => {
    //   block [0x821DA348..0x821DA38C)
	// 821DA348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DA34C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DA350: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DA354: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821DA358: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DA35C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821DA360: 90870000  stw r4, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821DA364: 91670004  stw r11, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821DA368: 419A0034  beq cr6, 0x821da39c
	if ctx.cr[6].eq {
	pc = 0x821DA39C; continue 'dispatch;
	}
	// 821DA36C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DA370: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821DA374: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA378: 409A0014  bne cr6, 0x821da38c
	if !ctx.cr[6].eq {
	pc = 0x821DA38C; continue 'dispatch;
	}
	// 821DA37C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DA380: 816B6AC0  lwz r11, 0x6ac0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27328 as u32) ) } as u64;
	// 821DA384: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA388: 419A0014  beq cr6, 0x821da39c
	if ctx.cr[6].eq {
	pc = 0x821DA39C; continue 'dispatch;
	}
	pc = 0x821DA38C; continue 'dispatch;
            }
            0x821DA38C => {
    //   block [0x821DA38C..0x821DA39C)
	// 821DA38C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DA390: 806B6DA0  lwz r3, 0x6da0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821DA394: 48009EBD  bl 0x821e4250
	ctx.lr = 0x821DA398;
	sub_821E4250(ctx, base);
	// 821DA398: 90670004  stw r3, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	pc = 0x821DA39C; continue 'dispatch;
            }
            0x821DA39C => {
    //   block [0x821DA39C..0x821DA3B0)
	// 821DA39C: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821DA3A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821DA3A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DA3A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DA3AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DA3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DA3B0 size=184
    let mut pc: u32 = 0x821DA3B0;
    'dispatch: loop {
        match pc {
            0x821DA3B0 => {
    //   block [0x821DA3B0..0x821DA450)
	// 821DA3B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DA3B4: 48ACF059  bl 0x82ca940c
	ctx.lr = 0x821DA3B8;
	sub_82CA93D0(ctx, base);
	// 821DA3B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DA3BC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DA3C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821DA3C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DA3C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA3CC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821DA3D0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA3D4: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DA3D8: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DA3DC: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 821DA3E0: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA3E4: 83A60004  lwz r29, 4(r6)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA3E8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821DA3EC: 4E800421  bctrl
	ctx.lr = 0x821DA3F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DA3F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821DA3F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA3F8: 4BFFFE91  bl 0x821da288
	ctx.lr = 0x821DA3FC;
	sub_821DA288(ctx, base);
	// 821DA3FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821DA400: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA404: 4803A9D5  bl 0x82214dd8
	ctx.lr = 0x821DA408;
	sub_82214DD8(ctx, base);
	// 821DA408: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA40C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA410: 80AB001C  lwz r5, 0x1c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DA414: 808B0020  lwz r4, 0x20(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DA418: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 821DA41C: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 821DA420: 4BFD80D9  bl 0x821b24f8
	ctx.lr = 0x821DA424;
	sub_821B24F8(ctx, base);
	// 821DA424: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821DA428: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 821DA42C: 4882629D  bl 0x82a006c8
	ctx.lr = 0x821DA430;
	sub_82A006C8(ctx, base);
	// 821DA430: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821DA434: 419A001C  beq cr6, 0x821da450
	if ctx.cr[6].eq {
	pc = 0x821DA450; continue 'dispatch;
	}
	// 821DA438: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA43C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DA440: 4BFFFF09  bl 0x821da348
	ctx.lr = 0x821DA444;
	sub_821DA348(ctx, base);
	// 821DA444: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DA448: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DA44C: 48ACF010  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821DA450 => {
    //   block [0x821DA450..0x821DA468)
	// 821DA450: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821DA454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DA458: 4BFFFEF1  bl 0x821da348
	ctx.lr = 0x821DA45C;
	sub_821DA348(ctx, base);
	// 821DA45C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DA460: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DA464: 48ACEFF8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DA468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DA468 size=1292
    let mut pc: u32 = 0x821DA468;
    'dispatch: loop {
        match pc {
            0x821DA468 => {
    //   block [0x821DA468..0x821DA4A0)
	// 821DA468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DA46C: 48ACEFA1  bl 0x82ca940c
	ctx.lr = 0x821DA470;
	sub_82CA93D0(ctx, base);
	// 821DA470: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DA474: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821DA478: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821DA47C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821DA480: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 821DA484: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DA488: 409900FC  ble cr6, 0x821da584
	if !ctx.cr[6].gt {
	pc = 0x821DA584; continue 'dispatch;
	}
	// 821DA48C: 2F0B000A  cmpwi cr6, r11, 0xa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 10, &mut ctx.xer);
	// 821DA490: 40980010  bge cr6, 0x821da4a0
	if !ctx.cr[6].lt {
	pc = 0x821DA4A0; continue 'dispatch;
	}
	// 821DA494: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DA498: 3BEB7088  addi r31, r11, 0x7088
	ctx.r[31].s64 = ctx.r[11].s64 + 28808;
	// 821DA49C: 4800000C  b 0x821da4a8
	pc = 0x821DA4A8; continue 'dispatch;
            }
            0x821DA4A0 => {
    //   block [0x821DA4A0..0x821DA4A8)
	// 821DA4A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821DA4A4: 3BEB0CA0  addi r31, r11, 0xca0
	ctx.r[31].s64 = ctx.r[11].s64 + 3232;
	pc = 0x821DA4A8; continue 'dispatch;
            }
            0x821DA4A8 => {
    //   block [0x821DA4A8..0x821DA584)
	// 821DA4A8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DA4AC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA4B0: 388B7990  addi r4, r11, 0x7990
	ctx.r[4].s64 = ctx.r[11].s64 + 31120;
	// 821DA4B4: 48015D8D  bl 0x821f0240
	ctx.lr = 0x821DA4B8;
	sub_821F0240(ctx, base);
	// 821DA4B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DA4BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA4C0: 48000501  bl 0x821da9c0
	ctx.lr = 0x821DA4C4;
	sub_821DA9C0(ctx, base);
	// 821DA4C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821DA4C8: 809E0040  lwz r4, 0x40(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 821DA4CC: 481747F5  bl 0x8234ecc0
	ctx.lr = 0x821DA4D0;
	sub_8234ECC0(ctx, base);
	// 821DA4D0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821DA4D4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821DA4D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DA4DC: 48008C2D  bl 0x821e3108
	ctx.lr = 0x821DA4E0;
	sub_821E3108(ctx, base);
	// 821DA4E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821DA4E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA4E8: 48015D59  bl 0x821f0240
	ctx.lr = 0x821DA4EC;
	sub_821F0240(ctx, base);
	// 821DA4EC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821DA4F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA4F4: 3BEA0B74  addi r31, r10, 0xb74
	ctx.r[31].s64 = ctx.r[10].s64 + 2932;
	// 821DA4F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DA4FC: 480004C5  bl 0x821da9c0
	ctx.lr = 0x821DA500;
	sub_821DA9C0(ctx, base);
	// 821DA500: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DA504: 4803A8D5  bl 0x82214dd8
	ctx.lr = 0x821DA508;
	sub_82214DD8(ctx, base);
	// 821DA508: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA50C: 4803A8CD  bl 0x82214dd8
	ctx.lr = 0x821DA510;
	sub_82214DD8(ctx, base);
	// 821DA510: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821DA514: 4803A8C5  bl 0x82214dd8
	ctx.lr = 0x821DA518;
	sub_82214DD8(ctx, base);
	// 821DA518: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821DA51C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821DA520: 481CDF01  bl 0x823a8420
	ctx.lr = 0x821DA524;
	sub_823A8420(ctx, base);
	// 821DA524: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821DA528: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821DA52C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DA530: 48008BD9  bl 0x821e3108
	ctx.lr = 0x821DA534;
	sub_821E3108(ctx, base);
	// 821DA534: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821DA538: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA53C: 48015D05  bl 0x821f0240
	ctx.lr = 0x821DA540;
	sub_821F0240(ctx, base);
	// 821DA540: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DA544: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA548: 48000479  bl 0x821da9c0
	ctx.lr = 0x821DA54C;
	sub_821DA9C0(ctx, base);
	// 821DA54C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821DA550: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA554: 48015CED  bl 0x821f0240
	ctx.lr = 0x821DA558;
	sub_821F0240(ctx, base);
	// 821DA558: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA55C: 4803A87D  bl 0x82214dd8
	ctx.lr = 0x821DA560;
	sub_82214DD8(ctx, base);
	// 821DA560: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DA564: 4803A875  bl 0x82214dd8
	ctx.lr = 0x821DA568;
	sub_82214DD8(ctx, base);
	// 821DA568: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821DA56C: 4803A86D  bl 0x82214dd8
	ctx.lr = 0x821DA570;
	sub_82214DD8(ctx, base);
	// 821DA570: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA574: 4803A865  bl 0x82214dd8
	ctx.lr = 0x821DA578;
	sub_82214DD8(ctx, base);
	// 821DA578: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA57C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821DA580: 48ACEEDC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821DA584 => {
    //   block [0x821DA584..0x821DA5E4)
	// 821DA584: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821DA588: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DA58C: 4BFFFE25  bl 0x821da3b0
	ctx.lr = 0x821DA590;
	sub_821DA3B0(ctx, base);
	// 821DA590: 4BFD7F69  bl 0x821b24f8
	ctx.lr = 0x821DA594;
	sub_821B24F8(ctx, base);
	// 821DA594: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821DA598: 388B1728  addi r4, r11, 0x1728
	ctx.r[4].s64 = ctx.r[11].s64 + 5928;
	// 821DA59C: 48148FA5  bl 0x82323540
	ctx.lr = 0x821DA5A0;
	sub_82323540(ctx, base);
	// 821DA5A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821DA5A4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA5A8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821DA5AC: 48052925  bl 0x8222ced0
	ctx.lr = 0x821DA5B0;
	sub_8222CED0(ctx, base);
	// 821DA5B0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821DA5B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA5B8: 419A005C  beq cr6, 0x821da614
	if ctx.cr[6].eq {
	pc = 0x821DA614; continue 'dispatch;
	}
	// 821DA5BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA5C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DA5C4: 40990050  ble cr6, 0x821da614
	if !ctx.cr[6].gt {
	pc = 0x821DA614; continue 'dispatch;
	}
	// 821DA5C8: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 821DA5CC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821DA5D0: 409A0014  bne cr6, 0x821da5e4
	if !ctx.cr[6].eq {
	pc = 0x821DA5E4; continue 'dispatch;
	}
	// 821DA5D4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821DA5D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA5DC: 388BA404  addi r4, r11, -0x5bfc
	ctx.r[4].s64 = ctx.r[11].s64 + -23548;
	// 821DA5E0: 480003E1  bl 0x821da9c0
	ctx.lr = 0x821DA5E4;
	sub_821DA9C0(ctx, base);
	pc = 0x821DA5E4; continue 'dispatch;
            }
            0x821DA5E4 => {
    //   block [0x821DA5E4..0x821DA614)
	// 821DA5E4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821DA5E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA5EC: 48015C55  bl 0x821f0240
	ctx.lr = 0x821DA5F0;
	sub_821F0240(ctx, base);
	// 821DA5F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821DA5F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA5F8: 388B0B74  addi r4, r11, 0xb74
	ctx.r[4].s64 = ctx.r[11].s64 + 2932;
	// 821DA5FC: 480003C5  bl 0x821da9c0
	ctx.lr = 0x821DA600;
	sub_821DA9C0(ctx, base);
	// 821DA600: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA604: 4803A7D5  bl 0x82214dd8
	ctx.lr = 0x821DA608;
	sub_82214DD8(ctx, base);
	// 821DA608: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA60C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821DA610: 48ACEE4C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821DA614 => {
    //   block [0x821DA614..0x821DA654)
	// 821DA614: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 821DA618: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821DA61C: 409A0334  bne cr6, 0x821da950
	if !ctx.cr[6].eq {
	pc = 0x821DA950; continue 'dispatch;
	}
	// 821DA620: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821DA624: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821DA628: 388B9FC4  addi r4, r11, -0x603c
	ctx.r[4].s64 = ctx.r[11].s64 + -24636;
	// 821DA62C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA630: 480528A1  bl 0x8222ced0
	ctx.lr = 0x821DA634;
	sub_8222CED0(ctx, base);
	// 821DA634: 57EA063E  clrlwi r10, r31, 0x18
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821DA638: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DA63C: 419A0018  beq cr6, 0x821da654
	if ctx.cr[6].eq {
	pc = 0x821DA654; continue 'dispatch;
	}
	// 821DA640: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821DA644: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA648: 388B0B74  addi r4, r11, 0xb74
	ctx.r[4].s64 = ctx.r[11].s64 + 2932;
	// 821DA64C: 48000375  bl 0x821da9c0
	ctx.lr = 0x821DA650;
	sub_821DA9C0(ctx, base);
	// 821DA650: 480002D8  b 0x821da928
	pc = 0x821DA928; continue 'dispatch;
            }
            0x821DA654 => {
    //   block [0x821DA654..0x821DA698)
	// 821DA654: 80DE0004  lwz r6, 4(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA658: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821DA65C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821DA660: 81460030  lwz r10, 0x30(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(48 as u32) ) } as u64;
	// 821DA664: 554937FE  rlwinm r9, r10, 6, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x03FFFFFFu64;
	// 821DA668: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DA66C: 419A00E8  beq cr6, 0x821da754
	if ctx.cr[6].eq {
	pc = 0x821DA754; continue 'dispatch;
	}
	// 821DA670: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 821DA674: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA678: 419A0020  beq cr6, 0x821da698
	if ctx.cr[6].eq {
	pc = 0x821DA698; continue 'dispatch;
	}
	// 821DA67C: 894B007A  lbz r10, 0x7a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(122 as u32) ) } as u64;
	// 821DA680: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DA684: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821DA688: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821DA68C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DA690: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA694: 480000C4  b 0x821da758
	pc = 0x821DA758; continue 'dispatch;
            }
            0x821DA698 => {
    //   block [0x821DA698..0x821DA6B4)
	// 821DA698: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DA69C: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 821DA6A0: 90810060  stw r4, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[4].u32 ) };
	// 821DA6A4: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 821DA6A8: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821DA6AC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DA6B0: 40810054  ble 0x821da704
	if !ctx.cr[0].gt {
	pc = 0x821DA704; continue 'dispatch;
	}
	pc = 0x821DA6B4; continue 'dispatch;
            }
            0x821DA6B4 => {
    //   block [0x821DA6B4..0x821DA6D4)
	// 821DA6B4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821DA6B8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DA6BC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821DA6C0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA6C4: 2F07007A  cmpwi cr6, r7, 0x7a
	ctx.cr[6].compare_i32(ctx.r[7].s32, 122, &mut ctx.xer);
	// 821DA6C8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821DA6CC: 41980008  blt cr6, 0x821da6d4
	if ctx.cr[6].lt {
	pc = 0x821DA6D4; continue 'dispatch;
	}
	// 821DA6D0: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	pc = 0x821DA6D4; continue 'dispatch;
            }
            0x821DA6D4 => {
    //   block [0x821DA6D4..0x821DA6F0)
	// 821DA6D4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821DA6D8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DA6DC: 419A0014  beq cr6, 0x821da6f0
	if ctx.cr[6].eq {
	pc = 0x821DA6F0; continue 'dispatch;
	}
	// 821DA6E0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821DA6E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821DA6E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821DA6EC: 4800000C  b 0x821da6f8
	pc = 0x821DA6F8; continue 'dispatch;
            }
            0x821DA6F0 => {
    //   block [0x821DA6F0..0x821DA6F8)
	// 821DA6F0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821DA6F4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821DA6F8; continue 'dispatch;
            }
            0x821DA6F8 => {
    //   block [0x821DA6F8..0x821DA704)
	// 821DA6F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DA6FC: 4199FFB8  bgt cr6, 0x821da6b4
	if ctx.cr[6].gt {
	pc = 0x821DA6B4; continue 'dispatch;
	}
	// 821DA700: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x821DA704; continue 'dispatch;
            }
            0x821DA704 => {
    //   block [0x821DA704..0x821DA720)
	// 821DA704: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821DA708: 419A003C  beq cr6, 0x821da744
	if ctx.cr[6].eq {
	pc = 0x821DA744; continue 'dispatch;
	}
	// 821DA70C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA710: 2F0B007A  cmpwi cr6, r11, 0x7a
	ctx.cr[6].compare_i32(ctx.r[11].s32, 122, &mut ctx.xer);
	// 821DA714: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DA718: 41990008  bgt cr6, 0x821da720
	if ctx.cr[6].gt {
	pc = 0x821DA720; continue 'dispatch;
	}
	// 821DA71C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x821DA720; continue 'dispatch;
            }
            0x821DA720 => {
    //   block [0x821DA720..0x821DA744)
	// 821DA720: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DA724: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA728: 409A001C  bne cr6, 0x821da744
	if !ctx.cr[6].eq {
	pc = 0x821DA744; continue 'dispatch;
	}
	// 821DA72C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821DA730: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DA734: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821DA738: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821DA73C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA740: 48000018  b 0x821da758
	pc = 0x821DA758; continue 'dispatch;
            }
            0x821DA744 => {
    //   block [0x821DA744..0x821DA754)
	// 821DA744: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821DA748: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DA74C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA750: 48000008  b 0x821da758
	pc = 0x821DA758; continue 'dispatch;
            }
            0x821DA754 => {
    //   block [0x821DA754..0x821DA758)
	// 821DA754: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	pc = 0x821DA758; continue 'dispatch;
            }
            0x821DA758 => {
    //   block [0x821DA758..0x821DA780)
	// 821DA758: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821DA75C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DA760: 419A0020  beq cr6, 0x821da780
	if ctx.cr[6].eq {
	pc = 0x821DA780; continue 'dispatch;
	}
	// 821DA764: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821DA768: 4BFE82B1  bl 0x821c2a18
	ctx.lr = 0x821DA76C;
	sub_821C2A18(ctx, base);
	// 821DA76C: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 821DA770: 409A0010  bne cr6, 0x821da780
	if !ctx.cr[6].eq {
	pc = 0x821DA780; continue 'dispatch;
	}
	// 821DA774: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821DA778: 388BA40C  addi r4, r11, -0x5bf4
	ctx.r[4].s64 = ctx.r[11].s64 + -23540;
	// 821DA77C: 48000134  b 0x821da8b0
	pc = 0x821DA8B0; continue 'dispatch;
            }
            0x821DA780 => {
    //   block [0x821DA780..0x821DA7BC)
	// 821DA780: 81460024  lwz r10, 0x24(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 821DA784: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821DA788: 5549A7FE  rlwinm r9, r10, 0x14, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000FFFu64;
	// 821DA78C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DA790: 419A00E8  beq cr6, 0x821da878
	if ctx.cr[6].eq {
	pc = 0x821DA878; continue 'dispatch;
	}
	// 821DA794: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 821DA798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA79C: 419A0020  beq cr6, 0x821da7bc
	if ctx.cr[6].eq {
	pc = 0x821DA7BC; continue 'dispatch;
	}
	// 821DA7A0: 894B000C  lbz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DA7A4: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DA7A8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821DA7AC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821DA7B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DA7B4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA7B8: 480000C4  b 0x821da87c
	pc = 0x821DA87C; continue 'dispatch;
            }
            0x821DA7BC => {
    //   block [0x821DA7BC..0x821DA7D8)
	// 821DA7BC: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DA7C0: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 821DA7C4: 90810060  stw r4, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[4].u32 ) };
	// 821DA7C8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821DA7CC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821DA7D0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DA7D4: 40810054  ble 0x821da828
	if !ctx.cr[0].gt {
	pc = 0x821DA828; continue 'dispatch;
	}
	pc = 0x821DA7D8; continue 'dispatch;
            }
            0x821DA7D8 => {
    //   block [0x821DA7D8..0x821DA7F8)
	// 821DA7D8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821DA7DC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DA7E0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821DA7E4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA7E8: 2F07000C  cmpwi cr6, r7, 0xc
	ctx.cr[6].compare_i32(ctx.r[7].s32, 12, &mut ctx.xer);
	// 821DA7EC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821DA7F0: 41980008  blt cr6, 0x821da7f8
	if ctx.cr[6].lt {
	pc = 0x821DA7F8; continue 'dispatch;
	}
	// 821DA7F4: 7C872378  mr r7, r4
	ctx.r[7].u64 = ctx.r[4].u64;
	pc = 0x821DA7F8; continue 'dispatch;
            }
            0x821DA7F8 => {
    //   block [0x821DA7F8..0x821DA814)
	// 821DA7F8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821DA7FC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DA800: 419A0014  beq cr6, 0x821da814
	if ctx.cr[6].eq {
	pc = 0x821DA814; continue 'dispatch;
	}
	// 821DA804: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821DA808: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821DA80C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821DA810: 4800000C  b 0x821da81c
	pc = 0x821DA81C; continue 'dispatch;
            }
            0x821DA814 => {
    //   block [0x821DA814..0x821DA81C)
	// 821DA814: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821DA818: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821DA81C; continue 'dispatch;
            }
            0x821DA81C => {
    //   block [0x821DA81C..0x821DA828)
	// 821DA81C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DA820: 4199FFB8  bgt cr6, 0x821da7d8
	if ctx.cr[6].gt {
	pc = 0x821DA7D8; continue 'dispatch;
	}
	// 821DA824: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x821DA828; continue 'dispatch;
            }
            0x821DA828 => {
    //   block [0x821DA828..0x821DA844)
	// 821DA828: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821DA82C: 419A003C  beq cr6, 0x821da868
	if ctx.cr[6].eq {
	pc = 0x821DA868; continue 'dispatch;
	}
	// 821DA830: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA834: 2F0B000C  cmpwi cr6, r11, 0xc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 12, &mut ctx.xer);
	// 821DA838: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DA83C: 41990008  bgt cr6, 0x821da844
	if ctx.cr[6].gt {
	pc = 0x821DA844; continue 'dispatch;
	}
	// 821DA840: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x821DA844; continue 'dispatch;
            }
            0x821DA844 => {
    //   block [0x821DA844..0x821DA868)
	// 821DA844: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DA848: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA84C: 409A001C  bne cr6, 0x821da868
	if !ctx.cr[6].eq {
	pc = 0x821DA868; continue 'dispatch;
	}
	// 821DA850: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821DA854: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DA858: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821DA85C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821DA860: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA864: 48000018  b 0x821da87c
	pc = 0x821DA87C; continue 'dispatch;
            }
            0x821DA868 => {
    //   block [0x821DA868..0x821DA878)
	// 821DA868: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821DA86C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DA870: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA874: 48000008  b 0x821da87c
	pc = 0x821DA87C; continue 'dispatch;
            }
            0x821DA878 => {
    //   block [0x821DA878..0x821DA87C)
	// 821DA878: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	pc = 0x821DA87C; continue 'dispatch;
            }
            0x821DA87C => {
    //   block [0x821DA87C..0x821DA8A8)
	// 821DA87C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821DA880: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DA884: 419A0034  beq cr6, 0x821da8b8
	if ctx.cr[6].eq {
	pc = 0x821DA8B8; continue 'dispatch;
	}
	// 821DA888: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DA88C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821DA890: 419A0018  beq cr6, 0x821da8a8
	if ctx.cr[6].eq {
	pc = 0x821DA8A8; continue 'dispatch;
	}
	// 821DA894: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821DA898: 409A0020  bne cr6, 0x821da8b8
	if !ctx.cr[6].eq {
	pc = 0x821DA8B8; continue 'dispatch;
	}
	// 821DA89C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821DA8A0: 388BA420  addi r4, r11, -0x5be0
	ctx.r[4].s64 = ctx.r[11].s64 + -23520;
	// 821DA8A4: 4800000C  b 0x821da8b0
	pc = 0x821DA8B0; continue 'dispatch;
            }
            0x821DA8A8 => {
    //   block [0x821DA8A8..0x821DA8B0)
	// 821DA8A8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821DA8AC: 388BA414  addi r4, r11, -0x5bec
	ctx.r[4].s64 = ctx.r[11].s64 + -23532;
	pc = 0x821DA8B0; continue 'dispatch;
            }
            0x821DA8B0 => {
    //   block [0x821DA8B0..0x821DA8B8)
	// 821DA8B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA8B4: 4800010D  bl 0x821da9c0
	ctx.lr = 0x821DA8B8;
	sub_821DA9C0(ctx, base);
	pc = 0x821DA8B8; continue 'dispatch;
            }
            0x821DA8B8 => {
    //   block [0x821DA8B8..0x821DA928)
	// 821DA8B8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DA8BC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821DA8C0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DA8C4: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821DA8C8: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA8CC: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA8D0: 4870B1A9  bl 0x828e5a78
	ctx.lr = 0x821DA8D4;
	sub_828E5A78(ctx, base);
	// 821DA8D4: 80FE0004  lwz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DA8D8: 7F071840  cmplw cr6, r7, r3
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821DA8DC: 409A004C  bne cr6, 0x821da928
	if !ctx.cr[6].eq {
	pc = 0x821DA928; continue 'dispatch;
	}
	// 821DA8E0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821DA8E4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821DA8E8: 388BA428  addi r4, r11, -0x5bd8
	ctx.r[4].s64 = ctx.r[11].s64 + -23512;
	// 821DA8EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DA8F0: 480525E1  bl 0x8222ced0
	ctx.lr = 0x821DA8F4;
	sub_8222CED0(ctx, base);
	// 821DA8F4: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 821DA8F8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821DA8FC: 388AA438  addi r4, r10, -0x5bc8
	ctx.r[4].s64 = ctx.r[10].s64 + -23496;
	// 821DA900: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821DA904: 480525CD  bl 0x8222ced0
	ctx.lr = 0x821DA908;
	sub_8222CED0(ctx, base);
	// 821DA908: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821DA90C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 821DA910: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA914: 4800BF35  bl 0x821e6848
	ctx.lr = 0x821DA918;
	sub_821E6848(ctx, base);
	// 821DA918: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821DA91C: 4803A4BD  bl 0x82214dd8
	ctx.lr = 0x821DA920;
	sub_82214DD8(ctx, base);
	// 821DA920: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DA924: 4803A4B5  bl 0x82214dd8
	ctx.lr = 0x821DA928;
	sub_82214DD8(ctx, base);
	pc = 0x821DA928; continue 'dispatch;
            }
            0x821DA928 => {
    //   block [0x821DA928..0x821DA950)
	// 821DA928: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821DA92C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA930: 48015911  bl 0x821f0240
	ctx.lr = 0x821DA934;
	sub_821F0240(ctx, base);
	// 821DA934: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DA938: 4803A4A1  bl 0x82214dd8
	ctx.lr = 0x821DA93C;
	sub_82214DD8(ctx, base);
	// 821DA93C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA940: 4803A499  bl 0x82214dd8
	ctx.lr = 0x821DA944;
	sub_82214DD8(ctx, base);
	// 821DA944: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA948: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821DA94C: 48ACEB10  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821DA950 => {
    //   block [0x821DA950..0x821DA974)
	// 821DA950: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821DA954: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA958: 388B5E78  addi r4, r11, 0x5e78
	ctx.r[4].s64 = ctx.r[11].s64 + 24184;
	// 821DA95C: 480158E5  bl 0x821f0240
	ctx.lr = 0x821DA960;
	sub_821F0240(ctx, base);
	// 821DA960: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DA964: 4803A475  bl 0x82214dd8
	ctx.lr = 0x821DA968;
	sub_82214DD8(ctx, base);
	// 821DA968: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DA96C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821DA970: 48ACEAEC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DA978(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DA978 size=72
    let mut pc: u32 = 0x821DA978;
    'dispatch: loop {
        match pc {
            0x821DA978 => {
    //   block [0x821DA978..0x821DA9C0)
	// 821DA978: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DA97C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DA980: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821DA984: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DA988: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DA98C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DA990: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821DA994: 480158AD  bl 0x821f0240
	ctx.lr = 0x821DA998;
	sub_821F0240(ctx, base);
	// 821DA998: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DA99C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821DA9A0: 48000021  bl 0x821da9c0
	ctx.lr = 0x821DA9A4;
	sub_821DA9C0(ctx, base);
	// 821DA9A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DA9A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821DA9AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DA9B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DA9B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821DA9B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821DA9BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DA9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DA9C0 size=216
    let mut pc: u32 = 0x821DA9C0;
    'dispatch: loop {
        match pc {
            0x821DA9C0 => {
    //   block [0x821DA9C0..0x821DA9FC)
	// 821DA9C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DA9C4: 48ACEA45  bl 0x82ca9408
	ctx.lr = 0x821DA9C8;
	sub_82CA93D0(ctx, base);
	// 821DA9C8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DA9CC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821DA9D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821DA9D4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA9D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DA9DC: 419A0020  beq cr6, 0x821da9fc
	if ctx.cr[6].eq {
	pc = 0x821DA9FC; continue 'dispatch;
	}
	// 821DA9E0: 48053E19  bl 0x8222e7f8
	ctx.lr = 0x821DA9E4;
	sub_8222E7F8(ctx, base);
	// 821DA9E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821DA9E8: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DA9EC: 48963F15  bl 0x82b3e900
	ctx.lr = 0x821DA9F0;
	sub_82B3E900(ctx, base);
	// 821DA9F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821DA9F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DA9F8: 48ACEA60  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x821DA9FC => {
    //   block [0x821DA9FC..0x821DAA44)
	// 821DA9FC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821DAA00: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821DAA04: 419A0068  beq cr6, 0x821daa6c
	if ctx.cr[6].eq {
	pc = 0x821DAA6C; continue 'dispatch;
	}
	// 821DAA08: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAA0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DAA10: 419A005C  beq cr6, 0x821daa6c
	if ctx.cr[6].eq {
	pc = 0x821DAA6C; continue 'dispatch;
	}
	// 821DAA14: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 821DAA18: 48044841  bl 0x8221f258
	ctx.lr = 0x821DAA1C;
	sub_8221F258(ctx, base);
	// 821DAA1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DAA20: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821DAA24: 419A0048  beq cr6, 0x821daa6c
	if ctx.cr[6].eq {
	pc = 0x821DAA6C; continue 'dispatch;
	}
	// 821DAA28: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 821DAA2C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821DAA30: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821DAA34: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 821DAA38: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAA3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DAA40: 419A0014  beq cr6, 0x821daa54
	if ctx.cr[6].eq {
	pc = 0x821DAA54; continue 'dispatch;
	}
	pc = 0x821DAA44; continue 'dispatch;
            }
            0x821DAA44 => {
    //   block [0x821DAA44..0x821DAA54)
	// 821DAA44: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821DAA48: 7D65F0AE  lbzx r11, r5, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 821DAA4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DAA50: 409AFFF4  bne cr6, 0x821daa44
	if !ctx.cr[6].eq {
	pc = 0x821DAA44; continue 'dispatch;
	}
	pc = 0x821DAA54; continue 'dispatch;
            }
            0x821DAA54 => {
    //   block [0x821DAA54..0x821DAA6C)
	// 821DAA54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821DAA58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DAA5C: 4802DD1D  bl 0x82208778
	ctx.lr = 0x821DAA60;
	sub_82208778(ctx, base);
	// 821DAA60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DAA64: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 821DAA68: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x821DAA6C; continue 'dispatch;
            }
            0x821DAA6C => {
    //   block [0x821DAA6C..0x821DAA80)
	// 821DAA6C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAA70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DAA74: 419A000C  beq cr6, 0x821daa80
	if ctx.cr[6].eq {
	pc = 0x821DAA80; continue 'dispatch;
	}
	// 821DAA78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821DAA7C: 4BFEBCED  bl 0x821c6768
	ctx.lr = 0x821DAA80;
	sub_821C6768(ctx, base);
	pc = 0x821DAA80; continue 'dispatch;
            }
            0x821DAA80 => {
    //   block [0x821DAA80..0x821DAA8C)
	// 821DAA80: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821DAA84: 419A0008  beq cr6, 0x821daa8c
	if ctx.cr[6].eq {
	pc = 0x821DAA8C; continue 'dispatch;
	}
	// 821DAA88: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x821DAA8C; continue 'dispatch;
            }
            0x821DAA8C => {
    //   block [0x821DAA8C..0x821DAA98)
	// 821DAA8C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821DAA90: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DAA94: 48ACE9C4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DAA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DAA98 size=176
    let mut pc: u32 = 0x821DAA98;
    'dispatch: loop {
        match pc {
            0x821DAA98 => {
    //   block [0x821DAA98..0x821DAB30)
	// 821DAA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DAA9C: 48ACE971  bl 0x82ca940c
	ctx.lr = 0x821DAAA0;
	sub_82CA93D0(ctx, base);
	// 821DAAA0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DAAA4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821DAAA8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821DAAAC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821DAAB0: 815F0080  lwz r10, 0x80(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 821DAAB4: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 821DAAB8: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821DAABC: 40990074  ble cr6, 0x821dab30
	if !ctx.cr[6].gt {
	pc = 0x821DAB30; continue 'dispatch;
	}
	// 821DAAC0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DAAC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DAAC8: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821DAACC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAAD0: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821DAAD4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821DAAD8: 4E800421  bctrl
	ctx.lr = 0x821DAADC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DAADC: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821DAAE0: 3BDF0070  addi r30, r31, 0x70
	ctx.r[30].s64 = ctx.r[31].s64 + 112;
	// 821DAAE4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821DAAE8: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
            }
            0x821DAB30 => {
    //   block [0x821DAB30..0x821DAB48)
	// 821DAB30: 39600070  li r11, 0x70
	ctx.r[11].s64 = 112;
	// 821DAB34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DAB48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DAB48 size=204
    let mut pc: u32 = 0x821DAB48;
    'dispatch: loop {
        match pc {
            0x821DAB48 => {
    //   block [0x821DAB48..0x821DAB94)
	// 821DAB48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DAB4C: 48ACE8BD  bl 0x82ca9408
	ctx.lr = 0x821DAB50;
	sub_82CA93D0(ctx, base);
	// 821DAB50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DAB54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821DAB58: 90A10058  stw r5, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 821DAB5C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821DAB60: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 821DAB64: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 821DAB68: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821DAB6C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821DAB70: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 821DAB74: 48039D25  bl 0x82214898
	ctx.lr = 0x821DAB78;
	sub_82214898(ctx, base);
	// 821DAB78: 817C0050  lwz r11, 0x50(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(80 as u32) ) } as u64;
	// 821DAB7C: 3BFC004C  addi r31, r28, 0x4c
	ctx.r[31].s64 = ctx.r[28].s64 + 76;
	// 821DAB80: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 821DAB84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DAB88: 409A000C  bne cr6, 0x821dab94
	if !ctx.cr[6].eq {
	pc = 0x821DAB94; continue 'dispatch;
	}
	// 821DAB8C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 821DAB90: 48000010  b 0x821daba0
	pc = 0x821DABA0; continue 'dispatch;
            }
            0x821DAB94 => {
    //   block [0x821DAB94..0x821DABA0)
	// 821DAB94: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DAB98: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821DAB9C: 7D484BD6  divw r10, r8, r9
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x821DABA0; continue 'dispatch;
            }
            0x821DABA0 => {
    //   block [0x821DABA0..0x821DABC8)
	// 821DABA0: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DABA4: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 821DABA8: 7D2B4BD6  divw r9, r11, r9
	ctx.r[9].s32 = ctx.r[11].s32 / ctx.r[9].s32;
	// 821DABAC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DABB0: 40980024  bge cr6, 0x821dabd4
	if !ctx.cr[6].lt {
	pc = 0x821DABD4; continue 'dispatch;
	}
	// 821DABB4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821DABB8: 419A0010  beq cr6, 0x821dabc8
	if ctx.cr[6].eq {
	pc = 0x821DABC8; continue 'dispatch;
	}
	// 821DABBC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 821DABC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821DABC4: 483A53AD  bl 0x8257ff70
	ctx.lr = 0x821DABC8;
	sub_8257FF70(ctx, base);
	pc = 0x821DABC8; continue 'dispatch;
            }
            0x821DABC8 => {
    //   block [0x821DABC8..0x821DABD4)
	// 821DABC8: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 821DABCC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821DABD0: 48000020  b 0x821dabf0
	pc = 0x821DABF0; continue 'dispatch;
            }
            0x821DABD4 => {
    //   block [0x821DABD4..0x821DABF0)
	// 821DABD4: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 821DABD8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821DABDC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821DABE0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821DABE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DABE8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DABEC: 4855285D  bl 0x8272d448
	ctx.lr = 0x821DABF0;
	sub_8272D448(ctx, base);
	pc = 0x821DABF0; continue 'dispatch;
            }
            0x821DABF0 => {
    //   block [0x821DABF0..0x821DAC14)
	// 821DABF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821DABF4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 821DABF8: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 821DABFC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821DAC00: 4BFB9239  bl 0x82193e38
	ctx.lr = 0x821DAC04;
	sub_82193E38(ctx, base);
	// 821DAC04: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821DAC08: 4809FB69  bl 0x8227a770
	ctx.lr = 0x821DAC0C;
	sub_8227A770(ctx, base);
	// 821DAC0C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821DAC10: 48ACE848  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DAC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DAC18 size=504
    let mut pc: u32 = 0x821DAC18;
    'dispatch: loop {
        match pc {
            0x821DAC18 => {
    //   block [0x821DAC18..0x821DAE10)
	// 821DAC18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DAC1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DAC20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821DAC24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DAC28: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 821DAC2C: 48AD30AD  bl 0x82cadcd8
	ctx.lr = 0x821DAC30;
	sub_82CADCA0(ctx, base);
	// 821DAC30: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DAE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DAE10 size=472
    let mut pc: u32 = 0x821DAE10;
    'dispatch: loop {
        match pc {
            0x821DAE10 => {
    //   block [0x821DAE10..0x821DAEB4)
	// 821DAE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DAE14: 48ACE5E1  bl 0x82ca93f4
	ctx.lr = 0x821DAE18;
	sub_82CA93D0(ctx, base);
	// 821DAE18: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 821DAE1C: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DAE20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAE24: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 821DAE28: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821DAE2C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DAE30: 4E800421  bctrl
	ctx.lr = 0x821DAE34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DAE34: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821DAE38: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821DAE3C: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 821DAE40: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821DAE44: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821DAE48: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 821DAE4C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAE50: 80E80020  lwz r7, 0x20(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DAE54: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821DAE58: 4E800421  bctrl
	ctx.lr = 0x821DAE5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DAE5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DAE60: 48025481  bl 0x822002e0
	ctx.lr = 0x821DAE64;
	sub_822002E0(ctx, base);
	// 821DAE64: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DAE68: 83210050  lwz r25, 0x50(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821DAE6C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821DAE70: 419A00B8  beq cr6, 0x821daf28
	if ctx.cr[6].eq {
	pc = 0x821DAF28; continue 'dispatch;
	}
	// 821DAE74: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 821DAE78: 38990024  addi r4, r25, 0x24
	ctx.r[4].s64 = ctx.r[25].s64 + 36;
	// 821DAE7C: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 821DAE80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DAE84: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 821DAE88: 48015469  bl 0x821f02f0
	ctx.lr = 0x821DAE8C;
	sub_821F02F0(ctx, base);
	// 821DAE8C: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 821DAE90: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 821DAE94: 83410064  lwz r26, 0x64(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821DAE98: 83010068  lwz r24, 0x68(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 821DAE9C: 7D5AC050  subf r10, r26, r24
	ctx.r[10].s64 = ctx.r[24].s64 - ctx.r[26].s64;
	// 821DAEA0: 7F8A5BD7  divw. r28, r10, r11
	ctx.r[28].s32 = ctx.r[10].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821DAEA4: 41820064  beq 0x821daf08
	if ctx.cr[0].eq {
	pc = 0x821DAF08; continue 'dispatch;
	}
	// 821DAEA8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821DAEAC: 3BFA0004  addi r31, r26, 4
	ctx.r[31].s64 = ctx.r[26].s64 + 4;
	// 821DAEB0: 3B6BFFDF  addi r27, r11, -0x21
	ctx.r[27].s64 = ctx.r[11].s64 + -33;
            }
            0x821DAEB4 => {
    //   block [0x821DAEB4..0x821DAECC)
	// 821DAEB4: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAEB8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821DAEBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DAEC0: 419A000C  beq cr6, 0x821daecc
	if ctx.cr[6].eq {
	pc = 0x821DAECC; continue 'dispatch;
	}
	// 821DAEC4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DAEC8: 409A000C  bne cr6, 0x821daed4
	if !ctx.cr[6].eq {
	pc = 0x821DAED4; continue 'dispatch;
	}
	pc = 0x821DAECC; continue 'dispatch;
            }
            0x821DAECC => {
    //   block [0x821DAECC..0x821DAED4)
	// 821DAECC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821DAED0: 48000008  b 0x821daed8
	pc = 0x821DAED8; continue 'dispatch;
            }
            0x821DAED4 => {
    //   block [0x821DAED4..0x821DAED8)
	// 821DAED4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821DAED8; continue 'dispatch;
            }
            0x821DAED8 => {
    //   block [0x821DAED8..0x821DAEEC)
	// 821DAED8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAEDC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821DAEE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DAEE4: 419A0008  beq cr6, 0x821daeec
	if ctx.cr[6].eq {
	pc = 0x821DAEEC; continue 'dispatch;
	}
	// 821DAEE8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821DAEEC; continue 'dispatch;
            }
            0x821DAEEC => {
    //   block [0x821DAEEC..0x821DAF08)
	// 821DAEEC: 48ACF205  bl 0x82caa0f0
	ctx.lr = 0x821DAEF0;
	sub_82CAA0F0(ctx, base);
	// 821DAEF0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821DAEF4: 419A0090  beq cr6, 0x821daf84
	if ctx.cr[6].eq {
	pc = 0x821DAF84; continue 'dispatch;
	}
	// 821DAEF8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 821DAEFC: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 821DAF00: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821DAF04: 409AFFB0  bne cr6, 0x821daeb4
	if !ctx.cr[6].eq {
	pc = 0x821DAEB4; continue 'dispatch;
	}
	pc = 0x821DAF08; continue 'dispatch;
            }
            0x821DAF08 => {
    //   block [0x821DAF08..0x821DAF28)
	// 821DAF08: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 821DAF0C: 419A001C  beq cr6, 0x821daf28
	if ctx.cr[6].eq {
	pc = 0x821DAF28; continue 'dispatch;
	}
	// 821DAF10: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821DAF14: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 821DAF18: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821DAF1C: 4838BAF5  bl 0x82566a10
	ctx.lr = 0x821DAF20;
	sub_82566A10(ctx, base);
	// 821DAF20: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821DAF24: 48040E15  bl 0x8221bd38
	ctx.lr = 0x821DAF28;
	sub_8221BD38(ctx, base);
	pc = 0x821DAF28; continue 'dispatch;
            }
            0x821DAF28 => {
    //   block [0x821DAF28..0x821DAF34)
	// 821DAF28: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821DAF2C: 419A0044  beq cr6, 0x821daf70
	if ctx.cr[6].eq {
	pc = 0x821DAF70; continue 'dispatch;
	}
	// 821DAF30: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	pc = 0x821DAF34; continue 'dispatch;
            }
            0x821DAF34 => {
    //   block [0x821DAF34..0x821DAF70)
	// 821DAF34: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821DAF38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821DAF3C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821DAF40: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821DAF44: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821DAF48: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821DAF4C: 4082FFE8  bne 0x821daf34
	if !ctx.cr[0].eq {
	pc = 0x821DAF34; continue 'dispatch;
	}
	// 821DAF50: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821DAF54: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DAF58: 409A0018  bne cr6, 0x821daf70
	if !ctx.cr[6].eq {
	pc = 0x821DAF70; continue 'dispatch;
	}
	// 821DAF5C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAF60: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821DAF64: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DAF68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DAF6C: 4E800421  bctrl
	ctx.lr = 0x821DAF70;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821DAF70 => {
    //   block [0x821DAF70..0x821DAF84)
	// 821DAF70: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DAF74: C02BD5C8  lfs f1, -0x2a38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821DAF78: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821DAF7C: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821DAF80: 48ACE4C4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x821DAF84 => {
    //   block [0x821DAF84..0x821DAF9C)
	// 821DAF84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DAF88: C3FFFFFC  lfs f31, -4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821DAF8C: 4881474D  bl 0x829ef6d8
	ctx.lr = 0x821DAF90;
	sub_829EF6D8(ctx, base);
	// 821DAF90: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821DAF94: 419A0044  beq cr6, 0x821dafd8
	if ctx.cr[6].eq {
	pc = 0x821DAFD8; continue 'dispatch;
	}
	// 821DAF98: 39790004  addi r11, r25, 4
	ctx.r[11].s64 = ctx.r[25].s64 + 4;
	pc = 0x821DAF9C; continue 'dispatch;
            }
            0x821DAF9C => {
    //   block [0x821DAF9C..0x821DAFD8)
	// 821DAF9C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821DAFA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821DAFA4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821DAFA8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821DAFAC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821DAFB0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821DAFB4: 4082FFE8  bne 0x821daf9c
	if !ctx.cr[0].eq {
	pc = 0x821DAF9C; continue 'dispatch;
	}
	// 821DAFB8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821DAFBC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DAFC0: 409A0018  bne cr6, 0x821dafd8
	if !ctx.cr[6].eq {
	pc = 0x821DAFD8; continue 'dispatch;
	}
	// 821DAFC4: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DAFC8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821DAFCC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DAFD0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DAFD4: 4E800421  bctrl
	ctx.lr = 0x821DAFD8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821DAFD8 => {
    //   block [0x821DAFD8..0x821DAFE8)
	// 821DAFD8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821DAFDC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821DAFE0: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821DAFE4: 48ACE460  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DAFE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DAFE8 size=116
    let mut pc: u32 = 0x821DAFE8;
    'dispatch: loop {
        match pc {
            0x821DAFE8 => {
    //   block [0x821DAFE8..0x821DB044)
	// 821DAFE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DAFEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DAFF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DAFF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DAFF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DAFFC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB000: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821DB004: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DB008: 4E800421  bctrl
	ctx.lr = 0x821DB00C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB00C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DB010: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DB014: 419A0030  beq cr6, 0x821db044
	if ctx.cr[6].eq {
	pc = 0x821DB044; continue 'dispatch;
	}
	// 821DB018: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DB01C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB020: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821DB024: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DB028: 4E800421  bctrl
	ctx.lr = 0x821DB02C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB02C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821DB030: 48000031  bl 0x821db060
	ctx.lr = 0x821DB034;
	sub_821DB060(ctx, base);
	// 821DB034: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DB038: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821DB03C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DB040: 409A0008  bne cr6, 0x821db048
	if !ctx.cr[6].eq {
	pc = 0x821DB048; continue 'dispatch;
	}
            }
            0x821DB044 => {
    //   block [0x821DB044..0x821DB048)
	// 821DB044: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821DB048; continue 'dispatch;
            }
            0x821DB048 => {
    //   block [0x821DB048..0x821DB05C)
	// 821DB048: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821DB04C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DB050: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DB054: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821DB058: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DB060 size=200
    let mut pc: u32 = 0x821DB060;
    'dispatch: loop {
        match pc {
            0x821DB060 => {
    //   block [0x821DB060..0x821DB088)
	// 821DB060: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 821DB064: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 821DB068: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DB06C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821DB070: 7D093050  subf r8, r9, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 821DB074: 9141FFF0  stw r10, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[10].u32 ) };
	// 821DB078: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 821DB07C: 9121FFF4  stw r9, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[9].u32 ) };
	// 821DB080: 7D685BD7  divw. r11, r8, r11
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DB084: 4081005C  ble 0x821db0e0
	if !ctx.cr[0].gt {
	pc = 0x821DB0E0; continue 'dispatch;
	}
	pc = 0x821DB088; continue 'dispatch;
            }
            0x821DB088 => {
    //   block [0x821DB088..0x821DB0B0)
	// 821DB088: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821DB08C: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DB090: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821DB094: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DB098: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821DB09C: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB0A0: 7F072000  cmpw cr6, r7, r4
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[4].s32, &mut ctx.xer);
	// 821DB0A4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821DB0A8: 41980008  blt cr6, 0x821db0b0
	if ctx.cr[6].lt {
	pc = 0x821DB0B0; continue 'dispatch;
	}
	// 821DB0AC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821DB0B0; continue 'dispatch;
            }
            0x821DB0B0 => {
    //   block [0x821DB0B0..0x821DB0CC)
	// 821DB0B0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821DB0B4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DB0B8: 419A0014  beq cr6, 0x821db0cc
	if ctx.cr[6].eq {
	pc = 0x821DB0CC; continue 'dispatch;
	}
	// 821DB0BC: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821DB0C0: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 821DB0C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821DB0C8: 4800000C  b 0x821db0d4
	pc = 0x821DB0D4; continue 'dispatch;
            }
            0x821DB0CC => {
    //   block [0x821DB0CC..0x821DB0D4)
	// 821DB0CC: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821DB0D0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x821DB0D4; continue 'dispatch;
            }
            0x821DB0D4 => {
    //   block [0x821DB0D4..0x821DB0E0)
	// 821DB0D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DB0D8: 4199FFB0  bgt cr6, 0x821db088
	if ctx.cr[6].gt {
	pc = 0x821DB088; continue 'dispatch;
	}
	// 821DB0DC: 9121FFF4  stw r9, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[9].u32 ) };
	pc = 0x821DB0E0; continue 'dispatch;
            }
            0x821DB0E0 => {
    //   block [0x821DB0E0..0x821DB0FC)
	// 821DB0E0: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821DB0E4: 419A0044  beq cr6, 0x821db128
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x821DB128);
		return;
	}
	// 821DB0E8: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB0EC: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821DB0F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DB0F4: 41980008  blt cr6, 0x821db0fc
	if ctx.cr[6].lt {
	pc = 0x821DB0FC; continue 'dispatch;
	}
	// 821DB0F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821DB0FC; continue 'dispatch;
            }
            0x821DB0FC => {
    //   block [0x821DB0FC..0x821DB128)
	// 821DB0FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DB100: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DB104: 409A0024  bne cr6, 0x821db128
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x821DB128);
		return;
	}
	// 821DB108: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821DB10C: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821DB110: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821DB114: 7D6B2850  subf r11, r11, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821DB118: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821DB11C: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821DB120: 69230001  xori r3, r9, 1
	ctx.r[3].u64 = ctx.r[9].u64 ^ 1;
	// 821DB124: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DB140 size=640
    let mut pc: u32 = 0x821DB140;
    'dispatch: loop {
        match pc {
            0x821DB140 => {
    //   block [0x821DB140..0x821DB1C8)
	// 821DB140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DB144: 48ACE2C5  bl 0x82ca9408
	ctx.lr = 0x821DB148;
	sub_82CA93D0(ctx, base);
	// 821DB148: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 821DB14C: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821DB150: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DB154: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DB158: 4808E409  bl 0x82269560
	ctx.lr = 0x821DB15C;
	sub_82269560(ctx, base);
	// 821DB15C: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 821DB160: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DB164: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DB168: 9B9F0020  stb r28, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[28].u8 ) };
	// 821DB16C: 4182005C  beq 0x821db1c8
	if ctx.cr[0].eq {
	pc = 0x821DB1C8; continue 'dispatch;
	}
	// 821DB170: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DB174: 83DF01DC  lwz r30, 0x1dc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 821DB178: 83AB0014  lwz r29, 0x14(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB17C: 4808583D  bl 0x822609b8
	ctx.lr = 0x821DB180;
	sub_822609B8(ctx, base);
	// 821DB180: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821DB184: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821DB188: 4BFD4C69  bl 0x821afdf0
	ctx.lr = 0x821DB18C;
	sub_821AFDF0(ctx, base);
	// 821DB18C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DB190: 41820038  beq 0x821db1c8
	if ctx.cr[0].eq {
	pc = 0x821DB1C8; continue 'dispatch;
	}
	// 821DB194: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DB198: 480EB589  bl 0x822c6720
	ctx.lr = 0x821DB19C;
	sub_822C6720(ctx, base);
	// 821DB19C: 987F01E0  stb r3, 0x1e0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), ctx.r[3].u8 ) };
	// 821DB1A0: 48085819  bl 0x822609b8
	ctx.lr = 0x821DB1A4;
	sub_822609B8(ctx, base);
	// 821DB1A4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DB1A8: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DB1AC: 83DF01DC  lwz r30, 0x1dc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) } as u64;
	// 821DB1B0: D01F01E4  stfs f0, 0x1e4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 821DB1B4: 83AB0014  lwz r29, 0x14(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB1B8: 48085801  bl 0x822609b8
	ctx.lr = 0x821DB1BC;
	sub_822609B8(ctx, base);
	// 821DB1BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821DB1C0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821DB1C4: 480EA075  bl 0x822c5238
	ctx.lr = 0x821DB1C8;
	sub_822C5238(ctx, base);
	pc = 0x821DB1C8; continue 'dispatch;
            }
            0x821DB1C8 => {
    //   block [0x821DB1C8..0x821DB208)
	// 821DB1C8: 897F000C  lbz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DB1CC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DB1D0: 41820038  beq 0x821db208
	if ctx.cr[0].eq {
	pc = 0x821DB208; continue 'dispatch;
	}
	// 821DB1D4: 897F01E0  lbz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 821DB1D8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DB1DC: 4182002C  beq 0x821db208
	if ctx.cr[0].eq {
	pc = 0x821DB208; continue 'dispatch;
	}
	// 821DB1E0: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821DB1E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DB1E8: 419A0028  beq cr6, 0x821db210
	if ctx.cr[6].eq {
	pc = 0x821DB210; continue 'dispatch;
	}
	// 821DB1EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821DB1F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DB1F4: 48C95DCD  bl 0x82e70fc0
	ctx.lr = 0x821DB1F8;
	sub_82E70FC0(ctx, base);
	// 821DB1F8: 480857C1  bl 0x822609b8
	ctx.lr = 0x821DB1FC;
	sub_822609B8(ctx, base);
	// 821DB1FC: C003004C  lfs f0, 0x4c(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DB200: D01F01D0  stfs f0, 0x1d0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 821DB204: 4800000C  b 0x821db210
	pc = 0x821DB210; continue 'dispatch;
            }
            0x821DB208 => {
    //   block [0x821DB208..0x821DB210)
	// 821DB208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DB20C: 480C1DCD  bl 0x8229cfd8
	ctx.lr = 0x821DB210;
	sub_8229CFD8(ctx, base);
	pc = 0x821DB210; continue 'dispatch;
            }
            0x821DB210 => {
    //   block [0x821DB210..0x821DB2A8)
	// 821DB210: 897F01B0  lbz r11, 0x1b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(432 as u32) ) } as u64;
	// 821DB214: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DB218: 41820194  beq 0x821db3ac
	if ctx.cr[0].eq {
	pc = 0x821DB3AC; continue 'dispatch;
	}
	// 821DB21C: 897F01E0  lbz r11, 0x1e0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) } as u64;
	// 821DB220: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DB224: 40820188  bne 0x821db3ac
	if !ctx.cr[0].eq {
	pc = 0x821DB3AC; continue 'dispatch;
	}
	// 821DB228: 897F01E1  lbz r11, 0x1e1(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(481 as u32) ) } as u64;
	// 821DB22C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DB230: 4082017C  bne 0x821db3ac
	if !ctx.cr[0].eq {
	pc = 0x821DB3AC; continue 'dispatch;
	}
	// 821DB234: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB238: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB23C: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821DB240: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DB244: 4E800421  bctrl
	ctx.lr = 0x821DB248;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB248: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB24C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821DB250: 389F0034  addi r4, r31, 0x34
	ctx.r[4].s64 = ctx.r[31].s64 + 52;
	// 821DB254: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821DB258: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB25C: C3EB0014  lfs f31, 0x14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821DB260: C3CB0018  lfs f30, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821DB264: 814A003C  lwz r10, 0x3c(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 821DB268: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DB26C: 4E800421  bctrl
	ctx.lr = 0x821DB270;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB270: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB274: C03F01E8  lfs f1, 0x1e8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(488 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821DB278: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB27C: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821DB280: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DB284: 4E800421  bctrl
	ctx.lr = 0x821DB288;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB288: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821DB28C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821DB290: 816B0718  lwz r11, 0x718(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1816 as u32) ) } as u64;
	// 821DB294: C02A0C14  lfs f1, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821DB298: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DB29C: 4182000C  beq 0x821db2a8
	if ctx.cr[0].eq {
	pc = 0x821DB2A8; continue 'dispatch;
	}
	// 821DB2A0: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DB2A4: 48000008  b 0x821db2ac
	pc = 0x821DB2AC; continue 'dispatch;
            }
            0x821DB2A8 => {
    //   block [0x821DB2A8..0x821DB2AC)
	// 821DB2A8: FDA00890  fmr f13, f1
	ctx.f[13].f64 = ctx.f[1].f64;
	pc = 0x821DB2AC; continue 'dispatch;
            }
            0x821DB2AC => {
    //   block [0x821DB2AC..0x821DB2B8)
	// 821DB2AC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DB2B0: 41820008  beq 0x821db2b8
	if ctx.cr[0].eq {
	pc = 0x821DB2B8; continue 'dispatch;
	}
	// 821DB2B4: C02B000C  lfs f1, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x821DB2B8; continue 'dispatch;
            }
            0x821DB2B8 => {
    //   block [0x821DB2B8..0x821DB358)
	// 821DB2B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821DB2BC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB2C0: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DB2C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB2C8: EC4D0032  fmuls f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821DB2CC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821DB2D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DB2D4: 4E800421  bctrl
	ctx.lr = 0x821DB2D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB2D8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB2DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DB2E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DB2E4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB2E8: 4BFD3441  bl 0x821ae728
	ctx.lr = 0x821DB2EC;
	sub_821AE728(ctx, base);
	// 821DB2EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821DB2F0: 817E0024  lwz r11, 0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 821DB2F4: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB2F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DB2FC: 4E800421  bctrl
	ctx.lr = 0x821DB300;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB300: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821DB304: 396B9128  addi r11, r11, -0x6ed8
	ctx.r[11].s64 = ctx.r[11].s64 + -28376;
	// 821DB308: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821DB30C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DB310: 41820048  beq 0x821db358
	if ctx.cr[0].eq {
	pc = 0x821DB358; continue 'dispatch;
	}
	// 821DB314: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB318: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DB31C: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DB320: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB324: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DB328: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DB32C: 4E800421  bctrl
	ctx.lr = 0x821DB330;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB330: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB334: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB338: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821DB33C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DB340: 4E800421  bctrl
	ctx.lr = 0x821DB344;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB344: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DB348: 41820010  beq 0x821db358
	if ctx.cr[0].eq {
	pc = 0x821DB358; continue 'dispatch;
	}
	// 821DB34C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DB350: 9B9F01E1  stb r28, 0x1e1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(481 as u32), ctx.r[28].u8 ) };
	// 821DB354: 997F01B0  stb r11, 0x1b0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), ctx.r[11].u8 ) };
            }
            0x821DB358 => {
    //   block [0x821DB358..0x821DB3AC)
	// 821DB358: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB35C: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821DB360: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821DB364: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB368: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821DB36C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DB370: 4E800421  bctrl
	ctx.lr = 0x821DB374;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB374: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB378: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821DB37C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB380: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821DB384: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DB388: 4E800421  bctrl
	ctx.lr = 0x821DB38C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB38C: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB390: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DB394: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DB398: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DB39C: 4E800421  bctrl
	ctx.lr = 0x821DB3A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DB3A0: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 821DB3A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821DB3A8: 419A0008  beq cr6, 0x821db3b0
	if ctx.cr[6].eq {
	pc = 0x821DB3B0; continue 'dispatch;
	}
            }
            0x821DB3AC => {
    //   block [0x821DB3AC..0x821DB3B0)
	// 821DB3AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x821DB3B0; continue 'dispatch;
            }
            0x821DB3B0 => {
    //   block [0x821DB3B0..0x821DB3C0)
	// 821DB3B0: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 821DB3B4: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821DB3B8: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821DB3BC: 48ACE09C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB3C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DB3C0 size=372
    let mut pc: u32 = 0x821DB3C0;
    'dispatch: loop {
        match pc {
            0x821DB3C0 => {
    //   block [0x821DB3C0..0x821DB534)
	// 821DB3C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DB3C4: 48ACE045  bl 0x82ca9408
	ctx.lr = 0x821DB3C8;
	sub_82CA93D0(ctx, base);
	// 821DB3C8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821DB3CC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DB3D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DB3D4: 3B800020  li r28, 0x20
	ctx.r[28].s64 = 32;
	// 821DB3D8: 3BA00030  li r29, 0x30
	ctx.r[29].s64 = 48;
	// 821DB3DC: 3BC00010  li r30, 0x10
	ctx.r[30].s64 = 16;
	// 821DB3E0: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DB538 size=104
    let mut pc: u32 = 0x821DB538;
    'dispatch: loop {
        match pc {
            0x821DB538 => {
    //   block [0x821DB538..0x821DB5A0)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DB5A0 size=56
    let mut pc: u32 = 0x821DB5A0;
    'dispatch: loop {
        match pc {
            0x821DB5A0 => {
    //   block [0x821DB5A0..0x821DB5BC)
	// 821DB5A0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821DB5A4: 419A0018  beq cr6, 0x821db5bc
	if ctx.cr[6].eq {
	pc = 0x821DB5BC; continue 'dispatch;
	}
	// 821DB5A8: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821DB5AC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821DB5B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DB5B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DB5B8: 409A0008  bne cr6, 0x821db5c0
	if !ctx.cr[6].eq {
	pc = 0x821DB5C0; continue 'dispatch;
	}
	pc = 0x821DB5BC; continue 'dispatch;
            }
            0x821DB5BC => {
    //   block [0x821DB5BC..0x821DB5C0)
	// 821DB5BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821DB5C0; continue 'dispatch;
            }
            0x821DB5C0 => {
    //   block [0x821DB5C0..0x821DB5D8)
	// 821DB5C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DB5C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DB5C8: 419A0010  beq cr6, 0x821db5d8
	if ctx.cr[6].eq {
		sub_821DB5D8(ctx, base);
		return;
	}
	// 821DB5CC: 81640028  lwz r11, 0x28(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 821DB5D0: 5563FFFE  rlwinm r3, r11, 0x1f, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821DB5D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DB5D8 size=8
    let mut pc: u32 = 0x821DB5D8;
    'dispatch: loop {
        match pc {
            0x821DB5D8 => {
    //   block [0x821DB5D8..0x821DB5E0)
	// 821DB5D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821DB5DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB5E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DB5E0 size=828
    let mut pc: u32 = 0x821DB5E0;
    'dispatch: loop {
        match pc {
            0x821DB5E0 => {
    //   block [0x821DB5E0..0x821DB6CC)
	// 821DB5E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DB5E4: 48ACDE25  bl 0x82ca9408
	ctx.lr = 0x821DB5E8;
	sub_82CA93D0(ctx, base);
	// 821DB5E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DB5EC: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821DB5F0: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821DB5F4: 3BCB2390  addi r30, r11, 0x2390
	ctx.r[30].s64 = ctx.r[11].s64 + 9104;
	// 821DB5F8: 390A7E70  addi r8, r10, 0x7e70
	ctx.r[8].s64 = ctx.r[10].s64 + 32368;
	// 821DB5FC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821DB600: 38FE2008  addi r7, r30, 0x2008
	ctx.r[7].s64 = ctx.r[30].s64 + 8200;
	// 821DB604: 98C10050  stb r6, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u8 ) };
	// 821DB608: 817E2004  lwz r11, 0x2004(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB60C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821DB610: 7D0BF12E  stwx r8, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[8].u32) };
	// 821DB614: 815E2004  lwz r10, 0x2004(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB618: 813E2000  lwz r9, 0x2000(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821DB61C: 817E400C  lwz r11, 0x400c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821DB620: 55661838  slwi r6, r11, 3
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821DB624: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 821DB628: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821DB62C: 917E2004  stw r11, 0x2004(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8196 as u32), ctx.r[11].u32 ) };
	// 821DB630: 915E2000  stw r10, 0x2000(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8192 as u32), ctx.r[10].u32 ) };
	// 821DB634: 7D06392E  stwx r8, r6, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32), ctx.r[8].u32) };
	// 821DB638: 817E400C  lwz r11, 0x400c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821DB63C: 815E4008  lwz r10, 0x4008(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16392 as u32) ) } as u64;
	// 821DB640: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821DB644: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821DB648: 915E4008  stw r10, 0x4008(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16392 as u32), ctx.r[10].u32 ) };
	// 821DB64C: 917E400C  stw r11, 0x400c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16396 as u32), ctx.r[11].u32 ) };
	// 821DB650: 816406FC  lwz r11, 0x6fc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821DB654: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821DB658: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821DB65C: 419A00C4  beq cr6, 0x821db720
	if ctx.cr[6].eq {
	pc = 0x821DB720; continue 'dispatch;
	}
	// 821DB660: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821DB664: 894B0045  lbz r10, 0x45(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(69 as u32) ) } as u64;
	// 821DB668: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821DB66C: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821DB670: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 821DB674: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DB678: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821DB67C: 419A0090  beq cr6, 0x821db70c
	if ctx.cr[6].eq {
	pc = 0x821DB70C; continue 'dispatch;
	}
	// 821DB680: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821DB684: 810B0038  lwz r8, 0x38(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821DB688: 7D274038  and r7, r9, r8
	ctx.r[7].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821DB68C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DB690: 409A003C  bne cr6, 0x821db6cc
	if !ctx.cr[6].eq {
	pc = 0x821DB6CC; continue 'dispatch;
	}
	// 821DB694: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB698: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821DB69C: 38CB0030  addi r6, r11, 0x30
	ctx.r[6].s64 = ctx.r[11].s64 + 48;
	// 821DB6A0: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DB6A4: 912B0038  stw r9, 0x38(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(56 as u32), ctx.r[9].u32 ) };
	// 821DB6A8: 7CC8512E  stwx r6, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 821DB6AC: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821DB6B0: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB6B4: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DB6B8: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821DB6BC: 91260004  stw r9, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821DB6C0: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB6C4: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821DB6C8: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x821DB6CC; continue 'dispatch;
            }
            0x821DB6CC => {
    //   block [0x821DB6CC..0x821DB70C)
	// 821DB6CC: 894B0044  lbz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821DB6D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821DB6D4: 912B0034  stw r9, 0x34(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(52 as u32), ctx.r[9].u32 ) };
	// 821DB6D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DB6DC: 409A0030  bne cr6, 0x821db70c
	if !ctx.cr[6].eq {
	pc = 0x821DB70C; continue 'dispatch;
	}
	// 821DB6E0: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821DB6E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DB6E8: 390B0030  addi r8, r11, 0x30
	ctx.r[8].s64 = ctx.r[11].s64 + 48;
	// 821DB6EC: 994B0044  stb r10, 0x44(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 821DB6F0: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821DB6F4: 81690DB0  lwz r11, 0xdb0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821DB6F8: 38C70DB8  addi r6, r7, 0xdb8
	ctx.r[6].s64 = ctx.r[7].s64 + 3512;
	// 821DB6FC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821DB700: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821DB704: 91690DB0  stw r11, 0xdb0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3504 as u32), ctx.r[11].u32 ) };
	// 821DB708: 7D0A312E  stwx r8, r10, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32), ctx.r[8].u32) };
	pc = 0x821DB70C; continue 'dispatch;
            }
            0x821DB70C => {
    //   block [0x821DB70C..0x821DB720)
	// 821DB70C: 4805EB05  bl 0x8223a210
	ctx.lr = 0x821DB710;
	sub_8223A210(ctx, base);
	// 821DB710: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DB714: 48043BCD  bl 0x8221f2e0
	ctx.lr = 0x821DB718;
	sub_8221F2E0(ctx, base);
	// 821DB718: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DB71C: 48ACDD3C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x821DB720 => {
    //   block [0x821DB720..0x821DB798)
	// 821DB720: 3BEB63A0  addi r31, r11, 0x63a0
	ctx.r[31].s64 = ctx.r[11].s64 + 25504;
	// 821DB724: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DB728: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 821DB72C: 3B8B0DB8  addi r28, r11, 0xdb8
	ctx.r[28].s64 = ctx.r[11].s64 + 3512;
	// 821DB730: 897F0045  lbz r11, 0x45(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(69 as u32) ) } as u64;
	// 821DB734: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821DB738: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821DB73C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821DB740: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 821DB744: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821DB748: 419A0084  beq cr6, 0x821db7cc
	if ctx.cr[6].eq {
	pc = 0x821DB7CC; continue 'dispatch;
	}
	// 821DB74C: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821DB750: 813F0038  lwz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821DB754: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821DB758: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821DB75C: 409A003C  bne cr6, 0x821db798
	if !ctx.cr[6].eq {
	pc = 0x821DB798; continue 'dispatch;
	}
	// 821DB760: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB764: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821DB768: 38FF0030  addi r7, r31, 0x30
	ctx.r[7].s64 = ctx.r[31].s64 + 48;
	// 821DB76C: 55061838  slwi r6, r8, 3
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821DB770: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 821DB774: 7CE6592E  stwx r7, r6, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 821DB778: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821DB77C: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB780: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821DB784: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821DB788: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821DB78C: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB790: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 821DB794: 910B2004  stw r8, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	pc = 0x821DB798; continue 'dispatch;
            }
            0x821DB798 => {
    //   block [0x821DB798..0x821DB7CC)
	// 821DB798: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 821DB79C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DB7A0: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 821DB7A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DB7A8: 409A0024  bne cr6, 0x821db7cc
	if !ctx.cr[6].eq {
	pc = 0x821DB7CC; continue 'dispatch;
	}
	// 821DB7AC: 817D0DB0  lwz r11, 0xdb0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821DB7B0: 393F0030  addi r9, r31, 0x30
	ctx.r[9].s64 = ctx.r[31].s64 + 48;
	// 821DB7B4: 995F0044  stb r10, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 821DB7B8: 5567103A  slwi r7, r11, 2
	ctx.r[7].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821DB7BC: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 821DB7C0: 911D0DB0  stw r8, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[8].u32 ) };
	// 821DB7C4: 7D27E12E  stwx r9, r7, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	// 821DB7C8: 48000008  b 0x821db7d0
	pc = 0x821DB7D0; continue 'dispatch;
            }
            0x821DB7CC => {
    //   block [0x821DB7CC..0x821DB7D0)
	// 821DB7CC: 811D0DB0  lwz r8, 0xdb0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x821DB7D0; continue 'dispatch;
            }
            0x821DB7D0 => {
    //   block [0x821DB7D0..0x821DB838)
	// 821DB7D0: 897F002D  lbz r11, 0x2d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 821DB7D4: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DB7D8: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821DB7DC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821DB7E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DB7E4: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821DB7E8: 419A0080  beq cr6, 0x821db868
	if ctx.cr[6].eq {
	pc = 0x821DB868; continue 'dispatch;
	}
	// 821DB7EC: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821DB7F0: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DB7F4: 7D474838  and r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821DB7F8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DB7FC: 409A003C  bne cr6, 0x821db838
	if !ctx.cr[6].eq {
	pc = 0x821DB838; continue 'dispatch;
	}
	// 821DB800: 80EB2004  lwz r7, 0x2004(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB804: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821DB808: 38DF0018  addi r6, r31, 0x18
	ctx.r[6].s64 = ctx.r[31].s64 + 24;
	// 821DB80C: 54E51838  slwi r5, r7, 3
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821DB810: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821DB814: 7CC5592E  stwx r6, r5, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32), ctx.r[6].u32) };
	// 821DB818: 812B2004  lwz r9, 0x2004(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB81C: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DB820: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821DB824: 7CE95A14  add r7, r9, r11
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821DB828: 91470004  stw r10, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821DB82C: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB830: 38CA0001  addi r6, r10, 1
	ctx.r[6].s64 = ctx.r[10].s64 + 1;
	// 821DB834: 90CB2004  stw r6, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
	pc = 0x821DB838; continue 'dispatch;
            }
            0x821DB838 => {
    //   block [0x821DB838..0x821DB868)
	// 821DB838: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821DB83C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821DB840: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 821DB844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DB848: 409A0020  bne cr6, 0x821db868
	if !ctx.cr[6].eq {
	pc = 0x821DB868; continue 'dispatch;
	}
	// 821DB84C: 5509103A  slwi r9, r8, 2
	ctx.r[9].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821DB850: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DB854: 38FF0018  addi r7, r31, 0x18
	ctx.r[7].s64 = ctx.r[31].s64 + 24;
	// 821DB858: 39480001  addi r10, r8, 1
	ctx.r[10].s64 = ctx.r[8].s64 + 1;
	// 821DB85C: 997F002C  stb r11, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u8 ) };
	// 821DB860: 915D0DB0  stw r10, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821DB864: 7CE9E12E  stwx r7, r9, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[28].u32), ctx.r[7].u32) };
	pc = 0x821DB868; continue 'dispatch;
            }
            0x821DB868 => {
    //   block [0x821DB868..0x821DB8D8)
	// 821DB868: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821DB86C: 4805E9A5  bl 0x8223a210
	ctx.lr = 0x821DB870;
	sub_8223A210(ctx, base);
	// 821DB870: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DB874: 895F002D  lbz r10, 0x2d(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(45 as u32) ) } as u64;
	// 821DB878: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 821DB87C: 1D6A2008  mulli r11, r10, 0x2008
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821DB880: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821DB884: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821DB888: 419A0084  beq cr6, 0x821db90c
	if ctx.cr[6].eq {
	pc = 0x821DB90C; continue 'dispatch;
	}
	// 821DB88C: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821DB890: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DB894: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821DB898: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821DB89C: 409A003C  bne cr6, 0x821db8d8
	if !ctx.cr[6].eq {
	pc = 0x821DB8D8; continue 'dispatch;
	}
	// 821DB8A0: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB8A4: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821DB8A8: 38FF0018  addi r7, r31, 0x18
	ctx.r[7].s64 = ctx.r[31].s64 + 24;
	// 821DB8AC: 55061838  slwi r6, r8, 3
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821DB8B0: 915F0020  stw r10, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	// 821DB8B4: 7CE6592E  stwx r7, r6, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 821DB8B8: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB8BC: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821DB8C0: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DB8C4: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821DB8C8: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821DB8CC: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821DB8D0: 386A0001  addi r3, r10, 1
	ctx.r[3].s64 = ctx.r[10].s64 + 1;
	// 821DB8D4: 906B2004  stw r3, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
	pc = 0x821DB8D8; continue 'dispatch;
            }
            0x821DB8D8 => {
    //   block [0x821DB8D8..0x821DB90C)
	// 821DB8D8: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821DB8DC: 3940000F  li r10, 0xf
	ctx.r[10].s64 = 15;
	// 821DB8E0: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 821DB8E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DB8E8: 409A0024  bne cr6, 0x821db90c
	if !ctx.cr[6].eq {
	pc = 0x821DB90C; continue 'dispatch;
	}
	// 821DB8EC: 817D0DB0  lwz r11, 0xdb0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821DB8F0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DB8F4: 393F0018  addi r9, r31, 0x18
	ctx.r[9].s64 = ctx.r[31].s64 + 24;
	// 821DB8F8: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DB8FC: 995F002C  stb r10, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[10].u8 ) };
	// 821DB900: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821DB904: 917D0DB0  stw r11, 0xdb0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(3504 as u32), ctx.r[11].u32 ) };
	// 821DB908: 7D28E12E  stwx r9, r8, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	pc = 0x821DB90C; continue 'dispatch;
            }
            0x821DB90C => {
    //   block [0x821DB90C..0x821DB91C)
	// 821DB90C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DB910: 480439D1  bl 0x8221f2e0
	ctx.lr = 0x821DB914;
	sub_8221F2E0(ctx, base);
	// 821DB914: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DB918: 48ACDB40  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DB920 size=124
    let mut pc: u32 = 0x821DB920;
    'dispatch: loop {
        match pc {
            0x821DB920 => {
    //   block [0x821DB920..0x821DB99C)
	// 821DB920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DB924: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DB928: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821DB92C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DB930: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DB934: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DB938: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821DB93C: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 821DB940: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DB9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DB9A0 size=516
    let mut pc: u32 = 0x821DB9A0;
    'dispatch: loop {
        match pc {
            0x821DB9A0 => {
    //   block [0x821DB9A0..0x821DB9CC)
	// 821DB9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DB9A4: 48ACDA51  bl 0x82ca93f4
	ctx.lr = 0x821DB9A8;
	sub_82CA93D0(ctx, base);
	// 821DB9A8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DB9AC: 3EE0820A  lis r23, -0x7df6
	ctx.r[23].s64 = -2113273856;
	// 821DB9B0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821DB9B4: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 821DB9B8: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 821DB9BC: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 821DB9C0: C0179484  lfs f0, -0x6b7c(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DB9C4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DB9C8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x821DB9CC; continue 'dispatch;
            }
            0x821DB9CC => {
    //   block [0x821DB9CC..0x821DBA88)
	// 821DB9CC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821DB9D0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821DB9D4: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821DB9D8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821DB9DC: 4080FFF0  bge 0x821db9cc
	if !ctx.cr[0].lt {
	pc = 0x821DB9CC; continue 'dispatch;
	}
	// 821DB9E0: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DB9E4: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821DB9E8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821DB9EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821DB9F0: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 821DB9F4: 4BFF520D  bl 0x821d0c00
	ctx.lr = 0x821DB9F8;
	sub_821D0C00(ctx, base);
	// 821DB9F8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821DB9FC: 3BFD0110  addi r31, r29, 0x110
	ctx.r[31].s64 = ctx.r[29].s64 + 272;
	// 821DBA00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821DBA04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DBA08: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821DBA0C: 480A4835  bl 0x82280240
	ctx.lr = 0x821DBA10;
	sub_82280240(ctx, base);
	// 821DBA10: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821DBA14: 3BDD0114  addi r30, r29, 0x114
	ctx.r[30].s64 = ctx.r[29].s64 + 276;
	// 821DBA18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821DBA1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821DBA20: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821DBA24: 480A481D  bl 0x82280240
	ctx.lr = 0x821DBA28;
	sub_82280240(ctx, base);
	// 821DBA28: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821DBA2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DBA30: 4BFE7469  bl 0x821c2e98
	ctx.lr = 0x821DBA34;
	sub_821C2E98(ctx, base);
	// 821DBA34: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821DBA38: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821DBA3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821DBA40: 4BFE7459  bl 0x821c2e98
	ctx.lr = 0x821DBA44;
	sub_821C2E98(ctx, base);
	// 821DBA44: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821DBA48: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821DBA4C: 3BEBDED4  addi r31, r11, -0x212c
	ctx.r[31].s64 = ctx.r[11].s64 + -8492;
	// 821DBA50: 793EFFE6  rldicr r30, r9, 0x3f, 0x3f
	ctx.r[30].u64 = (ctx.r[9].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821DBA54: 3F608336  lis r27, -0x7cca
	ctx.r[27].s64 = -2093613056;
	// 821DBA58: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821DBA5C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBA60: 808B0A74  lwz r4, 0xa74(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2676 as u32) ) } as u64;
	// 821DBA64: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821DBA68: 41980020  blt cr6, 0x821dba88
	if ctx.cr[6].lt {
	pc = 0x821DBA88; continue 'dispatch;
	}
	// 821DBA6C: 39640020  addi r11, r4, 0x20
	ctx.r[11].s64 = ctx.r[4].s64 + 32;
	// 821DBA70: 807B0364  lwz r3, 0x364(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(868 as u32) ) } as u64;
	// 821DBA74: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBA78: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821DBA7C: 7FC65436  srd r6, r30, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[30].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821DBA80: 4BFDB461  bl 0x821b6ee0
	ctx.lr = 0x821DBA84;
	sub_821B6EE0(ctx, base);
	// 821DBA84: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x821DBA88; continue 'dispatch;
            }
            0x821DBA88 => {
    //   block [0x821DBA88..0x821DBAAC)
	// 821DBA88: 808B0A80  lwz r4, 0xa80(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2688 as u32) ) } as u64;
	// 821DBA8C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821DBA90: 4198001C  blt cr6, 0x821dbaac
	if ctx.cr[6].lt {
	pc = 0x821DBAAC; continue 'dispatch;
	}
	// 821DBA94: 39640020  addi r11, r4, 0x20
	ctx.r[11].s64 = ctx.r[4].s64 + 32;
	// 821DBA98: 807B0364  lwz r3, 0x364(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(868 as u32) ) } as u64;
	// 821DBA9C: 80BA0004  lwz r5, 4(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBAA0: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821DBAA4: 7FC65436  srd r6, r30, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[30].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821DBAA8: 4BFDB439  bl 0x821b6ee0
	ctx.lr = 0x821DBAAC;
	sub_821B6EE0(ctx, base);
	pc = 0x821DBAAC; continue 'dispatch;
            }
            0x821DBAAC => {
    //   block [0x821DBAAC..0x821DBAF8)
	// 821DBAAC: 386000E1  li r3, 0xe1
	ctx.r[3].s64 = 225;
	// 821DBAB0: C0210068  lfs f1, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821DBAB4: 4800D1C5  bl 0x821e8c78
	ctx.lr = 0x821DBAB8;
	sub_821E8C78(ctx, base);
	// 821DBAB8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821DBABC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821DBAC0: 480394F1  bl 0x82214fb0
	ctx.lr = 0x821DBAC4;
	sub_82214FB0(ctx, base);
	// 821DBAC4: 8979070A  lbz r11, 0x70a(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(1802 as u32) ) } as u64;
	// 821DBAC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DBACC: 409A0030  bne cr6, 0x821dbafc
	if !ctx.cr[6].eq {
	pc = 0x821DBAFC; continue 'dispatch;
	}
	// 821DBAD0: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 821DBAD4: 419A0024  beq cr6, 0x821dbaf8
	if ctx.cr[6].eq {
	pc = 0x821DBAF8; continue 'dispatch;
	}
	// 821DBAD8: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821DBADC: 894BCBD2  lbz r10, -0x342e(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-13358 as u32) ) } as u64;
	// 821DBAE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DBAE4: 419A0014  beq cr6, 0x821dbaf8
	if ctx.cr[6].eq {
	pc = 0x821DBAF8; continue 'dispatch;
	}
	// 821DBAE8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821DBAEC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821DBAF0: 48892FB9  bl 0x82a6eaa8
	ctx.lr = 0x821DBAF4;
	sub_82A6EAA8(ctx, base);
	// 821DBAF4: 48000008  b 0x821dbafc
	pc = 0x821DBAFC; continue 'dispatch;
            }
            0x821DBAF8 => {
    //   block [0x821DBAF8..0x821DBAFC)
	// 821DBAF8: 480925A1  bl 0x8226e098
	ctx.lr = 0x821DBAFC;
	sub_8226E098(ctx, base);
	pc = 0x821DBAFC; continue 'dispatch;
            }
            0x821DBAFC => {
    //   block [0x821DBAFC..0x821DBBA4)
	// 821DBAFC: 3860010A  li r3, 0x10a
	ctx.r[3].s64 = 266;
	// 821DBB00: C03D004C  lfs f1, 0x4c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(76 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821DBB04: 4800D175  bl 0x821e8c78
	ctx.lr = 0x821DBB08;
	sub_821E8C78(ctx, base);
	// 821DBB08: 38600109  li r3, 0x109
	ctx.r[3].s64 = 265;
	// 821DBB0C: C03D0050  lfs f1, 0x50(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821DBB10: 4800D169  bl 0x821e8c78
	ctx.lr = 0x821DBB14;
	sub_821E8C78(ctx, base);
	// 821DBB14: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DBB18: C0179484  lfs f0, -0x6b7c(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DBB1C: 39400690  li r10, 0x690
	ctx.r[10].s64 = 1680;
	// 821DBB20: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821DBB24: 392B91A0  addi r9, r11, -0x6e60
	ctx.r[9].s64 = ctx.r[11].s64 + -28256;
	// 821DBB28: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821DBB2C: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821DBB30: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821DBB34: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 821DBB38: 798CDFE6  rldicr r12, r12, 0x3b, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(59) & 0xFFFFFFFFFFFFFFFF;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DBBA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DBBA8 size=308
    let mut pc: u32 = 0x821DBBA8;
    'dispatch: loop {
        match pc {
            0x821DBBA8 => {
    //   block [0x821DBBA8..0x821DBBE4)
	// 821DBBA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DBBAC: 48ACD859  bl 0x82ca9404
	ctx.lr = 0x821DBBB0;
	sub_82CA93D0(ctx, base);
	// 821DBBB0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DBBB4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821DBBB8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821DBBBC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821DBBC0: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 821DBBC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821DBBC8: 48024BA9  bl 0x82200770
	ctx.lr = 0x821DBBCC;
	sub_82200770(ctx, base);
	// 821DBBCC: 807B000C  lwz r3, 0xc(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DBBD0: 480E9E51  bl 0x822c5a20
	ctx.lr = 0x821DBBD4;
	sub_822C5A20(ctx, base);
	// 821DBBD4: 807B0010  lwz r3, 0x10(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DBBD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821DBBDC: 419A0008  beq cr6, 0x821dbbe4
	if ctx.cr[6].eq {
	pc = 0x821DBBE4; continue 'dispatch;
	}
	// 821DBBE0: 480C6FA9  bl 0x822a2b88
	ctx.lr = 0x821DBBE4;
	sub_822A2B88(ctx, base);
	pc = 0x821DBBE4; continue 'dispatch;
            }
            0x821DBBE4 => {
    //   block [0x821DBBE4..0x821DBBEC)
	// 821DBBE4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBBE8: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821DBBEC; continue 'dispatch;
            }
            0x821DBBEC => {
    //   block [0x821DBBEC..0x821DBC0C)
	// 821DBBEC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DBBF0: 419A00D0  beq cr6, 0x821dbcc0
	if ctx.cr[6].eq {
	pc = 0x821DBCC0; continue 'dispatch;
	}
	// 821DBBF4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DBBF8: 3BEB0030  addi r31, r11, 0x30
	ctx.r[31].s64 = ctx.r[11].s64 + 48;
	// 821DBBFC: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 821DBC00: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821DBC04: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821DBC08: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821DBC0C; continue 'dispatch;
            }
            0x821DBC0C => {
    //   block [0x821DBC0C..0x821DBC10)
	// 821DBC0C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x821DBC10; continue 'dispatch;
            }
            0x821DBC10 => {
    //   block [0x821DBC10..0x821DBC24)
	// 821DBC10: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBC14: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821DBC18: 419A000C  beq cr6, 0x821dbc24
	if ctx.cr[6].eq {
	pc = 0x821DBC24; continue 'dispatch;
	}
	// 821DBC1C: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821DBC20: 419A0008  beq cr6, 0x821dbc28
	if ctx.cr[6].eq {
	pc = 0x821DBC28; continue 'dispatch;
	}
	pc = 0x821DBC24; continue 'dispatch;
            }
            0x821DBC24 => {
    //   block [0x821DBC24..0x821DBC28)
	// 821DBC24: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DBC28; continue 'dispatch;
            }
            0x821DBC28 => {
    //   block [0x821DBC28..0x821DBC3C)
	// 821DBC28: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DBC2C: 419A007C  beq cr6, 0x821dbca8
	if ctx.cr[6].eq {
	pc = 0x821DBCA8; continue 'dispatch;
	}
	// 821DBC30: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821DBC34: 409A0008  bne cr6, 0x821dbc3c
	if !ctx.cr[6].eq {
	pc = 0x821DBC3C; continue 'dispatch;
	}
	// 821DBC38: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DBC3C; continue 'dispatch;
            }
            0x821DBC3C => {
    //   block [0x821DBC3C..0x821DBC4C)
	// 821DBC3C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBC40: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DBC44: 409A0008  bne cr6, 0x821dbc4c
	if !ctx.cr[6].eq {
	pc = 0x821DBC4C; continue 'dispatch;
	}
	// 821DBC48: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DBC4C; continue 'dispatch;
            }
            0x821DBC4C => {
    //   block [0x821DBC4C..0x821DBC7C)
	// 821DBC4C: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DBC50: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DBC54: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DBC58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DBC5C: 4E800421  bctrl
	ctx.lr = 0x821DBC60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DBC60: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DBC64: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DBC68: 419A001C  beq cr6, 0x821dbc84
	if ctx.cr[6].eq {
	pc = 0x821DBC84; continue 'dispatch;
	}
	// 821DBC6C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBC70: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DBC74: 409A0008  bne cr6, 0x821dbc7c
	if !ctx.cr[6].eq {
	pc = 0x821DBC7C; continue 'dispatch;
	}
	// 821DBC78: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x821DBC7C => {
    //   block [0x821DBC7C..0x821DBC84)
	// 821DBC7C: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DBC80: 4BFFFF8C  b 0x821dbc0c
	pc = 0x821DBC0C; continue 'dispatch;
            }
            0x821DBC84 => {
    //   block [0x821DBC84..0x821DBCA8)
	// 821DBC84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DBC88: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DBC8C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DBC90: 48084A61  bl 0x822606f0
	ctx.lr = 0x821DBC94;
	sub_822606F0(ctx, base);
	// 821DBC94: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821DBC98: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821DBC9C: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821DBCA0: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821DBCA4: 4BFFFF6C  b 0x821dbc10
	pc = 0x821DBC10; continue 'dispatch;
            }
            0x821DBCA8 => {
    //   block [0x821DBCA8..0x821DBCB8)
	// 821DBCA8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBCAC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DBCB0: 409A0008  bne cr6, 0x821dbcb8
	if !ctx.cr[6].eq {
	pc = 0x821DBCB8; continue 'dispatch;
	}
	// 821DBCB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DBCB8; continue 'dispatch;
            }
            0x821DBCB8 => {
    //   block [0x821DBCB8..0x821DBCC0)
	// 821DBCB8: 839C0000  lwz r28, 0(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DBCBC: 4BFFFF30  b 0x821dbbec
	pc = 0x821DBBEC; continue 'dispatch;
            }
            0x821DBCC0 => {
    //   block [0x821DBCC0..0x821DBCD4)
	// 821DBCC0: 8941005C  lbz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821DBCC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DBCC8: 419A000C  beq cr6, 0x821dbcd4
	if ctx.cr[6].eq {
	pc = 0x821DBCD4; continue 'dispatch;
	}
	// 821DBCCC: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821DBCD0: 490DDC85  bl 0x832b9954
	ctx.lr = 0x821DBCD4;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x821DBCD4; continue 'dispatch;
            }
            0x821DBCD4 => {
    //   block [0x821DBCD4..0x821DBCDC)
	// 821DBCD4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821DBCD8: 48ACD77C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DBCE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DBCE0 size=28
    let mut pc: u32 = 0x821DBCE0;
    'dispatch: loop {
        match pc {
            0x821DBCE0 => {
    //   block [0x821DBCE0..0x821DBCFC)
	// 821DBCE0: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DBCE4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821DBCE8: 894B0011  lbz r10, 0x11(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 821DBCEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DBCF0: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 821DBCF4: 886B0010  lbz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DBCF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DBD00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DBD00 size=140
    let mut pc: u32 = 0x821DBD00;
    'dispatch: loop {
        match pc {
            0x821DBD00 => {
    //   block [0x821DBD00..0x821DBD24)
	// 821DBD00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DBD04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DBD08: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DBD0C: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBD10: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 821DBD14: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DBD18: 409A000C  bne cr6, 0x821dbd24
	if !ctx.cr[6].eq {
	pc = 0x821DBD24; continue 'dispatch;
	}
	// 821DBD1C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821DBD20: 48000010  b 0x821dbd30
	pc = 0x821DBD30; continue 'dispatch;
            }
            0x821DBD24 => {
    //   block [0x821DBD24..0x821DBD30)
	// 821DBD24: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DBD28: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821DBD2C: 7D291670  srawi r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x821DBD30; continue 'dispatch;
            }
            0x821DBD30 => {
    //   block [0x821DBD30..0x821DBD64)
	// 821DBD30: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DBD34: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821DBD38: 7D481670  srawi r8, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 821DBD3C: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821DBD40: 40980024  bge cr6, 0x821dbd64
	if !ctx.cr[6].lt {
	pc = 0x821DBD64; continue 'dispatch;
	}
	// 821DBD44: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DBD48: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 821DBD4C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821DBD50: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821DBD54: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821DBD58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DBD5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DBD60: 4E800020  blr
	return;
            }
            0x821DBD64 => {
    //   block [0x821DBD64..0x821DBD8C)
	// 821DBD64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821DBD68: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821DBD6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821DBD70: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821DBD74: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DBD78: 48286739  bl 0x824624b0
	ctx.lr = 0x821DBD7C;
	sub_824624B0(ctx, base);
	// 821DBD7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821DBD80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DBD84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DBD88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DBD90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DBD90 size=436
    let mut pc: u32 = 0x821DBD90;
    'dispatch: loop {
        match pc {
            0x821DBD90 => {
    //   block [0x821DBD90..0x821DBE08)
	// 821DBD90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DBD94: 48ACD665  bl 0x82ca93f8
	ctx.lr = 0x821DBD98;
	sub_82CA93D0(ctx, base);
	// 821DBD98: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 821DBD9C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DBDA0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821DBDA4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821DBDA8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 821DBDAC: 38A00009  li r5, 9
	ctx.r[5].s64 = 9;
	// 821DBDB0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821DBDB4: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 821DBDB8: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 821DBDBC: 480186C5  bl 0x821f4480
	ctx.lr = 0x821DBDC0;
	sub_821F4480(ctx, base);
	// 821DBDC0: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 821DBDC4: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821DBDC8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DBDCC: 419A0168  beq cr6, 0x821dbf34
	if ctx.cr[6].eq {
	pc = 0x821DBF34; continue 'dispatch;
	}
	// 821DBDD0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DBDD4: 3D207FFF  lis r9, 0x7fff
	ctx.r[9].s64 = 2147418112;
	// 821DBDD8: 3B0000D0  li r24, 0xd0
	ctx.r[24].s64 = 208;
	// 821DBDDC: 613BFFFF  ori r27, r9, 0xffff
	ctx.r[27].u64 = ctx.r[9].u64 | 65535;
	// 821DBDE0: C3EB9A80  lfs f31, -0x6580(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821DBDE4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DBDE8: 81210074  lwz r9, 0x74(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821DBDEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DBDF0: 419A0018  beq cr6, 0x821dbe08
	if ctx.cr[6].eq {
	pc = 0x821DBE08; continue 'dispatch;
	}
	// 821DBDF4: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DBDF8: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821DBDFC: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821DBE00: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DBE04: 41980008  blt cr6, 0x821dbe0c
	if ctx.cr[6].lt {
	pc = 0x821DBE0C; continue 'dispatch;
	}
	pc = 0x821DBE08; continue 'dispatch;
            }
            0x821DBE08 => {
    //   block [0x821DBE08..0x821DBE0C)
	// 821DBE08: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DBE0C; continue 'dispatch;
            }
            0x821DBE0C => {
    //   block [0x821DBE0C..0x821DBF1C)
	// 821DBE0C: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821DBE10: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821DBE14: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821DBE18: 7FEA582E  lwzx r31, r10, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821DBE1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DBE20: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DBE24: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821DBE28: 81090068  lwz r8, 0x68(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(104 as u32) ) } as u64;
	// 821DBE2C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821DBE30: 4E800421  bctrl
	ctx.lr = 0x821DBE34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DBE34: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DBE38: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DBE3C: 419A00E0  beq cr6, 0x821dbf1c
	if ctx.cr[6].eq {
	pc = 0x821DBF1C; continue 'dispatch;
	}
            }
            0x821DBF1C => {
    //   block [0x821DBF1C..0x821DBF34)
	// 821DBF1C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821DBF20: 48023E59  bl 0x821ffd78
	ctx.lr = 0x821DBF24;
	sub_821FFD78(ctx, base);
	// 821DBF24: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 821DBF28: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 821DBF2C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DBF30: 409AFEB4  bne cr6, 0x821dbde4
	if !ctx.cr[6].eq {
	pc = 0x821DBDE4; continue 'dispatch;
	}
	pc = 0x821DBF34; continue 'dispatch;
            }
            0x821DBF34 => {
    //   block [0x821DBF34..0x821DBF44)
	// 821DBF34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DBF38: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821DBF3C: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821DBF40: 48ACD508  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DBF48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DBF48 size=384
    let mut pc: u32 = 0x821DBF48;
    'dispatch: loop {
        match pc {
            0x821DBF48 => {
    //   block [0x821DBF48..0x821DBF70)
	// 821DBF48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DBF4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DBF50: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DBF54: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821DBF58: 419A0018  beq cr6, 0x821dbf70
	if ctx.cr[6].eq {
	pc = 0x821DBF70; continue 'dispatch;
	}
	// 821DBF5C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821DBF60: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821DBF64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DBF68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DBF6C: 409A0008  bne cr6, 0x821dbf74
	if !ctx.cr[6].eq {
	pc = 0x821DBF74; continue 'dispatch;
	}
	pc = 0x821DBF70; continue 'dispatch;
            }
            0x821DBF70 => {
    //   block [0x821DBF70..0x821DBF74)
	// 821DBF70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821DBF74; continue 'dispatch;
            }
            0x821DBF74 => {
    //   block [0x821DBF74..0x821DBFBC)
	// 821DBF74: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DBF78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DBF7C: 419A0134  beq cr6, 0x821dc0b0
	if ctx.cr[6].eq {
	pc = 0x821DC0B0; continue 'dispatch;
	}
	// 821DBF80: 81440028  lwz r10, 0x28(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 821DBF84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DBF88: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 821DBF8C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DBF90: 419A00EC  beq cr6, 0x821dc07c
	if ctx.cr[6].eq {
	pc = 0x821DC07C; continue 'dispatch;
	}
	// 821DBF94: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 821DBF98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DBF9C: 419A0020  beq cr6, 0x821dbfbc
	if ctx.cr[6].eq {
	pc = 0x821DBFBC; continue 'dispatch;
	}
	// 821DBFA0: 894B0022  lbz r10, 0x22(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(34 as u32) ) } as u64;
	// 821DBFA4: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DBFA8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821DBFAC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821DBFB0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DBFB4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DBFB8: 480000C8  b 0x821dc080
	pc = 0x821DC080; continue 'dispatch;
            }
            0x821DBFBC => {
    //   block [0x821DBFBC..0x821DBFDC)
	// 821DBFBC: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DBFC0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DBFC4: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 821DBFC8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821DBFCC: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821DBFD0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821DBFD4: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DBFD8: 40810054  ble 0x821dc02c
	if !ctx.cr[0].gt {
	pc = 0x821DC02C; continue 'dispatch;
	}
	pc = 0x821DBFDC; continue 'dispatch;
            }
            0x821DBFDC => {
    //   block [0x821DBFDC..0x821DBFFC)
	// 821DBFDC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821DBFE0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DBFE4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821DBFE8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DBFEC: 2F070022  cmpwi cr6, r7, 0x22
	ctx.cr[6].compare_i32(ctx.r[7].s32, 34, &mut ctx.xer);
	// 821DBFF0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821DBFF4: 41980008  blt cr6, 0x821dbffc
	if ctx.cr[6].lt {
	pc = 0x821DBFFC; continue 'dispatch;
	}
	// 821DBFF8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821DBFFC; continue 'dispatch;
            }
            0x821DBFFC => {
    //   block [0x821DBFFC..0x821DC018)
	// 821DBFFC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821DC000: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DC004: 419A0014  beq cr6, 0x821dc018
	if ctx.cr[6].eq {
	pc = 0x821DC018; continue 'dispatch;
	}
	// 821DC008: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821DC00C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821DC010: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821DC014: 4800000C  b 0x821dc020
	pc = 0x821DC020; continue 'dispatch;
            }
            0x821DC018 => {
    //   block [0x821DC018..0x821DC020)
	// 821DC018: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821DC01C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821DC020; continue 'dispatch;
            }
            0x821DC020 => {
    //   block [0x821DC020..0x821DC02C)
	// 821DC020: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DC024: 4199FFB8  bgt cr6, 0x821dbfdc
	if ctx.cr[6].gt {
	pc = 0x821DBFDC; continue 'dispatch;
	}
	// 821DC028: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821DC02C; continue 'dispatch;
            }
            0x821DC02C => {
    //   block [0x821DC02C..0x821DC048)
	// 821DC02C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821DC030: 419A003C  beq cr6, 0x821dc06c
	if ctx.cr[6].eq {
	pc = 0x821DC06C; continue 'dispatch;
	}
	// 821DC034: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DC038: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 821DC03C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DC040: 41990008  bgt cr6, 0x821dc048
	if ctx.cr[6].gt {
	pc = 0x821DC048; continue 'dispatch;
	}
	// 821DC044: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821DC048; continue 'dispatch;
            }
            0x821DC048 => {
    //   block [0x821DC048..0x821DC06C)
	// 821DC048: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DC04C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DC050: 409A001C  bne cr6, 0x821dc06c
	if !ctx.cr[6].eq {
	pc = 0x821DC06C; continue 'dispatch;
	}
	// 821DC054: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DC058: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DC05C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821DC060: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821DC064: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC068: 48000018  b 0x821dc080
	pc = 0x821DC080; continue 'dispatch;
            }
            0x821DC06C => {
    //   block [0x821DC06C..0x821DC07C)
	// 821DC06C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821DC070: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DC074: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC078: 48000008  b 0x821dc080
	pc = 0x821DC080; continue 'dispatch;
            }
            0x821DC07C => {
    //   block [0x821DC07C..0x821DC080)
	// 821DC07C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821DC080; continue 'dispatch;
            }
            0x821DC080 => {
    //   block [0x821DC080..0x821DC0B0)
	// 821DC080: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821DC084: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DC088: 419A0028  beq cr6, 0x821dc0b0
	if ctx.cr[6].eq {
	pc = 0x821DC0B0; continue 'dispatch;
	}
	// 821DC08C: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DC090: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DC094: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821DC098: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821DC09C: 4E800421  bctrl
	ctx.lr = 0x821DC0A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DC0A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821DC0A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DC0A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DC0AC: 4E800020  blr
	return;
            }
            0x821DC0B0 => {
    //   block [0x821DC0B0..0x821DC0C8)
	// 821DC0B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DC0B4: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821DC0B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821DC0BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DC0C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DC0C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DC0C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DC0C8 size=144
    let mut pc: u32 = 0x821DC0C8;
    'dispatch: loop {
        match pc {
            0x821DC0C8 => {
    //   block [0x821DC0C8..0x821DC158)
	// 821DC0C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DC0CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DC0D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DC0D4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821DC0D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DC0DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DC0E0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821DC0E4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821DC0E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DC158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DC158 size=124
    let mut pc: u32 = 0x821DC158;
    'dispatch: loop {
        match pc {
            0x821DC158 => {
    //   block [0x821DC158..0x821DC19C)
	// 821DC158: 81432E48  lwz r10, 0x2e48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(11848 as u32) ) } as u64;
	// 821DC15C: 81632E4C  lwz r11, 0x2e4c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(11852 as u32) ) } as u64;
	// 821DC160: 508A06FE  rlwimi r10, r4, 0, 0x1b, 0x1f
	ctx.r[10].u64 = (((ctx.r[4].u32).rotate_left(0) as u64) & 0x000000000000001F) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFFE0);
	// 821DC164: 55690001  rlwinm. r9, r11, 0, 0, 0
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821DC168: 91432E48  stw r10, 0x2e48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(11848 as u32), ctx.r[10].u32 ) };
	// 821DC16C: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 821DC170: 556A0043  rlwinm. r10, r11, 0, 1, 1
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821DC174: 81632E48  lwz r11, 0x2e48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(11848 as u32) ) } as u64;
	// 821DC178: 40820024  bne 0x821dc19c
	if !ctx.cr[0].eq {
	pc = 0x821DC19C; continue 'dispatch;
	}
	// 821DC17C: 716A1010  andi. r10, r11, 0x1010
	ctx.r[10].u64 = ctx.r[11].u64 & 4112;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821DC180: 55692336  rlwinm r9, r11, 4, 0xc, 0x1b
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 821DC184: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821DC188: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821DC18C: 554A601E  rlwinm r10, r10, 0xc, 0, 0xf
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 821DC190: 554A0314  rlwinm r10, r10, 0, 0xc, 0xa
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821DC194: 554A0104  rlwinm r10, r10, 0, 4, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821DC198: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	pc = 0x821DC19C; continue 'dispatch;
            }
            0x821DC19C => {
    //   block [0x821DC19C..0x821DC1D4)
	// 821DC19C: 91632938  stw r11, 0x2938(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10552 as u32), ctx.r[11].u32 ) };
	// 821DC1A0: 91632958  stw r11, 0x2958(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10584 as u32), ctx.r[11].u32 ) };
	// 821DC1A4: 9163295C  stw r11, 0x295c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10588 as u32), ctx.r[11].u32 ) };
	// 821DC1A8: 91632960  stw r11, 0x2960(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10592 as u32), ctx.r[11].u32 ) };
	// 821DC1AC: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821DC1B0: 616B0400  ori r11, r11, 0x400
	ctx.r[11].u64 = ctx.r[11].u64 | 1024;
	// 821DC1B4: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821DC1B8: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 821DC1BC: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821DC1C0: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 821DC1C4: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821DC1C8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821DC1CC: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821DC1D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DC1D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DC1D8 size=148
    let mut pc: u32 = 0x821DC1D8;
    'dispatch: loop {
        match pc {
            0x821DC1D8 => {
    //   block [0x821DC1D8..0x821DC208)
	// 821DC1D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DC1DC: 48ACD22D  bl 0x82ca9408
	ctx.lr = 0x821DC1E0;
	sub_82CA93D0(ctx, base);
	// 821DC1E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DC1E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821DC1E8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821DC1EC: 7F1CF040  cmplw cr6, r28, r30
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821DC1F0: 419A0070  beq cr6, 0x821dc260
	if ctx.cr[6].eq {
	pc = 0x821DC260; continue 'dispatch;
	}
	// 821DC1F4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC1F8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821DC1FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DC200: 40990060  ble cr6, 0x821dc260
	if !ctx.cr[6].gt {
	pc = 0x821DC260; continue 'dispatch;
	}
	// 821DC204: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x821DC208; continue 'dispatch;
            }
            0x821DC208 => {
    //   block [0x821DC208..0x821DC24C)
	// 821DC208: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC20C: 7C8BF82E  lwzx r4, r11, r31
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821DC210: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DC214: 41820038  beq 0x821dc24c
	if ctx.cr[0].eq {
	pc = 0x821DC24C; continue 'dispatch;
	}
	// 821DC218: 89640004  lbz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC21C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821DC220: 4182002C  beq 0x821dc24c
	if ctx.cr[0].eq {
	pc = 0x821DC24C; continue 'dispatch;
	}
	// 821DC224: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC228: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821DC22C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DC230: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC234: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DC238: 4E800421  bctrl
	ctx.lr = 0x821DC23C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DC23C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC240: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DC244: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821DC248: 994B0004  stb r10, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
            }
            0x821DC24C => {
    //   block [0x821DC24C..0x821DC260)
	// 821DC24C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC250: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 821DC254: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 821DC258: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821DC25C: 4198FFAC  blt cr6, 0x821dc208
	if ctx.cr[6].lt {
	pc = 0x821DC208; continue 'dispatch;
	}
	pc = 0x821DC260; continue 'dispatch;
            }
            0x821DC260 => {
    //   block [0x821DC260..0x821DC26C)
	// 821DC260: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821DC264: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DC268: 48ACD1F0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DC270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DC270 size=916
    let mut pc: u32 = 0x821DC270;
    'dispatch: loop {
        match pc {
            0x821DC270 => {
    //   block [0x821DC270..0x821DC2B4)
	// 821DC270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DC274: 48ACD181  bl 0x82ca93f4
	ctx.lr = 0x821DC278;
	sub_82CA93D0(ctx, base);
	// 821DC278: DBC1FFA0  stfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 821DC27C: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 821DC280: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DC284: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 821DC288: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821DC28C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DC290: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 821DC294: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 821DC298: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821DC29C: 807C6AB8  lwz r3, 0x6ab8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821DC2A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821DC2A4: 419A0010  beq cr6, 0x821dc2b4
	if ctx.cr[6].eq {
	pc = 0x821DC2B4; continue 'dispatch;
	}
	// 821DC2A8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DC2AC: 896B6A5E  lbz r11, 0x6a5e(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27230 as u32) ) } as u64;
	// 821DC2B0: 48000008  b 0x821dc2b8
	pc = 0x821DC2B8; continue 'dispatch;
            }
            0x821DC2B4 => {
    //   block [0x821DC2B4..0x821DC2B8)
	// 821DC2B4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821DC2B8; continue 'dispatch;
            }
            0x821DC2B8 => {
    //   block [0x821DC2B8..0x821DC308)
	// 821DC2B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DC2BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DC2C0: 419A0114  beq cr6, 0x821dc3d4
	if ctx.cr[6].eq {
	pc = 0x821DC3D4; continue 'dispatch;
	}
	// 821DC2C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DC2C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821DC2CC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DC2D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DC2D4: 4E800421  bctrl
	ctx.lr = 0x821DC2D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DC2D8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821DC2DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821DC2E0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821DC2E4: 83C90004  lwz r30, 4(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC2E8: 389E0038  addi r4, r30, 0x38
	ctx.r[4].s64 = ctx.r[30].s64 + 56;
	// 821DC2EC: 48024485  bl 0x82200770
	ctx.lr = 0x821DC2F0;
	sub_82200770(ctx, base);
	// 821DC2F0: 88E10074  lbz r7, 0x74(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821DC2F4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DC2F8: 83DE0080  lwz r30, 0x80(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 821DC2FC: 419A000C  beq cr6, 0x821dc308
	if ctx.cr[6].eq {
	pc = 0x821DC308; continue 'dispatch;
	}
	// 821DC300: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 821DC304: 490DD651  bl 0x832b9954
	ctx.lr = 0x821DC308;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
            }
            0x821DC308 => {
    //   block [0x821DC308..0x821DC3D4)
	// 821DC308: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DC30C: DBC10088  stfd f30, 0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.f[30].u64 ) };
	// 821DC310: 9B610085  stb r27, 0x85(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(133 as u32), ctx.r[27].u8 ) };
	// 821DC314: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 821DC318: 7D2AF050  subf r9, r10, r30
	ctx.r[9].s64 = ctx.r[30].s64 - ctx.r[10].s64;
	// 821DC31C: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821DC320: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821DC324: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821DC328: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821DC32C: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 821DC330: 98E10084  stb r7, 0x84(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[7].u8 ) };
	// 821DC334: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DC338: 80A60058  lwz r5, 0x58(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(88 as u32) ) } as u64;
	// 821DC33C: 80650004  lwz r3, 4(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC340: 48003A91  bl 0x821dfdd0
	ctx.lr = 0x821DC344;
	sub_821DFDD0(ctx, base);
	// 821DC344: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DC348: 8064009C  lwz r3, 0x9c(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(156 as u32) ) } as u64;
	// 821DC34C: 4801C47D  bl 0x821f87c8
	ctx.lr = 0x821DC350;
	sub_821F87C8(ctx, base);
	// 821DC350: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821DC354: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821DC358: 419A029C  beq cr6, 0x821dc5f4
	if ctx.cr[6].eq {
	pc = 0x821DC5F4; continue 'dispatch;
	}
	// 821DC35C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821DC360: 48001051  bl 0x821dd3b0
	ctx.lr = 0x821DC364;
	sub_821DD3B0(ctx, base);
	// 821DC364: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DC368: C1A100E0  lfs f13, 0xe0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DC36C: 3BCBFE2C  addi r30, r11, -0x1d4
	ctx.r[30].s64 = ctx.r[11].s64 + -468;
	// 821DC370: C01E94A8  lfs f0, -0x6b58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27480 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DC374: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821DC378: 4805DC19  bl 0x82239f90
	ctx.lr = 0x821DC37C;
	sub_82239F90(ctx, base);
	// 821DC37C: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821DC380: 392100C0  addi r9, r1, 0xc0
	ctx.r[9].s64 = ctx.r[1].s64 + 192;
	// 821DC384: 390100D0  addi r8, r1, 0xd0
	ctx.r[8].s64 = ctx.r[1].s64 + 208;
	// 821DC388: C01E9664  lfs f0, -0x699c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27036 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DC38C: 38E100B0  addi r7, r1, 0xb0
	ctx.r[7].s64 = ctx.r[1].s64 + 176;
	// 821DC390: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	pc = 0x821DC3D4; continue 'dispatch;
            }
            0x821DC3D4 => {
    //   block [0x821DC3D4..0x821DC5F4)
	// 821DC3D4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DC3D8: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821DC3DC: 3BCBFE2C  addi r30, r11, -0x1d4
	ctx.r[30].s64 = ctx.r[11].s64 + -468;
	// 821DC3E0: 39210064  addi r9, r1, 0x64
	ctx.r[9].s64 = ctx.r[1].s64 + 100;
	// 821DC3E4: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 821DC3E8: 38E10064  addi r7, r1, 0x64
	ctx.r[7].s64 = ctx.r[1].s64 + 100;
	// 821DC3EC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 821DC3F0: C3FE9658  lfs f31, -0x69a8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27048 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821DC3F4: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 821DC3F8: D3E10064  stfs f31, 0x64(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821DC3FC: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 821DC400: C01E9664  lfs f0, -0x699c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-27036 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DC404: 3B810068  addi r28, r1, 0x68
	ctx.r[28].s64 = ctx.r[1].s64 + 104;
	// 821DC408: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821DC40C: 3B610068  addi r27, r1, 0x68
	ctx.r[27].s64 = ctx.r[1].s64 + 104;
	// 821DC410: D3E10070  stfs f31, 0x70(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821DC414: 3B2100A0  addi r25, r1, 0xa0
	ctx.r[25].s64 = ctx.r[1].s64 + 160;
	pc = 0x821DC5F4; continue 'dispatch;
            }
            0x821DC5F4 => {
    //   block [0x821DC5F4..0x821DC604)
	// 821DC5F4: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 821DC5F8: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 821DC5FC: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821DC600: 48ACCE44  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DC608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DC608 size=12
    let mut pc: u32 = 0x821DC608;
    'dispatch: loop {
        match pc {
            0x821DC608 => {
    //   block [0x821DC608..0x821DC614)
	// 821DC608: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821DC60C: 386B8E60  addi r3, r11, -0x71a0
	ctx.r[3].s64 = ctx.r[11].s64 + -29088;
	// 821DC610: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DC618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DC618 size=556
    let mut pc: u32 = 0x821DC618;
    'dispatch: loop {
        match pc {
            0x821DC618 => {
    //   block [0x821DC618..0x821DC670)
	// 821DC618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DC61C: 48ACCDE9  bl 0x82ca9404
	ctx.lr = 0x821DC620;
	sub_82CA93D0(ctx, base);
	// 821DC620: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DC624: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DC628: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821DC62C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821DC630: 38AA79B0  addi r5, r10, 0x79b0
	ctx.r[5].s64 = ctx.r[10].s64 + 31152;
	// 821DC634: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DC638: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821DC63C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DC640: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 821DC644: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC648: 83670010  lwz r27, 0x10(r7)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DC64C: 4804B97D  bl 0x82227fc8
	ctx.lr = 0x821DC650;
	sub_82227FC8(ctx, base);
	// 821DC650: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DC654: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821DC658: 409A0018  bne cr6, 0x821dc670
	if !ctx.cr[6].eq {
	pc = 0x821DC670; continue 'dispatch;
	}
	// 821DC65C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DC660: 48275CA9  bl 0x82452308
	ctx.lr = 0x821DC664;
	sub_82452308(ctx, base);
	// 821DC664: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821DC668: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821DC66C: 48ACCDE8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x821DC670 => {
    //   block [0x821DC670..0x821DC6C4)
	// 821DC670: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DC674: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC678: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821DC67C: 3BCB9700  addi r30, r11, -0x6900
	ctx.r[30].s64 = ctx.r[11].s64 + -26880;
	// 821DC680: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DC684: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821DC688: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821DC68C: 2F080018  cmpwi cr6, r8, 0x18
	ctx.cr[6].compare_i32(ctx.r[8].s32, 24, &mut ctx.xer);
	// 821DC690: 409A0034  bne cr6, 0x821dc6c4
	if !ctx.cr[6].eq {
	pc = 0x821DC6C4; continue 'dispatch;
	}
	// 821DC694: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821DC698: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DC69C: 40980028  bge cr6, 0x821dc6c4
	if !ctx.cr[6].lt {
	pc = 0x821DC6C4; continue 'dispatch;
	}
	// 821DC6A0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821DC6A4: 419A0020  beq cr6, 0x821dc6c4
	if ctx.cr[6].eq {
	pc = 0x821DC6C4; continue 'dispatch;
	}
	// 821DC6A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC6AC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821DC6B0: 409A0014  bne cr6, 0x821dc6c4
	if !ctx.cr[6].eq {
	pc = 0x821DC6C4; continue 'dispatch;
	}
	// 821DC6B4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821DC6B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DC6BC: 4805BA15  bl 0x822380d0
	ctx.lr = 0x821DC6C0;
	sub_822380D0(ctx, base);
	// 821DC6C0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	pc = 0x821DC6C4; continue 'dispatch;
            }
            0x821DC6C4 => {
    //   block [0x821DC6C4..0x821DC724)
	// 821DC6C4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821DC6C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DC6CC: 4804BA2D  bl 0x822280f8
	ctx.lr = 0x821DC6D0;
	sub_822280F8(ctx, base);
	// 821DC6D0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DC6D4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC6D8: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DC6DC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DC6E0: 40980138  bge cr6, 0x821dc818
	if !ctx.cr[6].lt {
	pc = 0x821DC818; continue 'dispatch;
	}
	// 821DC6E4: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821DC6E8: 419A003C  beq cr6, 0x821dc724
	if ctx.cr[6].eq {
	pc = 0x821DC724; continue 'dispatch;
	}
	// 821DC6EC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC6F0: 2F090003  cmpwi cr6, r9, 3
	ctx.cr[6].compare_i32(ctx.r[9].s32, 3, &mut ctx.xer);
	// 821DC6F4: 409A0030  bne cr6, 0x821dc724
	if !ctx.cr[6].eq {
	pc = 0x821DC724; continue 'dispatch;
	}
	// 821DC6F8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821DC6FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DC700: 4805B9D1  bl 0x822380d0
	ctx.lr = 0x821DC704;
	sub_822380D0(ctx, base);
	// 821DC704: E97D0008  ld r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 821DC708: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821DC70C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821DC710: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 821DC714: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821DC718: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821DC71C: 4BFBA4D5  bl 0x82196bf0
	ctx.lr = 0x821DC720;
	sub_82196BF0(ctx, base);
	// 821DC720: 480000BC  b 0x821dc7dc
	pc = 0x821DC7DC; continue 'dispatch;
            }
            0x821DC724 => {
    //   block [0x821DC724..0x821DC74C)
	// 821DC724: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DC728: 409800F0  bge cr6, 0x821dc818
	if !ctx.cr[6].lt {
	pc = 0x821DC818; continue 'dispatch;
	}
	// 821DC72C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821DC730: 419A00E8  beq cr6, 0x821dc818
	if ctx.cr[6].eq {
	pc = 0x821DC818; continue 'dispatch;
	}
	// 821DC734: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC738: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 821DC73C: 409A00DC  bne cr6, 0x821dc818
	if !ctx.cr[6].eq {
	pc = 0x821DC818; continue 'dispatch;
	}
	// 821DC740: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DC744: 41980008  blt cr6, 0x821dc74c
	if ctx.cr[6].lt {
	pc = 0x821DC74C; continue 'dispatch;
	}
	// 821DC748: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821DC74C; continue 'dispatch;
            }
            0x821DC74C => {
    //   block [0x821DC74C..0x821DC774)
	// 821DC74C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DC750: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 821DC754: 419A0050  beq cr6, 0x821dc7a4
	if ctx.cr[6].eq {
	pc = 0x821DC7A4; continue 'dispatch;
	}
	// 821DC758: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821DC75C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DC760: 480C25F9  bl 0x8229ed58
	ctx.lr = 0x821DC764;
	sub_8229ED58(ctx, base);
	// 821DC764: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821DC768: 409A000C  bne cr6, 0x821dc774
	if !ctx.cr[6].eq {
	pc = 0x821DC774; continue 'dispatch;
	}
	// 821DC76C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DC770: 4800003C  b 0x821dc7ac
	pc = 0x821DC7AC; continue 'dispatch;
            }
            0x821DC774 => {
    //   block [0x821DC774..0x821DC790)
	// 821DC774: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DC778: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821DC77C: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821DC780: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821DC784: 4198000C  blt cr6, 0x821dc790
	if ctx.cr[6].lt {
	pc = 0x821DC790; continue 'dispatch;
	}
	// 821DC788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DC78C: 4BF9CDF5  bl 0x82179580
	ctx.lr = 0x821DC790;
	sub_82179580(ctx, base);
	pc = 0x821DC790; continue 'dispatch;
            }
            0x821DC790 => {
    //   block [0x821DC790..0x821DC7A4)
	// 821DC790: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DC794: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC798: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DC79C: 41980008  blt cr6, 0x821dc7a4
	if ctx.cr[6].lt {
	pc = 0x821DC7A4; continue 'dispatch;
	}
	// 821DC7A0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821DC7A4; continue 'dispatch;
            }
            0x821DC7A4 => {
    //   block [0x821DC7A4..0x821DC7AC)
	// 821DC7A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DC7A8: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	pc = 0x821DC7AC; continue 'dispatch;
            }
            0x821DC7AC => {
    //   block [0x821DC7AC..0x821DC7DC)
	// 821DC7AC: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821DC7B0: E95D0008  ld r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 821DC7B4: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 821DC7B8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821DC7BC: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821DC7C0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 821DC7C4: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 821DC7C8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 821DC7CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821DC7D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821DC7D4: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 821DC7D8: 480F9F31  bl 0x822d6708
	ctx.lr = 0x821DC7DC;
	sub_822D6708(ctx, base);
	pc = 0x821DC7DC; continue 'dispatch;
            }
            0x821DC7DC => {
    //   block [0x821DC7DC..0x821DC818)
	// 821DC7DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821DC7E0: 419A0038  beq cr6, 0x821dc818
	if ctx.cr[6].eq {
	pc = 0x821DC818; continue 'dispatch;
	}
	// 821DC7E4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC7E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DC7EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821DC7F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DC7F4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821DC7F8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821DC7FC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC800: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 821DC804: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821DC808: 48222449  bl 0x823fec50
	ctx.lr = 0x821DC80C;
	sub_823FEC50(ctx, base);
	// 821DC80C: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 821DC810: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821DC814: 48ACCC40  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x821DC818 => {
    //   block [0x821DC818..0x821DC844)
	// 821DC818: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC81C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821DC820: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DC824: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821DC828: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821DC82C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821DC830: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DC834: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 821DC838: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821DC83C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821DC840: 48ACCC14  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DC848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DC848 size=600
    let mut pc: u32 = 0x821DC848;
    'dispatch: loop {
        match pc {
            0x821DC848 => {
    //   block [0x821DC848..0x821DCAA0)
	// 821DC848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DC84C: 48ACCBBD  bl 0x82ca9408
	ctx.lr = 0x821DC850;
	sub_82CA93D0(ctx, base);
	// 821DC850: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 821DC854: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 821DC858: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821DC85C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DC860: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DCAA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DCAA0 size=128
    let mut pc: u32 = 0x821DCAA0;
    'dispatch: loop {
        match pc {
            0x821DCAA0 => {
    //   block [0x821DCAA0..0x821DCAD8)
	// 821DCAA0: 81632E4C  lwz r11, 0x2e4c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(11852 as u32) ) } as u64;
	// 821DCAA4: 508BF800  rlwimi r11, r4, 0x1f, 0, 0
	ctx.r[11].u64 = (((ctx.r[4].u32).rotate_left(31) as u64) & 0x0000000080000000) | (ctx.r[11].u64 & 0xFFFFFFFF7FFFFFFF);
	// 821DCAA8: 91632E4C  stw r11, 0x2e4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(11852 as u32), ctx.r[11].u32 ) };
	// 821DCAAC: 556A0043  rlwinm. r10, r11, 0, 1, 1
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821DCAB0: 81632E48  lwz r11, 0x2e48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(11848 as u32) ) } as u64;
	// 821DCAB4: 40820024  bne 0x821dcad8
	if !ctx.cr[0].eq {
	pc = 0x821DCAD8; continue 'dispatch;
	}
	// 821DCAB8: 716A1010  andi. r10, r11, 0x1010
	ctx.r[10].u64 = ctx.r[11].u64 & 4112;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821DCABC: 55692336  rlwinm r9, r11, 4, 0xc, 0x1b
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0FFFFFFFu64;
	// 821DCAC0: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 821DCAC4: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821DCAC8: 554A601E  rlwinm r10, r10, 0xc, 0, 0xf
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 821DCACC: 554A0314  rlwinm r10, r10, 0, 0xc, 0xa
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821DCAD0: 554A0104  rlwinm r10, r10, 0, 4, 2
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821DCAD4: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	pc = 0x821DCAD8; continue 'dispatch;
            }
            0x821DCAD8 => {
    //   block [0x821DCAD8..0x821DCAE8)
	// 821DCAD8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821DCADC: 409A000C  bne cr6, 0x821dcae8
	if !ctx.cr[6].eq {
	pc = 0x821DCAE8; continue 'dispatch;
	}
	// 821DCAE0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821DCAE4: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	pc = 0x821DCAE8; continue 'dispatch;
            }
            0x821DCAE8 => {
    //   block [0x821DCAE8..0x821DCB20)
	// 821DCAE8: 9163295C  stw r11, 0x295c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10588 as u32), ctx.r[11].u32 ) };
	// 821DCAEC: 91632938  stw r11, 0x2938(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10552 as u32), ctx.r[11].u32 ) };
	// 821DCAF0: 91632958  stw r11, 0x2958(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10584 as u32), ctx.r[11].u32 ) };
	// 821DCAF4: 91632960  stw r11, 0x2960(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10592 as u32), ctx.r[11].u32 ) };
	// 821DCAF8: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821DCAFC: 616B0400  ori r11, r11, 0x400
	ctx.r[11].u64 = ctx.r[11].u64 | 1024;
	// 821DCB00: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821DCB04: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 821DCB08: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821DCB0C: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 821DCB10: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821DCB14: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821DCB18: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821DCB1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DCB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DCB20 size=1136
    let mut pc: u32 = 0x821DCB20;
    'dispatch: loop {
        match pc {
            0x821DCB20 => {
    //   block [0x821DCB20..0x821DCF90)
	// 821DCB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DCB24: 48ACC8AD  bl 0x82ca93d0
	ctx.lr = 0x821DCB28;
	sub_82CA93D0(ctx, base);
	// 821DCB28: DBC1FF58  stfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 821DCB2C: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 821DCB30: 3980FF40  li r12, -0xc0
	ctx.r[12].s64 = -192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DCF90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DCF90 size=416
    let mut pc: u32 = 0x821DCF90;
    'dispatch: loop {
        match pc {
            0x821DCF90 => {
    //   block [0x821DCF90..0x821DD130)
	// 821DCF90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DCF94: 48ACC465  bl 0x82ca93f8
	ctx.lr = 0x821DCF98;
	sub_82CA93D0(ctx, base);
	// 821DCF98: 8163013C  lwz r11, 0x13c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(316 as u32) ) } as u64;
	// 821DCF9C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821DCFA0: 81430138  lwz r10, 0x138(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(312 as u32) ) } as u64;
	// 821DCFA4: 38E30100  addi r7, r3, 0x100
	ctx.r[7].s64 = ctx.r[3].s64 + 256;
	// 821DCFA8: 81230134  lwz r9, 0x134(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(308 as u32) ) } as u64;
	// 821DCFAC: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 821DCFB0: 3BEAFFFF  addi r31, r10, -1
	ctx.r[31].s64 = ctx.r[10].s64 + -1;
	// 821DCFB4: 81030130  lwz r8, 0x130(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(304 as u32) ) } as u64;
	// 821DCFB8: 3BC9FFFF  addi r30, r9, -1
	ctx.r[30].s64 = ctx.r[9].s64 + -1;
	// 821DCFBC: 83840010  lwz r28, 0x10(r4)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DCFC0: 7CBBFE70  srawi r27, r5, 0x1f
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[5].s32 >> 31) as i64;
	// 821DCFC4: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 821DCFC8: 7FFAFE70  srawi r26, r31, 0x1f
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[31].s32 >> 31) as i64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DD130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DD130 size=416
    let mut pc: u32 = 0x821DD130;
    'dispatch: loop {
        match pc {
            0x821DD130 => {
    //   block [0x821DD130..0x821DD2D0)
	// 821DD130: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DD134: 48ACC2C5  bl 0x82ca93f8
	ctx.lr = 0x821DD138;
	sub_82CA93D0(ctx, base);
	// 821DD138: 816300BC  lwz r11, 0xbc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(188 as u32) ) } as u64;
	// 821DD13C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821DD140: 814300B8  lwz r10, 0xb8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(184 as u32) ) } as u64;
	// 821DD144: 38E300A0  addi r7, r3, 0xa0
	ctx.r[7].s64 = ctx.r[3].s64 + 160;
	// 821DD148: 812300B4  lwz r9, 0xb4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(180 as u32) ) } as u64;
	// 821DD14C: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 821DD150: 3BEAFFFF  addi r31, r10, -1
	ctx.r[31].s64 = ctx.r[10].s64 + -1;
	// 821DD154: 810300B0  lwz r8, 0xb0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) } as u64;
	// 821DD158: 3BC9FFFF  addi r30, r9, -1
	ctx.r[30].s64 = ctx.r[9].s64 + -1;
	// 821DD15C: 83840010  lwz r28, 0x10(r4)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DD160: 7CBBFE70  srawi r27, r5, 0x1f
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[5].s32 >> 31) as i64;
	// 821DD164: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 821DD168: 7FFAFE70  srawi r26, r31, 0x1f
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[26].s64 = (ctx.r[31].s32 >> 31) as i64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DD2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DD2D0 size=224
    let mut pc: u32 = 0x821DD2D0;
    'dispatch: loop {
        match pc {
            0x821DD2D0 => {
    //   block [0x821DD2D0..0x821DD330)
	// 821DD2D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DD2D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DD2D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821DD2DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DD2E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DD2E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821DD2E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821DD2EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DD2F0: 997F0700  stb r11, 0x700(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1792 as u32), ctx.r[11].u8 ) };
	// 821DD2F4: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DD2F8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821DD2FC: 419A009C  beq cr6, 0x821dd398
	if ctx.cr[6].eq {
	pc = 0x821DD398; continue 'dispatch;
	}
	// 821DD300: 480CCF41  bl 0x822aa240
	ctx.lr = 0x821DD304;
	sub_822AA240(ctx, base);
	// 821DD304: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DD308: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821DD30C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821DD310: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD314: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DD318: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821DD31C: 4E800421  bctrl
	ctx.lr = 0x821DD320;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DD320: 57C8063E  clrlwi r8, r30, 0x18
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 821DD324: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821DD328: 419A0008  beq cr6, 0x821dd330
	if ctx.cr[6].eq {
	pc = 0x821DD330; continue 'dispatch;
	}
	// 821DD32C: 480B200D  bl 0x8228f338
	ctx.lr = 0x821DD330;
	sub_8228F338(ctx, base);
            }
            0x821DD330 => {
    //   block [0x821DD330..0x821DD394)
	// 821DD330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DD334: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DD338: 4BFEFFD9  bl 0x821cd310
	ctx.lr = 0x821DD33C;
	sub_821CD310(ctx, base);
	// 821DD33C: 48046815  bl 0x82223b50
	ctx.lr = 0x821DD340;
	sub_82223B50(ctx, base);
	// 821DD340: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 821DD344: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 821DD348: 38A00060  li r5, 0x60
	ctx.r[5].s64 = 96;
	// 821DD34C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821DD350: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821DD354: 4BFBFA15  bl 0x8219cd68
	ctx.lr = 0x821DD358;
	sub_8219CD68(ctx, base);
	// 821DD358: 480443E9  bl 0x82221740
	ctx.lr = 0x821DD35C;
	sub_82221740(ctx, base);
	// 821DD35C: 38C00050  li r6, 0x50
	ctx.r[6].s64 = 80;
	// 821DD360: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 821DD364: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821DD368: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821DD36C: 4BFBF9FD  bl 0x8219cd68
	ctx.lr = 0x821DD370;
	sub_8219CD68(ctx, base);
	// 821DD370: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DD374: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821DD378: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821DD37C: 894B70D3  lbz r10, 0x70d3(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28883 as u32) ) } as u64;
	// 821DD380: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DD384: 419A0010  beq cr6, 0x821dd394
	if ctx.cr[6].eq {
	pc = 0x821DD394; continue 'dispatch;
	}
	// 821DD388: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821DD38C: 489C49B5  bl 0x82ba1d40
	ctx.lr = 0x821DD390;
	sub_82BA1D40(ctx, base);
	// 821DD390: 48000008  b 0x821dd398
	pc = 0x821DD398; continue 'dispatch;
            }
            0x821DD394 => {
    //   block [0x821DD394..0x821DD398)
	// 821DD394: 4808825D  bl 0x822655f0
	ctx.lr = 0x821DD398;
	sub_822655F0(ctx, base);
	pc = 0x821DD398; continue 'dispatch;
            }
            0x821DD398 => {
    //   block [0x821DD398..0x821DD3B0)
	// 821DD398: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821DD39C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DD3A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DD3A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821DD3A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821DD3AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DD3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DD3B0 size=288
    let mut pc: u32 = 0x821DD3B0;
    'dispatch: loop {
        match pc {
            0x821DD3B0 => {
    //   block [0x821DD3B0..0x821DD3E0)
	// 821DD3B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DD3B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DD3B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DD3BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DD3C0: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DD3C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DD3C8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821DD3CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DD3D0: 419A0010  beq cr6, 0x821dd3e0
	if ctx.cr[6].eq {
	pc = 0x821DD3E0; continue 'dispatch;
	}
	// 821DD3D4: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821DD3D8: 894A6A5E  lbz r10, 0x6a5e(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(27230 as u32) ) } as u64;
	// 821DD3DC: 48000008  b 0x821dd3e4
	pc = 0x821DD3E4; continue 'dispatch;
            }
            0x821DD3E0 => {
    //   block [0x821DD3E0..0x821DD3E4)
	// 821DD3E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821DD3E4; continue 'dispatch;
            }
            0x821DD3E4 => {
    //   block [0x821DD3E4..0x821DD420)
	// 821DD3E4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821DD3E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DD3EC: 419A0058  beq cr6, 0x821dd444
	if ctx.cr[6].eq {
	pc = 0x821DD444; continue 'dispatch;
	}
	// 821DD3F0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DD3F4: 894B0104  lbz r10, 0x104(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(260 as u32) ) } as u64;
	// 821DD3F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DD3FC: 409A0048  bne cr6, 0x821dd444
	if !ctx.cr[6].eq {
	pc = 0x821DD444; continue 'dispatch;
	}
	// 821DD400: 80640004  lwz r3, 4(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DD404: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821DD408: 419A0030  beq cr6, 0x821dd438
	if ctx.cr[6].eq {
	pc = 0x821DD438; continue 'dispatch;
	}
	// 821DD40C: 48088B85  bl 0x82265f90
	ctx.lr = 0x821DD410;
	sub_82265F90(ctx, base);
	// 821DD410: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821DD414: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 821DD418: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821DD41C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821DD420; continue 'dispatch;
            }
            0x821DD420 => {
    //   block [0x821DD420..0x821DD438)
	// 821DD420: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821DD424: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821DD428: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821DD42C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821DD430: 4200FFF0  bdnz 0x821dd420
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821DD420; continue 'dispatch;
	}
	// 821DD434: 48000084  b 0x821dd4b8
	pc = 0x821DD4B8; continue 'dispatch;
            }
            0x821DD438 => {
    //   block [0x821DD438..0x821DD444)
	// 821DD438: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DD43C: 4826143D  bl 0x8243e878
	ctx.lr = 0x821DD440;
	sub_8243E878(ctx, base);
	// 821DD440: 48000078  b 0x821dd4b8
	pc = 0x821DD4B8; continue 'dispatch;
            }
            0x821DD444 => {
    //   block [0x821DD444..0x821DD4B8)
	// 821DD444: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DD448: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 821DD44C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 821DD450: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821DD454: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821DD458: 38E99140  addi r7, r9, -0x6ec0
	ctx.r[7].s64 = ctx.r[9].s64 + -28352;
	// 821DD45C: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DD460: 38C89150  addi r6, r8, -0x6eb0
	ctx.r[6].s64 = ctx.r[8].s64 + -28336;
	// 821DD464: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821DD468: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	pc = 0x821DD4B8; continue 'dispatch;
            }
            0x821DD4B8 => {
    //   block [0x821DD4B8..0x821DD4D0)
	// 821DD4B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DD4BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821DD4C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DD4C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DD4C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821DD4CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DD4D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DD4D0 size=328
    let mut pc: u32 = 0x821DD4D0;
    'dispatch: loop {
        match pc {
            0x821DD4D0 => {
    //   block [0x821DD4D0..0x821DD500)
	// 821DD4D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DD4D4: 48ACBF39  bl 0x82ca940c
	ctx.lr = 0x821DD4D8;
	sub_82CA93D0(ctx, base);
	// 821DD4D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DD4DC: 81430018  lwz r10, 0x18(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 821DD4E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DD4E4: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DD4E8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821DD4EC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821DD4F0: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821DD4F4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821DD4F8: 7D2B2671  srawi. r11, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 4) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DD4FC: 40810054  ble 0x821dd550
	if !ctx.cr[0].gt {
	pc = 0x821DD550; continue 'dispatch;
	}
	pc = 0x821DD500; continue 'dispatch;
            }
            0x821DD500 => {
    //   block [0x821DD500..0x821DD520)
	// 821DD500: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821DD504: 55282036  slwi r8, r9, 4
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DD508: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821DD50C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD510: 7F072000  cmpw cr6, r7, r4
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[4].s32, &mut ctx.xer);
	// 821DD514: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821DD518: 41980008  blt cr6, 0x821dd520
	if ctx.cr[6].lt {
	pc = 0x821DD520; continue 'dispatch;
	}
	// 821DD51C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821DD520; continue 'dispatch;
            }
            0x821DD520 => {
    //   block [0x821DD520..0x821DD53C)
	// 821DD520: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821DD524: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DD528: 419A0014  beq cr6, 0x821dd53c
	if ctx.cr[6].eq {
	pc = 0x821DD53C; continue 'dispatch;
	}
	// 821DD52C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821DD530: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 821DD534: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821DD538: 4800000C  b 0x821dd544
	pc = 0x821DD544; continue 'dispatch;
            }
            0x821DD53C => {
    //   block [0x821DD53C..0x821DD544)
	// 821DD53C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821DD540: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821DD544; continue 'dispatch;
            }
            0x821DD544 => {
    //   block [0x821DD544..0x821DD550)
	// 821DD544: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DD548: 4199FFB8  bgt cr6, 0x821dd500
	if ctx.cr[6].gt {
	pc = 0x821DD500; continue 'dispatch;
	}
	// 821DD54C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821DD550; continue 'dispatch;
            }
            0x821DD550 => {
    //   block [0x821DD550..0x821DD56C)
	// 821DD550: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821DD554: 419A0034  beq cr6, 0x821dd588
	if ctx.cr[6].eq {
	pc = 0x821DD588; continue 'dispatch;
	}
	// 821DD558: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD55C: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821DD560: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DD564: 41980008  blt cr6, 0x821dd56c
	if ctx.cr[6].lt {
	pc = 0x821DD56C; continue 'dispatch;
	}
	// 821DD568: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821DD56C; continue 'dispatch;
            }
            0x821DD56C => {
    //   block [0x821DD56C..0x821DD588)
	// 821DD56C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DD570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DD574: 409A0014  bne cr6, 0x821dd588
	if !ctx.cr[6].eq {
	pc = 0x821DD588; continue 'dispatch;
	}
	// 821DD578: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DD57C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821DD580: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821DD584: 48000008  b 0x821dd58c
	pc = 0x821DD58C; continue 'dispatch;
            }
            0x821DD588 => {
    //   block [0x821DD588..0x821DD58C)
	// 821DD588: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x821DD58C; continue 'dispatch;
            }
            0x821DD58C => {
    //   block [0x821DD58C..0x821DD5A4)
	// 821DD58C: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DD590: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DD594: 419A0078  beq cr6, 0x821dd60c
	if ctx.cr[6].eq {
	pc = 0x821DD60C; continue 'dispatch;
	}
	// 821DD598: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DD59C: 3BCB0004  addi r30, r11, 4
	ctx.r[30].s64 = ctx.r[11].s64 + 4;
	// 821DD5A0: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821DD5A4; continue 'dispatch;
            }
            0x821DD5A4 => {
    //   block [0x821DD5A4..0x821DD5B4)
	// 821DD5A4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DD5A8: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821DD5AC: 419A0008  beq cr6, 0x821dd5b4
	if ctx.cr[6].eq {
	pc = 0x821DD5B4; continue 'dispatch;
	}
	// 821DD5B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DD5B4; continue 'dispatch;
            }
            0x821DD5B4 => {
    //   block [0x821DD5B4..0x821DD5CC)
	// 821DD5B4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DD5B8: 419A0054  beq cr6, 0x821dd60c
	if ctx.cr[6].eq {
	pc = 0x821DD60C; continue 'dispatch;
	}
	// 821DD5BC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DD5C0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DD5C4: 409A0008  bne cr6, 0x821dd5cc
	if !ctx.cr[6].eq {
	pc = 0x821DD5CC; continue 'dispatch;
	}
	// 821DD5C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DD5CC; continue 'dispatch;
            }
            0x821DD5CC => {
    //   block [0x821DD5CC..0x821DD5F8)
	// 821DD5CC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DD5D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD5D4: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DD5D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DD5DC: 4E800421  bctrl
	ctx.lr = 0x821DD5E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DD5E0: 7F03E800  cmpw cr6, r3, r29
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[29].s32, &mut ctx.xer);
	// 821DD5E4: 419A001C  beq cr6, 0x821dd600
	if ctx.cr[6].eq {
	pc = 0x821DD600; continue 'dispatch;
	}
	// 821DD5E8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DD5EC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DD5F0: 409A0008  bne cr6, 0x821dd5f8
	if !ctx.cr[6].eq {
	pc = 0x821DD5F8; continue 'dispatch;
	}
	// 821DD5F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x821DD5F8 => {
    //   block [0x821DD5F8..0x821DD600)
	// 821DD5F8: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD5FC: 4BFFFFA8  b 0x821dd5a4
	pc = 0x821DD5A4; continue 'dispatch;
            }
            0x821DD600 => {
    //   block [0x821DD600..0x821DD60C)
	// 821DD600: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821DD604: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DD608: 48ACBE54  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821DD60C => {
    //   block [0x821DD60C..0x821DD618)
	// 821DD60C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821DD610: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DD614: 48ACBE48  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DD618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DD618 size=328
    let mut pc: u32 = 0x821DD618;
    'dispatch: loop {
        match pc {
            0x821DD618 => {
    //   block [0x821DD618..0x821DD69C)
	// 821DD618: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DD61C: 48ACBDED  bl 0x82ca9408
	ctx.lr = 0x821DD620;
	sub_82CA93D0(ctx, base);
	// 821DD620: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DD624: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821DD628: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821DD62C: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 821DD630: 48048CC9  bl 0x822262f8
	ctx.lr = 0x821DD634;
	sub_822262F8(ctx, base);
	// 821DD634: 89630004  lbz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DD638: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DD63C: 409A011C  bne cr6, 0x821dd758
	if !ctx.cr[6].eq {
	pc = 0x821DD758; continue 'dispatch;
	}
	// 821DD640: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DD644: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821DD648: 80C30010  lwz r6, 0x10(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DD64C: 3CA08331  lis r5, -0x7ccf
	ctx.r[5].s64 = -2093940736;
	// 821DD650: 80830060  lwz r4, 0x60(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 821DD654: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821DD658: 83A3005C  lwz r29, 0x5c(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(92 as u32) ) } as u64;
	// 821DD65C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821DD660: 3B9F00B0  addi r28, r31, 0xb0
	ctx.r[28].s64 = ctx.r[31].s64 + 176;
	// 821DD664: C00300B0  lfs f0, 0xb0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DD668: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821DD66C: 990B16C7  stb r8, 0x16c7(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(5831 as u32), ctx.r[8].u8 ) };
	// 821DD670: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821DD674: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821DD678: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 821DD67C: 90C10068  stw r6, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[6].u32 ) };
	// 821DD680: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821DD684: 9081006C  stw r4, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[4].u32 ) };
	// 821DD688: 39000008  li r8, 8
	ctx.r[8].s64 = 8;
	// 821DD68C: 98E55E3A  stb r7, 0x5e3a(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(24122 as u32), ctx.r[7].u8 ) };
	// 821DD690: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 821DD694: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 821DD698: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	pc = 0x821DD69C; continue 'dispatch;
            }
            0x821DD69C => {
    //   block [0x821DD69C..0x821DD754)
	// 821DD69C: E90B0000  ld r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821DD6A0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821DD6A4: F90A0000  std r8, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u64 ) };
	// 821DD6A8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821DD6AC: 4200FFF0  bdnz 0x821dd69c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821DD69C; continue 'dispatch;
	}
	// 821DD6B0: 8163004C  lwz r11, 0x4c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 821DD6B4: C0030050  lfs f0, 0x50(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DD6B8: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DD6BC: C1A30044  lfs f13, 0x44(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DD6C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821DD6C4: C1830040  lfs f12, 0x40(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821DD6C8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821DD6CC: 906100D8  stw r3, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[3].u32 ) };
	// 821DD6D0: 7D6807B4  extsw r8, r11
	ctx.r[8].s64 = ctx.r[11].s32 as i64;
	// 821DD6D4: D1A100C8  stfs f13, 0xc8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 821DD6D8: 7D4707B4  extsw r7, r10
	ctx.r[7].s64 = ctx.r[10].s32 as i64;
	// 821DD6DC: D18100CC  stfs f12, 0xcc(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 821DD6E0: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 821DD6E4: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DD6E8: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 821DD6EC: C9410050  lfd f10, 0x50(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DD6F0: FD005E9C  fcfid f8, f11
	ctx.f[8].f64 = (ctx.f[11].s64 as f64);
	// 821DD6F4: 912100C0  stw r9, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[9].u32 ) };
	// 821DD6F8: FD20569C  fcfid f9, f10
	ctx.f[9].f64 = (ctx.f[10].s64 as f64);
	// 821DD6FC: 912100C4  stw r9, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[9].u32 ) };
	// 821DD700: FCC04018  frsp f6, f8
	ctx.f[6].f64 = (ctx.f[8].f64 as f32) as f64;
	// 821DD704: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821DD708: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821DD70C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DD710: FCE04818  frsp f7, f9
	ctx.f[7].f64 = (ctx.f[9].f64 as f32) as f64;
	// 821DD714: EC860032  fmuls f4, f6, f0
	ctx.f[4].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 821DD718: D08100D4  stfs f4, 0xd4(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 821DD71C: ECA70032  fmuls f5, f7, f0
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 821DD720: D0A100D0  stfs f5, 0xd0(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 821DD724: 4806043D  bl 0x8223db60
	ctx.lr = 0x821DD728;
	sub_8223DB60(ctx, base);
	// 821DD728: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 821DD72C: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821DD730: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821DD734: 88A670D3  lbz r5, 0x70d3(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(28883 as u32) ) } as u64;
	// 821DD738: 806B0364  lwz r3, 0x364(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 821DD73C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821DD740: 419A0014  beq cr6, 0x821dd754
	if ctx.cr[6].eq {
	pc = 0x821DD754; continue 'dispatch;
	}
	// 821DD744: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821DD748: 489C45F9  bl 0x82ba1d40
	ctx.lr = 0x821DD74C;
	sub_82BA1D40(ctx, base);
	// 821DD74C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821DD750: 48ACBD08  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x821DD754 => {
    //   block [0x821DD754..0x821DD758)
	// 821DD754: 48087E9D  bl 0x822655f0
	ctx.lr = 0x821DD758;
	sub_822655F0(ctx, base);
	pc = 0x821DD758; continue 'dispatch;
            }
            0x821DD758 => {
    //   block [0x821DD758..0x821DD760)
	// 821DD758: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 821DD75C: 48ACBCFC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DD760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DD760 size=2924
    let mut pc: u32 = 0x821DD760;
    'dispatch: loop {
        match pc {
            0x821DD760 => {
    //   block [0x821DD760..0x821DD798)
	// 821DD760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DD764: 48ACBC6D  bl 0x82ca93d0
	ctx.lr = 0x821DD768;
	sub_82CA93D0(ctx, base);
	// 821DD768: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 821DD76C: 48AD0551  bl 0x82cadcbc
	ctx.lr = 0x821DD770;
	sub_82CADCA0(ctx, base);
	// 821DD770: 9421FD10  stwu r1, -0x2f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-752 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DD774: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821DD778: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821DD77C: 99210058  stb r9, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u8 ) };
	// 821DD780: 3D20834B  lis r9, -0x7cb5
	ctx.r[9].s64 = -2092236800;
	// 821DD784: 394B2390  addi r10, r11, 0x2390
	ctx.r[10].s64 = ctx.r[11].s64 + 9104;
	// 821DD788: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 821DD78C: 7C8E2378  mr r14, r4
	ctx.r[14].u64 = ctx.r[4].u64;
	// 821DD790: 396A2004  addi r11, r10, 0x2004
	ctx.r[11].s64 = ctx.r[10].s64 + 8196;
	// 821DD794: 39097E70  addi r8, r9, 0x7e70
	ctx.r[8].s64 = ctx.r[9].s64 + 32368;
	pc = 0x821DD798; continue 'dispatch;
            }
            0x821DD798 => {
    //   block [0x821DD798..0x821DD860)
	// 821DD798: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD79C: 38EA6014  addi r7, r10, 0x6014
	ctx.r[7].s64 = ctx.r[10].s64 + 24596;
	// 821DD7A0: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821DD7A4: 7CC95A14  add r6, r9, r11
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821DD7A8: 9106DFFC  stw r8, -0x2004(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(-8196 as u32), ctx.r[8].u32 ) };
	// 821DD7AC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD7B0: 80ABFFFC  lwz r5, -4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821DD7B4: 54A3083C  slwi r3, r5, 1
	ctx.r[3].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821DD7B8: 38890001  addi r4, r9, 1
	ctx.r[4].s64 = ctx.r[9].s64 + 1;
	// 821DD7BC: 906BFFFC  stw r3, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[3].u32 ) };
	// 821DD7C0: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821DD7C4: 396B2008  addi r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + 8200;
	// 821DD7C8: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821DD7CC: 4198FFCC  blt cr6, 0x821dd798
	if ctx.cr[6].lt {
	pc = 0x821DD798; continue 'dispatch;
	}
	// 821DD7D0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821DD7D4: C8140048  lfd f0, 0x48(r20)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[20].u32.wrapping_add(72 as u32) ) };
	// 821DD7D8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821DD7DC: 3AAAB480  addi r21, r10, -0x4b80
	ctx.r[21].s64 = ctx.r[10].s64 + -19328;
	// 821DD7E0: 39740048  addi r11, r20, 0x48
	ctx.r[11].s64 = ctx.r[20].s64 + 72;
	// 821DD7E4: C9890D38  lfd f12, 0xd38(r9)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(3384 as u32) ) };
	// 821DD7E8: C1B5E010  lfs f13, -0x1ff0(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-8176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DD7EC: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 821DD7F0: C3D5E004  lfs f30, -0x1ffc(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-8188 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821DD7F4: 419A006C  beq cr6, 0x821dd860
	if ctx.cr[6].eq {
	pc = 0x821DD860; continue 'dispatch;
	}
	// 821DD7F8: C96B0008  lfd f11, 8(r11)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821DD7FC: FD6B0028  fsub f11, f11, f0
	ctx.f[11].f64 = ctx.f[11].f64 - ctx.f[0].f64;
	// 821DD800: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 821DD804: 4099005C  ble cr6, 0x821dd860
	if !ctx.cr[6].gt {
	pc = 0x821DD860; continue 'dispatch;
	}
	// 821DD808: 814E0004  lwz r10, 4(r14)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DD80C: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 821DD810: 39090E68  addi r8, r9, 0xe68
	ctx.r[8].s64 = ctx.r[9].s64 + 3688;
	// 821DD814: C98A02E8  lfd f12, 0x2e8(r10)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(744 as u32) ) };
	// 821DD818: FD4C0028  fsub f10, f12, f0
	ctx.f[10].f64 = ctx.f[12].f64 - ctx.f[0].f64;
	// 821DD81C: FD2A5824  fdiv f9, f10, f11
	ctx.f[9].f64 = ctx.f[10].f64 / ctx.f[11].f64;
	// 821DD820: FD004818  frsp f8, f9
	ctx.f[8].f64 = (ctx.f[9].f64 as f32) as f64;
	// 821DD824: FF08F000  fcmpu cr6, f8, f30
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[30].f64);
	// 821DD828: 7CE00026  mfcr r7
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[7].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821DD82C: 54E6DF7A  rlwinm r6, r7, 0x1b, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 821DD830: 54E5F77A  rlwinm r5, r7, 0x1e, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 821DD834: 7CC42B78  or r4, r6, r5
	ctx.r[4].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 821DD838: 7CE8242E  lfsx f7, r8, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821DD83C: FCC7F22E  fsel f6, f7, f8, f30
	ctx.f[6].f64 = if ctx.f[7].f64 >= 0.0 { ctx.f[8].f64 } else { ctx.f[30].f64 };
	// 821DD840: ECA66828  fsubs f5, f6, f13
	ctx.f[5].f64 = (((ctx.f[6].f64 - ctx.f[13].f64) as f32) as f64);
	// 821DD844: FF05F000  fcmpu cr6, f5, f30
	ctx.cr[6].compare_f64(ctx.f[5].f64, ctx.f[30].f64);
	// 821DD848: 7C600026  mfcr r3
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[3].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821DD84C: 546ADF7A  rlwinm r10, r3, 0x1b, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x0000001Fu64;
	// 821DD850: 5469F77A  rlwinm r9, r3, 0x1e, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x00000003u64;
	// 821DD854: 7D474B78  or r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821DD858: 7C883C2E  lfsx f4, r8, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821DD85C: FDA4336E  fsel f13, f4, f13, f6
	ctx.f[13].f64 = if ctx.f[4].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[6].f64 };
	pc = 0x821DD860; continue 'dispatch;
            }
            0x821DD860 => {
    //   block [0x821DD860..0x821DD874)
	// 821DD860: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DD864: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821DD868: 409A000C  bne cr6, 0x821dd874
	if !ctx.cr[6].eq {
	pc = 0x821DD874; continue 'dispatch;
	}
	// 821DD86C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DD870: 4800000C  b 0x821dd87c
	pc = 0x821DD87C; continue 'dispatch;
            }
            0x821DD874 => {
    //   block [0x821DD874..0x821DD87C)
	// 821DD874: D1AB0010  stfs f13, 0x10(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821DD878: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x821DD87C; continue 'dispatch;
            }
            0x821DD87C => {
    //   block [0x821DD87C..0x821DD8A0)
	// 821DD87C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DD880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DD884: 419A001C  beq cr6, 0x821dd8a0
	if ctx.cr[6].eq {
	pc = 0x821DD8A0; continue 'dispatch;
	}
	// 821DD888: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD88C: C0340058  lfs f1, 0x58(r20)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821DD890: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 821DD894: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821DD898: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DD89C: 4E800421  bctrl
	ctx.lr = 0x821DD8A0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821DD8A0 => {
    //   block [0x821DD8A0..0x821DD8D4)
	// 821DD8A0: 81740000  lwz r11, 0(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DD8A4: 7DC47378  mr r4, r14
	ctx.r[4].u64 = ctx.r[14].u64;
	// 821DD8A8: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 821DD8AC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DD8B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DD8B4: 4E800421  bctrl
	ctx.lr = 0x821DD8B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DD8B8: 3D40834F  lis r10, -0x7cb1
	ctx.r[10].s64 = -2091974656;
	// 821DD8BC: 816A6DC8  lwz r11, 0x6dc8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28104 as u32) ) } as u64;
	// 821DD8C0: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821DD8C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DD8C8: 409A000C  bne cr6, 0x821dd8d4
	if !ctx.cr[6].eq {
	pc = 0x821DD8D4; continue 'dispatch;
	}
	// 821DD8CC: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821DD8D0: 916A6DC8  stw r11, 0x6dc8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28104 as u32), ctx.r[11].u32 ) };
            }
            0x821DD8D4 => {
    //   block [0x821DD8D4..0x821DD8E8)
	// 821DD8D4: 556907BC  rlwinm r9, r11, 0, 0x1e, 0x1e
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821DD8D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DD8DC: 409A000C  bne cr6, 0x821dd8e8
	if !ctx.cr[6].eq {
	pc = 0x821DD8E8; continue 'dispatch;
	}
	// 821DD8E0: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 821DD8E4: 916A6DC8  stw r11, 0x6dc8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28104 as u32), ctx.r[11].u32 ) };
	pc = 0x821DD8E8; continue 'dispatch;
            }
            0x821DD8E8 => {
    //   block [0x821DD8E8..0x821DD914)
	// 821DD8E8: 3CE0834C  lis r7, -0x7cb4
	ctx.r[7].s64 = -2092171264;
	// 821DD8EC: C3F5E010  lfs f31, -0x1ff0(r21)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(-8176 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821DD8F0: 3D60834F  lis r11, -0x7cb1
	ctx.r[11].s64 = -2091974656;
	// 821DD8F4: 39EB6AC8  addi r15, r11, 0x6ac8
	ctx.r[15].s64 = ctx.r[11].s64 + 27336;
	// 821DD8F8: 8967EC92  lbz r11, -0x136e(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(-4974 as u32) ) } as u64;
	// 821DD8FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DD900: 409A00E4  bne cr6, 0x821dd9e4
	if !ctx.cr[6].eq {
	pc = 0x821DD9E4; continue 'dispatch;
	}
	// 821DD904: 3D200000  lis r9, 0
	ctx.r[9].s64 = 0;
	// 821DD908: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 821DD90C: 396F0002  addi r11, r15, 2
	ctx.r[11].s64 = ctx.r[15].s64 + 2;
	// 821DD910: 6129FFFE  ori r9, r9, 0xfffe
	ctx.r[9].u64 = ctx.r[9].u64 | 65534;
	pc = 0x821DD914; continue 'dispatch;
            }
            0x821DD914 => {
    //   block [0x821DD914..0x821DD9E4)
	// 821DD914: 390A0001  addi r8, r10, 1
	ctx.r[8].s64 = ctx.r[10].s64 + 1;
	// 821DD918: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821DD91C: 5544043E  clrlwi r4, r10, 0x10
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 821DD920: B10B0006  sth r8, 6(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[8].u16 ) };
	// 821DD924: 54C3043E  clrlwi r3, r6, 0x10
	ctx.r[3].u64 = ctx.r[6].u32 as u64 & 0x0000FFFFu64;
	// 821DD928: 7CA84A14  add r5, r8, r9
	ctx.r[5].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821DD92C: B08B0000  sth r4, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u16 ) };
	// 821DD930: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821DD934: B06BFFFE  sth r3, -2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(-2 as u32), ctx.r[3].u16 ) };
	// 821DD938: B0AB0002  sth r5, 2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[5].u16 ) };
	// 821DD93C: B06B0004  sth r3, 4(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u16 ) };
	// 821DD940: 2F0A0102  cmpwi cr6, r10, 0x102
	ctx.cr[6].compare_i32(ctx.r[10].s32, 258, &mut ctx.xer);
	// 821DD944: B08B0008  sth r4, 8(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u16 ) };
	// 821DD948: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 821DD94C: 4198FFC8  blt cr6, 0x821dd914
	if ctx.cr[6].lt {
	pc = 0x821DD914; continue 'dispatch;
	}
	// 821DD950: C0152148  lfs f0, 0x2148(r21)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DD954: 3CC0834F  lis r6, -0x7cb1
	ctx.r[6].s64 = -2091974656;
	// 821DD958: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821DD95C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DD960: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821DD964: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DD968: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821DD96C: 38A66A88  addi r5, r6, 0x6a88
	ctx.r[5].s64 = ctx.r[6].s64 + 27272;
	// 821DD970: D3C10054  stfs f30, 0x54(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821DD974: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DD978: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821DD97C: 9967EC92  stb r11, -0x136e(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(-4974 as u32), ctx.r[11].u8 ) };
	// 821DD980: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821DD984: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DD988: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821DD98C: F9250008  std r9, 8(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 821DD990: D3E10068  stfs f31, 0x68(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821DD994: F9050018  std r8, 0x18(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(24 as u32), ctx.r[8].u64 ) };
	// 821DD998: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821DD99C: D3C10064  stfs f30, 0x64(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821DD9A0: E9010060  ld r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821DD9A4: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821DD9A8: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821DD9AC: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821DD9B0: D3E10094  stfs f31, 0x94(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821DD9B4: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821DD9B8: D3C10068  stfs f30, 0x68(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821DD9BC: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821DD9C0: E9210068  ld r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 821DD9C4: F9650010  std r11, 0x10(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821DD9C8: F9466A88  std r10, 0x6a88(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(27272 as u32), ctx.r[10].u64 ) };
	// 821DD9CC: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DD9D0: E9610090  ld r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821DD9D4: F9250028  std r9, 0x28(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(40 as u32), ctx.r[9].u64 ) };
	// 821DD9D8: F9650030  std r11, 0x30(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(48 as u32), ctx.r[11].u64 ) };
	// 821DD9DC: F9450020  std r10, 0x20(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(32 as u32), ctx.r[10].u64 ) };
	// 821DD9E0: F9050038  std r8, 0x38(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	pc = 0x821DD9E4; continue 'dispatch;
            }
            0x821DD9E4 => {
    //   block [0x821DD9E4..0x821DD9FC)
	// 821DD9E4: 817400D4  lwz r11, 0xd4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(212 as u32) ) } as u64;
	// 821DD9E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DD9EC: 409A0010  bne cr6, 0x821dd9fc
	if !ctx.cr[6].eq {
	pc = 0x821DD9FC; continue 'dispatch;
	}
	// 821DD9F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DD9F4: 3A4B9218  addi r18, r11, -0x6de8
	ctx.r[18].s64 = ctx.r[11].s64 + -28136;
	// 821DD9F8: 48000008  b 0x821dda00
	pc = 0x821DDA00; continue 'dispatch;
            }
            0x821DD9FC => {
    //   block [0x821DD9FC..0x821DDA00)
	// 821DD9FC: 824B0000  lwz r18, 0(r11)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821DDA00; continue 'dispatch;
            }
            0x821DDA00 => {
    //   block [0x821DDA00..0x821DE2CC)
	// 821DDA00: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821DDA04: 812E0004  lwz r9, 4(r14)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DDA08: 388E06B0  addi r4, r14, 0x6b0
	ctx.r[4].s64 = ctx.r[14].s64 + 1712;
	// 821DDA0C: 390B60B8  addi r8, r11, 0x60b8
	ctx.r[8].s64 = ctx.r[11].s64 + 24760;
	// 821DDA10: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 821DDA14: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821DDA18: C0090210  lfs f0, 0x210(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(528 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DDA1C: 814B60B8  lwz r10, 0x60b8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24760 as u32) ) } as u64;
	// 821DDA20: 81280008  lwz r9, 8(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DDA24: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DDA28: 7CEA4850  subf r7, r10, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 821DDA2C: 8148000C  lwz r10, 0xc(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DDA30: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821DDA34: 7CE607B4  extsw r6, r7
	ctx.r[6].s64 = ctx.r[7].s32 as i64;
	// 821DDA38: 7CAB07B4  extsw r11, r5
	ctx.r[11].s64 = ctx.r[5].s32 as i64;
	// 821DDA3C: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 821DDA40: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DDA44: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 821DDA48: C9A10070  lfd f13, 0x70(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 821DDA4C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 821DDA50: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 821DDA54: FF405018  frsp f26, f10
	ctx.f[26].f64 = (ctx.f[10].f64 as f32) as f64;
	// 821DDA58: FF206018  frsp f25, f12
	ctx.f[25].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821DDA5C: ED3AC824  fdivs f9, f26, f25
	ctx.f[9].f64 = ((ctx.f[26].f64 / ctx.f[25].f64) as f32) as f64;
	// 821DDA60: EF690024  fdivs f27, f9, f0
	ctx.f[27].f64 = ((ctx.f[9].f64 / ctx.f[0].f64) as f32) as f64;
	// 821DDA64: 4BFC4A2D  bl 0x821a2490
	ctx.lr = 0x821DDA68;
	sub_821A2490(ctx, base);
	// 821DDA68: D3E10060  stfs f31, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821DDA6C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821DDA70: 392000B0  li r9, 0xb0
	ctx.r[9].s64 = 176;
	// 821DDA74: 390A91A0  addi r8, r10, -0x6e60
	ctx.r[8].s64 = ctx.r[10].s64 + -28256;
	// 821DDA78: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821DDA7C: 38C10160  addi r6, r1, 0x160
	ctx.r[6].s64 = ctx.r[1].s64 + 352;
	// 821DDA80: 38A10180  addi r5, r1, 0x180
	ctx.r[5].s64 = ctx.r[1].s64 + 384;
	// 821DDA84: 38810170  addi r4, r1, 0x170
	ctx.r[4].s64 = ctx.r[1].s64 + 368;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DE2D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821DE2D0 size=20
    let mut pc: u32 = 0x821DE2D0;
    'dispatch: loop {
        match pc {
            0x821DE2D0 => {
    //   block [0x821DE2D0..0x821DE2E4)
	// 821DE2D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DE2D4: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DE2D8: D0040014  stfs f0, 0x14(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821DE2DC: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821DE2E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DE2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DE2E8 size=320
    let mut pc: u32 = 0x821DE2E8;
    'dispatch: loop {
        match pc {
            0x821DE2E8 => {
    //   block [0x821DE2E8..0x821DE364)
	// 821DE2E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DE2EC: 48ACB115  bl 0x82ca9400
	ctx.lr = 0x821DE2F0;
	sub_82CA93D0(ctx, base);
	// 821DE2F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DE2F4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821DE2F8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821DE2FC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821DE300: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 821DE304: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE308: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DE30C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DE310: 4E800421  bctrl
	ctx.lr = 0x821DE314;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DE314: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DE318: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DE31C: 419A0080  beq cr6, 0x821de39c
	if ctx.cr[6].eq {
	pc = 0x821DE39C; continue 'dispatch;
	}
	// 821DE320: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821DE324: 579D2036  slwi r29, r28, 4
	ctx.r[29].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821DE328: 3BCBF850  addi r30, r11, -0x7b0
	ctx.r[30].s64 = ctx.r[11].s64 + -1968;
	// 821DE32C: 397E0010  addi r11, r30, 0x10
	ctx.r[11].s64 = ctx.r[30].s64 + 16;
	// 821DE330: 7FFD5A14  add r31, r29, r11
	ctx.r[31].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 821DE334: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DE338: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE33C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821DE340: 7D2B1671  srawi. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DE344: 40820020  bne 0x821de364
	if !ctx.cr[0].eq {
	pc = 0x821DE364; continue 'dispatch;
	}
	// 821DE348: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821DE34C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821DE350: 488B1399  bl 0x82a8f6e8
	ctx.lr = 0x821DE354;
	sub_82A8F6E8(ctx, base);
	// 821DE354: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DE358: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE35C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821DE360: 7D2B1670  srawi r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
            }
            0x821DE364 => {
    //   block [0x821DE364..0x821DE398)
	// 821DE364: 395E0014  addi r10, r30, 0x14
	ctx.r[10].s64 = ctx.r[30].s64 + 20;
	// 821DE368: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE36C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821DE370: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DE374: 7CE85850  subf r7, r8, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 821DE378: 7D5D502E  lwzx r10, r29, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821DE37C: 54E6003A  rlwinm r6, r7, 0, 0, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821DE380: 7CAA4A14  add r5, r10, r9
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821DE384: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821DE388: 8145FFFC  lwz r10, -4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821DE38C: 419A000C  beq cr6, 0x821de398
	if ctx.cr[6].eq {
	pc = 0x821DE398; continue 'dispatch;
	}
	// 821DE390: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 821DE394: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x821DE398; continue 'dispatch;
            }
            0x821DE398 => {
    //   block [0x821DE398..0x821DE39C)
	// 821DE398: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	pc = 0x821DE39C; continue 'dispatch;
            }
            0x821DE39C => {
    //   block [0x821DE39C..0x821DE3D4)
	// 821DE39C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821DE3A0: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821DE3A4: 392BF9B0  addi r9, r11, -0x650
	ctx.r[9].s64 = ctx.r[11].s64 + -1616;
	// 821DE3A8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821DE3AC: 7FEA482E  lwzx r31, r10, r9
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821DE3B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DE3B4: 4804C7C5  bl 0x8222ab78
	ctx.lr = 0x821DE3B8;
	sub_8222AB78(ctx, base);
	// 821DE3B8: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821DE3BC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821DE3C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DE3C4: 4804C81D  bl 0x8222abe0
	ctx.lr = 0x821DE3C8;
	sub_8222ABE0(ctx, base);
	// 821DE3C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821DE3CC: 419A0008  beq cr6, 0x821de3d4
	if ctx.cr[6].eq {
	pc = 0x821DE3D4; continue 'dispatch;
	}
	// 821DE3D0: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x821DE3D4; continue 'dispatch;
            }
            0x821DE3D4 => {
    //   block [0x821DE3D4..0x821DE3F0)
	// 821DE3D4: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821DE3D8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821DE3DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DE3E0: 4804C801  bl 0x8222abe0
	ctx.lr = 0x821DE3E4;
	sub_8222ABE0(ctx, base);
	// 821DE3E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821DE3E8: 419A0008  beq cr6, 0x821de3f0
	if ctx.cr[6].eq {
	pc = 0x821DE3F0; continue 'dispatch;
	}
	// 821DE3EC: 93430000  stw r26, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x821DE3F0; continue 'dispatch;
            }
            0x821DE3F0 => {
    //   block [0x821DE3F0..0x821DE428)
	// 821DE3F0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE3F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DE3F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821DE3FC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DE400: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DE404: 4E800421  bctrl
	ctx.lr = 0x821DE408;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DE408: 813F002C  lwz r9, 0x2c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821DE40C: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DE410: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821DE414: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821DE418: 80FF0020  lwz r7, 0x20(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DE41C: 90FF0028  stw r7, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[7].u32 ) };
	// 821DE420: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821DE424: 48ACB02C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DE428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DE428 size=76
    let mut pc: u32 = 0x821DE428;
    'dispatch: loop {
        match pc {
            0x821DE428 => {
    //   block [0x821DE428..0x821DE474)
	// 821DE428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DE42C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DE430: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DE434: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DE438: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 821DE43C: 48040065  bl 0x8221e4a0
	ctx.lr = 0x821DE440;
	sub_8221E4A0(ctx, base);
	// 821DE440: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 821DE444: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821DE448: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821DE44C: 7CFF5A14  add r7, r31, r11
	ctx.r[7].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 821DE450: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821DE454: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821DE458: 806A0364  lwz r3, 0x364(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(868 as u32) ) } as u64;
	// 821DE45C: 4803FB65  bl 0x8221dfc0
	ctx.lr = 0x821DE460;
	sub_8221DFC0(ctx, base);
	// 821DE460: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821DE464: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DE468: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DE46C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821DE470: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DE478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DE478 size=440
    let mut pc: u32 = 0x821DE478;
    'dispatch: loop {
        match pc {
            0x821DE478 => {
    //   block [0x821DE478..0x821DE4D8)
	// 821DE478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DE47C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DE480: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DE484: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821DE488: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821DE48C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DE490: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821DE494: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE498: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE49C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 821DE4A0: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 821DE4A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE4A8: 419A0084  beq cr6, 0x821de52c
	if ctx.cr[6].eq {
	pc = 0x821DE52C; continue 'dispatch;
	}
	// 821DE4AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE4B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DE4B4: 419A0074  beq cr6, 0x821de528
	if ctx.cr[6].eq {
	pc = 0x821DE528; continue 'dispatch;
	}
	// 821DE4B8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821DE4BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE4C0: 419A0018  beq cr6, 0x821de4d8
	if ctx.cr[6].eq {
	pc = 0x821DE4D8; continue 'dispatch;
	}
	// 821DE4C4: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821DE4C8: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821DE4CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821DE4D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DE4D4: 409A0008  bne cr6, 0x821de4dc
	if !ctx.cr[6].eq {
	pc = 0x821DE4DC; continue 'dispatch;
	}
	pc = 0x821DE4D8; continue 'dispatch;
            }
            0x821DE4D8 => {
    //   block [0x821DE4D8..0x821DE4DC)
	// 821DE4D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821DE4DC; continue 'dispatch;
            }
            0x821DE4DC => {
    //   block [0x821DE4DC..0x821DE528)
	// 821DE4DC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821DE4E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DE4E4: 419A0138  beq cr6, 0x821de61c
	if ctx.cr[6].eq {
	pc = 0x821DE61C; continue 'dispatch;
	}
	// 821DE4E8: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821DE4EC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821DE4F0: 5528FFFE  rlwinm r8, r9, 0x1f, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 821DE4F4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821DE4F8: 419A0104  beq cr6, 0x821de5fc
	if ctx.cr[6].eq {
	pc = 0x821DE5FC; continue 'dispatch;
	}
	// 821DE4FC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821DE500: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DE504: 419A0030  beq cr6, 0x821de534
	if ctx.cr[6].eq {
	pc = 0x821DE534; continue 'dispatch;
	}
	// 821DE508: 894A0021  lbz r10, 0x21(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 821DE50C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DE510: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821DE514: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821DE518: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE51C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821DE520: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DE524: 480000DC  b 0x821de600
	pc = 0x821DE600; continue 'dispatch;
            }
            0x821DE528 => {
    //   block [0x821DE528..0x821DE52C)
	// 821DE528: 4BFB5911  bl 0x82193e38
	ctx.lr = 0x821DE52C;
	sub_82193E38(ctx, base);
	pc = 0x821DE52C; continue 'dispatch;
            }
            0x821DE52C => {
    //   block [0x821DE52C..0x821DE534)
	// 821DE52C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821DE530: 4BFFFFA8  b 0x821de4d8
	pc = 0x821DE4D8; continue 'dispatch;
            }
            0x821DE534 => {
    //   block [0x821DE534..0x821DE554)
	// 821DE534: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DE538: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821DE53C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821DE540: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821DE544: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821DE548: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821DE54C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DE550: 40810054  ble 0x821de5a4
	if !ctx.cr[0].gt {
	pc = 0x821DE5A4; continue 'dispatch;
	}
	pc = 0x821DE554; continue 'dispatch;
            }
            0x821DE554 => {
    //   block [0x821DE554..0x821DE574)
	// 821DE554: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821DE558: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821DE55C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821DE560: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE564: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 821DE568: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821DE56C: 41980008  blt cr6, 0x821de574
	if ctx.cr[6].lt {
	pc = 0x821DE574; continue 'dispatch;
	}
	// 821DE570: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821DE574; continue 'dispatch;
            }
            0x821DE574 => {
    //   block [0x821DE574..0x821DE590)
	// 821DE574: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821DE578: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821DE57C: 419A0014  beq cr6, 0x821de590
	if ctx.cr[6].eq {
	pc = 0x821DE590; continue 'dispatch;
	}
	// 821DE580: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821DE584: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821DE588: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821DE58C: 4800000C  b 0x821de598
	pc = 0x821DE598; continue 'dispatch;
            }
            0x821DE590 => {
    //   block [0x821DE590..0x821DE598)
	// 821DE590: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821DE594: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821DE598; continue 'dispatch;
            }
            0x821DE598 => {
    //   block [0x821DE598..0x821DE5A4)
	// 821DE598: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821DE59C: 4199FFB8  bgt cr6, 0x821de554
	if ctx.cr[6].gt {
	pc = 0x821DE554; continue 'dispatch;
	}
	// 821DE5A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821DE5A4; continue 'dispatch;
            }
            0x821DE5A4 => {
    //   block [0x821DE5A4..0x821DE5C0)
	// 821DE5A4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821DE5A8: 419A0040  beq cr6, 0x821de5e8
	if ctx.cr[6].eq {
	pc = 0x821DE5E8; continue 'dispatch;
	}
	// 821DE5AC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE5B0: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 821DE5B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DE5B8: 41990008  bgt cr6, 0x821de5c0
	if ctx.cr[6].gt {
	pc = 0x821DE5C0; continue 'dispatch;
	}
	// 821DE5BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821DE5C0; continue 'dispatch;
            }
            0x821DE5C0 => {
    //   block [0x821DE5C0..0x821DE5E8)
	// 821DE5C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DE5C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE5C8: 409A0020  bne cr6, 0x821de5e8
	if !ctx.cr[6].eq {
	pc = 0x821DE5E8; continue 'dispatch;
	}
	// 821DE5CC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DE5D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821DE5D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821DE5D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE5DC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821DE5E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DE5E4: 4800001C  b 0x821de600
	pc = 0x821DE600; continue 'dispatch;
            }
            0x821DE5E8 => {
    //   block [0x821DE5E8..0x821DE5FC)
	// 821DE5E8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821DE5EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE5F0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821DE5F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DE5F8: 48000008  b 0x821de600
	pc = 0x821DE600; continue 'dispatch;
            }
            0x821DE5FC => {
    //   block [0x821DE5FC..0x821DE600)
	// 821DE5FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821DE600; continue 'dispatch;
            }
            0x821DE600 => {
    //   block [0x821DE600..0x821DE61C)
	// 821DE600: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DE604: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE608: 419A0014  beq cr6, 0x821de61c
	if ctx.cr[6].eq {
	pc = 0x821DE61C; continue 'dispatch;
	}
	// 821DE60C: 896A008C  lbz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 821DE610: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821DE614: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE618: 409A0008  bne cr6, 0x821de620
	if !ctx.cr[6].eq {
	pc = 0x821DE620; continue 'dispatch;
	}
	pc = 0x821DE61C; continue 'dispatch;
            }
            0x821DE61C => {
    //   block [0x821DE61C..0x821DE620)
	// 821DE61C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821DE620; continue 'dispatch;
            }
            0x821DE620 => {
    //   block [0x821DE620..0x821DE630)
	// 821DE620: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821DE624: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DE628: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DE62C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DE630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DE630 size=416
    let mut pc: u32 = 0x821DE630;
    'dispatch: loop {
        match pc {
            0x821DE630 => {
    //   block [0x821DE630..0x821DE65C)
	// 821DE630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DE634: 48ACADC5  bl 0x82ca93f8
	ctx.lr = 0x821DE638;
	sub_82CA93D0(ctx, base);
	// 821DE638: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DE63C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821DE640: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821DE644: 3B6B4FF8  addi r27, r11, 0x4ff8
	ctx.r[27].s64 = ctx.r[11].s64 + 20472;
	// 821DE648: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE64C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DE650: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DE654: 40990008  ble cr6, 0x821de65c
	if !ctx.cr[6].gt {
	pc = 0x821DE65C; continue 'dispatch;
	}
	// 821DE658: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DE65C; continue 'dispatch;
            }
            0x821DE65C => {
    //   block [0x821DE65C..0x821DE66C)
	// 821DE65C: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 821DE660: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DE664: 40990008  ble cr6, 0x821de66c
	if !ctx.cr[6].gt {
	pc = 0x821DE66C; continue 'dispatch;
	}
	// 821DE668: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DE66C; continue 'dispatch;
            }
            0x821DE66C => {
    //   block [0x821DE66C..0x821DE674)
	// 821DE66C: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 821DE670: 3F208336  lis r25, -0x7cca
	ctx.r[25].s64 = -2093613056;
	pc = 0x821DE674; continue 'dispatch;
            }
            0x821DE674 => {
    //   block [0x821DE674..0x821DE694)
	// 821DE674: 7F1CC040  cmplw cr6, r28, r24
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[24].u32, &mut ctx.xer);
	// 821DE678: 419A0150  beq cr6, 0x821de7c8
	if ctx.cr[6].eq {
	pc = 0x821DE7C8; continue 'dispatch;
	}
	// 821DE67C: 815A06FC  lwz r10, 0x6fc(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821DE680: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821DE684: 409A00A4  bne cr6, 0x821de728
	if !ctx.cr[6].eq {
	pc = 0x821DE728; continue 'dispatch;
	}
	// 821DE688: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DE68C: 41980008  blt cr6, 0x821de694
	if ctx.cr[6].lt {
	pc = 0x821DE694; continue 'dispatch;
	}
	// 821DE690: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DE694; continue 'dispatch;
            }
            0x821DE694 => {
    //   block [0x821DE694..0x821DE700)
	// 821DE694: 83DC0000  lwz r30, 0(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE698: 8159F94C  lwz r10, -0x6b4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-1716 as u32) ) } as u64;
	// 821DE69C: 3BFE00D4  addi r31, r30, 0xd4
	ctx.r[31].s64 = ctx.r[30].s64 + 212;
	// 821DE6A0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821DE6A4: 813E00DC  lwz r9, 0xdc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(220 as u32) ) } as u64;
	// 821DE6A8: 7D480034  cntlzw r8, r10
	ctx.r[8].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 821DE6AC: 80FE00D8  lwz r7, 0xd8(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(216 as u32) ) } as u64;
	// 821DE6B0: 551DDFFE  rlwinm r29, r8, 0x1b, 0x1f, 0x1f
	ctx.r[29].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 821DE6B4: 7CC74850  subf r6, r7, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 821DE6B8: 54C5003A  rlwinm r5, r6, 0, 0, 0x1d
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 821DE6BC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821DE6C0: 419A00F4  beq cr6, 0x821de7b4
	if ctx.cr[6].eq {
	pc = 0x821DE7B4; continue 'dispatch;
	}
	// 821DE6C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821DE6C8: 48952B79  bl 0x82b31240
	ctx.lr = 0x821DE6CC;
	sub_82B31240(ctx, base);
	// 821DE6CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DE6D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE6D4: 419A00DC  beq cr6, 0x821de7b0
	if ctx.cr[6].eq {
	pc = 0x821DE7B0; continue 'dispatch;
	}
	// 821DE6D8: 817E00C8  lwz r11, 0xc8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 821DE6DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE6E0: 419A0020  beq cr6, 0x821de700
	if ctx.cr[6].eq {
	pc = 0x821DE700; continue 'dispatch;
	}
	// 821DE6E4: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821DE6E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE6EC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE6F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DE6F4: 4E800421  bctrl
	ctx.lr = 0x821DE6F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DE6F8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 821DE6FC: 48000008  b 0x821de704
	pc = 0x821DE704; continue 'dispatch;
            }
            0x821DE700 => {
    //   block [0x821DE700..0x821DE704)
	// 821DE700: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	pc = 0x821DE704; continue 'dispatch;
            }
            0x821DE704 => {
    //   block [0x821DE704..0x821DE728)
	// 821DE704: 807E00CC  lwz r3, 0xcc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(204 as u32) ) } as u64;
	// 821DE708: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821DE70C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821DE710: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821DE714: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE718: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DE71C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DE720: 4E800421  bctrl
	ctx.lr = 0x821DE724;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DE724: 4800008C  b 0x821de7b0
	pc = 0x821DE7B0; continue 'dispatch;
            }
            0x821DE728 => {
    //   block [0x821DE728..0x821DE734)
	// 821DE728: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DE72C: 41980008  blt cr6, 0x821de734
	if ctx.cr[6].lt {
	pc = 0x821DE734; continue 'dispatch;
	}
	// 821DE730: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DE734; continue 'dispatch;
            }
            0x821DE734 => {
    //   block [0x821DE734..0x821DE790)
	// 821DE734: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE738: 3BDF00D4  addi r30, r31, 0xd4
	ctx.r[30].s64 = ctx.r[31].s64 + 212;
	// 821DE73C: 815F00DC  lwz r10, 0xdc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 821DE740: 813F00D8  lwz r9, 0xd8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(216 as u32) ) } as u64;
	// 821DE744: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821DE748: 5507003A  rlwinm r7, r8, 0, 0, 0x1d
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821DE74C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821DE750: 419A0064  beq cr6, 0x821de7b4
	if ctx.cr[6].eq {
	pc = 0x821DE7B4; continue 'dispatch;
	}
	// 821DE754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DE758: 48952AE9  bl 0x82b31240
	ctx.lr = 0x821DE75C;
	sub_82B31240(ctx, base);
	// 821DE75C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DE760: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE764: 419A004C  beq cr6, 0x821de7b0
	if ctx.cr[6].eq {
	pc = 0x821DE7B0; continue 'dispatch;
	}
	// 821DE768: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 821DE76C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE770: 419A0020  beq cr6, 0x821de790
	if ctx.cr[6].eq {
	pc = 0x821DE790; continue 'dispatch;
	}
	// 821DE774: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821DE778: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE77C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE780: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DE784: 4E800421  bctrl
	ctx.lr = 0x821DE788;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DE788: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 821DE78C: 48000008  b 0x821de794
	pc = 0x821DE794; continue 'dispatch;
            }
            0x821DE790 => {
    //   block [0x821DE790..0x821DE794)
	// 821DE790: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	pc = 0x821DE794; continue 'dispatch;
            }
            0x821DE794 => {
    //   block [0x821DE794..0x821DE7B0)
	// 821DE794: 807F00CC  lwz r3, 0xcc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 821DE798: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821DE79C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821DE7A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE7A4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DE7A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DE7AC: 4E800421  bctrl
	ctx.lr = 0x821DE7B0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821DE7B0 => {
    //   block [0x821DE7B0..0x821DE7B4)
	// 821DE7B0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x821DE7B4; continue 'dispatch;
            }
            0x821DE7B4 => {
    //   block [0x821DE7B4..0x821DE7C0)
	// 821DE7B4: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DE7B8: 41980008  blt cr6, 0x821de7c0
	if ctx.cr[6].lt {
	pc = 0x821DE7C0; continue 'dispatch;
	}
	// 821DE7BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DE7C0; continue 'dispatch;
            }
            0x821DE7C0 => {
    //   block [0x821DE7C0..0x821DE7C8)
	// 821DE7C0: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 821DE7C4: 4BFFFEB0  b 0x821de674
	pc = 0x821DE674; continue 'dispatch;
            }
            0x821DE7C8 => {
    //   block [0x821DE7C8..0x821DE7D0)
	// 821DE7C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821DE7CC: 48ACAC7C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DE7D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DE7D0 size=324
    let mut pc: u32 = 0x821DE7D0;
    'dispatch: loop {
        match pc {
            0x821DE7D0 => {
    //   block [0x821DE7D0..0x821DE810)
	// 821DE7D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DE7D4: 48ACAC35  bl 0x82ca9408
	ctx.lr = 0x821DE7D8;
	sub_82CA93D0(ctx, base);
	// 821DE7D8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821DE7DC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DE7E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DE7E4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821DE7E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821DE7EC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821DE7F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821DE7F4: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821DE7F8: 419A0018  beq cr6, 0x821de810
	if ctx.cr[6].eq {
	pc = 0x821DE810; continue 'dispatch;
	}
	// 821DE7FC: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 821DE800: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821DE804: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DE808: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DE80C: 409A0008  bne cr6, 0x821de814
	if !ctx.cr[6].eq {
	pc = 0x821DE814; continue 'dispatch;
	}
	pc = 0x821DE810; continue 'dispatch;
            }
            0x821DE810 => {
    //   block [0x821DE810..0x821DE814)
	// 821DE810: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821DE814; continue 'dispatch;
            }
            0x821DE814 => {
    //   block [0x821DE814..0x821DE830)
	// 821DE814: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DE818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE81C: 419A00E8  beq cr6, 0x821de904
	if ctx.cr[6].eq {
	pc = 0x821DE904; continue 'dispatch;
	}
	// 821DE820: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE824: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DE828: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DE82C: 419A00D8  beq cr6, 0x821de904
	if ctx.cr[6].eq {
	pc = 0x821DE904; continue 'dispatch;
	}
	pc = 0x821DE830; continue 'dispatch;
            }
            0x821DE830 => {
    //   block [0x821DE830..0x821DE85C)
	// 821DE830: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE834: 7F03E040  cmplw cr6, r3, r28
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821DE838: 419A00CC  beq cr6, 0x821de904
	if ctx.cr[6].eq {
	pc = 0x821DE904; continue 'dispatch;
	}
	// 821DE83C: 4877A335  bl 0x82958b70
	ctx.lr = 0x821DE840;
	sub_82958B70(ctx, base);
	// 821DE840: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821DE844: 419A0018  beq cr6, 0x821de85c
	if ctx.cr[6].eq {
	pc = 0x821DE85C; continue 'dispatch;
	}
	// 821DE848: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821DE84C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821DE850: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DE854: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DE858: 409A0008  bne cr6, 0x821de860
	if !ctx.cr[6].eq {
	pc = 0x821DE860; continue 'dispatch;
	}
	pc = 0x821DE85C; continue 'dispatch;
            }
            0x821DE85C => {
    //   block [0x821DE85C..0x821DE860)
	// 821DE85C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821DE860; continue 'dispatch;
            }
            0x821DE860 => {
    //   block [0x821DE860..0x821DE89C)
	// 821DE860: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DE864: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE868: 419A008C  beq cr6, 0x821de8f4
	if ctx.cr[6].eq {
	pc = 0x821DE8F4; continue 'dispatch;
	}
	// 821DE86C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE870: 4877A301  bl 0x82958b70
	ctx.lr = 0x821DE874;
	sub_82958B70(ctx, base);
	// 821DE874: 39630014  addi r11, r3, 0x14
	ctx.r[11].s64 = ctx.r[3].s64 + 20;
	// 821DE878: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DE87C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE880: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DE884: 409A0018  bne cr6, 0x821de89c
	if !ctx.cr[6].eq {
	pc = 0x821DE89C; continue 'dispatch;
	}
	// 821DE888: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DE88C: 815E0018  lwz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 821DE890: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821DE894: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DE898: 419A0008  beq cr6, 0x821de8a0
	if ctx.cr[6].eq {
	pc = 0x821DE8A0; continue 'dispatch;
	}
	pc = 0x821DE89C; continue 'dispatch;
            }
            0x821DE89C => {
    //   block [0x821DE89C..0x821DE8A0)
	// 821DE89C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821DE8A0; continue 'dispatch;
            }
            0x821DE8A0 => {
    //   block [0x821DE8A0..0x821DE8F4)
	// 821DE8A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DE8A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE8A8: 419A004C  beq cr6, 0x821de8f4
	if ctx.cr[6].eq {
	pc = 0x821DE8F4; continue 'dispatch;
	}
	// 821DE8AC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE8B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821DE8B4: 808A0014  lwz r4, 0x14(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DE8B8: 481FF641  bl 0x823ddef8
	ctx.lr = 0x821DE8BC;
	sub_823DDEF8(ctx, base);
	// 821DE8BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DE8C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DE8C4: 419A0030  beq cr6, 0x821de8f4
	if ctx.cr[6].eq {
	pc = 0x821DE8F4; continue 'dispatch;
	}
	// 821DE8C8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DE8CC: 7D445378  mr r4, r10
	ctx.r[4].u64 = ctx.r[10].u64;
	// 821DE8D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821DE8D4: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821DE8D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DE8DC: 4E800421  bctrl
	ctx.lr = 0x821DE8E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DE8E0: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DE8E4: C1A30010  lfs f13, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DE8E8: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821DE8EC: FD606210  fabs f11, f12
	ctx.f[11].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 821DE8F0: EFEBF82A  fadds f31, f11, f31
	ctx.f[31].f64 = ((ctx.f[11].f64 + ctx.f[31].f64) as f32) as f64;
            }
            0x821DE8F4 => {
    //   block [0x821DE8F4..0x821DE904)
	// 821DE8F4: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DE8F8: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 821DE8FC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DE900: 409AFF30  bne cr6, 0x821de830
	if !ctx.cr[6].eq {
	pc = 0x821DE830; continue 'dispatch;
	}
	pc = 0x821DE904; continue 'dispatch;
            }
            0x821DE904 => {
    //   block [0x821DE904..0x821DE914)
	// 821DE904: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821DE908: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821DE90C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821DE910: 48ACAB48  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DE918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DE918 size=560
    let mut pc: u32 = 0x821DE918;
    'dispatch: loop {
        match pc {
            0x821DE918 => {
    //   block [0x821DE918..0x821DEB48)
	// 821DE918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DE91C: 48ACAAE5  bl 0x82ca9400
	ctx.lr = 0x821DE920;
	sub_82CA93D0(ctx, base);
	// 821DE920: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DEB48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DEB48 size=600
    let mut pc: u32 = 0x821DEB48;
    'dispatch: loop {
        match pc {
            0x821DEB48 => {
    //   block [0x821DEB48..0x821DED74)
	// 821DEB48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DEB4C: 48ACA8B9  bl 0x82ca9404
	ctx.lr = 0x821DEB50;
	sub_82CA93D0(ctx, base);
	// 821DEB50: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DEB54: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821DEB58: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821DEB5C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821DEB60: 556A06F6  rlwinm r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821DEB64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821DEB68: 419A020C  beq cr6, 0x821ded74
	if ctx.cr[6].eq {
	pc = 0x821DED74; continue 'dispatch;
	}
	// 821DEB6C: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 821DEB70: 807D6AB8  lwz r3, 0x6ab8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821DEB74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DEB78: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DEB7C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DEB80: 4E800421  bctrl
	ctx.lr = 0x821DEB84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DEB84: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821DEB88: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821DEB8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DEB90: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821DEB94: 81696B08  lwz r11, 0x6b08(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821DEB98: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DEB9C: 3BCA0020  addi r30, r10, 0x20
	ctx.r[30].s64 = ctx.r[10].s64 + 32;
	// 821DEBA0: 80EB0020  lwz r7, 0x20(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DEBA4: 80C7001C  lwz r6, 0x1c(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DEBA8: 8386004C  lwz r28, 0x4c(r6)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 821DEBAC: 480001F5  bl 0x821deda0
	ctx.lr = 0x821DEBB0;
	sub_821DEDA0(ctx, base);
	// 821DEBB0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821DEBB4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821DEBB8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
            }
            0x821DED74 => {
    //   block [0x821DED74..0x821DEDA0)
	// 821DED74: C01F00B4  lfs f0, 0xb4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DED78: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821DED7C: C1BF00B8  lfs f13, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DED80: C19F00BC  lfs f12, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821DED84: C17F00C0  lfs f11, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821DED88: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821DED8C: D1BB0004  stfs f13, 4(r27)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821DED90: D19B0008  stfs f12, 8(r27)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821DED94: D17B000C  stfs f11, 0xc(r27)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821DED98: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821DED9C: 48ACA6B8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DEDA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DEDA0 size=868
    let mut pc: u32 = 0x821DEDA0;
    'dispatch: loop {
        match pc {
            0x821DEDA0 => {
    //   block [0x821DEDA0..0x821DF104)
	// 821DEDA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DEDA4: 48ACA65D  bl 0x82ca9400
	ctx.lr = 0x821DEDA8;
	sub_82CA93D0(ctx, base);
	// 821DEDA8: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DF108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DF108 size=308
    let mut pc: u32 = 0x821DF108;
    'dispatch: loop {
        match pc {
            0x821DF108 => {
    //   block [0x821DF108..0x821DF23C)
	// 821DF108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DF10C: 48ACA2FD  bl 0x82ca9408
	ctx.lr = 0x821DF110;
	sub_82CA93D0(ctx, base);
	// 821DF110: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DF114: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821DF118: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821DF11C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821DF120: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821DF124: 817F6B08  lwz r11, 0x6b08(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27400 as u32) ) } as u64;
	// 821DF128: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821DF12C: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821DF130: 838A004C  lwz r28, 0x4c(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) } as u64;
	// 821DF134: 4BFFFC6D  bl 0x821deda0
	ctx.lr = 0x821DF138;
	sub_821DEDA0(ctx, base);
	// 821DF138: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821DF13C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821DF140: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DF240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821DF240 size=536
    let mut pc: u32 = 0x821DF240;
    'dispatch: loop {
        match pc {
            0x821DF240 => {
    //   block [0x821DF240..0x821DF458)
	// 821DF240: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 821DF244: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821DF248: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 821DF24C: C1010024  lfs f8, 0x24(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821DF250: C0040098  lfs f0, 0x98(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(152 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DF254: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821DF258: C1A40090  lfs f13, 0x90(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DF25C: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 821DF260: FD406890  fmr f10, f13
	ctx.f[10].f64 = ctx.f[13].f64;
	// 821DF264: 392B92D4  addi r9, r11, -0x6d2c
	ctx.r[9].s64 = ctx.r[11].s64 + -27948;
	// 821DF268: ED60682A  fadds f11, f0, f13
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821DF26C: 3941FFD0  addi r10, r1, -0x30
	ctx.r[10].s64 = ctx.r[1].s64 + -48;
	// 821DF270: 38A1FFD0  addi r5, r1, -0x30
	ctx.r[5].s64 = ctx.r[1].s64 + -48;
	// 821DF274: C0E40094  lfs f7, 0x94(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(148 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821DF278: C00B92D4  lfs f0, -0x6d2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821DF27C: FC403890  fmr f2, f7
	ctx.f[2].f64 = ctx.f[7].f64;
	// 821DF280: C0C4008C  lfs f6, 0x8c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821DF284: 3901FFD4  addi r8, r1, -0x2c
	ctx.r[8].s64 = ctx.r[1].s64 + -44;
	// 821DF288: C1A901B0  lfs f13, 0x1b0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(432 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821DF28C: ECA7302A  fadds f5, f7, f6
	ctx.f[5].f64 = ((ctx.f[7].f64 + ctx.f[6].f64) as f32) as f64;
	// 821DF290: D1A1FFD0  stfs f13, -0x30(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), tmp.u32 ) };
	// 821DF294: 38C1FFD4  addi r6, r1, -0x2c
	ctx.r[6].s64 = ctx.r[1].s64 + -44;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DF458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DF458 size=200
    let mut pc: u32 = 0x821DF458;
    'dispatch: loop {
        match pc {
            0x821DF458 => {
    //   block [0x821DF458..0x821DF4F8)
	// 821DF458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DF45C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DF460: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821DF464: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DF468: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821DF46C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DF470: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DF474: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821DF478: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821DF47C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821DF480: 419A0080  beq cr6, 0x821df500
	if ctx.cr[6].eq {
	pc = 0x821DF500; continue 'dispatch;
	}
	// 821DF484: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DF488: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 821DF48C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DF490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DF494: 48049C75  bl 0x82229108
	ctx.lr = 0x821DF498;
	sub_82229108(ctx, base);
	// 821DF498: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821DF49C: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 821DF4A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DF4A4: 48048EE5  bl 0x82228388
	ctx.lr = 0x821DF4A8;
	sub_82228388(ctx, base);
	// 821DF4A8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DF4AC: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821DF4B0: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 821DF4B4: 39099700  addi r8, r9, -0x6900
	ctx.r[8].s64 = ctx.r[9].s64 + -26880;
	// 821DF4B8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821DF4BC: 419A003C  beq cr6, 0x821df4f8
	if ctx.cr[6].eq {
	pc = 0x821DF4F8; continue 'dispatch;
	}
	// 821DF4C0: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DF4C4: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 821DF4C8: 409A0030  bne cr6, 0x821df4f8
	if !ctx.cr[6].eq {
	pc = 0x821DF4F8; continue 'dispatch;
	}
	// 821DF4CC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821DF4D0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821DF4D4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821DF4D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DF4DC: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 821DF4E0: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821DF4E4: 48122A15  bl 0x82301ef8
	ctx.lr = 0x821DF4E8;
	sub_82301EF8(ctx, base);
	// 821DF4E8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DF4EC: 392BFFF0  addi r9, r11, -0x10
	ctx.r[9].s64 = ctx.r[11].s64 + -16;
	// 821DF4F0: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821DF4F4: 48000010  b 0x821df504
	pc = 0x821DF504; continue 'dispatch;
            }
            0x821DF4F8 => {
    //   block [0x821DF4F8..0x821DF500)
	// 821DF4F8: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 821DF4FC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x821DF500; continue 'dispatch;
            }
            0x821DF500 => {
    //   block [0x821DF500..0x821DF504)
	// 821DF500: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	pc = 0x821DF504; continue 'dispatch;
            }
            0x821DF504 => {
    //   block [0x821DF504..0x821DF520)
	// 821DF504: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821DF508: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DF50C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DF510: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821DF514: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821DF518: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821DF51C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DF520(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DF520 size=172
    let mut pc: u32 = 0x821DF520;
    'dispatch: loop {
        match pc {
            0x821DF520 => {
    //   block [0x821DF520..0x821DF5CC)
	// 821DF520: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DF524: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DF528: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DF52C: 10410C84  vmr v2, v1
	ctx.v[2] = ctx.v[1];
	// 821DF530: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821DF534: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DF5D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DF5D0 size=20
    let mut pc: u32 = 0x821DF5D0;
    'dispatch: loop {
        match pc {
            0x821DF5D0 => {
    //   block [0x821DF5D0..0x821DF5E4)
	// 821DF5D0: 80630014  lwz r3, 0x14(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DF5D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DF5D8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821DF5DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821DF5E0: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DF5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821DF5E8 size=132
    let mut pc: u32 = 0x821DF5E8;
    'dispatch: loop {
        match pc {
            0x821DF5E8 => {
    //   block [0x821DF5E8..0x821DF62C)
	// 821DF5E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DF5EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821DF5F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821DF5F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821DF5F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DF5FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821DF600: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821DF604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DF608: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DF60C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DF610: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DF614: 4E800421  bctrl
	ctx.lr = 0x821DF618;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DF618: 2F030008  cmpwi cr6, r3, 8
	ctx.cr[6].compare_i32(ctx.r[3].s32, 8, &mut ctx.xer);
	// 821DF61C: 409A0010  bne cr6, 0x821df62c
	if !ctx.cr[6].eq {
	pc = 0x821DF62C; continue 'dispatch;
	}
	// 821DF620: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821DF624: 48694215  bl 0x82873838
	ctx.lr = 0x821DF628;
	sub_82873838(ctx, base);
	// 821DF628: 4800002C  b 0x821df654
	pc = 0x821DF654; continue 'dispatch;
            }
            0x821DF62C => {
    //   block [0x821DF62C..0x821DF654)
	// 821DF62C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DF630: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821DF634: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DF638: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DF63C: 4E800421  bctrl
	ctx.lr = 0x821DF640;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DF640: 2F030009  cmpwi cr6, r3, 9
	ctx.cr[6].compare_i32(ctx.r[3].s32, 9, &mut ctx.xer);
	// 821DF644: 409A0010  bne cr6, 0x821df654
	if !ctx.cr[6].eq {
	pc = 0x821DF654; continue 'dispatch;
	}
	// 821DF648: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DF64C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821DF650: 48694091  bl 0x828736e0
	ctx.lr = 0x821DF654;
	sub_828736E0(ctx, base);
            }
            0x821DF654 => {
    //   block [0x821DF654..0x821DF66C)
	// 821DF654: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821DF658: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821DF65C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821DF660: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821DF664: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821DF668: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DF670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821DF670 size=1884
    let mut pc: u32 = 0x821DF670;
    'dispatch: loop {
        match pc {
            0x821DF670 => {
    //   block [0x821DF670..0x821DFDCC)
	// 821DF670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DF674: 48AC9D85  bl 0x82ca93f8
	ctx.lr = 0x821DF678;
	sub_82CA93D0(ctx, base);
	// 821DF678: 3981FFB8  addi r12, r1, -0x48
	ctx.r[12].s64 = ctx.r[1].s64 + -72;
	// 821DF67C: 48ACE64D  bl 0x82cadcc8
	ctx.lr = 0x821DF680;
	sub_82CADCA0(ctx, base);
	// 821DF680: 3980FF50  li r12, -0xb0
	ctx.r[12].s64 = -176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821DFDD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821DFDD0 size=1100
    let mut pc: u32 = 0x821DFDD0;
    'dispatch: loop {
        match pc {
            0x821DFDD0 => {
    //   block [0x821DFDD0..0x821DFE1C)
	// 821DFDD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821DFDD4: 48AC9629  bl 0x82ca93fc
	ctx.lr = 0x821DFDD8;
	sub_82CA93D0(ctx, base);
	// 821DFDD8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821DFDDC: E981F000  ld r12, -0x1000(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-4096 as u32) ) };
	// 821DFDE0: 9421EE90  stwu r1, -0x1170(r1)
	ea = ctx.r[1].u32.wrapping_add(-4464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821DFDE4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821DFDE8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821DFDEC: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 821DFDF0: 807A0018  lwz r3, 0x18(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 821DFDF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821DFDF8: 419A0024  beq cr6, 0x821dfe1c
	if ctx.cr[6].eq {
	pc = 0x821DFE1C; continue 'dispatch;
	}
	// 821DFDFC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DFE00: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DFE04: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DFE08: 4E800421  bctrl
	ctx.lr = 0x821DFE0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DFE0C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821DFE10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821DFE14: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821DFE18: 409A0008  bne cr6, 0x821dfe20
	if !ctx.cr[6].eq {
	pc = 0x821DFE20; continue 'dispatch;
	}
            }
            0x821DFE1C => {
    //   block [0x821DFE1C..0x821DFE20)
	// 821DFE1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821DFE20; continue 'dispatch;
            }
            0x821DFE20 => {
    //   block [0x821DFE20..0x821DFE4C)
	// 821DFE20: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821DFE24: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821DFE28: 419A00A8  beq cr6, 0x821dfed0
	if ctx.cr[6].eq {
	pc = 0x821DFED0; continue 'dispatch;
	}
	// 821DFE2C: 807A003C  lwz r3, 0x3c(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(60 as u32) ) } as u64;
	// 821DFE30: 4BFE9071  bl 0x821c8ea0
	ctx.lr = 0x821DFE34;
	sub_821C8EA0(ctx, base);
	// 821DFE34: 817A0040  lwz r11, 0x40(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(64 as u32) ) } as u64;
	// 821DFE38: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DFE3C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DFE40: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DFE44: 40990008  ble cr6, 0x821dfe4c
	if !ctx.cr[6].gt {
	pc = 0x821DFE4C; continue 'dispatch;
	}
	// 821DFE48: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DFE4C; continue 'dispatch;
            }
            0x821DFE4C => {
    //   block [0x821DFE4C..0x821DFE50)
	// 821DFE4C: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	pc = 0x821DFE50; continue 'dispatch;
            }
            0x821DFE50 => {
    //   block [0x821DFE50..0x821DFE5C)
	// 821DFE50: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DFE54: 40990008  ble cr6, 0x821dfe5c
	if !ctx.cr[6].gt {
	pc = 0x821DFE5C; continue 'dispatch;
	}
	// 821DFE58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DFE5C; continue 'dispatch;
            }
            0x821DFE5C => {
    //   block [0x821DFE5C..0x821DFE70)
	// 821DFE5C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DFE60: 419A0018  beq cr6, 0x821dfe78
	if ctx.cr[6].eq {
	pc = 0x821DFE78; continue 'dispatch;
	}
	// 821DFE64: 4198000C  blt cr6, 0x821dfe70
	if ctx.cr[6].lt {
	pc = 0x821DFE70; continue 'dispatch;
	}
	// 821DFE68: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 821DFE6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DFE70; continue 'dispatch;
            }
            0x821DFE70 => {
    //   block [0x821DFE70..0x821DFE78)
	// 821DFE70: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821DFE74: 4BFFFFDC  b 0x821dfe50
	pc = 0x821DFE50; continue 'dispatch;
            }
            0x821DFE78 => {
    //   block [0x821DFE78..0x821DFE84)
	// 821DFE78: 83DA0044  lwz r30, 0x44(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(68 as u32) ) } as u64;
	// 821DFE7C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DFE80: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821DFE84; continue 'dispatch;
            }
            0x821DFE84 => {
    //   block [0x821DFE84..0x821DFEA0)
	// 821DFE84: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DFE88: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DFE8C: 419A0044  beq cr6, 0x821dfed0
	if ctx.cr[6].eq {
	pc = 0x821DFED0; continue 'dispatch;
	}
	// 821DFE90: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821DFE94: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DFE98: 409A0008  bne cr6, 0x821dfea0
	if !ctx.cr[6].eq {
	pc = 0x821DFEA0; continue 'dispatch;
	}
	// 821DFE9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DFEA0; continue 'dispatch;
            }
            0x821DFEA0 => {
    //   block [0x821DFEA0..0x821DFEC8)
	// 821DFEA0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DFEA4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821DFEA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DFEAC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821DFEB0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821DFEB4: 4E800421  bctrl
	ctx.lr = 0x821DFEB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821DFEB8: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DFEBC: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821DFEC0: 409A0008  bne cr6, 0x821dfec8
	if !ctx.cr[6].eq {
	pc = 0x821DFEC8; continue 'dispatch;
	}
	// 821DFEC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x821DFEC8 => {
    //   block [0x821DFEC8..0x821DFED0)
	// 821DFEC8: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DFECC: 4BFFFFB8  b 0x821dfe84
	pc = 0x821DFE84; continue 'dispatch;
            }
            0x821DFED0 => {
    //   block [0x821DFED0..0x821DFF58)
	// 821DFED0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821DFED4: 480EA495  bl 0x822ca368
	ctx.lr = 0x821DFED8;
	sub_822CA368(ctx, base);
	// 821DFED8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821DFEDC: 419A007C  beq cr6, 0x821dff58
	if ctx.cr[6].eq {
	pc = 0x821DFF58; continue 'dispatch;
	}
	// 821DFEE0: 817A0050  lwz r11, 0x50(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(80 as u32) ) } as u64;
	// 821DFEE4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821DFEE8: 83F90000  lwz r31, 0(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DFEEC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821DFEF0: 3BCA16D8  addi r30, r10, 0x16d8
	ctx.r[30].s64 = ctx.r[10].s64 + 5848;
	// 821DFEF4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821DFEF8: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821DFEFC: 93E100A8  stw r31, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[31].u32 ) };
	// 821DFF00: 912100A4  stw r9, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[9].u32 ) };
	// 821DFF04: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 821DFF08: 48007721  bl 0x821e7628
	ctx.lr = 0x821DFF0C;
	sub_821E7628(ctx, base);
	// 821DFF0C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821DFF10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821DFF14: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 821DFF18: 4BFFE3D1  bl 0x821de2e8
	ctx.lr = 0x821DFF1C;
	sub_821DE2E8(ctx, base);
	// 821DFF1C: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 821DFF20: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821DFF24: 4805D015  bl 0x8223cf38
	ctx.lr = 0x821DFF28;
	sub_8223CF38(ctx, base);
	// 821DFF28: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821DFF2C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821DFF30: 807A0054  lwz r3, 0x54(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(84 as u32) ) } as u64;
	// 821DFF34: 38E86A70  addi r7, r8, 0x6a70
	ctx.r[7].s64 = ctx.r[8].s64 + 27248;
	// 821DFF38: 90E100A0  stw r7, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[7].u32 ) };
	// 821DFF3C: 480BB85D  bl 0x8229b798
	ctx.lr = 0x821DFF40;
	sub_8229B798(ctx, base);
	// 821DFF40: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821DFF44: 807A0058  lwz r3, 0x58(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(88 as u32) ) } as u64;
	// 821DFF48: 480E5BC9  bl 0x822c5b10
	ctx.lr = 0x821DFF4C;
	sub_822C5B10(ctx, base);
	// 821DFF4C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821DFF50: 807A005C  lwz r3, 0x5c(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(92 as u32) ) } as u64;
	// 821DFF54: 4BFFF71D  bl 0x821df670
	ctx.lr = 0x821DFF58;
	sub_821DF670(ctx, base);
	pc = 0x821DFF58; continue 'dispatch;
            }
            0x821DFF58 => {
    //   block [0x821DFF58..0x821DFF8C)
	// 821DFF58: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DFF5C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821DFF60: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DFF64: 4813D325  bl 0x8231d288
	ctx.lr = 0x821DFF68;
	sub_8231D288(ctx, base);
	// 821DFF68: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821DFF6C: 419A0020  beq cr6, 0x821dff8c
	if ctx.cr[6].eq {
	pc = 0x821DFF8C; continue 'dispatch;
	}
	// 821DFF70: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821DFF74: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DFF78: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821DFF7C: 480353C5  bl 0x82215340
	ctx.lr = 0x821DFF80;
	sub_82215340(ctx, base);
	// 821DFF80: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821DFF84: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821DFF88: 480D51C9  bl 0x822b5150
	ctx.lr = 0x821DFF8C;
	sub_822B5150(ctx, base);
	pc = 0x821DFF8C; continue 'dispatch;
            }
            0x821DFF8C => {
    //   block [0x821DFF8C..0x821DFFB4)
	// 821DFF8C: 817A00B8  lwz r11, 0xb8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(184 as u32) ) } as u64;
	// 821DFF90: 3B9A00B4  addi r28, r26, 0xb4
	ctx.r[28].s64 = ctx.r[26].s64 + 180;
	// 821DFF94: 83790000  lwz r27, 0(r25)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DFF98: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821DFF9C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821DFFA0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821DFFA4: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821DFFA8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821DFFAC: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821DFFB0: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821DFFB4; continue 'dispatch;
            }
            0x821DFFB4 => {
    //   block [0x821DFFB4..0x821DFFC8)
	// 821DFFB4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DFFB8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821DFFBC: 419A000C  beq cr6, 0x821dffc8
	if ctx.cr[6].eq {
	pc = 0x821DFFC8; continue 'dispatch;
	}
	// 821DFFC0: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821DFFC4: 419A0008  beq cr6, 0x821dffcc
	if ctx.cr[6].eq {
	pc = 0x821DFFCC; continue 'dispatch;
	}
	pc = 0x821DFFC8; continue 'dispatch;
            }
            0x821DFFC8 => {
    //   block [0x821DFFC8..0x821DFFCC)
	// 821DFFC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DFFCC; continue 'dispatch;
            }
            0x821DFFCC => {
    //   block [0x821DFFCC..0x821DFFE0)
	// 821DFFCC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DFFD0: 419A005C  beq cr6, 0x821e002c
	if ctx.cr[6].eq {
	pc = 0x821E002C; continue 'dispatch;
	}
	// 821DFFD4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821DFFD8: 409A0008  bne cr6, 0x821dffe0
	if !ctx.cr[6].eq {
	pc = 0x821DFFE0; continue 'dispatch;
	}
	// 821DFFDC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DFFE0; continue 'dispatch;
            }
            0x821DFFE0 => {
    //   block [0x821DFFE0..0x821DFFF0)
	// 821DFFE0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821DFFE4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821DFFE8: 409A0008  bne cr6, 0x821dfff0
	if !ctx.cr[6].eq {
	pc = 0x821DFFF0; continue 'dispatch;
	}
	// 821DFFEC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821DFFF0; continue 'dispatch;
            }
            0x821DFFF0 => {
    //   block [0x821DFFF0..0x821E0014)
	// 821DFFF0: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DFFF4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821DFFF8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821DFFFC: 409A0018  bne cr6, 0x821e0014
	if !ctx.cr[6].eq {
	pc = 0x821E0014; continue 'dispatch;
	}
	// 821E0000: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821E0004: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E0008: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821E000C: 4BFFE2DD  bl 0x821de2e8
	ctx.lr = 0x821E0010;
	sub_821DE2E8(ctx, base);
	// 821E0010: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	pc = 0x821E0014; continue 'dispatch;
            }
            0x821E0014 => {
    //   block [0x821E0014..0x821E0024)
	// 821E0014: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0018: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E001C: 409A0008  bne cr6, 0x821e0024
	if !ctx.cr[6].eq {
	pc = 0x821E0024; continue 'dispatch;
	}
	// 821E0020: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E0024; continue 'dispatch;
            }
            0x821E0024 => {
    //   block [0x821E0024..0x821E002C)
	// 821E0024: 83BD0000  lwz r29, 0(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E0028: 4BFFFF8C  b 0x821dffb4
	pc = 0x821DFFB4; continue 'dispatch;
            }
            0x821E002C => {
    //   block [0x821E002C..0x821E005C)
	// 821E002C: 817A00D4  lwz r11, 0xd4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(212 as u32) ) } as u64;
	// 821E0030: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E0034: 419A009C  beq cr6, 0x821e00d0
	if ctx.cr[6].eq {
	pc = 0x821E00D0; continue 'dispatch;
	}
	// 821E0038: 3BBA00CC  addi r29, r26, 0xcc
	ctx.r[29].s64 = ctx.r[26].s64 + 204;
	// 821E003C: 817A00D0  lwz r11, 0xd0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(208 as u32) ) } as u64;
	// 821E0040: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 821E0044: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E0048: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E004C: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E0050: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821E0054: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E0058: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x821E005C; continue 'dispatch;
            }
            0x821E005C => {
    //   block [0x821E005C..0x821E0070)
	// 821E005C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0060: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E0064: 419A000C  beq cr6, 0x821e0070
	if ctx.cr[6].eq {
	pc = 0x821E0070; continue 'dispatch;
	}
	// 821E0068: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 821E006C: 419A0008  beq cr6, 0x821e0074
	if ctx.cr[6].eq {
	pc = 0x821E0074; continue 'dispatch;
	}
	pc = 0x821E0070; continue 'dispatch;
            }
            0x821E0070 => {
    //   block [0x821E0070..0x821E0074)
	// 821E0070: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E0074; continue 'dispatch;
            }
            0x821E0074 => {
    //   block [0x821E0074..0x821E0088)
	// 821E0074: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E0078: 419A0050  beq cr6, 0x821e00c8
	if ctx.cr[6].eq {
	pc = 0x821E00C8; continue 'dispatch;
	}
	// 821E007C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E0080: 409A0008  bne cr6, 0x821e0088
	if !ctx.cr[6].eq {
	pc = 0x821E0088; continue 'dispatch;
	}
	// 821E0084: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E0088; continue 'dispatch;
            }
            0x821E0088 => {
    //   block [0x821E0088..0x821E0098)
	// 821E0088: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E008C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E0090: 409A0008  bne cr6, 0x821e0098
	if !ctx.cr[6].eq {
	pc = 0x821E0098; continue 'dispatch;
	}
	// 821E0094: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E0098; continue 'dispatch;
            }
            0x821E0098 => {
    //   block [0x821E0098..0x821E00B0)
	// 821E0098: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E009C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E00A0: 419A0010  beq cr6, 0x821e00b0
	if ctx.cr[6].eq {
	pc = 0x821E00B0; continue 'dispatch;
	}
	// 821E00A4: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E00A8: 906B0040  stw r3, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[3].u32 ) };
	// 821E00AC: 49054155  bl 0x83234200
	ctx.lr = 0x821E00B0;
	sub_83234200(ctx, base);
	pc = 0x821E00B0; continue 'dispatch;
            }
            0x821E00B0 => {
    //   block [0x821E00B0..0x821E00C0)
	// 821E00B0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E00B4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E00B8: 409A0008  bne cr6, 0x821e00c0
	if !ctx.cr[6].eq {
	pc = 0x821E00C0; continue 'dispatch;
	}
	// 821E00BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E00C0; continue 'dispatch;
            }
            0x821E00C0 => {
    //   block [0x821E00C0..0x821E00C8)
	// 821E00C0: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E00C4: 4BFFFF98  b 0x821e005c
	pc = 0x821E005C; continue 'dispatch;
            }
            0x821E00C8 => {
    //   block [0x821E00C8..0x821E00D0)
	// 821E00C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E00CC: 485C0D4D  bl 0x827a0e18
	ctx.lr = 0x821E00D0;
	sub_827A0E18(ctx, base);
	pc = 0x821E00D0; continue 'dispatch;
            }
            0x821E00D0 => {
    //   block [0x821E00D0..0x821E0140)
	// 821E00D0: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821E00D4: 807F6AB8  lwz r3, 0x6ab8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821E00D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E00DC: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E00E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E00E4: 4E800421  bctrl
	ctx.lr = 0x821E00E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E00E8: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E00EC: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E00F0: 490541C1  bl 0x832342b0
	ctx.lr = 0x821E00F4;
	sub_832342B0(ctx, base);
	// 821E00F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E00F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E00FC: 419A0044  beq cr6, 0x821e0140
	if ctx.cr[6].eq {
	pc = 0x821E0140; continue 'dispatch;
	}
	// 821E0100: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821E0104: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E0108: 806A009C  lwz r3, 0x9c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 821E010C: 480186BD  bl 0x821f87c8
	ctx.lr = 0x821E0110;
	sub_821F87C8(ctx, base);
	// 821E0110: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E0114: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821E0118: 419A0028  beq cr6, 0x821e0140
	if ctx.cr[6].eq {
	pc = 0x821E0140; continue 'dispatch;
	}
	// 821E011C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E0120: 4BFFD291  bl 0x821dd3b0
	ctx.lr = 0x821E0124;
	sub_821DD3B0(ctx, base);
	// 821E0124: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 821E0128: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821E012C: C0210090  lfs f1, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821E0130: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
            }
            0x821E0140 => {
    //   block [0x821E0140..0x821E021C)
	// 821E0140: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821E0144: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E0148: 812A0080  lwz r9, 0x80(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 821E014C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0150: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0154: 54EA003E  slwi r10, r7, 0
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E0158: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E015C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E0160: 409A000C  bne cr6, 0x821e016c
	if !ctx.cr[6].eq {
	pc = 0x821E016C; continue 'dispatch;
	}
	// 821E0164: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 821E0168: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 821E016C: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E0170: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E0174: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0178: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E017C: 4E800421  bctrl
	ctx.lr = 0x821E0180;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E0180: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821E0184: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E0188: 812B011C  lwz r9, 0x11c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 821E018C: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 821E0190: 409A0038  bne cr6, 0x821e01c8
	if !ctx.cr[6].eq {
	pc = 0x821E01C8; continue 'dispatch;
	}
	// 821E0194: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E0198: 894B00D9  lbz r10, 0xd9(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(217 as u32) ) } as u64;
	// 821E019C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E01A0: 419A0028  beq cr6, 0x821e01c8
	if ctx.cr[6].eq {
	pc = 0x821E01C8; continue 'dispatch;
	}
	// 821E01A4: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821E01A8: 396B09FC  addi r11, r11, 0x9fc
	ctx.r[11].s64 = ctx.r[11].s64 + 2556;
	// 821E01AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E01B0: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821E01B4: 7D4A00D0  neg r10, r10
	ctx.r[10].s64 = -ctx.r[10].s64;
	// 821E01B8: 7D49FE70  srawi r9, r10, 0x1f
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 31) as i64;
	// 821E01BC: 7D285038  and r8, r9, r10
	ctx.r[8].u64 = ctx.r[9].u64 & ctx.r[10].u64;
	// 821E01C0: 7D4800D0  neg r10, r8
	ctx.r[10].s64 = -ctx.r[8].s64;
	// 821E01C4: 48000010  b 0x821e01d4
	pc = 0x821E01D4; continue 'dispatch;
	// 821E01C8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821E01CC: 3940000A  li r10, 0xa
	ctx.r[10].s64 = 10;
	// 821E01D0: 396B09FC  addi r11, r11, 0x9fc
	ctx.r[11].s64 = ctx.r[11].s64 + 2556;
	// 821E01D4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821E01D8: 897A00B1  lbz r11, 0xb1(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(177 as u32) ) } as u64;
	// 821E01DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E01E0: 419A0030  beq cr6, 0x821e0210
	if ctx.cr[6].eq {
	pc = 0x821E0210; continue 'dispatch;
	}
	// 821E01E4: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 821E01E8: 419A0028  beq cr6, 0x821e0210
	if ctx.cr[6].eq {
	pc = 0x821E0210; continue 'dispatch;
	}
	// 821E01EC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E01F0: 419A0020  beq cr6, 0x821e0210
	if ctx.cr[6].eq {
	pc = 0x821E0210; continue 'dispatch;
	}
	// 821E01F4: 89790005  lbz r11, 5(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(5 as u32) ) } as u64;
	// 821E01F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E01FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E0200: 409A0008  bne cr6, 0x821e0208
	if !ctx.cr[6].eq {
	pc = 0x821E0208; continue 'dispatch;
	}
	// 821E0204: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821E0208: 49054A31  bl 0x83234c38
	ctx.lr = 0x821E020C;
	sub_83234C38(ctx, base);
	// 821E020C: 480DE96D  bl 0x822beb78
	ctx.lr = 0x821E0210;
	sub_822BEB78(ctx, base);
	// 821E0210: 38211170  addi r1, r1, 0x1170
	ctx.r[1].s64 = ctx.r[1].s64 + 4464;
	// 821E0214: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821E0218: 48AC9234  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E0220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E0220 size=360
    let mut pc: u32 = 0x821E0220;
    'dispatch: loop {
        match pc {
            0x821E0220 => {
    //   block [0x821E0220..0x821E0330)
	// 821E0220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E0224: 48AC91C1  bl 0x82ca93e4
	ctx.lr = 0x821E0228;
	sub_82CA93D0(ctx, base);
	// 821E0228: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E022C: 7D575378  mr r23, r10
	ctx.r[23].u64 = ctx.r[10].u64;
	// 821E0230: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821E0234: 39770070  addi r11, r23, 0x70
	ctx.r[11].s64 = ctx.r[23].s64 + 112;
	// 821E0238: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 821E023C: 557D1838  slwi r29, r11, 3
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 821E0240: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E0244: 7CD43378  mr r20, r6
	ctx.r[20].u64 = ctx.r[6].u64;
	// 821E0248: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 821E024C: 7D154378  mr r21, r8
	ctx.r[21].u64 = ctx.r[8].u64;
	// 821E0250: 7D7DF82E  lwzx r11, r29, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821E0254: 7D334B78  mr r19, r9
	ctx.r[19].u64 = ctx.r[9].u64;
	// 821E0258: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821E025C: 836B036C  lwz r27, 0x36c(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(876 as u32) ) } as u64;
	// 821E0260: 577CF0BE  srwi r28, r27, 2
	ctx.r[28].u32 = ctx.r[27].u32.wrapping_shr(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 821E0264: 389C0005  addi r4, r28, 5
	ctx.r[4].s64 = ctx.r[28].s64 + 5;
	// 821E0268: 48033871  bl 0x82213ad8
	ctx.lr = 0x821E026C;
	sub_82213AD8(ctx, base);
	// 821E026C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E0270: 41820110  beq 0x821e0380
	if ctx.cr[0].eq {
	pc = 0x821E0380; continue 'dispatch;
	}
	// 821E0274: 3D60C000  lis r11, -0x4000
	ctx.r[11].s64 = -1073741824;
	// 821E0278: 39400100  li r10, 0x100
	ctx.r[10].s64 = 256;
	// 821E027C: 616B3B00  ori r11, r11, 0x3b00
	ctx.r[11].u64 = ctx.r[11].u64 | 15104;
	// 821E0280: 3D20C000  lis r9, -0x4000
	ctx.r[9].s64 = -1073741824;
	// 821E0284: 95630004  stwu r11, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[3].u32 = ea;
	// 821E0288: 397C0001  addi r11, r28, 1
	ctx.r[11].s64 = ctx.r[28].s64 + 1;
	// 821E028C: 61292B00  ori r9, r9, 0x2b00
	ctx.r[9].u64 = ctx.r[9].u64 | 11008;
	// 821E0290: 578804BE  clrlwi r8, r28, 0x12
	ctx.r[8].u64 = ctx.r[28].u32 as u64 & 0x00003FFFu64;
	// 821E0294: 5169809E  rlwimi r9, r11, 0x10, 2, 0xf
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(16) as u64) & 0x000000003FFF0000) | (ctx.r[9].u64 & 0xFFFFFFFFC000FFFF);
	// 821E0298: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E029C: 95430004  stwu r10, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[3].u32 = ea;
	// 821E02A0: 95230004  stwu r9, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[3].u32 = ea;
	// 821E02A4: 95630004  stwu r11, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[11].u32) };
	ctx.r[3].u32 = ea;
	// 821E02A8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821E02AC: 95190004  stwu r8, 4(r25)
	ea = ctx.r[25].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[8].u32) };
	ctx.r[25].u32 = ea;
	// 821E02B0: 7D7DF82E  lwzx r11, r29, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 821E02B4: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E02B8: 3B590004  addi r26, r25, 4
	ctx.r[26].s64 = ctx.r[25].s64 + 4;
	// 821E02BC: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821E02C0: 816B0368  lwz r11, 0x368(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(872 as u32) ) } as u64;
	// 821E02C4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E02C8: 5569653E  srwi r9, r11, 0x14
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(20);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E02CC: 556A00FE  clrlwi r10, r11, 3
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 821E02D0: 39690200  addi r11, r9, 0x200
	ctx.r[11].s64 = ctx.r[9].s64 + 512;
	// 821E02D4: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E02D8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E02DC: 3FABC000  addis r29, r11, -0x4000
	ctx.r[29].s64 = ctx.r[11].s64 + -1073741824;
	// 821E02E0: 7C0004AC  sync
	// 821E02E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821E02E8: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821E02EC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821E02F0: 48AC9191  bl 0x82ca9480
	ctx.lr = 0x821E02F4;
	sub_82CA9480(ctx, base);
	// 821E02F4: 7C9DDA14  add r4, r29, r27
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[27].u64;
	// 821E02F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E02FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E0300: 4BFF1209  bl 0x821d1508
	ctx.lr = 0x821E0304;
	sub_821D1508(ctx, base);
	// 821E0304: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 821E0308: 419A0028  beq cr6, 0x821e0330
	if ctx.cr[6].eq {
	pc = 0x821E0330; continue 'dispatch;
	}
	// 821E030C: 89750008  lbz r11, 8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E0310: 556B077E  clrlwi r11, r11, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 821E0314: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 821E0318: 419A0018  beq cr6, 0x821e0330
	if ctx.cr[6].eq {
	pc = 0x821E0330; continue 'dispatch;
	}
	// 821E031C: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	// 821E0320: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 821E0324: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821E0328: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 821E032C: 489C3A5D  bl 0x82ba3d88
	ctx.lr = 0x821E0330;
	sub_82BA3D88(ctx, base);
	pc = 0x821E0330; continue 'dispatch;
            }
            0x821E0330 => {
    //   block [0x821E0330..0x821E0380)
	// 821E0330: 7F0B0034  cntlzw r11, r24
	ctx.r[11].u64 = if ctx.r[24].u32 == 0 { 32 } else { ctx.r[24].u32.leading_zeros() as u64 };
	// 821E0334: 895E2ABE  lbz r10, 0x2abe(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(10942 as u32) ) } as u64;
	// 821E0338: 38DE30F0  addi r6, r30, 0x30f0
	ctx.r[6].s64 = ctx.r[30].s64 + 12528;
	// 821E033C: 556B1630  rlwinm r11, r11, 2, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 821E0340: 554A067E  clrlwi r10, r10, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 821E0344: 696B0080  xori r11, r11, 0x80
	ctx.r[11].u64 = ctx.r[11].u64 ^ 128;
	// 821E0348: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 821E034C: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 821E0350: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 821E0354: 997E2ABE  stb r11, 0x2abe(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(10942 as u32), ctx.r[11].u8 ) };
	// 821E0358: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821E035C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E0360: 4BFF3211  bl 0x821d3570
	ctx.lr = 0x821E0364;
	sub_821D3570(ctx, base);
	// 821E0364: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E0368: E95E30F8  ld r10, 0x30f8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(12536 as u32) ) };
	// 821E036C: 7D6BCA14  add r11, r11, r25
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 821E0370: 917E0030  stw r11, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 821E0374: F95E2E40  std r10, 0x2e40(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(11840 as u32), ctx.r[10].u64 ) };
	// 821E0378: E97E30F0  ld r11, 0x30f0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(12528 as u32) ) };
	// 821E037C: F97E2E38  std r11, 0x2e38(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(11832 as u32), ctx.r[11].u64 ) };
	pc = 0x821E0380; continue 'dispatch;
            }
            0x821E0380 => {
    //   block [0x821E0380..0x821E0388)
	// 821E0380: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821E0384: 48AC90B0  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E0388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E0388 size=96
    let mut pc: u32 = 0x821E0388;
    'dispatch: loop {
        match pc {
            0x821E0388 => {
    //   block [0x821E0388..0x821E03AC)
	// 821E0388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E038C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E0390: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E0394: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821E0398: 48843D49  bl 0x82a240e0
	ctx.lr = 0x821E039C;
	sub_82A240E0(ctx, base);
	// 821E039C: 81450008  lwz r10, 8(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E03A0: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 821E03A4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E03A8: 40980024  bge cr6, 0x821e03cc
	if !ctx.cr[6].lt {
	pc = 0x821E03CC; continue 'dispatch;
	}
	pc = 0x821E03AC; continue 'dispatch;
            }
            0x821E03AC => {
    //   block [0x821E03AC..0x821E03CC)
	// 821E03AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E03B0: 914BFFF8  stw r10, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[10].u32 ) };
	// 821E03B4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E03B8: 912BFFFC  stw r9, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[9].u32 ) };
	// 821E03BC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E03C0: 81050008  lwz r8, 8(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E03C4: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E03C8: 4198FFE4  blt cr6, 0x821e03ac
	if ctx.cr[6].lt {
	pc = 0x821E03AC; continue 'dispatch;
	}
	pc = 0x821E03CC; continue 'dispatch;
            }
            0x821E03CC => {
    //   block [0x821E03CC..0x821E03E8)
	// 821E03CC: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E03D0: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 821E03D4: 91650008  stw r11, 8(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821E03D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E03DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E03E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E03E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E03E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E03E8 size=2060
    let mut pc: u32 = 0x821E03E8;
    'dispatch: loop {
        match pc {
            0x821E03E8 => {
    //   block [0x821E03E8..0x821E0484)
	// 821E03E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E03EC: 48AC9005  bl 0x82ca93f0
	ctx.lr = 0x821E03F0;
	sub_82CA93D0(ctx, base);
	// 821E03F0: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 821E03F4: 48ACD8E5  bl 0x82cadcd8
	ctx.lr = 0x821E03F8;
	sub_82CADCA0(ctx, base);
	// 821E03F8: 3981FF80  addi r12, r1, -0x80
	ctx.r[12].s64 = ctx.r[1].s64 + -128;
	// 821E03FC: 48E265D1  bl 0x830069cc
	ctx.lr = 0x821E0400;
	sub_83006760(ctx, base);
	// 821E0400: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E0404: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 821E0408: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821E040C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821E0410: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821E0414: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 821E0418: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821E041C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 821E0420: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 821E0424: 93210080  stw r25, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[25].u32 ) };
	// 821E0428: 7CD63378  mr r22, r6
	ctx.r[22].u64 = ctx.r[6].u64;
	// 821E042C: 9321007C  stw r25, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[25].u32 ) };
	// 821E0430: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 821E0434: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 821E0438: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 821E043C: 91610078  stw r11, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 821E0440: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 821E0444: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 821E0448: 4800CB29  bl 0x821ecf70
	ctx.lr = 0x821E044C;
	sub_821ECF70(ctx, base);
	// 821E044C: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821E0450: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 821E0454: 3B4BDED4  addi r26, r11, -0x212c
	ctx.r[26].s64 = ctx.r[11].s64 + -8492;
	// 821E0458: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 821E045C: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 821E0460: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 821E0464: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0468: 80AB02AC  lwz r5, 0x2ac(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(684 as u32) ) } as u64;
	// 821E046C: 48087F95  bl 0x82268400
	ctx.lr = 0x821E0470;
	sub_82268400(ctx, base);
	// 821E0470: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E0474: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821E0478: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	// 821E047C: 394A0190  addi r10, r10, 0x190
	ctx.r[10].s64 = ctx.r[10].s64 + 400;
	// 821E0480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x821E0484; continue 'dispatch;
            }
            0x821E0484 => {
    //   block [0x821E0484..0x821E0530)
	// 821E0484: E96A0000  ld r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821E0488: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E048C: F9690000  std r11, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821E0490: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 821E0494: 4200FFF0  bdnz 0x821e0484
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821E0484; continue 'dispatch;
	}
	// 821E0498: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821E049C: 480AE2ED  bl 0x8228e788
	ctx.lr = 0x821E04A0;
	sub_8228E788(ctx, base);
	// 821E04A0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821E04A4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821E04A8: 48090829  bl 0x82270cd0
	ctx.lr = 0x821E04AC;
	sub_82270CD0(ctx, base);
	// 821E04AC: 7BCB0020  clrldi r11, r30, 0x20
	ctx.r[11].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 821E04B0: 7BAA0020  clrldi r10, r29, 0x20
	ctx.r[10].u64 = ctx.r[29].u64 & 0x00000000FFFFFFFFu64;
	// 821E04B4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821E04B8: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821E04BC: 7B890020  clrldi r9, r28, 0x20
	ctx.r[9].u64 = ctx.r[28].u64 & 0x00000000FFFFFFFFu64;
	// 821E04C0: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 821E04C4: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821E04C8: 7BE80020  clrldi r8, r31, 0x20
	ctx.r[8].u64 = ctx.r[31].u64 & 0x00000000FFFFFFFFu64;
	// 821E04CC: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 821E04D0: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821E04D4: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 821E04D8: C9610060  lfd f11, 0x60(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821E04DC: FD20069C  fcfid f9, f0
	ctx.f[9].f64 = (ctx.f[0].s64 as f64);
	// 821E04E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E04E4: FCA04818  frsp f5, f9
	ctx.f[5].f64 = (ctx.f[9].f64 as f32) as f64;
	// 821E04E8: 3AEB9484  addi r23, r11, -0x6b7c
	ctx.r[23].s64 = ctx.r[11].s64 + -27516;
	// 821E04EC: FCE06E9C  fcfid f7, f13
	ctx.f[7].f64 = (ctx.f[13].s64 as f64);
	// 821E04F0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821E04F4: FD00669C  fcfid f8, f12
	ctx.f[8].f64 = (ctx.f[12].s64 as f64);
	// 821E04F8: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 821E04FC: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 821E0500: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821E0504: C397000C  lfs f28, 0xc(r23)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(12 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821E0508: EC7C2824  fdivs f3, f28, f5
	ctx.f[3].f64 = ((ctx.f[28].f64 / ctx.f[5].f64) as f32) as f64;
	// 821E050C: D0610050  stfs f3, 0x50(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821E0510: FFA03818  frsp f29, f7
	ctx.f[29].f64 = (ctx.f[7].f64 as f32) as f64;
	// 821E0514: D3A10060  stfs f29, 0x60(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821E0518: FFC04018  frsp f30, f8
	ctx.f[30].f64 = (ctx.f[8].f64 as f32) as f64;
	// 821E051C: D3C10058  stfs f30, 0x58(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821E0520: FCC05018  frsp f6, f10
	ctx.f[6].f64 = (ctx.f[10].f64 as f32) as f64;
	// 821E0524: EC9C3024  fdivs f4, f28, f6
	ctx.f[4].f64 = ((ctx.f[28].f64 / ctx.f[6].f64) as f32) as f64;
	// 821E0528: D0810054  stfs f4, 0x54(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821E052C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821E0530; continue 'dispatch;
            }
            0x821E0530 => {
    //   block [0x821E0530..0x821E0BF4)
	// 821E0530: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821E0534: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E0538: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821E053C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E0540: 4200FFF0  bdnz 0x821e0530
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821E0530; continue 'dispatch;
	}
	// 821E0544: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821E0548: 38600075  li r3, 0x75
	ctx.r[3].s64 = 117;
	// 821E054C: 480A6F2D  bl 0x82287478
	ctx.lr = 0x821E0550;
	sub_82287478(ctx, base);
	// 821E0550: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821E0554: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 821E0558: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 821E055C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 821E0560: 386000CF  li r3, 0xcf
	ctx.r[3].s64 = 207;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E0BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E0BF8 size=28
    let mut pc: u32 = 0x821E0BF8;
    'dispatch: loop {
        match pc {
            0x821E0BF8 => {
    //   block [0x821E0BF8..0x821E0C14)
	// 821E0BF8: 81632940  lwz r11, 0x2940(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(10560 as u32) ) } as u64;
	// 821E0BFC: 508B2EB4  rlwimi r11, r4, 5, 0x1a, 0x1a
	ctx.r[11].u64 = (((ctx.r[4].u32).rotate_left(5) as u64) & 0x0000000000000020) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFFDF);
	// 821E0C00: 91632940  stw r11, 0x2940(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10560 as u32), ctx.r[11].u32 ) };
	// 821E0C04: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821E0C08: 616B0100  ori r11, r11, 0x100
	ctx.r[11].u64 = ctx.r[11].u64 | 256;
	// 821E0C0C: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821E0C10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E0C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E0C18 size=96
    let mut pc: u32 = 0x821E0C18;
    'dispatch: loop {
        match pc {
            0x821E0C18 => {
    //   block [0x821E0C18..0x821E0C78)
	// 821E0C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E0C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E0C20: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E0C24: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E0C28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E0C2C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821E0C30: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 821E0C34: 392A0B7C  addi r9, r10, 0xb7c
	ctx.r[9].s64 = ctx.r[10].s64 + 2940;
	// 821E0C38: 386B0070  addi r3, r11, 0x70
	ctx.r[3].s64 = ctx.r[11].s64 + 112;
	// 821E0C3C: 913F0080  stw r9, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 821E0C40: 4BFB31F9  bl 0x82193e38
	ctx.lr = 0x821E0C44;
	sub_82193E38(ctx, base);
	// 821E0C44: 3D008203  lis r8, -0x7dfd
	ctx.r[8].s64 = -2113732608;
	// 821E0C48: 3CE0820B  lis r7, -0x7df5
	ctx.r[7].s64 = -2113208320;
	// 821E0C4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821E0C50: 38A82B14  addi r5, r8, 0x2b14
	ctx.r[5].s64 = ctx.r[8].s64 + 11028;
	// 821E0C54: 38879950  addi r4, r7, -0x66b0
	ctx.r[4].s64 = ctx.r[7].s64 + -26288;
	// 821E0C58: 90DF0084  stw r6, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[6].u32 ) };
	// 821E0C5C: 90BF0010  stw r5, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	// 821E0C60: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 821E0C64: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E0C68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E0C6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E0C70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E0C74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E0C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E0C78 size=168
    let mut pc: u32 = 0x821E0C78;
    'dispatch: loop {
        match pc {
            0x821E0C78 => {
    //   block [0x821E0C78..0x821E0CF0)
	// 821E0C78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E0C7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E0C80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E0C84: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821E0C88: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E0C8C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821E0C90: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E0C94: 38830038  addi r4, r3, 0x38
	ctx.r[4].s64 = ctx.r[3].s64 + 56;
	// 821E0C98: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 821E0C9C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E0CA0: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E0CA4: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E0CA8: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E0CAC: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821E0CB0: ED806FFA  fmadds f12, f0, f31, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 821E0CB4: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821E0CB8: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E0CBC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821E0CC0: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 821E0CC4: 4882CF95  bl 0x82a0dc58
	ctx.lr = 0x821E0CC8;
	sub_82A0DC58(ctx, base);
	// 821E0CC8: 88E10068  lbz r7, 0x68(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 821E0CCC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E0CD0: 409A0038  bne cr6, 0x821e0d08
	if !ctx.cr[6].eq {
	pc = 0x821E0D08; continue 'dispatch;
	}
	// 821E0CD4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821E0CD8: C01F0018  lfs f0, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E0CDC: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E0CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E0CE4: EC006FFA  fmadds f0, f0, f31, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 821E0CE8: 409A0008  bne cr6, 0x821e0cf0
	if !ctx.cr[6].eq {
	pc = 0x821E0CF0; continue 'dispatch;
	}
	// 821E0CEC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E0CF0; continue 'dispatch;
            }
            0x821E0CF0 => {
    //   block [0x821E0CF0..0x821E0D04)
	// 821E0CF0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0CF4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821E0CF8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E0CFC: 409A0008  bne cr6, 0x821e0d04
	if !ctx.cr[6].eq {
	pc = 0x821E0D04; continue 'dispatch;
	}
	// 821E0D00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E0D04; continue 'dispatch;
            }
            0x821E0D04 => {
    //   block [0x821E0D04..0x821E0D08)
	// 821E0D04: D00B0010  stfs f0, 0x10(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	pc = 0x821E0D08; continue 'dispatch;
            }
            0x821E0D08 => {
    //   block [0x821E0D08..0x821E0D20)
	// 821E0D08: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821E0D0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E0D10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E0D14: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E0D18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E0D1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E0D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E0D20 size=552
    let mut pc: u32 = 0x821E0D20;
    'dispatch: loop {
        match pc {
            0x821E0D20 => {
    //   block [0x821E0D20..0x821E0D7C)
	// 821E0D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E0D24: 48AC86D5  bl 0x82ca93f8
	ctx.lr = 0x821E0D28;
	sub_82CA93D0(ctx, base);
	// 821E0D28: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E0D2C: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 821E0D30: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 821E0D34: 90C10054  stw r6, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[6].u32 ) };
	// 821E0D38: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 821E0D3C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E0D40: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821E0D44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E0D48: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E0D4C: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 821E0D50: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 821E0D54: 7D5A5378  mr r26, r10
	ctx.r[26].u64 = ctx.r[10].u64;
	// 821E0D58: 480AB7D1  bl 0x8228c528
	ctx.lr = 0x821E0D5C;
	sub_8228C528(ctx, base);
	// 821E0D5C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821E0D60: 8381005C  lwz r28, 0x5c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821E0D64: 83610058  lwz r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E0D68: 419900B4  bgt cr6, 0x821e0e1c
	if ctx.cr[6].gt {
	pc = 0x821E0E1C; continue 'dispatch;
	}
	// 821E0D6C: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 821E0D70: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821E0D74: 41980008  blt cr6, 0x821e0d7c
	if ctx.cr[6].lt {
	pc = 0x821E0D7C; continue 'dispatch;
	}
	// 821E0D78: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821E0D7C; continue 'dispatch;
            }
            0x821E0D7C => {
    //   block [0x821E0D7C..0x821E0D8C)
	// 821E0D7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E0D80: 409A000C  bne cr6, 0x821e0d8c
	if !ctx.cr[6].eq {
	pc = 0x821E0D8C; continue 'dispatch;
	}
	// 821E0D84: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821E0D88: 48000090  b 0x821e0e18
	pc = 0x821E0E18; continue 'dispatch;
            }
            0x821E0D8C => {
    //   block [0x821E0D8C..0x821E0DA0)
	// 821E0D8C: 3D408000  lis r10, -0x8000
	ctx.r[10].s64 = -2147483648;
	// 821E0D90: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E0D94: 4198000C  blt cr6, 0x821e0da0
	if ctx.cr[6].lt {
	pc = 0x821E0DA0; continue 'dispatch;
	}
	// 821E0D98: 3960001F  li r11, 0x1f
	ctx.r[11].s64 = 31;
	// 821E0D9C: 4800007C  b 0x821e0e18
	pc = 0x821E0E18; continue 'dispatch;
            }
            0x821E0DA0 => {
    //   block [0x821E0DA0..0x821E0E18)
	// 821E0DA0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E0DA4: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821E0DA8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E0DAC: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 821E0DB0: 7D07FE70  srawi r7, r8, 0x1f
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 31) as i64;
	// 821E0DB4: 54E906F6  rlwinm r9, r7, 0, 0x1b, 0x1b
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821E0DB8: 38C90008  addi r6, r9, 8
	ctx.r[6].s64 = ctx.r[9].s64 + 8;
	// 821E0DBC: 7D453030  slw r5, r10, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = ((ctx.r[10].u32) << ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 821E0DC0: 7C8B2850  subf r4, r11, r5
	ctx.r[4].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821E0DC4: 7C83FE70  srawi r3, r4, 0x1f
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[4].s32 >> 31) as i64;
	// 821E0DC8: 54680738  rlwinm r8, r3, 0, 0x1c, 0x1c
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0xFFFFFFFFu64;
	// 821E0DCC: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821E0DD0: 39090004  addi r8, r9, 4
	ctx.r[8].s64 = ctx.r[9].s64 + 4;
	// 821E0DD4: 7D474030  slw r7, r10, r8
	if (ctx.r[8].u8 & 0x20) != 0 {
		ctx.r[7].u64 = 0;
	} else {
		ctx.r[7].u64 = ((ctx.r[10].u32) << ((ctx.r[8].u8 & 0x1F) as u32)) as u64;
	}
	// 821E0DD8: 7CCB3850  subf r6, r11, r7
	ctx.r[6].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 821E0DDC: 7CC5FE70  srawi r5, r6, 0x1f
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[6].s32 >> 31) as i64;
	// 821E0DE0: 54A8077A  rlwinm r8, r5, 0, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821E0DE4: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821E0DE8: 38890002  addi r4, r9, 2
	ctx.r[4].s64 = ctx.r[9].s64 + 2;
	// 821E0DEC: 7D432030  slw r3, r10, r4
	if (ctx.r[4].u8 & 0x20) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = ((ctx.r[10].u32) << ((ctx.r[4].u8 & 0x1F) as u32)) as u64;
	}
	// 821E0DF0: 7D0B1850  subf r8, r11, r3
	ctx.r[8].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821E0DF4: 7D07FE70  srawi r7, r8, 0x1f
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 31) as i64;
	// 821E0DF8: 54E807BC  rlwinm r8, r7, 0, 0x1e, 0x1e
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821E0DFC: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821E0E00: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821E0E04: 7D453030  slw r5, r10, r6
	if (ctx.r[6].u8 & 0x20) != 0 {
		ctx.r[5].u64 = 0;
	} else {
		ctx.r[5].u64 = ((ctx.r[10].u32) << ((ctx.r[6].u8 & 0x1F) as u32)) as u64;
	}
	// 821E0E08: 7C8B2850  subf r4, r11, r5
	ctx.r[4].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 821E0E0C: 7C83FE70  srawi r3, r4, 0x1f
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[4].s32 >> 31) as i64;
	// 821E0E10: 546B07FE  clrlwi r11, r3, 0x1f
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00000001u64;
	// 821E0E14: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x821E0E18; continue 'dispatch;
            }
            0x821E0E18 => {
    //   block [0x821E0E18..0x821E0E1C)
	// 821E0E18: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	pc = 0x821E0E1C; continue 'dispatch;
            }
            0x821E0E1C => {
    //   block [0x821E0E1C..0x821E0EA4)
	// 821E0E1C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821E0E20: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821E0E24: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821E0E28: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E0E2C: 480A5675  bl 0x822864a0
	ctx.lr = 0x821E0E30;
	sub_822864A0(ctx, base);
	// 821E0E30: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E0E34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E0E38: 480AB681  bl 0x8228c4b8
	ctx.lr = 0x821E0E3C;
	sub_8228C4B8(ctx, base);
	// 821E0E3C: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 821E0E40: 419A00FC  beq cr6, 0x821e0f3c
	if ctx.cr[6].eq {
	pc = 0x821E0F3C; continue 'dispatch;
	}
	// 821E0E44: 39630001  addi r11, r3, 1
	ctx.r[11].s64 = ctx.r[3].s64 + 1;
	// 821E0E48: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821E0E4C: 1D6B004C  mulli r11, r11, 0x4c
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 76 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821E0E50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E0E54: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821E0E58: 4BFED261  bl 0x821ce0b8
	ctx.lr = 0x821E0E5C;
	sub_821CE0B8(ctx, base);
	// 821E0E5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E0E60: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E0E64: 419A00D8  beq cr6, 0x821e0f3c
	if ctx.cr[6].eq {
	pc = 0x821E0F3C; continue 'dispatch;
	}
	// 821E0E68: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821E0E6C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 821E0E70: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821E0E74: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821E0E78: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821E0E7C: 4897ED2D  bl 0x82b5fba8
	ctx.lr = 0x821E0E80;
	sub_82B5FBA8(ctx, base);
	// 821E0E80: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E0E84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E0E88: 419A00B4  beq cr6, 0x821e0f3c
	if ctx.cr[6].eq {
	pc = 0x821E0F3C; continue 'dispatch;
	}
	// 821E0E8C: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 821E0E90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E0E94: 419A0010  beq cr6, 0x821e0ea4
	if ctx.cr[6].eq {
	pc = 0x821E0EA4; continue 'dispatch;
	}
	// 821E0E98: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0E9C: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821E0EA0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x821E0EA4; continue 'dispatch;
            }
            0x821E0EA4 => {
    //   block [0x821E0EA4..0x821E0EBC)
	// 821E0EA4: 933E0038  stw r25, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[25].u32 ) };
	// 821E0EA8: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821E0EAC: 419A0010  beq cr6, 0x821e0ebc
	if ctx.cr[6].eq {
	pc = 0x821E0EBC; continue 'dispatch;
	}
	// 821E0EB0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0EB4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E0EB8: 91790004  stw r11, 4(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x821E0EBC; continue 'dispatch;
            }
            0x821E0EBC => {
    //   block [0x821E0EBC..0x821E0ECC)
	// 821E0EBC: 80780004  lwz r3, 4(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0EC0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E0EC4: 419A0044  beq cr6, 0x821e0f08
	if ctx.cr[6].eq {
	pc = 0x821E0F08; continue 'dispatch;
	}
	// 821E0EC8: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x821E0ECC; continue 'dispatch;
            }
            0x821E0ECC => {
    //   block [0x821E0ECC..0x821E0F00)
	// 821E0ECC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821E0ED0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E0ED4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821E0ED8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E0EDC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821E0EE0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E0EE4: 4082FFE8  bne 0x821e0ecc
	if !ctx.cr[0].eq {
	pc = 0x821E0ECC; continue 'dispatch;
	}
	// 821E0EE8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E0EEC: 409A0014  bne cr6, 0x821e0f00
	if !ctx.cr[6].eq {
	pc = 0x821E0F00; continue 'dispatch;
	}
	// 821E0EF0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E0EF4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E0EF8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E0EFC: 4E800421  bctrl
	ctx.lr = 0x821E0F00;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821E0F00 => {
    //   block [0x821E0F00..0x821E0F08)
	// 821E0F00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E0F04: 91780004  stw r11, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x821E0F08; continue 'dispatch;
            }
            0x821E0F08 => {
    //   block [0x821E0F08..0x821E0F14)
	// 821E0F08: 57CB003E  slwi r11, r30, 0
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E0F0C: 93D80004  stw r30, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821E0F10: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	pc = 0x821E0F14; continue 'dispatch;
            }
            0x821E0F14 => {
    //   block [0x821E0F14..0x821E0F3C)
	// 821E0F14: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821E0F18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E0F1C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821E0F20: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821E0F24: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821E0F28: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E0F2C: 4082FFE8  bne 0x821e0f14
	if !ctx.cr[0].eq {
	pc = 0x821E0F14; continue 'dispatch;
	}
	// 821E0F30: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821E0F34: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821E0F38: 48AC8510  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x821E0F3C => {
    //   block [0x821E0F3C..0x821E0F48)
	// 821E0F3C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E0F40: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821E0F44: 48AC8504  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E0F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E0F48 size=476
    let mut pc: u32 = 0x821E0F48;
    'dispatch: loop {
        match pc {
            0x821E0F48 => {
    //   block [0x821E0F48..0x821E1044)
	// 821E0F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E0F4C: 48AC84B5  bl 0x82ca9400
	ctx.lr = 0x821E0F50;
	sub_82CA93D0(ctx, base);
	// 821E0F50: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E0F54: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E0F58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821E0F5C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E0F60: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821E0F64: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E0F68: 388BE438  addi r4, r11, -0x1bc8
	ctx.r[4].s64 = ctx.r[11].s64 + -7112;
	// 821E0F6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E0F70: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 821E0F74: 4801F7FD  bl 0x82200770
	ctx.lr = 0x821E0F78;
	sub_82200770(ctx, base);
	// 821E0F78: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 821E0F7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E0F80: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 821E0F84: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821E0F88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E0F8C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821E0F90: 409A00B4  bne cr6, 0x821e1044
	if !ctx.cr[6].eq {
	pc = 0x821E1044; continue 'dispatch;
	}
	// 821E0F94: 809E0020  lwz r4, 0x20(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E0F98: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E0F9C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E0FA0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E0FA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E0FA8: 4E800421  bctrl
	ctx.lr = 0x821E0FAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E0FAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E0FB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E0FB4: 48A30D15  bl 0x82c11cc8
	ctx.lr = 0x821E0FB8;
	sub_82C11CC8(ctx, base);
	// 821E0FB8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E0FBC: 48A24F3D  bl 0x82c05ef8
	ctx.lr = 0x821E0FC0;
	sub_82C05EF8(ctx, base);
	// 821E0FC0: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821E0FC4: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 821E0FC8: 38A99170  addi r5, r9, -0x6e90
	ctx.r[5].s64 = ctx.r[9].s64 + -28304;
	// 821E0FCC: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 821E0FD0: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 821E0FD4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821E0FD8: 3C60820A  lis r3, -0x7df6
	ctx.r[3].s64 = -2113273856;
            }
            0x821E1044 => {
    //   block [0x821E1044..0x821E1124)
	// 821E1044: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E1048: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E104C: 48A30C7D  bl 0x82c11cc8
	ctx.lr = 0x821E1050;
	sub_82C11CC8(ctx, base);
	// 821E1050: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E1054: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821E1058: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E105C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1060: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1064: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E1068: 4E800421  bctrl
	ctx.lr = 0x821E106C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E106C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E1074: 419A0074  beq cr6, 0x821e10e8
	if ctx.cr[6].eq {
	pc = 0x821E10E8; continue 'dispatch;
	}
	// 821E1078: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E107C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 821E1080: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E1084: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 821E1088: 419A0014  beq cr6, 0x821e109c
	if ctx.cr[6].eq {
	pc = 0x821E109C; continue 'dispatch;
	}
	// 821E108C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1090: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1094: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E1098: 4E800421  bctrl
	ctx.lr = 0x821E109C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E109C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821E10A0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821E10A4: 4800F19D  bl 0x821f0240
	ctx.lr = 0x821E10A8;
	sub_821F0240(ctx, base);
	// 821E10A8: 817E0034  lwz r11, 0x34(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) } as u64;
	// 821E10AC: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 821E10B0: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821E10B4: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 821E10B8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 821E10BC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821E10C0: 4BFF42F9  bl 0x821d53b8
	ctx.lr = 0x821E10C4;
	sub_821D53B8(ctx, base);
	// 821E10C4: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821E10C8: 48033D11  bl 0x82214dd8
	ctx.lr = 0x821E10CC;
	sub_82214DD8(ctx, base);
	// 821E10CC: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 821E10D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E10D4: 419A0014  beq cr6, 0x821e10e8
	if ctx.cr[6].eq {
	pc = 0x821E10E8; continue 'dispatch;
	}
	// 821E10D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E10DC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E10E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E10E4: 4E800421  bctrl
	ctx.lr = 0x821E10E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E10E8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E10EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E10F0: 419A0014  beq cr6, 0x821e1104
	if ctx.cr[6].eq {
	pc = 0x821E1104; continue 'dispatch;
	}
	// 821E10F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E10F8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E10FC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E1100: 4E800421  bctrl
	ctx.lr = 0x821E1104;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E1104: 89410064  lbz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821E1108: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E110C: 419A000C  beq cr6, 0x821e1118
	if ctx.cr[6].eq {
	pc = 0x821E1118; continue 'dispatch;
	}
	// 821E1110: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821E1114: 490D8841  bl 0x832b9954
	ctx.lr = 0x821E1118;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 821E1118: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E111C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821E1120: 48AC8330  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1128 size=48
    let mut pc: u32 = 0x821E1128;
    'dispatch: loop {
        match pc {
            0x821E1128 => {
    //   block [0x821E1128..0x821E1158)
	// 821E1128: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E112C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E1130: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821E1134: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
	// 821E1138: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E113C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E1140: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821E1144: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1148: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821E114C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E1150: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E1154: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1160 size=628
    let mut pc: u32 = 0x821E1160;
    'dispatch: loop {
        match pc {
            0x821E1160 => {
    //   block [0x821E1160..0x821E13D4)
	// 821E1160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E1164: 48AC82A9  bl 0x82ca940c
	ctx.lr = 0x821E1168;
	sub_82CA93D0(ctx, base);
	// 821E1168: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 821E116C: 48ACCB6D  bl 0x82cadcd8
	ctx.lr = 0x821E1170;
	sub_82CADCA0(ctx, base);
	// 821E1170: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E13D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E13D8 size=276
    let mut pc: u32 = 0x821E13D8;
    'dispatch: loop {
        match pc {
            0x821E13D8 => {
    //   block [0x821E13D8..0x821E1410)
	// 821E13D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E13DC: 48AC801D  bl 0x82ca93f8
	ctx.lr = 0x821E13E0;
	sub_82CA93D0(ctx, base);
	// 821E13E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E13E4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821E13E8: 3B60000C  li r27, 0xc
	ctx.r[27].s64 = 12;
	// 821E13EC: 3BFA09F4  addi r31, r26, 0x9f4
	ctx.r[31].s64 = ctx.r[26].s64 + 2548;
	// 821E13F0: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 821E13F4: 817A09FC  lwz r11, 0x9fc(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(2556 as u32) ) } as u64;
	// 821E13F8: 815A09F8  lwz r10, 0x9f8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(2552 as u32) ) } as u64;
	// 821E13FC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821E1400: 7D09DBD7  divw. r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821E1404: 418200E0  beq 0x821e14e4
	if ctx.cr[0].eq {
	pc = 0x821E14E4; continue 'dispatch;
	}
	// 821E1408: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821E140C: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	pc = 0x821E1410; continue 'dispatch;
            }
            0x821E1410 => {
    //   block [0x821E1410..0x821E148C)
	// 821E1410: 817A09F8  lwz r11, 0x9f8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(2552 as u32) ) } as u64;
	// 821E1414: 7D4BE214  add r10, r11, r28
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821E1418: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 821E141C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821E1420: 41990098  bgt cr6, 0x821e14b8
	if ctx.cr[6].gt {
	pc = 0x821E14B8; continue 'dispatch;
	}
	// 821E1424: 81796AB8  lwz r11, 0x6ab8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821E1428: 388A0004  addi r4, r10, 4
	ctx.r[4].s64 = ctx.r[10].s64 + 4;
	// 821E142C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E1430: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E1434: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1438: 4816F489  bl 0x823508c0
	ctx.lr = 0x821E143C;
	sub_823508C0(ctx, base);
	// 821E143C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1440: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1444: 815A09F8  lwz r10, 0x9f8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(2552 as u32) ) } as u64;
	// 821E1448: 7CE84850  subf r7, r8, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821E144C: 7C7C5214  add r3, r28, r10
	ctx.r[3].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 821E1450: 7D67DBD6  divw r11, r7, r27
	ctx.r[11].s32 = ctx.r[7].s32 / ctx.r[27].s32;
	// 821E1454: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E1458: 7CCB4A14  add r6, r11, r9
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821E145C: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E1460: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E1464: 388BFFF4  addi r4, r11, -0xc
	ctx.r[4].s64 = ctx.r[11].s64 + -12;
	// 821E1468: 489442E9  bl 0x82b25750
	ctx.lr = 0x821E146C;
	sub_82B25750(ctx, base);
	// 821E146C: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1470: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1474: 7C85F050  subf r4, r5, r30
	ctx.r[4].s64 = ctx.r[30].s64 - ctx.r[5].s64;
	// 821E1478: 7C64DBD7  divw. r3, r4, r27
	ctx.r[3].s32 = ctx.r[4].s32 / ctx.r[27].s32;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821E147C: 41820030  beq 0x821e14ac
	if ctx.cr[0].eq {
	pc = 0x821E14AC; continue 'dispatch;
	}
	// 821E1480: 3BBEFFF4  addi r29, r30, -0xc
	ctx.r[29].s64 = ctx.r[30].s64 + -12;
	// 821E1484: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821E1488: 419A0018  beq cr6, 0x821e14a0
	if ctx.cr[6].eq {
	pc = 0x821E14A0; continue 'dispatch;
	}
	pc = 0x821E148C; continue 'dispatch;
            }
            0x821E148C => {
    //   block [0x821E148C..0x821E14A0)
	// 821E148C: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 821E1490: 4BFD6689  bl 0x821b7b18
	ctx.lr = 0x821E1494;
	sub_821B7B18(ctx, base);
	// 821E1494: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 821E1498: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821E149C: 409AFFF0  bne cr6, 0x821e148c
	if !ctx.cr[6].eq {
	pc = 0x821E148C; continue 'dispatch;
	}
	pc = 0x821E14A0; continue 'dispatch;
            }
            0x821E14A0 => {
    //   block [0x821E14A0..0x821E14AC)
	// 821E14A0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E14A4: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 821E14A8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x821E14AC; continue 'dispatch;
            }
            0x821E14AC => {
    //   block [0x821E14AC..0x821E14B8)
	// 821E14AC: 3B18FFFF  addi r24, r24, -1
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	// 821E14B0: 3B9CFFF4  addi r28, r28, -0xc
	ctx.r[28].s64 = ctx.r[28].s64 + -12;
	// 821E14B4: 48000010  b 0x821e14c4
	pc = 0x821E14C4; continue 'dispatch;
            }
            0x821E14B8 => {
    //   block [0x821E14B8..0x821E14C4)
	// 821E14B8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E14BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E14C0: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x821E14C4; continue 'dispatch;
            }
            0x821E14C4 => {
    //   block [0x821E14C4..0x821E14E4)
	// 821E14C4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E14C8: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 821E14CC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E14D0: 3B9C000C  addi r28, r28, 0xc
	ctx.r[28].s64 = ctx.r[28].s64 + 12;
	// 821E14D4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821E14D8: 7D09DBD6  divw r8, r9, r27
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	// 821E14DC: 7F184040  cmplw cr6, r24, r8
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E14E0: 4198FF30  blt cr6, 0x821e1410
	if ctx.cr[6].lt {
	pc = 0x821E1410; continue 'dispatch;
	}
	pc = 0x821E14E4; continue 'dispatch;
            }
            0x821E14E4 => {
    //   block [0x821E14E4..0x821E14EC)
	// 821E14E4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821E14E8: 48AC7F60  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E14F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E14F0 size=776
    let mut pc: u32 = 0x821E14F0;
    'dispatch: loop {
        match pc {
            0x821E14F0 => {
    //   block [0x821E14F0..0x821E15A4)
	// 821E14F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E14F4: 48AC7F01  bl 0x82ca93f4
	ctx.lr = 0x821E14F8;
	sub_82CA93D0(ctx, base);
	// 821E14F8: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E14FC: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821E1500: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821E1504: 3BEB2390  addi r31, r11, 0x2390
	ctx.r[31].s64 = ctx.r[11].s64 + 9104;
	// 821E1508: 390A7E70  addi r8, r10, 0x7e70
	ctx.r[8].s64 = ctx.r[10].s64 + 32368;
	// 821E150C: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 821E1510: 3CC08332  lis r6, -0x7cce
	ctx.r[6].s64 = -2093875200;
	// 821E1514: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821E1518: 817F2004  lwz r11, 0x2004(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E151C: 38A6AC38  addi r5, r6, -0x53c8
	ctx.r[5].s64 = ctx.r[6].s64 + -21448;
	// 821E1520: 38FF2008  addi r7, r31, 0x2008
	ctx.r[7].s64 = ctx.r[31].s64 + 8200;
	// 821E1524: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E1528: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821E152C: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821E1530: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E1534: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821E1538: 9B410050  stb r26, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u8 ) };
	// 821E153C: 7D0BF92E  stwx r8, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[8].u32) };
	// 821E1540: 815F2004  lwz r10, 0x2004(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E1544: 813F2000  lwz r9, 0x2000(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821E1548: 817F400C  lwz r11, 0x400c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821E154C: 55661838  slwi r6, r11, 3
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821E1550: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 821E1554: 552A083C  slwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E1558: 917F2004  stw r11, 0x2004(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8196 as u32), ctx.r[11].u32 ) };
	// 821E155C: 915F2000  stw r10, 0x2000(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8192 as u32), ctx.r[10].u32 ) };
	// 821E1560: 7D06392E  stwx r8, r6, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32), ctx.r[8].u32) };
	// 821E1564: 817F400C  lwz r11, 0x400c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821E1568: 815F4008  lwz r10, 0x4008(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16392 as u32) ) } as u64;
	// 821E156C: 554A083C  slwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E1570: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E1574: 915F4008  stw r10, 0x4008(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16392 as u32), ctx.r[10].u32 ) };
	// 821E1578: 917F400C  stw r11, 0x400c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16396 as u32), ctx.r[11].u32 ) };
	// 821E157C: 48039225  bl 0x8221a7a0
	ctx.lr = 0x821E1580;
	sub_8221A7A0(ctx, base);
	// 821E1580: 817E06FC  lwz r11, 0x6fc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821E1584: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821E1588: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821E158C: 7EFCBB78  mr r28, r23
	ctx.r[28].u64 = ctx.r[23].u64;
	// 821E1590: 831E06F8  lwz r24, 0x6f8(r30)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1784 as u32) ) } as u64;
	// 821E1594: 935E06F8  stw r26, 0x6f8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1784 as u32), ctx.r[26].u32 ) };
	// 821E1598: 419A000C  beq cr6, 0x821e15a4
	if ctx.cr[6].eq {
	pc = 0x821E15A4; continue 'dispatch;
	}
	// 821E159C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821E15A0: 409A002C  bne cr6, 0x821e15cc
	if !ctx.cr[6].eq {
	pc = 0x821E15CC; continue 'dispatch;
	}
	pc = 0x821E15A4; continue 'dispatch;
            }
            0x821E15A4 => {
    //   block [0x821E15A4..0x821E15CC)
	// 821E15A4: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E15A8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821E15AC: 409A0020  bne cr6, 0x821e15cc
	if !ctx.cr[6].eq {
	pc = 0x821E15CC; continue 'dispatch;
	}
	// 821E15B0: 817D0034  lwz r11, 0x34(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 821E15B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821E15B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E15BC: 388B0110  addi r4, r11, 0x110
	ctx.r[4].s64 = ctx.r[11].s64 + 272;
	// 821E15C0: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 821E15C4: 838B0128  lwz r28, 0x128(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(296 as u32) ) } as u64;
	// 821E15C8: 4803F651  bl 0x82220c18
	ctx.lr = 0x821E15CC;
	sub_82220C18(ctx, base);
	pc = 0x821E15CC; continue 'dispatch;
            }
            0x821E15CC => {
    //   block [0x821E15CC..0x821E1630)
	// 821E15CC: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E15D0: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E15D4: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 821E15D8: 7D1C5A14  add r8, r28, r11
	ctx.r[8].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 821E15DC: 39694F30  addi r11, r9, 0x4f30
	ctx.r[11].s64 = ctx.r[9].s64 + 20272;
	// 821E15E0: 5507103A  slwi r7, r8, 2
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821E15E4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821E15E8: 7CC75A14  add r6, r7, r11
	ctx.r[6].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 821E15EC: 80FD0024  lwz r7, 0x24(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E15F0: 390A0050  addi r8, r10, 0x50
	ctx.r[8].s64 = ctx.r[10].s64 + 80;
	// 821E15F4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821E15F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E15FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E1600: 4802A4F9  bl 0x8220baf8
	ctx.lr = 0x821E1604;
	sub_8220BAF8(ctx, base);
	// 821E1604: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E1608: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E160C: 80BD0004  lwz r5, 4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1610: 480414A1  bl 0x82222ab0
	ctx.lr = 0x821E1614;
	sub_82222AB0(ctx, base);
	// 821E1614: 80FE06FC  lwz r7, 0x6fc(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821E1618: 2F070005  cmpwi cr6, r7, 5
	ctx.cr[6].compare_i32(ctx.r[7].s32, 5, &mut ctx.xer);
	// 821E161C: 409A0014  bne cr6, 0x821e1630
	if !ctx.cr[6].eq {
	pc = 0x821E1630; continue 'dispatch;
	}
	// 821E1620: 817B0038  lwz r11, 0x38(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(56 as u32) ) } as u64;
	// 821E1624: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E1628: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 821E162C: 48000068  b 0x821e1694
	pc = 0x821E1694; continue 'dispatch;
            }
            0x821E1630 => {
    //   block [0x821E1630..0x821E1650)
	// 821E1630: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E1634: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1638: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E163C: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821E1640: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E1644: 409A000C  bne cr6, 0x821e1650
	if !ctx.cr[6].eq {
	pc = 0x821E1650; continue 'dispatch;
	}
	// 821E1648: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 821E164C: 48000018  b 0x821e1664
	pc = 0x821E1664; continue 'dispatch;
            }
            0x821E1650 => {
    //   block [0x821E1650..0x821E1664)
	// 821E1650: 896B009B  lbz r11, 0x9b(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(155 as u32) ) } as u64;
	// 821E1654: 7D690034  cntlzw r9, r11
	ctx.r[9].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821E1658: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 821E165C: 690B0001  xori r11, r8, 1
	ctx.r[11].u64 = ctx.r[8].u64 ^ 1;
	// 821E1660: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	pc = 0x821E1664; continue 'dispatch;
            }
            0x821E1664 => {
    //   block [0x821E1664..0x821E1694)
	// 821E1664: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E1668: 554AF7FE  rlwinm r10, r10, 0x1e, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 821E166C: 811B0034  lwz r8, 0x34(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) } as u64;
	// 821E1670: 38EB001C  addi r7, r11, 0x1c
	ctx.r[7].s64 = ctx.r[11].s64 + 28;
	// 821E1674: 54EB083C  slwi r11, r7, 1
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E1678: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E167C: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E1680: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E1684: 7CCB4A14  add r6, r11, r9
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821E1688: 54C5103A  slwi r5, r6, 2
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821E168C: 7C85402E  lwzx r4, r5, r8
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821E1690: 9081007C  stw r4, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[4].u32 ) };
	pc = 0x821E1694; continue 'dispatch;
            }
            0x821E1694 => {
    //   block [0x821E1694..0x821E1754)
	// 821E1694: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E1698: 4802A3F1  bl 0x8220ba88
	ctx.lr = 0x821E169C;
	sub_8220BA88(ctx, base);
	// 821E169C: 3F808336  lis r28, -0x7cca
	ctx.r[28].s64 = -2093613056;
	// 821E16A0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821E16A4: 815D0030  lwz r10, 0x30(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E16A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821E16AC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821E16B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E16B4: 997C05A1  stb r11, 0x5a1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1441 as u32), ctx.r[11].u8 ) };
	// 821E16B8: 808A0004  lwz r4, 4(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E16BC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E16C0: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E16C4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E16C8: 4E800421  bctrl
	ctx.lr = 0x821E16CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E16CC: 891C05A1  lbz r8, 0x5a1(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(1441 as u32) ) } as u64;
	// 821E16D0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E16D4: 419A00A4  beq cr6, 0x821e1778
	if ctx.cr[6].eq {
	pc = 0x821E1778; continue 'dispatch;
	}
	// 821E16D8: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821E16DC: 3D408331  lis r10, -0x7ccf
	ctx.r[10].s64 = -2093940736;
	// 821E16E0: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821E16E4: 392A6FAC  addi r9, r10, 0x6fac
	ctx.r[9].s64 = ctx.r[10].s64 + 28588;
	// 821E16E8: 890B1A25  lbz r8, 0x1a25(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6693 as u32) ) } as u64;
	// 821E16EC: 80E90008  lwz r7, 8(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E16F0: 1D482008  mulli r10, r8, 0x2008
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821E16F4: 812B1A14  lwz r9, 0x1a14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6676 as u32) ) } as u64;
	// 821E16F8: 7D4AFA14  add r10, r10, r31
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[31].u64;
	// 821E16FC: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821E1700: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821E1704: 419A006C  beq cr6, 0x821e1770
	if ctx.cr[6].eq {
	pc = 0x821E1770; continue 'dispatch;
	}
	// 821E1708: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821E170C: 810B1A18  lwz r8, 0x1a18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6680 as u32) ) } as u64;
	// 821E1710: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821E1714: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821E1718: 409A003C  bne cr6, 0x821e1754
	if !ctx.cr[6].eq {
	pc = 0x821E1754; continue 'dispatch;
	}
	// 821E171C: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E1720: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821E1724: 38AB1A10  addi r5, r11, 0x1a10
	ctx.r[5].s64 = ctx.r[11].s64 + 6672;
	// 821E1728: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821E172C: 912B1A18  stw r9, 0x1a18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6680 as u32), ctx.r[9].u32 ) };
	// 821E1730: 7CA4512E  stwx r5, r4, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 821E1734: 812B1A14  lwz r9, 0x1a14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6676 as u32) ) } as u64;
	// 821E1738: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E173C: 54681838  slwi r8, r3, 3
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E1740: 7D085214  add r8, r8, r10
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E1744: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821E1748: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E174C: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821E1750: 90CA2004  stw r6, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[6].u32 ) };
            }
            0x821E1754 => {
    //   block [0x821E1754..0x821E1770)
	// 821E1754: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 821E1758: 90EB1A14  stw r7, 0x1a14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6676 as u32), ctx.r[7].u32 ) };
	// 821E175C: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 821E1760: 994B1A24  stb r10, 0x1a24(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6692 as u32), ctx.r[10].u8 ) };
	// 821E1764: 386B1A10  addi r3, r11, 0x1a10
	ctx.r[3].s64 = ctx.r[11].s64 + 6672;
	// 821E1768: 992B1A1C  stb r9, 0x1a1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6684 as u32), ctx.r[9].u8 ) };
	// 821E176C: 4803CDE5  bl 0x8221e550
	ctx.lr = 0x821E1770;
	sub_8221E550(ctx, base);
	pc = 0x821E1770; continue 'dispatch;
            }
            0x821E1770 => {
    //   block [0x821E1770..0x821E1778)
	// 821E1770: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821E1774: 997C05A1  stb r11, 0x5a1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1441 as u32), ctx.r[11].u8 ) };
	pc = 0x821E1778; continue 'dispatch;
            }
            0x821E1778 => {
    //   block [0x821E1778..0x821E1798)
	// 821E1778: 572B063E  clrlwi r11, r25, 0x18
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 821E177C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E1780: 409A0018  bne cr6, 0x821e1798
	if !ctx.cr[6].eq {
	pc = 0x821E1798; continue 'dispatch;
	}
	// 821E1784: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1788: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E178C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 821E1790: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E1794: 419A0008  beq cr6, 0x821e179c
	if ctx.cr[6].eq {
	pc = 0x821E179C; continue 'dispatch;
	}
	pc = 0x821E1798; continue 'dispatch;
            }
            0x821E1798 => {
    //   block [0x821E1798..0x821E179C)
	// 821E1798: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x821E179C; continue 'dispatch;
            }
            0x821E179C => {
    //   block [0x821E179C..0x821E17D0)
	// 821E179C: 5567063E  clrlwi r7, r11, 0x18
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E17A0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821E17A4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821E17A8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821E17AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E17B0: 4801D3C1  bl 0x821feb70
	ctx.lr = 0x821E17B4;
	sub_821FEB70(ctx, base);
	// 821E17B4: 894100C9  lbz r10, 0xc9(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(201 as u32) ) } as u64;
	// 821E17B8: 931E06F8  stw r24, 0x6f8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(1784 as u32), ctx.r[24].u32 ) };
	// 821E17BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E17C0: 419A0010  beq cr6, 0x821e17d0
	if ctx.cr[6].eq {
	pc = 0x821E17D0; continue 'dispatch;
	}
	// 821E17C4: 9AE100C9  stb r23, 0xc9(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(201 as u32), ctx.r[23].u8 ) };
	// 821E17C8: 387F2008  addi r3, r31, 0x2008
	ctx.r[3].s64 = ctx.r[31].s64 + 8200;
	// 821E17CC: 4803DB7D  bl 0x8221f348
	ctx.lr = 0x821E17D0;
	sub_8221F348(ctx, base);
	pc = 0x821E17D0; continue 'dispatch;
            }
            0x821E17D0 => {
    //   block [0x821E17D0..0x821E17E8)
	// 821E17D0: 894100C8  lbz r10, 0xc8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) } as u64;
	// 821E17D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E17D8: 419A0010  beq cr6, 0x821e17e8
	if ctx.cr[6].eq {
	pc = 0x821E17E8; continue 'dispatch;
	}
	// 821E17DC: 9AE100C8  stb r23, 0xc8(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[23].u8 ) };
	// 821E17E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E17E4: 4803DB65  bl 0x8221f348
	ctx.lr = 0x821E17E8;
	sub_8221F348(ctx, base);
	pc = 0x821E17E8; continue 'dispatch;
            }
            0x821E17E8 => {
    //   block [0x821E17E8..0x821E17F8)
	// 821E17E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E17EC: 4803DAF5  bl 0x8221f2e0
	ctx.lr = 0x821E17F0;
	sub_8221F2E0(ctx, base);
	// 821E17F0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821E17F4: 48AC7C50  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E17F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E17F8 size=80
    let mut pc: u32 = 0x821E17F8;
    'dispatch: loop {
        match pc {
            0x821E17F8 => {
    //   block [0x821E17F8..0x821E1830)
	// 821E17F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E17FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E1800: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E1804: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821E1808: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 821E180C: 390A2A2C  addi r8, r10, 0x2a2c
	ctx.r[8].s64 = ctx.r[10].s64 + 10796;
	// 821E1810: 806B0014  lwz r3, 0x14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E1814: 812B0018  lwz r9, 0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 821E1818: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E181C: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 821E1820: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 821E1824: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821E1828: 419A0008  beq cr6, 0x821e1830
	if ctx.cr[6].eq {
	pc = 0x821E1830; continue 'dispatch;
	}
	// 821E182C: 4801A94D  bl 0x821fc178
	ctx.lr = 0x821E1830;
	sub_821FC178(ctx, base);
	pc = 0x821E1830; continue 'dispatch;
            }
            0x821E1830 => {
    //   block [0x821E1830..0x821E1848)
	// 821E1830: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E1834: 4801AB6D  bl 0x821fc3a0
	ctx.lr = 0x821E1838;
	sub_821FC3A0(ctx, base);
	// 821E1838: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E183C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E1840: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E1844: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E1848 size=144
    let mut pc: u32 = 0x821E1848;
    'dispatch: loop {
        match pc {
            0x821E1848 => {
    //   block [0x821E1848..0x821E186C)
	// 821E1848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E184C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E1850: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821E1854: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E1858: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E185C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E1860: 489EA339  bl 0x82bcbb98
	ctx.lr = 0x821E1864;
	sub_82BCBB98(ctx, base);
	// 821E1864: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E1868: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x821E186C; continue 'dispatch;
            }
            0x821E186C => {
    //   block [0x821E186C..0x821E18D8)
	// 821E186C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1870: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E1874: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E1878: 409AFFF4  bne cr6, 0x821e186c
	if !ctx.cr[6].eq {
	pc = 0x821E186C; continue 'dispatch;
	}
	// 821E187C: 7D655850  subf r11, r5, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	// 821E1880: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821E1884: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E1888: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E188C: 5565003E  slwi r5, r11, 0
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821E1890: 4809A329  bl 0x8227bbb8
	ctx.lr = 0x821E1894;
	sub_8227BBB8(ctx, base);
	// 821E1894: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 821E1898: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 821E189C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821E18A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E18A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E18A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E18AC: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E18B0: 4BFEDE29  bl 0x821cf6d8
	ctx.lr = 0x821E18B4;
	sub_821CF6D8(ctx, base);
	// 821E18B4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E18B8: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 821E18BC: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821E18C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E18C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E18C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E18CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E18D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E18D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E18D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E18D8 size=36
    let mut pc: u32 = 0x821E18D8;
    'dispatch: loop {
        match pc {
            0x821E18D8 => {
    //   block [0x821E18D8..0x821E18FC)
	// 821E18D8: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821E18DC: 3944FFFF  addi r10, r4, -1
	ctx.r[10].s64 = ctx.r[4].s64 + -1;
	// 821E18E0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E18E4: 40980018  bge cr6, 0x821e18fc
	if !ctx.cr[6].lt {
		sub_821E18FC(ctx, base);
		return;
	}
	// 821E18E8: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E18EC: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E18F0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E18F4: 386BFFF8  addi r3, r11, -8
	ctx.r[3].s64 = ctx.r[11].s64 + -8;
	// 821E18F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E18FC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821E18FC size=140
    let mut pc: u32 = 0x821E18FC;
    'dispatch: loop {
        match pc {
            0x821E18FC => {
    //   block [0x821E18FC..0x821E1958)
	// 821E18FC: 7C8B07B4  extsw r11, r4
	ctx.r[11].s64 = ctx.r[4].s32 as i64;
	// 821E1900: 89230007  lbz r9, 7(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(7 as u32) ) } as u64;
	// 821E1904: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821E1908: 81430010  lwz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E190C: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821E1910: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 821E1914: 7D0B4830  slw r11, r8, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[8].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 821E1918: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 821E191C: C1A79490  lfs f13, -0x6b70(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E1920: 60C50001  ori r5, r6, 1
	ctx.r[5].u64 = ctx.r[6].u64 | 1;
	// 821E1924: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E1928: FD80069C  fcfid f12, f0
	ctx.f[12].f64 = (ctx.f[0].s64 as f64);
	// 821E192C: FC006018  frsp f0, f12
	ctx.f[0].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821E1930: ED60682A  fadds f11, f0, f13
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821E1934: D161FFF0  stfs f11, -0x10(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 821E1938: 8161FFF0  lwz r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 821E193C: 7C8B2B96  divwu r4, r11, r5
	ctx.r[4].u32 = ctx.r[11].u32 / ctx.r[5].u32;
	// 821E1940: 7C6429D6  mullw r3, r4, r5
	ctx.r[3].s32 = ((ctx.r[4].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 821E1944: 7D635850  subf r11, r3, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 821E1948: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E194C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821E1950: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E1954: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x821E1958; continue 'dispatch;
            }
            0x821E1958 => {
    //   block [0x821E1958..0x821E1970)
	// 821E1958: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E195C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821E1960: 409A0010  bne cr6, 0x821e1970
	if !ctx.cr[6].eq {
	pc = 0x821E1970; continue 'dispatch;
	}
	// 821E1964: C1A30008  lfs f13, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E1968: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821E196C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x821E1970; continue 'dispatch;
            }
            0x821E1970 => {
    //   block [0x821E1970..0x821E1988)
	// 821E1970: 80630010  lwz r3, 0x10(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E1974: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E1978: 409AFFE0  bne cr6, 0x821e1958
	if !ctx.cr[6].eq {
	pc = 0x821E1958; continue 'dispatch;
	}
	// 821E197C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821E1980: 386B06F4  addi r3, r11, 0x6f4
	ctx.r[3].s64 = ctx.r[11].s64 + 1780;
	// 821E1984: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E1988 size=88
    let mut pc: u32 = 0x821E1988;
    'dispatch: loop {
        match pc {
            0x821E1988 => {
    //   block [0x821E1988..0x821E19E0)
	// 821E1988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E198C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E1990: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E1994: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E1998: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E199C: 489EA1FD  bl 0x82bcbb98
	ctx.lr = 0x821E19A0;
	sub_82BCBB98(ctx, base);
	// 821E19A0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 821E19A4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E19A8: 4BFFFF31  bl 0x821e18d8
	ctx.lr = 0x821E19AC;
	sub_821E18D8(ctx, base);
	// 821E19AC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E19B0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E19B4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821E19B8: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E19BC: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821E19C0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E19C4: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 821E19C8: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821E19CC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E19D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E19D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E19D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E19DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E19E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E19E0 size=452
    let mut pc: u32 = 0x821E19E0;
    'dispatch: loop {
        match pc {
            0x821E19E0 => {
    //   block [0x821E19E0..0x821E1AB8)
	// 821E19E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E19E4: 48AC7A21  bl 0x82ca9404
	ctx.lr = 0x821E19E8;
	sub_82CA93D0(ctx, base);
	// 821E19E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E19EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E19F0: 3D6082BC  lis r11, -0x7d44
	ctx.r[11].s64 = -2101608448;
	// 821E19F4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E19F8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821E19FC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E1A00: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1A04: 388B9118  addi r4, r11, -0x6ee8
	ctx.r[4].s64 = ctx.r[11].s64 + -28392;
	// 821E1A08: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1A0C: 8123000C  lwz r9, 0xc(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E1A10: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821E1A14: 7D1D1E70  srawi r29, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821E1A18: 48099F51  bl 0x8227b968
	ctx.lr = 0x821E1A1C;
	sub_8227B968(ctx, base);
	// 821E1A1C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821E1A20: 837F0004  lwz r27, 4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1A24: 817B0010  lwz r11, 0x10(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E1A28: 806B005C  lwz r3, 0x5c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 821E1A2C: 4BFFFEAD  bl 0x821e18d8
	ctx.lr = 0x821E1A30;
	sub_821E18D8(ctx, base);
	// 821E1A30: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1A34: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E1A38: 80FB0008  lwz r7, 8(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1A3C: 90C70000  stw r6, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 821E1A40: 80A30004  lwz r5, 4(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1A44: 90A70004  stw r5, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 821E1A48: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1A4C: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 821E1A50: 907B0008  stw r3, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 821E1A54: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1A58: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1A5C: 806BFFF8  lwz r3, -8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E1A60: 4BFFFE79  bl 0x821e18d8
	ctx.lr = 0x821E1A64;
	sub_821E18D8(ctx, base);
	// 821E1A64: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1A68: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1A6C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821E1A70: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 821E1A74: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821E1A78: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1A7C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821E1A80: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1A84: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 821E1A88: 911E0008  stw r8, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821E1A8C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1A90: 4BFFFDB9  bl 0x821e1848
	ctx.lr = 0x821E1A94;
	sub_821E1848(ctx, base);
	// 821E1A94: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1A98: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1A9C: 3CE08209  lis r7, -0x7df7
	ctx.r[7].s64 = -2113339392;
	// 821E1AA0: 38C706F4  addi r6, r7, 0x6f4
	ctx.r[6].s64 = ctx.r[7].s64 + 1780;
	// 821E1AA4: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 821E1AA8: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E1AAC: 409A000C  bne cr6, 0x821e1ab8
	if !ctx.cr[6].eq {
	pc = 0x821E1AB8; continue 'dispatch;
	}
	// 821E1AB0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821E1AB4: 48000008  b 0x821e1abc
	pc = 0x821E1ABC; continue 'dispatch;
            }
            0x821E1AB8 => {
    //   block [0x821E1AB8..0x821E1ABC)
	// 821E1AB8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x821E1ABC; continue 'dispatch;
            }
            0x821E1ABC => {
    //   block [0x821E1ABC..0x821E1B4C)
	// 821E1ABC: 396BFFFA  addi r11, r11, -6
	ctx.r[11].s64 = ctx.r[11].s64 + -6;
	// 821E1AC0: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821E1AC4: 555CDFFE  rlwinm r28, r10, 0x1b, 0x1f, 0x1f
	ctx.r[28].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821E1AC8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821E1ACC: 419A00C0  beq cr6, 0x821e1b8c
	if ctx.cr[6].eq {
	pc = 0x821E1B8C; continue 'dispatch;
	}
	// 821E1AD0: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821E1AD4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821E1AD8: 388A0DA8  addi r4, r10, 0xda8
	ctx.r[4].s64 = ctx.r[10].s64 + 3496;
	// 821E1ADC: 80ABD9FC  lwz r5, -0x2604(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9732 as u32) ) } as u64;
	// 821E1AE0: 4BFBB221  bl 0x8219cd00
	ctx.lr = 0x821E1AE4;
	sub_8219CD00(ctx, base);
	// 821E1AE4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1AE8: 3880D8EE  li r4, -0x2712
	ctx.r[4].s64 = -10002;
	// 821E1AEC: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1AF0: 80E8FFE8  lwz r7, -0x18(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-24 as u32) ) } as u64;
	// 821E1AF4: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821E1AF8: 80C8FFEC  lwz r6, -0x14(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-20 as u32) ) } as u64;
	// 821E1AFC: 90C80004  stw r6, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821E1B00: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1B04: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 821E1B08: 90A90008  stw r5, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 821E1B0C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1B10: 480C45C9  bl 0x822a60d8
	ctx.lr = 0x821E1B14;
	sub_822A60D8(ctx, base);
	// 821E1B14: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1B18: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1B1C: 349D0001  addic. r4, r29, 1
	ctx.xer.ca = (ctx.r[29].u32 > (!(1 as u32)));
	ctx.r[4].s64 = ctx.r[29].s64 + 1;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821E1B20: 814BFFF0  lwz r10, -0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 821E1B24: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821E1B28: 812BFFF4  lwz r9, -0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821E1B2C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821E1B30: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1B34: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 821E1B38: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821E1B3C: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1B40: 4082000C  bne 0x821e1b4c
	if !ctx.cr[0].eq {
	pc = 0x821E1B4C; continue 'dispatch;
	}
	// 821E1B44: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821E1B48: 48000014  b 0x821e1b5c
	pc = 0x821E1B5C; continue 'dispatch;
            }
            0x821E1B4C => {
    //   block [0x821E1B4C..0x821E1B5C)
	// 821E1B4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E1B50: 489EA049  bl 0x82bcbb98
	ctx.lr = 0x821E1B54;
	sub_82BCBB98(ctx, base);
	// 821E1B54: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E1B58: 7CEB1850  subf r7, r11, r3
	ctx.r[7].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	pc = 0x821E1B5C; continue 'dispatch;
            }
            0x821E1B5C => {
    //   block [0x821E1B5C..0x821E1B8C)
	// 821E1B5C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1B60: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821E1B64: 813E0020  lwz r9, 0x20(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E1B68: 3D0082BD  lis r8, -0x7d43
	ctx.r[8].s64 = -2101542912;
	// 821E1B6C: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 821E1B70: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E1B74: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821E1B78: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821E1B7C: 3888C870  addi r4, r8, -0x3790
	ctx.r[4].s64 = ctx.r[8].s64 + -14224;
	// 821E1B80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E1B84: 7CC95850  subf r6, r9, r11
	ctx.r[6].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E1B88: 480DE9E9  bl 0x822c0570
	ctx.lr = 0x821E1B8C;
	sub_822C0570(ctx, base);
	pc = 0x821E1B8C; continue 'dispatch;
            }
            0x821E1B8C => {
    //   block [0x821E1B8C..0x821E1BA4)
	// 821E1B8C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821E1B90: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1B94: 489EA175  bl 0x82bcbd08
	ctx.lr = 0x821E1B98;
	sub_82BCBD08(ctx, base);
	// 821E1B98: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821E1B9C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821E1BA0: 48AC78B4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E1BA8 size=100
    let mut pc: u32 = 0x821E1BA8;
    'dispatch: loop {
        match pc {
            0x821E1BA8 => {
    //   block [0x821E1BA8..0x821E1BD8)
	// 821E1BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E1BAC: 48AC7861  bl 0x82ca940c
	ctx.lr = 0x821E1BB0;
	sub_82CA93D0(ctx, base);
	// 821E1BB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E1BB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E1BB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E1BBC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821E1BC0: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E1BC4: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821E1BC8: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821E1BCC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821E1BD0: 41980008  blt cr6, 0x821e1bd8
	if ctx.cr[6].lt {
	pc = 0x821E1BD8; continue 'dispatch;
	}
	// 821E1BD4: 4BF979AD  bl 0x82179580
	ctx.lr = 0x821E1BD8;
	sub_82179580(ctx, base);
	pc = 0x821E1BD8; continue 'dispatch;
            }
            0x821E1BD8 => {
    //   block [0x821E1BD8..0x821E1C0C)
	// 821E1BD8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821E1BDC: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1BE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E1BE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E1BE8: 48045AB9  bl 0x822276a0
	ctx.lr = 0x821E1BEC;
	sub_822276A0(ctx, base);
	// 821E1BEC: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821E1BF0: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821E1BF4: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821E1BF8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1BFC: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 821E1C00: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821E1C04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E1C08: 48AC7854  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1C10 size=312
    let mut pc: u32 = 0x821E1C10;
    'dispatch: loop {
        match pc {
            0x821E1C10 => {
    //   block [0x821E1C10..0x821E1D48)
	// 821E1C10: 39200820  li r9, 0x820
	ctx.r[9].s64 = 2080;
	// 821E1C14: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1C18: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E1D48 size=288
    let mut pc: u32 = 0x821E1D48;
    'dispatch: loop {
        match pc {
            0x821E1D48 => {
    //   block [0x821E1D48..0x821E1DC4)
	// 821E1D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E1D4C: 48AC76BD  bl 0x82ca9408
	ctx.lr = 0x821E1D50;
	sub_82CA93D0(ctx, base);
	// 821E1D50: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 821E1D54: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 821E1D58: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821E1D5C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E1D60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E1D64: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821E1D68: 897F0024  lbz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E1D6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E1D70: 419A00E4  beq cr6, 0x821e1e54
	if ctx.cr[6].eq {
	pc = 0x821E1E54; continue 'dispatch;
	}
	// 821E1D74: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1D78: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1D7C: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E1D80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E1D84: 4E800421  bctrl
	ctx.lr = 0x821E1D88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E1D88: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1D8C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E1D90: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1D94: 8109001C  lwz r8, 0x1c(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 821E1D98: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821E1D9C: 4E800421  bctrl
	ctx.lr = 0x821E1DA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E1DA0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E1DA4: 3FC0820A  lis r30, -0x7df6
	ctx.r[30].s64 = -2113273856;
	// 821E1DA8: 396B9484  addi r11, r11, -0x6b7c
	ctx.r[11].s64 = ctx.r[11].s64 + -27516;
	// 821E1DAC: C1BE9A80  lfs f13, -0x6580(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E1DB0: C3CB000C  lfs f30, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821E1DB4: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 821E1DB8: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 821E1DBC: 40990008  ble cr6, 0x821e1dc4
	if !ctx.cr[6].gt {
	pc = 0x821E1DC4; continue 'dispatch;
	}
	// 821E1DC0: EC01F824  fdivs f0, f1, f31
	ctx.f[0].f64 = ((ctx.f[1].f64 / ctx.f[31].f64) as f32) as f64;
            }
            0x821E1DC4 => {
    //   block [0x821E1DC4..0x821E1E40)
	// 821E1DC4: C3EB0000  lfs f31, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821E1DC8: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 821E1DCC: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821E1DD0: 7D400026  mfcr r10
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[10].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[10].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821E1DD4: 5549DF7A  rlwinm r9, r10, 0x1b, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821E1DD8: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1DDC: 5547F77A  rlwinm r7, r10, 0x1e, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 821E1DE0: 3B8B0E68  addi r28, r11, 0xe68
	ctx.r[28].s64 = ctx.r[11].s64 + 3688;
	// 821E1DE4: 7D263B78  or r6, r9, r7
	ctx.r[6].u64 = ctx.r[9].u64 | ctx.r[7].u64;
	// 821E1DE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E1DEC: 80A80024  lwz r5, 0x24(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E1DF0: 7DBC342E  lfsx f13, r28, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E1DF4: FFADF82E  fsel f29, f13, f0, f31
	ctx.f[29].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[31].f64 };
	// 821E1DF8: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 821E1DFC: 4E800421  bctrl
	ctx.lr = 0x821E1E00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E1E00: ED9DF028  fsubs f12, f29, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[29].f64 - ctx.f[30].f64) as f32) as f64);
	// 821E1E04: FC000890  fmr f0, f1
	ctx.f[0].f64 = ctx.f[1].f64;
	// 821E1E08: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 821E1E0C: 7C800026  mfcr r4
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[4].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821E1E10: 5483DF7A  rlwinm r3, r4, 0x1b, 0x1d, 0x1d
	ctx.r[3].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 821E1E14: 548BF77A  rlwinm r11, r4, 0x1e, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000003u64;
	// 821E1E18: 7C6A5B78  or r10, r3, r11
	ctx.r[10].u64 = ctx.r[3].u64 | ctx.r[11].u64;
	// 821E1E1C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1E20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E1E24: 7D7C542E  lfsx f11, r28, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821E1E28: FD4BEFAE  fsel f10, f11, f30, f29
	ctx.f[10].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[29].f64 };
	// 821E1E2C: EC2A0032  fmuls f1, f10, f0
	ctx.f[1].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821E1E30: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821E1E34: 4098000C  bge cr6, 0x821e1e40
	if !ctx.cr[6].lt {
	pc = 0x821E1E40; continue 'dispatch;
	}
	// 821E1E38: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E1E3C: 48000010  b 0x821e1e4c
	pc = 0x821E1E4C; continue 'dispatch;
            }
            0x821E1E40 => {
    //   block [0x821E1E40..0x821E1E4C)
	// 821E1E40: C1BE9A80  lfs f13, -0x6580(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E1E44: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821E1E48: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x821E1E4C; continue 'dispatch;
            }
            0x821E1E4C => {
    //   block [0x821E1E4C..0x821E1E54)
	// 821E1E4C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E1E50: 4E800421  bctrl
	ctx.lr = 0x821E1E54;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821E1E54 => {
    //   block [0x821E1E54..0x821E1E68)
	// 821E1E54: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821E1E58: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821E1E5C: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821E1E60: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821E1E64: 48AC75F4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1E68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E1E68 size=88
    let mut pc: u32 = 0x821E1E68;
    'dispatch: loop {
        match pc {
            0x821E1E68 => {
    //   block [0x821E1E68..0x821E1EB4)
	// 821E1E68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E1E6C: 48AC75A1  bl 0x82ca940c
	ctx.lr = 0x821E1E70;
	sub_82CA93D0(ctx, base);
	// 821E1E70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E1E74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E1E78: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821E1E7C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821E1E80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1E84: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E1E88: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E1E8C: 4E800421  bctrl
	ctx.lr = 0x821E1E90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E1E90: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821E1E94: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E1E98: 419A001C  beq cr6, 0x821e1eb4
	if ctx.cr[6].eq {
	pc = 0x821E1EB4; continue 'dispatch;
	}
	// 821E1E9C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821E1EA0: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 821E1EA4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E1EA8: 48673579  bl 0x82855420
	ctx.lr = 0x821E1EAC;
	sub_82855420(ctx, base);
	// 821E1EAC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E1EB0: 48AC75AC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821E1EB4 => {
    //   block [0x821E1EB4..0x821E1EC0)
	// 821E1EB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E1EB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E1EBC: 48AC75A0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1EC0 size=36
    let mut pc: u32 = 0x821E1EC0;
    'dispatch: loop {
        match pc {
            0x821E1EC0 => {
    //   block [0x821E1EC0..0x821E1EDC)
	// 821E1EC0: 89640706  lbz r11, 0x706(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(1798 as u32) ) } as u64;
	// 821E1EC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E1EC8: 409A0014  bne cr6, 0x821e1edc
	if !ctx.cr[6].eq {
	pc = 0x821E1EDC; continue 'dispatch;
	}
	// 821E1ECC: 89640707  lbz r11, 0x707(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(1799 as u32) ) } as u64;
	// 821E1ED0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E1ED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E1ED8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x821E1EDC; continue 'dispatch;
            }
            0x821E1EDC => {
    //   block [0x821E1EDC..0x821E1EE4)
	// 821E1EDC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821E1EE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E1EE8 size=80
    let mut pc: u32 = 0x821E1EE8;
    'dispatch: loop {
        match pc {
            0x821E1EE8 => {
    //   block [0x821E1EE8..0x821E1EF8)
	// 821E1EE8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E1EEC: 394B5034  addi r10, r11, 0x5034
	ctx.r[10].s64 = ctx.r[11].s64 + 20532;
	// 821E1EF0: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1EF4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821E1EF8; continue 'dispatch;
            }
            0x821E1EF8 => {
    //   block [0x821E1EF8..0x821E1F1C)
	// 821E1EF8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E1EFC: 419A003C  beq cr6, 0x821e1f38
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x821E1F38);
		return;
	}
	// 821E1F00: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1F04: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1F08: 7F081840  cmplw cr6, r8, r3
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821E1F0C: 419A0018  beq cr6, 0x821e1f24
	if ctx.cr[6].eq {
	pc = 0x821E1F24; continue 'dispatch;
	}
	// 821E1F10: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E1F14: 409A0008  bne cr6, 0x821e1f1c
	if !ctx.cr[6].eq {
	pc = 0x821E1F1C; continue 'dispatch;
	}
	// 821E1F18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E1F1C; continue 'dispatch;
            }
            0x821E1F1C => {
    //   block [0x821E1F1C..0x821E1F24)
	// 821E1F1C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1F20: 4BFFFFD8  b 0x821e1ef8
	pc = 0x821E1EF8; continue 'dispatch;
            }
            0x821E1F24 => {
    //   block [0x821E1F24..0x821E1F30)
	// 821E1F24: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E1F28: 409A0008  bne cr6, 0x821e1f30
	if !ctx.cr[6].eq {
	pc = 0x821E1F30; continue 'dispatch;
	}
	// 821E1F2C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E1F30; continue 'dispatch;
            }
            0x821E1F30 => {
    //   block [0x821E1F30..0x821E1F38)
	// 821E1F30: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1F34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E1F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E1F40 size=404
    let mut pc: u32 = 0x821E1F40;
    'dispatch: loop {
        match pc {
            0x821E1F40 => {
    //   block [0x821E1F40..0x821E1FC4)
	// 821E1F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E1F44: 48AC74BD  bl 0x82ca9400
	ctx.lr = 0x821E1F48;
	sub_82CA93D0(ctx, base);
	// 821E1F48: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 821E1F4C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E1F50: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821E1F54: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E1F58: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821E1F5C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821E1F60: 93C100CC  stw r30, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[30].u32 ) };
	// 821E1F64: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 821E1F68: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E1F6C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1F70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E1F74: 4E800421  bctrl
	ctx.lr = 0x821E1F78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E1F78: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821E1F7C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821E1F80: 419A0144  beq cr6, 0x821e20c4
	if ctx.cr[6].eq {
	pc = 0x821E20C4; continue 'dispatch;
	}
	// 821E1F84: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 821E1F88: 409A0064  bne cr6, 0x821e1fec
	if !ctx.cr[6].eq {
	pc = 0x821E1FEC; continue 'dispatch;
	}
	// 821E1F8C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E1F90: 3BEBF850  addi r31, r11, -0x7b0
	ctx.r[31].s64 = ctx.r[11].s64 + -1968;
	// 821E1F94: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E1F98: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821E1F9C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E1FA0: 7D291671  srawi. r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821E1FA4: 40820020  bne 0x821e1fc4
	if !ctx.cr[0].eq {
	pc = 0x821E1FC4; continue 'dispatch;
	}
	// 821E1FA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E1FAC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821E1FB0: 488AD739  bl 0x82a8f6e8
	ctx.lr = 0x821E1FB4;
	sub_82A8F6E8(ctx, base);
	// 821E1FB4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E1FB8: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821E1FBC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E1FC0: 7D291670  srawi r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
            }
            0x821E1FC4 => {
    //   block [0x821E1FC4..0x821E1FE8)
	// 821E1FC4: 5529103A  slwi r9, r9, 2
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E1FC8: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E1FCC: 7CE95A14  add r7, r9, r11
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821E1FD0: 5506003A  rlwinm r6, r8, 0, 0, 0x1d
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821E1FD4: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821E1FD8: 83C7FFFC  lwz r30, -4(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821E1FDC: 419A000C  beq cr6, 0x821e1fe8
	if ctx.cr[6].eq {
	pc = 0x821E1FE8; continue 'dispatch;
	}
	// 821E1FE0: 396AFFFC  addi r11, r10, -4
	ctx.r[11].s64 = ctx.r[10].s64 + -4;
	// 821E1FE4: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x821E1FE8; continue 'dispatch;
            }
            0x821E1FE8 => {
    //   block [0x821E1FE8..0x821E1FEC)
	// 821E1FE8: 93C100CC  stw r30, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[30].u32 ) };
	pc = 0x821E1FEC; continue 'dispatch;
            }
            0x821E1FEC => {
    //   block [0x821E1FEC..0x821E2044)
	// 821E1FEC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E1FF0: 3BEBF7A8  addi r31, r11, -0x858
	ctx.r[31].s64 = ctx.r[11].s64 + -2136;
	// 821E1FF4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E1FF8: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E1FFC: 7D694050  subf r11, r9, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 821E2000: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 821E2004: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E2008: 41980054  blt cr6, 0x821e205c
	if ctx.cr[6].lt {
	pc = 0x821E205C; continue 'dispatch;
	}
	// 821E200C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821E2010: 395E0001  addi r10, r30, 1
	ctx.r[10].s64 = ctx.r[30].s64 + 1;
	// 821E2014: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 821E2018: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E201C: 40990028  ble cr6, 0x821e2044
	if !ctx.cr[6].gt {
	pc = 0x821E2044; continue 'dispatch;
	}
	// 821E2020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E2024: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 821E2028: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821E202C: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 821E2030: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E2034: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821E2038: 4886D8A1  bl 0x82a4f8d8
	ctx.lr = 0x821E203C;
	sub_82A4F8D8(ctx, base);
	// 821E203C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E2040: 4800001C  b 0x821e205c
	pc = 0x821E205C; continue 'dispatch;
            }
            0x821E2044 => {
    //   block [0x821E2044..0x821E205C)
	// 821E2044: 40980018  bge cr6, 0x821e205c
	if !ctx.cr[6].lt {
	pc = 0x821E205C; continue 'dispatch;
	}
	// 821E2048: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E204C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821E2050: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E2054: 419A0008  beq cr6, 0x821e205c
	if ctx.cr[6].eq {
	pc = 0x821E205C; continue 'dispatch;
	}
	// 821E2058: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x821E205C; continue 'dispatch;
            }
            0x821E205C => {
    //   block [0x821E205C..0x821E20C4)
	// 821E205C: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E2060: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E2064: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821E2068: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E206C: 7FAB492E  stwx r29, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[29].u32) };
	// 821E2070: 93DD0010  stw r30, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 821E2074: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E2078: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E207C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E2080: 4E800421  bctrl
	ctx.lr = 0x821E2084;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E2084: 811D0000  lwz r8, 0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E2088: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821E208C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E2090: 80E80038  lwz r7, 0x38(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(56 as u32) ) } as u64;
	// 821E2094: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821E2098: 4E800421  bctrl
	ctx.lr = 0x821E209C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E209C: 80DC0004  lwz r6, 4(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E20A0: 54C5077A  rlwinm r5, r6, 0, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 821E20A4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821E20A8: 419A001C  beq cr6, 0x821e20c4
	if ctx.cr[6].eq {
	pc = 0x821E20C4; continue 'dispatch;
	}
	// 821E20AC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821E20B0: 574B2036  slwi r11, r26, 4
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E20B4: 394AF970  addi r10, r10, -0x690
	ctx.r[10].s64 = ctx.r[10].s64 + -1680;
	// 821E20B8: 388100CC  addi r4, r1, 0xcc
	ctx.r[4].s64 = ctx.r[1].s64 + 204;
	// 821E20BC: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E20C0: 4817FAA9  bl 0x82361b68
	ctx.lr = 0x821E20C4;
	sub_82361B68(ctx, base);
            }
            0x821E20C4 => {
    //   block [0x821E20C4..0x821E20D4)
	// 821E20C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E20C8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821E20CC: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 821E20D0: 48AC7380  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E20D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E20D8 size=100
    let mut pc: u32 = 0x821E20D8;
    'dispatch: loop {
        match pc {
            0x821E20D8 => {
    //   block [0x821E20D8..0x821E2114)
	// 821E20D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E20DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E20E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821E20E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E20E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E20EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E20F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E20F4: 807E00B0  lwz r3, 0xb0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 821E20F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E20FC: 419A0018  beq cr6, 0x821e2114
	if ctx.cr[6].eq {
	pc = 0x821E2114; continue 'dispatch;
	}
	// 821E2100: 4801D0C9  bl 0x821ff1c8
	ctx.lr = 0x821E2104;
	sub_821FF1C8(ctx, base);
	// 821E2104: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E2108: 809E00B0  lwz r4, 0xb0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) } as u64;
	// 821E210C: 4805126D  bl 0x82233378
	ctx.lr = 0x821E2110;
	sub_82233378(ctx, base);
	// 821E2110: 48000010  b 0x821e2120
	pc = 0x821E2120; continue 'dispatch;
            }
            0x821E2114 => {
    //   block [0x821E2114..0x821E2120)
	// 821E2114: 389E0150  addi r4, r30, 0x150
	ctx.r[4].s64 = ctx.r[30].s64 + 336;
	// 821E2118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E211C: 48029375  bl 0x8220b490
	ctx.lr = 0x821E2120;
	sub_8220B490(ctx, base);
	pc = 0x821E2120; continue 'dispatch;
            }
            0x821E2120 => {
    //   block [0x821E2120..0x821E213C)
	// 821E2120: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E2124: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E2128: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E212C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E2130: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E2134: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E2138: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E2140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E2140 size=1548
    let mut pc: u32 = 0x821E2140;
    'dispatch: loop {
        match pc {
            0x821E2140 => {
    //   block [0x821E2140..0x821E21BC)
	// 821E2140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E2144: 48AC72B9  bl 0x82ca93fc
	ctx.lr = 0x821E2148;
	sub_82CA93D0(ctx, base);
	// 821E2148: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 821E214C: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 821E2150: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E2154: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821E2158: 817B002C  lwz r11, 0x2c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E215C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821E2160: 419A05DC  beq cr6, 0x821e273c
	if ctx.cr[6].eq {
	pc = 0x821E273C; continue 'dispatch;
	}
	// 821E2164: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E2168: 48025689  bl 0x822077f0
	ctx.lr = 0x821E216C;
	sub_822077F0(ctx, base);
	// 821E216C: 80BB0004  lwz r5, 4(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E2170: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821E2174: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821E2178: 7F9AE378  mr r26, r28
	ctx.r[26].u64 = ctx.r[28].u64;
	// 821E217C: 7F99E378  mr r25, r28
	ctx.r[25].u64 = ctx.r[28].u64;
	// 821E2180: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821E2184: 81450028  lwz r10, 0x28(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) } as u64;
	// 821E2188: 554927FE  rlwinm r9, r10, 4, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0FFFFFFFu64;
	// 821E218C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E2190: 419A00E8  beq cr6, 0x821e2278
	if ctx.cr[6].eq {
	pc = 0x821E2278; continue 'dispatch;
	}
	// 821E2194: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E2198: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E219C: 419A0020  beq cr6, 0x821e21bc
	if ctx.cr[6].eq {
	pc = 0x821E21BC; continue 'dispatch;
	}
	// 821E21A0: 894B003C  lbz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821E21A4: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E21A8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821E21AC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E21B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E21B4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E21B8: 480000C4  b 0x821e227c
	pc = 0x821E227C; continue 'dispatch;
            }
            0x821E21BC => {
    //   block [0x821E21BC..0x821E21D8)
	// 821E21BC: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E21C0: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E21C4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821E21C8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E21CC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E21D0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E21D4: 40810054  ble 0x821e2228
	if !ctx.cr[0].gt {
	pc = 0x821E2228; continue 'dispatch;
	}
	pc = 0x821E21D8; continue 'dispatch;
            }
            0x821E21D8 => {
    //   block [0x821E21D8..0x821E21F8)
	// 821E21D8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E21DC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E21E0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E21E4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E21E8: 2F07003C  cmpwi cr6, r7, 0x3c
	ctx.cr[6].compare_i32(ctx.r[7].s32, 60, &mut ctx.xer);
	// 821E21EC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E21F0: 41980008  blt cr6, 0x821e21f8
	if ctx.cr[6].lt {
	pc = 0x821E21F8; continue 'dispatch;
	}
	// 821E21F4: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x821E21F8; continue 'dispatch;
            }
            0x821E21F8 => {
    //   block [0x821E21F8..0x821E2214)
	// 821E21F8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E21FC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E2200: 419A0014  beq cr6, 0x821e2214
	if ctx.cr[6].eq {
	pc = 0x821E2214; continue 'dispatch;
	}
	// 821E2204: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E2208: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E220C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E2210: 4800000C  b 0x821e221c
	pc = 0x821E221C; continue 'dispatch;
            }
            0x821E2214 => {
    //   block [0x821E2214..0x821E221C)
	// 821E2214: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E2218: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821E221C; continue 'dispatch;
            }
            0x821E221C => {
    //   block [0x821E221C..0x821E2228)
	// 821E221C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E2220: 4199FFB8  bgt cr6, 0x821e21d8
	if ctx.cr[6].gt {
	pc = 0x821E21D8; continue 'dispatch;
	}
	// 821E2224: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821E2228; continue 'dispatch;
            }
            0x821E2228 => {
    //   block [0x821E2228..0x821E2244)
	// 821E2228: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E222C: 419A003C  beq cr6, 0x821e2268
	if ctx.cr[6].eq {
	pc = 0x821E2268; continue 'dispatch;
	}
	// 821E2230: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E2234: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 821E2238: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E223C: 41990008  bgt cr6, 0x821e2244
	if ctx.cr[6].gt {
	pc = 0x821E2244; continue 'dispatch;
	}
	// 821E2240: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821E2244; continue 'dispatch;
            }
            0x821E2244 => {
    //   block [0x821E2244..0x821E2268)
	// 821E2244: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E2248: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E224C: 409A001C  bne cr6, 0x821e2268
	if !ctx.cr[6].eq {
	pc = 0x821E2268; continue 'dispatch;
	}
	// 821E2250: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E2254: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E2258: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821E225C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E2260: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E2264: 48000018  b 0x821e227c
	pc = 0x821E227C; continue 'dispatch;
            }
            0x821E2268 => {
    //   block [0x821E2268..0x821E2278)
	// 821E2268: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E226C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E2270: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E2274: 48000008  b 0x821e227c
	pc = 0x821E227C; continue 'dispatch;
            }
            0x821E2278 => {
    //   block [0x821E2278..0x821E227C)
	// 821E2278: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x821E227C; continue 'dispatch;
            }
            0x821E227C => {
    //   block [0x821E227C..0x821E2298)
	// 821E227C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821E2280: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E2284: 419A0014  beq cr6, 0x821e2298
	if ctx.cr[6].eq {
	pc = 0x821E2298; continue 'dispatch;
	}
	// 821E2288: 816B00A8  lwz r11, 0xa8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 821E228C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821E2290: 409A0120  bne cr6, 0x821e23b0
	if !ctx.cr[6].eq {
	pc = 0x821E23B0; continue 'dispatch;
	}
	// 821E2294: 48000118  b 0x821e23ac
	pc = 0x821E23AC; continue 'dispatch;
            }
            0x821E2298 => {
    //   block [0x821E2298..0x821E22D4)
	// 821E2298: 81450028  lwz r10, 0x28(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) } as u64;
	// 821E229C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821E22A0: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821E22A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E22A8: 419A00E8  beq cr6, 0x821e2390
	if ctx.cr[6].eq {
	pc = 0x821E2390; continue 'dispatch;
	}
	// 821E22AC: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E22B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E22B4: 419A0020  beq cr6, 0x821e22d4
	if ctx.cr[6].eq {
	pc = 0x821E22D4; continue 'dispatch;
	}
	// 821E22B8: 894B0020  lbz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E22BC: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E22C0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821E22C4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E22C8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E22CC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E22D0: 480000C4  b 0x821e2394
	pc = 0x821E2394; continue 'dispatch;
            }
            0x821E22D4 => {
    //   block [0x821E22D4..0x821E22F0)
	// 821E22D4: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E22D8: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E22DC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821E22E0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E22E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E22E8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E22EC: 40810054  ble 0x821e2340
	if !ctx.cr[0].gt {
	pc = 0x821E2340; continue 'dispatch;
	}
	pc = 0x821E22F0; continue 'dispatch;
            }
            0x821E22F0 => {
    //   block [0x821E22F0..0x821E2310)
	// 821E22F0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E22F4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E22F8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E22FC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E2300: 2F070020  cmpwi cr6, r7, 0x20
	ctx.cr[6].compare_i32(ctx.r[7].s32, 32, &mut ctx.xer);
	// 821E2304: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E2308: 41980008  blt cr6, 0x821e2310
	if ctx.cr[6].lt {
	pc = 0x821E2310; continue 'dispatch;
	}
	// 821E230C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x821E2310; continue 'dispatch;
            }
            0x821E2310 => {
    //   block [0x821E2310..0x821E232C)
	// 821E2310: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E2314: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E2318: 419A0014  beq cr6, 0x821e232c
	if ctx.cr[6].eq {
	pc = 0x821E232C; continue 'dispatch;
	}
	// 821E231C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E2320: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E2324: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E2328: 4800000C  b 0x821e2334
	pc = 0x821E2334; continue 'dispatch;
            }
            0x821E232C => {
    //   block [0x821E232C..0x821E2334)
	// 821E232C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E2330: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821E2334; continue 'dispatch;
            }
            0x821E2334 => {
    //   block [0x821E2334..0x821E2340)
	// 821E2334: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E2338: 4199FFB8  bgt cr6, 0x821e22f0
	if ctx.cr[6].gt {
	pc = 0x821E22F0; continue 'dispatch;
	}
	// 821E233C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821E2340; continue 'dispatch;
            }
            0x821E2340 => {
    //   block [0x821E2340..0x821E235C)
	// 821E2340: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E2344: 419A003C  beq cr6, 0x821e2380
	if ctx.cr[6].eq {
	pc = 0x821E2380; continue 'dispatch;
	}
	// 821E2348: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E234C: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 821E2350: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E2354: 41990008  bgt cr6, 0x821e235c
	if ctx.cr[6].gt {
	pc = 0x821E235C; continue 'dispatch;
	}
	// 821E2358: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821E235C; continue 'dispatch;
            }
            0x821E235C => {
    //   block [0x821E235C..0x821E2380)
	// 821E235C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E2360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E2364: 409A001C  bne cr6, 0x821e2380
	if !ctx.cr[6].eq {
	pc = 0x821E2380; continue 'dispatch;
	}
	// 821E2368: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E236C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E2370: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821E2374: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E2378: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E237C: 48000018  b 0x821e2394
	pc = 0x821E2394; continue 'dispatch;
            }
            0x821E2380 => {
    //   block [0x821E2380..0x821E2390)
	// 821E2380: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E2384: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E2388: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E238C: 48000008  b 0x821e2394
	pc = 0x821E2394; continue 'dispatch;
            }
            0x821E2390 => {
    //   block [0x821E2390..0x821E2394)
	// 821E2390: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x821E2394; continue 'dispatch;
            }
            0x821E2394 => {
    //   block [0x821E2394..0x821E23AC)
	// 821E2394: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821E2398: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E239C: 419A0014  beq cr6, 0x821e23b0
	if ctx.cr[6].eq {
	pc = 0x821E23B0; continue 'dispatch;
	}
	// 821E23A0: 896B0040  lbz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 821E23A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E23A8: 419A0008  beq cr6, 0x821e23b0
	if ctx.cr[6].eq {
	pc = 0x821E23B0; continue 'dispatch;
	}
	pc = 0x821E23AC; continue 'dispatch;
            }
            0x821E23AC => {
    //   block [0x821E23AC..0x821E23B0)
	// 821E23AC: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	pc = 0x821E23B0; continue 'dispatch;
            }
            0x821E23B0 => {
    //   block [0x821E23B0..0x821E23EC)
	// 821E23B0: 81450028  lwz r10, 0x28(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(40 as u32) ) } as u64;
	// 821E23B4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821E23B8: 55497FFE  rlwinm r9, r10, 0xf, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0001FFFFu64;
	// 821E23BC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E23C0: 419A00E8  beq cr6, 0x821e24a8
	if ctx.cr[6].eq {
	pc = 0x821E24A8; continue 'dispatch;
	}
	// 821E23C4: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E23C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E23CC: 419A0020  beq cr6, 0x821e23ec
	if ctx.cr[6].eq {
	pc = 0x821E23EC; continue 'dispatch;
	}
	// 821E23D0: 894B0031  lbz r10, 0x31(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 821E23D4: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E23D8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821E23DC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E23E0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E23E4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E23E8: 480000C4  b 0x821e24ac
	pc = 0x821E24AC; continue 'dispatch;
            }
            0x821E23EC => {
    //   block [0x821E23EC..0x821E2408)
	// 821E23EC: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E23F0: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E23F4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821E23F8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E23FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E2400: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E2404: 40810054  ble 0x821e2458
	if !ctx.cr[0].gt {
	pc = 0x821E2458; continue 'dispatch;
	}
	pc = 0x821E2408; continue 'dispatch;
            }
            0x821E2408 => {
    //   block [0x821E2408..0x821E2428)
	// 821E2408: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E240C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E2410: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821E2414: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E2418: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 821E241C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E2420: 41980008  blt cr6, 0x821e2428
	if ctx.cr[6].lt {
	pc = 0x821E2428; continue 'dispatch;
	}
	// 821E2424: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x821E2428; continue 'dispatch;
            }
            0x821E2428 => {
    //   block [0x821E2428..0x821E2444)
	// 821E2428: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E242C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E2430: 419A0014  beq cr6, 0x821e2444
	if ctx.cr[6].eq {
	pc = 0x821E2444; continue 'dispatch;
	}
	// 821E2434: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E2438: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E243C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E2440: 4800000C  b 0x821e244c
	pc = 0x821E244C; continue 'dispatch;
            }
            0x821E2444 => {
    //   block [0x821E2444..0x821E244C)
	// 821E2444: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E2448: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821E244C; continue 'dispatch;
            }
            0x821E244C => {
    //   block [0x821E244C..0x821E2458)
	// 821E244C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E2450: 4199FFB8  bgt cr6, 0x821e2408
	if ctx.cr[6].gt {
	pc = 0x821E2408; continue 'dispatch;
	}
	// 821E2454: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821E2458; continue 'dispatch;
            }
            0x821E2458 => {
    //   block [0x821E2458..0x821E2474)
	// 821E2458: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E245C: 419A003C  beq cr6, 0x821e2498
	if ctx.cr[6].eq {
	pc = 0x821E2498; continue 'dispatch;
	}
	// 821E2460: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E2464: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 821E2468: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E246C: 41990008  bgt cr6, 0x821e2474
	if ctx.cr[6].gt {
	pc = 0x821E2474; continue 'dispatch;
	}
	// 821E2470: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821E2474; continue 'dispatch;
            }
            0x821E2474 => {
    //   block [0x821E2474..0x821E2498)
	// 821E2474: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E2478: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E247C: 409A001C  bne cr6, 0x821e2498
	if !ctx.cr[6].eq {
	pc = 0x821E2498; continue 'dispatch;
	}
	// 821E2480: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E2484: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E2488: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821E248C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E2490: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E2494: 48000018  b 0x821e24ac
	pc = 0x821E24AC; continue 'dispatch;
            }
            0x821E2498 => {
    //   block [0x821E2498..0x821E24A8)
	// 821E2498: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E249C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E24A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E24A4: 48000008  b 0x821e24ac
	pc = 0x821E24AC; continue 'dispatch;
            }
            0x821E24A8 => {
    //   block [0x821E24A8..0x821E24AC)
	// 821E24A8: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x821E24AC; continue 'dispatch;
            }
            0x821E24AC => {
    //   block [0x821E24AC..0x821E24DC)
	// 821E24AC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821E24B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E24B4: 419A0028  beq cr6, 0x821e24dc
	if ctx.cr[6].eq {
	pc = 0x821E24DC; continue 'dispatch;
	}
	// 821E24B8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E24BC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821E24C0: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E24C4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E24C8: 4E800421  bctrl
	ctx.lr = 0x821E24CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E24CC: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E24D0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E24D4: 419A0008  beq cr6, 0x821e24dc
	if ctx.cr[6].eq {
	pc = 0x821E24DC; continue 'dispatch;
	}
	// 821E24D8: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
            }
            0x821E24DC => {
    //   block [0x821E24DC..0x821E2540)
	// 821E24DC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E24E0: 573E063E  clrlwi r30, r25, 0x18
	ctx.r[30].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 821E24E4: 3BAB9490  addi r29, r11, -0x6b70
	ctx.r[29].s64 = ctx.r[11].s64 + -27504;
	// 821E24E8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E24EC: C3FDFFF4  lfs f31, -0xc(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821E24F0: 409A0058  bne cr6, 0x821e2548
	if !ctx.cr[6].eq {
	pc = 0x821E2548; continue 'dispatch;
	}
	// 821E24F4: 897B0030  lbz r11, 0x30(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E24F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E24FC: 419A0044  beq cr6, 0x821e2540
	if ctx.cr[6].eq {
	pc = 0x821E2540; continue 'dispatch;
	}
	// 821E2500: D3FB0018  stfs f31, 0x18(r27)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821E2504: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E2508: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821E250C: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821E2510: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E2514: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821E2518: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E251C: 4E800421  bctrl
	ctx.lr = 0x821E2520;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E2520: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 821E2524: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 821E2528: C01B000C  lfs f0, 0xc(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
            }
            0x821E2540 => {
    //   block [0x821E2540..0x821E2548)
	// 821E2540: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E2544: 419A0010  beq cr6, 0x821e2554
	if ctx.cr[6].eq {
	pc = 0x821E2554; continue 'dispatch;
	}
	pc = 0x821E2548; continue 'dispatch;
            }
            0x821E2548 => {
    //   block [0x821E2548..0x821E273C)
	// 821E2548: 817B002C  lwz r11, 0x2c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E254C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821E2550: 419A0060  beq cr6, 0x821e25b0
	if ctx.cr[6].eq {
	pc = 0x821E25B0; continue 'dispatch;
	}
	// 821E2554: C1BB0014  lfs f13, 0x14(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E2558: C19B0010  lfs f12, 0x10(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821E255C: ED6C6828  fsubs f11, f12, f13
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 821E2560: C01DFE48  lfs f0, -0x1b8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-440 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E2564: C03B0018  lfs f1, 0x18(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821E2568: ED4B683A  fmadds f10, f11, f0, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 821E256C: D15B0014  stfs f10, 0x14(r27)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821E2570: 48057A21  bl 0x82239f90
	ctx.lr = 0x821E2574;
	sub_82239F90(ctx, base);
	// 821E2574: C13B0018  lfs f9, 0x18(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821E2578: C11B0024  lfs f8, 0x24(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821E257C: FCE00818  frsp f7, f1
	ctx.f[7].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821E2580: EC084FBA  fmadds f0, f8, f30, f9
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[30].f64 + ctx.f[9].f64) as f32) as f64);
	// 821E2584: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E2588: C0DB001C  lfs f6, 0x1c(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821E258C: C0BB0014  lfs f5, 0x14(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821E2590: D01B0018  stfs f0, 0x18(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821E2594: C1AB9044  lfs f13, -0x6fbc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28604 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E2598: EC8629FA  fmadds f4, f6, f7, f5
	ctx.f[4].f64 = (((ctx.f[6].f64 * ctx.f[7].f64 + ctx.f[5].f64) as f32) as f64);
	// 821E259C: D09B0020  stfs f4, 0x20(r27)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821E25A0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821E25A4: 4099000C  ble cr6, 0x821e25b0
	if !ctx.cr[6].gt {
	pc = 0x821E25B0; continue 'dispatch;
	}
	// 821E25A8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821E25AC: D01B0018  stfs f0, 0x18(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821E25B0: 817B002C  lwz r11, 0x2c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E25B4: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 821E25B8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821E25BC: 409A0014  bne cr6, 0x821e25d0
	if !ctx.cr[6].eq {
	pc = 0x821E25D0; continue 'dispatch;
	}
	// 821E25C0: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 821E25C4: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821E25C8: 555FDFFE  rlwinm r31, r10, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821E25CC: 4800003C  b 0x821e2608
	pc = 0x821E2608; continue 'dispatch;
	// 821E25D0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821E25D4: 409A0028  bne cr6, 0x821e25fc
	if !ctx.cr[6].eq {
	pc = 0x821E25FC; continue 'dispatch;
	}
	// 821E25D8: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 821E25DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E25E0: 409A0010  bne cr6, 0x821e25f0
	if !ctx.cr[6].eq {
	pc = 0x821E25F0; continue 'dispatch;
	}
	// 821E25E4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E25E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E25EC: 419A0008  beq cr6, 0x821e25f4
	if ctx.cr[6].eq {
	pc = 0x821E25F4; continue 'dispatch;
	}
	// 821E25F0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821E25F4: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E25F8: 48000010  b 0x821e2608
	pc = 0x821E2608; continue 'dispatch;
	// 821E25FC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821E2600: 409A0008  bne cr6, 0x821e2608
	if !ctx.cr[6].eq {
	pc = 0x821E2608; continue 'dispatch;
	}
	// 821E2604: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 821E2608: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E260C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821E2610: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821E2614: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E2618: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821E261C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E2620: 4E800421  bctrl
	ctx.lr = 0x821E2624;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E2624: 57E8063E  clrlwi r8, r31, 0x18
	ctx.r[8].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821E2628: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E262C: 419A0054  beq cr6, 0x821e2680
	if ctx.cr[6].eq {
	pc = 0x821E2680; continue 'dispatch;
	}
	// 821E2630: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E2634: C01B0020  lfs f0, 0x20(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E2638: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821E263C: C1BB000C  lfs f13, 0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E2640: 392B9190  addi r9, r11, -0x6e70
	ctx.r[9].s64 = ctx.r[11].s64 + -28272;
	// 821E2644: ED80682A  fadds f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821E2648: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821E264C: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821E2650: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 821E2654: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
            }
            0x821E273C => {
    //   block [0x821E273C..0x821E274C)
	// 821E273C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 821E2740: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 821E2744: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 821E2748: 48AC6D04  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E2750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821E2750 size=36
    let mut pc: u32 = 0x821E2750;
    'dispatch: loop {
        match pc {
            0x821E2750 => {
    //   block [0x821E2750..0x821E276C)
	// 821E2750: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E2754: C1A30334  lfs f13, 0x334(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(820 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E2758: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E275C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E2760: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821E2764: 41990008  bgt cr6, 0x821e276c
	if ctx.cr[6].gt {
	pc = 0x821E276C; continue 'dispatch;
	}
	// 821E2768: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821E276C; continue 'dispatch;
            }
            0x821E276C => {
    //   block [0x821E276C..0x821E2774)
	// 821E276C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E2770: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E2778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E2778 size=332
    let mut pc: u32 = 0x821E2778;
    'dispatch: loop {
        match pc {
            0x821E2778 => {
    //   block [0x821E2778..0x821E27D8)
	// 821E2778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E277C: 48AC6C89  bl 0x82ca9404
	ctx.lr = 0x821E2780;
	sub_82CA93D0(ctx, base);
	// 821E2780: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E2784: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821E2788: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821E278C: 83BC0038  lwz r29, 0x38(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 821E2790: 897D0112  lbz r11, 0x112(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(274 as u32) ) } as u64;
	// 821E2794: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E2798: 409A0124  bne cr6, 0x821e28bc
	if !ctx.cr[6].eq {
	pc = 0x821E28BC; continue 'dispatch;
	}
	// 821E279C: 817B06FC  lwz r11, 0x6fc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821E27A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E27A4: 419A005C  beq cr6, 0x821e2800
	if ctx.cr[6].eq {
	pc = 0x821E2800; continue 'dispatch;
	}
	// 821E27A8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E27AC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E27B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E27B4: 808B5030  lwz r4, 0x5030(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20528 as u32) ) } as u64;
	// 821E27B8: 4801DFB9  bl 0x82200770
	ctx.lr = 0x821E27BC;
	sub_82200770(ctx, base);
	// 821E27BC: 8BE10054  lbz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E27C0: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E27C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821E27C8: 419A0010  beq cr6, 0x821e27d8
	if ctx.cr[6].eq {
	pc = 0x821E27D8; continue 'dispatch;
	}
	// 821E27CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E27D0: 490D7185  bl 0x832b9954
	ctx.lr = 0x821E27D4;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 821E27D4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x821E27D8; continue 'dispatch;
            }
            0x821E27D8 => {
    //   block [0x821E27D8..0x821E27EC)
	// 821E27D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E27DC: 4BFFF70D  bl 0x821e1ee8
	ctx.lr = 0x821E27E0;
	sub_821E1EE8(ctx, base);
	// 821E27E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E27E4: 419A0008  beq cr6, 0x821e27ec
	if ctx.cr[6].eq {
	pc = 0x821E27EC; continue 'dispatch;
	}
	// 821E27E8: 480BC8D1  bl 0x8229f0b8
	ctx.lr = 0x821E27EC;
	sub_8229F0B8(ctx, base);
	pc = 0x821E27EC; continue 'dispatch;
            }
            0x821E27EC => {
    //   block [0x821E27EC..0x821E2800)
	// 821E27EC: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821E27F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E27F4: 419A000C  beq cr6, 0x821e2800
	if ctx.cr[6].eq {
	pc = 0x821E2800; continue 'dispatch;
	}
	// 821E27F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E27FC: 490D7159  bl 0x832b9954
	ctx.lr = 0x821E2800;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x821E2800; continue 'dispatch;
            }
            0x821E2800 => {
    //   block [0x821E2800..0x821E2824)
	// 821E2800: 817C0034  lwz r11, 0x34(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) } as u64;
	// 821E2804: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E2808: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E280C: 41980018  blt cr6, 0x821e2824
	if ctx.cr[6].lt {
	pc = 0x821E2824; continue 'dispatch;
	}
	// 821E2810: 815C001C  lwz r10, 0x1c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 821E2814: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E2818: 810A0058  lwz r8, 0x58(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E281C: 7C88482E  lwzx r4, r8, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821E2820: 4800000C  b 0x821e282c
	pc = 0x821E282C; continue 'dispatch;
            }
            0x821E2824 => {
    //   block [0x821E2824..0x821E282C)
	// 821E2824: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E2828: 808B5760  lwz r4, 0x5760(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(22368 as u32) ) } as u64;
	pc = 0x821E282C; continue 'dispatch;
            }
            0x821E282C => {
    //   block [0x821E282C..0x821E284C)
	// 821E282C: 817B06FC  lwz r11, 0x6fc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1788 as u32) ) } as u64;
	// 821E2830: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E2834: 419A002C  beq cr6, 0x821e2860
	if ctx.cr[6].eq {
	pc = 0x821E2860; continue 'dispatch;
	}
	// 821E2838: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821E283C: 419A0010  beq cr6, 0x821e284c
	if ctx.cr[6].eq {
	pc = 0x821E284C; continue 'dispatch;
	}
	// 821E2840: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 821E2844: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E2848: 409A0008  bne cr6, 0x821e2850
	if !ctx.cr[6].eq {
	pc = 0x821E2850; continue 'dispatch;
	}
	pc = 0x821E284C; continue 'dispatch;
            }
            0x821E284C => {
    //   block [0x821E284C..0x821E2850)
	// 821E284C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x821E2850; continue 'dispatch;
            }
            0x821E2850 => {
    //   block [0x821E2850..0x821E2860)
	// 821E2850: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E2854: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E2858: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E285C: 419A0008  beq cr6, 0x821e2864
	if ctx.cr[6].eq {
	pc = 0x821E2864; continue 'dispatch;
	}
	pc = 0x821E2860; continue 'dispatch;
            }
            0x821E2860 => {
    //   block [0x821E2860..0x821E2864)
	// 821E2860: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x821E2864; continue 'dispatch;
            }
            0x821E2864 => {
    //   block [0x821E2864..0x821E2884)
	// 821E2864: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E2868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E286C: 419A0018  beq cr6, 0x821e2884
	if ctx.cr[6].eq {
	pc = 0x821E2884; continue 'dispatch;
	}
	// 821E2870: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821E2874: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821E2878: 48097FE1  bl 0x8227a858
	ctx.lr = 0x821E287C;
	sub_8227A858(ctx, base);
	// 821E287C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821E2880: 48AC6BD4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x821E2884 => {
    //   block [0x821E2884..0x821E289C)
	// 821E2884: 897B0701  lbz r11, 0x701(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(1793 as u32) ) } as u64;
	// 821E2888: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E288C: 419A0010  beq cr6, 0x821e289c
	if ctx.cr[6].eq {
	pc = 0x821E289C; continue 'dispatch;
	}
	// 821E2890: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E2894: 556BE7FE  rlwinm r11, r11, 0x1c, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 821E2898: 48000008  b 0x821e28a0
	pc = 0x821E28A0; continue 'dispatch;
            }
            0x821E289C => {
    //   block [0x821E289C..0x821E28A0)
	// 821E289C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x821E28A0; continue 'dispatch;
            }
            0x821E28A0 => {
    //   block [0x821E28A0..0x821E28BC)
	// 821E28A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E28A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E28A8: 419A0014  beq cr6, 0x821e28bc
	if ctx.cr[6].eq {
	pc = 0x821E28BC; continue 'dispatch;
	}
	// 821E28AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821E28B0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 821E28B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821E28B8: 4BFFEC39  bl 0x821e14f0
	ctx.lr = 0x821E28BC;
	sub_821E14F0(ctx, base);
	pc = 0x821E28BC; continue 'dispatch;
            }
            0x821E28BC => {
    //   block [0x821E28BC..0x821E28C4)
	// 821E28BC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821E28C0: 48AC6B94  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E28C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E28C8 size=636
    let mut pc: u32 = 0x821E28C8;
    'dispatch: loop {
        match pc {
            0x821E28C8 => {
    //   block [0x821E28C8..0x821E28F8)
	// 821E28C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E28CC: 48AC6B41  bl 0x82ca940c
	ctx.lr = 0x821E28D0;
	sub_82CA93D0(ctx, base);
	// 821E28D0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E28D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E28D8: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 821E28DC: 389E0200  addi r4, r30, 0x200
	ctx.r[4].s64 = ctx.r[30].s64 + 512;
	// 821E28E0: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 821E28E4: 480382AD  bl 0x8221ab90
	ctx.lr = 0x821E28E8;
	sub_8221AB90(ctx, base);
	// 821E28E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821E28EC: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 821E28F0: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821E28F4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821E28F8; continue 'dispatch;
            }
            0x821E28F8 => {
    //   block [0x821E28F8..0x821E2960)
	// 821E28F8: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821E28FC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E2900: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821E2904: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E2908: 4200FFF0  bdnz 0x821e28f8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821E28F8; continue 'dispatch;
	}
	// 821E290C: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E2910: 816B00C0  lwz r11, 0xc0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) } as u64;
	// 821E2914: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821E2918: 409A016C  bne cr6, 0x821e2a84
	if !ctx.cr[6].eq {
	pc = 0x821E2A84; continue 'dispatch;
	}
	// 821E291C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E2920: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E2924: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 821E2928: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821E292C: EBAB1758  ld r29, 0x1758(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(5976 as u32) ) };
	// 821E2930: 409A00AC  bne cr6, 0x821e29dc
	if !ctx.cr[6].eq {
	pc = 0x821E29DC; continue 'dispatch;
	}
	// 821E2934: 798CB7E6  rldicr r12, r12, 0x36, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(54) & 0xFFFFFFFFFFFFFFFF;
	// 821E2938: 7FAA6038  and r10, r29, r12
	ctx.r[10].u64 = ctx.r[29].u64 & ctx.r[12].u64;
	// 821E293C: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 821E2940: 419A0020  beq cr6, 0x821e2960
	if ctx.cr[6].eq {
	pc = 0x821E2960; continue 'dispatch;
	}
	// 821E2944: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E2948: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821E294C: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821E2950: 78E7B7E6  rldicr r7, r7, 0x36, 0x3f
	ctx.r[7].u64 = (ctx.r[7].u64).rotate_left(54) & 0xFFFFFFFFFFFFFFFF;
	// 821E2954: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821E2958: 38800024  li r4, 0x24
	ctx.r[4].s64 = 36;
	// 821E295C: 480324D5  bl 0x82214e30
	ctx.lr = 0x821E2960;
	sub_82214E30(ctx, base);
	pc = 0x821E2960; continue 'dispatch;
            }
            0x821E2960 => {
    //   block [0x821E2960..0x821E29DC)
	// 821E2960: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821E2964: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 821E2968: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821E296C: 798CE7E6  rldicr r12, r12, 0x3c, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(60) & 0xFFFFFFFFFFFFFFFF;
	// 821E2970: 7FA96038  and r9, r29, r12
	ctx.r[9].u64 = ctx.r[29].u64 & ctx.r[12].u64;
	pc = 0x821E29DC; continue 'dispatch;
            }
            0x821E29DC => {
    //   block [0x821E29DC..0x821E2A84)
	// 821E29DC: 798CAFE6  rldicr r12, r12, 0x35, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(53) & 0xFFFFFFFFFFFFFFFF;
	// 821E29E0: 7FAA6038  and r10, r29, r12
	ctx.r[10].u64 = ctx.r[29].u64 & ctx.r[12].u64;
	// 821E29E4: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 821E29E8: 419A0020  beq cr6, 0x821e2a08
	if ctx.cr[6].eq {
	pc = 0x821E2A08; continue 'dispatch;
	}
	// 821E29EC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E29F0: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821E29F4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821E29F8: 78E7AFE6  rldicr r7, r7, 0x35, 0x3f
	ctx.r[7].u64 = (ctx.r[7].u64).rotate_left(53) & 0xFFFFFFFFFFFFFFFF;
	// 821E29FC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821E2A00: 38800028  li r4, 0x28
	ctx.r[4].s64 = 40;
	// 821E2A04: 4803242D  bl 0x82214e30
	ctx.lr = 0x821E2A08;
	sub_82214E30(ctx, base);
	// 821E2A08: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821E2A0C: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 821E2A10: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821E2A14: 798CE7E6  rldicr r12, r12, 0x3c, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(60) & 0xFFFFFFFFFFFFFFFF;
	// 821E2A18: 7FA96038  and r9, r29, r12
	ctx.r[9].u64 = ctx.r[29].u64 & ctx.r[12].u64;
	pc = 0x821E2A84; continue 'dispatch;
            }
            0x821E2A84 => {
    //   block [0x821E2A84..0x821E2B44)
	// 821E2A84: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821E2A88: 409A00B4  bne cr6, 0x821e2b3c
	if !ctx.cr[6].eq {
	pc = 0x821E2B3C; continue 'dispatch;
	}
	// 821E2A8C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E2A90: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821E2A94: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 821E2A98: 798CBFE6  rldicr r12, r12, 0x37, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(55) & 0xFFFFFFFFFFFFFFFF;
	// 821E2A9C: EBAB1758  ld r29, 0x1758(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(5976 as u32) ) };
	// 821E2AA0: 7FAA6038  and r10, r29, r12
	ctx.r[10].u64 = ctx.r[29].u64 & ctx.r[12].u64;
	// 821E2AA4: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 821E2AA8: 419A0020  beq cr6, 0x821e2ac8
	if ctx.cr[6].eq {
	pc = 0x821E2AC8; continue 'dispatch;
	}
	// 821E2AAC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E2AB0: 807F0364  lwz r3, 0x364(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821E2AB4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821E2AB8: 78E7BFE6  rldicr r7, r7, 0x37, 0x3f
	ctx.r[7].u64 = (ctx.r[7].u64).rotate_left(55) & 0xFFFFFFFFFFFFFFFF;
	// 821E2ABC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821E2AC0: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 821E2AC4: 4803236D  bl 0x82214e30
	ctx.lr = 0x821E2AC8;
	sub_82214E30(ctx, base);
	// 821E2AC8: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 821E2ACC: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 821E2AD0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821E2AD4: 798C9FE6  rldicr r12, r12, 0x33, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(51) & 0xFFFFFFFFFFFFFFFF;
	// 821E2AD8: 7FA96038  and r9, r29, r12
	ctx.r[9].u64 = ctx.r[29].u64 & ctx.r[12].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E2B48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E2B48 size=188
    let mut pc: u32 = 0x821E2B48;
    'dispatch: loop {
        match pc {
            0x821E2B48 => {
    //   block [0x821E2B48..0x821E2C04)
	// 821E2B48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E2B4C: 48AC68B9  bl 0x82ca9404
	ctx.lr = 0x821E2B50;
	sub_82CA93D0(ctx, base);
	// 821E2B50: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821E2B54: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E2B58: 396100D4  addi r11, r1, 0xd4
	ctx.r[11].s64 = ctx.r[1].s64 + 212;
	// 821E2B5C: 90E100D4  stw r7, 0xd4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), ctx.r[7].u32 ) };
	// 821E2B60: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 821E2B64: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E2B68: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821E2B6C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821E2B70: 394A1390  addi r10, r10, 0x1390
	ctx.r[10].s64 = ctx.r[10].s64 + 5008;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E2C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E2C08 size=984
    let mut pc: u32 = 0x821E2C08;
    'dispatch: loop {
        match pc {
            0x821E2C08 => {
    //   block [0x821E2C08..0x821E2CF8)
	// 821E2C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E2C0C: 48AC6801  bl 0x82ca940c
	ctx.lr = 0x821E2C10;
	sub_82CA93D0(ctx, base);
	// 821E2C10: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E2C14: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821E2C18: 3D20834B  lis r9, -0x7cb5
	ctx.r[9].s64 = -2092236800;
	// 821E2C1C: 394B2390  addi r10, r11, 0x2390
	ctx.r[10].s64 = ctx.r[11].s64 + 9104;
	// 821E2C20: 38C97E70  addi r6, r9, 0x7e70
	ctx.r[6].s64 = ctx.r[9].s64 + 32368;
	// 821E2C24: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821E2C28: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821E2C2C: 99010050  stb r8, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u8 ) };
	// 821E2C30: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821E2C34: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2C38: 386A2008  addi r3, r10, 0x2008
	ctx.r[3].s64 = ctx.r[10].s64 + 8200;
	// 821E2C3C: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821E2C40: 55271838  slwi r7, r9, 3
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821E2C44: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821E2C48: 3CA08349  lis r5, -0x7cb7
	ctx.r[5].s64 = -2092367872;
	// 821E2C4C: 38890DB8  addi r4, r9, 0xdb8
	ctx.r[4].s64 = ctx.r[9].s64 + 3512;
	// 821E2C50: 7CC7512E  stwx r6, r7, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 821E2C54: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2C58: 80EA2000  lwz r7, 0x2000(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821E2C5C: 812A400C  lwz r9, 0x400c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821E2C60: 553F1838  slwi r31, r9, 3
	ctx.r[31].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 821E2C64: 39280001  addi r9, r8, 1
	ctx.r[9].s64 = ctx.r[8].s64 + 1;
	// 821E2C68: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E2C6C: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	// 821E2C70: 910A2000  stw r8, 0x2000(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8192 as u32), ctx.r[8].u32 ) };
	// 821E2C74: 7CDF192E  stwx r6, r31, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[3].u32), ctx.r[6].u32) };
	// 821E2C78: 886B1A6D  lbz r3, 0x1a6d(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6765 as u32) ) } as u64;
	// 821E2C7C: 80EA4008  lwz r7, 0x4008(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16392 as u32) ) } as u64;
	// 821E2C80: 80CB1A5C  lwz r6, 0x1a5c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6748 as u32) ) } as u64;
	// 821E2C84: 810A400C  lwz r8, 0x400c(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16396 as u32) ) } as u64;
	// 821E2C88: 39280001  addi r9, r8, 1
	ctx.r[9].s64 = ctx.r[8].s64 + 1;
	// 821E2C8C: 1D032008  mulli r8, r3, 0x2008
	ctx.r[8].s32 = ((ctx.r[3].s32 as i64 * 8200 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 821E2C90: 912A400C  stw r9, 0x400c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16396 as u32), ctx.r[9].u32 ) };
	// 821E2C94: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E2C98: 54E8083C  slwi r8, r7, 1
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E2C9C: 3929DFF8  addi r9, r9, -0x2008
	ctx.r[9].s64 = ctx.r[9].s64 + -8200;
	// 821E2CA0: 910A4008  stw r8, 0x4008(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16392 as u32), ctx.r[8].u32 ) };
	// 821E2CA4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821E2CA8: 419A0088  beq cr6, 0x821e2d30
	if ctx.cr[6].eq {
	pc = 0x821E2D30; continue 'dispatch;
	}
	// 821E2CAC: 81092000  lwz r8, 0x2000(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821E2CB0: 80EB1A60  lwz r7, 0x1a60(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6752 as u32) ) } as u64;
	// 821E2CB4: 7D063838  and r6, r8, r7
	ctx.r[6].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 821E2CB8: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821E2CBC: 409A003C  bne cr6, 0x821e2cf8
	if !ctx.cr[6].eq {
	pc = 0x821E2CF8; continue 'dispatch;
	}
	// 821E2CC0: 80C92004  lwz r6, 0x2004(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2CC4: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 821E2CC8: 386B1A58  addi r3, r11, 0x1a58
	ctx.r[3].s64 = ctx.r[11].s64 + 6744;
	// 821E2CCC: 54C71838  slwi r7, r6, 3
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821E2CD0: 910B1A60  stw r8, 0x1a60(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6752 as u32), ctx.r[8].u32 ) };
	// 821E2CD4: 7C67492E  stwx r3, r7, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32), ctx.r[3].u32) };
	// 821E2CD8: 810B1A5C  lwz r8, 0x1a5c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6748 as u32) ) } as u64;
	// 821E2CDC: 80C92004  lwz r6, 0x2004(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2CE0: 54C71838  slwi r7, r6, 3
	ctx.r[7].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821E2CE4: 7C674A14  add r3, r7, r9
	ctx.r[3].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821E2CE8: 91030004  stw r8, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821E2CEC: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2CF0: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821E2CF4: 91092004  stw r8, 0x2004(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	pc = 0x821E2CF8; continue 'dispatch;
            }
            0x821E2CF8 => {
    //   block [0x821E2CF8..0x821E2D30)
	// 821E2CF8: 892B1A6C  lbz r9, 0x1a6c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6764 as u32) ) } as u64;
	// 821E2CFC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821E2D00: 910B1A5C  stw r8, 0x1a5c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6748 as u32), ctx.r[8].u32 ) };
	// 821E2D04: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E2D08: 409A0028  bne cr6, 0x821e2d30
	if !ctx.cr[6].eq {
	pc = 0x821E2D30; continue 'dispatch;
	}
	// 821E2D0C: 81250DB0  lwz r9, 0xdb0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821E2D10: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821E2D14: 38EB1A58  addi r7, r11, 0x1a58
	ctx.r[7].s64 = ctx.r[11].s64 + 6744;
	// 821E2D18: 5523103A  slwi r3, r9, 2
	ctx.r[3].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821E2D1C: 990B1A6C  stb r8, 0x1a6c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6764 as u32), ctx.r[8].u8 ) };
	// 821E2D20: 38C90001  addi r6, r9, 1
	ctx.r[6].s64 = ctx.r[9].s64 + 1;
	// 821E2D24: 90C50DB0  stw r6, 0xdb0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821E2D28: 7CE3212E  stwx r7, r3, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	// 821E2D2C: 48000008  b 0x821e2d34
	pc = 0x821E2D34; continue 'dispatch;
            }
            0x821E2D30 => {
    //   block [0x821E2D30..0x821E2D34)
	// 821E2D30: 80C50DB0  lwz r6, 0xdb0(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x821E2D34; continue 'dispatch;
            }
            0x821E2D34 => {
    //   block [0x821E2D34..0x821E2D9C)
	// 821E2D34: 892B1A85  lbz r9, 0x1a85(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6789 as u32) ) } as u64;
	// 821E2D38: 810B1A74  lwz r8, 0x1a74(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6772 as u32) ) } as u64;
	// 821E2D3C: 1D292008  mulli r9, r9, 0x2008
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 8200 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821E2D40: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821E2D44: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 821E2D48: 3929DFF8  addi r9, r9, -0x2008
	ctx.r[9].s64 = ctx.r[9].s64 + -8200;
	// 821E2D4C: 419A0080  beq cr6, 0x821e2dcc
	if ctx.cr[6].eq {
	pc = 0x821E2DCC; continue 'dispatch;
	}
	// 821E2D50: 81092000  lwz r8, 0x2000(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821E2D54: 80EB1A78  lwz r7, 0x1a78(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6776 as u32) ) } as u64;
	// 821E2D58: 7D033838  and r3, r8, r7
	ctx.r[3].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 821E2D5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E2D60: 409A003C  bne cr6, 0x821e2d9c
	if !ctx.cr[6].eq {
	pc = 0x821E2D9C; continue 'dispatch;
	}
	// 821E2D64: 80692004  lwz r3, 0x2004(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2D68: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 821E2D6C: 38EB1A70  addi r7, r11, 0x1a70
	ctx.r[7].s64 = ctx.r[11].s64 + 6768;
	// 821E2D70: 54631838  slwi r3, r3, 3
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821E2D74: 910B1A78  stw r8, 0x1a78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6776 as u32), ctx.r[8].u32 ) };
	// 821E2D78: 7CE3492E  stwx r7, r3, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 821E2D7C: 810B1A74  lwz r8, 0x1a74(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6772 as u32) ) } as u64;
	// 821E2D80: 80E92004  lwz r7, 0x2004(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2D84: 54E71838  slwi r7, r7, 3
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821E2D88: 7C674A14  add r3, r7, r9
	ctx.r[3].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821E2D8C: 91030004  stw r8, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821E2D90: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2D94: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821E2D98: 91092004  stw r8, 0x2004(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	pc = 0x821E2D9C; continue 'dispatch;
            }
            0x821E2D9C => {
    //   block [0x821E2D9C..0x821E2DCC)
	// 821E2D9C: 892B1A84  lbz r9, 0x1a84(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6788 as u32) ) } as u64;
	// 821E2DA0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821E2DA4: 910B1A74  stw r8, 0x1a74(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6772 as u32), ctx.r[8].u32 ) };
	// 821E2DA8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E2DAC: 409A0020  bne cr6, 0x821e2dcc
	if !ctx.cr[6].eq {
	pc = 0x821E2DCC; continue 'dispatch;
	}
	// 821E2DB0: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E2DB4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821E2DB8: 38EB1A70  addi r7, r11, 0x1a70
	ctx.r[7].s64 = ctx.r[11].s64 + 6768;
	// 821E2DBC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821E2DC0: 992B1A84  stb r9, 0x1a84(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6788 as u32), ctx.r[9].u8 ) };
	// 821E2DC4: 90C50DB0  stw r6, 0xdb0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821E2DC8: 7CE8212E  stwx r7, r8, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	pc = 0x821E2DCC; continue 'dispatch;
            }
            0x821E2DCC => {
    //   block [0x821E2DCC..0x821E2E34)
	// 821E2DCC: 892B1AB5  lbz r9, 0x1ab5(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6837 as u32) ) } as u64;
	// 821E2DD0: 810B1AA4  lwz r8, 0x1aa4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6820 as u32) ) } as u64;
	// 821E2DD4: 1D292008  mulli r9, r9, 0x2008
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 8200 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821E2DD8: 7D295214  add r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821E2DDC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E2DE0: 3929DFF8  addi r9, r9, -0x2008
	ctx.r[9].s64 = ctx.r[9].s64 + -8200;
	// 821E2DE4: 419A0080  beq cr6, 0x821e2e64
	if ctx.cr[6].eq {
	pc = 0x821E2E64; continue 'dispatch;
	}
	// 821E2DE8: 81092000  lwz r8, 0x2000(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821E2DEC: 80EB1AA8  lwz r7, 0x1aa8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6824 as u32) ) } as u64;
	// 821E2DF0: 7D033838  and r3, r8, r7
	ctx.r[3].u64 = ctx.r[8].u64 & ctx.r[7].u64;
	// 821E2DF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E2DF8: 409A003C  bne cr6, 0x821e2e34
	if !ctx.cr[6].eq {
	pc = 0x821E2E34; continue 'dispatch;
	}
	// 821E2DFC: 80692004  lwz r3, 0x2004(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2E00: 7D083B78  or r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 | ctx.r[7].u64;
	// 821E2E04: 38EB1AA0  addi r7, r11, 0x1aa0
	ctx.r[7].s64 = ctx.r[11].s64 + 6816;
	// 821E2E08: 54631838  slwi r3, r3, 3
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821E2E0C: 910B1AA8  stw r8, 0x1aa8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6824 as u32), ctx.r[8].u32 ) };
	// 821E2E10: 7CE3492E  stwx r7, r3, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 821E2E14: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2E18: 55071838  slwi r7, r8, 3
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821E2E1C: 7CE74A14  add r7, r7, r9
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821E2E20: 810B1AA4  lwz r8, 0x1aa4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6820 as u32) ) } as u64;
	// 821E2E24: 91070004  stw r8, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821E2E28: 81092004  lwz r8, 0x2004(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2E2C: 38680001  addi r3, r8, 1
	ctx.r[3].s64 = ctx.r[8].s64 + 1;
	// 821E2E30: 90692004  stw r3, 0x2004(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
	pc = 0x821E2E34; continue 'dispatch;
            }
            0x821E2E34 => {
    //   block [0x821E2E34..0x821E2E64)
	// 821E2E34: 892B1AB4  lbz r9, 0x1ab4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6836 as u32) ) } as u64;
	// 821E2E38: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821E2E3C: 910B1AA4  stw r8, 0x1aa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6820 as u32), ctx.r[8].u32 ) };
	// 821E2E40: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E2E44: 409A0020  bne cr6, 0x821e2e64
	if !ctx.cr[6].eq {
	pc = 0x821E2E64; continue 'dispatch;
	}
	// 821E2E48: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E2E4C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821E2E50: 38EB1AA0  addi r7, r11, 0x1aa0
	ctx.r[7].s64 = ctx.r[11].s64 + 6816;
	// 821E2E54: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 821E2E58: 992B1AB4  stb r9, 0x1ab4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6836 as u32), ctx.r[9].u8 ) };
	// 821E2E5C: 90C50DB0  stw r6, 0xdb0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(3504 as u32), ctx.r[6].u32 ) };
	// 821E2E60: 7CE8212E  stwx r7, r8, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	pc = 0x821E2E64; continue 'dispatch;
            }
            0x821E2E64 => {
    //   block [0x821E2E64..0x821E2ED8)
	// 821E2E64: 3CE08331  lis r7, -0x7ccf
	ctx.r[7].s64 = -2093940736;
	// 821E2E68: 886B1A9D  lbz r3, 0x1a9d(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6813 as u32) ) } as u64;
	// 821E2E6C: 810B1A8C  lwz r8, 0x1a8c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6796 as u32) ) } as u64;
	// 821E2E70: 38E76FB8  addi r7, r7, 0x6fb8
	ctx.r[7].s64 = ctx.r[7].s64 + 28600;
	// 821E2E74: 1D232008  mulli r9, r3, 0x2008
	ctx.r[9].s32 = ((ctx.r[3].s32 as i64 * 8200 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821E2E78: 80E70004  lwz r7, 4(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E2E7C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821E2E80: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821E2E84: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821E2E88: 419A007C  beq cr6, 0x821e2f04
	if ctx.cr[6].eq {
	pc = 0x821E2F04; continue 'dispatch;
	}
	// 821E2E8C: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821E2E90: 810B1A90  lwz r8, 0x1a90(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6800 as u32) ) } as u64;
	// 821E2E94: 7D234038  and r3, r9, r8
	ctx.r[3].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821E2E98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E2E9C: 409A003C  bne cr6, 0x821e2ed8
	if !ctx.cr[6].eq {
	pc = 0x821E2ED8; continue 'dispatch;
	}
	// 821E2EA0: 806A2004  lwz r3, 0x2004(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2EA4: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821E2EA8: 390B1A88  addi r8, r11, 0x1a88
	ctx.r[8].s64 = ctx.r[11].s64 + 6792;
	// 821E2EAC: 54631838  slwi r3, r3, 3
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821E2EB0: 912B1A90  stw r9, 0x1a90(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6800 as u32), ctx.r[9].u32 ) };
	// 821E2EB4: 7D03512E  stwx r8, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821E2EB8: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2EBC: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E2EC0: 812B1A8C  lwz r9, 0x1a8c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(6796 as u32) ) } as u64;
	// 821E2EC4: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E2EC8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821E2ECC: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E2ED0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821E2ED4: 912A2004  stw r9, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[9].u32 ) };
	pc = 0x821E2ED8; continue 'dispatch;
            }
            0x821E2ED8 => {
    //   block [0x821E2ED8..0x821E2F04)
	// 821E2ED8: 894B1A9C  lbz r10, 0x1a9c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6812 as u32) ) } as u64;
	// 821E2EDC: 90EB1A8C  stw r7, 0x1a8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(6796 as u32), ctx.r[7].u32 ) };
	// 821E2EE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E2EE4: 409A0020  bne cr6, 0x821e2f04
	if !ctx.cr[6].eq {
	pc = 0x821E2F04; continue 'dispatch;
	}
	// 821E2EE8: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E2EEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E2EF0: 38EB1A88  addi r7, r11, 0x1a88
	ctx.r[7].s64 = ctx.r[11].s64 + 6792;
	// 821E2EF4: 39260001  addi r9, r6, 1
	ctx.r[9].s64 = ctx.r[6].s64 + 1;
	// 821E2EF8: 994B1A9C  stb r10, 0x1a9c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6812 as u32), ctx.r[10].u8 ) };
	// 821E2EFC: 91250DB0  stw r9, 0xdb0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(3504 as u32), ctx.r[9].u32 ) };
	// 821E2F00: 7CE8212E  stwx r7, r8, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32), ctx.r[7].u32) };
	pc = 0x821E2F04; continue 'dispatch;
            }
            0x821E2F04 => {
    //   block [0x821E2F04..0x821E2F24)
	// 821E2F04: 3FC08336  lis r30, -0x7cca
	ctx.r[30].s64 = -2093613056;
	// 821E2F08: 83FE0364  lwz r31, 0x364(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(868 as u32) ) } as u64;
	// 821E2F0C: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821E2F10: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E2F14: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E2F18: 4099000C  ble cr6, 0x821e2f24
	if !ctx.cr[6].gt {
	pc = 0x821E2F24; continue 'dispatch;
	}
	// 821E2F1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E2F20: 48005FA1  bl 0x821e8ec0
	ctx.lr = 0x821E2F24;
	sub_821E8EC0(ctx, base);
	pc = 0x821E2F24; continue 'dispatch;
            }
            0x821E2F24 => {
    //   block [0x821E2F24..0x821E2FE0)
	// 821E2F24: 3D60C000  lis r11, -0x4000
	ctx.r[11].s64 = -1073741824;
	// 821E2F28: 3940000F  li r10, 0xf
	ctx.r[10].s64 = 15;
	// 821E2F2C: 61694600  ori r9, r11, 0x4600
	ctx.r[9].u64 = ctx.r[11].u64 | 17920;
	// 821E2F30: 95230004  stwu r9, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[3].u32 = ea;
	// 821E2F34: 95430004  stwu r10, 4(r3)
	ea = ctx.r[3].u32.wrapping_add(4 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[10].u32) };
	ctx.r[3].u32 = ea;
	// 821E2F38: 891F2ABD  lbz r8, 0x2abd(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10941 as u32) ) } as u64;
	// 821E2F3C: 5507063E  clrlwi r7, r8, 0x18
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 821E2F40: 54E707B8  rlwinm r7, r7, 0, 0x1e, 0x1c
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821E2F44: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 821E2F48: 98FF2ABD  stb r7, 0x2abd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10941 as u32), ctx.r[7].u8 ) };
	// 821E2F4C: 4803B555  bl 0x8221e4a0
	ctx.lr = 0x821E2F50;
	sub_8221E4A0(ctx, base);
	// 821E2F50: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821E2F54: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821E2F58: 807E0364  lwz r3, 0x364(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(868 as u32) ) } as u64;
	// 821E2F5C: 38EA1390  addi r7, r10, 0x1390
	ctx.r[7].s64 = ctx.r[10].s64 + 5008;
	// 821E2F60: 38A91350  addi r5, r9, 0x1350
	ctx.r[5].s64 = ctx.r[9].s64 + 4944;
	// 821E2F64: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821E2F68: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 821E2F6C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E2FE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E2FE0 size=296
    let mut pc: u32 = 0x821E2FE0;
    'dispatch: loop {
        match pc {
            0x821E2FE0 => {
    //   block [0x821E2FE0..0x821E300C)
	// 821E2FE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E2FE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E2FE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E2FEC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E2FF0: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821E2FF4: 409A00FC  bne cr6, 0x821e30f0
	if !ctx.cr[6].eq {
	pc = 0x821E30F0; continue 'dispatch;
	}
	// 821E2FF8: 80E33098  lwz r7, 0x3098(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12440 as u32) ) } as u64;
	// 821E2FFC: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 821E3000: 28070000  cmplwi r7, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E3004: 40820008  bne 0x821e300c
	if !ctx.cr[0].eq {
	pc = 0x821E300C; continue 'dispatch;
	}
	// 821E3008: 816330A8  lwz r11, 0x30a8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12456 as u32) ) } as u64;
	pc = 0x821E300C; continue 'dispatch;
            }
            0x821E300C => {
    //   block [0x821E300C..0x821E3048)
	// 821E300C: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E3010: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E3014: 89632ABC  lbz r11, 0x2abc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821E3018: 552A74BE  srwi r10, r9, 0x12
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shr(18);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E301C: 90A10050  stw r5, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u32 ) };
	// 821E3020: 5529EC7E  rlwinm r9, r9, 0x1d, 0x11, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 821E3024: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 821E3028: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821E302C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821E3030: 557F06F7  rlwinm. r31, r11, 0, 0x1b, 0x1b
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 821E3034: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821E3038: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 821E303C: 4182000C  beq 0x821e3048
	if ctx.cr[0].eq {
	pc = 0x821E3048; continue 'dispatch;
	}
	// 821E3040: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E3044: 48000090  b 0x821e30d4
	pc = 0x821E30D4; continue 'dispatch;
            }
            0x821E3048 => {
    //   block [0x821E3048..0x821E3064)
	// 821E3048: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E304C: 41820080  beq 0x821e30cc
	if ctx.cr[0].eq {
	pc = 0x821E30CC; continue 'dispatch;
	}
	// 821E3050: 816331B8  lwz r11, 0x31b8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12728 as u32) ) } as u64;
	// 821E3054: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821E3058: 419A000C  beq cr6, 0x821e3064
	if ctx.cr[6].eq {
	pc = 0x821E3064; continue 'dispatch;
	}
	// 821E305C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E3060: 409A006C  bne cr6, 0x821e30cc
	if !ctx.cr[6].eq {
	pc = 0x821E30CC; continue 'dispatch;
	}
	pc = 0x821E3064; continue 'dispatch;
            }
            0x821E3064 => {
    //   block [0x821E3064..0x821E307C)
	// 821E3064: 8163309C  lwz r11, 0x309c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12444 as u32) ) } as u64;
	// 821E3068: 814331BC  lwz r10, 0x31bc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12732 as u32) ) } as u64;
	// 821E306C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E3070: 419A000C  beq cr6, 0x821e307c
	if ctx.cr[6].eq {
	pc = 0x821E307C; continue 'dispatch;
	}
	// 821E3074: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3078: 409A0054  bne cr6, 0x821e30cc
	if !ctx.cr[6].eq {
	pc = 0x821E30CC; continue 'dispatch;
	}
	pc = 0x821E307C; continue 'dispatch;
            }
            0x821E307C => {
    //   block [0x821E307C..0x821E3094)
	// 821E307C: 816330A0  lwz r11, 0x30a0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12448 as u32) ) } as u64;
	// 821E3080: 814331C0  lwz r10, 0x31c0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12736 as u32) ) } as u64;
	// 821E3084: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E3088: 419A000C  beq cr6, 0x821e3094
	if ctx.cr[6].eq {
	pc = 0x821E3094; continue 'dispatch;
	}
	// 821E308C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3090: 409A003C  bne cr6, 0x821e30cc
	if !ctx.cr[6].eq {
	pc = 0x821E30CC; continue 'dispatch;
	}
	pc = 0x821E3094; continue 'dispatch;
            }
            0x821E3094 => {
    //   block [0x821E3094..0x821E30AC)
	// 821E3094: 816330A4  lwz r11, 0x30a4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12452 as u32) ) } as u64;
	// 821E3098: 814331C4  lwz r10, 0x31c4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12740 as u32) ) } as u64;
	// 821E309C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E30A0: 419A000C  beq cr6, 0x821e30ac
	if ctx.cr[6].eq {
	pc = 0x821E30AC; continue 'dispatch;
	}
	// 821E30A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E30A8: 409A0024  bne cr6, 0x821e30cc
	if !ctx.cr[6].eq {
	pc = 0x821E30CC; continue 'dispatch;
	}
	pc = 0x821E30AC; continue 'dispatch;
            }
            0x821E30AC => {
    //   block [0x821E30AC..0x821E30C4)
	// 821E30AC: 816330A8  lwz r11, 0x30a8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12456 as u32) ) } as u64;
	// 821E30B0: 814331C8  lwz r10, 0x31c8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12744 as u32) ) } as u64;
	// 821E30B4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E30B8: 419A000C  beq cr6, 0x821e30c4
	if ctx.cr[6].eq {
	pc = 0x821E30C4; continue 'dispatch;
	}
	// 821E30BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E30C0: 409A000C  bne cr6, 0x821e30cc
	if !ctx.cr[6].eq {
	pc = 0x821E30CC; continue 'dispatch;
	}
	pc = 0x821E30C4; continue 'dispatch;
            }
            0x821E30C4 => {
    //   block [0x821E30C4..0x821E30CC)
	// 821E30C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E30C8: 48000008  b 0x821e30d0
	pc = 0x821E30D0; continue 'dispatch;
            }
            0x821E30CC => {
    //   block [0x821E30CC..0x821E30D0)
	// 821E30CC: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x821E30D0; continue 'dispatch;
            }
            0x821E30D0 => {
    //   block [0x821E30D0..0x821E30D4)
	// 821E30D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x821E30D4; continue 'dispatch;
            }
            0x821E30D4 => {
    //   block [0x821E30D4..0x821E30EC)
	// 821E30D4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E30D8: 41820014  beq 0x821e30ec
	if ctx.cr[0].eq {
	pc = 0x821E30EC; continue 'dispatch;
	}
	// 821E30DC: 8163337C  lwz r11, 0x337c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(13180 as u32) ) } as u64;
	// 821E30E0: 81433380  lwz r10, 0x3380(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(13184 as u32) ) } as u64;
	// 821E30E4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821E30E8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x821E30EC; continue 'dispatch;
            }
            0x821E30EC => {
    //   block [0x821E30EC..0x821E30F0)
	// 821E30EC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	pc = 0x821E30F0; continue 'dispatch;
            }
            0x821E30F0 => {
    //   block [0x821E30F0..0x821E3108)
	// 821E30F0: 48048801  bl 0x8222b8f0
	ctx.lr = 0x821E30F4;
	sub_8222B8F0(ctx, base);
	// 821E30F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E30F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E30FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E3100: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E3104: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E3108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E3108 size=120
    let mut pc: u32 = 0x821E3108;
    'dispatch: loop {
        match pc {
            0x821E3108 => {
    //   block [0x821E3108..0x821E3134)
	// 821E3108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E310C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E3110: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821E3114: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E3118: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E311C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E3120: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E3124: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821E3128: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821E312C: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 821E3130: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x821E3134; continue 'dispatch;
            }
            0x821E3134 => {
    //   block [0x821E3134..0x821E3180)
	// 821E3134: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821E3138: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E313C: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821E3140: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821E3144: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821E3148: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E314C: 4082FFE8  bne 0x821e3134
	if !ctx.cr[0].eq {
	pc = 0x821E3134; continue 'dispatch;
	}
	// 821E3150: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3154: 4808204D  bl 0x822651a0
	ctx.lr = 0x821E3158;
	sub_822651A0(ctx, base);
	// 821E3158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E315C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E3160: 48009699  bl 0x821ec7f8
	ctx.lr = 0x821E3164;
	sub_821EC7F8(ctx, base);
	// 821E3164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3168: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E316C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E3170: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E3174: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E3178: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E317C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E3180(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E3180 size=812
    let mut pc: u32 = 0x821E3180;
    'dispatch: loop {
        match pc {
            0x821E3180 => {
    //   block [0x821E3180..0x821E3280)
	// 821E3180: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E3184: 48AC6261  bl 0x82ca93e4
	ctx.lr = 0x821E3188;
	sub_82CA93D0(ctx, base);
	// 821E3188: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 821E318C: 48ACAB4D  bl 0x82cadcd8
	ctx.lr = 0x821E3190;
	sub_82CADCA0(ctx, base);
	// 821E3190: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E3194: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821E3198: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E319C: 3EC08349  lis r22, -0x7cb7
	ctx.r[22].s64 = -2092367872;
	// 821E31A0: 396BF1C8  addi r11, r11, -0xe38
	ctx.r[11].s64 = ctx.r[11].s64 + -3640;
	// 821E31A4: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 821E31A8: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E31AC: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821E31B0: 3A600001  li r19, 1
	ctx.r[19].s64 = 1;
	// 821E31B4: 3D208332  lis r9, -0x7cce
	ctx.r[9].s64 = -2093875200;
	// 821E31B8: C8166F08  lfd f0, 0x6f08(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[22].u32.wrapping_add(28424 as u32) ) };
	// 821E31BC: C3EBA2BC  lfs f31, -0x5d44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-23876 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821E31C0: C9A80D38  lfd f13, 0xd38(r8)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(3384 as u32) ) };
	// 821E31C4: FFA0F890  fmr f29, f31
	ctx.f[29].f64 = ctx.f[31].f64;
	// 821E31C8: 828A0008  lwz r20, 8(r10)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E31CC: CB876E18  lfd f28, 0x6e18(r7)
	ctx.f[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(28184 as u32) ) };
	// 821E31D0: 7E6A9B78  mr r10, r19
	ctx.r[10].u64 = ctx.r[19].u64;
	// 821E31D4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821E31D8: 3BA9AC70  addi r29, r9, -0x5390
	ctx.r[29].s64 = ctx.r[9].s64 + -21392;
	// 821E31DC: 419A00A4  beq cr6, 0x821e3280
	if ctx.cr[6].eq {
	pc = 0x821E3280; continue 'dispatch;
	}
	// 821E31E0: FD7C0028  fsub f11, f28, f0
	ctx.f[11].f64 = ctx.f[28].f64 - ctx.f[0].f64;
	// 821E31E4: C1BD0024  lfs f13, 0x24(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E31E8: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 821E31EC: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821E31F0: 3D208331  lis r9, -0x7ccf
	ctx.r[9].s64 = -2093940736;
	// 821E31F4: 390A0E68  addi r8, r10, 0xe68
	ctx.r[8].s64 = ctx.r[10].s64 + 3688;
	// 821E31F8: C0097E84  lfs f0, 0x7e84(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E31FC: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 821E3200: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 821E3204: FF09F800  fcmpu cr6, f9, f31
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[31].f64);
	// 821E3208: 7CE00026  mfcr r7
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[7].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821E320C: 54E6DF7A  rlwinm r6, r7, 0x1b, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 821E3210: 54E5F77A  rlwinm r5, r7, 0x1e, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 821E3214: 7CC42B78  or r4, r6, r5
	ctx.r[4].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 821E3218: 7D08242E  lfsx f8, r8, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821E321C: FCE8FA6E  fsel f7, f8, f9, f31
	ctx.f[7].f64 = if ctx.f[8].f64 >= 0.0 { ctx.f[9].f64 } else { ctx.f[31].f64 };
	// 821E3220: ECC70028  fsubs f6, f7, f0
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 821E3224: FF06F800  fcmpu cr6, f6, f31
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[31].f64);
	// 821E3228: 7C600026  mfcr r3
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[3].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821E322C: 546BDF7A  rlwinm r11, r3, 0x1b, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000001Fu64;
	// 821E3230: 546AF77A  rlwinm r10, r3, 0x1e, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x00000003u64;
	// 821E3234: 7D695378  or r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 821E3238: 7CA84C2E  lfsx f5, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821E323C: FFC5382E  fsel f30, f5, f0, f7
	ctx.f[30].f64 = if ctx.f[5].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[7].f64 };
	// 821E3240: EC3E0332  fmuls f1, f30, f12
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[12].f64) as f32) as f64);
	// 821E3244: 480B27C5  bl 0x82295a08
	ctx.lr = 0x821E3248;
	sub_82295A08(ctx, base);
	// 821E3248: FC800818  frsp f4, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[4].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821E324C: FC60201E  fctiwz f3, f4
	ctx.f[3].s64 = if ctx.f[4].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[4].f64.trunc() as i32 as i64 };
	// 821E3250: D8610050  stfd f3, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[3].u64 ) };
	// 821E3254: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E3258: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 821E325C: 7D68FE70  srawi r8, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 821E3260: 7D075838  and r7, r8, r11
	ctx.r[7].u64 = ctx.r[8].u64 & ctx.r[11].u64;
	// 821E3264: 7D475050  subf r10, r7, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 821E3268: 7D4607B4  extsw r6, r10
	ctx.r[6].s64 = ctx.r[10].s32 as i64;
	// 821E326C: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 821E3270: C8410050  lfd f2, 0x50(r1)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E3274: FC20169C  fcfid f1, f2
	ctx.f[1].f64 = (ctx.f[2].s64 as f64);
	// 821E3278: FC000818  frsp f0, f1
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821E327C: EFBE0024  fdivs f29, f30, f0
	ctx.f[29].f64 = ((ctx.f[30].f64 / ctx.f[0].f64) as f32) as f64;
	pc = 0x821E3280; continue 'dispatch;
            }
            0x821E3280 => {
    //   block [0x821E3280..0x821E32A4)
	// 821E3280: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821E3284: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E3288: 7F38CB78  mr r24, r25
	ctx.r[24].u64 = ctx.r[25].u64;
	// 821E328C: 40990180  ble cr6, 0x821e340c
	if !ctx.cr[6].gt {
	pc = 0x821E340C; continue 'dispatch;
	}
	// 821E3290: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E3294: 3AEB5058  addi r23, r11, 0x5058
	ctx.r[23].s64 = ctx.r[11].s64 + 20568;
	// 821E3298: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E329C: 7D755B78  mr r21, r11
	ctx.r[21].u64 = ctx.r[11].u64;
	// 821E32A0: 834B0000  lwz r26, 0(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821E32A4; continue 'dispatch;
            }
            0x821E32A4 => {
    //   block [0x821E32A4..0x821E32B8)
	// 821E32A4: 7F1AA840  cmplw cr6, r26, r21
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[21].u32, &mut ctx.xer);
	// 821E32A8: 419A0164  beq cr6, 0x821e340c
	if ctx.cr[6].eq {
	pc = 0x821E340C; continue 'dispatch;
	}
	// 821E32AC: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E32B0: 409A0008  bne cr6, 0x821e32b8
	if !ctx.cr[6].eq {
	pc = 0x821E32B8; continue 'dispatch;
	}
	// 821E32B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E32B8; continue 'dispatch;
            }
            0x821E32B8 => {
    //   block [0x821E32B8..0x821E3300)
	// 821E32B8: 83FA0008  lwz r31, 8(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E32BC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E32C0: 9B3F0112  stb r25, 0x112(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(274 as u32), ctx.r[25].u8 ) };
	// 821E32C4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E32C8: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E32CC: 7F09A000  cmpw cr6, r9, r20
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[20].s32, &mut ctx.xer);
	// 821E32D0: 409A0124  bne cr6, 0x821e33f4
	if !ctx.cr[6].eq {
	pc = 0x821E33F4; continue 'dispatch;
	}
	// 821E32D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E32D8: 4BFFEC11  bl 0x821e1ee8
	ctx.lr = 0x821E32DC;
	sub_821E1EE8(ctx, base);
	// 821E32DC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821E32E0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821E32E4: 419A0110  beq cr6, 0x821e33f4
	if ctx.cr[6].eq {
	pc = 0x821E33F4; continue 'dispatch;
	}
	// 821E32E8: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E32EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E32F0: 409A0010  bne cr6, 0x821e3300
	if !ctx.cr[6].eq {
	pc = 0x821E3300; continue 'dispatch;
	}
	// 821E32F4: 897F0110  lbz r11, 0x110(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(272 as u32) ) } as u64;
	// 821E32F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E32FC: 419A001C  beq cr6, 0x821e3318
	if ctx.cr[6].eq {
	pc = 0x821E3318; continue 'dispatch;
	}
	pc = 0x821E3300; continue 'dispatch;
            }
            0x821E3300 => {
    //   block [0x821E3300..0x821E3314)
	// 821E3300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3304: 4BFFEBE5  bl 0x821e1ee8
	ctx.lr = 0x821E3308;
	sub_821E1EE8(ctx, base);
	// 821E3308: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E330C: 419A0008  beq cr6, 0x821e3314
	if ctx.cr[6].eq {
	pc = 0x821E3314; continue 'dispatch;
	}
	// 821E3310: 488B0F99  bl 0x82a942a8
	ctx.lr = 0x821E3314;
	sub_82A942A8(ctx, base);
	pc = 0x821E3314; continue 'dispatch;
            }
            0x821E3314 => {
    //   block [0x821E3314..0x821E3318)
	// 821E3314: 9B3F0110  stb r25, 0x110(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), ctx.r[25].u8 ) };
	pc = 0x821E3318; continue 'dispatch;
            }
            0x821E3318 => {
    //   block [0x821E3318..0x821E3330)
	// 821E3318: 3BDF00D0  addi r30, r31, 0xd0
	ctx.r[30].s64 = ctx.r[31].s64 + 208;
	// 821E331C: C81B02E8  lfd f0, 0x2e8(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(744 as u32) ) };
	// 821E3320: 395F0090  addi r10, r31, 0x90
	ctx.r[10].s64 = ctx.r[31].s64 + 144;
	// 821E3324: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821E3328: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821E332C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821E3330; continue 'dispatch;
            }
            0x821E3330 => {
    //   block [0x821E3330..0x821E3364)
	// 821E3330: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821E3334: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E3338: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821E333C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E3340: 4200FFF0  bdnz 0x821e3330
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821E3330; continue 'dispatch;
	}
	// 821E3344: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E3348: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E334C: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821E3350: 4BFFED89  bl 0x821e20d8
	ctx.lr = 0x821E3354;
	sub_821E20D8(ctx, base);
	// 821E3354: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821E3358: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 821E335C: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821E3360: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821E3364; continue 'dispatch;
            }
            0x821E3364 => {
    //   block [0x821E3364..0x821E33F0)
	// 821E3364: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821E3368: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E336C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821E3370: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E3374: 4200FFF0  bdnz 0x821e3364
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821E3364; continue 'dispatch;
	}
	// 821E3378: E97C0190  ld r11, 0x190(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(400 as u32) ) };
	// 821E337C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821E3380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3384: 395C0190  addi r10, r28, 0x190
	ctx.r[10].s64 = ctx.r[28].s64 + 400;
	// 821E3388: 393F0060  addi r9, r31, 0x60
	ctx.r[9].s64 = ctx.r[31].s64 + 96;
	// 821E338C: F97F0060  std r11, 0x60(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821E3390: E91C0198  ld r8, 0x198(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(408 as u32) ) };
	// 821E3394: F91F0068  std r8, 0x68(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 821E3398: E8FC01A0  ld r7, 0x1a0(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(416 as u32) ) };
	// 821E339C: F8FF0070  std r7, 0x70(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[7].u64 ) };
	// 821E33A0: E8DC01A8  ld r6, 0x1a8(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(424 as u32) ) };
	// 821E33A4: F8DF0078  std r6, 0x78(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[6].u64 ) };
	// 821E33A8: E8BC01B0  ld r5, 0x1b0(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(432 as u32) ) };
	// 821E33AC: F8BF0080  std r5, 0x80(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[5].u64 ) };
	// 821E33B0: E97C01B8  ld r11, 0x1b8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(440 as u32) ) };
	// 821E33B4: F97F0088  std r11, 0x88(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u64 ) };
	// 821E33B8: 480000F9  bl 0x821e34b0
	ctx.lr = 0x821E33BC;
	sub_821E34B0(ctx, base);
	// 821E33BC: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821E33C0: FF1EF800  fcmpu cr6, f30, f31
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 821E33C4: 4099002C  ble cr6, 0x821e33f0
	if !ctx.cr[6].gt {
	pc = 0x821E33F0; continue 'dispatch;
	}
	// 821E33C8: 9A7F0111  stb r19, 0x111(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(273 as u32), ctx.r[19].u8 ) };
	// 821E33CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E33D0: 4BFEEC09  bl 0x821d1fd8
	ctx.lr = 0x821E33D4;
	sub_821D1FD8(ctx, base);
	// 821E33D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E33D8: C87B02E8  lfd f3, 0x2e8(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(744 as u32) ) };
	// 821E33DC: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 821E33E0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821E33E4: 4BFC8B0D  bl 0x821abef0
	ctx.lr = 0x821E33E8;
	sub_821ABEF0(ctx, base);
	// 821E33E8: 7E789B78  mr r24, r19
	ctx.r[24].u64 = ctx.r[19].u64;
	// 821E33EC: 48000008  b 0x821e33f4
	pc = 0x821E33F4; continue 'dispatch;
            }
            0x821E33F0 => {
    //   block [0x821E33F0..0x821E33F4)
	// 821E33F0: 9B3F0111  stb r25, 0x111(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(273 as u32), ctx.r[25].u8 ) };
	pc = 0x821E33F4; continue 'dispatch;
            }
            0x821E33F4 => {
    //   block [0x821E33F4..0x821E3404)
	// 821E33F4: 81770004  lwz r11, 4(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E33F8: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E33FC: 409A0008  bne cr6, 0x821e3404
	if !ctx.cr[6].eq {
	pc = 0x821E3404; continue 'dispatch;
	}
	// 821E3400: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E3404; continue 'dispatch;
            }
            0x821E3404 => {
    //   block [0x821E3404..0x821E340C)
	// 821E3404: 835A0000  lwz r26, 0(r26)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3408: 4BFFFE9C  b 0x821e32a4
	pc = 0x821E32A4; continue 'dispatch;
            }
            0x821E340C => {
    //   block [0x821E340C..0x821E3494)
	// 821E340C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 821E3410: DB966F08  stfd f28, 0x6f08(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[22].u32.wrapping_add(28424 as u32), ctx.f[28].u64 ) };
	// 821E3414: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 821E3418: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 821E341C: 997D0001  stb r11, 1(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 821E3420: 5708063E  clrlwi r8, r24, 0x18
	ctx.r[8].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 821E3424: 995D0003  stb r10, 3(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(3 as u32), ctx.r[10].u8 ) };
	// 821E3428: 993D0002  stb r9, 2(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(2 as u32), ctx.r[9].u8 ) };
	// 821E342C: 997D0005  stb r11, 5(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(5 as u32), ctx.r[11].u8 ) };
	// 821E3430: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E3434: 995D0006  stb r10, 6(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(6 as u32), ctx.r[10].u8 ) };
	// 821E3438: 993D0007  stb r9, 7(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(7 as u32), ctx.r[9].u8 ) };
	// 821E343C: 997D0008  stb r11, 8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 821E3440: 995D0000  stb r10, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 821E3444: 419A0058  beq cr6, 0x821e349c
	if ctx.cr[6].eq {
	pc = 0x821E349C; continue 'dispatch;
	}
	// 821E3448: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E344C: 83CB5030  lwz r30, 0x5030(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20528 as u32) ) } as u64;
	// 821E3450: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E3454: 490D6511  bl 0x832b9964
	ctx.lr = 0x821E3458;
	// extern call 0x832B9964  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 821E3458: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 821E345C: 895F6F04  lbz r10, 0x6f04(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28420 as u32) ) } as u64;
	// 821E3460: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E3464: 409A0030  bne cr6, 0x821e3494
	if !ctx.cr[6].eq {
	pc = 0x821E3494; continue 'dispatch;
	}
	// 821E3468: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E346C: 806B6F14  lwz r3, 0x6f14(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28436 as u32) ) } as u64;
	// 821E3470: 4BFAA7A9  bl 0x8218dc18
	ctx.lr = 0x821E3474;
	sub_8218DC18(ctx, base);
	// 821E3474: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821E3478: 806A6F10  lwz r3, 0x6f10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28432 as u32) ) } as u64;
	// 821E347C: 480E5F0D  bl 0x822c9388
	ctx.lr = 0x821E3480;
	sub_822C9388(ctx, base);
	// 821E3480: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	// 821E3484: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 821E3488: 997F6F04  stb r11, 0x6f04(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28420 as u32), ctx.r[11].u8 ) };
	// 821E348C: 38695040  addi r3, r9, 0x5040
	ctx.r[3].s64 = ctx.r[9].s64 + 20544;
	// 821E3490: 48831901  bl 0x82a14d90
	ctx.lr = 0x821E3494;
	sub_82A14D90(ctx, base);
	pc = 0x821E3494; continue 'dispatch;
            }
            0x821E3494 => {
    //   block [0x821E3494..0x821E349C)
	// 821E3494: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E3498: 490D64BD  bl 0x832b9954
	ctx.lr = 0x821E349C;
	// extern call 0x832B9954  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	pc = 0x821E349C; continue 'dispatch;
            }
            0x821E349C => {
    //   block [0x821E349C..0x821E34AC)
	// 821E349C: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 821E34A0: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 821E34A4: 48ACA881  bl 0x82cadd24
	ctx.lr = 0x821E34A8;
	sub_82CADCEC(ctx, base);
	// 821E34A8: 48AC5F8C  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E34B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E34B0 size=296
    let mut pc: u32 = 0x821E34B0;
    'dispatch: loop {
        match pc {
            0x821E34B0 => {
    //   block [0x821E34B0..0x821E35D8)
	// 821E34B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E34B4: 48AC5F55  bl 0x82ca9408
	ctx.lr = 0x821E34B8;
	sub_82CA93D0(ctx, base);
	// 821E34B8: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 821E34BC: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 821E34C0: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821E34C4: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E35D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E35D8 size=348
    let mut pc: u32 = 0x821E35D8;
    'dispatch: loop {
        match pc {
            0x821E35D8 => {
    //   block [0x821E35D8..0x821E3624)
	// 821E35D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E35DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E35E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E35E4: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 821E35E8: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821E35EC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E35F0: 80C30004  lwz r6, 4(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E35F4: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 821E35F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821E35FC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E3600: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821E3604: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 821E3608: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821E360C: 81260018  lwz r9, 0x18(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 821E3610: 80A6001C  lwz r5, 0x1c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821E3614: 7D092850  subf r8, r9, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[9].s64;
	// 821E3618: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 821E361C: 7D685BD7  divw. r11, r8, r11
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E3620: 4081005C  ble 0x821e367c
	if !ctx.cr[0].gt {
	pc = 0x821E367C; continue 'dispatch;
	}
	pc = 0x821E3624; continue 'dispatch;
            }
            0x821E3624 => {
    //   block [0x821E3624..0x821E364C)
	// 821E3624: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E3628: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E362C: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821E3630: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E3634: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821E3638: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E363C: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 821E3640: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E3644: 41980008  blt cr6, 0x821e364c
	if ctx.cr[6].lt {
	pc = 0x821E364C; continue 'dispatch;
	}
	// 821E3648: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821E364C; continue 'dispatch;
            }
            0x821E364C => {
    //   block [0x821E364C..0x821E3668)
	// 821E364C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E3650: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E3654: 419A0014  beq cr6, 0x821e3668
	if ctx.cr[6].eq {
	pc = 0x821E3668; continue 'dispatch;
	}
	// 821E3658: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821E365C: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 821E3660: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E3664: 4800000C  b 0x821e3670
	pc = 0x821E3670; continue 'dispatch;
            }
            0x821E3668 => {
    //   block [0x821E3668..0x821E3670)
	// 821E3668: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 821E366C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x821E3670; continue 'dispatch;
            }
            0x821E3670 => {
    //   block [0x821E3670..0x821E367C)
	// 821E3670: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E3674: 4199FFB0  bgt cr6, 0x821e3624
	if ctx.cr[6].gt {
	pc = 0x821E3624; continue 'dispatch;
	}
	// 821E3678: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x821E367C; continue 'dispatch;
            }
            0x821E367C => {
    //   block [0x821E367C..0x821E3698)
	// 821E367C: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821E3680: 419A0034  beq cr6, 0x821e36b4
	if ctx.cr[6].eq {
	pc = 0x821E36B4; continue 'dispatch;
	}
	// 821E3684: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3688: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821E368C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E3690: 41990008  bgt cr6, 0x821e3698
	if ctx.cr[6].gt {
	pc = 0x821E3698; continue 'dispatch;
	}
	// 821E3694: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821E3698; continue 'dispatch;
            }
            0x821E3698 => {
    //   block [0x821E3698..0x821E36B4)
	// 821E3698: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E369C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E36A0: 409A0014  bne cr6, 0x821e36b4
	if !ctx.cr[6].eq {
	pc = 0x821E36B4; continue 'dispatch;
	}
	// 821E36A4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E36A8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821E36AC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E36B0: 48000008  b 0x821e36b8
	pc = 0x821E36B8; continue 'dispatch;
            }
            0x821E36B4 => {
    //   block [0x821E36B4..0x821E36B8)
	// 821E36B4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	pc = 0x821E36B8; continue 'dispatch;
            }
            0x821E36B8 => {
    //   block [0x821E36B8..0x821E36D0)
	// 821E36B8: 8146001C  lwz r10, 0x1c(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821E36BC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E36C0: 419A0010  beq cr6, 0x821e36d0
	if ctx.cr[6].eq {
	pc = 0x821E36D0; continue 'dispatch;
	}
	// 821E36C4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E36C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E36CC: 4800000C  b 0x821e36d8
	pc = 0x821E36D8; continue 'dispatch;
            }
            0x821E36D0 => {
    //   block [0x821E36D0..0x821E36D8)
	// 821E36D0: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E36D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821E36D8; continue 'dispatch;
            }
            0x821E36D8 => {
    //   block [0x821E36D8..0x821E3714)
	// 821E36D8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E36DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E36E0: 419A0034  beq cr6, 0x821e3714
	if ctx.cr[6].eq {
	pc = 0x821E3714; continue 'dispatch;
	}
	// 821E36E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E36E8: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E36EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E36F0: 4E800421  bctrl
	ctx.lr = 0x821E36F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E36F4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E36F8: 419A001C  beq cr6, 0x821e3714
	if ctx.cr[6].eq {
	pc = 0x821E3714; continue 'dispatch;
	}
	// 821E36FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E3700: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821E3704: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E3708: 48011691  bl 0x821f4d98
	ctx.lr = 0x821E370C;
	sub_821F4D98(ctx, base);
	// 821E370C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821E3710: 48000008  b 0x821e3718
	pc = 0x821E3718; continue 'dispatch;
            }
            0x821E3714 => {
    //   block [0x821E3714..0x821E3718)
	// 821E3714: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821E3718; continue 'dispatch;
            }
            0x821E3718 => {
    //   block [0x821E3718..0x821E3734)
	// 821E3718: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E371C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E3720: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E3724: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821E3728: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E372C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E3730: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E3738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E3738 size=1620
    let mut pc: u32 = 0x821E3738;
    'dispatch: loop {
        match pc {
            0x821E3738 => {
    //   block [0x821E3738..0x821E3794)
	// 821E3738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E373C: 48AC5CC1  bl 0x82ca93fc
	ctx.lr = 0x821E3740;
	sub_82CA93D0(ctx, base);
	// 821E3740: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 821E3744: 48ACA595  bl 0x82cadcd8
	ctx.lr = 0x821E3748;
	sub_82CADCA0(ctx, base);
	// 821E3748: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E374C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821E3750: 4BFB6341  bl 0x82199a90
	ctx.lr = 0x821E3754;
	sub_82199A90(ctx, base);
	// 821E3754: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821E3758: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E375C: 4BFD727D  bl 0x821ba9d8
	ctx.lr = 0x821E3760;
	sub_821BA9D8(ctx, base);
	// 821E3760: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E3764: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821E3768: C39D006C  lfs f28, 0x6c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821E376C: 395D0004  addi r10, r29, 4
	ctx.r[10].s64 = ctx.r[29].s64 + 4;
	// 821E3770: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821E3774: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 821E3778: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E377C: 419A0020  beq cr6, 0x821e379c
	if ctx.cr[6].eq {
	pc = 0x821E379C; continue 'dispatch;
	}
	// 821E3780: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3784: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E3788: 419A000C  beq cr6, 0x821e3794
	if ctx.cr[6].eq {
	pc = 0x821E3794; continue 'dispatch;
	}
	// 821E378C: 552B003E  slwi r11, r9, 0
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E3790: 48000010  b 0x821e37a0
	pc = 0x821E37A0; continue 'dispatch;
            }
            0x821E3794 => {
    //   block [0x821E3794..0x821E379C)
	// 821E3794: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 821E3798: 4BFB06A1  bl 0x82193e38
	ctx.lr = 0x821E379C;
	sub_82193E38(ctx, base);
	pc = 0x821E379C; continue 'dispatch;
            }
            0x821E379C => {
    //   block [0x821E379C..0x821E37A0)
	// 821E379C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821E37A0; continue 'dispatch;
            }
            0x821E37A0 => {
    //   block [0x821E37A0..0x821E37E0)
	// 821E37A0: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821E37A4: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 821E37A8: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 821E37AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E37B0: 419A00F4  beq cr6, 0x821e38a4
	if ctx.cr[6].eq {
	pc = 0x821E38A4; continue 'dispatch;
	}
	// 821E37B4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E37B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E37BC: 419A0024  beq cr6, 0x821e37e0
	if ctx.cr[6].eq {
	pc = 0x821E37E0; continue 'dispatch;
	}
	// 821E37C0: 894A0022  lbz r10, 0x22(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(34 as u32) ) } as u64;
	// 821E37C4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E37C8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821E37CC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E37D0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E37D4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821E37D8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821E37DC: 480000CC  b 0x821e38a8
	pc = 0x821E38A8; continue 'dispatch;
            }
            0x821E37E0 => {
    //   block [0x821E37E0..0x821E37FC)
	// 821E37E0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E37E4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E37E8: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 821E37EC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E37F0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821E37F4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E37F8: 40810054  ble 0x821e384c
	if !ctx.cr[0].gt {
	pc = 0x821E384C; continue 'dispatch;
	}
	pc = 0x821E37FC; continue 'dispatch;
            }
            0x821E37FC => {
    //   block [0x821E37FC..0x821E381C)
	// 821E37FC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E3800: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E3804: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E3808: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E380C: 2F070022  cmpwi cr6, r7, 0x22
	ctx.cr[6].compare_i32(ctx.r[7].s32, 34, &mut ctx.xer);
	// 821E3810: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 821E3814: 41980008  blt cr6, 0x821e381c
	if ctx.cr[6].lt {
	pc = 0x821E381C; continue 'dispatch;
	}
	// 821E3818: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x821E381C; continue 'dispatch;
            }
            0x821E381C => {
    //   block [0x821E381C..0x821E3838)
	// 821E381C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E3820: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E3824: 419A0014  beq cr6, 0x821e3838
	if ctx.cr[6].eq {
	pc = 0x821E3838; continue 'dispatch;
	}
	// 821E3828: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E382C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E3830: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E3834: 4800000C  b 0x821e3840
	pc = 0x821E3840; continue 'dispatch;
            }
            0x821E3838 => {
    //   block [0x821E3838..0x821E3840)
	// 821E3838: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E383C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821E3840; continue 'dispatch;
            }
            0x821E3840 => {
    //   block [0x821E3840..0x821E384C)
	// 821E3840: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E3844: 4199FFB8  bgt cr6, 0x821e37fc
	if ctx.cr[6].gt {
	pc = 0x821E37FC; continue 'dispatch;
	}
	// 821E3848: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x821E384C; continue 'dispatch;
            }
            0x821E384C => {
    //   block [0x821E384C..0x821E3868)
	// 821E384C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E3850: 419A0040  beq cr6, 0x821e3890
	if ctx.cr[6].eq {
	pc = 0x821E3890; continue 'dispatch;
	}
	// 821E3854: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3858: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 821E385C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821E3860: 41990008  bgt cr6, 0x821e3868
	if ctx.cr[6].gt {
	pc = 0x821E3868; continue 'dispatch;
	}
	// 821E3864: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821E3868; continue 'dispatch;
            }
            0x821E3868 => {
    //   block [0x821E3868..0x821E3890)
	// 821E3868: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E386C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3870: 409A0020  bne cr6, 0x821e3890
	if !ctx.cr[6].eq {
	pc = 0x821E3890; continue 'dispatch;
	}
	// 821E3874: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821E3878: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821E387C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821E3880: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E3884: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821E3888: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821E388C: 4800001C  b 0x821e38a8
	pc = 0x821E38A8; continue 'dispatch;
            }
            0x821E3890 => {
    //   block [0x821E3890..0x821E38A4)
	// 821E3890: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E3894: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E3898: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821E389C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 821E38A0: 48000008  b 0x821e38a8
	pc = 0x821E38A8; continue 'dispatch;
            }
            0x821E38A4 => {
    //   block [0x821E38A4..0x821E38A8)
	// 821E38A4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821E38A8; continue 'dispatch;
            }
            0x821E38A8 => {
    //   block [0x821E38A8..0x821E38BC)
	// 821E38A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E38AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E38B0: 419A000C  beq cr6, 0x821e38bc
	if ctx.cr[6].eq {
	pc = 0x821E38BC; continue 'dispatch;
	}
	// 821E38B4: C01F003C  lfs f0, 0x3c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E38B8: EF800732  fmuls f28, f0, f28
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	pc = 0x821E38BC; continue 'dispatch;
            }
            0x821E38BC => {
    //   block [0x821E38BC..0x821E3930)
	// 821E38BC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E38C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E38C4: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E38C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E38CC: 4E800421  bctrl
	ctx.lr = 0x821E38D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E38D0: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 821E38D4: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821E38D8: 4803B981  bl 0x8221f258
	ctx.lr = 0x821E38DC;
	sub_8221F258(ctx, base);
	// 821E38DC: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821E38E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E38E4: 39099490  addi r8, r9, -0x6b70
	ctx.r[8].s64 = ctx.r[9].s64 + -27504;
	// 821E38E8: C3A99490  lfs f29, -0x6b70(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821E38EC: C3E8FFF4  lfs f31, -0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821E38F0: 419A0040  beq cr6, 0x821e3930
	if ctx.cr[6].eq {
	pc = 0x821E3930; continue 'dispatch;
	}
	// 821E38F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E38F8: D3E30008  stfs f31, 8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821E38FC: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821E3900: D3E3000C  stfs f31, 0xc(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821E3904: 392B21E0  addi r9, r11, 0x21e0
	ctx.r[9].s64 = ctx.r[11].s64 + 8672;
	// 821E3908: D3C30010  stfs f30, 0x10(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821E390C: D3A30014  stfs f29, 0x14(r3)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821E3910: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821E3914: D3830020  stfs f28, 0x20(r3)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821E3918: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E391C: 91430018  stw r10, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 821E3920: 9B83001C  stb r28, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[28].u8 ) };
	// 821E3924: 9B83001D  stb r28, 0x1d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(29 as u32), ctx.r[28].u8 ) };
	// 821E3928: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821E392C: 48000008  b 0x821e3934
	pc = 0x821E3934; continue 'dispatch;
            }
            0x821E3930 => {
    //   block [0x821E3930..0x821E3934)
	// 821E3930: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x821E3934; continue 'dispatch;
            }
            0x821E3934 => {
    //   block [0x821E3934..0x821E39C8)
	// 821E3934: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3938: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 821E393C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E3940: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E3944: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E3948: 4E800421  bctrl
	ctx.lr = 0x821E394C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E394C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E3950: 419A0304  beq cr6, 0x821e3c54
	if ctx.cr[6].eq {
	pc = 0x821E3C54; continue 'dispatch;
	}
	// 821E3954: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3958: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E395C: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E3960: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E3964: 4E800421  bctrl
	ctx.lr = 0x821E3968;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E3968: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E396C: 889D0076  lbz r4, 0x76(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(118 as u32) ) } as u64;
	// 821E3970: 81090010  lwz r8, 0x10(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E3974: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821E3978: 4E800421  bctrl
	ctx.lr = 0x821E397C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E397C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 821E3980: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821E3984: 38871808  addi r4, r7, 0x1808
	ctx.r[4].s64 = ctx.r[7].s64 + 6152;
	// 821E3988: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E398C: 48049545  bl 0x8222ced0
	ctx.lr = 0x821E3990;
	sub_8222CED0(ctx, base);
	// 821E3990: 80DB0000  lwz r6, 0(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3994: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 821E3998: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E399C: 80A60020  lwz r5, 0x20(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E39A0: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 821E39A4: 4E800421  bctrl
	ctx.lr = 0x821E39A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E39A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E39AC: 48089C15  bl 0x8226d5c0
	ctx.lr = 0x821E39B0;
	sub_8226D5C0(ctx, base);
	// 821E39B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E39B4: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821E39B8: 48031421  bl 0x82214dd8
	ctx.lr = 0x821E39BC;
	sub_82214DD8(ctx, base);
	// 821E39BC: FF1EF800  fcmpu cr6, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 821E39C0: 40990008  ble cr6, 0x821e39c8
	if !ctx.cr[6].gt {
	pc = 0x821E39C8; continue 'dispatch;
	}
	// 821E39C4: D3DE0008  stfs f30, 8(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
            }
            0x821E39C8 => {
    //   block [0x821E39C8..0x821E3A14)
	// 821E39C8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E39CC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821E39D0: 388B1100  addi r4, r11, 0x1100
	ctx.r[4].s64 = ctx.r[11].s64 + 4352;
	// 821E39D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E39D8: 480494F9  bl 0x8222ced0
	ctx.lr = 0x821E39DC;
	sub_8222CED0(ctx, base);
	// 821E39DC: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E39E0: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 821E39E4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E39E8: 812A0020  lwz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E39EC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E39F0: 4E800421  bctrl
	ctx.lr = 0x821E39F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E39F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E39F8: 4BFF7419  bl 0x821dae10
	ctx.lr = 0x821E39FC;
	sub_821DAE10(ctx, base);
	// 821E39FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E3A00: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821E3A04: 480313D5  bl 0x82214dd8
	ctx.lr = 0x821E3A08;
	sub_82214DD8(ctx, base);
	// 821E3A08: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821E3A0C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 821E3A10: 38A87088  addi r5, r8, 0x7088
	ctx.r[5].s64 = ctx.r[8].s64 + 28808;
            }
            0x821E3A14 => {
    //   block [0x821E3A14..0x821E3AC4)
	// 821E3A14: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 821E3A18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E3A1C: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 821E3A20: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821E3A24: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821E3A28: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E3A2C: 4082FFE8  bne 0x821e3a14
	if !ctx.cr[0].eq {
	pc = 0x821E3A14; continue 'dispatch;
	}
	// 821E3A30: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 821E3A34: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821E3A38: 38840F10  addi r4, r4, 0xf10
	ctx.r[4].s64 = ctx.r[4].s64 + 3856;
	// 821E3A3C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E3A40: 48049491  bl 0x8222ced0
	ctx.lr = 0x821E3A44;
	sub_8222CED0(ctx, base);
	// 821E3A44: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3A48: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 821E3A4C: 3B210058  addi r25, r1, 0x58
	ctx.r[25].s64 = ctx.r[1].s64 + 88;
	// 821E3A50: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E3A54: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E3A58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E3A5C: 4E800421  bctrl
	ctx.lr = 0x821E3A60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E3A60: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821E3A64: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821E3A68: 48058F01  bl 0x8223c968
	ctx.lr = 0x821E3A6C;
	sub_8223C968(ctx, base);
	// 821E3A6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E3A70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E3A74: 48031365  bl 0x82214dd8
	ctx.lr = 0x821E3A78;
	sub_82214DD8(ctx, base);
	// 821E3A78: 57E9063E  clrlwi r9, r31, 0x18
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821E3A7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E3A80: 419A0064  beq cr6, 0x821e3ae4
	if ctx.cr[6].eq {
	pc = 0x821E3AE4; continue 'dispatch;
	}
	// 821E3A84: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 821E3A88: 4803B7D1  bl 0x8221f258
	ctx.lr = 0x821E3A8C;
	sub_8221F258(ctx, base);
	// 821E3A8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E3A90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821E3A94: 419A0030  beq cr6, 0x821e3ac4
	if ctx.cr[6].eq {
	pc = 0x821E3AC4; continue 'dispatch;
	}
	// 821E3A98: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3A9C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E3AA0: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E3AA4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E3AA8: 4E800421  bctrl
	ctx.lr = 0x821E3AAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E3AAC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821E3AB0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821E3AB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3AB8: 4849DF49  bl 0x82681a00
	ctx.lr = 0x821E3ABC;
	sub_82681A00(ctx, base);
	// 821E3ABC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3AC0: 48000008  b 0x821e3ac8
	pc = 0x821E3AC8; continue 'dispatch;
            }
            0x821E3AC4 => {
    //   block [0x821E3AC4..0x821E3AC8)
	// 821E3AC4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x821E3AC8; continue 'dispatch;
            }
            0x821E3AC8 => {
    //   block [0x821E3AC8..0x821E3AE4)
	// 821E3AC8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E3ACC: 4BFD7FE5  bl 0x821bbab0
	ctx.lr = 0x821E3AD0;
	sub_821BBAB0(ctx, base);
	// 821E3AD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3AD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E3AD8: 48088391  bl 0x8226be68
	ctx.lr = 0x821E3ADC;
	sub_8226BE68(ctx, base);
	// 821E3ADC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E3AE0: 4BFD4039  bl 0x821b7b18
	ctx.lr = 0x821E3AE4;
	sub_821B7B18(ctx, base);
	pc = 0x821E3AE4; continue 'dispatch;
            }
            0x821E3AE4 => {
    //   block [0x821E3AE4..0x821E3B78)
	// 821E3AE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E3AE8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821E3AEC: 388B12E0  addi r4, r11, 0x12e0
	ctx.r[4].s64 = ctx.r[11].s64 + 4832;
	// 821E3AF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E3AF4: 480493DD  bl 0x8222ced0
	ctx.lr = 0x821E3AF8;
	sub_8222CED0(ctx, base);
	// 821E3AF8: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3AFC: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 821E3B00: 3B210058  addi r25, r1, 0x58
	ctx.r[25].s64 = ctx.r[1].s64 + 88;
	// 821E3B04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E3B08: 812A0020  lwz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E3B0C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E3B10: 4E800421  bctrl
	ctx.lr = 0x821E3B14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E3B14: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821E3B18: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821E3B1C: 48058E4D  bl 0x8223c968
	ctx.lr = 0x821E3B20;
	sub_8223C968(ctx, base);
	// 821E3B20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E3B24: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E3B28: 480312B1  bl 0x82214dd8
	ctx.lr = 0x821E3B2C;
	sub_82214DD8(ctx, base);
	// 821E3B2C: 57E8063E  clrlwi r8, r31, 0x18
	ctx.r[8].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821E3B30: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E3B34: 419A0064  beq cr6, 0x821e3b98
	if ctx.cr[6].eq {
	pc = 0x821E3B98; continue 'dispatch;
	}
	// 821E3B38: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 821E3B3C: 4803B71D  bl 0x8221f258
	ctx.lr = 0x821E3B40;
	sub_8221F258(ctx, base);
	// 821E3B40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E3B44: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821E3B48: 419A0030  beq cr6, 0x821e3b78
	if ctx.cr[6].eq {
	pc = 0x821E3B78; continue 'dispatch;
	}
	// 821E3B4C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3B50: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E3B54: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E3B58: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E3B5C: 4E800421  bctrl
	ctx.lr = 0x821E3B60;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E3B60: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821E3B64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821E3B68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3B6C: 4849EC25  bl 0x82682790
	ctx.lr = 0x821E3B70;
	sub_82682790(ctx, base);
	// 821E3B70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3B74: 48000008  b 0x821e3b7c
	pc = 0x821E3B7C; continue 'dispatch;
            }
            0x821E3B78 => {
    //   block [0x821E3B78..0x821E3B7C)
	// 821E3B78: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x821E3B7C; continue 'dispatch;
            }
            0x821E3B7C => {
    //   block [0x821E3B7C..0x821E3B98)
	// 821E3B7C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821E3B80: 4BFD7F31  bl 0x821bbab0
	ctx.lr = 0x821E3B84;
	sub_821BBAB0(ctx, base);
	// 821E3B84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3B88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E3B8C: 480882DD  bl 0x8226be68
	ctx.lr = 0x821E3B90;
	sub_8226BE68(ctx, base);
	// 821E3B90: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821E3B94: 4BFD3F85  bl 0x821b7b18
	ctx.lr = 0x821E3B98;
	sub_821B7B18(ctx, base);
	pc = 0x821E3B98; continue 'dispatch;
            }
            0x821E3B98 => {
    //   block [0x821E3B98..0x821E3C2C)
	// 821E3B98: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E3B9C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821E3BA0: 388B11C8  addi r4, r11, 0x11c8
	ctx.r[4].s64 = ctx.r[11].s64 + 4552;
	// 821E3BA4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E3BA8: 48049329  bl 0x8222ced0
	ctx.lr = 0x821E3BAC;
	sub_8222CED0(ctx, base);
	// 821E3BAC: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3BB0: 3BE10050  addi r31, r1, 0x50
	ctx.r[31].s64 = ctx.r[1].s64 + 80;
	// 821E3BB4: 3B210058  addi r25, r1, 0x58
	ctx.r[25].s64 = ctx.r[1].s64 + 88;
	// 821E3BB8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E3BBC: 812A0020  lwz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E3BC0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E3BC4: 4E800421  bctrl
	ctx.lr = 0x821E3BC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E3BC8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821E3BCC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821E3BD0: 48058D99  bl 0x8223c968
	ctx.lr = 0x821E3BD4;
	sub_8223C968(ctx, base);
	// 821E3BD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E3BD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E3BDC: 480311FD  bl 0x82214dd8
	ctx.lr = 0x821E3BE0;
	sub_82214DD8(ctx, base);
	// 821E3BE0: 57E8063E  clrlwi r8, r31, 0x18
	ctx.r[8].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 821E3BE4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E3BE8: 419A0064  beq cr6, 0x821e3c4c
	if ctx.cr[6].eq {
	pc = 0x821E3C4C; continue 'dispatch;
	}
	// 821E3BEC: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 821E3BF0: 4803B669  bl 0x8221f258
	ctx.lr = 0x821E3BF4;
	sub_8221F258(ctx, base);
	// 821E3BF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E3BF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821E3BFC: 419A0030  beq cr6, 0x821e3c2c
	if ctx.cr[6].eq {
	pc = 0x821E3C2C; continue 'dispatch;
	}
	// 821E3C00: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3C04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E3C08: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E3C0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E3C10: 4E800421  bctrl
	ctx.lr = 0x821E3C14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E3C14: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821E3C18: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821E3C1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3C20: 4849F101  bl 0x82682d20
	ctx.lr = 0x821E3C24;
	sub_82682D20(ctx, base);
	// 821E3C24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3C28: 48000008  b 0x821e3c30
	pc = 0x821E3C30; continue 'dispatch;
            }
            0x821E3C2C => {
    //   block [0x821E3C2C..0x821E3C30)
	// 821E3C2C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x821E3C30; continue 'dispatch;
            }
            0x821E3C30 => {
    //   block [0x821E3C30..0x821E3C4C)
	// 821E3C30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821E3C34: 4BFD7E7D  bl 0x821bbab0
	ctx.lr = 0x821E3C38;
	sub_821BBAB0(ctx, base);
	// 821E3C38: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3C3C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E3C40: 48088229  bl 0x8226be68
	ctx.lr = 0x821E3C44;
	sub_8226BE68(ctx, base);
	// 821E3C44: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821E3C48: 4BFD3ED1  bl 0x821b7b18
	ctx.lr = 0x821E3C4C;
	sub_821B7B18(ctx, base);
	pc = 0x821E3C4C; continue 'dispatch;
            }
            0x821E3C4C => {
    //   block [0x821E3C4C..0x821E3C54)
	// 821E3C4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E3C50: 48031189  bl 0x82214dd8
	ctx.lr = 0x821E3C54;
	sub_82214DD8(ctx, base);
	pc = 0x821E3C54; continue 'dispatch;
            }
            0x821E3C54 => {
    //   block [0x821E3C54..0x821E3CF8)
	// 821E3C54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E3C58: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821E3C5C: 4BFD7E55  bl 0x821bbab0
	ctx.lr = 0x821E3C60;
	sub_821BBAB0(ctx, base);
	// 821E3C60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3C64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E3C68: 48088201  bl 0x8226be68
	ctx.lr = 0x821E3C6C;
	sub_8226BE68(ctx, base);
	// 821E3C6C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 821E3C70: 4BFD3EA9  bl 0x821b7b18
	ctx.lr = 0x821E3C74;
	sub_821B7B18(ctx, base);
	// 821E3C74: 897D0074  lbz r11, 0x74(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(116 as u32) ) } as u64;
	// 821E3C78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3C7C: 419A009C  beq cr6, 0x821e3d18
	if ctx.cr[6].eq {
	pc = 0x821E3D18; continue 'dispatch;
	}
	// 821E3C80: 38600060  li r3, 0x60
	ctx.r[3].s64 = 96;
	// 821E3C84: 4803B5D5  bl 0x8221f258
	ctx.lr = 0x821E3C88;
	sub_8221F258(ctx, base);
	// 821E3C88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E3C8C: 419A006C  beq cr6, 0x821e3cf8
	if ctx.cr[6].eq {
	pc = 0x821E3CF8; continue 'dispatch;
	}
	// 821E3C90: 897D0075  lbz r11, 0x75(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(117 as u32) ) } as u64;
	// 821E3C94: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821E3C98: D3E30008  stfs f31, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821E3C9C: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821E3CA0: 392A1DEC  addi r9, r10, 0x1dec
	ctx.r[9].s64 = ctx.r[10].s64 + 7660;
	// 821E3CA4: D3A30024  stfs f29, 0x24(r3)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821E3CA8: D3A30028  stfs f29, 0x28(r3)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821E3CAC: 9B43000C  stb r26, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[26].u8 ) };
	// 821E3CB0: D3E3002C  stfs f31, 0x2c(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821E3CB4: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821E3CB8: D3E30030  stfs f31, 0x30(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821E3CBC: 9B83000D  stb r28, 0xd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(13 as u32), ctx.r[28].u8 ) };
	// 821E3CC0: D3E30034  stfs f31, 0x34(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821E3CC4: 9B83000E  stb r28, 0xe(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(14 as u32), ctx.r[28].u8 ) };
	// 821E3CC8: D3E30038  stfs f31, 0x38(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821E3CCC: 9B830020  stb r28, 0x20(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[28].u8 ) };
	// 821E3CD0: D3E3003C  stfs f31, 0x3c(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821E3CD4: 9B830040  stb r28, 0x40(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[28].u8 ) };
	// 821E3CD8: 99630041  stb r11, 0x41(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(65 as u32), ctx.r[11].u8 ) };
	// 821E3CDC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3CE0: 9B830042  stb r28, 0x42(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(66 as u32), ctx.r[28].u8 ) };
	// 821E3CE4: 9B830043  stb r28, 0x43(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(67 as u32), ctx.r[28].u8 ) };
	// 821E3CE8: 93830048  stw r28, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[28].u32 ) };
	// 821E3CEC: 9383004C  stw r28, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[28].u32 ) };
	// 821E3CF0: 9B430054  stb r26, 0x54(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[26].u8 ) };
	// 821E3CF4: 48000008  b 0x821e3cfc
	pc = 0x821E3CFC; continue 'dispatch;
            }
            0x821E3CF8 => {
    //   block [0x821E3CF8..0x821E3CFC)
	// 821E3CF8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x821E3CFC; continue 'dispatch;
            }
            0x821E3CFC => {
    //   block [0x821E3CFC..0x821E3D18)
	// 821E3CFC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821E3D00: 4BFD7DB1  bl 0x821bbab0
	ctx.lr = 0x821E3D04;
	sub_821BBAB0(ctx, base);
	// 821E3D04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3D08: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E3D0C: 4808815D  bl 0x8226be68
	ctx.lr = 0x821E3D10;
	sub_8226BE68(ctx, base);
	// 821E3D10: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821E3D14: 4BFD3E05  bl 0x821b7b18
	ctx.lr = 0x821E3D18;
	sub_821B7B18(ctx, base);
	pc = 0x821E3D18; continue 'dispatch;
            }
            0x821E3D18 => {
    //   block [0x821E3D18..0x821E3D5C)
	// 821E3D18: C01D0070  lfs f0, 0x70(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E3D1C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821E3D20: 419A005C  beq cr6, 0x821e3d7c
	if ctx.cr[6].eq {
	pc = 0x821E3D7C; continue 'dispatch;
	}
	// 821E3D24: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 821E3D28: 4803B531  bl 0x8221f258
	ctx.lr = 0x821E3D2C;
	sub_8221F258(ctx, base);
	// 821E3D2C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E3D30: 419A002C  beq cr6, 0x821e3d5c
	if ctx.cr[6].eq {
	pc = 0x821E3D5C; continue 'dispatch;
	}
	// 821E3D34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821E3D38: C01D0070  lfs f0, 0x70(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E3D3C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821E3D40: 93A30004  stw r29, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821E3D44: 394BB714  addi r10, r11, -0x48ec
	ctx.r[10].s64 = ctx.r[11].s64 + -18668;
	// 821E3D48: D3E3000C  stfs f31, 0xc(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821E3D4C: D3C30010  stfs f30, 0x10(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821E3D50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3D54: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821E3D58: 48000008  b 0x821e3d60
	pc = 0x821E3D60; continue 'dispatch;
            }
            0x821E3D5C => {
    //   block [0x821E3D5C..0x821E3D60)
	// 821E3D5C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x821E3D60; continue 'dispatch;
            }
            0x821E3D60 => {
    //   block [0x821E3D60..0x821E3D7C)
	// 821E3D60: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 821E3D64: 4BFD7D4D  bl 0x821bbab0
	ctx.lr = 0x821E3D68;
	sub_821BBAB0(ctx, base);
	// 821E3D68: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E3D6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E3D70: 480880F9  bl 0x8226be68
	ctx.lr = 0x821E3D74;
	sub_8226BE68(ctx, base);
	// 821E3D74: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 821E3D78: 4BFD3DA1  bl 0x821b7b18
	ctx.lr = 0x821E3D7C;
	sub_821B7B18(ctx, base);
	pc = 0x821E3D7C; continue 'dispatch;
            }
            0x821E3D7C => {
    //   block [0x821E3D7C..0x821E3D8C)
	// 821E3D7C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 821E3D80: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 821E3D84: 48AC9FA1  bl 0x82cadd24
	ctx.lr = 0x821E3D88;
	sub_82CADCEC(ctx, base);
	// 821E3D88: 48AC56C4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E3D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E3D90 size=192
    let mut pc: u32 = 0x821E3D90;
    'dispatch: loop {
        match pc {
            0x821E3D90 => {
    //   block [0x821E3D90..0x821E3DB8)
	// 821E3D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E3D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E3D98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821E3D9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E3DA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E3DA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E3DA8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821E3DAC: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821E3DB0: 39097088  addi r8, r9, 0x7088
	ctx.r[8].s64 = ctx.r[9].s64 + 28808;
	// 821E3DB4: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x821E3DB8; continue 'dispatch;
            }
            0x821E3DB8 => {
    //   block [0x821E3DB8..0x821E3DEC)
	// 821E3DB8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821E3DBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E3DC0: 7D604028  lwarx r11, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821E3DC4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E3DC8: 7D60412D  stwcx. r11, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821E3DCC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E3DD0: 4082FFE8  bne 0x821e3db8
	if !ctx.cr[0].eq {
	pc = 0x821E3DB8; continue 'dispatch;
	}
	// 821E3DD4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3DD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3DDC: 409A0010  bne cr6, 0x821e3dec
	if !ctx.cr[6].eq {
	pc = 0x821E3DEC; continue 'dispatch;
	}
	// 821E3DE0: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821E3DE4: 396BFFDF  addi r11, r11, -0x21
	ctx.r[11].s64 = ctx.r[11].s64 + -33;
	// 821E3DE8: 48000008  b 0x821e3df0
	pc = 0x821E3DF0; continue 'dispatch;
            }
            0x821E3DEC => {
    //   block [0x821E3DEC..0x821E3DF0)
	// 821E3DEC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821E3DF0; continue 'dispatch;
            }
            0x821E3DF0 => {
    //   block [0x821E3DF0..0x821E3E14)
	// 821E3DF0: 7C8B2A15  add. r4, r11, r5
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821E3DF4: 41820020  beq 0x821e3e14
	if ctx.cr[0].eq {
	pc = 0x821E3E14; continue 'dispatch;
	}
	// 821E3DF8: 89640000  lbz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3DFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3E00: 419A0014  beq cr6, 0x821e3e14
	if ctx.cr[6].eq {
	pc = 0x821E3E14; continue 'dispatch;
	}
	// 821E3E04: 7CA53050  subf r5, r5, r6
	ctx.r[5].s64 = ctx.r[6].s64 - ctx.r[5].s64;
	// 821E3E08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3E0C: 48023A95  bl 0x822078a0
	ctx.lr = 0x821E3E10;
	sub_822078A0(ctx, base);
	// 821E3E10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	pc = 0x821E3E14; continue 'dispatch;
            }
            0x821E3E14 => {
    //   block [0x821E3E14..0x821E3E28)
	// 821E3E14: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3E18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3E1C: 419A000C  beq cr6, 0x821e3e28
	if ctx.cr[6].eq {
	pc = 0x821E3E28; continue 'dispatch;
	}
	// 821E3E20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3E24: 4BFE2945  bl 0x821c6768
	ctx.lr = 0x821E3E28;
	sub_821C6768(ctx, base);
	pc = 0x821E3E28; continue 'dispatch;
            }
            0x821E3E28 => {
    //   block [0x821E3E28..0x821E3E34)
	// 821E3E28: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E3E2C: 419A0008  beq cr6, 0x821e3e34
	if ctx.cr[6].eq {
	pc = 0x821E3E34; continue 'dispatch;
	}
	// 821E3E30: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x821E3E34; continue 'dispatch;
            }
            0x821E3E34 => {
    //   block [0x821E3E34..0x821E3E50)
	// 821E3E34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E3E38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E3E3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E3E40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E3E44: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E3E48: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E3E4C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E3E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E3E50 size=292
    let mut pc: u32 = 0x821E3E50;
    'dispatch: loop {
        match pc {
            0x821E3E50 => {
    //   block [0x821E3E50..0x821E3E80)
	// 821E3E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E3E54: 48AC55B1  bl 0x82ca9404
	ctx.lr = 0x821E3E58;
	sub_82CA93D0(ctx, base);
	// 821E3E58: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 821E3E5C: F8C10028  std r6, 0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(40 as u32), ctx.r[6].u64 ) };
	// 821E3E60: F8E10030  std r7, 0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(48 as u32), ctx.r[7].u64 ) };
	// 821E3E64: F9010038  std r8, 0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(56 as u32), ctx.r[8].u64 ) };
	// 821E3E68: F9210040  std r9, 0x40(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 821E3E6C: F9410048  std r10, 0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(72 as u32), ctx.r[10].u64 ) };
	// 821E3E70: 3BE1FF70  addi r31, r1, -0x90
	ctx.r[31].s64 = ctx.r[1].s64 + -144;
	// 821E3E74: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E3E78: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821E3E7C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	pc = 0x821E3E80; continue 'dispatch;
            }
            0x821E3E80 => {
    //   block [0x821E3E80..0x821E3F20)
	// 821E3E80: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3E84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E3E88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E3E8C: 409AFFF4  bne cr6, 0x821e3e80
	if !ctx.cr[6].eq {
	pc = 0x821E3E80; continue 'dispatch;
	}
	// 821E3E90: 7D645850  subf r11, r4, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 821E3E94: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E3E98: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E3E9C: 3BAB0400  addi r29, r11, 0x400
	ctx.r[29].s64 = ctx.r[11].s64 + 1024;
	// 821E3EA0: 7D5D00D0  neg r10, r29
	ctx.r[10].s64 = -ctx.r[29].s64;
	// 821E3EA4: 554C0036  rlwinm r12, r10, 0, 0, 0x1b
	ctx.r[12].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821E3EA8: 48ACC7AD  bl 0x82cb0654
	ctx.lr = 0x821E3EAC;
	sub_82CB0654(ctx, base);
	// 821E3EAC: 81210000  lwz r9, 0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3EB0: 391F0050  addi r8, r31, 0x50
	ctx.r[8].s64 = ctx.r[31].s64 + 80;
	// 821E3EB4: 38FF00B0  addi r7, r31, 0xb0
	ctx.r[7].s64 = ctx.r[31].s64 + 176;
	// 821E3EB8: 7D21616E  stwux r9, r1, r12
	ea = ctx.r[1].u32.wrapping_add(ctx.r[12].u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[9].u32) };
	ctx.r[1].u32 = ea;
	// 821E3EBC: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821E3EC0: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 821E3EC4: 80BF0050  lwz r5, 0x50(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E3EC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E3ECC: 4BFE2985  bl 0x821c6850
	ctx.lr = 0x821E3ED0;
	sub_821C6850(ctx, base);
	// 821E3ED0: 7F03E800  cmpw cr6, r3, r29
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[29].s32, &mut ctx.xer);
	// 821E3ED4: 41990094  bgt cr6, 0x821e3f68
	if ctx.cr[6].gt {
	pc = 0x821E3F68; continue 'dispatch;
	}
	// 821E3ED8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821E3EDC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E3EE0: 419A0068  beq cr6, 0x821e3f48
	if ctx.cr[6].eq {
	pc = 0x821E3F48; continue 'dispatch;
	}
	// 821E3EE4: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3EE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3EEC: 419A005C  beq cr6, 0x821e3f48
	if ctx.cr[6].eq {
	pc = 0x821E3F48; continue 'dispatch;
	}
	// 821E3EF0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 821E3EF4: 4803B365  bl 0x8221f258
	ctx.lr = 0x821E3EF8;
	sub_8221F258(ctx, base);
	// 821E3EF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821E3EFC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821E3F00: 419A0048  beq cr6, 0x821e3f48
	if ctx.cr[6].eq {
	pc = 0x821E3F48; continue 'dispatch;
	}
	// 821E3F04: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 821E3F08: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821E3F0C: 939D0004  stw r28, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 821E3F10: 939D0008  stw r28, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 821E3F14: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3F18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3F1C: 419A0014  beq cr6, 0x821e3f30
	if ctx.cr[6].eq {
	pc = 0x821E3F30; continue 'dispatch;
	}
	pc = 0x821E3F20; continue 'dispatch;
            }
            0x821E3F20 => {
    //   block [0x821E3F20..0x821E3F30)
	// 821E3F20: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821E3F24: 7D65F0AE  lbzx r11, r5, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 821E3F28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3F2C: 409AFFF4  bne cr6, 0x821e3f20
	if !ctx.cr[6].eq {
	pc = 0x821E3F20; continue 'dispatch;
	}
	pc = 0x821E3F30; continue 'dispatch;
            }
            0x821E3F30 => {
    //   block [0x821E3F30..0x821E3F48)
	// 821E3F30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E3F34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E3F38: 48024841  bl 0x82208778
	ctx.lr = 0x821E3F3C;
	sub_82208778(ctx, base);
	// 821E3F3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E3F40: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 821E3F44: 917D000C  stw r11, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x821E3F48; continue 'dispatch;
            }
            0x821E3F48 => {
    //   block [0x821E3F48..0x821E3F5C)
	// 821E3F48: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E3F4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3F50: 419A000C  beq cr6, 0x821e3f5c
	if ctx.cr[6].eq {
	pc = 0x821E3F5C; continue 'dispatch;
	}
	// 821E3F54: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E3F58: 4BFE2811  bl 0x821c6768
	ctx.lr = 0x821E3F5C;
	sub_821C6768(ctx, base);
	pc = 0x821E3F5C; continue 'dispatch;
            }
            0x821E3F5C => {
    //   block [0x821E3F5C..0x821E3F68)
	// 821E3F5C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821E3F60: 419A0008  beq cr6, 0x821e3f68
	if ctx.cr[6].eq {
	pc = 0x821E3F68; continue 'dispatch;
	}
	// 821E3F64: 939B0000  stw r28, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x821E3F68; continue 'dispatch;
            }
            0x821E3F68 => {
    //   block [0x821E3F68..0x821E3F74)
	// 821E3F68: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E3F6C: 383F0090  addi r1, r31, 0x90
	ctx.r[1].s64 = ctx.r[31].s64 + 144;
	// 821E3F70: 48AC54E4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E3F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E3F78 size=548
    let mut pc: u32 = 0x821E3F78;
    'dispatch: loop {
        match pc {
            0x821E3F78 => {
    //   block [0x821E3F78..0x821E3FCC)
	// 821E3F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E3F7C: 48AC5485  bl 0x82ca9400
	ctx.lr = 0x821E3F80;
	sub_82CA93D0(ctx, base);
	// 821E3F80: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E3F84: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821E3F88: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 821E3F8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E3F90: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 821E3F94: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821E3F98: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821E3F9C: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E3FA0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821E3FA4: 4800C29D  bl 0x821f0240
	ctx.lr = 0x821E3FA8;
	sub_821F0240(ctx, base);
	// 821E3FA8: 389D0008  addi r4, r29, 8
	ctx.r[4].s64 = ctx.r[29].s64 + 8;
	// 821E3FAC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E3FB0: 4800C291  bl 0x821f0240
	ctx.lr = 0x821E3FB4;
	sub_821F0240(ctx, base);
	// 821E3FB4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E3FB8: 3B40000C  li r26, 0xc
	ctx.r[26].s64 = 12;
	// 821E3FBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E3FC0: 409A000C  bne cr6, 0x821e3fcc
	if !ctx.cr[6].eq {
	pc = 0x821E3FCC; continue 'dispatch;
	}
	// 821E3FC4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821E3FC8: 48000010  b 0x821e3fd8
	pc = 0x821E3FD8; continue 'dispatch;
            }
            0x821E3FCC => {
    //   block [0x821E3FCC..0x821E3FD8)
	// 821E3FCC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E3FD0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E3FD4: 7D29D3D6  divw r9, r9, r26
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	pc = 0x821E3FD8; continue 'dispatch;
            }
            0x821E3FD8 => {
    //   block [0x821E3FD8..0x821E4008)
	// 821E3FD8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E3FDC: 419A01A8  beq cr6, 0x821e4184
	if ctx.cr[6].eq {
	pc = 0x821E4184; continue 'dispatch;
	}
	// 821E3FE0: 839F0008  lwz r28, 8(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E3FE4: 3D401555  lis r10, 0x1555
	ctx.r[10].s64 = 357892096;
	// 821E3FE8: 7D0BE050  subf r8, r11, r28
	ctx.r[8].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	// 821E3FEC: 614A5555  ori r10, r10, 0x5555
	ctx.r[10].u64 = ctx.r[10].u64 | 21845;
	// 821E3FF0: 7D68D3D6  divw r11, r8, r26
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[26].s32;
	// 821E3FF4: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E3FF8: 7F07F040  cmplw cr6, r7, r30
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821E3FFC: 4098000C  bge cr6, 0x821e4008
	if !ctx.cr[6].lt {
	pc = 0x821E4008; continue 'dispatch;
	}
	// 821E4000: 488634C9  bl 0x82a474c8
	ctx.lr = 0x821E4004;
	sub_82A474C8(ctx, base);
	// 821E4004: 48000180  b 0x821e4184
	pc = 0x821E4184; continue 'dispatch;
            }
            0x821E4008 => {
    //   block [0x821E4008..0x821E402C)
	// 821E4008: 7D0BF214  add r8, r11, r30
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821E400C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E4010: 409800D8  bge cr6, 0x821e40e8
	if !ctx.cr[6].lt {
	pc = 0x821E40E8; continue 'dispatch;
	}
	// 821E4014: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E4018: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821E401C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E4020: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821E4024: 41980008  blt cr6, 0x821e402c
	if ctx.cr[6].lt {
	pc = 0x821E402C; continue 'dispatch;
	}
	// 821E4028: 7F8B4A14  add r28, r11, r9
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x821E402C; continue 'dispatch;
            }
            0x821E402C => {
    //   block [0x821E402C..0x821E4038)
	// 821E402C: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E4030: 40980008  bge cr6, 0x821e4038
	if !ctx.cr[6].lt {
	pc = 0x821E4038; continue 'dispatch;
	}
	// 821E4034: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	pc = 0x821E4038; continue 'dispatch;
            }
            0x821E4038 => {
    //   block [0x821E4038..0x821E40B8)
	// 821E4038: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821E403C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E4040: 4813F371  bl 0x823233b0
	ctx.lr = 0x821E4044;
	sub_823233B0(ctx, base);
	// 821E4044: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E4048: 836100BC  lwz r27, 0xbc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821E404C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821E4050: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821E4054: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821E4058: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821E405C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821E4060: 48383BA9  bl 0x82567c08
	ctx.lr = 0x821E4064;
	sub_82567C08(ctx, base);
	// 821E4064: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E4068: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821E406C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821E4070: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E4074: 4880B825  bl 0x829ef898
	ctx.lr = 0x821E4078;
	sub_829EF898(ctx, base);
	// 821E4078: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821E407C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821E4080: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E4084: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E4088: 48383B81  bl 0x82567c08
	ctx.lr = 0x821E408C;
	sub_82567C08(ctx, base);
	// 821E408C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E4090: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E4094: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E4098: 7D432050  subf r10, r3, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 821E409C: 7D6AD3D6  divw r11, r10, r26
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	// 821E40A0: 7FCBF214  add r30, r11, r30
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821E40A4: 419A0014  beq cr6, 0x821e40b8
	if ctx.cr[6].eq {
	pc = 0x821E40B8; continue 'dispatch;
	}
	// 821E40A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 821E40AC: 48382965  bl 0x82566a10
	ctx.lr = 0x821E40B0;
	sub_82566A10(ctx, base);
	// 821E40B0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E40B4: 48037C85  bl 0x8221bd38
	ctx.lr = 0x821E40B8;
	sub_8221BD38(ctx, base);
	pc = 0x821E40B8; continue 'dispatch;
            }
            0x821E40B8 => {
    //   block [0x821E40B8..0x821E40E8)
	// 821E40B8: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E40BC: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821E40C0: 57CA083C  slwi r10, r30, 1
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E40C4: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 821E40C8: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 821E40CC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E40D0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E40D4: 7D2BEA14  add r9, r11, r29
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821E40D8: 7D0AEA14  add r8, r10, r29
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 821E40DC: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 821E40E0: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821E40E4: 480000A0  b 0x821e4184
	pc = 0x821E4184; continue 'dispatch;
            }
            0x821E40E8 => {
    //   block [0x821E40E8..0x821E414C)
	// 821E40E8: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 821E40EC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821E40F0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821E40F4: 7D7DE050  subf r11, r29, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 821E40F8: 7D4BD3D6  divw r10, r11, r26
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 821E40FC: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E4100: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821E4104: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821E4108: 40980044  bge cr6, 0x821e414c
	if !ctx.cr[6].lt {
	pc = 0x821E414C; continue 'dispatch;
	}
	// 821E410C: 557C103A  slwi r28, r11, 2
	ctx.r[28].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 821E4110: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E4114: 7CBCEA14  add r5, r28, r29
	ctx.r[5].u64 = ctx.r[28].u64 + ctx.r[29].u64;
	// 821E4118: 48383AF1  bl 0x82567c08
	ctx.lr = 0x821E411C;
	sub_82567C08(ctx, base);
	// 821E411C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E4120: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821E4124: 7D5D2050  subf r10, r29, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[29].s64;
	// 821E4128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E412C: 7D2AD3D6  divw r9, r10, r26
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	// 821E4130: 7CA9F050  subf r5, r9, r30
	ctx.r[5].s64 = ctx.r[30].s64 - ctx.r[9].s64;
	// 821E4134: 4880B765  bl 0x829ef898
	ctx.lr = 0x821E4138;
	sub_829EF898(ctx, base);
	// 821E4138: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E413C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821E4140: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821E4144: 7C9C5850  subf r4, r28, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 821E4148: 48000030  b 0x821e4178
	pc = 0x821E4178; continue 'dispatch;
            }
            0x821E414C => {
    //   block [0x821E414C..0x821E4178)
	// 821E414C: 557E103A  slwi r30, r11, 2
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821E4150: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821E4154: 7F7EE050  subf r27, r30, r28
	ctx.r[27].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	// 821E4158: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E415C: 48383AAD  bl 0x82567c08
	ctx.lr = 0x821E4160;
	sub_82567C08(ctx, base);
	// 821E4160: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 821E4164: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821E4168: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821E416C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E4170: 48382999  bl 0x82566b08
	ctx.lr = 0x821E4174;
	sub_82566B08(ctx, base);
	// 821E4174: 7C9EEA14  add r4, r30, r29
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	pc = 0x821E4178; continue 'dispatch;
            }
            0x821E4178 => {
    //   block [0x821E4178..0x821E4184)
	// 821E4178: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821E417C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E4180: 48382929  bl 0x82566aa8
	ctx.lr = 0x821E4184;
	sub_82566AA8(ctx, base);
	pc = 0x821E4184; continue 'dispatch;
            }
            0x821E4184 => {
    //   block [0x821E4184..0x821E419C)
	// 821E4184: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E4188: 48030C51  bl 0x82214dd8
	ctx.lr = 0x821E418C;
	sub_82214DD8(ctx, base);
	// 821E418C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821E4190: 48030C49  bl 0x82214dd8
	ctx.lr = 0x821E4194;
	sub_82214DD8(ctx, base);
	// 821E4194: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821E4198: 48AC52B8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E41A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E41A0 size=176
    let mut pc: u32 = 0x821E41A0;
    'dispatch: loop {
        match pc {
            0x821E41A0 => {
    //   block [0x821E41A0..0x821E4250)
	// 821E41A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E41A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E41A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E41AC: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E4250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E4250 size=92
    let mut pc: u32 = 0x821E4250;
    'dispatch: loop {
        match pc {
            0x821E4250 => {
    //   block [0x821E4250..0x821E4274)
	// 821E4250: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E4254: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E4258: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E425C: 3968FFFF  addi r11, r8, -1
	ctx.r[11].s64 = ctx.r[8].s64 + -1;
	// 821E4260: 7D6B2038  and r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[4].u64;
	// 821E4264: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E4268: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821E426C: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821E4270: 419A002C  beq cr6, 0x821e429c
	if ctx.cr[6].eq {
	pc = 0x821E429C; continue 'dispatch;
	}
	pc = 0x821E4274; continue 'dispatch;
            }
            0x821E4274 => {
    //   block [0x821E4274..0x821E428C)
	// 821E4274: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E4278: 419A0034  beq cr6, 0x821e42ac
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x821E42AC);
		return;
	}
	// 821E427C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E4280: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E4284: 409A0008  bne cr6, 0x821e428c
	if !ctx.cr[6].eq {
	pc = 0x821E428C; continue 'dispatch;
	}
	// 821E4288: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821E428C; continue 'dispatch;
            }
            0x821E428C => {
    //   block [0x821E428C..0x821E429C)
	// 821E428C: 556A1838  slwi r10, r11, 3
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E4290: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821E4294: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821E4298: 409AFFDC  bne cr6, 0x821e4274
	if !ctx.cr[6].eq {
	pc = 0x821E4274; continue 'dispatch;
	}
	pc = 0x821E429C; continue 'dispatch;
            }
            0x821E429C => {
    //   block [0x821E429C..0x821E42AC)
	// 821E429C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E42A0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821E42A4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E42A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E42B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E42B8 size=172
    let mut pc: u32 = 0x821E42B8;
    'dispatch: loop {
        match pc {
            0x821E42B8 => {
    //   block [0x821E42B8..0x821E4350)
	// 821E42B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E42BC: 48AC5151  bl 0x82ca940c
	ctx.lr = 0x821E42C0;
	sub_82CA93D0(ctx, base);
	// 821E42C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E42C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E42C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E42CC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821E42D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E42D4: 419A0084  beq cr6, 0x821e4358
	if ctx.cr[6].eq {
	pc = 0x821E4358; continue 'dispatch;
	}
	// 821E42D8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E42DC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 821E42E0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E42E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E42E8: 48044E21  bl 0x82229108
	ctx.lr = 0x821E42EC;
	sub_82229108(ctx, base);
	// 821E42EC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821E42F0: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 821E42F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E42F8: 48044091  bl 0x82228388
	ctx.lr = 0x821E42FC;
	sub_82228388(ctx, base);
	// 821E42FC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E4300: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821E4304: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 821E4308: 39099700  addi r8, r9, -0x6900
	ctx.r[8].s64 = ctx.r[9].s64 + -26880;
	// 821E430C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E4310: 419A0040  beq cr6, 0x821e4350
	if ctx.cr[6].eq {
	pc = 0x821E4350; continue 'dispatch;
	}
	// 821E4314: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E4318: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 821E431C: 409A0034  bne cr6, 0x821e4350
	if !ctx.cr[6].eq {
	pc = 0x821E4350; continue 'dispatch;
	}
	// 821E4320: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821E4324: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821E4328: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821E432C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E4330: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 821E4334: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E4338: 4811DB61  bl 0x82301e98
	ctx.lr = 0x821E433C;
	sub_82301E98(ctx, base);
	// 821E433C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E4340: 392BFFF0  addi r9, r11, -0x10
	ctx.r[9].s64 = ctx.r[11].s64 + -16;
	// 821E4344: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821E4348: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E434C: 48AC5110  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821E4350 => {
    //   block [0x821E4350..0x821E4358)
	// 821E4350: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 821E4354: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x821E4358; continue 'dispatch;
            }
            0x821E4358 => {
    //   block [0x821E4358..0x821E4364)
	// 821E4358: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E435C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E4360: 48AC50FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E4368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E4368 size=388
    let mut pc: u32 = 0x821E4368;
    'dispatch: loop {
        match pc {
            0x821E4368 => {
    //   block [0x821E4368..0x821E4398)
	// 821E4368: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E436C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E4370: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E4374: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E4378: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E437C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 821E4380: 419A0018  beq cr6, 0x821e4398
	if ctx.cr[6].eq {
	pc = 0x821E4398; continue 'dispatch;
	}
	// 821E4384: 89650090  lbz r11, 0x90(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(144 as u32) ) } as u64;
	// 821E4388: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E438C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E4390: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E4394: 409A0008  bne cr6, 0x821e439c
	if !ctx.cr[6].eq {
	pc = 0x821E439C; continue 'dispatch;
	}
	pc = 0x821E4398; continue 'dispatch;
            }
            0x821E4398 => {
    //   block [0x821E4398..0x821E439C)
	// 821E4398: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821E439C; continue 'dispatch;
            }
            0x821E439C => {
    //   block [0x821E439C..0x821E43E4)
	// 821E439C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E43A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E43A4: 419A0130  beq cr6, 0x821e44d4
	if ctx.cr[6].eq {
	pc = 0x821E44D4; continue 'dispatch;
	}
	// 821E43A8: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E43AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E43B0: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 821E43B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E43B8: 419A00EC  beq cr6, 0x821e44a4
	if ctx.cr[6].eq {
	pc = 0x821E44A4; continue 'dispatch;
	}
	// 821E43BC: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E43C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E43C4: 419A0020  beq cr6, 0x821e43e4
	if ctx.cr[6].eq {
	pc = 0x821E43E4; continue 'dispatch;
	}
	// 821E43C8: 894B0002  lbz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821E43CC: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E43D0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821E43D4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E43D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E43DC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E43E0: 480000C8  b 0x821e44a8
	pc = 0x821E44A8; continue 'dispatch;
            }
            0x821E43E4 => {
    //   block [0x821E43E4..0x821E4404)
	// 821E43E4: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E43E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E43EC: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E43F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821E43F4: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E43F8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E43FC: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E4400: 40810054  ble 0x821e4454
	if !ctx.cr[0].gt {
	pc = 0x821E4454; continue 'dispatch;
	}
	pc = 0x821E4404; continue 'dispatch;
            }
            0x821E4404 => {
    //   block [0x821E4404..0x821E4424)
	// 821E4404: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E4408: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E440C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E4410: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E4414: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 821E4418: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E441C: 41980008  blt cr6, 0x821e4424
	if ctx.cr[6].lt {
	pc = 0x821E4424; continue 'dispatch;
	}
	// 821E4420: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821E4424; continue 'dispatch;
            }
            0x821E4424 => {
    //   block [0x821E4424..0x821E4440)
	// 821E4424: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E4428: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E442C: 419A0014  beq cr6, 0x821e4440
	if ctx.cr[6].eq {
	pc = 0x821E4440; continue 'dispatch;
	}
	// 821E4430: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E4434: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E4438: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E443C: 4800000C  b 0x821e4448
	pc = 0x821E4448; continue 'dispatch;
            }
            0x821E4440 => {
    //   block [0x821E4440..0x821E4448)
	// 821E4440: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E4444: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821E4448; continue 'dispatch;
            }
            0x821E4448 => {
    //   block [0x821E4448..0x821E4454)
	// 821E4448: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E444C: 4199FFB8  bgt cr6, 0x821e4404
	if ctx.cr[6].gt {
	pc = 0x821E4404; continue 'dispatch;
	}
	// 821E4450: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821E4454; continue 'dispatch;
            }
            0x821E4454 => {
    //   block [0x821E4454..0x821E4470)
	// 821E4454: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E4458: 419A003C  beq cr6, 0x821e4494
	if ctx.cr[6].eq {
	pc = 0x821E4494; continue 'dispatch;
	}
	// 821E445C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E4460: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821E4464: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E4468: 41990008  bgt cr6, 0x821e4470
	if ctx.cr[6].gt {
	pc = 0x821E4470; continue 'dispatch;
	}
	// 821E446C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821E4470; continue 'dispatch;
            }
            0x821E4470 => {
    //   block [0x821E4470..0x821E4494)
	// 821E4470: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E4474: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E4478: 409A001C  bne cr6, 0x821e4494
	if !ctx.cr[6].eq {
	pc = 0x821E4494; continue 'dispatch;
	}
	// 821E447C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E4480: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E4484: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821E4488: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E448C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E4490: 48000018  b 0x821e44a8
	pc = 0x821E44A8; continue 'dispatch;
            }
            0x821E4494 => {
    //   block [0x821E4494..0x821E44A4)
	// 821E4494: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E4498: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E449C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E44A0: 48000008  b 0x821e44a8
	pc = 0x821E44A8; continue 'dispatch;
            }
            0x821E44A4 => {
    //   block [0x821E44A4..0x821E44A8)
	// 821E44A4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821E44A8; continue 'dispatch;
            }
            0x821E44A8 => {
    //   block [0x821E44A8..0x821E44D4)
	// 821E44A8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821E44AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E44B0: 419A0024  beq cr6, 0x821e44d4
	if ctx.cr[6].eq {
	pc = 0x821E44D4; continue 'dispatch;
	}
	// 821E44B4: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E44B8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821E44BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E44C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E44C4: 4E800421  bctrl
	ctx.lr = 0x821E44C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E44C8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
            }
            0x821E44D4 => {
    //   block [0x821E44D4..0x821E44EC)
	// 821E44D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E44D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E44DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E44E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E44E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E44E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E44F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E44F0 size=1940
    let mut pc: u32 = 0x821E44F0;
    'dispatch: loop {
        match pc {
            0x821E44F0 => {
    //   block [0x821E44F0..0x821E4C84)
	// 821E44F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E44F4: 48AC4EE9  bl 0x82ca93dc
	ctx.lr = 0x821E44F8;
	sub_82CA93D0(ctx, base);
	// 821E44F8: DBE1FF78  stfd f31, -0x88(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 821E44FC: 3980FF60  li r12, -0xa0
	ctx.r[12].s64 = -160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E4C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E4C88 size=1204
    let mut pc: u32 = 0x821E4C88;
    'dispatch: loop {
        match pc {
            0x821E4C88 => {
    //   block [0x821E4C88..0x821E513C)
	// 821E4C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E4C8C: 48AC4745  bl 0x82ca93d0
	ctx.lr = 0x821E4C90;
	sub_82CA93D0(ctx, base);
	// 821E4C90: 39600680  li r11, 0x680
	ctx.r[11].s64 = 1664;
	// 821E4C94: 9061FF00  stw r3, -0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-256 as u32), ctx.r[3].u32 ) };
	// 821E4C98: 3941FF40  addi r10, r1, -0xc0
	ctx.r[10].s64 = ctx.r[1].s64 + -192;
	// 821E4C9C: 39200670  li r9, 0x670
	ctx.r[9].s64 = 1648;
	// 821E4CA0: 3901FF40  addi r8, r1, -0xc0
	ctx.r[8].s64 = ctx.r[1].s64 + -192;
	// 821E4CA4: 38C1FF40  addi r6, r1, -0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + -192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E5140 size=336
    let mut pc: u32 = 0x821E5140;
    'dispatch: loop {
        match pc {
            0x821E5140 => {
    //   block [0x821E5140..0x821E5160)
	// 821E5140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E5144: 48AC42C1  bl 0x82ca9404
	ctx.lr = 0x821E5148;
	sub_82CA93D0(ctx, base);
	// 821E5148: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E514C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E5150: 3BA00005  li r29, 5
	ctx.r[29].s64 = 5;
	// 821E5154: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E5158: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E515C: 419A007C  beq cr6, 0x821e51d8
	if ctx.cr[6].eq {
	pc = 0x821E51D8; continue 'dispatch;
	}
	pc = 0x821E5160; continue 'dispatch;
            }
            0x821E5160 => {
    //   block [0x821E5160..0x821E5184)
	// 821E5160: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821E5164: 419A0074  beq cr6, 0x821e51d8
	if ctx.cr[6].eq {
	pc = 0x821E51D8; continue 'dispatch;
	}
	// 821E5168: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E516C: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 821E5170: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E5174: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E5178: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821E517C: 40990008  ble cr6, 0x821e5184
	if !ctx.cr[6].gt {
	pc = 0x821E5184; continue 'dispatch;
	}
	// 821E5180: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E5184; continue 'dispatch;
            }
            0x821E5184 => {
    //   block [0x821E5184..0x821E5198)
	// 821E5184: 556AF87E  srwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E5188: 556807FE  clrlwi r8, r11, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821E518C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821E5190: 41980008  blt cr6, 0x821e5198
	if ctx.cr[6].lt {
	pc = 0x821E5198; continue 'dispatch;
	}
	// 821E5194: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E5198; continue 'dispatch;
            }
            0x821E5198 => {
    //   block [0x821E5198..0x821E51A8)
	// 821E5198: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E519C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E51A0: 41990008  bgt cr6, 0x821e51a8
	if ctx.cr[6].gt {
	pc = 0x821E51A8; continue 'dispatch;
	}
	// 821E51A4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	pc = 0x821E51A8; continue 'dispatch;
            }
            0x821E51A8 => {
    //   block [0x821E51A8..0x821E51D8)
	// 821E51A8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E51AC: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E51B0: 550A1838  slwi r10, r8, 3
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E51B4: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821E51B8: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E51BC: 484991F5  bl 0x8267e3b0
	ctx.lr = 0x821E51C0;
	sub_8267E3B0(ctx, base);
	// 821E51C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E51C4: 48499425  bl 0x8267e5e8
	ctx.lr = 0x821E51C8;
	sub_8267E5E8(ctx, base);
	// 821E51C8: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E51CC: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 821E51D0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E51D4: 409AFF8C  bne cr6, 0x821e5160
	if !ctx.cr[6].eq {
	pc = 0x821E5160; continue 'dispatch;
	}
	pc = 0x821E51D8; continue 'dispatch;
            }
            0x821E51D8 => {
    //   block [0x821E51D8..0x821E5290)
	// 821E51D8: 3BFE0018  addi r31, r30, 0x18
	ctx.r[31].s64 = ctx.r[30].s64 + 24;
	// 821E51DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E51E0: 484991D1  bl 0x8267e3b0
	ctx.lr = 0x821E51E4;
	sub_8267E3B0(ctx, base);
	// 821E51E4: 3BBE0020  addi r29, r30, 0x20
	ctx.r[29].s64 = ctx.r[30].s64 + 32;
	// 821E51E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E51EC: 484991C5  bl 0x8267e3b0
	ctx.lr = 0x821E51F0;
	sub_8267E3B0(ctx, base);
	// 821E51F0: 3BDE0028  addi r30, r30, 0x28
	ctx.r[30].s64 = ctx.r[30].s64 + 40;
	// 821E51F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E51F8: 484991B9  bl 0x8267e3b0
	ctx.lr = 0x821E51FC;
	sub_8267E3B0(ctx, base);
	// 821E51FC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E5200: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821E5204: 3B6B0B7C  addi r27, r11, 0xb7c
	ctx.r[27].s64 = ctx.r[11].s64 + 2940;
	// 821E5208: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 821E520C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E5210: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821E5214: 4BFAEC25  bl 0x82193e38
	ctx.lr = 0x821E5218;
	sub_82193E38(ctx, base);
	// 821E5218: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E521C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E5220: 482ECCA9  bl 0x824d1ec8
	ctx.lr = 0x821E5224;
	sub_824D1EC8(ctx, base);
	// 821E5224: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821E5228: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E522C: 3BEA0B7C  addi r31, r10, 0xb7c
	ctx.r[31].s64 = ctx.r[10].s64 + 2940;
	// 821E5230: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821E5234: 4BFAEC05  bl 0x82193e38
	ctx.lr = 0x821E5238;
	sub_82193E38(ctx, base);
	// 821E5238: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821E523C: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 821E5240: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E5244: 4BFAEBF5  bl 0x82193e38
	ctx.lr = 0x821E5248;
	sub_82193E38(ctx, base);
	// 821E5248: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E524C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E5250: 482ECC79  bl 0x824d1ec8
	ctx.lr = 0x821E5254;
	sub_824D1EC8(ctx, base);
	// 821E5254: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821E5258: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E525C: 4BFAEBDD  bl 0x82193e38
	ctx.lr = 0x821E5260;
	sub_82193E38(ctx, base);
	// 821E5260: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 821E5264: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 821E5268: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E526C: 4BFAEBCD  bl 0x82193e38
	ctx.lr = 0x821E5270;
	sub_82193E38(ctx, base);
	// 821E5270: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E5274: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E5278: 482ECC51  bl 0x824d1ec8
	ctx.lr = 0x821E527C;
	sub_824D1EC8(ctx, base);
	// 821E527C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821E5280: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E5284: 4BFAEBB5  bl 0x82193e38
	ctx.lr = 0x821E5288;
	sub_82193E38(ctx, base);
	// 821E5288: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821E528C: 48AC41C8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E5290 size=104
    let mut pc: u32 = 0x821E5290;
    'dispatch: loop {
        match pc {
            0x821E5290 => {
    //   block [0x821E5290..0x821E52B0)
	// 821E5290: 39640030  addi r11, r4, 0x30
	ctx.r[11].s64 = ctx.r[4].s64 + 48;
	// 821E5294: 1D6B0018  mulli r11, r11, 0x18
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821E5298: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821E529C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E52A0: 55490529  rlwinm. r9, r10, 0, 0x14, 0x14
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821E52A4: 4082000C  bne 0x821e52b0
	if !ctx.cr[0].eq {
	pc = 0x821E52B0; continue 'dispatch;
	}
	// 821E52A8: 554A056B  rlwinm. r10, r10, 0, 0x15, 0x15
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E52AC: 41820040  beq 0x821e52ec
	if ctx.cr[0].eq {
	pc = 0x821E52EC; continue 'dispatch;
	}
	pc = 0x821E52B0; continue 'dispatch;
            }
            0x821E52B0 => {
    //   block [0x821E52B0..0x821E52EC)
	// 821E52B0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821E52B4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E52B8: 54A8103A  slwi r8, r5, 2
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E52BC: 394A5110  addi r10, r10, 0x5110
	ctx.r[10].s64 = ctx.r[10].s64 + 20752;
	// 821E52C0: 38E40020  addi r7, r4, 0x20
	ctx.r[7].s64 = ctx.r[4].s64 + 32;
	// 821E52C4: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821E52C8: 78E70020  clrldi r7, r7, 0x20
	ctx.r[7].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 821E52CC: 78C6FFE6  rldicr r6, r6, 0x3f, 0x3f
	ctx.r[6].u64 = (ctx.r[6].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821E52D0: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821E52D4: 7CC83C36  srd r8, r6, r7
	if (ctx.r[7].u8 & 0x40) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = (ctx.r[6].u64) >> ((ctx.r[7].u8 & 0x3F) as u32);
	}
	// 821E52D8: 5149C90C  rlwimi r9, r10, 0x19, 4, 6
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(25) as u64) & 0x000000000E000000) | (ctx.r[9].u64 & 0xFFFFFFFFF1FFFFFF);
	// 821E52DC: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 821E52E0: E9630018  ld r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	// 821E52E4: 7D0B5B78  or r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 | ctx.r[11].u64;
	// 821E52E8: F9630018  std r11, 0x18(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	pc = 0x821E52EC; continue 'dispatch;
            }
            0x821E52EC => {
    //   block [0x821E52EC..0x821E52F8)
	// 821E52EC: 7D632214  add r11, r3, r4
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[4].u64;
	// 821E52F0: 98AB2E94  stb r5, 0x2e94(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(11924 as u32), ctx.r[5].u8 ) };
	// 821E52F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E52F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E52F8 size=688
    let mut pc: u32 = 0x821E52F8;
    'dispatch: loop {
        match pc {
            0x821E52F8 => {
    //   block [0x821E52F8..0x821E5388)
	// 821E52F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E52FC: 48AC4109  bl 0x82ca9404
	ctx.lr = 0x821E5300;
	sub_82CA93D0(ctx, base);
	// 821E5300: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 821E5304: 48AC89C9  bl 0x82cadccc
	ctx.lr = 0x821E5308;
	sub_82CADCA0(ctx, base);
	// 821E5308: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E530C: F88100E0  std r4, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[4].u64 ) };
	// 821E5310: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E5314: F8A100E8  std r5, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[5].u64 ) };
	// 821E5318: C00100EC  lfs f0, 0xec(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E531C: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821E5320: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 821E5324: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E5328: 5528F87E  srwi r8, r9, 1
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E532C: 5507F87E  srwi r7, r8, 1
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821E5330: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 821E5334: 38CB0CF0  addi r6, r11, 0xcf0
	ctx.r[6].s64 = ctx.r[11].s64 + 3312;
	// 821E5338: 54E5FFBE  rlwinm r5, r7, 0x1f, 0x1e, 0x1f
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 821E533C: 552307FE  clrlwi r3, r9, 0x1f
	ctx.r[3].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 821E5340: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 821E5344: 54EB07FE  clrlwi r11, r7, 0x1f
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 821E5348: 39440CD0  addi r10, r4, 0xcd0
	ctx.r[10].s64 = ctx.r[4].s64 + 3280;
	// 821E534C: 7D2530AE  lbzx r9, r5, r6
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821E5350: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 821E5354: 38EA0001  addi r7, r10, 1
	ctx.r[7].s64 = ctx.r[10].s64 + 1;
	// 821E5358: 7D3E0774  extsb r30, r9
	ctx.r[30].s64 = ctx.r[9].s8 as i64;
	// 821E535C: 551B07FE  clrlwi r27, r8, 0x1f
	ctx.r[27].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 821E5360: 7CDE5A14  add r6, r30, r11
	ctx.r[6].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821E5364: 7CABF050  subf r5, r11, r30
	ctx.r[5].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 821E5368: 7C8650AE  lbzx r4, r6, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821E536C: 7C6538AE  lbzx r3, r5, r7
	ctx.r[3].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821E5370: 7C9D0774  extsb r29, r4
	ctx.r[29].s64 = ctx.r[4].s8 as i64;
	// 821E5374: 7C7C0774  extsb r28, r3
	ctx.r[28].s64 = ctx.r[3].s8 as i64;
	// 821E5378: 409A0010  bne cr6, 0x821e5388
	if !ctx.cr[6].eq {
	pc = 0x821E5388; continue 'dispatch;
	}
	// 821E537C: C1A100E0  lfs f13, 0xe0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E5380: C00100E8  lfs f0, 0xe8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E5384: 4800000C  b 0x821e5390
	pc = 0x821E5390; continue 'dispatch;
            }
            0x821E5388 => {
    //   block [0x821E5388..0x821E5390)
	// 821E5388: C1A100E8  lfs f13, 0xe8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E538C: C00100E0  lfs f0, 0xe0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821E5390; continue 'dispatch;
            }
            0x821E5390 => {
    //   block [0x821E5390..0x821E53A8)
	// 821E5390: C18100E4  lfs f12, 0xe4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821E5394: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821E5398: 409A0010  bne cr6, 0x821e53a8
	if !ctx.cr[6].eq {
	pc = 0x821E53A8; continue 'dispatch;
	}
	// 821E539C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821E53A0: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 821E53A4: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x821E53A8; continue 'dispatch;
            }
            0x821E53A8 => {
    //   block [0x821E53A8..0x821E54E8)
	// 821E53A8: FFC00090  fmr f30, f0
	ctx.f[30].f64 = ctx.f[0].f64;
	// 821E53AC: FF406090  fmr f26, f12
	ctx.f[26].f64 = ctx.f[12].f64;
	// 821E53B0: FF206890  fmr f25, f13
	ctx.f[25].f64 = ctx.f[13].f64;
	// 821E53B4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821E53B8: 48054AF9  bl 0x82239eb0
	ctx.lr = 0x821E53BC;
	sub_82239EB0(ctx, base);
	// 821E53BC: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 821E53C0: FC20D090  fmr f1, f26
	ctx.f[1].f64 = ctx.f[26].f64;
	// 821E53C4: 48054AED  bl 0x82239eb0
	ctx.lr = 0x821E53C8;
	sub_82239EB0(ctx, base);
	// 821E53C8: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E53CC: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 821E53D0: 48054AE1  bl 0x82239eb0
	ctx.lr = 0x821E53D4;
	sub_82239EB0(ctx, base);
	// 821E53D4: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 821E53D8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821E53DC: 48054BB5  bl 0x82239f90
	ctx.lr = 0x821E53E0;
	sub_82239F90(ctx, base);
	// 821E53E0: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	// 821E53E4: FC20D090  fmr f1, f26
	ctx.f[1].f64 = ctx.f[26].f64;
	// 821E53E8: 48054BA9  bl 0x82239f90
	ctx.lr = 0x821E53EC;
	sub_82239F90(ctx, base);
	// 821E53EC: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 821E53F0: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 821E53F4: 48054B9D  bl 0x82239f90
	ctx.lr = 0x821E53F8;
	sub_82239F90(ctx, base);
	// 821E53F8: 57C9103A  slwi r9, r30, 2
	ctx.r[9].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E53FC: FC1C0772  fmul f0, f28, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[28].f64 * ctx.f[29].f64;
	// 821E5400: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E5404: FDBB0732  fmul f13, f27, f28
	ctx.f[13].f64 = ctx.f[27].f64 * ctx.f[28].f64;
	// 821E5408: 7D1E4A14  add r8, r30, r9
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[9].u64;
	// 821E540C: FD810772  fmul f12, f1, f29
	ctx.f[12].f64 = ctx.f[1].f64 * ctx.f[29].f64;
	// 821E5410: 7CEBEA14  add r7, r11, r29
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821E5414: FD6106F2  fmul f11, f1, f27
	ctx.f[11].f64 = ctx.f[1].f64 * ctx.f[27].f64;
	// 821E5418: 57A9103A  slwi r9, r29, 2
	ctx.r[9].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E541C: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E5420: 5504103A  slwi r4, r8, 2
	ctx.r[4].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821E5424: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E5428: 7CFD4A14  add r7, r29, r9
	ctx.r[7].u64 = ctx.r[29].u64 + ctx.r[9].u64;
	// 821E542C: 7CCBE214  add r6, r11, r28
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 821E5430: 7CAAF214  add r5, r10, r30
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 821E5434: 7C6AE214  add r3, r10, r28
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 821E5438: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E543C: 2F1B0001  cmpwi cr6, r27, 1
	ctx.cr[6].compare_i32(ctx.r[27].s32, 1, &mut ctx.xer);
	// 821E5440: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E5444: 54C6103A  slwi r6, r6, 2
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821E5448: 54A5103A  slwi r5, r5, 2
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821E544C: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E5450: 5467103A  slwi r7, r3, 2
	ctx.r[7].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821E5454: 409A0094  bne cr6, 0x821e54e8
	if !ctx.cr[6].eq {
	pc = 0x821E54E8; continue 'dispatch;
	}
	// 821E5458: FD4C07F2  fmul f10, f12, f31
	ctx.f[10].f64 = ctx.f[12].f64 * ctx.f[31].f64;
	// 821E545C: FCC107B2  fmul f6, f1, f30
	ctx.f[6].f64 = ctx.f[1].f64 * ctx.f[30].f64;
	// 821E5460: FCFE0772  fmul f7, f30, f29
	ctx.f[7].f64 = ctx.f[30].f64 * ctx.f[29].f64;
	// 821E5464: FD3E0732  fmul f9, f30, f28
	ctx.f[9].f64 = ctx.f[30].f64 * ctx.f[28].f64;
	// 821E5468: FD1E06F2  fmul f8, f30, f27
	ctx.f[8].f64 = ctx.f[30].f64 * ctx.f[27].f64;
	// 821E546C: FCAB07FC  fnmsub f5, f11, f31, f0
	ctx.f[5].f64 = -(ctx.f[11].f64 * ctx.f[31].f64 - ctx.f[0].f64);
	// 821E5470: FC605FF8  fmsub f3, f0, f31, f11
	ctx.f[3].f64 = ctx.f[0].f64 * ctx.f[31].f64 - ctx.f[11].f64;
	// 821E5474: FC8D67FA  fmadd f4, f13, f31, f12
	ctx.f[4].f64 = ctx.f[13].f64 * ctx.f[31].f64 + ctx.f[12].f64;
	// 821E5478: FC40F818  frsp f2, f31
	ctx.f[2].f64 = (ctx.f[31].f64 as f32) as f64;
	// 821E547C: 7C44FD2E  stfsx f2, r4, r31
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E5480: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821E5484: FC205050  fneg f1, f10
	ctx.f[1].u64 = ctx.f[10].u64 ^ 0x8000_0000_0000_0000u64;
	// 821E5488: 5484103A  slwi r4, r4, 2
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821E548C: FD403018  frsp f10, f6
	ctx.f[10].f64 = (ctx.f[6].f64 as f32) as f64;
	// 821E5490: FD603818  frsp f11, f7
	ctx.f[11].f64 = (ctx.f[7].f64 as f32) as f64;
	// 821E5494: FC004850  fneg f0, f9
	ctx.f[0].u64 = ctx.f[9].u64 ^ 0x8000_0000_0000_0000u64;
	// 821E5498: FD804018  frsp f12, f8
	ctx.f[12].f64 = (ctx.f[8].f64 as f32) as f64;
	// 821E549C: 7D88FD2E  stfsx f12, r8, r31
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E54A0: 7D66FD2E  stfsx f11, r6, r31
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E54A4: 7D0BEA14  add r8, r11, r29
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821E54A8: 7CDC5214  add r6, r28, r10
	ctx.r[6].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 821E54AC: 7D45FD2E  stfsx f10, r5, r31
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E54B0: 5503103A  slwi r3, r8, 2
	ctx.r[3].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821E54B4: FD202818  frsp f9, f5
	ctx.f[9].f64 = (ctx.f[5].f64 as f32) as f64;
	// 821E54B8: 54CB103A  slwi r11, r6, 2
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E54BC: FD002018  frsp f8, f4
	ctx.f[8].f64 = (ctx.f[4].f64 as f32) as f64;
	// 821E54C0: 7D29FD2E  stfsx f9, r9, r31
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E54C4: FCA01818  frsp f5, f3
	ctx.f[5].f64 = (ctx.f[3].f64 as f32) as f64;
	// 821E54C8: FCE16828  fsub f7, f1, f13
	ctx.f[7].f64 = ctx.f[1].f64 - ctx.f[13].f64;
	// 821E54CC: FCC00018  frsp f6, f0
	ctx.f[6].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821E54D0: FC803818  frsp f4, f7
	ctx.f[4].f64 = (ctx.f[7].f64 as f32) as f64;
	// 821E54D4: 7C87FD2E  stfsx f4, r7, r31
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E54D8: 7CC4FD2E  stfsx f6, r4, r31
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E54DC: 7D03FD2E  stfsx f8, r3, r31
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E54E0: 7CABFD2E  stfsx f5, r11, r31
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E54E4: 48000088  b 0x821e556c
	pc = 0x821E556C; continue 'dispatch;
            }
            0x821E54E8 => {
    //   block [0x821E54E8..0x821E556C)
	// 821E54E8: FD5C07F2  fmul f10, f28, f31
	ctx.f[10].f64 = ctx.f[28].f64 * ctx.f[31].f64;
	// 821E54EC: FD2D67B8  fmsub f9, f13, f30, f12
	ctx.f[9].f64 = ctx.f[13].f64 * ctx.f[30].f64 - ctx.f[12].f64;
	// 821E54F0: FD005FBA  fmadd f8, f0, f30, f11
	ctx.f[8].f64 = ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[11].f64;
	// 821E54F4: FCE107F2  fmul f7, f1, f31
	ctx.f[7].f64 = ctx.f[1].f64 * ctx.f[31].f64;
	// 821E54F8: FCCB07BA  fmadd f6, f11, f30, f0
	ctx.f[6].f64 = ctx.f[11].f64 * ctx.f[30].f64 + ctx.f[0].f64;
	// 821E54FC: FCAC6FB8  fmsub f5, f12, f30, f13
	ctx.f[5].f64 = ctx.f[12].f64 * ctx.f[30].f64 - ctx.f[13].f64;
	// 821E5500: FC80F050  fneg f4, f30
	ctx.f[4].u64 = ctx.f[30].u64 ^ 0x8000_0000_0000_0000u64;
	// 821E5504: FC7B07F2  fmul f3, f27, f31
	ctx.f[3].f64 = ctx.f[27].f64 * ctx.f[31].f64;
	// 821E5508: FC5F0772  fmul f2, f31, f29
	ctx.f[2].f64 = ctx.f[31].f64 * ctx.f[29].f64;
	// 821E550C: FC205018  frsp f1, f10
	ctx.f[1].f64 = (ctx.f[10].f64 as f32) as f64;
	// 821E5510: 7C24FD2E  stfsx f1, r4, r31
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E5514: FC004818  frsp f0, f9
	ctx.f[0].f64 = (ctx.f[9].f64 as f32) as f64;
	// 821E5518: 7C08FD2E  stfsx f0, r8, r31
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E551C: FDA04018  frsp f13, f8
	ctx.f[13].f64 = (ctx.f[8].f64 as f32) as f64;
	// 821E5520: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 821E5524: 7DA6FD2E  stfsx f13, r6, r31
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E5528: FD803818  frsp f12, f7
	ctx.f[12].f64 = (ctx.f[7].f64 as f32) as f64;
	// 821E552C: 7D0BEA14  add r8, r11, r29
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 821E5530: 7D85FD2E  stfsx f12, r5, r31
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E5534: 7CDC5214  add r6, r28, r10
	ctx.r[6].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 821E5538: FD603018  frsp f11, f6
	ctx.f[11].f64 = (ctx.f[6].f64 as f32) as f64;
	// 821E553C: 5485103A  slwi r5, r4, 2
	ctx.r[5].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821E5540: 7D69FD2E  stfsx f11, r9, r31
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E5544: 5504103A  slwi r4, r8, 2
	ctx.r[4].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821E5548: FD402818  frsp f10, f5
	ctx.f[10].f64 = (ctx.f[5].f64 as f32) as f64;
	// 821E554C: 54C3103A  slwi r3, r6, 2
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821E5550: 7D47FD2E  stfsx f10, r7, r31
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E5554: FD202018  frsp f9, f4
	ctx.f[9].f64 = (ctx.f[4].f64 as f32) as f64;
	// 821E5558: FD001818  frsp f8, f3
	ctx.f[8].f64 = (ctx.f[3].f64 as f32) as f64;
	// 821E555C: 7D25FD2E  stfsx f9, r5, r31
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E5560: FCE01018  frsp f7, f2
	ctx.f[7].f64 = (ctx.f[2].f64 as f32) as f64;
	// 821E5564: 7D04FD2E  stfsx f8, r4, r31
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	// 821E5568: 7CE3FD2E  stfsx f7, r3, r31
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[31].u32), tmp.u32) };
	pc = 0x821E556C; continue 'dispatch;
            }
            0x821E556C => {
    //   block [0x821E556C..0x821E55A8)
	// 821E556C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E5570: 394B9490  addi r10, r11, -0x6b70
	ctx.r[10].s64 = ctx.r[11].s64 + -27504;
	// 821E5574: C00B9490  lfs f0, -0x6b70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E5578: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 821E557C: C00AFFF4  lfs f0, -0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E5580: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821E5584: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821E5588: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821E558C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 821E5590: D01F001C  stfs f0, 0x1c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 821E5594: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821E5598: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821E559C: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 821E55A0: 48AC8779  bl 0x82cadd18
	ctx.lr = 0x821E55A4;
	sub_82CADCEC(ctx, base);
	// 821E55A4: 48AC3EB0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E55A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E55A8 size=100
    let mut pc: u32 = 0x821E55A8;
    'dispatch: loop {
        match pc {
            0x821E55A8 => {
    //   block [0x821E55A8..0x821E55C8)
	// 821E55A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E55AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E55B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E55B4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821E55B8: 4883EB29  bl 0x82a240e0
	ctx.lr = 0x821E55BC;
	sub_82A240E0(ctx, base);
	// 821E55BC: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E55C0: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821E55C4: 40990024  ble cr6, 0x821e55e8
	if !ctx.cr[6].gt {
	pc = 0x821E55E8; continue 'dispatch;
	}
	pc = 0x821E55C8; continue 'dispatch;
            }
            0x821E55C8 => {
    //   block [0x821E55C8..0x821E55E8)
	// 821E55C8: 812BFFF8  lwz r9, -8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E55CC: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 821E55D0: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821E55D4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821E55D8: 810BFFFC  lwz r8, -4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821E55DC: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821E55E0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821E55E4: 4199FFE4  bgt cr6, 0x821e55c8
	if ctx.cr[6].gt {
	pc = 0x821E55C8; continue 'dispatch;
	}
	pc = 0x821E55E8; continue 'dispatch;
            }
            0x821E55E8 => {
    //   block [0x821E55E8..0x821E560C)
	// 821E55E8: 81650008  lwz r11, 8(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E55EC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E55F0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821E55F4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E55F8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821E55FC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E5600: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E5604: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E5608: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E5610 size=232
    let mut pc: u32 = 0x821E5610;
    'dispatch: loop {
        match pc {
            0x821E5610 => {
    //   block [0x821E5610..0x821E564C)
	// 821E5610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E5614: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E5618: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821E561C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E5620: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E5624: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E5628: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E562C: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 821E5630: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E5634: 419A0018  beq cr6, 0x821e564c
	if ctx.cr[6].eq {
	pc = 0x821E564C; continue 'dispatch;
	}
	// 821E5638: 93CB0550  stw r30, 0x550(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1360 as u32), ctx.r[30].u32 ) };
	// 821E563C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 821E5640: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 821E5644: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 821E5648: 48ACA3E9  bl 0x82cafa30
	ctx.lr = 0x821E564C;
	sub_82CAFA30(ctx, base);
	pc = 0x821E564C; continue 'dispatch;
            }
            0x821E564C => {
    //   block [0x821E564C..0x821E56D0)
	// 821E564C: 9BDF0006  stb r30, 6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[30].u8 ) };
	// 821E5650: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E5654: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E5658: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E565C: 419A0094  beq cr6, 0x821e56f0
	if ctx.cr[6].eq {
	pc = 0x821E56F0; continue 'dispatch;
	}
	// 821E5660: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821E5664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E5668: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 821E566C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5670: 909F000C  stw r4, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 821E5674: 48045DF5  bl 0x8222b468
	ctx.lr = 0x821E5678;
	sub_8222B468(ctx, base);
	// 821E5678: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E567C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E5680: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E5684: 4884E315  bl 0x82a33998
	ctx.lr = 0x821E5688;
	sub_82A33998(ctx, base);
	// 821E5688: A13F0036  lhz r9, 0x36(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(54 as u32) ) } as u64;
	// 821E568C: 811F0030  lwz r8, 0x30(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E5690: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E5694: 995F0039  stb r10, 0x39(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(57 as u32), ctx.r[10].u8 ) };
	// 821E5698: 2F084E20  cmpwi cr6, r8, 0x4e20
	ctx.cr[6].compare_i32(ctx.r[8].s32, 20000, &mut ctx.xer);
	// 821E569C: B13F0034  sth r9, 0x34(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[9].u16 ) };
	// 821E56A0: 40990030  ble cr6, 0x821e56d0
	if !ctx.cr[6].gt {
	pc = 0x821E56D0; continue 'dispatch;
	}
	// 821E56A4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E56A8: 39400018  li r10, 0x18
	ctx.r[10].s64 = 24;
	// 821E56AC: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821E56B0: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E56B4: 7D6853D6  divw r11, r8, r10
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	// 821E56B8: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 821E56BC: 2F074E20  cmpwi cr6, r7, 0x4e20
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20000, &mut ctx.xer);
	// 821E56C0: 40980010  bge cr6, 0x821e56d0
	if !ctx.cr[6].lt {
	pc = 0x821E56D0; continue 'dispatch;
	}
	// 821E56C4: 38804E20  li r4, 0x4e20
	ctx.r[4].s64 = 20000;
	// 821E56C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E56CC: 4884E50D  bl 0x82a33bd8
	ctx.lr = 0x821E56D0;
	sub_82A33BD8(ctx, base);
	pc = 0x821E56D0; continue 'dispatch;
            }
            0x821E56D0 => {
    //   block [0x821E56D0..0x821E56F0)
	// 821E56D0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E56D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E56D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E56DC: 917F0064  stw r11, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821E56E0: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821E56E4: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E56E8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E56EC: 4E800421  bctrl
	ctx.lr = 0x821E56F0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821E56F0 => {
    //   block [0x821E56F0..0x821E56F8)
	// 821E56F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821E56F4: 48ACA875  bl 0x82caff68
	ctx.lr = 0x821E56F8;
	sub_82CAFF68(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E56F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E56F8 size=56
    let mut pc: u32 = 0x821E56F8;
    'dispatch: loop {
        match pc {
            0x821E56F8 => {
    //   block [0x821E56F8..0x821E570C)
	// 821E56F8: 816330A8  lwz r11, 0x30a8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12456 as u32) ) } as u64;
	// 821E56FC: 90832E68  stw r4, 0x2e68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(11880 as u32), ctx.r[4].u32 ) };
	// 821E5700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E5704: 409A0008  bne cr6, 0x821e570c
	if !ctx.cr[6].eq {
	pc = 0x821E570C; continue 'dispatch;
	}
	// 821E5708: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x821E570C; continue 'dispatch;
            }
            0x821E570C => {
    //   block [0x821E570C..0x821E5730)
	// 821E570C: 81632934  lwz r11, 0x2934(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(10548 as u32) ) } as u64;
	// 821E5710: 508B07FE  rlwimi r11, r4, 0, 0x1f, 0x1f
	ctx.r[11].u64 = (((ctx.r[4].u32).rotate_left(0) as u64) & 0x0000000000000001) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFFFE);
	// 821E5714: 91632934  stw r11, 0x2934(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(10548 as u32), ctx.r[11].u32 ) };
	// 821E5718: E9630010  ld r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	// 821E571C: 616B0800  ori r11, r11, 0x800
	ctx.r[11].u64 = ctx.r[11].u64 | 2048;
	// 821E5720: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821E5724: 656B0002  oris r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 131072;
	// 821E5728: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821E572C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E5730 size=224
    let mut pc: u32 = 0x821E5730;
    'dispatch: loop {
        match pc {
            0x821E5730 => {
    //   block [0x821E5730..0x821E5810)
	// 821E5730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E5734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E5738: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821E573C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E5740: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5810(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E5810 size=104
    let mut pc: u32 = 0x821E5810;
    'dispatch: loop {
        match pc {
            0x821E5810 => {
    //   block [0x821E5810..0x821E5878)
	// 821E5810: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E5814: 48AC3BF9  bl 0x82ca940c
	ctx.lr = 0x821E5818;
	sub_82CA93D0(ctx, base);
	// 821E5818: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E581C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E5820: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821E5824: 392B0F94  addi r9, r11, 0xf94
	ctx.r[9].s64 = ctx.r[11].s64 + 3988;
	// 821E5828: 99410054  stb r10, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u8 ) };
	// 821E582C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E5830: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821E5834: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E5838: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E583C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821E5840: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E5844: 4801D515  bl 0x82202d58
	ctx.lr = 0x821E5848;
	sub_82202D58(ctx, base);
	// 821E5848: 3D00820F  lis r8, -0x7df1
	ctx.r[8].s64 = -2112946176;
	// 821E584C: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E5850: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E5854: 38E82B90  addi r7, r8, 0x2b90
	ctx.r[7].s64 = ctx.r[8].s64 + 11152;
	// 821E5858: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821E585C: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 821E5860: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5864: 81660018  lwz r11, 0x18(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 821E5868: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821E586C: 4E800421  bctrl
	ctx.lr = 0x821E5870;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E5870: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E5874: 48AC3BE8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E5878 size=92
    let mut pc: u32 = 0x821E5878;
    'dispatch: loop {
        match pc {
            0x821E5878 => {
    //   block [0x821E5878..0x821E58BC)
	// 821E5878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E587C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E5880: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E5884: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E5888: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821E588C: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821E5890: 4881AE39  bl 0x82a006c8
	ctx.lr = 0x821E5894;
	sub_82A006C8(ctx, base);
	// 821E5894: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E5898: 419A0024  beq cr6, 0x821e58bc
	if ctx.cr[6].eq {
	pc = 0x821E58BC; continue 'dispatch;
	}
	// 821E589C: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E58A0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821E58A4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E58A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E58AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E58B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E58B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E58B8: 4E800020  blr
	return;
            }
            0x821E58BC => {
    //   block [0x821E58BC..0x821E58D4)
	// 821E58BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E58C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E58C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E58C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E58CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E58D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E58D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E58D8 size=152
    let mut pc: u32 = 0x821E58D8;
    'dispatch: loop {
        match pc {
            0x821E58D8 => {
    //   block [0x821E58D8..0x821E5964)
	// 821E58D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E58DC: 48AC3B31  bl 0x82ca940c
	ctx.lr = 0x821E58E0;
	sub_82CA93D0(ctx, base);
	// 821E58E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E58E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E58E8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E58EC: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 821E58F0: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 821E58F4: 386B0E48  addi r3, r11, 0xe48
	ctx.r[3].s64 = ctx.r[11].s64 + 3656;
	// 821E58F8: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 821E58FC: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5900: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821E5904: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 821E5908: 4800E451  bl 0x821f3d58
	ctx.lr = 0x821E590C;
	sub_821F3D58(ctx, base);
	// 821E590C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E5910: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E5914: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821E5918: 48000059  bl 0x821e5970
	ctx.lr = 0x821E591C;
	sub_821E5970(ctx, base);
	// 821E591C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E5920: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E5924: 419A0040  beq cr6, 0x821e5964
	if ctx.cr[6].eq {
	pc = 0x821E5964; continue 'dispatch;
	}
	// 821E5928: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E592C: 556A002E  rlwinm r10, r11, 0, 0, 0x17
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E5930: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E5934: 419A0030  beq cr6, 0x821e5964
	if ctx.cr[6].eq {
	pc = 0x821E5964; continue 'dispatch;
	}
	// 821E5938: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 821E593C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E5940: 419A0024  beq cr6, 0x821e5964
	if ctx.cr[6].eq {
	pc = 0x821E5964; continue 'dispatch;
	}
	// 821E5944: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E5948: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821E594C: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E5950: 806A6DA0  lwz r3, 0x6da0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28064 as u32) ) } as u64;
	// 821E5954: 7C88582E  lwzx r4, r8, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821E5958: 4BFFE8F9  bl 0x821e4250
	ctx.lr = 0x821E595C;
	sub_821E4250(ctx, base);
	// 821E595C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E5960: 48AC3AFC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821E5964 => {
    //   block [0x821E5964..0x821E5970)
	// 821E5964: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E5968: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E596C: 48AC3AF0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E5970 size=88
    let mut pc: u32 = 0x821E5970;
    'dispatch: loop {
        match pc {
            0x821E5970 => {
    //   block [0x821E5970..0x821E5980)
	// 821E5970: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5974: 38E30004  addi r7, r3, 4
	ctx.r[7].s64 = ctx.r[3].s64 + 4;
	// 821E5978: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821E597C: 5569C23E  srwi r9, r11, 8
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shr(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	pc = 0x821E5980; continue 'dispatch;
            }
            0x821E5980 => {
    //   block [0x821E5980..0x821E59AC)
	// 821E5980: 7D694214  add r11, r9, r8
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821E5984: 556BF87E  srwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E5988: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E598C: 7D4A382E  lwzx r10, r10, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821E5990: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821E5994: 419A0034  beq cr6, 0x821e59c8
	if ctx.cr[6].eq {
		sub_821E59C8(ctx, base);
		return;
	}
	// 821E5998: 40980014  bge cr6, 0x821e59ac
	if !ctx.cr[6].lt {
	pc = 0x821E59AC; continue 'dispatch;
	}
	// 821E599C: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E59A0: 419A0020  beq cr6, 0x821e59c0
	if ctx.cr[6].eq {
	pc = 0x821E59C0; continue 'dispatch;
	}
	// 821E59A4: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 821E59A8: 48000010  b 0x821e59b8
	pc = 0x821E59B8; continue 'dispatch;
            }
            0x821E59AC => {
    //   block [0x821E59AC..0x821E59B8)
	// 821E59AC: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E59B0: 419A0010  beq cr6, 0x821e59c0
	if ctx.cr[6].eq {
	pc = 0x821E59C0; continue 'dispatch;
	}
	// 821E59B4: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	pc = 0x821E59B8; continue 'dispatch;
            }
            0x821E59B8 => {
    //   block [0x821E59B8..0x821E59C0)
	// 821E59B8: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821E59BC: 4099FFC4  ble cr6, 0x821e5980
	if !ctx.cr[6].gt {
	pc = 0x821E5980; continue 'dispatch;
	}
	pc = 0x821E59C0; continue 'dispatch;
            }
            0x821E59C0 => {
    //   block [0x821E59C0..0x821E59C8)
	// 821E59C0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E59C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E59C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E59C8 size=64
    let mut pc: u32 = 0x821E59C8;
    'dispatch: loop {
        match pc {
            0x821E59C8 => {
    //   block [0x821E59C8..0x821E59D4)
	// 821E59C8: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821E59CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E59D0: 419A0030  beq cr6, 0x821e5a00
	if ctx.cr[6].eq {
	pc = 0x821E5A00; continue 'dispatch;
	}
	pc = 0x821E59D4; continue 'dispatch;
            }
            0x821E59D4 => {
    //   block [0x821E59D4..0x821E5A00)
	// 821E59D4: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E59D8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E59DC: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821E59E0: 812AFFFC  lwz r9, -4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821E59E4: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821E59E8: 409A0018  bne cr6, 0x821e5a00
	if !ctx.cr[6].eq {
	pc = 0x821E5A00; continue 'dispatch;
	}
	// 821E59EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E59F0: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E59F4: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821E59F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E59FC: 4199FFD8  bgt cr6, 0x821e59d4
	if ctx.cr[6].gt {
	pc = 0x821E59D4; continue 'dispatch;
	}
	pc = 0x821E5A00; continue 'dispatch;
            }
            0x821E5A00 => {
    //   block [0x821E5A00..0x821E5A08)
	// 821E5A00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821E5A04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E5A08 size=184
    let mut pc: u32 = 0x821E5A08;
    'dispatch: loop {
        match pc {
            0x821E5A08 => {
    //   block [0x821E5A08..0x821E5A2C)
	// 821E5A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E5A0C: 48AC39FD  bl 0x82ca9408
	ctx.lr = 0x821E5A10;
	sub_82CA93D0(ctx, base);
	// 821E5A10: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E5A14: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821E5A18: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821E5A1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E5A20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E5A24: 419A0040  beq cr6, 0x821e5a64
	if ctx.cr[6].eq {
	pc = 0x821E5A64; continue 'dispatch;
	}
	// 821E5A28: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	pc = 0x821E5A2C; continue 'dispatch;
            }
            0x821E5A2C => {
    //   block [0x821E5A2C..0x821E5A64)
	// 821E5A2C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821E5A30: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821E5A34: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5A38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821E5A3C: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 821E5A40: 4BFFFF31  bl 0x821e5970
	ctx.lr = 0x821E5A44;
	sub_821E5970(ctx, base);
	// 821E5A44: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E5A48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E5A4C: 409A0024  bne cr6, 0x821e5a70
	if !ctx.cr[6].eq {
	pc = 0x821E5A70; continue 'dispatch;
	}
	// 821E5A50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E5A54: 4BFFFE85  bl 0x821e58d8
	ctx.lr = 0x821E5A58;
	sub_821E58D8(ctx, base);
	// 821E5A58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E5A5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821E5A60: 409AFFCC  bne cr6, 0x821e5a2c
	if !ctx.cr[6].eq {
	pc = 0x821E5A2C; continue 'dispatch;
	}
	pc = 0x821E5A64; continue 'dispatch;
            }
            0x821E5A64 => {
    //   block [0x821E5A64..0x821E5A70)
	// 821E5A64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E5A68: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E5A6C: 48AC39EC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x821E5A70 => {
    //   block [0x821E5A70..0x821E5AB0)
	// 821E5A70: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5A74: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E5A78: 556BC23E  srwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E5A7C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5A80: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E5A84: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 821E5A88: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5A8C: 5505103A  slwi r5, r8, 2
	ctx.r[5].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821E5A90: 54E4002E  rlwinm r4, r7, 0, 0, 0x17
	ctx.r[4].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 821E5A94: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821E5A98: 7C6530AE  lbzx r3, r5, r6
	ctx.r[3].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821E5A9C: 7C6B0774  extsb r11, r3
	ctx.r[11].s64 = ctx.r[3].s8 as i64;
	// 821E5AA0: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821E5AA4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 821E5AA8: 409A0008  bne cr6, 0x821e5ab0
	if !ctx.cr[6].eq {
	pc = 0x821E5AB0; continue 'dispatch;
	}
	// 821E5AAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821E5AB0; continue 'dispatch;
            }
            0x821E5AB0 => {
    //   block [0x821E5AB0..0x821E5AC0)
	// 821E5AB0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E5AB4: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E5AB8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E5ABC: 48AC399C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E5AC0 size=104
    let mut pc: u32 = 0x821E5AC0;
    'dispatch: loop {
        match pc {
            0x821E5AC0 => {
    //   block [0x821E5AC0..0x821E5B14)
	// 821E5AC0: 39650006  addi r11, r5, 6
	ctx.r[11].s64 = ctx.r[5].s64 + 6;
	// 821E5AC4: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E5AC8: 7D6A202E  lwzx r11, r10, r4
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 821E5ACC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E5AD0: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 821E5AD4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821E5AD8: 39430010  addi r10, r3, 0x10
	ctx.r[10].s64 = ctx.r[3].s64 + 16;
	// 821E5ADC: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 821E5AE0: 38C00020  li r6, 0x20
	ctx.r[6].s64 = 32;
	// 821E5AE4: 8164002C  lwz r11, 0x2c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E5AE8: 7D6B402E  lwzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 821E5AEC: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821E5AF0: 419A0024  beq cr6, 0x821e5b14
	if ctx.cr[6].eq {
	pc = 0x821E5B14; continue 'dispatch;
	}
	// 821E5AF4: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	pc = 0x821E5B14; continue 'dispatch;
            }
            0x821E5B14 => {
    //   block [0x821E5B14..0x821E5B28)
	// 821E5B14: 34E7FFFF  addic. r7, r7, -1
	ctx.xer.ca = (ctx.r[7].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821E5B18: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 821E5B1C: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 821E5B20: 4082FFC4  bne 0x821e5ae4
	if !ctx.cr[0].eq {
	pc = 0x821E5AE4; continue 'dispatch;
	}
	// 821E5B24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E5B28 size=396
    let mut pc: u32 = 0x821E5B28;
    'dispatch: loop {
        match pc {
            0x821E5B28 => {
    //   block [0x821E5B28..0x821E5B7C)
	// 821E5B28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E5B2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E5B30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E5B34: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E5B38: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E5B3C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821E5B40: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E5B44: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 821E5B48: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E5B4C: 419A00F4  beq cr6, 0x821e5c40
	if ctx.cr[6].eq {
	pc = 0x821E5C40; continue 'dispatch;
	}
	// 821E5B50: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E5B54: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E5B58: 419A0024  beq cr6, 0x821e5b7c
	if ctx.cr[6].eq {
	pc = 0x821E5B7C; continue 'dispatch;
	}
	// 821E5B5C: 894A0015  lbz r10, 0x15(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 821E5B60: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E5B64: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821E5B68: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E5B6C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E5B70: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821E5B74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E5B78: 480000CC  b 0x821e5c44
	pc = 0x821E5C44; continue 'dispatch;
            }
            0x821E5B7C => {
    //   block [0x821E5B7C..0x821E5B98)
	// 821E5B7C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E5B80: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E5B84: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 821E5B88: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E5B8C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E5B90: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E5B94: 40810054  ble 0x821e5be8
	if !ctx.cr[0].gt {
	pc = 0x821E5BE8; continue 'dispatch;
	}
	pc = 0x821E5B98; continue 'dispatch;
            }
            0x821E5B98 => {
    //   block [0x821E5B98..0x821E5BB8)
	// 821E5B98: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E5B9C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E5BA0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E5BA4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5BA8: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 821E5BAC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E5BB0: 41980008  blt cr6, 0x821e5bb8
	if ctx.cr[6].lt {
	pc = 0x821E5BB8; continue 'dispatch;
	}
	// 821E5BB4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x821E5BB8; continue 'dispatch;
            }
            0x821E5BB8 => {
    //   block [0x821E5BB8..0x821E5BD4)
	// 821E5BB8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E5BBC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E5BC0: 419A0014  beq cr6, 0x821e5bd4
	if ctx.cr[6].eq {
	pc = 0x821E5BD4; continue 'dispatch;
	}
	// 821E5BC4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E5BC8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E5BCC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E5BD0: 4800000C  b 0x821e5bdc
	pc = 0x821E5BDC; continue 'dispatch;
            }
            0x821E5BD4 => {
    //   block [0x821E5BD4..0x821E5BDC)
	// 821E5BD4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E5BD8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821E5BDC; continue 'dispatch;
            }
            0x821E5BDC => {
    //   block [0x821E5BDC..0x821E5BE8)
	// 821E5BDC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E5BE0: 4199FFB8  bgt cr6, 0x821e5b98
	if ctx.cr[6].gt {
	pc = 0x821E5B98; continue 'dispatch;
	}
	// 821E5BE4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821E5BE8; continue 'dispatch;
            }
            0x821E5BE8 => {
    //   block [0x821E5BE8..0x821E5C04)
	// 821E5BE8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E5BEC: 419A0040  beq cr6, 0x821e5c2c
	if ctx.cr[6].eq {
	pc = 0x821E5C2C; continue 'dispatch;
	}
	// 821E5BF0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E5BF4: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 821E5BF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E5BFC: 41990008  bgt cr6, 0x821e5c04
	if ctx.cr[6].gt {
	pc = 0x821E5C04; continue 'dispatch;
	}
	// 821E5C00: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x821E5C04; continue 'dispatch;
            }
            0x821E5C04 => {
    //   block [0x821E5C04..0x821E5C2C)
	// 821E5C04: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E5C08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E5C0C: 409A0020  bne cr6, 0x821e5c2c
	if !ctx.cr[6].eq {
	pc = 0x821E5C2C; continue 'dispatch;
	}
	// 821E5C10: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E5C14: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821E5C18: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E5C1C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E5C20: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821E5C24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E5C28: 4800001C  b 0x821e5c44
	pc = 0x821E5C44; continue 'dispatch;
            }
            0x821E5C2C => {
    //   block [0x821E5C2C..0x821E5C40)
	// 821E5C2C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E5C30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E5C34: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821E5C38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E5C3C: 48000008  b 0x821e5c44
	pc = 0x821E5C44; continue 'dispatch;
            }
            0x821E5C40 => {
    //   block [0x821E5C40..0x821E5C44)
	// 821E5C40: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x821E5C44; continue 'dispatch;
            }
            0x821E5C44 => {
    //   block [0x821E5C44..0x821E5C80)
	// 821E5C44: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E5C48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E5C4C: 419A0050  beq cr6, 0x821e5c9c
	if ctx.cr[6].eq {
	pc = 0x821E5C9C; continue 'dispatch;
	}
	// 821E5C50: 3880002C  li r4, 0x2c
	ctx.r[4].s64 = 44;
	// 821E5C54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E5C58: 48019971  bl 0x821ff5c8
	ctx.lr = 0x821E5C5C;
	sub_821FF5C8(ctx, base);
	// 821E5C5C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E5C60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E5C64: 419A001C  beq cr6, 0x821e5c80
	if ctx.cr[6].eq {
	pc = 0x821E5C80; continue 'dispatch;
	}
	// 821E5C68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E5C6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E5C70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E5C74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E5C78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E5C7C: 4E800020  blr
	return;
            }
            0x821E5C80 => {
    //   block [0x821E5C80..0x821E5C9C)
	// 821E5C80: 3880001D  li r4, 0x1d
	ctx.r[4].s64 = 29;
	// 821E5C84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E5C88: 48019941  bl 0x821ff5c8
	ctx.lr = 0x821E5C8C;
	sub_821FF5C8(ctx, base);
	// 821E5C8C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E5C90: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E5C94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E5C98: 409A0008  bne cr6, 0x821e5ca0
	if !ctx.cr[6].eq {
	pc = 0x821E5CA0; continue 'dispatch;
	}
	pc = 0x821E5C9C; continue 'dispatch;
            }
            0x821E5C9C => {
    //   block [0x821E5C9C..0x821E5CA0)
	// 821E5C9C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x821E5CA0; continue 'dispatch;
            }
            0x821E5CA0 => {
    //   block [0x821E5CA0..0x821E5CB4)
	// 821E5CA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E5CA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E5CA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E5CAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E5CB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821E5CB8 size=252
    let mut pc: u32 = 0x821E5CB8;
    'dispatch: loop {
        match pc {
            0x821E5CB8 => {
    //   block [0x821E5CB8..0x821E5D40)
	// 821E5CB8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821E5CBC: C80300F0  lfd f0, 0xf0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(240 as u32) ) };
	// 821E5CC0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821E5CC4: 394A9484  addi r10, r10, -0x6b7c
	ctx.r[10].s64 = ctx.r[10].s64 + -27516;
	// 821E5CC8: 396300F0  addi r11, r3, 0xf0
	ctx.r[11].s64 = ctx.r[3].s64 + 240;
	// 821E5CCC: C9890D38  lfd f12, 0xd38(r9)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(3384 as u32) ) };
	// 821E5CD0: C1AA000C  lfs f13, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E5CD4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 821E5CD8: 419A0068  beq cr6, 0x821e5d40
	if ctx.cr[6].eq {
	pc = 0x821E5D40; continue 'dispatch;
	}
	// 821E5CDC: C96B0008  lfd f11, 8(r11)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821E5CE0: FD6B0028  fsub f11, f11, f0
	ctx.f[11].f64 = ctx.f[11].f64 - ctx.f[0].f64;
	// 821E5CE4: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 821E5CE8: 40990058  ble cr6, 0x821e5d40
	if !ctx.cr[6].gt {
	pc = 0x821E5D40; continue 'dispatch;
	}
	// 821E5CEC: FD810028  fsub f12, f1, f0
	ctx.f[12].f64 = ctx.f[1].f64 - ctx.f[0].f64;
	// 821E5CF0: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E5CF4: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 821E5CF8: 392A0E68  addi r9, r10, 0xe68
	ctx.r[9].s64 = ctx.r[10].s64 + 3688;
	// 821E5CFC: FD6C5824  fdiv f11, f12, f11
	ctx.f[11].f64 = ctx.f[12].f64 / ctx.f[11].f64;
	// 821E5D00: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 821E5D04: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 821E5D08: 7D000026  mfcr r8
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[8].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821E5D0C: 5507DF7A  rlwinm r7, r8, 0x1b, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 821E5D10: 5506F77A  rlwinm r6, r8, 0x1e, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 821E5D14: 7CE53378  or r5, r7, r6
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 821E5D18: 7D292C2E  lfsx f9, r9, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821E5D1C: FD0902AE  fsel f8, f9, f10, f0
	ctx.f[8].f64 = if ctx.f[9].f64 >= 0.0 { ctx.f[10].f64 } else { ctx.f[0].f64 };
	// 821E5D20: ECE86828  fsubs f7, f8, f13
	ctx.f[7].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 821E5D24: FF070000  fcmpu cr6, f7, f0
	ctx.cr[6].compare_f64(ctx.f[7].f64, ctx.f[0].f64);
	// 821E5D28: 7C800026  mfcr r4
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[4].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821E5D2C: 548ADF7A  rlwinm r10, r4, 0x1b, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 821E5D30: 5488F77A  rlwinm r8, r4, 0x1e, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[4].u32 as u64 & 0x00000003u64;
	// 821E5D34: 7D474378  or r7, r10, r8
	ctx.r[7].u64 = ctx.r[10].u64 | ctx.r[8].u64;
	// 821E5D38: 7CC93C2E  lfsx f6, r9, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821E5D3C: FDA6436E  fsel f13, f6, f13, f8
	ctx.f[13].f64 = if ctx.f[6].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[8].f64 };
	pc = 0x821E5D40; continue 'dispatch;
            }
            0x821E5D40 => {
    //   block [0x821E5D40..0x821E5D54)
	// 821E5D40: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E5D44: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821E5D48: 409A000C  bne cr6, 0x821e5d54
	if !ctx.cr[6].eq {
	pc = 0x821E5D54; continue 'dispatch;
	}
	// 821E5D4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E5D50: 4800000C  b 0x821e5d5c
	pc = 0x821E5D5C; continue 'dispatch;
            }
            0x821E5D54 => {
    //   block [0x821E5D54..0x821E5D5C)
	// 821E5D54: D1AB0010  stfs f13, 0x10(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821E5D58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x821E5D5C; continue 'dispatch;
            }
            0x821E5D5C => {
    //   block [0x821E5D5C..0x821E5DB4)
	// 821E5D5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E5D60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E5D64: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821E5D68: 396300B0  addi r11, r3, 0xb0
	ctx.r[11].s64 = ctx.r[3].s64 + 176;
	// 821E5D6C: C0030100  lfs f0, 0x100(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E5D70: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 821E5D74: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 821E5D78: 3921FFF0  addi r9, r1, -0x10
	ctx.r[9].s64 = ctx.r[1].s64 + -16;
	// 821E5D7C: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E5DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E5DB8 size=2136
    let mut pc: u32 = 0x821E5DB8;
    'dispatch: loop {
        match pc {
            0x821E5DB8 => {
    //   block [0x821E5DB8..0x821E6610)
	// 821E5DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E5DBC: 48AC3619  bl 0x82ca93d4
	ctx.lr = 0x821E5DC0;
	sub_82CA93D0(ctx, base);
	// 821E5DC0: DBA1FF58  stfd f29, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[29].u64 ) };
	// 821E5DC4: DBC1FF60  stfd f30, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[30].u64 ) };
	// 821E5DC8: DBE1FF68  stfd f31, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[31].u64 ) };
	// 821E5DCC: 3980FF40  li r12, -0xc0
	ctx.r[12].s64 = -192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E6610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E6610 size=212
    let mut pc: u32 = 0x821E6610;
    'dispatch: loop {
        match pc {
            0x821E6610 => {
    //   block [0x821E6610..0x821E66E4)
	// 821E6610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E6614: 48AC2DE9  bl 0x82ca93fc
	ctx.lr = 0x821E6618;
	sub_82CA93D0(ctx, base);
	// 821E6618: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E661C: E8630028  ld r3, 0x28(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	// 821E6620: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E6624: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821E6628: 486E1F51  bl 0x828c8578
	ctx.lr = 0x821E662C;
	sub_828C8578(ctx, base);
	// 821E662C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821E6630: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E6634: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6638: 3B800030  li r28, 0x30
	ctx.r[28].s64 = 48;
	// 821E663C: 39091220  addi r8, r9, 0x1220
	ctx.r[8].s64 = ctx.r[9].s64 + 4640;
	// 821E6640: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E6644: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821E6648: 7CC7E3D7  divw. r6, r7, r28
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[28].s32;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E66E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821E66E8 size=8
    let mut pc: u32 = 0x821E66E8;
    'dispatch: loop {
        match pc {
            0x821E66E8 => {
    //   block [0x821E66E8..0x821E66F0)
	// 821E66E8: C0230100  lfs f1, 0x100(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(256 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821E66EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E66F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E66F0 size=88
    let mut pc: u32 = 0x821E66F0;
    'dispatch: loop {
        match pc {
            0x821E66F0 => {
    //   block [0x821E66F0..0x821E6730)
	// 821E66F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E66F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E66F8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E66FC: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E6700: 386B0018  addi r3, r11, 0x18
	ctx.r[3].s64 = ctx.r[11].s64 + 24;
	// 821E6704: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821E6708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E670C: 419A0028  beq cr6, 0x821e6734
	if ctx.cr[6].eq {
	pc = 0x821E6734; continue 'dispatch;
	}
	// 821E6710: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E6714: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E6718: 419A0018  beq cr6, 0x821e6730
	if ctx.cr[6].eq {
	pc = 0x821E6730; continue 'dispatch;
	}
	// 821E671C: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821E6720: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E6724: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E6728: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E672C: 4E800020  blr
	return;
            }
            0x821E6730 => {
    //   block [0x821E6730..0x821E6734)
	// 821E6730: 4BFAD709  bl 0x82193e38
	ctx.lr = 0x821E6734;
	sub_82193E38(ctx, base);
	pc = 0x821E6734; continue 'dispatch;
            }
            0x821E6734 => {
    //   block [0x821E6734..0x821E6748)
	// 821E6734: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E6738: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E673C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E6740: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E6744: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E6748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E6748 size=128
    let mut pc: u32 = 0x821E6748;
    'dispatch: loop {
        match pc {
            0x821E6748 => {
    //   block [0x821E6748..0x821E677C)
	// 821E6748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E674C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E6750: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821E6754: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E6758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E675C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E6760: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 821E6764: 3BCAFFDF  addi r30, r10, -0x21
	ctx.r[30].s64 = ctx.r[10].s64 + -33;
	// 821E6768: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E676C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E6770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E6774: 419A0008  beq cr6, 0x821e677c
	if ctx.cr[6].eq {
	pc = 0x821E677C; continue 'dispatch;
	}
	// 821E6778: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821E677C; continue 'dispatch;
            }
            0x821E677C => {
    //   block [0x821E677C..0x821E67A0)
	// 821E677C: 4800004D  bl 0x821e67c8
	ctx.lr = 0x821E6780;
	sub_821E67C8(ctx, base);
	// 821E6780: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E6784: 419A0028  beq cr6, 0x821e67ac
	if ctx.cr[6].eq {
	pc = 0x821E67AC; continue 'dispatch;
	}
	// 821E6788: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E678C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E6790: 409A0010  bne cr6, 0x821e67a0
	if !ctx.cr[6].eq {
	pc = 0x821E67A0; continue 'dispatch;
	}
	// 821E6794: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821E6798: 7C6B1850  subf r3, r11, r3
	ctx.r[3].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821E679C: 48000014  b 0x821e67b0
	pc = 0x821E67B0; continue 'dispatch;
            }
            0x821E67A0 => {
    //   block [0x821E67A0..0x821E67AC)
	// 821E67A0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E67A4: 7C6B1850  subf r3, r11, r3
	ctx.r[3].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 821E67A8: 48000008  b 0x821e67b0
	pc = 0x821E67B0; continue 'dispatch;
            }
            0x821E67AC => {
    //   block [0x821E67AC..0x821E67B0)
	// 821E67AC: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x821E67B0; continue 'dispatch;
            }
            0x821E67B0 => {
    //   block [0x821E67B0..0x821E67C8)
	// 821E67B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E67B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E67B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E67BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E67C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E67C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E67C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E67C8 size=124
    let mut pc: u32 = 0x821E67C8;
    'dispatch: loop {
        match pc {
            0x821E67C8 => {
    //   block [0x821E67C8..0x821E67E4)
	// 821E67C8: 89640000  lbz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E67CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E67D0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821E67D4: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E67D8: 7D6A0775  extsb. r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E67DC: 41820060  beq 0x821e683c
	if ctx.cr[0].eq {
	pc = 0x821E683C; continue 'dispatch;
	}
	// 821E67E0: 7D241850  subf r9, r4, r3
	ctx.r[9].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	pc = 0x821E67E4; continue 'dispatch;
            }
            0x821E67E4 => {
    //   block [0x821E67E4..0x821E67F0)
	// 821E67E4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821E67E8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E67EC: 419A0030  beq cr6, 0x821e681c
	if ctx.cr[6].eq {
	pc = 0x821E681C; continue 'dispatch;
	}
	pc = 0x821E67F0; continue 'dispatch;
            }
            0x821E67F0 => {
    //   block [0x821E67F0..0x821E681C)
	// 821E67F0: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E67F4: 7D4A0775  extsb. r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E67F8: 41820024  beq 0x821e681c
	if ctx.cr[0].eq {
	pc = 0x821E681C; continue 'dispatch;
	}
	// 821E67FC: 7D0958AE  lbzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821E6800: 7D080774  extsb r8, r8
	ctx.r[8].s64 = ctx.r[8].s8 as i64;
	// 821E6804: 7D4A4051  subf. r10, r10, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E6808: 40820014  bne 0x821e681c
	if !ctx.cr[0].eq {
	pc = 0x821E681C; continue 'dispatch;
	}
	// 821E680C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E6810: 7D4958AE  lbzx r10, r9, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821E6814: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E6818: 409AFFD8  bne cr6, 0x821e67f0
	if !ctx.cr[6].eq {
	pc = 0x821E67F0; continue 'dispatch;
	}
	pc = 0x821E681C; continue 'dispatch;
            }
            0x821E681C => {
    //   block [0x821E681C..0x821E683C)
	// 821E681C: 896B0000  lbz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E6820: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E6824: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821E6828: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 821E682C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821E6830: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E6834: 7D6A0775  extsb. r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E6838: 4082FFAC  bne 0x821e67e4
	if !ctx.cr[0].eq {
	pc = 0x821E67E4; continue 'dispatch;
	}
	pc = 0x821E683C; continue 'dispatch;
            }
            0x821E683C => {
    //   block [0x821E683C..0x821E6844)
	// 821E683C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E6840: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E6848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E6848 size=356
    let mut pc: u32 = 0x821E6848;
    'dispatch: loop {
        match pc {
            0x821E6848 => {
    //   block [0x821E6848..0x821E6870)
	// 821E6848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E684C: 48AC2BAD  bl 0x82ca93f8
	ctx.lr = 0x821E6850;
	sub_82CA93D0(ctx, base);
	// 821E6850: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E6854: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E6858: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 821E685C: 3B4B7088  addi r26, r11, 0x7088
	ctx.r[26].s64 = ctx.r[11].s64 + 28808;
	// 821E6860: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821E6864: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 821E6868: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 821E686C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	pc = 0x821E6870; continue 'dispatch;
            }
            0x821E6870 => {
    //   block [0x821E6870..0x821E68A8)
	// 821E6870: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821E6874: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E6878: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821E687C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821E6880: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821E6884: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E6888: 4082FFE8  bne 0x821e6870
	if !ctx.cr[0].eq {
	pc = 0x821E6870; continue 'dispatch;
	}
	// 821E688C: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 821E6890: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E6894: 3BCAFFDF  addi r30, r10, -0x21
	ctx.r[30].s64 = ctx.r[10].s64 + -33;
	// 821E6898: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E689C: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 821E68A0: 419A0008  beq cr6, 0x821e68a8
	if ctx.cr[6].eq {
	pc = 0x821E68A8; continue 'dispatch;
	}
	// 821E68A4: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821E68A8; continue 'dispatch;
            }
            0x821E68A8 => {
    //   block [0x821E68A8..0x821E68B8)
	// 821E68A8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E68AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E68B0: 419A0008  beq cr6, 0x821e68b8
	if ctx.cr[6].eq {
	pc = 0x821E68B8; continue 'dispatch;
	}
	// 821E68B4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821E68B8; continue 'dispatch;
            }
            0x821E68B8 => {
    //   block [0x821E68B8..0x821E68D4)
	// 821E68B8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E68BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821E68C0: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 821E68C4: 4BFFFF05  bl 0x821e67c8
	ctx.lr = 0x821E68C8;
	sub_821E67C8(ctx, base);
	// 821E68C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E68CC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821E68D0: 419A009C  beq cr6, 0x821e696c
	if ctx.cr[6].eq {
	pc = 0x821E696C; continue 'dispatch;
	}
	pc = 0x821E68D4; continue 'dispatch;
            }
            0x821E68D4 => {
    //   block [0x821E68D4..0x821E6900)
	// 821E68D4: 7CDCF850  subf r6, r28, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[28].s64;
	// 821E68D8: 7CBCE850  subf r5, r28, r29
	ctx.r[5].s64 = ctx.r[29].s64 - ctx.r[28].s64;
	// 821E68DC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821E68E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821E68E4: 4BFFD4AD  bl 0x821e3d90
	ctx.lr = 0x821E68E8;
	sub_821E3D90(ctx, base);
	// 821E68E8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E68EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E68F0: 48005F09  bl 0x821ec7f8
	ctx.lr = 0x821E68F4;
	sub_821EC7F8(ctx, base);
	// 821E68F4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821E68F8: 4BFDFE71  bl 0x821c6768
	ctx.lr = 0x821E68FC;
	sub_821C6768(ctx, base);
	// 821E68FC: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x821E6900; continue 'dispatch;
            }
            0x821E6900 => {
    //   block [0x821E6900..0x821E6924)
	// 821E6900: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 821E6904: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E6908: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821E690C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E6910: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821E6914: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E6918: 4082FFE8  bne 0x821e6900
	if !ctx.cr[0].eq {
	pc = 0x821E6900; continue 'dispatch;
	}
	// 821E691C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821E6920: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	pc = 0x821E6924; continue 'dispatch;
            }
            0x821E6924 => {
    //   block [0x821E6924..0x821E696C)
	// 821E6924: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E6928: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E692C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E6930: 409AFFF4  bne cr6, 0x821e6924
	if !ctx.cr[6].eq {
	pc = 0x821E6924; continue 'dispatch;
	}
	// 821E6934: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 821E6938: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 821E693C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E6940: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E6944: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E6948: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 821E694C: 48005EAD  bl 0x821ec7f8
	ctx.lr = 0x821E6950;
	sub_821EC7F8(ctx, base);
	// 821E6950: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E6954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E6958: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 821E695C: 4BFFFE6D  bl 0x821e67c8
	ctx.lr = 0x821E6960;
	sub_821E67C8(ctx, base);
	// 821E6960: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E6964: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821E6968: 409AFF6C  bne cr6, 0x821e68d4
	if !ctx.cr[6].eq {
	pc = 0x821E68D4; continue 'dispatch;
	}
	pc = 0x821E696C; continue 'dispatch;
            }
            0x821E696C => {
    //   block [0x821E696C..0x821E69AC)
	// 821E696C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821E6970: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821E6974: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E6978: 48046559  bl 0x8222ced0
	ctx.lr = 0x821E697C;
	sub_8222CED0(ctx, base);
	// 821E697C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E6980: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E6984: 48005E75  bl 0x821ec7f8
	ctx.lr = 0x821E6988;
	sub_821EC7F8(ctx, base);
	// 821E6988: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E698C: 4802E44D  bl 0x82214dd8
	ctx.lr = 0x821E6990;
	sub_82214DD8(ctx, base);
	// 821E6990: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E6994: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 821E6998: 4807E809  bl 0x822651a0
	ctx.lr = 0x821E699C;
	sub_822651A0(ctx, base);
	// 821E699C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E69A0: 4802E439  bl 0x82214dd8
	ctx.lr = 0x821E69A4;
	sub_82214DD8(ctx, base);
	// 821E69A4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821E69A8: 48AC2AA0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E69B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E69B8 size=372
    let mut pc: u32 = 0x821E69B8;
    'dispatch: loop {
        match pc {
            0x821E69B8 => {
    //   block [0x821E69B8..0x821E69E0)
	// 821E69B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E69BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E69C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E69C4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821E69C8: 419A0018  beq cr6, 0x821e69e0
	if ctx.cr[6].eq {
	pc = 0x821E69E0; continue 'dispatch;
	}
	// 821E69CC: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821E69D0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E69D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E69D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E69DC: 409A0008  bne cr6, 0x821e69e4
	if !ctx.cr[6].eq {
	pc = 0x821E69E4; continue 'dispatch;
	}
	pc = 0x821E69E0; continue 'dispatch;
            }
            0x821E69E0 => {
    //   block [0x821E69E0..0x821E69E4)
	// 821E69E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821E69E4; continue 'dispatch;
            }
            0x821E69E4 => {
    //   block [0x821E69E4..0x821E6A2C)
	// 821E69E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E69E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E69EC: 419A012C  beq cr6, 0x821e6b18
	if ctx.cr[6].eq {
	pc = 0x821E6B18; continue 'dispatch;
	}
	// 821E69F0: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E69F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E69F8: 5549CFFE  rlwinm r9, r10, 0x19, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 821E69FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E6A00: 419A00E8  beq cr6, 0x821e6ae8
	if ctx.cr[6].eq {
	pc = 0x821E6AE8; continue 'dispatch;
	}
	// 821E6A04: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E6A08: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E6A0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E6A10: 419A001C  beq cr6, 0x821e6a2c
	if ctx.cr[6].eq {
	pc = 0x821E6A2C; continue 'dispatch;
	}
	// 821E6A14: 896B0047  lbz r11, 0x47(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(71 as u32) ) } as u64;
	// 821E6A18: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821E6A1C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E6A20: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6A24: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E6A28: 480000C4  b 0x821e6aec
	pc = 0x821E6AEC; continue 'dispatch;
            }
            0x821E6A2C => {
    //   block [0x821E6A2C..0x821E6A48)
	// 821E6A2C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E6A30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E6A34: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E6A38: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E6A3C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821E6A40: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E6A44: 40810054  ble 0x821e6a98
	if !ctx.cr[0].gt {
	pc = 0x821E6A98; continue 'dispatch;
	}
	pc = 0x821E6A48; continue 'dispatch;
            }
            0x821E6A48 => {
    //   block [0x821E6A48..0x821E6A68)
	// 821E6A48: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E6A4C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E6A50: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E6A54: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E6A58: 2F070047  cmpwi cr6, r7, 0x47
	ctx.cr[6].compare_i32(ctx.r[7].s32, 71, &mut ctx.xer);
	// 821E6A5C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E6A60: 41980008  blt cr6, 0x821e6a68
	if ctx.cr[6].lt {
	pc = 0x821E6A68; continue 'dispatch;
	}
	// 821E6A64: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821E6A68; continue 'dispatch;
            }
            0x821E6A68 => {
    //   block [0x821E6A68..0x821E6A84)
	// 821E6A68: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E6A6C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E6A70: 419A0014  beq cr6, 0x821e6a84
	if ctx.cr[6].eq {
	pc = 0x821E6A84; continue 'dispatch;
	}
	// 821E6A74: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E6A78: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E6A7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E6A80: 4800000C  b 0x821e6a8c
	pc = 0x821E6A8C; continue 'dispatch;
            }
            0x821E6A84 => {
    //   block [0x821E6A84..0x821E6A8C)
	// 821E6A84: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E6A88: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821E6A8C; continue 'dispatch;
            }
            0x821E6A8C => {
    //   block [0x821E6A8C..0x821E6A98)
	// 821E6A8C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E6A90: 4199FFB8  bgt cr6, 0x821e6a48
	if ctx.cr[6].gt {
	pc = 0x821E6A48; continue 'dispatch;
	}
	// 821E6A94: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821E6A98; continue 'dispatch;
            }
            0x821E6A98 => {
    //   block [0x821E6A98..0x821E6AB4)
	// 821E6A98: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E6A9C: 419A003C  beq cr6, 0x821e6ad8
	if ctx.cr[6].eq {
	pc = 0x821E6AD8; continue 'dispatch;
	}
	// 821E6AA0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E6AA4: 2F0B0047  cmpwi cr6, r11, 0x47
	ctx.cr[6].compare_i32(ctx.r[11].s32, 71, &mut ctx.xer);
	// 821E6AA8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E6AAC: 41990008  bgt cr6, 0x821e6ab4
	if ctx.cr[6].gt {
	pc = 0x821E6AB4; continue 'dispatch;
	}
	// 821E6AB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821E6AB4; continue 'dispatch;
            }
            0x821E6AB4 => {
    //   block [0x821E6AB4..0x821E6AD8)
	// 821E6AB4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E6AB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E6ABC: 409A001C  bne cr6, 0x821e6ad8
	if !ctx.cr[6].eq {
	pc = 0x821E6AD8; continue 'dispatch;
	}
	// 821E6AC0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E6AC4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E6AC8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821E6ACC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E6AD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6AD4: 48000018  b 0x821e6aec
	pc = 0x821E6AEC; continue 'dispatch;
            }
            0x821E6AD8 => {
    //   block [0x821E6AD8..0x821E6AE8)
	// 821E6AD8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E6ADC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E6AE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6AE4: 48000008  b 0x821e6aec
	pc = 0x821E6AEC; continue 'dispatch;
            }
            0x821E6AE8 => {
    //   block [0x821E6AE8..0x821E6AEC)
	// 821E6AE8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x821E6AEC; continue 'dispatch;
            }
            0x821E6AEC => {
    //   block [0x821E6AEC..0x821E6B18)
	// 821E6AEC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821E6AF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E6AF4: 419A0024  beq cr6, 0x821e6b18
	if ctx.cr[6].eq {
	pc = 0x821E6B18; continue 'dispatch;
	}
	// 821E6AF8: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E6AFC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821E6B00: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E6B04: 4E800421  bctrl
	ctx.lr = 0x821E6B08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E6B08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E6B0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E6B10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E6B14: 4E800020  blr
	return;
            }
            0x821E6B18 => {
    //   block [0x821E6B18..0x821E6B2C)
	// 821E6B18: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E6B1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E6B20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E6B24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E6B28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E6B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E6B30 size=400
    let mut pc: u32 = 0x821E6B30;
    'dispatch: loop {
        match pc {
            0x821E6B30 => {
    //   block [0x821E6B30..0x821E6B8C)
	// 821E6B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E6B34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E6B38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E6B3C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E6B40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E6B44: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 821E6B48: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E6B4C: 40990160  ble cr6, 0x821e6cac
	if !ctx.cr[6].gt {
	pc = 0x821E6CAC; continue 'dispatch;
	}
	// 821E6B50: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6B54: 48020C9D  bl 0x822077f0
	ctx.lr = 0x821E6B58;
	sub_822077F0(ctx, base);
	// 821E6B58: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821E6B5C: 815F01A0  lwz r10, 0x1a0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 821E6B60: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821E6B64: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821E6B68: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E6B6C: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 821E6B70: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 821E6B74: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 821E6B78: FDA10024  fdiv f13, f1, f0
	ctx.f[13].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 821E6B7C: C0069484  lfs f0, -0x6b7c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E6B80: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821E6B84: 40990054  ble cr6, 0x821e6bd8
	if !ctx.cr[6].gt {
	pc = 0x821E6BD8; continue 'dispatch;
	}
	// 821E6B88: 397F0238  addi r11, r31, 0x238
	ctx.r[11].s64 = ctx.r[31].s64 + 568;
	pc = 0x821E6B8C; continue 'dispatch;
            }
            0x821E6B8C => {
    //   block [0x821E6B8C..0x821E6BB4)
	// 821E6B8C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E6B90: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 821E6B94: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821E6B98: 4099001C  ble cr6, 0x821e6bb4
	if !ctx.cr[6].gt {
	pc = 0x821E6BB4; continue 'dispatch;
	}
	// 821E6B9C: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 821E6BA0: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E6BA4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821E6BA8: 4199000C  bgt cr6, 0x821e6bb4
	if ctx.cr[6].gt {
	pc = 0x821E6BB4; continue 'dispatch;
	}
	// 821E6BAC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E6BB0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x821E6BB4; continue 'dispatch;
            }
            0x821E6BB4 => {
    //   block [0x821E6BB4..0x821E6BC4)
	// 821E6BB4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821E6BB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E6BBC: 419A0008  beq cr6, 0x821e6bc4
	if ctx.cr[6].eq {
	pc = 0x821E6BC4; continue 'dispatch;
	}
	// 821E6BC0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	pc = 0x821E6BC4; continue 'dispatch;
            }
            0x821E6BC4 => {
    //   block [0x821E6BC4..0x821E6BD8)
	// 821E6BC4: 815F01A0  lwz r10, 0x1a0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 821E6BC8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821E6BCC: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821E6BD0: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821E6BD4: 4198FFB8  blt cr6, 0x821e6b8c
	if ctx.cr[6].lt {
	pc = 0x821E6B8C; continue 'dispatch;
	}
	pc = 0x821E6BD8; continue 'dispatch;
            }
            0x821E6BD8 => {
    //   block [0x821E6BD8..0x821E6C00)
	// 821E6BD8: 54EB063E  clrlwi r11, r7, 0x18
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E6BDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E6BE0: 419A00CC  beq cr6, 0x821e6cac
	if ctx.cr[6].eq {
	pc = 0x821E6CAC; continue 'dispatch;
	}
	// 821E6BE4: 817F01A0  lwz r11, 0x1a0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 821E6BE8: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 821E6BEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E6BF0: 40990034  ble cr6, 0x821e6c24
	if !ctx.cr[6].gt {
	pc = 0x821E6C24; continue 'dispatch;
	}
	// 821E6BF4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E6BF8: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 821E6BFC: 395F0238  addi r10, r31, 0x238
	ctx.r[10].s64 = ctx.r[31].s64 + 568;
	pc = 0x821E6C00; continue 'dispatch;
            }
            0x821E6C00 => {
    //   block [0x821E6C00..0x821E6C18)
	// 821E6C00: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E6C04: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821E6C08: 40990010  ble cr6, 0x821e6c18
	if !ctx.cr[6].gt {
	pc = 0x821E6C18; continue 'dispatch;
	}
	// 821E6C0C: D1A90000  stfs f13, 0(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E6C10: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 821E6C14: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	pc = 0x821E6C18; continue 'dispatch;
            }
            0x821E6C18 => {
    //   block [0x821E6C18..0x821E6C24)
	// 821E6C18: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E6C1C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821E6C20: 4082FFE0  bne 0x821e6c00
	if !ctx.cr[0].eq {
	pc = 0x821E6C00; continue 'dispatch;
	}
	pc = 0x821E6C24; continue 'dispatch;
            }
            0x821E6C24 => {
    //   block [0x821E6C24..0x821E6C34)
	// 821E6C24: 395F0238  addi r10, r31, 0x238
	ctx.r[10].s64 = ctx.r[31].s64 + 568;
	// 821E6C28: 3920000A  li r9, 0xa
	ctx.r[9].s64 = 10;
	// 821E6C2C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821E6C30: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x821E6C34; continue 'dispatch;
            }
            0x821E6C34 => {
    //   block [0x821E6C34..0x821E6C54)
	// 821E6C34: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821E6C38: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821E6C3C: 4200FFF8  bdnz 0x821e6c34
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821E6C34; continue 'dispatch;
	}
	// 821E6C40: 90FF01A0  stw r7, 0x1a0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), ctx.r[7].u32 ) };
	// 821E6C44: 7D094378  mr r9, r8
	ctx.r[9].u64 = ctx.r[8].u64;
	// 821E6C48: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821E6C4C: 40990028  ble cr6, 0x821e6c74
	if !ctx.cr[6].gt {
	pc = 0x821E6C74; continue 'dispatch;
	}
	// 821E6C50: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	pc = 0x821E6C54; continue 'dispatch;
            }
            0x821E6C54 => {
    //   block [0x821E6C54..0x821E6C74)
	// 821E6C54: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E6C58: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821E6C5C: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E6C60: 80FF01A0  lwz r7, 0x1a0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 821E6C64: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821E6C68: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 821E6C6C: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 821E6C70: 4198FFE4  blt cr6, 0x821e6c54
	if ctx.cr[6].lt {
	pc = 0x821E6C54; continue 'dispatch;
	}
	pc = 0x821E6C74; continue 'dispatch;
            }
            0x821E6C74 => {
    //   block [0x821E6C74..0x821E6CAC)
	// 821E6C74: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 821E6C78: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E6C7C: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 821E6C80: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E6C84: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 821E6C88: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6C8C: 48563E3D  bl 0x8274aac8
	ctx.lr = 0x821E6C90;
	sub_8274AAC8(ctx, base);
	// 821E6C90: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E6C94: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6C98: 48563B09  bl 0x8274a7a0
	ctx.lr = 0x821E6C9C;
	sub_8274A7A0(ctx, base);
	// 821E6C9C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E6CA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E6CA4: 419A0008  beq cr6, 0x821e6cac
	if ctx.cr[6].eq {
	pc = 0x821E6CAC; continue 'dispatch;
	}
	// 821E6CA8: 48035091  bl 0x8221bd38
	ctx.lr = 0x821E6CAC;
	sub_8221BD38(ctx, base);
	pc = 0x821E6CAC; continue 'dispatch;
            }
            0x821E6CAC => {
    //   block [0x821E6CAC..0x821E6CC0)
	// 821E6CAC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821E6CB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E6CB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E6CB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E6CBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E6CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E6CC0 size=172
    let mut pc: u32 = 0x821E6CC0;
    'dispatch: loop {
        match pc {
            0x821E6CC0 => {
    //   block [0x821E6CC0..0x821E6D6C)
	// 821E6CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E6CC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E6CC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E6CCC: 3980FFE0  li r12, -0x20
	ctx.r[12].s64 = -32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E6D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E6D70 size=412
    let mut pc: u32 = 0x821E6D70;
    'dispatch: loop {
        match pc {
            0x821E6D70 => {
    //   block [0x821E6D70..0x821E6DF4)
	// 821E6D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E6D74: 48AC2699  bl 0x82ca940c
	ctx.lr = 0x821E6D78;
	sub_82CA93D0(ctx, base);
	// 821E6D78: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 821E6D7C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821E6D80: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E6D84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E6D88: 897F026D  lbz r11, 0x26d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(621 as u32) ) } as u64;
	// 821E6D8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E6D90: 419A016C  beq cr6, 0x821e6efc
	if ctx.cr[6].eq {
	pc = 0x821E6EFC; continue 'dispatch;
	}
	// 821E6D94: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6D98: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E6D9C: 48020A55  bl 0x822077f0
	ctx.lr = 0x821E6DA0;
	sub_822077F0(ctx, base);
	// 821E6DA0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821E6DA4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E6DA8: C1BF020C  lfs f13, 0x20c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E6DAC: C19F0210  lfs f12, 0x210(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821E6DB0: 3BCBBE04  addi r30, r11, -0x41fc
	ctx.r[30].s64 = ctx.r[11].s64 + -16892;
	// 821E6DB4: C80A9660  lfd f0, -0x69a0(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 821E6DB8: FD610024  fdiv f11, f1, f0
	ctx.f[11].f64 = ctx.f[1].f64 / ctx.f[0].f64;
	// 821E6DBC: C3DED680  lfs f30, -0x2980(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-10624 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821E6DC0: C3FED68C  lfs f31, -0x2974(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-10612 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821E6DC4: FF0CF000  fcmpu cr6, f12, f30
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[30].f64);
	// 821E6DC8: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 821E6DCC: EC0C6ABA  fmadds f0, f12, f10, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64);
	// 821E6DD0: D01F020C  stfs f0, 0x20c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), tmp.u32 ) };
	// 821E6DD4: 40990020  ble cr6, 0x821e6df4
	if !ctx.cr[6].gt {
	pc = 0x821E6DF4; continue 'dispatch;
	}
	// 821E6DD8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821E6DDC: 41980024  blt cr6, 0x821e6e00
	if ctx.cr[6].lt {
	pc = 0x821E6E00; continue 'dispatch;
	}
	// 821E6DE0: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 821E6DE4: D3FF020C  stfs f31, 0x20c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), tmp.u32 ) };
	// 821E6DE8: C00B1474  lfs f0, 0x1474(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5236 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E6DEC: D01F0210  stfs f0, 0x210(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), tmp.u32 ) };
	// 821E6DF0: 48000010  b 0x821e6e00
	pc = 0x821E6E00; continue 'dispatch;
            }
            0x821E6DF4 => {
    //   block [0x821E6DF4..0x821E6E00)
	// 821E6DF4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821E6DF8: 41990008  bgt cr6, 0x821e6e00
	if ctx.cr[6].gt {
	pc = 0x821E6E00; continue 'dispatch;
	}
	// 821E6DFC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	pc = 0x821E6E00; continue 'dispatch;
            }
            0x821E6E00 => {
    //   block [0x821E6E00..0x821E6E88)
	// 821E6E00: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 821E6E04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E6E08: 409A00C4  bne cr6, 0x821e6ecc
	if !ctx.cr[6].eq {
	pc = 0x821E6ECC; continue 'dispatch;
	}
	// 821E6E0C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E6E10: C01F0214  lfs f0, 0x214(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E6E14: C1BF0218  lfs f13, 0x218(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E6E18: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821E6E1C: C17F020C  lfs f11, 0x20c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821E6E20: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821E6E24: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E6E28: EC2C02FA  fmadds f1, f12, f11, f0
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 821E6E2C: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E6E30: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6E34: 83A80054  lwz r29, 0x54(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E6E38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E6E3C: 48426F0D  bl 0x8260dd48
	ctx.lr = 0x821E6E40;
	sub_8260DD48(ctx, base);
	// 821E6E40: C1BED4C8  lfs f13, -0x2b38(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-11064 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E6E44: C19F0220  lfs f12, 0x220(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821E6E48: C01F020C  lfs f0, 0x20c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(524 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E6E4C: FC206090  fmr f1, f12
	ctx.f[1].f64 = ctx.f[12].f64;
	// 821E6E50: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821E6E54: 4098005C  bge cr6, 0x821e6eb0
	if !ctx.cr[6].lt {
	pc = 0x821E6EB0; continue 'dispatch;
	}
	// 821E6E58: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821E6E5C: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E6E60: ED4DF83C  fnmsubs f10, f13, f0, f31
	ctx.f[10].f64 = -(((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 821E6E64: FF0AF800  fcmpu cr6, f10, f31
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[31].f64);
	// 821E6E68: 40980048  bge cr6, 0x821e6eb0
	if !ctx.cr[6].lt {
	pc = 0x821E6EB0; continue 'dispatch;
	}
	// 821E6E6C: C17F021C  lfs f11, 0x21c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821E6E70: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E6E74: EC0C5828  fsubs f0, f12, f11
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 821E6E78: C1AB9044  lfs f13, -0x6fbc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28604 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821E6E7C: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821E6E80: 40980008  bge cr6, 0x821e6e88
	if !ctx.cr[6].lt {
	pc = 0x821E6E88; continue 'dispatch;
	}
	// 821E6E84: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	pc = 0x821E6E88; continue 'dispatch;
            }
            0x821E6E88 => {
    //   block [0x821E6E88..0x821E6E9C)
	// 821E6E88: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E6E8C: C18B9040  lfs f12, -0x6fc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28608 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821E6E90: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 821E6E94: 40990008  ble cr6, 0x821e6e9c
	if !ctx.cr[6].gt {
	pc = 0x821E6E9C; continue 'dispatch;
	}
	// 821E6E98: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x821E6E9C; continue 'dispatch;
            }
            0x821E6E9C => {
    //   block [0x821E6E9C..0x821E6EB0)
	// 821E6E9C: EC005ABA  fmadds f0, f0, f10, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64);
	// 821E6EA0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821E6EA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E6EA8: 4840F719  bl 0x825f65c0
	ctx.lr = 0x821E6EAC;
	sub_825F65C0(ctx, base);
	// 821E6EAC: C0210050  lfs f1, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x821E6EB0; continue 'dispatch;
            }
            0x821E6EB0 => {
    //   block [0x821E6EB0..0x821E6ECC)
	// 821E6EB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E6EB4: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 821E6EB8: 48426F01  bl 0x8260ddb8
	ctx.lr = 0x821E6EBC;
	sub_8260DDB8(ctx, base);
	// 821E6EBC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821E6EC0: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821E6EC4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821E6EC8: 48AC2594  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821E6ECC => {
    //   block [0x821E6ECC..0x821E6EFC)
	// 821E6ECC: 897F026D  lbz r11, 0x26d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(621 as u32) ) } as u64;
	// 821E6ED0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E6ED4: 419A0028  beq cr6, 0x821e6efc
	if ctx.cr[6].eq {
	pc = 0x821E6EFC; continue 'dispatch;
	}
	// 821E6ED8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E6EDC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821E6EE0: 997F026D  stb r11, 0x26d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(621 as u32), ctx.r[11].u8 ) };
	// 821E6EE4: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821E6EE8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E6EEC: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E6EF0: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E6EF4: 80670054  lwz r3, 0x54(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E6EF8: 48426F29  bl 0x8260de20
	ctx.lr = 0x821E6EFC;
	sub_8260DE20(ctx, base);
	pc = 0x821E6EFC; continue 'dispatch;
            }
            0x821E6EFC => {
    //   block [0x821E6EFC..0x821E6F0C)
	// 821E6EFC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821E6F00: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821E6F04: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821E6F08: 48AC2554  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E6F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E6F10 size=1228
    let mut pc: u32 = 0x821E6F10;
    'dispatch: loop {
        match pc {
            0x821E6F10 => {
    //   block [0x821E6F10..0x821E73DC)
	// 821E6F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E6F14: 48AC24F5  bl 0x82ca9408
	ctx.lr = 0x821E6F18;
	sub_82CA93D0(ctx, base);
	// 821E6F18: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 821E6F1C: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 821E6F20: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821E6F24: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E73E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E73E0 size=296
    let mut pc: u32 = 0x821E73E0;
    'dispatch: loop {
        match pc {
            0x821E73E0 => {
    //   block [0x821E73E0..0x821E7450)
	// 821E73E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E73E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E73E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E73EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E73F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E73F4: 897F026A  lbz r11, 0x26a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(618 as u32) ) } as u64;
	// 821E73F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E73FC: 419A0058  beq cr6, 0x821e7454
	if ctx.cr[6].eq {
	pc = 0x821E7454; continue 'dispatch;
	}
	// 821E7400: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E7404: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7408: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E740C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821E7410: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821E7414: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E7418: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821E741C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7420: 80680044  lwz r3, 0x44(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(68 as u32) ) } as u64;
	// 821E7424: 4BF8CF05  bl 0x82174328
	ctx.lr = 0x821E7428;
	sub_82174328(ctx, base);
	// 821E7428: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E742C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E7430: 409A0020  bne cr6, 0x821e7450
	if !ctx.cr[6].eq {
	pc = 0x821E7450; continue 'dispatch;
	}
	// 821E7434: 815F017C  lwz r10, 0x17c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(380 as u32) ) } as u64;
	// 821E7438: 997F026A  stb r11, 0x26a(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(618 as u32), ctx.r[11].u8 ) };
	// 821E743C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E7440: 409A0010  bne cr6, 0x821e7450
	if !ctx.cr[6].eq {
	pc = 0x821E7450; continue 'dispatch;
	}
	// 821E7444: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821E7448: C00A9240  lfs f0, -0x6dc0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E744C: D01F0234  stfs f0, 0x234(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), tmp.u32 ) };
	pc = 0x821E7450; continue 'dispatch;
            }
            0x821E7450 => {
    //   block [0x821E7450..0x821E7454)
	// 821E7450: 997F026B  stb r11, 0x26b(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(619 as u32), ctx.r[11].u8 ) };
	pc = 0x821E7454; continue 'dispatch;
            }
            0x821E7454 => {
    //   block [0x821E7454..0x821E7474)
	// 821E7454: 817F0070  lwz r11, 0x70(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 821E7458: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E745C: 419A002C  beq cr6, 0x821e7488
	if ctx.cr[6].eq {
	pc = 0x821E7488; continue 'dispatch;
	}
	// 821E7460: 817F0174  lwz r11, 0x174(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 821E7464: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E7468: 419A000C  beq cr6, 0x821e7474
	if ctx.cr[6].eq {
	pc = 0x821E7474; continue 'dispatch;
	}
	// 821E746C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E7470: 917F0174  stw r11, 0x174(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	pc = 0x821E7474; continue 'dispatch;
            }
            0x821E7474 => {
    //   block [0x821E7474..0x821E7488)
	// 821E7474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E7478: 483572B1  bl 0x8253e728
	ctx.lr = 0x821E747C;
	sub_8253E728(ctx, base);
	// 821E747C: 48357515  bl 0x8253e990
	ctx.lr = 0x821E7480;
	sub_8253E990(ctx, base);
	// 821E7480: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E7484: 4835B8ED  bl 0x82542d70
	ctx.lr = 0x821E7488;
	sub_82542D70(ctx, base);
	pc = 0x821E7488; continue 'dispatch;
            }
            0x821E7488 => {
    //   block [0x821E7488..0x821E74D4)
	// 821E7488: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E748C: C01F0234  lfs f0, 0x234(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E7490: C16B9484  lfs f11, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821E7494: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 821E7498: 4099003C  ble cr6, 0x821e74d4
	if !ctx.cr[6].gt {
	pc = 0x821E74D4; continue 'dispatch;
	}
	// 821E749C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E74A0: 48020351  bl 0x822077f0
	ctx.lr = 0x821E74A4;
	sub_822077F0(ctx, base);
	// 821E74A4: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821E74A8: C01F0234  lfs f0, 0x234(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E74AC: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 821E74B0: C9AB9660  lfd f13, -0x69a0(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 821E74B4: FDA16824  fdiv f13, f1, f13
	ctx.f[13].f64 = ctx.f[1].f64 / ctx.f[13].f64;
	// 821E74B8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821E74BC: 40990018  ble cr6, 0x821e74d4
	if !ctx.cr[6].gt {
	pc = 0x821E74D4; continue 'dispatch;
	}
	// 821E74C0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821E74C4: D01F0234  stfs f0, 0x234(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 821E74C8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 821E74CC: 41990008  bgt cr6, 0x821e74d4
	if ctx.cr[6].gt {
	pc = 0x821E74D4; continue 'dispatch;
	}
	// 821E74D0: D17F0234  stfs f11, 0x234(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), tmp.u32 ) };
	pc = 0x821E74D4; continue 'dispatch;
            }
            0x821E74D4 => {
    //   block [0x821E74D4..0x821E7508)
	// 821E74D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E74D8: 4BFFFA39  bl 0x821e6f10
	ctx.lr = 0x821E74DC;
	sub_821E6F10(ctx, base);
	// 821E74DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E74E0: 4BFFF651  bl 0x821e6b30
	ctx.lr = 0x821E74E4;
	sub_821E6B30(ctx, base);
	// 821E74E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E74E8: 4BFFF889  bl 0x821e6d70
	ctx.lr = 0x821E74EC;
	sub_821E6D70(ctx, base);
	// 821E74EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E74F0: 4BFFF7D1  bl 0x821e6cc0
	ctx.lr = 0x821E74F4;
	sub_821E6CC0(ctx, base);
	// 821E74F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E74F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E74FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E7500: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E7504: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E7508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E7508 size=88
    let mut pc: u32 = 0x821E7508;
    'dispatch: loop {
        match pc {
            0x821E7508 => {
    //   block [0x821E7508..0x821E7560)
	// 821E7508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E750C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E7510: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E7514: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E7518: 8084007C  lwz r4, 0x7c(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(124 as u32) ) } as u64;
	// 821E751C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E7520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E7524: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E7528: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821E752C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E7530: 4E800421  bctrl
	ctx.lr = 0x821E7534;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E7534: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821E7538: E8690000  ld r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821E753C: E8890008  ld r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 821E7540: 4800E619  bl 0x821f5b58
	ctx.lr = 0x821E7544;
	sub_821F5B58(ctx, base);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E7560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E7560 size=196
    let mut pc: u32 = 0x821E7560;
    'dispatch: loop {
        match pc {
            0x821E7560 => {
    //   block [0x821E7560..0x821E75A0)
	// 821E7560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E7564: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E7568: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E756C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E7570: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E7574: 81440014  lwz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E7578: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E757C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821E7580: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E7584: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821E7588: 409A0018  bne cr6, 0x821e75a0
	if !ctx.cr[6].eq {
	pc = 0x821E75A0; continue 'dispatch;
	}
	// 821E758C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821E7590: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821E7594: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821E7598: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821E759C: 48000028  b 0x821e75c4
	pc = 0x821E75C4; continue 'dispatch;
            }
            0x821E75A0 => {
    //   block [0x821E75A0..0x821E75C0)
	// 821E75A0: 81040010  lwz r8, 0x10(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E75A4: 3964000C  addi r11, r4, 0xc
	ctx.r[11].s64 = ctx.r[4].s64 + 12;
	// 821E75A8: 550A003E  slwi r10, r8, 0
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E75AC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E75B0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E75B4: 409A000C  bne cr6, 0x821e75c0
	if !ctx.cr[6].eq {
	pc = 0x821E75C0; continue 'dispatch;
	}
	// 821E75B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 821E75BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E75C0; continue 'dispatch;
            }
            0x821E75C0 => {
    //   block [0x821E75C0..0x821E75C4)
	// 821E75C0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	pc = 0x821E75C4; continue 'dispatch;
            }
            0x821E75C4 => {
    //   block [0x821E75C4..0x821E75DC)
	// 821E75C4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E75C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E75CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E75D0: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821E75D4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821E75D8: 419A0020  beq cr6, 0x821e75f8
	if ctx.cr[6].eq {
	pc = 0x821E75F8; continue 'dispatch;
	}
	pc = 0x821E75DC; continue 'dispatch;
            }
            0x821E75DC => {
    //   block [0x821E75DC..0x821E75F8)
	// 821E75DC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 821E75E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E75E4: 7D605028  lwarx r11, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 821E75E8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821E75EC: 7D60512D  stwcx. r11, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821E75F0: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E75F4: 4082FFE8  bne 0x821e75dc
	if !ctx.cr[0].eq {
	pc = 0x821E75DC; continue 'dispatch;
	}
	pc = 0x821E75F8; continue 'dispatch;
            }
            0x821E75F8 => {
    //   block [0x821E75F8..0x821E760C)
	// 821E75F8: 552B07FE  clrlwi r11, r9, 0x1f
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 821E75FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E7600: 419A000C  beq cr6, 0x821e760c
	if ctx.cr[6].eq {
	pc = 0x821E760C; continue 'dispatch;
	}
	// 821E7604: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E7608: 4BFD0511  bl 0x821b7b18
	ctx.lr = 0x821E760C;
	sub_821B7B18(ctx, base);
	pc = 0x821E760C; continue 'dispatch;
            }
            0x821E760C => {
    //   block [0x821E760C..0x821E7624)
	// 821E760C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E7610: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E7614: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E7618: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E761C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E7620: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E7628(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E7628 size=220
    let mut pc: u32 = 0x821E7628;
    'dispatch: loop {
        match pc {
            0x821E7628 => {
    //   block [0x821E7628..0x821E7660)
	// 821E7628: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E762C: 48AC1DD5  bl 0x82ca9400
	ctx.lr = 0x821E7630;
	sub_82CA93D0(ctx, base);
	// 821E7630: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E7634: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821E7638: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821E763C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E7640: 392B6978  addi r9, r11, 0x6978
	ctx.r[9].s64 = ctx.r[11].s64 + 27000;
	// 821E7644: 3BDB0F38  addi r30, r27, 0xf38
	ctx.r[30].s64 = ctx.r[27].s64 + 3896;
	// 821E7648: 915B0004  stw r10, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821E764C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821E7650: 913B0000  stw r9, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821E7654: 3940000E  li r10, 0xe
	ctx.r[10].s64 = 14;
	// 821E7658: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	// 821E765C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x821E7660; continue 'dispatch;
            }
            0x821E7660 => {
    //   block [0x821E7660..0x821E7684)
	// 821E7660: 912BFFFC  stw r9, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[9].u32 ) };
	// 821E7664: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E7668: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821E766C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821E7670: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 821E7674: 4080FFEC  bge 0x821e7660
	if !ctx.cr[0].lt {
	pc = 0x821E7660; continue 'dispatch;
	}
	// 821E7678: 3BBB1028  addi r29, r27, 0x1028
	ctx.r[29].s64 = ctx.r[27].s64 + 4136;
	// 821E767C: 7FFBD050  subf r31, r27, r26
	ctx.r[31].s64 = ctx.r[26].s64 - ctx.r[27].s64;
	// 821E7680: 3B80000F  li r28, 0xf
	ctx.r[28].s64 = 15;
	pc = 0x821E7684; continue 'dispatch;
            }
            0x821E7684 => {
    //   block [0x821E7684..0x821E7704)
	// 821E7684: 7C9FF214  add r4, r31, r30
	ctx.r[4].u64 = ctx.r[31].u64 + ctx.r[30].u64;
	// 821E7688: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E768C: 4800007D  bl 0x821e7708
	ctx.lr = 0x821E7690;
	sub_821E7708(ctx, base);
	// 821E7690: 7C1FEC2E  lfsx f0, r31, r29
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E7694: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E7698: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 821E769C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 821E76A0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821E76A4: 4082FFE0  bne 0x821e7684
	if !ctx.cr[0].eq {
	pc = 0x821E7684; continue 'dispatch;
	}
	// 821E76A8: 38FA0C34  addi r7, r26, 0xc34
	ctx.r[7].s64 = ctx.r[26].s64 + 3124;
	// 821E76AC: 391A0020  addi r8, r26, 0x20
	ctx.r[8].s64 = ctx.r[26].s64 + 32;
	// 821E76B0: 395B0C30  addi r10, r27, 0xc30
	ctx.r[10].s64 = ctx.r[27].s64 + 3120;
	// 821E76B4: 397B0010  addi r11, r27, 0x10
	ctx.r[11].s64 = ctx.r[27].s64 + 16;
	// 821E76B8: 39200061  li r9, 0x61
	ctx.r[9].s64 = 97;
	// 821E76BC: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E7708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E7708 size=568
    let mut pc: u32 = 0x821E7708;
    'dispatch: loop {
        match pc {
            0x821E7708 => {
    //   block [0x821E7708..0x821E7768)
	// 821E7708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E770C: 48AC1D01  bl 0x82ca940c
	ctx.lr = 0x821E7710;
	sub_82CA93D0(ctx, base);
	// 821E7710: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E7714: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821E7718: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821E771C: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821E7720: 419A0214  beq cr6, 0x821e7934
	if ctx.cr[6].eq {
	pc = 0x821E7934; continue 'dispatch;
	}
	// 821E7724: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E7728: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E772C: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7730: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 821E7734: 7D471E71  srawi. r7, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821E7738: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E773C: 4082005C  bne 0x821e7798
	if !ctx.cr[0].eq {
	pc = 0x821E7798; continue 'dispatch;
	}
	// 821E7740: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E7744: 419A01F0  beq cr6, 0x821e7934
	if ctx.cr[6].eq {
	pc = 0x821E7934; continue 'dispatch;
	}
	// 821E7748: 7D0A5050  subf r8, r10, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[10].s64;
	// 821E774C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821E7750: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821E7754: 7F0A5040  cmplw cr6, r10, r10
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E7758: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E775C: 7CE84A14  add r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 821E7760: 419A0028  beq cr6, 0x821e7788
	if ctx.cr[6].eq {
	pc = 0x821E7788; continue 'dispatch;
	}
	// 821E7764: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	pc = 0x821E7768; continue 'dispatch;
            }
            0x821E7768 => {
    //   block [0x821E7768..0x821E7788)
	// 821E7768: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E776C: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 821E7770: 7C095D2E  stfsx f0, r9, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821E7774: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7778: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E777C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E7780: 7CC9412E  stwx r6, r9, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32), ctx.r[6].u32) };
	// 821E7784: 409AFFE4  bne cr6, 0x821e7768
	if !ctx.cr[6].eq {
	pc = 0x821E7768; continue 'dispatch;
	}
	pc = 0x821E7788; continue 'dispatch;
            }
            0x821E7788 => {
    //   block [0x821E7788..0x821E7798)
	// 821E7788: 90FD0008  stw r7, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821E778C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E7790: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E7794: 48AC1CC8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821E7798 => {
    //   block [0x821E7798..0x821E77B4)
	// 821E7798: 7CC95050  subf r6, r9, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 821E779C: 7CCA1E70  srawi r10, r6, 3
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[6].s32 >> 3) as i64;
	// 821E77A0: 7F075040  cmplw cr6, r7, r10
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E77A4: 4199005C  bgt cr6, 0x821e7800
	if ctx.cr[6].gt {
	pc = 0x821E7800; continue 'dispatch;
	}
	// 821E77A8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E77AC: 419A0028  beq cr6, 0x821e77d4
	if ctx.cr[6].eq {
	pc = 0x821E77D4; continue 'dispatch;
	}
	// 821E77B0: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x821E77B4; continue 'dispatch;
            }
            0x821E77B4 => {
    //   block [0x821E77B4..0x821E77D4)
	// 821E77B4: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E77B8: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 821E77BC: 7C0A5D2E  stfsx f0, r10, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 821E77C0: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E77C4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E77C8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E77CC: 7CEA492E  stwx r7, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	// 821E77D0: 409AFFE4  bne cr6, 0x821e77b4
	if !ctx.cr[6].eq {
	pc = 0x821E77B4; continue 'dispatch;
	}
	pc = 0x821E77D4; continue 'dispatch;
            }
            0x821E77D4 => {
    //   block [0x821E77D4..0x821E7800)
	// 821E77D4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E77D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E77DC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E77E0: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E77E4: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E77E8: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 821E77EC: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E77F0: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E77F4: 90DD0008  stw r6, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 821E77F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E77FC: 48AC1C60  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821E7800 => {
    //   block [0x821E7800..0x821E7814)
	// 821E7800: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821E7804: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E7808: 409A000C  bne cr6, 0x821e7814
	if !ctx.cr[6].eq {
	pc = 0x821E7814; continue 'dispatch;
	}
	// 821E780C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821E7810: 48000010  b 0x821e7820
	pc = 0x821E7820; continue 'dispatch;
            }
            0x821E7814 => {
    //   block [0x821E7814..0x821E7820)
	// 821E7814: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E7818: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E781C: 7D0B1E70  srawi r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	pc = 0x821E7820; continue 'dispatch;
            }
            0x821E7820 => {
    //   block [0x821E7820..0x821E783C)
	// 821E7820: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E7824: 41990084  bgt cr6, 0x821e78a8
	if ctx.cr[6].gt {
	pc = 0x821E78A8; continue 'dispatch;
	}
	// 821E7828: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E782C: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E7830: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E7834: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E7838: 419A0024  beq cr6, 0x821e785c
	if ctx.cr[6].eq {
	pc = 0x821E785C; continue 'dispatch;
	}
	pc = 0x821E783C; continue 'dispatch;
            }
            0x821E783C => {
    //   block [0x821E783C..0x821E785C)
	// 821E783C: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E7840: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E7844: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7848: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E784C: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821E7850: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E7854: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 821E7858: 409AFFE4  bne cr6, 0x821e783c
	if !ctx.cr[6].eq {
	pc = 0x821E783C; continue 'dispatch;
	}
	pc = 0x821E785C; continue 'dispatch;
            }
            0x821E785C => {
    //   block [0x821E785C..0x821E7870)
	// 821E785C: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E7860: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821E7864: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E7868: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E786C: 419A002C  beq cr6, 0x821e7898
	if ctx.cr[6].eq {
	pc = 0x821E7898; continue 'dispatch;
	}
	pc = 0x821E7870; continue 'dispatch;
            }
            0x821E7870 => {
    //   block [0x821E7870..0x821E7888)
	// 821E7870: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E7874: 419A0014  beq cr6, 0x821e7888
	if ctx.cr[6].eq {
	pc = 0x821E7888; continue 'dispatch;
	}
	// 821E7878: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E787C: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E7880: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7884: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x821E7888; continue 'dispatch;
            }
            0x821E7888 => {
    //   block [0x821E7888..0x821E7898)
	// 821E7888: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E788C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 821E7890: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821E7894: 409AFFDC  bne cr6, 0x821e7870
	if !ctx.cr[6].eq {
	pc = 0x821E7870; continue 'dispatch;
	}
	pc = 0x821E7898; continue 'dispatch;
            }
            0x821E7898 => {
    //   block [0x821E7898..0x821E78A8)
	// 821E7898: 913D0008  stw r9, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 821E789C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E78A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E78A4: 48AC1BB8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821E78A8 => {
    //   block [0x821E78A8..0x821E78B8)
	// 821E78A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E78AC: 419A000C  beq cr6, 0x821e78b8
	if ctx.cr[6].eq {
	pc = 0x821E78B8; continue 'dispatch;
	}
	// 821E78B0: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 821E78B4: 48034485  bl 0x8221bd38
	ctx.lr = 0x821E78B8;
	sub_8221BD38(ctx, base);
	pc = 0x821E78B8; continue 'dispatch;
            }
            0x821E78B8 => {
    //   block [0x821E78B8..0x821E78E0)
	// 821E78B8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E78BC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E78C0: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821E78C4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821E78C8: 93DD0008  stw r30, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821E78CC: 93DD000C  stw r30, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821E78D0: 7D241E71  srawi. r4, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821E78D4: 4082000C  bne 0x821e78e0
	if !ctx.cr[0].eq {
	pc = 0x821E78E0; continue 'dispatch;
	}
	// 821E78D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E78DC: 4800000C  b 0x821e78e8
	pc = 0x821E78E8; continue 'dispatch;
            }
            0x821E78E0 => {
    //   block [0x821E78E0..0x821E78E8)
	// 821E78E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E78E4: 48370535  bl 0x82557e18
	ctx.lr = 0x821E78E8;
	sub_82557E18(ctx, base);
	pc = 0x821E78E8; continue 'dispatch;
            }
            0x821E78E8 => {
    //   block [0x821E78E8..0x821E7908)
	// 821E78E8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E78EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E78F0: 419A0044  beq cr6, 0x821e7934
	if ctx.cr[6].eq {
	pc = 0x821E7934; continue 'dispatch;
	}
	// 821E78F4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E78F8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E78FC: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7900: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821E7904: 419A002C  beq cr6, 0x821e7930
	if ctx.cr[6].eq {
	pc = 0x821E7930; continue 'dispatch;
	}
	pc = 0x821E7908; continue 'dispatch;
            }
            0x821E7908 => {
    //   block [0x821E7908..0x821E7920)
	// 821E7908: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E790C: 419A0014  beq cr6, 0x821e7920
	if ctx.cr[6].eq {
	pc = 0x821E7920; continue 'dispatch;
	}
	// 821E7910: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E7914: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E7918: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E791C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	pc = 0x821E7920; continue 'dispatch;
            }
            0x821E7920 => {
    //   block [0x821E7920..0x821E7930)
	// 821E7920: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E7924: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E7928: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821E792C: 409AFFDC  bne cr6, 0x821e7908
	if !ctx.cr[6].eq {
	pc = 0x821E7908; continue 'dispatch;
	}
	pc = 0x821E7930; continue 'dispatch;
            }
            0x821E7930 => {
    //   block [0x821E7930..0x821E7934)
	// 821E7930: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x821E7934; continue 'dispatch;
            }
            0x821E7934 => {
    //   block [0x821E7934..0x821E7940)
	// 821E7934: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E7938: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E793C: 48AC1B20  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E7940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E7940 size=324
    let mut pc: u32 = 0x821E7940;
    'dispatch: loop {
        match pc {
            0x821E7940 => {
    //   block [0x821E7940..0x821E79C0)
	// 821E7940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E7944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E7948: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821E794C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E7950: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E7954: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E7958: 3BFE0030  addi r31, r30, 0x30
	ctx.r[31].s64 = ctx.r[30].s64 + 48;
	// 821E795C: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E7960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E7964: 419A005C  beq cr6, 0x821e79c0
	if ctx.cr[6].eq {
	pc = 0x821E79C0; continue 'dispatch;
	}
	// 821E7968: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E796C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E7970: 419A0050  beq cr6, 0x821e79c0
	if ctx.cr[6].eq {
	pc = 0x821E79C0; continue 'dispatch;
	}
	// 821E7974: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E7978: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 821E797C: 388B0CA0  addi r4, r11, 0xca0
	ctx.r[4].s64 = ctx.r[11].s64 + 3232;
	// 821E7980: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E7984: 4804554D  bl 0x8222ced0
	ctx.lr = 0x821E7988;
	sub_8222CED0(ctx, base);
	// 821E7988: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E798C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E7990: 4807F819  bl 0x822671a8
	ctx.lr = 0x821E7994;
	sub_822671A8(ctx, base);
	// 821E7994: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821E7998: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821E799C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821E79A0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E79A4: 4BFF1C65  bl 0x821d9608
	ctx.lr = 0x821E79A8;
	sub_821D9608(ctx, base);
	// 821E79A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E79AC: 48A1E54D  bl 0x82c05ef8
	ctx.lr = 0x821E79B0;
	sub_82C05EF8(ctx, base);
	// 821E79B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E79B4: 480A2095  bl 0x82289a48
	ctx.lr = 0x821E79B8;
	sub_82289A48(ctx, base);
	// 821E79B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E79BC: 4802D41D  bl 0x82214dd8
	ctx.lr = 0x821E79C0;
	sub_82214DD8(ctx, base);
	pc = 0x821E79C0; continue 'dispatch;
            }
            0x821E79C0 => {
    //   block [0x821E79C0..0x821E79D8)
	// 821E79C0: 815E0038  lwz r10, 0x38(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 821E79C4: 3BFE0034  addi r31, r30, 0x34
	ctx.r[31].s64 = ctx.r[30].s64 + 52;
	// 821E79C8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821E79CC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821E79D0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E79D4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x821E79D8; continue 'dispatch;
            }
            0x821E79D8 => {
    //   block [0x821E79D8..0x821E79EC)
	// 821E79D8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E79DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E79E0: 419A000C  beq cr6, 0x821e79ec
	if ctx.cr[6].eq {
	pc = 0x821E79EC; continue 'dispatch;
	}
	// 821E79E4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821E79E8: 419A0008  beq cr6, 0x821e79f0
	if ctx.cr[6].eq {
	pc = 0x821E79F0; continue 'dispatch;
	}
	pc = 0x821E79EC; continue 'dispatch;
            }
            0x821E79EC => {
    //   block [0x821E79EC..0x821E79F0)
	// 821E79EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E79F0; continue 'dispatch;
            }
            0x821E79F0 => {
    //   block [0x821E79F0..0x821E7A04)
	// 821E79F0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E79F4: 419A0078  beq cr6, 0x821e7a6c
	if ctx.cr[6].eq {
	pc = 0x821E7A6C; continue 'dispatch;
	}
	// 821E79F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E79FC: 409A0008  bne cr6, 0x821e7a04
	if !ctx.cr[6].eq {
	pc = 0x821E7A04; continue 'dispatch;
	}
	// 821E7A00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E7A04; continue 'dispatch;
            }
            0x821E7A04 => {
    //   block [0x821E7A04..0x821E7A14)
	// 821E7A04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7A08: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E7A0C: 409A0008  bne cr6, 0x821e7a14
	if !ctx.cr[6].eq {
	pc = 0x821E7A14; continue 'dispatch;
	}
	// 821E7A10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E7A14; continue 'dispatch;
            }
            0x821E7A14 => {
    //   block [0x821E7A14..0x821E7A48)
	// 821E7A14: 807E002C  lwz r3, 0x2c(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E7A18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E7A1C: 419A002C  beq cr6, 0x821e7a48
	if ctx.cr[6].eq {
	pc = 0x821E7A48; continue 'dispatch;
	}
	// 821E7A20: 3889000C  addi r4, r9, 0xc
	ctx.r[4].s64 = ctx.r[9].s64 + 12;
	// 821E7A24: 488163A5  bl 0x829fddc8
	ctx.lr = 0x821E7A28;
	sub_829FDDC8(ctx, base);
	// 821E7A28: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E7A2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E7A30: 419A0018  beq cr6, 0x821e7a48
	if ctx.cr[6].eq {
	pc = 0x821E7A48; continue 'dispatch;
	}
	// 821E7A34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E7A38: 4836EE21  bl 0x82556858
	ctx.lr = 0x821E7A3C;
	sub_82556858(ctx, base);
	// 821E7A3C: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E7A40: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E7A44: 4BFFFF94  b 0x821e79d8
	pc = 0x821E79D8; continue 'dispatch;
            }
            0x821E7A48 => {
    //   block [0x821E7A48..0x821E7A6C)
	// 821E7A48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E7A4C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E7A50: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E7A54: 48133DC5  bl 0x8231b818
	ctx.lr = 0x821E7A58;
	sub_8231B818(ctx, base);
	// 821E7A58: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821E7A5C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821E7A60: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E7A64: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E7A68: 4BFFFF70  b 0x821e79d8
	pc = 0x821E79D8; continue 'dispatch;
            }
            0x821E7A6C => {
    //   block [0x821E7A6C..0x821E7A84)
	// 821E7A6C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821E7A70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E7A74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E7A78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E7A7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E7A80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E7A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E7A88 size=904
    let mut pc: u32 = 0x821E7A88;
    'dispatch: loop {
        match pc {
            0x821E7A88 => {
    //   block [0x821E7A88..0x821E7E08)
	// 821E7A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E7A8C: 48AC1955  bl 0x82ca93e0
	ctx.lr = 0x821E7A90;
	sub_82CA93D0(ctx, base);
	// 821E7A90: 9421FE60  stwu r1, -0x1a0(r1)
	ea = ctx.r[1].u32.wrapping_add(-416 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E7A94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E7A98: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821E7A9C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 821E7AA0: 897E0052  lbz r11, 0x52(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(82 as u32) ) } as u64;
	// 821E7AA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E7AA8: 419A0360  beq cr6, 0x821e7e08
	if ctx.cr[6].eq {
	pc = 0x821E7E08; continue 'dispatch;
	}
	// 821E7AAC: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821E7AB0: 839A003C  lwz r28, 0x3c(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(60 as u32) ) } as u64;
	// 821E7AB4: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821E7AB8: 3BEB2390  addi r31, r11, 0x2390
	ctx.r[31].s64 = ctx.r[11].s64 + 9104;
	// 821E7ABC: 3C60820A  lis r3, -0x7df6
	ctx.r[3].s64 = -2113273856;
	// 821E7AC0: 390A7E70  addi r8, r10, 0x7e70
	ctx.r[8].s64 = ctx.r[10].s64 + 32368;
	// 821E7AC4: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 821E7AC8: 833C0004  lwz r25, 4(r28)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7ACC: 831C0034  lwz r24, 0x34(r28)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) } as u64;
	// 821E7AD0: 38FF2008  addi r7, r31, 0x2008
	ctx.r[7].s64 = ctx.r[31].s64 + 8200;
	// 821E7AD4: 817F2004  lwz r11, 0x2004(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821E7AD8: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821E7ADC: C0039490  lfs f0, -0x6b70(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E7AE0: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 821E7AE4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E7AE8: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	pc = 0x821E7E08; continue 'dispatch;
            }
            0x821E7E08 => {
    //   block [0x821E7E08..0x821E7E10)
	// 821E7E08: 382101A0  addi r1, r1, 0x1a0
	ctx.r[1].s64 = ctx.r[1].s64 + 416;
	// 821E7E0C: 48AC1624  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E7E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E7E10 size=292
    let mut pc: u32 = 0x821E7E10;
    'dispatch: loop {
        match pc {
            0x821E7E10 => {
    //   block [0x821E7E10..0x821E7EC4)
	// 821E7E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E7E14: 48AC15E9  bl 0x82ca93fc
	ctx.lr = 0x821E7E18;
	sub_82CA93D0(ctx, base);
	// 821E7E18: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E7E1C: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 821E7E20: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821E7E24: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 821E7E28: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821E7E2C: 409A00AC  bne cr6, 0x821e7ed8
	if !ctx.cr[6].eq {
	pc = 0x821E7ED8; continue 'dispatch;
	}
	// 821E7E30: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E7E34: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821E7E38: 8343000C  lwz r26, 0xc(r3)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E7E3C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 821E7E40: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821E7E44: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821E7E48: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E7E4C: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821E7E50: 419A00DC  beq cr6, 0x821e7f2c
	if ctx.cr[6].eq {
	pc = 0x821E7F2C; continue 'dispatch;
	}
	// 821E7E54: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821E7E58: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E7E5C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 821E7E60: 3B800030  li r28, 0x30
	ctx.r[28].s64 = 48;
	// 821E7E64: 3BEB44B0  addi r31, r11, 0x44b0
	ctx.r[31].s64 = ctx.r[11].s64 + 17584;
	// 821E7E68: 3BCA1148  addi r30, r10, 0x1148
	ctx.r[30].s64 = ctx.r[10].s64 + 4424;
	// 821E7E6C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7E70: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7E74: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 821E7E78: 419A004C  beq cr6, 0x821e7ec4
	if ctx.cr[6].eq {
	pc = 0x821E7EC4; continue 'dispatch;
	}
	// 821E7E7C: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	pc = 0x821E7EC4; continue 'dispatch;
            }
            0x821E7EC4 => {
    //   block [0x821E7EC4..0x821E7ED8)
	// 821E7EC4: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 821E7EC8: 7F1DD040  cmplw cr6, r29, r26
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[26].u32, &mut ctx.xer);
	// 821E7ECC: 409AFFA0  bne cr6, 0x821e7e6c
	if !ctx.cr[6].eq {
	pc = 0x821E7E6C; continue 'dispatch;
	}
	// 821E7ED0: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821E7ED4: 48AC1578  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821E7ED8 => {
    //   block [0x821E7ED8..0x821E7F2C)
	// 821E7ED8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 821E7EDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E7EE0: 419A004C  beq cr6, 0x821e7f2c
	if ctx.cr[6].eq {
	pc = 0x821E7F2C; continue 'dispatch;
	}
	// 821E7EE4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7EE8: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 821E7EEC: 419A0040  beq cr6, 0x821e7f2c
	if ctx.cr[6].eq {
	pc = 0x821E7F2C; continue 'dispatch;
	}
	// 821E7EF0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E7EF4: 394100A0  addi r10, r1, 0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + 160;
	// 821E7EF8: 392B11A4  addi r9, r11, 0x11a4
	ctx.r[9].s64 = ctx.r[11].s64 + 4516;
	// 821E7EFC: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 821E7F00: 91210090  stw r9, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 821E7F04: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 821E7F08: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E7F0C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821E7F10: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 821E7F14: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821E7F18: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E7F1C: 4200FFF0  bdnz 0x821e7f0c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x821E7F0C; continue 'dispatch;
	}
	// 821E7F20: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 821E7F24: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 821E7F28: 48042BA1  bl 0x8222aac8
	ctx.lr = 0x821E7F2C;
	sub_8222AAC8(ctx, base);
	pc = 0x821E7F2C; continue 'dispatch;
            }
            0x821E7F2C => {
    //   block [0x821E7F2C..0x821E7F34)
	// 821E7F2C: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 821E7F30: 48AC151C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E7F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E7F58 size=284
    let mut pc: u32 = 0x821E7F58;
    'dispatch: loop {
        match pc {
            0x821E7F58 => {
    //   block [0x821E7F58..0x821E805C)
	// 821E7F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E7F5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E7F60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E7F64: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E7F68: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 821E7F6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E7F70: 214B0000  subfic r10, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[11].s64;
	// 821E7F74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E7F78: 7D2A5110  subfe r9, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821E7F7C: 552B077C  rlwinm r11, r9, 0, 0x1d, 0x1e
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821E7F80: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 821E7F84: 480000F5  bl 0x821e8078
	ctx.lr = 0x821E7F88;
	sub_821E8078(ctx, base);
	// 821E7F88: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E7F8C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E7F90: 419A00CC  beq cr6, 0x821e805c
	if ctx.cr[6].eq {
	pc = 0x821E805C; continue 'dispatch;
	}
	// 821E7F94: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E7F98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E7F9C: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821E7FA0: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E7FA4: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821E7FA8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E7FAC: 4E800421  bctrl
	ctx.lr = 0x821E7FB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E7FB0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E7FB4: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821E7FB8: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821E7FBC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 821E7FC0: 396B92D8  addi r11, r11, -0x6d28
	ctx.r[11].s64 = ctx.r[11].s64 + -27944;
            }
            0x821E805C => {
    //   block [0x821E805C..0x821E8074)
	// 821E805C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E8060: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E8064: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8068: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E806C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E8070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E8078 size=184
    let mut pc: u32 = 0x821E8078;
    'dispatch: loop {
        match pc {
            0x821E8078 => {
    //   block [0x821E8078..0x821E809C)
	// 821E8078: 54AB07BC  rlwinm r11, r5, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821E807C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821E8080: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8084: 419A0018  beq cr6, 0x821e809c
	if ctx.cr[6].eq {
	pc = 0x821E809C; continue 'dispatch;
	}
	// 821E8088: 816A00B4  lwz r11, 0xb4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(180 as u32) ) } as u64;
	// 821E808C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821E8090: 419A0034  beq cr6, 0x821e80c4
	if ctx.cr[6].eq {
	pc = 0x821E80C4; continue 'dispatch;
	}
	// 821E8094: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821E8098: 419A002C  beq cr6, 0x821e80c4
	if ctx.cr[6].eq {
	pc = 0x821E80C4; continue 'dispatch;
	}
	pc = 0x821E809C; continue 'dispatch;
            }
            0x821E809C => {
    //   block [0x821E809C..0x821E80C4)
	// 821E809C: 54AB077A  rlwinm r11, r5, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821E80A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E80A4: 419A0050  beq cr6, 0x821e80f4
	if ctx.cr[6].eq {
	pc = 0x821E80F4; continue 'dispatch;
	}
	// 821E80A8: 816A00B4  lwz r11, 0xb4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(180 as u32) ) } as u64;
	// 821E80AC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821E80B0: 419A0014  beq cr6, 0x821e80c4
	if ctx.cr[6].eq {
	pc = 0x821E80C4; continue 'dispatch;
	}
	// 821E80B4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821E80B8: 419A000C  beq cr6, 0x821e80c4
	if ctx.cr[6].eq {
	pc = 0x821E80C4; continue 'dispatch;
	}
	// 821E80BC: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821E80C0: 409A0034  bne cr6, 0x821e80f4
	if !ctx.cr[6].eq {
	pc = 0x821E80F4; continue 'dispatch;
	}
	pc = 0x821E80C4; continue 'dispatch;
            }
            0x821E80C4 => {
    //   block [0x821E80C4..0x821E80F4)
	// 821E80C4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E80C8: 39200210  li r9, 0x210
	ctx.r[9].s64 = 528;
	// 821E80CC: 390BA950  addi r8, r11, -0x56b0
	ctx.r[8].s64 = ctx.r[11].s64 + -22192;
	pc = 0x821E80F4; continue 'dispatch;
            }
            0x821E80F4 => {
    //   block [0x821E80F4..0x821E8130)
	// 821E80F4: 54AB073E  clrlwi r11, r5, 0x1c
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x0000000Fu64;
	// 821E80F8: 556B07F8  rlwinm r11, r11, 0, 0x1f, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E80FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8100: 419A008C  beq cr6, 0x821e818c
	if ctx.cr[6].eq {
		sub_821E818C(ctx, base);
		return;
	}
	// 821E8104: 816A00AC  lwz r11, 0xac(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(172 as u32) ) } as u64;
	// 821E8108: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821E810C: 409A0044  bne cr6, 0x821e8150
	if !ctx.cr[6].eq {
		sub_821E8150(ctx, base);
		return;
	}
	// 821E8110: 54AB07FE  clrlwi r11, r5, 0x1f
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x00000001u64;
	// 821E8114: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8118: 419A0018  beq cr6, 0x821e8130
	if ctx.cr[6].eq {
		sub_821E8130(ctx, base);
		return;
	}
	// 821E811C: 39600270  li r11, 0x270
	ctx.r[11].s64 = 624;
	// 821E8120: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E8130 size=32
    let mut pc: u32 = 0x821E8130;
    'dispatch: loop {
        match pc {
            0x821E8130 => {
    //   block [0x821E8130..0x821E8148)
	// 821E8130: 54AB0738  rlwinm r11, r5, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 821E8134: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8138: 419A0010  beq cr6, 0x821e8148
	if ctx.cr[6].eq {
	pc = 0x821E8148; continue 'dispatch;
	}
	// 821E813C: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	pc = 0x821E8148; continue 'dispatch;
            }
            0x821E8148 => {
    //   block [0x821E8148..0x821E8150)
	// 821E8148: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821E814C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E8150 size=60
    let mut pc: u32 = 0x821E8150;
    'dispatch: loop {
        match pc {
            0x821E8150 => {
    //   block [0x821E8150..0x821E8178)
	// 821E8150: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821E8154: 419A0024  beq cr6, 0x821e8178
	if ctx.cr[6].eq {
	pc = 0x821E8178; continue 'dispatch;
	}
	// 821E8158: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 821E815C: 419A001C  beq cr6, 0x821e8178
	if ctx.cr[6].eq {
	pc = 0x821E8178; continue 'dispatch;
	}
	// 821E8160: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821E8164: 419A0014  beq cr6, 0x821e8178
	if ctx.cr[6].eq {
	pc = 0x821E8178; continue 'dispatch;
	}
	// 821E8168: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821E816C: 419A000C  beq cr6, 0x821e8178
	if ctx.cr[6].eq {
	pc = 0x821E8178; continue 'dispatch;
	}
	// 821E8170: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821E8174: 409A0018  bne cr6, 0x821e818c
	if !ctx.cr[6].eq {
		sub_821E818C(ctx, base);
		return;
	}
	pc = 0x821E8178; continue 'dispatch;
            }
            0x821E8178 => {
    //   block [0x821E8178..0x821E818C)
	// 821E8178: 39600020  li r11, 0x20
	ctx.r[11].s64 = 32;
	// 821E817C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E818C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E818C size=8
    let mut pc: u32 = 0x821E818C;
    'dispatch: loop {
        match pc {
            0x821E818C => {
    //   block [0x821E818C..0x821E8194)
	// 821E818C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E8190: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E8198 size=432
    let mut pc: u32 = 0x821E8198;
    'dispatch: loop {
        match pc {
            0x821E8198 => {
    //   block [0x821E8198..0x821E8330)
	// 821E8198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E819C: 48AC1271  bl 0x82ca940c
	ctx.lr = 0x821E81A0;
	sub_82CA93D0(ctx, base);
	// 821E81A0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 821E81A4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821E81A8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E81AC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821E81B0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821E81B4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821E81B8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821E81BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E81C0: 4BFFFEB9  bl 0x821e8078
	ctx.lr = 0x821E81C4;
	sub_821E8078(ctx, base);
	// 821E81C4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E81C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E81CC: 419A0164  beq cr6, 0x821e8330
	if ctx.cr[6].eq {
	pc = 0x821E8330; continue 'dispatch;
	}
	// 821E81D0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E81D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E81D8: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821E81DC: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E81E0: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821E81E4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821E81E8: 4E800421  bctrl
	ctx.lr = 0x821E81EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E81EC: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821E81F0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821E81F4: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 821E81F8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821E81FC: 388690F0  addi r4, r6, -0x6f10
	ctx.r[4].s64 = ctx.r[6].s64 + -28432;
            }
            0x821E8330 => {
    //   block [0x821E8330..0x821E8348)
	// 821E8330: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E8334: C02BD5C8  lfs f1, -0x2a38(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10808 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821E8338: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821E833C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821E8340: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 821E8344: 48AC1118  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8348 size=300
    let mut pc: u32 = 0x821E8348;
    'dispatch: loop {
        match pc {
            0x821E8348 => {
    //   block [0x821E8348..0x821E838C)
	// 821E8348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E834C: 48AC10C1  bl 0x82ca940c
	ctx.lr = 0x821E8350;
	sub_82CA93D0(ctx, base);
	// 821E8350: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E8354: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821E8358: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E835C: 93A1009C  stw r29, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[29].u32 ) };
	// 821E8360: 38A1009C  addi r5, r1, 0x9c
	ctx.r[5].s64 = ctx.r[1].s64 + 156;
	// 821E8364: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	// 821E8368: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E836C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E8370: 48825589  bl 0x82a0d8f8
	ctx.lr = 0x821E8374;
	sub_82A0D8F8(ctx, base);
	// 821E8374: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E8378: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E837C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8380: 419A000C  beq cr6, 0x821e838c
	if ctx.cr[6].eq {
	pc = 0x821E838C; continue 'dispatch;
	}
	// 821E8384: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821E8388: 419A0008  beq cr6, 0x821e8390
	if ctx.cr[6].eq {
	pc = 0x821E8390; continue 'dispatch;
	}
	pc = 0x821E838C; continue 'dispatch;
            }
            0x821E838C => {
    //   block [0x821E838C..0x821E8390)
	// 821E838C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E8390; continue 'dispatch;
            }
            0x821E8390 => {
    //   block [0x821E8390..0x821E83AC)
	// 821E8390: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E8394: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E8398: 419A0014  beq cr6, 0x821e83ac
	if ctx.cr[6].eq {
	pc = 0x821E83AC; continue 'dispatch;
	}
	// 821E839C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E83A0: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E83A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E83A8: 48362B79  bl 0x8254af20
	ctx.lr = 0x821E83AC;
	sub_8254AF20(ctx, base);
	pc = 0x821E83AC; continue 'dispatch;
            }
            0x821E83AC => {
    //   block [0x821E83AC..0x821E83C4)
	// 821E83AC: 815E0248  lwz r10, 0x248(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(584 as u32) ) } as u64;
	// 821E83B0: 3BFE0244  addi r31, r30, 0x244
	ctx.r[31].s64 = ctx.r[30].s64 + 580;
	// 821E83B4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821E83B8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821E83BC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E83C0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821E83C4; continue 'dispatch;
            }
            0x821E83C4 => {
    //   block [0x821E83C4..0x821E83D8)
	// 821E83C4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E83C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E83CC: 419A000C  beq cr6, 0x821e83d8
	if ctx.cr[6].eq {
	pc = 0x821E83D8; continue 'dispatch;
	}
	// 821E83D0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821E83D4: 419A0008  beq cr6, 0x821e83dc
	if ctx.cr[6].eq {
	pc = 0x821E83DC; continue 'dispatch;
	}
	pc = 0x821E83D8; continue 'dispatch;
            }
            0x821E83D8 => {
    //   block [0x821E83D8..0x821E83DC)
	// 821E83D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E83DC; continue 'dispatch;
            }
            0x821E83DC => {
    //   block [0x821E83DC..0x821E83F0)
	// 821E83DC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821E83E0: 419A008C  beq cr6, 0x821e846c
	if ctx.cr[6].eq {
	pc = 0x821E846C; continue 'dispatch;
	}
	// 821E83E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E83E8: 409A0008  bne cr6, 0x821e83f0
	if !ctx.cr[6].eq {
	pc = 0x821E83F0; continue 'dispatch;
	}
	// 821E83EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E83F0; continue 'dispatch;
            }
            0x821E83F0 => {
    //   block [0x821E83F0..0x821E8400)
	// 821E83F0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E83F4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E83F8: 409A0008  bne cr6, 0x821e8400
	if !ctx.cr[6].eq {
	pc = 0x821E8400; continue 'dispatch;
	}
	// 821E83FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E8400; continue 'dispatch;
            }
            0x821E8400 => {
    //   block [0x821E8400..0x821E8440)
	// 821E8400: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E8404: 386A0010  addi r3, r10, 0x10
	ctx.r[3].s64 = ctx.r[10].s64 + 16;
	// 821E8408: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E840C: 419A0034  beq cr6, 0x821e8440
	if ctx.cr[6].eq {
	pc = 0x821E8440; continue 'dispatch;
	}
	// 821E8410: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8414: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E8418: 419A003C  beq cr6, 0x821e8454
	if ctx.cr[6].eq {
	pc = 0x821E8454; continue 'dispatch;
	}
	// 821E841C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E8420: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8424: 419A001C  beq cr6, 0x821e8440
	if ctx.cr[6].eq {
	pc = 0x821E8440; continue 'dispatch;
	}
	// 821E8428: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E842C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821E8430: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8434: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E8438: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E843C: 4E800421  bctrl
	ctx.lr = 0x821E8440;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821E8440 => {
    //   block [0x821E8440..0x821E8454)
	// 821E8440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E8444: 488B40D5  bl 0x82a9c518
	ctx.lr = 0x821E8448;
	sub_82A9C518(ctx, base);
	// 821E8448: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E844C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E8450: 4BFFFF74  b 0x821e83c4
	pc = 0x821E83C4; continue 'dispatch;
            }
            0x821E8454 => {
    //   block [0x821E8454..0x821E846C)
	// 821E8454: 4BFAB9E5  bl 0x82193e38
	ctx.lr = 0x821E8458;
	sub_82193E38(ctx, base);
	// 821E8458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E845C: 488B40BD  bl 0x82a9c518
	ctx.lr = 0x821E8460;
	sub_82A9C518(ctx, base);
	// 821E8460: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E8464: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E8468: 4BFFFF5C  b 0x821e83c4
	pc = 0x821E83C4; continue 'dispatch;
            }
            0x821E846C => {
    //   block [0x821E846C..0x821E8474)
	// 821E846C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E8470: 48AC0FEC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E8478 size=124
    let mut pc: u32 = 0x821E8478;
    'dispatch: loop {
        match pc {
            0x821E8478 => {
    //   block [0x821E8478..0x821E84D8)
	// 821E8478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E847C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E8480: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E8484: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821E8488: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E848C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E8490: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E8494: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E8498: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E849C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E84A0: 4099003C  ble cr6, 0x821e84dc
	if !ctx.cr[6].gt {
	pc = 0x821E84DC; continue 'dispatch;
	}
	// 821E84A4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E84A8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821E84AC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821E84B0: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 821E84B4: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E84B8: 480001C1  bl 0x821e8678
	ctx.lr = 0x821E84BC;
	sub_821E8678(ctx, base);
	// 821E84BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E84C0: 41820018  beq 0x821e84d8
	if ctx.cr[0].eq {
	pc = 0x821E84D8; continue 'dispatch;
	}
	// 821E84C4: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E84C8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E84CC: 4099000C  ble cr6, 0x821e84d8
	if !ctx.cr[6].gt {
	pc = 0x821E84D8; continue 'dispatch;
	}
	// 821E84D0: D01F01E8  stfs f0, 0x1e8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 821E84D4: 48000008  b 0x821e84dc
	pc = 0x821E84DC; continue 'dispatch;
            }
            0x821E84D8 => {
    //   block [0x821E84D8..0x821E84DC)
	// 821E84D8: D3FF01E8  stfs f31, 0x1e8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(488 as u32), tmp.u32 ) };
	pc = 0x821E84DC; continue 'dispatch;
            }
            0x821E84DC => {
    //   block [0x821E84DC..0x821E84F4)
	// 821E84DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E84E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E84E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E84E8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E84EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E84F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E84F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E84F8 size=124
    let mut pc: u32 = 0x821E84F8;
    'dispatch: loop {
        match pc {
            0x821E84F8 => {
    //   block [0x821E84F8..0x821E8558)
	// 821E84F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E84FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E8500: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E8504: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821E8508: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E850C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E8510: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E8514: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E8518: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E851C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E8520: 4099003C  ble cr6, 0x821e855c
	if !ctx.cr[6].gt {
	pc = 0x821E855C; continue 'dispatch;
	}
	// 821E8524: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E8528: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821E852C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821E8530: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 821E8534: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E8538: 48000141  bl 0x821e8678
	ctx.lr = 0x821E853C;
	sub_821E8678(ctx, base);
	// 821E853C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E8540: 41820018  beq 0x821e8558
	if ctx.cr[0].eq {
	pc = 0x821E8558; continue 'dispatch;
	}
	// 821E8544: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E8548: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E854C: 4099000C  ble cr6, 0x821e8558
	if !ctx.cr[6].gt {
	pc = 0x821E8558; continue 'dispatch;
	}
	// 821E8550: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 821E8554: 48000008  b 0x821e855c
	pc = 0x821E855C; continue 'dispatch;
            }
            0x821E8558 => {
    //   block [0x821E8558..0x821E855C)
	// 821E8558: D3FF00AC  stfs f31, 0xac(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	pc = 0x821E855C; continue 'dispatch;
            }
            0x821E855C => {
    //   block [0x821E855C..0x821E8574)
	// 821E855C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E8560: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8564: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8568: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E856C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E8570: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E8578 size=124
    let mut pc: u32 = 0x821E8578;
    'dispatch: loop {
        match pc {
            0x821E8578 => {
    //   block [0x821E8578..0x821E85D8)
	// 821E8578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E857C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E8580: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E8584: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821E8588: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E858C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E8590: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E8594: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E8598: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E859C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E85A0: 4099003C  ble cr6, 0x821e85dc
	if !ctx.cr[6].gt {
	pc = 0x821E85DC; continue 'dispatch;
	}
	// 821E85A4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E85A8: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821E85AC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821E85B0: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 821E85B4: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E85B8: 480000C1  bl 0x821e8678
	ctx.lr = 0x821E85BC;
	sub_821E8678(ctx, base);
	// 821E85BC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E85C0: 41820018  beq 0x821e85d8
	if ctx.cr[0].eq {
	pc = 0x821E85D8; continue 'dispatch;
	}
	// 821E85C4: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E85C8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E85CC: 4099000C  ble cr6, 0x821e85d8
	if !ctx.cr[6].gt {
	pc = 0x821E85D8; continue 'dispatch;
	}
	// 821E85D0: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 821E85D4: 48000008  b 0x821e85dc
	pc = 0x821E85DC; continue 'dispatch;
            }
            0x821E85D8 => {
    //   block [0x821E85D8..0x821E85DC)
	// 821E85D8: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	pc = 0x821E85DC; continue 'dispatch;
            }
            0x821E85DC => {
    //   block [0x821E85DC..0x821E85F4)
	// 821E85DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E85E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E85E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E85E8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E85EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E85F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E85F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E85F8 size=124
    let mut pc: u32 = 0x821E85F8;
    'dispatch: loop {
        match pc {
            0x821E85F8 => {
    //   block [0x821E85F8..0x821E8658)
	// 821E85F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E85FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E8600: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E8604: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821E8608: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E860C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E8610: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E8614: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E8618: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E861C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E8620: 4099003C  ble cr6, 0x821e865c
	if !ctx.cr[6].gt {
	pc = 0x821E865C; continue 'dispatch;
	}
	// 821E8624: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E8628: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821E862C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821E8630: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 821E8634: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E8638: 48000041  bl 0x821e8678
	ctx.lr = 0x821E863C;
	sub_821E8678(ctx, base);
	// 821E863C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E8640: 41820018  beq 0x821e8658
	if ctx.cr[0].eq {
	pc = 0x821E8658; continue 'dispatch;
	}
	// 821E8644: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E8648: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E864C: 4099000C  ble cr6, 0x821e8658
	if !ctx.cr[6].gt {
	pc = 0x821E8658; continue 'dispatch;
	}
	// 821E8650: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821E8654: 48000008  b 0x821e865c
	pc = 0x821E865C; continue 'dispatch;
            }
            0x821E8658 => {
    //   block [0x821E8658..0x821E865C)
	// 821E8658: D3FF0070  stfs f31, 0x70(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	pc = 0x821E865C; continue 'dispatch;
            }
            0x821E865C => {
    //   block [0x821E865C..0x821E8674)
	// 821E865C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E8660: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8664: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8668: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E866C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E8670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8678 size=204
    let mut pc: u32 = 0x821E8678;
    'dispatch: loop {
        match pc {
            0x821E8678 => {
    //   block [0x821E8678..0x821E86BC)
	// 821E8678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E867C: 48AC0D89  bl 0x82ca9404
	ctx.lr = 0x821E8680;
	sub_82CA93D0(ctx, base);
	// 821E8680: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E8684: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E8688: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 821E868C: 54AB063F  clrlwi. r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8690: 4182002C  beq 0x821e86bc
	if ctx.cr[0].eq {
	pc = 0x821E86BC; continue 'dispatch;
	}
	// 821E8694: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E8698: 2C0B0000  cmpwi r11, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 821E869C: 4180008C  blt 0x821e8728
	if ctx.cr[0].lt {
	pc = 0x821E8728; continue 'dispatch;
	}
	// 821E86A0: 815E005C  lwz r10, 0x5c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 821E86A4: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821E86A8: 40980080  bge cr6, 0x821e8728
	if !ctx.cr[6].lt {
	pc = 0x821E8728; continue 'dispatch;
	}
	// 821E86AC: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 821E86B0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E86B4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821E86B8: 48000074  b 0x821e872c
	pc = 0x821E872C; continue 'dispatch;
            }
            0x821E86BC => {
    //   block [0x821E86BC..0x821E86D0)
	// 821E86BC: 817E005C  lwz r11, 0x5c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 821E86C0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821E86C4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E86C8: 40990060  ble cr6, 0x821e8728
	if !ctx.cr[6].gt {
	pc = 0x821E8728; continue 'dispatch;
	}
	// 821E86CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x821E86D0; continue 'dispatch;
            }
            0x821E86D0 => {
    //   block [0x821E86D0..0x821E86F4)
	// 821E86D0: 817E0060  lwz r11, 0x60(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 821E86D4: 7FEBE82E  lwzx r31, r11, r29
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 821E86D8: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E86DC: 41820038  beq 0x821e8714
	if ctx.cr[0].eq {
	pc = 0x821E8714; continue 'dispatch;
	}
	// 821E86E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E86E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E86E8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E86EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821E86F0: 4E800421  bctrl
	ctx.lr = 0x821E86F4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821E86F4 => {
    //   block [0x821E86F4..0x821E870C)
	// 821E86F4: 7F1B1840  cmplw cr6, r27, r3
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821E86F8: 419A003C  beq cr6, 0x821e8734
	if ctx.cr[6].eq {
	pc = 0x821E8734; continue 'dispatch;
	}
	// 821E86FC: 8063010C  lwz r3, 0x10c(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(268 as u32) ) } as u64;
	// 821E8700: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E8704: 4082FFF0  bne 0x821e86f4
	if !ctx.cr[0].eq {
	pc = 0x821E86F4; continue 'dispatch;
	}
	// 821E8708: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821E870C; continue 'dispatch;
            }
            0x821E870C => {
    //   block [0x821E870C..0x821E8714)
	// 821E870C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8710: 4082002C  bne 0x821e873c
	if !ctx.cr[0].eq {
	pc = 0x821E873C; continue 'dispatch;
	}
	pc = 0x821E8714; continue 'dispatch;
            }
            0x821E8714 => {
    //   block [0x821E8714..0x821E8728)
	// 821E8714: 817E005C  lwz r11, 0x5c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(92 as u32) ) } as u64;
	// 821E8718: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 821E871C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 821E8720: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 821E8724: 4198FFAC  blt cr6, 0x821e86d0
	if ctx.cr[6].lt {
	pc = 0x821E86D0; continue 'dispatch;
	}
	pc = 0x821E8728; continue 'dispatch;
            }
            0x821E8728 => {
    //   block [0x821E8728..0x821E872C)
	// 821E8728: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821E872C; continue 'dispatch;
            }
            0x821E872C => {
    //   block [0x821E872C..0x821E8734)
	// 821E872C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E8730: 48AC0D24  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x821E8734 => {
    //   block [0x821E8734..0x821E873C)
	// 821E8734: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E8738: 4BFFFFD4  b 0x821e870c
	pc = 0x821E870C; continue 'dispatch;
            }
            0x821E873C => {
    //   block [0x821E873C..0x821E8744)
	// 821E873C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8740: 4BFFFFEC  b 0x821e872c
	pc = 0x821E872C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E8748 size=124
    let mut pc: u32 = 0x821E8748;
    'dispatch: loop {
        match pc {
            0x821E8748 => {
    //   block [0x821E8748..0x821E87A8)
	// 821E8748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E874C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E8750: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E8754: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821E8758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E875C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E8760: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821E8764: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E8768: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E876C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E8770: 4099003C  ble cr6, 0x821e87ac
	if !ctx.cr[6].gt {
	pc = 0x821E87AC; continue 'dispatch;
	}
	// 821E8774: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E8778: 3D608334  lis r11, -0x7ccc
	ctx.r[11].s64 = -2093744128;
	// 821E877C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821E8780: 388BC28C  addi r4, r11, -0x3d74
	ctx.r[4].s64 = ctx.r[11].s64 + -15732;
	// 821E8784: 806A0014  lwz r3, 0x14(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E8788: 4BFFFEF1  bl 0x821e8678
	ctx.lr = 0x821E878C;
	sub_821E8678(ctx, base);
	// 821E878C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E8790: 41820018  beq 0x821e87a8
	if ctx.cr[0].eq {
	pc = 0x821E87A8; continue 'dispatch;
	}
	// 821E8794: C0030004  lfs f0, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E8798: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 821E879C: 4099000C  ble cr6, 0x821e87a8
	if !ctx.cr[6].gt {
	pc = 0x821E87A8; continue 'dispatch;
	}
	// 821E87A0: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821E87A4: 48000008  b 0x821e87ac
	pc = 0x821E87AC; continue 'dispatch;
            }
            0x821E87A8 => {
    //   block [0x821E87A8..0x821E87AC)
	// 821E87A8: D3FF0088  stfs f31, 0x88(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	pc = 0x821E87AC; continue 'dispatch;
            }
            0x821E87AC => {
    //   block [0x821E87AC..0x821E87C4)
	// 821E87AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E87B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E87B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E87B8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E87BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E87C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E87C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E87C8 size=348
    let mut pc: u32 = 0x821E87C8;
    'dispatch: loop {
        match pc {
            0x821E87C8 => {
    //   block [0x821E87C8..0x821E8828)
	// 821E87C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E87CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E87D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E87D4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821E87D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E87DC: 83E30018  lwz r31, 0x18(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 821E87E0: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E87E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821E87E8: 419A0040  beq cr6, 0x821e8828
	if ctx.cr[6].eq {
	pc = 0x821E8828; continue 'dispatch;
	}
	// 821E87EC: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E87F0: 4BFFFF59  bl 0x821e8748
	ctx.lr = 0x821E87F4;
	sub_821E8748(ctx, base);
	// 821E87F4: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E87F8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E87FC: 4BFFFCFD  bl 0x821e84f8
	ctx.lr = 0x821E8800;
	sub_821E84F8(ctx, base);
	// 821E8800: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821E8804: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E8808: 4BFFFDF1  bl 0x821e85f8
	ctx.lr = 0x821E880C;
	sub_821E85F8(ctx, base);
	// 821E880C: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E8810: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E8814: 4BFFFD65  bl 0x821e8578
	ctx.lr = 0x821E8818;
	sub_821E8578(ctx, base);
	// 821E8818: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E881C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E8820: 4BFFFC59  bl 0x821e8478
	ctx.lr = 0x821E8824;
	sub_821E8478(ctx, base);
	// 821E8824: 480000E8  b 0x821e890c
	pc = 0x821E890C; continue 'dispatch;
            }
            0x821E8828 => {
    //   block [0x821E8828..0x821E8838)
	// 821E8828: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E882C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821E8830: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 821E8834: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	pc = 0x821E8838; continue 'dispatch;
            }
            0x821E8838 => {
    //   block [0x821E8838..0x821E8898)
	// 821E8838: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821E883C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E8840: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821E8844: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821E8848: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821E884C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821E8850: 4082FFE8  bne 0x821e8838
	if !ctx.cr[0].eq {
	pc = 0x821E8838; continue 'dispatch;
	}
	// 821E8854: 81630078  lwz r11, 0x78(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 821E8858: 3BE30074  addi r31, r3, 0x74
	ctx.r[31].s64 = ctx.r[3].s64 + 116;
	// 821E885C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8860: 419A0038  beq cr6, 0x821e8898
	if ctx.cr[6].eq {
	pc = 0x821E8898; continue 'dispatch;
	}
	// 821E8864: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8868: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E886C: 419A007C  beq cr6, 0x821e88e8
	if ctx.cr[6].eq {
	pc = 0x821E88E8; continue 'dispatch;
	}
	// 821E8870: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E8874: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8878: 419A0020  beq cr6, 0x821e8898
	if ctx.cr[6].eq {
	pc = 0x821E8898; continue 'dispatch;
	}
	// 821E887C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8880: 4BF8B5B9  bl 0x82173e38
	ctx.lr = 0x821E8884;
	sub_82173E38(ctx, base);
	// 821E8884: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821E8888: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E888C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E8890: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E8894: 409A0008  bne cr6, 0x821e889c
	if !ctx.cr[6].eq {
	pc = 0x821E889C; continue 'dispatch;
	}
	pc = 0x821E8898; continue 'dispatch;
            }
            0x821E8898 => {
    //   block [0x821E8898..0x821E889C)
	// 821E8898: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821E889C; continue 'dispatch;
            }
            0x821E889C => {
    //   block [0x821E889C..0x821E88E8)
	// 821E889C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E88A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E88A4: 419A0050  beq cr6, 0x821e88f4
	if ctx.cr[6].eq {
	pc = 0x821E88F4; continue 'dispatch;
	}
	// 821E88A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E88AC: 4BF8B58D  bl 0x82173e38
	ctx.lr = 0x821E88B0;
	sub_82173E38(ctx, base);
	// 821E88B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821E88B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E88B8: 388B0080  addi r4, r11, 0x80
	ctx.r[4].s64 = ctx.r[11].s64 + 128;
	// 821E88BC: 48007985  bl 0x821f0240
	ctx.lr = 0x821E88C0;
	sub_821F0240(ctx, base);
	// 821E88C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821E88C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E88C8: 388B8544  addi r4, r11, -0x7abc
	ctx.r[4].s64 = ctx.r[11].s64 + -31420;
	// 821E88CC: 4BFF20F5  bl 0x821da9c0
	ctx.lr = 0x821E88D0;
	sub_821DA9C0(ctx, base);
	// 821E88D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E88D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821E88D8: 4807C8C9  bl 0x822651a0
	ctx.lr = 0x821E88DC;
	sub_822651A0(ctx, base);
	// 821E88DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E88E0: 4802C4F9  bl 0x82214dd8
	ctx.lr = 0x821E88E4;
	sub_82214DD8(ctx, base);
	// 821E88E4: 48000020  b 0x821e8904
	pc = 0x821E8904; continue 'dispatch;
            }
            0x821E88E8 => {
    //   block [0x821E88E8..0x821E88F4)
	// 821E88E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E88EC: 4BFAB54D  bl 0x82193e38
	ctx.lr = 0x821E88F0;
	sub_82193E38(ctx, base);
	// 821E88F0: 4BFFFFA8  b 0x821e8898
	pc = 0x821E8898; continue 'dispatch;
            }
            0x821E88F4 => {
    //   block [0x821E88F4..0x821E8904)
	// 821E88F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821E88F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821E88FC: 388B8554  addi r4, r11, -0x7aac
	ctx.r[4].s64 = ctx.r[11].s64 + -31404;
	// 821E8900: 4808CB39  bl 0x82275438
	ctx.lr = 0x821E8904;
	sub_82275438(ctx, base);
	pc = 0x821E8904; continue 'dispatch;
            }
            0x821E8904 => {
    //   block [0x821E8904..0x821E890C)
	// 821E8904: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 821E8908: 4802C4D1  bl 0x82214dd8
	ctx.lr = 0x821E890C;
	sub_82214DD8(ctx, base);
	pc = 0x821E890C; continue 'dispatch;
            }
            0x821E890C => {
    //   block [0x821E890C..0x821E8924)
	// 821E890C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E8910: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8914: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8918: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E891C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E8920: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8928 size=88
    let mut pc: u32 = 0x821E8928;
    'dispatch: loop {
        match pc {
            0x821E8928 => {
    //   block [0x821E8928..0x821E8964)
	// 821E8928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E892C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E8930: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E8934: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E8938: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E893C: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E8940: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E8944: 40820020  bne 0x821e8964
	if !ctx.cr[0].eq {
	pc = 0x821E8964; continue 'dispatch;
	}
	// 821E8948: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E894C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E8950: 41820014  beq 0x821e8964
	if ctx.cr[0].eq {
	pc = 0x821E8964; continue 'dispatch;
	}
	// 821E8954: 809F0030  lwz r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E8958: 28040000  cmplwi r4, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 821E895C: 41820008  beq 0x821e8964
	if ctx.cr[0].eq {
	pc = 0x821E8964; continue 'dispatch;
	}
	// 821E8960: 48CA4C51  bl 0x82e8d5b0
	ctx.lr = 0x821E8964;
	sub_82E8D5B0(ctx, base);
	pc = 0x821E8964; continue 'dispatch;
            }
            0x821E8964 => {
    //   block [0x821E8964..0x821E8980)
	// 821E8964: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E8968: 997F002C  stb r11, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u8 ) };
	// 821E896C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E8970: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8974: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8978: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E897C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8980 size=524
    let mut pc: u32 = 0x821E8980;
    'dispatch: loop {
        match pc {
            0x821E8980 => {
    //   block [0x821E8980..0x821E89C8)
	// 821E8980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E8984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E8988: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E898C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E8990: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E8994: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E8998: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E899C: 419A01D4  beq cr6, 0x821e8b70
	if ctx.cr[6].eq {
	pc = 0x821E8B70; continue 'dispatch;
	}
	// 821E89A0: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821E89A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E89A8: 40990020  ble cr6, 0x821e89c8
	if !ctx.cr[6].gt {
	pc = 0x821E89C8; continue 'dispatch;
	}
	// 821E89AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E89B0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E89B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E89B8: 4E800421  bctrl
	ctx.lr = 0x821E89BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E89BC: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821E89C0: 7D034850  subf r8, r3, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 821E89C4: 911F0018  stw r8, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
            }
            0x821E89C8 => {
    //   block [0x821E89C8..0x821E8A18)
	// 821E89C8: 897F001C  lbz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821E89CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E89D0: 419A016C  beq cr6, 0x821e8b3c
	if ctx.cr[6].eq {
	pc = 0x821E8B3C; continue 'dispatch;
	}
	// 821E89D4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E89D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821E89DC: 812B0034  lwz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821E89E0: 5528CFFE  rlwinm r8, r9, 0x19, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000007Fu64;
	// 821E89E4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E89E8: 419A00F8  beq cr6, 0x821e8ae0
	if ctx.cr[6].eq {
	pc = 0x821E8AE0; continue 'dispatch;
	}
	// 821E89EC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E89F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E89F4: 419A0024  beq cr6, 0x821e8a18
	if ctx.cr[6].eq {
	pc = 0x821E8A18; continue 'dispatch;
	}
	// 821E89F8: 894A0087  lbz r10, 0x87(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(135 as u32) ) } as u64;
	// 821E89FC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E8A00: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821E8A04: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E8A08: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E8A0C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821E8A10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E8A14: 480000D0  b 0x821e8ae4
	pc = 0x821E8AE4; continue 'dispatch;
            }
            0x821E8A18 => {
    //   block [0x821E8A18..0x821E8A38)
	// 821E8A18: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E8A1C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821E8A20: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E8A24: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 821E8A28: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E8A2C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E8A30: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8A34: 40810054  ble 0x821e8a88
	if !ctx.cr[0].gt {
	pc = 0x821E8A88; continue 'dispatch;
	}
	pc = 0x821E8A38; continue 'dispatch;
            }
            0x821E8A38 => {
    //   block [0x821E8A38..0x821E8A58)
	// 821E8A38: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E8A3C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E8A40: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E8A44: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8A48: 2F070087  cmpwi cr6, r7, 0x87
	ctx.cr[6].compare_i32(ctx.r[7].s32, 135, &mut ctx.xer);
	// 821E8A4C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E8A50: 41980008  blt cr6, 0x821e8a58
	if ctx.cr[6].lt {
	pc = 0x821E8A58; continue 'dispatch;
	}
	// 821E8A54: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x821E8A58; continue 'dispatch;
            }
            0x821E8A58 => {
    //   block [0x821E8A58..0x821E8A74)
	// 821E8A58: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E8A5C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E8A60: 419A0014  beq cr6, 0x821e8a74
	if ctx.cr[6].eq {
	pc = 0x821E8A74; continue 'dispatch;
	}
	// 821E8A64: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E8A68: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E8A6C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E8A70: 4800000C  b 0x821e8a7c
	pc = 0x821E8A7C; continue 'dispatch;
            }
            0x821E8A74 => {
    //   block [0x821E8A74..0x821E8A7C)
	// 821E8A74: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E8A78: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821E8A7C; continue 'dispatch;
            }
            0x821E8A7C => {
    //   block [0x821E8A7C..0x821E8A88)
	// 821E8A7C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8A80: 4199FFB8  bgt cr6, 0x821e8a38
	if ctx.cr[6].gt {
	pc = 0x821E8A38; continue 'dispatch;
	}
	// 821E8A84: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821E8A88; continue 'dispatch;
            }
            0x821E8A88 => {
    //   block [0x821E8A88..0x821E8AA4)
	// 821E8A88: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E8A8C: 419A0040  beq cr6, 0x821e8acc
	if ctx.cr[6].eq {
	pc = 0x821E8ACC; continue 'dispatch;
	}
	// 821E8A90: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8A94: 2F0B0087  cmpwi cr6, r11, 0x87
	ctx.cr[6].compare_i32(ctx.r[11].s32, 135, &mut ctx.xer);
	// 821E8A98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E8A9C: 41990008  bgt cr6, 0x821e8aa4
	if ctx.cr[6].gt {
	pc = 0x821E8AA4; continue 'dispatch;
	}
	// 821E8AA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821E8AA4; continue 'dispatch;
            }
            0x821E8AA4 => {
    //   block [0x821E8AA4..0x821E8ACC)
	// 821E8AA4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E8AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8AAC: 409A0020  bne cr6, 0x821e8acc
	if !ctx.cr[6].eq {
	pc = 0x821E8ACC; continue 'dispatch;
	}
	// 821E8AB0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E8AB4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821E8AB8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E8ABC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E8AC0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821E8AC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E8AC8: 4800001C  b 0x821e8ae4
	pc = 0x821E8AE4; continue 'dispatch;
            }
            0x821E8ACC => {
    //   block [0x821E8ACC..0x821E8AE0)
	// 821E8ACC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E8AD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E8AD4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 821E8AD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E8ADC: 48000008  b 0x821e8ae4
	pc = 0x821E8AE4; continue 'dispatch;
            }
            0x821E8AE0 => {
    //   block [0x821E8AE0..0x821E8AE4)
	// 821E8AE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821E8AE4; continue 'dispatch;
            }
            0x821E8AE4 => {
    //   block [0x821E8AE4..0x821E8B0C)
	// 821E8AE4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E8AE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8AEC: 419A008C  beq cr6, 0x821e8b78
	if ctx.cr[6].eq {
	pc = 0x821E8B78; continue 'dispatch;
	}
	// 821E8AF0: 806A002C  lwz r3, 0x2c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E8AF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E8AF8: 419A0014  beq cr6, 0x821e8b0c
	if ctx.cr[6].eq {
	pc = 0x821E8B0C; continue 'dispatch;
	}
	// 821E8AFC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821E8B00: 388B8A34  addi r4, r11, -0x75cc
	ctx.r[4].s64 = ctx.r[11].s64 + -30156;
	// 821E8B04: 488152C5  bl 0x829fddc8
	ctx.lr = 0x821E8B08;
	sub_829FDDC8(ctx, base);
	// 821E8B08: 48000008  b 0x821e8b10
	pc = 0x821E8B10; continue 'dispatch;
            }
            0x821E8B0C => {
    //   block [0x821E8B0C..0x821E8B10)
	// 821E8B0C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821E8B10; continue 'dispatch;
            }
            0x821E8B10 => {
    //   block [0x821E8B10..0x821E8B3C)
	// 821E8B10: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E8B14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8B18: 409A0060  bne cr6, 0x821e8b78
	if !ctx.cr[6].eq {
	pc = 0x821E8B78; continue 'dispatch;
	}
	// 821E8B1C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821E8B20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8B24: 483F071D  bl 0x825d9240
	ctx.lr = 0x821E8B28;
	sub_825D9240(ctx, base);
	// 821E8B28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E8B2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8B30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8B34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E8B38: 4E800020  blr
	return;
            }
            0x821E8B3C => {
    //   block [0x821E8B3C..0x821E8B70)
	// 821E8B3C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821E8B40: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821E8B44: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 821E8B48: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821E8B4C: 4099002C  ble cr6, 0x821e8b78
	if !ctx.cr[6].gt {
	pc = 0x821E8B78; continue 'dispatch;
	}
	// 821E8B50: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821E8B54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8B58: 483F06E9  bl 0x825d9240
	ctx.lr = 0x821E8B5C;
	sub_825D9240(ctx, base);
	// 821E8B5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E8B60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8B64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8B68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E8B6C: 4E800020  blr
	return;
            }
            0x821E8B70 => {
    //   block [0x821E8B70..0x821E8B78)
	// 821E8B70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E8B74: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	pc = 0x821E8B78; continue 'dispatch;
            }
            0x821E8B78 => {
    //   block [0x821E8B78..0x821E8B8C)
	// 821E8B78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E8B7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8B80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8B84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E8B88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8B90 size=116
    let mut pc: u32 = 0x821E8B90;
    'dispatch: loop {
        match pc {
            0x821E8B90 => {
    //   block [0x821E8B90..0x821E8BF8)
	// 821E8B90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E8B94: 48AC0879  bl 0x82ca940c
	ctx.lr = 0x821E8B98;
	sub_82CA93D0(ctx, base);
	// 821E8B98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E8B9C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E8BA0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821E8BA4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821E8BA8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821E8BAC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E8BB0: 806A0080  lwz r3, 0x80(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 821E8BB4: 4808C32D  bl 0x82274ee0
	ctx.lr = 0x821E8BB8;
	sub_82274EE0(ctx, base);
	// 821E8BB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E8BBC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821E8BC0: 419A0038  beq cr6, 0x821e8bf8
	if ctx.cr[6].eq {
	pc = 0x821E8BF8; continue 'dispatch;
	}
	// 821E8BC4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8BC8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E8BCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E8BD0: 4E800421  bctrl
	ctx.lr = 0x821E8BD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E8BD4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821E8BD8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821E8BDC: 419A001C  beq cr6, 0x821e8bf8
	if ctx.cr[6].eq {
	pc = 0x821E8BF8; continue 'dispatch;
	}
	// 821E8BE0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 821E8BE4: 809E0024  lwz r4, 0x24(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 821E8BE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8BEC: 4BFF48E5  bl 0x821dd4d0
	ctx.lr = 0x821E8BF0;
	sub_821DD4D0(ctx, base);
	// 821E8BF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E8BF4: 48AC0868  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821E8BF8 => {
    //   block [0x821E8BF8..0x821E8C04)
	// 821E8BF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E8BFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E8C00: 48AC085C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8C08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8C08 size=112
    let mut pc: u32 = 0x821E8C08;
    'dispatch: loop {
        match pc {
            0x821E8C08 => {
    //   block [0x821E8C08..0x821E8C24)
	// 821E8C08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E8C0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E8C10: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E8C14: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821E8C18: 488929D1  bl 0x82a7b5e8
	ctx.lr = 0x821E8C1C;
	sub_82A7B5E8(ctx, base);
	// 821E8C1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E8C20: 409A0018  bne cr6, 0x821e8c38
	if !ctx.cr[6].eq {
	pc = 0x821E8C38; continue 'dispatch;
	}
	pc = 0x821E8C24; continue 'dispatch;
            }
            0x821E8C24 => {
    //   block [0x821E8C24..0x821E8C38)
	// 821E8C24: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821E8C28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E8C2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8C30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8C34: 4E800020  blr
	return;
            }
            0x821E8C38 => {
    //   block [0x821E8C38..0x821E8C64)
	// 821E8C38: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8C3C: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821E8C40: 409AFFE4  bne cr6, 0x821e8c24
	if !ctx.cr[6].eq {
	pc = 0x821E8C24; continue 'dispatch;
	}
	// 821E8C44: 81680010  lwz r11, 0x10(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E8C48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8C4C: 419A0018  beq cr6, 0x821e8c64
	if ctx.cr[6].eq {
	pc = 0x821E8C64; continue 'dispatch;
	}
	// 821E8C50: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8C54: 91680010  stw r11, 0x10(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821E8C58: 4082000C  bne 0x821e8c64
	if !ctx.cr[0].eq {
	pc = 0x821E8C64; continue 'dispatch;
	}
	// 821E8C5C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821E8C60: 9168000C  stw r11, 0xc(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	pc = 0x821E8C64; continue 'dispatch;
            }
            0x821E8C64 => {
    //   block [0x821E8C64..0x821E8C78)
	// 821E8C64: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821E8C68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821E8C6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8C70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8C74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8C78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821E8C78 size=192
    let mut pc: u32 = 0x821E8C78;
    'dispatch: loop {
        match pc {
            0x821E8C78 => {
    //   block [0x821E8C78..0x821E8D38)
	// 821E8C78: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 821E8C7C: 546B083C  slwi r11, r3, 1
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E8C80: 390ADED4  addi r8, r10, -0x212c
	ctx.r[8].s64 = ctx.r[10].s64 + -8492;
	// 821E8C84: 7CE35A14  add r7, r3, r11
	ctx.r[7].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 821E8C88: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821E8C8C: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821E8C90: 396BED14  addi r11, r11, -0x12ec
	ctx.r[11].s64 = ctx.r[11].s64 + -4844;
	// 821E8C94: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E8C98: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821E8C9C: D02B0000  stfs f1, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821E8CA0: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E8CA4: 2F060001  cmpwi cr6, r6, 1
	ctx.cr[6].compare_i32(ctx.r[6].s32, 1, &mut ctx.xer);
	// 821E8CA8: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8CAC: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 821E8CB0: 7D491670  srawi r9, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 821E8CB4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 821E8CB8: 7CC90194  addze r6, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[6].s64 = tmp.s64;
	// 821E8CBC: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821E8CC0: 7909FFE6  rldicr r9, r8, 0x3f, 0x3f
	ctx.r[9].u64 = (ctx.r[8].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821E8CC4: 7CC507B4  extsw r5, r6
	ctx.r[5].s64 = ctx.r[6].s32 as i64;
	// 821E8CC8: 7D242C36  srd r4, r9, r5
	if (ctx.r[5].u8 & 0x40) != 0 {
		ctx.r[4].u64 = 0;
	} else {
		ctx.r[4].u64 = (ctx.r[9].u64) >> ((ctx.r[5].u8 & 0x3F) as u32);
	}
	// 821E8CCC: E9071758  ld r8, 0x1758(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(5976 as u32) ) };
	// 821E8CD0: 7C834038  and r3, r4, r8
	ctx.r[3].u64 = ctx.r[4].u64 & ctx.r[8].u64;
	// 821E8CD4: 2B230000  cmpldi cr6, r3, 0
	ctx.cr[6].compare_u64(ctx.r[3].u64, 0, &mut ctx.xer);
	// 821E8CD8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 821E8CDC: 3CE08336  lis r7, -0x7cca
	ctx.r[7].s64 = -2093613056;
	// 821E8CE0: 38CA0178  addi r6, r10, 0x178
	ctx.r[6].s64 = ctx.r[10].s64 + 376;
	// 821E8CE4: 5545F0BE  srwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821E8CE8: 55482036  slwi r8, r10, 4
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E8CEC: 54C42036  slwi r4, r6, 4
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(4);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821E8CF0: 81470364  lwz r10, 0x364(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(868 as u32) ) } as u64;
	// 821E8CF4: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 821E8CF8: 7CE52850  subf r7, r5, r5
	ctx.r[7].s64 = ctx.r[5].s64 - ctx.r[5].s64;
	// 821E8CFC: 7D285214  add r9, r8, r10
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E8D00: 78E60020  clrldi r6, r7, 0x20
	ctx.r[6].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 821E8D04: 7C24552E  stfsx f1, r4, r10
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 821E8D08: 7C643634  srad r4, r3, r6
	tmp.u64 = (ctx.r[6].u64 & 0x7F) as u64;
	if tmp.u64 > 0x3F { tmp.u64 = 0x3F; }
	ctx.xer.ca = (ctx.r[3].s64 < 0) && ((ctx.r[3].u64 & ((1u64 << tmp.u64) - 1)) != 0);
	ctx.r[4].s64 = ctx.r[3].s64 >> tmp.u64;
	// 821E8D0C: 7C832C36  srd r3, r4, r5
	if (ctx.r[5].u8 & 0x40) != 0 {
		ctx.r[3].u64 = 0;
	} else {
		ctx.r[3].u64 = (ctx.r[4].u64) >> ((ctx.r[5].u8 & 0x3F) as u32);
	}
	// 821E8D10: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E8D14: D0091784  stfs f0, 0x1784(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(6020 as u32), tmp.u32 ) };
	// 821E8D18: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E8D1C: D0091788  stfs f0, 0x1788(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(6024 as u32), tmp.u32 ) };
	// 821E8D20: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E8D24: D009178C  stfs f0, 0x178c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(6028 as u32), tmp.u32 ) };
	// 821E8D28: E96A0008  ld r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821E8D2C: 7C695B78  or r9, r3, r11
	ctx.r[9].u64 = ctx.r[3].u64 | ctx.r[11].u64;
	// 821E8D30: F92A0008  std r9, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 821E8D34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8D38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8D38 size=388
    let mut pc: u32 = 0x821E8D38;
    'dispatch: loop {
        match pc {
            0x821E8D38 => {
    //   block [0x821E8D38..0x821E8DA8)
	// 821E8D38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E8D3C: 48AC06CD  bl 0x82ca9408
	ctx.lr = 0x821E8D40;
	sub_82CA93D0(ctx, base);
	// 821E8D40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E8D44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E8D48: 895F2ABD  lbz r10, 0x2abd(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10941 as u32) ) } as u64;
	// 821E8D4C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E8D50: 83DF3A50  lwz r30, 0x3a50(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(14928 as u32) ) } as u64;
	// 821E8D54: 554A06B5  rlwinm. r10, r10, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821E8D58: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 821E8D5C: 4082011C  bne 0x821e8e78
	if !ctx.cr[0].eq {
	pc = 0x821E8E78; continue 'dispatch;
	}
	// 821E8D60: 897F2ABC  lbz r11, 0x2abc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821E8D64: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8D68: 4182006C  beq 0x821e8dd4
	if ctx.cr[0].eq {
	pc = 0x821E8DD4; continue 'dispatch;
	}
	// 821E8D6C: 817F34CC  lwz r11, 0x34cc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13516 as u32) ) } as u64;
	// 821E8D70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8D74: 419A0104  beq cr6, 0x821e8e78
	if ctx.cr[6].eq {
	pc = 0x821E8E78; continue 'dispatch;
	}
	// 821E8D78: 816B0098  lwz r11, 0x98(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) } as u64;
	// 821E8D7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8D80: 409A00F8  bne cr6, 0x821e8e78
	if !ctx.cr[6].eq {
	pc = 0x821E8E78; continue 'dispatch;
	}
	// 821E8D84: 7D7EE050  subf r11, r30, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	// 821E8D88: 7D7D1671  srawi. r29, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821E8D8C: 418200EC  beq 0x821e8e78
	if ctx.cr[0].eq {
	pc = 0x821E8E78; continue 'dispatch;
	}
	// 821E8D90: 817F34E4  lwz r11, 0x34e4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13540 as u32) ) } as u64;
	// 821E8D94: 807F34E0  lwz r3, 0x34e0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13536 as u32) ) } as u64;
	// 821E8D98: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E8D9C: 4198000C  blt cr6, 0x821e8da8
	if ctx.cr[6].lt {
	pc = 0x821E8DA8; continue 'dispatch;
	}
	// 821E8DA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8DA4: 489B8DD5  bl 0x82ba1b78
	ctx.lr = 0x821E8DA8;
	sub_82BA1B78(ctx, base);
	pc = 0x821E8DA8; continue 'dispatch;
            }
            0x821E8DA8 => {
    //   block [0x821E8DA8..0x821E8DD4)
	// 821E8DA8: 57CB653E  srwi r11, r30, 0x14
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shr(20);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E8DAC: 57CA00FE  clrlwi r10, r30, 3
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x1FFFFFFFu64;
	// 821E8DB0: 396B0200  addi r11, r11, 0x200
	ctx.r[11].s64 = ctx.r[11].s64 + 512;
	// 821E8DB4: 67A98100  oris r9, r29, 0x8100
	ctx.r[9].u64 = ctx.r[29].u64 | 2164260864;
	// 821E8DB8: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E8DBC: 39030008  addi r8, r3, 8
	ctx.r[8].s64 = ctx.r[3].s64 + 8;
	// 821E8DC0: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821E8DC4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E8DC8: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821E8DCC: 911F34E0  stw r8, 0x34e0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13536 as u32), ctx.r[8].u32 ) };
	// 821E8DD0: 480000A8  b 0x821e8e78
	pc = 0x821E8E78; continue 'dispatch;
            }
            0x821E8DD4 => {
    //   block [0x821E8DD4..0x821E8E20)
	// 821E8DD4: 817F33B0  lwz r11, 0x33b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13232 as u32) ) } as u64;
	// 821E8DD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8DDC: 419A005C  beq cr6, 0x821e8e38
	if ctx.cr[6].eq {
	pc = 0x821E8E38; continue 'dispatch;
	}
	// 821E8DE0: 57CB653E  srwi r11, r30, 0x14
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shr(20);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E8DE4: 57CA00FE  clrlwi r10, r30, 3
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x1FFFFFFFu64;
	// 821E8DE8: 396B0200  addi r11, r11, 0x200
	ctx.r[11].s64 = ctx.r[11].s64 + 512;
	// 821E8DEC: 7D3EE050  subf r9, r30, r28
	ctx.r[9].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	// 821E8DF0: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E8DF4: 7D3E1671  srawi. r30, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821E8DF8: 7FAB5214  add r29, r11, r10
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E8DFC: 4182007C  beq 0x821e8e78
	if ctx.cr[0].eq {
	pc = 0x821E8E78; continue 'dispatch;
	}
	// 821E8E00: 817F3440  lwz r11, 0x3440(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13376 as u32) ) } as u64;
	// 821E8E04: 387F3438  addi r3, r31, 0x3438
	ctx.r[3].s64 = ctx.r[31].s64 + 13368;
	// 821E8E08: 815F3444  lwz r10, 0x3444(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13380 as u32) ) } as u64;
	// 821E8E0C: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 821E8E10: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E8E14: 4099000C  ble cr6, 0x821e8e20
	if !ctx.cr[6].gt {
	pc = 0x821E8E20; continue 'dispatch;
	}
	// 821E8E18: 4BFE8799  bl 0x821d15b0
	ctx.lr = 0x821E8E1C;
	sub_821D15B0(ctx, base);
	// 821E8E1C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x821E8E20; continue 'dispatch;
            }
            0x821E8E20 => {
    //   block [0x821E8E20..0x821E8E38)
	// 821E8E20: 67CA8100  oris r10, r30, 0x8100
	ctx.r[10].u64 = ctx.r[30].u64 | 2164260864;
	// 821E8E24: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 821E8E28: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 821E8E2C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821E8E30: 913F3440  stw r9, 0x3440(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(13376 as u32), ctx.r[9].u32 ) };
	// 821E8E34: 48000044  b 0x821e8e78
	pc = 0x821E8E78; continue 'dispatch;
            }
            0x821E8E38 => {
    //   block [0x821E8E38..0x821E8E78)
	// 821E8E38: 389CFFFC  addi r4, r28, -4
	ctx.r[4].s64 = ctx.r[28].s64 + -4;
	// 821E8E3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8E40: 480AF7F1  bl 0x82298630
	ctx.lr = 0x821E8E44;
	sub_82298630(ctx, base);
	// 821E8E44: 57CB653E  srwi r11, r30, 0x14
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shr(20);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821E8E48: 38830004  addi r4, r3, 4
	ctx.r[4].s64 = ctx.r[3].s64 + 4;
	// 821E8E4C: 396B0200  addi r11, r11, 0x200
	ctx.r[11].s64 = ctx.r[11].s64 + 512;
	// 821E8E50: 7D3E2050  subf r9, r30, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 821E8E54: 556B04E6  rlwinm r11, r11, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E8E58: 57CA00FE  clrlwi r10, r30, 3
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x1FFFFFFFu64;
	// 821E8E5C: 391F3438  addi r8, r31, 0x3438
	ctx.r[8].s64 = ctx.r[31].s64 + 13368;
	// 821E8E60: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821E8E64: 7D261670  srawi r6, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 821E8E68: 7CAB5214  add r5, r11, r10
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821E8E6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8E70: 4809DA59  bl 0x822868c8
	ctx.lr = 0x821E8E74;
	sub_822868C8(ctx, base);
	// 821E8E74: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	pc = 0x821E8E78; continue 'dispatch;
            }
            0x821E8E78 => {
    //   block [0x821E8E78..0x821E8EA4)
	// 821E8E78: 397C001F  addi r11, r28, 0x1f
	ctx.r[11].s64 = ctx.r[28].s64 + 31;
	// 821E8E7C: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821E8E80: 55690034  rlwinm r9, r11, 0, 0, 0x1a
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E8E84: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E8E88: 4099001C  ble cr6, 0x821e8ea4
	if !ctx.cr[6].gt {
	pc = 0x821E8EA4; continue 'dispatch;
	}
	// 821E8E8C: 397CFFFC  addi r11, r28, -4
	ctx.r[11].s64 = ctx.r[28].s64 + -4;
	// 821E8E90: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821E8E94: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 821E8E98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8E9C: 4BFE8C5D  bl 0x821d1af8
	ctx.lr = 0x821E8EA0;
	sub_821D1AF8(ctx, base);
	// 821E8EA0: 48000014  b 0x821e8eb4
	pc = 0x821E8EB4; continue 'dispatch;
            }
            0x821E8EA4 => {
    //   block [0x821E8EA4..0x821E8EB4)
	// 821E8EA4: 556B0034  rlwinm r11, r11, 0, 0, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E8EA8: 394BFFFC  addi r10, r11, -4
	ctx.r[10].s64 = ctx.r[11].s64 + -4;
	// 821E8EAC: 917F3A50  stw r11, 0x3a50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(14928 as u32), ctx.r[11].u32 ) };
	// 821E8EB0: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	pc = 0x821E8EB4; continue 'dispatch;
            }
            0x821E8EB4 => {
    //   block [0x821E8EB4..0x821E8EBC)
	// 821E8EB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E8EB8: 48AC05A0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8EC0 size=256
    let mut pc: u32 = 0x821E8EC0;
    'dispatch: loop {
        match pc {
            0x821E8EC0 => {
    //   block [0x821E8EC0..0x821E8EE8)
	// 821E8EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E8EC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E8EC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821E8ECC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E8ED0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E8ED4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E8ED8: 817F2A90  lwz r11, 0x2a90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10896 as u32) ) } as u64;
	// 821E8EDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8EE0: 419A0008  beq cr6, 0x821e8ee8
	if ctx.cr[6].eq {
	pc = 0x821E8EE8; continue 'dispatch;
	}
	// 821E8EE4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821E8EE8; continue 'dispatch;
            }
            0x821E8EE8 => {
    //   block [0x821E8EE8..0x821E8F4C)
	// 821E8EE8: 817F33B0  lwz r11, 0x33b0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13232 as u32) ) } as u64;
	// 821E8EEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E8EF0: 409A005C  bne cr6, 0x821e8f4c
	if !ctx.cr[6].eq {
	pc = 0x821E8F4C; continue 'dispatch;
	}
	// 821E8EF4: 897F2ABC  lbz r11, 0x2abc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821E8EF8: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8EFC: 40820050  bne 0x821e8f4c
	if !ctx.cr[0].eq {
	pc = 0x821E8F4C; continue 'dispatch;
	}
	// 821E8F00: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821E8F04: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821E8F08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8F0C: 4809A925  bl 0x82283830
	ctx.lr = 0x821E8F10;
	sub_82283830(ctx, base);
	// 821E8F10: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E8F14: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E8F18: 419A0034  beq cr6, 0x821e8f4c
	if ctx.cr[6].eq {
	pc = 0x821E8F4C; continue 'dispatch;
	}
	// 821E8F1C: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 821E8F20: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 821E8F24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8F28: 4801D7C1  bl 0x822066e8
	ctx.lr = 0x821E8F2C;
	sub_822066E8(ctx, base);
	// 821E8F2C: 7C641B79  or. r4, r3, r3
	ctx.r[4].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821E8F30: 4182001C  beq 0x821e8f4c
	if ctx.cr[0].eq {
	pc = 0x821E8F4C; continue 'dispatch;
	}
	// 821E8F34: 391F3438  addi r8, r31, 0x3438
	ctx.r[8].s64 = ctx.r[31].s64 + 13368;
	// 821E8F38: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E8F3C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821E8F40: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 821E8F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8F48: 4809D981  bl 0x822868c8
	ctx.lr = 0x821E8F4C;
	sub_822868C8(ctx, base);
	pc = 0x821E8F4C; continue 'dispatch;
            }
            0x821E8F4C => {
    //   block [0x821E8F4C..0x821E8F98)
	// 821E8F4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8F50: 4BFFFDE9  bl 0x821e8d38
	ctx.lr = 0x821E8F54;
	sub_821E8D38(ctx, base);
	// 821E8F54: 897F2ABC  lbz r11, 0x2abc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10940 as u32) ) } as u64;
	// 821E8F58: 556B0031  rlwinm. r11, r11, 0, 0, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8F5C: 40820048  bne 0x821e8fa4
	if !ctx.cr[0].eq {
	pc = 0x821E8FA4; continue 'dispatch;
	}
	// 821E8F60: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821E8F64: 816B7144  lwz r11, 0x7144(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28996 as u32) ) } as u64;
	// 821E8F68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8F6C: 419A0038  beq cr6, 0x821e8fa4
	if ctx.cr[6].eq {
	pc = 0x821E8FA4; continue 'dispatch;
	}
	// 821E8F70: 897F2ABD  lbz r11, 0x2abd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10941 as u32) ) } as u64;
	// 821E8F74: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E8F78: 4082002C  bne 0x821e8fa4
	if !ctx.cr[0].eq {
	pc = 0x821E8FA4; continue 'dispatch;
	}
	// 821E8F7C: 817F2A9C  lwz r11, 0x2a9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(10908 as u32) ) } as u64;
	// 821E8F80: 348BFFFE  addic. r4, r11, -2
	ctx.xer.ca = (ctx.r[11].u32 > (!(-2 as u32)));
	ctx.r[4].s64 = ctx.r[11].s64 + -2;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 821E8F84: 41820014  beq 0x821e8f98
	if ctx.cr[0].eq {
	pc = 0x821E8F98; continue 'dispatch;
	}
	// 821E8F88: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821E8F8C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821E8F90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E8F94: 480596D5  bl 0x82242668
	ctx.lr = 0x821E8F98;
	sub_82242668(ctx, base);
	pc = 0x821E8F98; continue 'dispatch;
            }
            0x821E8F98 => {
    //   block [0x821E8F98..0x821E8FA4)
	// 821E8F98: 897F2ABD  lbz r11, 0x2abd(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10941 as u32) ) } as u64;
	// 821E8F9C: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 821E8FA0: 997F2ABD  stb r11, 0x2abd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10941 as u32), ctx.r[11].u8 ) };
	pc = 0x821E8FA4; continue 'dispatch;
            }
            0x821E8FA4 => {
    //   block [0x821E8FA4..0x821E8FC0)
	// 821E8FA4: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821E8FA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821E8FAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E8FB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E8FB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821E8FB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E8FBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E8FC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E8FC8 size=140
    let mut pc: u32 = 0x821E8FC8;
    'dispatch: loop {
        match pc {
            0x821E8FC8 => {
    //   block [0x821E8FC8..0x821E9030)
	// 821E8FC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E8FCC: 48AC0441  bl 0x82ca940c
	ctx.lr = 0x821E8FD0;
	sub_82CA93D0(ctx, base);
	// 821E8FD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E8FD4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821E8FD8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821E8FDC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821E8FE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821E8FE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E8FE8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E8FEC: 814B0044  lwz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 821E8FF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E8FF4: 4E800421  bctrl
	ctx.lr = 0x821E8FF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E8FF8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 821E8FFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E9000: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821E9004: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821E9008: E9090000  ld r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 821E900C: F91D00E0  std r8, 0xe0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(224 as u32), ctx.r[8].u64 ) };
	// 821E9010: E8E90008  ld r7, 8(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 821E9014: F8FD00E8  std r7, 0xe8(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(232 as u32), ctx.r[7].u64 ) };
	// 821E9018: 4BFFC7F9  bl 0x821e5810
	ctx.lr = 0x821E901C;
	sub_821E5810(ctx, base);
	// 821E901C: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 821E9020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E9024: 419A000C  beq cr6, 0x821e9030
	if ctx.cr[6].eq {
	pc = 0x821E9030; continue 'dispatch;
	}
	// 821E9028: 806B0038  lwz r3, 0x38(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 821E902C: 48000008  b 0x821e9034
	pc = 0x821E9034; continue 'dispatch;
            }
            0x821E9030 => {
    //   block [0x821E9030..0x821E9034)
	// 821E9030: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x821E9034; continue 'dispatch;
            }
            0x821E9034 => {
    //   block [0x821E9034..0x821E9054)
	// 821E9034: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E9038: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E903C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821E9040: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E9044: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821E9048: 4E800421  bctrl
	ctx.lr = 0x821E904C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E904C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E9050: 48AC040C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E9058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E9058 size=664
    let mut pc: u32 = 0x821E9058;
    'dispatch: loop {
        match pc {
            0x821E9058 => {
    //   block [0x821E9058..0x821E9094)
	// 821E9058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E905C: 48AC0399  bl 0x82ca93f4
	ctx.lr = 0x821E9060;
	sub_82CA93D0(ctx, base);
	// 821E9060: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 821E9064: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E9068: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 821E906C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821E9070: 7FB7EB78  mr r23, r29
	ctx.r[23].u64 = ctx.r[29].u64;
	// 821E9074: 817900EC  lwz r11, 0xec(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(236 as u32) ) } as u64;
	// 821E9078: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 821E907C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E9080: 40990240  ble cr6, 0x821e92c0
	if !ctx.cr[6].gt {
	pc = 0x821E92C0; continue 'dispatch;
	}
	// 821E9084: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E9088: 3B5900E4  addi r26, r25, 0xe4
	ctx.r[26].s64 = ctx.r[25].s64 + 228;
	// 821E908C: 3F008349  lis r24, -0x7cb7
	ctx.r[24].s64 = -2092367872;
	// 821E9090: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x821E9094; continue 'dispatch;
            }
            0x821E9094 => {
    //   block [0x821E9094..0x821E90AC)
	// 821E9094: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E9098: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821E909C: 48000255  bl 0x821e92f0
	ctx.lr = 0x821E90A0;
	sub_821E92F0(ctx, base);
	// 821E90A0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821E90A4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E90A8: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821E90AC; continue 'dispatch;
            }
            0x821E90AC => {
    //   block [0x821E90AC..0x821E90C8)
	// 821E90AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 821E90B0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821E90B4: 4800023D  bl 0x821e92f0
	ctx.lr = 0x821E90B8;
	sub_821E92F0(ctx, base);
	// 821E90B8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E90BC: 7F1B1840  cmplw cr6, r27, r3
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[3].u32, &mut ctx.xer);
	// 821E90C0: 419A0008  beq cr6, 0x821e90c8
	if ctx.cr[6].eq {
	pc = 0x821E90C8; continue 'dispatch;
	}
	// 821E90C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E90C8; continue 'dispatch;
            }
            0x821E90C8 => {
    //   block [0x821E90C8..0x821E90E0)
	// 821E90C8: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E90CC: 419A01E0  beq cr6, 0x821e92ac
	if ctx.cr[6].eq {
	pc = 0x821E92AC; continue 'dispatch;
	}
	// 821E90D0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E90D4: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E90D8: 409A0008  bne cr6, 0x821e90e0
	if !ctx.cr[6].eq {
	pc = 0x821E90E0; continue 'dispatch;
	}
	// 821E90DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E90E0; continue 'dispatch;
            }
            0x821E90E0 => {
    //   block [0x821E90E0..0x821E911C)
	// 821E90E0: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E90E4: 387C0008  addi r3, r28, 8
	ctx.r[3].s64 = ctx.r[28].s64 + 8;
	// 821E90E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E90EC: 419A0084  beq cr6, 0x821e9170
	if ctx.cr[6].eq {
	pc = 0x821E9170; continue 'dispatch;
	}
	// 821E90F0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E90F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E90F8: 419A0074  beq cr6, 0x821e916c
	if ctx.cr[6].eq {
	pc = 0x821E916C; continue 'dispatch;
	}
	// 821E90FC: 555E003E  slwi r30, r10, 0
	ctx.r[30].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 821E9100: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821E9104: 419A0018  beq cr6, 0x821e911c
	if ctx.cr[6].eq {
	pc = 0x821E911C; continue 'dispatch;
	}
	// 821E9108: 897E0090  lbz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 821E910C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821E9110: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E9114: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E9118: 409A0008  bne cr6, 0x821e9120
	if !ctx.cr[6].eq {
	pc = 0x821E9120; continue 'dispatch;
	}
	pc = 0x821E911C; continue 'dispatch;
            }
            0x821E911C => {
    //   block [0x821E911C..0x821E9120)
	// 821E911C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821E9120; continue 'dispatch;
            }
            0x821E9120 => {
    //   block [0x821E9120..0x821E916C)
	// 821E9120: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E9124: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E9128: 419A016C  beq cr6, 0x821e9294
	if ctx.cr[6].eq {
	pc = 0x821E9294; continue 'dispatch;
	}
	// 821E912C: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 821E9130: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 821E9134: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 821E9138: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E913C: 419A0100  beq cr6, 0x821e923c
	if ctx.cr[6].eq {
	pc = 0x821E923C; continue 'dispatch;
	}
	// 821E9140: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 821E9144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E9148: 419A0030  beq cr6, 0x821e9178
	if ctx.cr[6].eq {
	pc = 0x821E9178; continue 'dispatch;
	}
	// 821E914C: 894B0055  lbz r10, 0x55(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(85 as u32) ) } as u64;
	// 821E9150: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E9154: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 821E9158: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821E915C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E9160: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821E9164: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E9168: 480000D8  b 0x821e9240
	pc = 0x821E9240; continue 'dispatch;
            }
            0x821E916C => {
    //   block [0x821E916C..0x821E9170)
	// 821E916C: 4BFAACCD  bl 0x82193e38
	ctx.lr = 0x821E9170;
	sub_82193E38(ctx, base);
	pc = 0x821E9170; continue 'dispatch;
            }
            0x821E9170 => {
    //   block [0x821E9170..0x821E9178)
	// 821E9170: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 821E9174: 4BFFFFA8  b 0x821e911c
	pc = 0x821E911C; continue 'dispatch;
            }
            0x821E9178 => {
    //   block [0x821E9178..0x821E9194)
	// 821E9178: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 821E917C: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 821E9180: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 821E9184: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821E9188: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821E918C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E9190: 40810054  ble 0x821e91e4
	if !ctx.cr[0].gt {
	pc = 0x821E91E4; continue 'dispatch;
	}
	pc = 0x821E9194; continue 'dispatch;
            }
            0x821E9194 => {
    //   block [0x821E9194..0x821E91B4)
	// 821E9194: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821E9198: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821E919C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821E91A0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E91A4: 2F070055  cmpwi cr6, r7, 0x55
	ctx.cr[6].compare_i32(ctx.r[7].s32, 85, &mut ctx.xer);
	// 821E91A8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821E91AC: 41980008  blt cr6, 0x821e91b4
	if ctx.cr[6].lt {
	pc = 0x821E91B4; continue 'dispatch;
	}
	// 821E91B0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x821E91B4; continue 'dispatch;
            }
            0x821E91B4 => {
    //   block [0x821E91B4..0x821E91D0)
	// 821E91B4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821E91B8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821E91BC: 419A0014  beq cr6, 0x821e91d0
	if ctx.cr[6].eq {
	pc = 0x821E91D0; continue 'dispatch;
	}
	// 821E91C0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821E91C4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821E91C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821E91CC: 4800000C  b 0x821e91d8
	pc = 0x821E91D8; continue 'dispatch;
            }
            0x821E91D0 => {
    //   block [0x821E91D0..0x821E91D8)
	// 821E91D0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821E91D4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821E91D8; continue 'dispatch;
            }
            0x821E91D8 => {
    //   block [0x821E91D8..0x821E91E4)
	// 821E91D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821E91DC: 4199FFB8  bgt cr6, 0x821e9194
	if ctx.cr[6].gt {
	pc = 0x821E9194; continue 'dispatch;
	}
	// 821E91E0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x821E91E4; continue 'dispatch;
            }
            0x821E91E4 => {
    //   block [0x821E91E4..0x821E9200)
	// 821E91E4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821E91E8: 419A0040  beq cr6, 0x821e9228
	if ctx.cr[6].eq {
	pc = 0x821E9228; continue 'dispatch;
	}
	// 821E91EC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E91F0: 2F0B0055  cmpwi cr6, r11, 0x55
	ctx.cr[6].compare_i32(ctx.r[11].s32, 85, &mut ctx.xer);
	// 821E91F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E91F8: 41990008  bgt cr6, 0x821e9200
	if ctx.cr[6].gt {
	pc = 0x821E9200; continue 'dispatch;
	}
	// 821E91FC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821E9200; continue 'dispatch;
            }
            0x821E9200 => {
    //   block [0x821E9200..0x821E9228)
	// 821E9200: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E9204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E9208: 409A0020  bne cr6, 0x821e9228
	if !ctx.cr[6].eq {
	pc = 0x821E9228; continue 'dispatch;
	}
	// 821E920C: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821E9210: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821E9214: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821E9218: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E921C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821E9220: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E9224: 4800001C  b 0x821e9240
	pc = 0x821E9240; continue 'dispatch;
            }
            0x821E9228 => {
    //   block [0x821E9228..0x821E923C)
	// 821E9228: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 821E922C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E9230: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821E9234: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E9238: 48000008  b 0x821e9240
	pc = 0x821E9240; continue 'dispatch;
            }
            0x821E923C => {
    //   block [0x821E923C..0x821E9240)
	// 821E923C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821E9240; continue 'dispatch;
            }
            0x821E9240 => {
    //   block [0x821E9240..0x821E926C)
	// 821E9240: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E9244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E9248: 419A0044  beq cr6, 0x821e928c
	if ctx.cr[6].eq {
	pc = 0x821E928C; continue 'dispatch;
	}
	// 821E924C: 89786C21  lbz r11, 0x6c21(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(27681 as u32) ) } as u64;
	// 821E9250: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E9254: 419A002C  beq cr6, 0x821e9280
	if ctx.cr[6].eq {
	pc = 0x821E9280; continue 'dispatch;
	}
	// 821E9258: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E925C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E9260: 419A000C  beq cr6, 0x821e926c
	if ctx.cr[6].eq {
	pc = 0x821E926C; continue 'dispatch;
	}
	// 821E9264: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E9268: 49049179  bl 0x832323e0
	ctx.lr = 0x821E926C;
	sub_832323E0(ctx, base);
	pc = 0x821E926C; continue 'dispatch;
            }
            0x821E926C => {
    //   block [0x821E926C..0x821E9280)
	// 821E926C: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E9270: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821E9274: 419A0018  beq cr6, 0x821e928c
	if ctx.cr[6].eq {
	pc = 0x821E928C; continue 'dispatch;
	}
	// 821E9278: 49048D89  bl 0x83232000
	ctx.lr = 0x821E927C;
	sub_83232000(ctx, base);
	// 821E927C: 48000010  b 0x821e928c
	pc = 0x821E928C; continue 'dispatch;
            }
            0x821E9280 => {
    //   block [0x821E9280..0x821E928C)
	// 821E9280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821E9284: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E9288: 48380C99  bl 0x82569f20
	ctx.lr = 0x821E928C;
	sub_82569F20(ctx, base);
	pc = 0x821E928C; continue 'dispatch;
            }
            0x821E928C => {
    //   block [0x821E928C..0x821E9294)
	// 821E928C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821E9290: 481A4599  bl 0x8238d828
	ctx.lr = 0x821E9294;
	sub_8238D828(ctx, base);
	pc = 0x821E9294; continue 'dispatch;
            }
            0x821E9294 => {
    //   block [0x821E9294..0x821E92A4)
	// 821E9294: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E9298: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E929C: 409A0008  bne cr6, 0x821e92a4
	if !ctx.cr[6].eq {
	pc = 0x821E92A4; continue 'dispatch;
	}
	// 821E92A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E92A4; continue 'dispatch;
            }
            0x821E92A4 => {
    //   block [0x821E92A4..0x821E92AC)
	// 821E92A4: 839C0000  lwz r28, 0(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E92A8: 4BFFFE04  b 0x821e90ac
	pc = 0x821E90AC; continue 'dispatch;
            }
            0x821E92AC => {
    //   block [0x821E92AC..0x821E92C0)
	// 821E92AC: 817900EC  lwz r11, 0xec(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(236 as u32) ) } as u64;
	// 821E92B0: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	// 821E92B4: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 821E92B8: 7F175840  cmplw cr6, r23, r11
	ctx.cr[6].compare_u32(ctx.r[23].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E92BC: 4198FDD8  blt cr6, 0x821e9094
	if ctx.cr[6].lt {
	pc = 0x821E9094; continue 'dispatch;
	}
	pc = 0x821E92C0; continue 'dispatch;
            }
            0x821E92C0 => {
    //   block [0x821E92C0..0x821E92F0)
	// 821E92C0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 821E92C4: 480E0BC5  bl 0x822c9e88
	ctx.lr = 0x821E92C8;
	sub_822C9E88(ctx, base);
	// 821E92C8: 93B90158  stw r29, 0x158(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(344 as u32), ctx.r[29].u32 ) };
	// 821E92CC: 387900F0  addi r3, r25, 0xf0
	ctx.r[3].s64 = ctx.r[25].s64 + 240;
	// 821E92D0: 4882BAC1  bl 0x82a14d90
	ctx.lr = 0x821E92D4;
	sub_82A14D90(ctx, base);
	// 821E92D4: 387900FC  addi r3, r25, 0xfc
	ctx.r[3].s64 = ctx.r[25].s64 + 252;
	// 821E92D8: 4882BAB9  bl 0x82a14d90
	ctx.lr = 0x821E92DC;
	sub_82A14D90(ctx, base);
	// 821E92DC: 93B901AC  stw r29, 0x1ac(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(428 as u32), ctx.r[29].u32 ) };
	// 821E92E0: 93B901B0  stw r29, 0x1b0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(432 as u32), ctx.r[29].u32 ) };
	// 821E92E4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821E92E8: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 821E92EC: 48AC0158  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E92F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E92F0 size=320
    let mut pc: u32 = 0x821E92F0;
    'dispatch: loop {
        match pc {
            0x821E92F0 => {
    //   block [0x821E92F0..0x821E9320)
	// 821E92F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E92F4: 48AC0119  bl 0x82ca940c
	ctx.lr = 0x821E92F8;
	sub_82CA93D0(ctx, base);
	// 821E92F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E92FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821E9300: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821E9304: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821E9308: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E930C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E9310: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 821E9314: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E9318: 409A0044  bne cr6, 0x821e935c
	if !ctx.cr[6].eq {
	pc = 0x821E935C; continue 'dispatch;
	}
	// 821E931C: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821E9320; continue 'dispatch;
            }
            0x821E9320 => {
    //   block [0x821E9320..0x821E9334)
	// 821E9320: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E9324: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821E9328: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821E932C: 41980008  blt cr6, 0x821e9334
	if ctx.cr[6].lt {
	pc = 0x821E9334; continue 'dispatch;
	}
	// 821E9330: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x821E9334; continue 'dispatch;
            }
            0x821E9334 => {
    //   block [0x821E9334..0x821E9348)
	// 821E9334: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821E9338: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E933C: 419A000C  beq cr6, 0x821e9348
	if ctx.cr[6].eq {
	pc = 0x821E9348; continue 'dispatch;
	}
	// 821E9340: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E9344: 4800000C  b 0x821e9350
	pc = 0x821E9350; continue 'dispatch;
            }
            0x821E9348 => {
    //   block [0x821E9348..0x821E9350)
	// 821E9348: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821E934C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821E9350; continue 'dispatch;
            }
            0x821E9350 => {
    //   block [0x821E9350..0x821E935C)
	// 821E9350: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 821E9354: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821E9358: 419AFFC8  beq cr6, 0x821e9320
	if ctx.cr[6].eq {
	pc = 0x821E9320; continue 'dispatch;
	}
	pc = 0x821E935C; continue 'dispatch;
            }
            0x821E935C => {
    //   block [0x821E935C..0x821E9390)
	// 821E935C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E9360: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 821E9364: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 821E9368: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821E936C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E9370: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 821E9374: 419A0028  beq cr6, 0x821e939c
	if ctx.cr[6].eq {
	pc = 0x821E939C; continue 'dispatch;
	}
	// 821E9378: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E937C: 8129000C  lwz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E9380: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 821E9384: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821E9388: 41980008  blt cr6, 0x821e9390
	if ctx.cr[6].lt {
	pc = 0x821E9390; continue 'dispatch;
	}
	// 821E938C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821E9390; continue 'dispatch;
            }
            0x821E9390 => {
    //   block [0x821E9390..0x821E939C)
	// 821E9390: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821E9394: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E9398: 419A0070  beq cr6, 0x821e9408
	if ctx.cr[6].eq {
	pc = 0x821E9408; continue 'dispatch;
	}
	pc = 0x821E939C; continue 'dispatch;
            }
            0x821E939C => {
    //   block [0x821E939C..0x821E9408)
	// 821E939C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E93A0: 4865EC11  bl 0x82847fb0
	ctx.lr = 0x821E93A4;
	sub_82847FB0(ctx, base);
	// 821E93A4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E93A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821E93AC: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 821E93B0: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 821E93B4: 4836E8D5  bl 0x82557c88
	ctx.lr = 0x821E93B8;
	sub_82557C88(ctx, base);
	// 821E93B8: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 821E93BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E93C0: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821E93C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821E93C8: 4836D591  bl 0x82556958
	ctx.lr = 0x821E93CC;
	sub_82556958(ctx, base);
	// 821E93CC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 821E93D0: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 821E93D4: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821E93D8: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 821E93DC: 48543F5D  bl 0x8272d338
	ctx.lr = 0x821E93E0;
	sub_8272D338(ctx, base);
	// 821E93E0: 80610078  lwz r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821E93E4: 48032955  bl 0x8221bd38
	ctx.lr = 0x821E93E8;
	sub_8221BD38(ctx, base);
	// 821E93E8: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 821E93EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821E93F0: 48543F49  bl 0x8272d338
	ctx.lr = 0x821E93F4;
	sub_8272D338(ctx, base);
	// 821E93F4: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821E93F8: 48032941  bl 0x8221bd38
	ctx.lr = 0x821E93FC;
	sub_8221BD38(ctx, base);
	// 821E93FC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E9400: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821E9404: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	pc = 0x821E9408; continue 'dispatch;
            }
            0x821E9408 => {
    //   block [0x821E9408..0x821E9414)
	// 821E9408: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821E940C: 409A0008  bne cr6, 0x821e9414
	if !ctx.cr[6].eq {
	pc = 0x821E9414; continue 'dispatch;
	}
	// 821E9410: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E9414; continue 'dispatch;
            }
            0x821E9414 => {
    //   block [0x821E9414..0x821E9424)
	// 821E9414: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821E9418: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E941C: 409A0008  bne cr6, 0x821e9424
	if !ctx.cr[6].eq {
	pc = 0x821E9424; continue 'dispatch;
	}
	// 821E9420: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E9424; continue 'dispatch;
            }
            0x821E9424 => {
    //   block [0x821E9424..0x821E9430)
	// 821E9424: 386A0010  addi r3, r10, 0x10
	ctx.r[3].s64 = ctx.r[10].s64 + 16;
	// 821E9428: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 821E942C: 48AC0030  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E9430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E9430 size=2504
    let mut pc: u32 = 0x821E9430;
    'dispatch: loop {
        match pc {
            0x821E9430 => {
    //   block [0x821E9430..0x821E9DF8)
	// 821E9430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E9434: 48ABFFC1  bl 0x82ca93f4
	ctx.lr = 0x821E9438;
	sub_82CA93D0(ctx, base);
	// 821E9438: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 821E943C: 48AC489D  bl 0x82cadcd8
	ctx.lr = 0x821E9440;
	sub_82CADCA0(ctx, base);
	// 821E9440: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E9DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821E9DF8 size=192
    let mut pc: u32 = 0x821E9DF8;
    'dispatch: loop {
        match pc {
            0x821E9DF8 => {
    //   block [0x821E9DF8..0x821E9EB8)
	// 821E9DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E9DFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E9E00: 3981FFF8  addi r12, r1, -8
	ctx.r[12].s64 = ctx.r[1].s64 + -8;
	// 821E9E04: 48AC3ED5  bl 0x82cadcd8
	ctx.lr = 0x821E9E08;
	sub_82CADCA0(ctx, base);
	// 821E9E08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E9E0C: FFA01090  fmr f29, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[2].f64;
	// 821E9E10: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821E9E14: FFC01890  fmr f30, f3
	ctx.f[30].f64 = ctx.f[3].f64;
	// 821E9E18: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 821E9E1C: 48050095  bl 0x82239eb0
	ctx.lr = 0x821E9E20;
	sub_82239EB0(ctx, base);
	// 821E9E20: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821E9E24: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 821E9E28: EFA007B2  fmuls f29, f0, f30
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821E9E2C: 48050165  bl 0x82239f90
	ctx.lr = 0x821E9E30;
	sub_82239F90(ctx, base);
	// 821E9E30: FF800818  frsp f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821E9E34: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E9E38: 48050079  bl 0x82239eb0
	ctx.lr = 0x821E9E3C;
	sub_82239EB0(ctx, base);
	// 821E9E3C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821E9E40: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821E9E44: ED9C07B2  fmuls f12, f28, f30
	ctx.f[12].f64 = (((ctx.f[28].f64 * ctx.f[30].f64) as f32) as f64);
	// 821E9E48: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821E9E4C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821E9E50: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821E9E54: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821E9E58: ED6D0772  fmuls f11, f13, f29
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 821E9E5C: D1610050  stfs f11, 0x50(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821E9E60: 48050131  bl 0x82239f90
	ctx.lr = 0x821E9E64;
	sub_82239F90(ctx, base);
	// 821E9E64: FD400818  frsp f10, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821E9E68: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821E9E6C: 3921005C  addi r9, r1, 0x5c
	ctx.r[9].s64 = ctx.r[1].s64 + 92;
	// 821E9E70: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 821E9E74: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E9EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821E9EB8 size=168
    let mut pc: u32 = 0x821E9EB8;
    'dispatch: loop {
        match pc {
            0x821E9EB8 => {
    //   block [0x821E9EB8..0x821E9EF0)
	// 821E9EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E9EBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821E9EC0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821E9EC4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821E9EC8: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821E9ECC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821E9ED0: 38A00024  li r5, 0x24
	ctx.r[5].s64 = 36;
	// 821E9ED4: 388B0D54  addi r4, r11, 0xd54
	ctx.r[4].s64 = ctx.r[11].s64 + 3412;
	// 821E9ED8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E9EDC: 4800A5A5  bl 0x821f4480
	ctx.lr = 0x821E9EE0;
	sub_821F4480(ctx, base);
	// 821E9EE0: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821E9EE4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821E9EE8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821E9EEC: 419A0060  beq cr6, 0x821e9f4c
	if ctx.cr[6].eq {
	pc = 0x821E9F4C; continue 'dispatch;
	}
	pc = 0x821E9EF0; continue 'dispatch;
            }
            0x821E9EF0 => {
    //   block [0x821E9EF0..0x821E9F14)
	// 821E9EF0: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821E9EF4: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821E9EF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821E9EFC: 419A0018  beq cr6, 0x821e9f14
	if ctx.cr[6].eq {
	pc = 0x821E9F14; continue 'dispatch;
	}
	// 821E9F00: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821E9F04: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 821E9F08: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 821E9F0C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821E9F10: 41980008  blt cr6, 0x821e9f18
	if ctx.cr[6].lt {
	pc = 0x821E9F18; continue 'dispatch;
	}
	pc = 0x821E9F14; continue 'dispatch;
            }
            0x821E9F14 => {
    //   block [0x821E9F14..0x821E9F18)
	// 821E9F14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821E9F18; continue 'dispatch;
            }
            0x821E9F18 => {
    //   block [0x821E9F18..0x821E9F4C)
	// 821E9F18: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821E9F1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821E9F20: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821E9F24: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821E9F28: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 821E9F2C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821E9F30: 4E800421  bctrl
	ctx.lr = 0x821E9F34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821E9F34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821E9F38: 48015E41  bl 0x821ffd78
	ctx.lr = 0x821E9F3C;
	sub_821FFD78(ctx, base);
	// 821E9F3C: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821E9F40: 80E10064  lwz r7, 0x64(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821E9F44: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821E9F48: 409AFFA8  bne cr6, 0x821e9ef0
	if !ctx.cr[6].eq {
	pc = 0x821E9EF0; continue 'dispatch;
	}
            }
            0x821E9F4C => {
    //   block [0x821E9F4C..0x821E9F60)
	// 821E9F4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821E9F50: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821E9F54: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821E9F58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821E9F5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821E9F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821E9F60 size=2044
    let mut pc: u32 = 0x821E9F60;
    'dispatch: loop {
        match pc {
            0x821E9F60 => {
    //   block [0x821E9F60..0x821EA75C)
	// 821E9F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821E9F64: 48ABF491  bl 0x82ca93f4
	ctx.lr = 0x821E9F68;
	sub_82CA93D0(ctx, base);
	// 821E9F68: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 821E9F6C: 48AC3D6D  bl 0x82cadcd8
	ctx.lr = 0x821E9F70;
	sub_82CADCA0(ctx, base);
	// 821E9F70: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EA760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821EA760 size=2512
    let mut pc: u32 = 0x821EA760;
    'dispatch: loop {
        match pc {
            0x821EA760 => {
    //   block [0x821EA760..0x821EA798)
	// 821EA760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EA764: 48ABEC79  bl 0x82ca93dc
	ctx.lr = 0x821EA768;
	sub_82CA93D0(ctx, base);
	// 821EA768: DBC1FF70  stfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[30].u64 ) };
	// 821EA76C: DBE1FF78  stfd f31, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 821EA770: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EA774: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821EA778: 3A800001  li r20, 1
	ctx.r[20].s64 = 1;
	// 821EA77C: 3B4B2390  addi r26, r11, 0x2390
	ctx.r[26].s64 = ctx.r[11].s64 + 9104;
	// 821EA780: 3D40834B  lis r10, -0x7cb5
	ctx.r[10].s64 = -2092236800;
	// 821EA784: 9A810050  stb r20, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[20].u8 ) };
	// 821EA788: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 821EA78C: 7C912378  mr r17, r4
	ctx.r[17].u64 = ctx.r[4].u64;
	// 821EA790: 397A2004  addi r11, r26, 0x2004
	ctx.r[11].s64 = ctx.r[26].s64 + 8196;
	// 821EA794: 392A7E70  addi r9, r10, 0x7e70
	ctx.r[9].s64 = ctx.r[10].s64 + 32368;
	pc = 0x821EA798; continue 'dispatch;
            }
            0x821EA798 => {
    //   block [0x821EA798..0x821EA854)
	// 821EA798: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EA79C: 391A6014  addi r8, r26, 0x6014
	ctx.r[8].s64 = ctx.r[26].s64 + 24596;
	// 821EA7A0: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EA7A4: 7CEA5A14  add r7, r10, r11
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821EA7A8: 9127DFFC  stw r9, -0x2004(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-8196 as u32), ctx.r[9].u32 ) };
	// 821EA7AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EA7B0: 80CBFFFC  lwz r6, -4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821EA7B4: 54C4083C  slwi r4, r6, 1
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821EA7B8: 38AA0001  addi r5, r10, 1
	ctx.r[5].s64 = ctx.r[10].s64 + 1;
	// 821EA7BC: 908BFFFC  stw r4, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[4].u32 ) };
	// 821EA7C0: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 821EA7C4: 396B2008  addi r11, r11, 0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + 8200;
	// 821EA7C8: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 821EA7CC: 4198FFCC  blt cr6, 0x821ea798
	if ctx.cr[6].lt {
	pc = 0x821EA798; continue 'dispatch;
	}
	// 821EA7D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821EA7D4: 807305A4  lwz r3, 0x5a4(r19)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(1444 as u32) ) } as u64;
	// 821EA7D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821EA7DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821EA7E0: 3A530270  addi r18, r19, 0x270
	ctx.r[18].s64 = ctx.r[19].s64 + 624;
	// 821EA7E4: 4803430D  bl 0x8221eaf0
	ctx.lr = 0x821EA7E8;
	sub_8221EAF0(ctx, base);
	// 821EA7E8: 817305A4  lwz r11, 0x5a4(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(1444 as u32) ) } as u64;
	// 821EA7EC: 3D407FFF  lis r10, 0x7fff
	ctx.r[10].s64 = 2147418112;
	// 821EA7F0: 81330270  lwz r9, 0x270(r19)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(624 as u32) ) } as u64;
	// 821EA7F4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821EA7F8: 615FFFFF  ori r31, r10, 0xffff
	ctx.r[31].u64 = ctx.r[10].u64 | 65535;
	// 821EA7FC: 5528077A  rlwinm r8, r9, 0, 0x1d, 0x1d
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 821EA800: 80EB0054  lwz r7, 0x54(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 821EA804: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821EA808: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821EA80C: 7CC7F850  subf r6, r7, r31
	ctx.r[6].s64 = ctx.r[31].s64 - ctx.r[7].s64;
	// 821EA810: 7CC50034  cntlzw r5, r6
	ctx.r[5].u64 = if ctx.r[6].u32 == 0 { 32 } else { ctx.r[6].u32.leading_zeros() as u64 };
	// 821EA814: 54A4DFFE  rlwinm r4, r5, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[5].u32 as u64 & 0x0000001Fu64;
	// 821EA818: 689E0001  xori r30, r4, 1
	ctx.r[30].u64 = ctx.r[4].u64 ^ 1;
	// 821EA81C: 419A0038  beq cr6, 0x821ea854
	if ctx.cr[6].eq {
	pc = 0x821EA854; continue 'dispatch;
	}
	// 821EA820: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821EA824: 807305A8  lwz r3, 0x5a8(r19)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(1448 as u32) ) } as u64;
	// 821EA828: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821EA82C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821EA830: 480342C1  bl 0x8221eaf0
	ctx.lr = 0x821EA834;
	sub_8221EAF0(ctx, base);
	// 821EA834: 817305A8  lwz r11, 0x5a8(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(1448 as u32) ) } as u64;
	// 821EA838: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 821EA83C: 814B0054  lwz r10, 0x54(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 821EA840: 7D2AF850  subf r9, r10, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 821EA844: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821EA848: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 821EA84C: 68E60001  xori r6, r7, 1
	ctx.r[6].u64 = ctx.r[7].u64 ^ 1;
	// 821EA850: 7CDEF038  and r30, r6, r30
	ctx.r[30].u64 = ctx.r[6].u64 & ctx.r[30].u64;
	pc = 0x821EA854; continue 'dispatch;
            }
            0x821EA854 => {
    //   block [0x821EA854..0x821EA8F4)
	// 821EA854: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 821EA858: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EA85C: 419A08BC  beq cr6, 0x821eb118
	if ctx.cr[6].eq {
	pc = 0x821EB118; continue 'dispatch;
	}
	// 821EA860: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821EA864: C8130048  lfd f0, 0x48(r19)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[19].u32.wrapping_add(72 as u32) ) };
	// 821EA868: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 821EA86C: 390A9484  addi r8, r10, -0x6b7c
	ctx.r[8].s64 = ctx.r[10].s64 + -27516;
	// 821EA870: 39730048  addi r11, r19, 0x48
	ctx.r[11].s64 = ctx.r[19].s64 + 72;
	// 821EA874: C3CA9484  lfs f30, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821EA878: C9A90D38  lfd f13, 0xd38(r9)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(3384 as u32) ) };
	// 821EA87C: C3E8000C  lfs f31, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821EA880: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821EA884: FD60F890  fmr f11, f31
	ctx.f[11].f64 = ctx.f[31].f64;
	// 821EA888: 419A006C  beq cr6, 0x821ea8f4
	if ctx.cr[6].eq {
	pc = 0x821EA8F4; continue 'dispatch;
	}
	// 821EA88C: C98B0008  lfd f12, 8(r11)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821EA890: FD8C0028  fsub f12, f12, f0
	ctx.f[12].f64 = ctx.f[12].f64 - ctx.f[0].f64;
	// 821EA894: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 821EA898: 4099005C  ble cr6, 0x821ea8f4
	if !ctx.cr[6].gt {
	pc = 0x821EA8F4; continue 'dispatch;
	}
	// 821EA89C: 81510004  lwz r10, 4(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EA8A0: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 821EA8A4: 39090E68  addi r8, r9, 0xe68
	ctx.r[8].s64 = ctx.r[9].s64 + 3688;
	// 821EA8A8: C9AA02E8  lfd f13, 0x2e8(r10)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(744 as u32) ) };
	// 821EA8AC: FD6D0028  fsub f11, f13, f0
	ctx.f[11].f64 = ctx.f[13].f64 - ctx.f[0].f64;
	// 821EA8B0: FD4B6024  fdiv f10, f11, f12
	ctx.f[10].f64 = ctx.f[11].f64 / ctx.f[12].f64;
	// 821EA8B4: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 821EA8B8: FF09F000  fcmpu cr6, f9, f30
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[30].f64);
	// 821EA8BC: 7CE00026  mfcr r7
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[7].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821EA8C0: 54E6DF7A  rlwinm r6, r7, 0x1b, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 821EA8C4: 54E5F77A  rlwinm r5, r7, 0x1e, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 821EA8C8: 7CC42B78  or r4, r6, r5
	ctx.r[4].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 821EA8CC: 7D08242E  lfsx f8, r8, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821EA8D0: FCE8F26E  fsel f7, f8, f9, f30
	ctx.f[7].f64 = if ctx.f[8].f64 >= 0.0 { ctx.f[9].f64 } else { ctx.f[30].f64 };
	// 821EA8D4: ECC7F828  fsubs f6, f7, f31
	ctx.f[6].f64 = (((ctx.f[7].f64 - ctx.f[31].f64) as f32) as f64);
	// 821EA8D8: FF06F000  fcmpu cr6, f6, f30
	ctx.cr[6].compare_f64(ctx.f[6].f64, ctx.f[30].f64);
	// 821EA8DC: 7C600026  mfcr r3
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[3].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[3].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 821EA8E0: 546ADF7A  rlwinm r10, r3, 0x1b, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x0000001Fu64;
	// 821EA8E4: 5469F77A  rlwinm r9, r3, 0x1e, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x00000003u64;
	// 821EA8E8: 7D474B78  or r7, r10, r9
	ctx.r[7].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821EA8EC: 7CA83C2E  lfsx f5, r8, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821EA8F0: FD653FEE  fsel f11, f5, f31, f7
	ctx.f[11].f64 = if ctx.f[5].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[7].f64 };
	pc = 0x821EA8F4; continue 'dispatch;
            }
            0x821EA8F4 => {
    //   block [0x821EA8F4..0x821EA908)
	// 821EA8F4: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821EA8F8: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 821EA8FC: 409A000C  bne cr6, 0x821ea908
	if !ctx.cr[6].eq {
	pc = 0x821EA908; continue 'dispatch;
	}
	// 821EA900: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821EA904: 4800000C  b 0x821ea910
	pc = 0x821EA910; continue 'dispatch;
            }
            0x821EA908 => {
    //   block [0x821EA908..0x821EA910)
	// 821EA908: D16B0010  stfs f11, 0x10(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 821EA90C: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	pc = 0x821EA910; continue 'dispatch;
            }
            0x821EA910 => {
    //   block [0x821EA910..0x821EA928)
	// 821EA910: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821EA914: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EA918: 419A0010  beq cr6, 0x821ea928
	if ctx.cr[6].eq {
	pc = 0x821EA928; continue 'dispatch;
	}
	// 821EA91C: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 821EA920: C0330058  lfs f1, 0x58(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(88 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821EA924: 4887AF45  bl 0x82a65868
	ctx.lr = 0x821EA928;
	sub_82A65868(ctx, base);
	pc = 0x821EA928; continue 'dispatch;
            }
            0x821EA928 => {
    //   block [0x821EA928..0x821EA9E4)
	// 821EA928: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821EA92C: 3EA08336  lis r21, -0x7cca
	ctx.r[21].s64 = -2093613056;
	// 821EA930: 394BDF40  addi r10, r11, -0x20c0
	ctx.r[10].s64 = ctx.r[11].s64 + -8384;
	// 821EA934: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821EA938: 38600076  li r3, 0x76
	ctx.r[3].s64 = 118;
	// 821EA93C: 81750364  lwz r11, 0x364(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EA940: 814A00B4  lwz r10, 0xb4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(180 as u32) ) } as u64;
	// 821EA944: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 821EA948: 914B2E2C  stw r10, 0x2e2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11820 as u32), ctx.r[10].u32 ) };
	// 821EA94C: E8E80010  ld r7, 0x10(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) };
	// 821EA950: 64E60008  oris r6, r7, 8
	ctx.r[6].u64 = ctx.r[7].u64 | 524288;
	// 821EA954: 914970B8  stw r10, 0x70b8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28856 as u32), ctx.r[10].u32 ) };
	// 821EA958: F8C80010  std r6, 0x10(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 821EA95C: 480418B5  bl 0x8222c210
	ctx.lr = 0x821EA960;
	sub_8222C210(ctx, base);
	// 821EA960: 38600077  li r3, 0x77
	ctx.r[3].s64 = 119;
	// 821EA964: 4801E1AD  bl 0x82208b10
	ctx.lr = 0x821EA968;
	sub_82208B10(ctx, base);
	// 821EA968: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821EA96C: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 821EA970: 3BEB63A0  addi r31, r11, 0x63a0
	ctx.r[31].s64 = ctx.r[11].s64 + 25504;
	// 821EA974: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821EA978: 3ACB0DB8  addi r22, r11, 0xdb8
	ctx.r[22].s64 = ctx.r[11].s64 + 3512;
	// 821EA97C: 88BF00BD  lbz r5, 0xbd(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(189 as u32) ) } as u64;
	// 821EA980: 817F00AC  lwz r11, 0xac(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 821EA984: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821EA988: 1D652008  mulli r11, r5, 0x2008
	ctx.r[11].s32 = ((ctx.r[5].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821EA98C: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 821EA990: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821EA994: 419A0084  beq cr6, 0x821eaa18
	if ctx.cr[6].eq {
	pc = 0x821EAA18; continue 'dispatch;
	}
	// 821EA998: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821EA99C: 813F00B0  lwz r9, 0xb0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) } as u64;
	// 821EA9A0: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821EA9A4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821EA9A8: 409A003C  bne cr6, 0x821ea9e4
	if !ctx.cr[6].eq {
	pc = 0x821EA9E4; continue 'dispatch;
	}
	// 821EA9AC: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EA9B0: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821EA9B4: 38FF00A8  addi r7, r31, 0xa8
	ctx.r[7].s64 = ctx.r[31].s64 + 168;
	// 821EA9B8: 55061838  slwi r6, r8, 3
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821EA9BC: 915F00B0  stw r10, 0xb0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 821EA9C0: 7CE6592E  stwx r7, r6, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 821EA9C4: 80AB2004  lwz r5, 0x2004(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EA9C8: 54A91838  slwi r9, r5, 3
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EA9CC: 815F00AC  lwz r10, 0xac(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) } as u64;
	// 821EA9D0: 7C895A14  add r4, r9, r11
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821EA9D4: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821EA9D8: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EA9DC: 386A0001  addi r3, r10, 1
	ctx.r[3].s64 = ctx.r[10].s64 + 1;
	// 821EA9E0: 906B2004  stw r3, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[3].u32 ) };
	pc = 0x821EA9E4; continue 'dispatch;
            }
            0x821EA9E4 => {
    //   block [0x821EA9E4..0x821EAA18)
	// 821EA9E4: 897F00BC  lbz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 821EA9E8: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	// 821EA9EC: 915F00AC  stw r10, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[10].u32 ) };
	// 821EA9F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EA9F4: 409A0024  bne cr6, 0x821eaa18
	if !ctx.cr[6].eq {
	pc = 0x821EAA18; continue 'dispatch;
	}
	// 821EA9F8: 81790DB0  lwz r11, 0xdb0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821EA9FC: 393F00A8  addi r9, r31, 0xa8
	ctx.r[9].s64 = ctx.r[31].s64 + 168;
	// 821EAA00: 995F00BC  stb r10, 0xbc(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[10].u8 ) };
	// 821EAA04: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EAA08: 38AB0001  addi r5, r11, 1
	ctx.r[5].s64 = ctx.r[11].s64 + 1;
	// 821EAA0C: 90B90DB0  stw r5, 0xdb0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(3504 as u32), ctx.r[5].u32 ) };
	// 821EAA10: 7D28B12E  stwx r9, r8, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[22].u32), ctx.r[9].u32) };
	// 821EAA14: 48000008  b 0x821eaa1c
	pc = 0x821EAA1C; continue 'dispatch;
            }
            0x821EAA18 => {
    //   block [0x821EAA18..0x821EAA1C)
	// 821EAA18: 80B90DB0  lwz r5, 0xdb0(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x821EAA1C; continue 'dispatch;
            }
            0x821EAA1C => {
    //   block [0x821EAA1C..0x821EAA84)
	// 821EAA1C: 897F0045  lbz r11, 0x45(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(69 as u32) ) } as u64;
	// 821EAA20: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821EAA24: 1D6B2008  mulli r11, r11, 0x2008
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 8200 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821EAA28: 7D6BD214  add r11, r11, r26
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 821EAA2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EAA30: 396BDFF8  addi r11, r11, -0x2008
	ctx.r[11].s64 = ctx.r[11].s64 + -8200;
	// 821EAA34: 419A0080  beq cr6, 0x821eaab4
	if ctx.cr[6].eq {
	pc = 0x821EAAB4; continue 'dispatch;
	}
	// 821EAA38: 814B2000  lwz r10, 0x2000(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821EAA3C: 813F0038  lwz r9, 0x38(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821EAA40: 7D484838  and r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & ctx.r[9].u64;
	// 821EAA44: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821EAA48: 409A003C  bne cr6, 0x821eaa84
	if !ctx.cr[6].eq {
	pc = 0x821EAA84; continue 'dispatch;
	}
	// 821EAA4C: 810B2004  lwz r8, 0x2004(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAA50: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 821EAA54: 38FF0030  addi r7, r31, 0x30
	ctx.r[7].s64 = ctx.r[31].s64 + 48;
	// 821EAA58: 55061838  slwi r6, r8, 3
	ctx.r[6].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821EAA5C: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 821EAA60: 7CE6592E  stwx r7, r6, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u32) };
	// 821EAA64: 808B2004  lwz r4, 0x2004(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAA68: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821EAA6C: 54891838  slwi r9, r4, 3
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EAA70: 7C695A14  add r3, r9, r11
	ctx.r[3].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821EAA74: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821EAA78: 814B2004  lwz r10, 0x2004(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAA7C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821EAA80: 914B2004  stw r10, 0x2004(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8196 as u32), ctx.r[10].u32 ) };
	pc = 0x821EAA84; continue 'dispatch;
            }
            0x821EAA84 => {
    //   block [0x821EAA84..0x821EAAB4)
	// 821EAA84: 897F0044  lbz r11, 0x44(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) } as u64;
	// 821EAA88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821EAA8C: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 821EAA90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EAA94: 409A0020  bne cr6, 0x821eaab4
	if !ctx.cr[6].eq {
	pc = 0x821EAAB4; continue 'dispatch;
	}
	// 821EAA98: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EAA9C: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	// 821EAAA0: 393F0030  addi r9, r31, 0x30
	ctx.r[9].s64 = ctx.r[31].s64 + 48;
	// 821EAAA4: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821EAAA8: 997F0044  stb r11, 0x44(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u8 ) };
	// 821EAAAC: 90B90DB0  stw r5, 0xdb0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(3504 as u32), ctx.r[5].u32 ) };
	// 821EAAB0: 7D2AB12E  stwx r9, r10, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), ctx.r[9].u32) };
	pc = 0x821EAAB4; continue 'dispatch;
            }
            0x821EAAB4 => {
    //   block [0x821EAAB4..0x821EAAFC)
	// 821EAAB4: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821EAAB8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821EAABC: 392BDED4  addi r9, r11, -0x212c
	ctx.r[9].s64 = ctx.r[11].s64 + -8492;
	// 821EAAC0: 7958FFE6  rldicr r24, r10, 0x3f, 0x3f
	ctx.r[24].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821EAAC4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAAC8: 83CB0300  lwz r30, 0x300(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(768 as u32) ) } as u64;
	// 821EAACC: 83AB02F4  lwz r29, 0x2f4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(756 as u32) ) } as u64;
	// 821EAAD0: 836B0660  lwz r27, 0x660(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1632 as u32) ) } as u64;
	// 821EAAD4: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 821EAAD8: 41980024  blt cr6, 0x821eaafc
	if ctx.cr[6].lt {
	pc = 0x821EAAFC; continue 'dispatch;
	}
	// 821EAADC: 397E0020  addi r11, r30, 0x20
	ctx.r[11].s64 = ctx.r[30].s64 + 32;
	// 821EAAE0: 80750364  lwz r3, 0x364(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EAAE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821EAAE8: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAAEC: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821EAAF0: 7F065436  srd r6, r24, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[24].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821EAAF4: 4BFCC3ED  bl 0x821b6ee0
	ctx.lr = 0x821EAAF8;
	sub_821B6EE0(ctx, base);
	// 821EAAF8: 80B90DB0  lwz r5, 0xdb0(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x821EAAFC; continue 'dispatch;
            }
            0x821EAAFC => {
    //   block [0x821EAAFC..0x821EAB84)
	// 821EAAFC: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821EAB00: 395F0AB0  addi r10, r31, 0xab0
	ctx.r[10].s64 = ctx.r[31].s64 + 2736;
	// 821EAB04: 7D3E5A14  add r9, r30, r11
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 821EAB08: 3D608331  lis r11, -0x7ccf
	ctx.r[11].s64 = -2093940736;
	// 821EAB0C: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EAB10: 3BCB6F38  addi r30, r11, 0x6f38
	ctx.r[30].s64 = ctx.r[11].s64 + 28472;
	// 821EAB14: 7D695214  add r11, r9, r10
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821EAB18: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EAB1C: 88EB0015  lbz r7, 0x15(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821EAB20: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAB24: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	// 821EAB28: 1D472008  mulli r10, r7, 0x2008
	ctx.r[10].s32 = ((ctx.r[7].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821EAB2C: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 821EAB30: 7F044040  cmplw cr6, r4, r8
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821EAB34: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821EAB38: 419A0070  beq cr6, 0x821eaba8
	if ctx.cr[6].eq {
	pc = 0x821EABA8; continue 'dispatch;
	}
	// 821EAB3C: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821EAB40: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EAB44: 7CE44038  and r4, r7, r8
	ctx.r[4].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 821EAB48: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821EAB4C: 409A0038  bne cr6, 0x821eab84
	if !ctx.cr[6].eq {
	pc = 0x821EAB84; continue 'dispatch;
	}
	// 821EAB50: 808A2004  lwz r4, 0x2004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAB54: 7CE34378  or r3, r7, r8
	ctx.r[3].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 821EAB58: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EAB5C: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 821EAB60: 7D68512E  stwx r11, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821EAB64: 808A2004  lwz r4, 0x2004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAB68: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EAB6C: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAB70: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821EAB74: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821EAB78: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAB7C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821EAB80: 910A2004  stw r8, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	pc = 0x821EAB84; continue 'dispatch;
            }
            0x821EAB84 => {
    //   block [0x821EAB84..0x821EABA8)
	// 821EAB84: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EAB88: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821EAB8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EAB90: 409A0018  bne cr6, 0x821eaba8
	if !ctx.cr[6].eq {
	pc = 0x821EABA8; continue 'dispatch;
	}
	// 821EAB94: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EAB98: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 821EAB9C: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821EABA0: 90B90DB0  stw r5, 0xdb0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(3504 as u32), ctx.r[5].u32 ) };
	// 821EABA4: 7D6AB12E  stwx r11, r10, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), ctx.r[11].u32) };
	pc = 0x821EABA8; continue 'dispatch;
            }
            0x821EABA8 => {
    //   block [0x821EABA8..0x821EAC1C)
	// 821EABA8: 397F0C90  addi r11, r31, 0xc90
	ctx.r[11].s64 = ctx.r[31].s64 + 3216;
	// 821EABAC: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EABB0: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821EABB4: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 821EABB8: 88CB0015  lbz r6, 0x15(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821EABBC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EABC0: 1D462008  mulli r10, r6, 0x2008
	ctx.r[10].s32 = ((ctx.r[6].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821EABC4: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 821EABC8: 7F044040  cmplw cr6, r4, r8
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821EABCC: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821EABD0: 419A0070  beq cr6, 0x821eac40
	if ctx.cr[6].eq {
	pc = 0x821EAC40; continue 'dispatch;
	}
	// 821EABD4: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821EABD8: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EABDC: 7D064838  and r6, r8, r9
	ctx.r[6].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821EABE0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821EABE4: 409A0038  bne cr6, 0x821eac1c
	if !ctx.cr[6].eq {
	pc = 0x821EAC1C; continue 'dispatch;
	}
	// 821EABE8: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EABEC: 7D044B78  or r4, r8, r9
	ctx.r[4].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821EABF0: 54C31838  slwi r3, r6, 3
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821EABF4: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 821EABF8: 7D63512E  stwx r11, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821EABFC: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAC00: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAC04: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EAC08: 7CC95214  add r6, r9, r10
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821EAC0C: 91060004  stw r8, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821EAC10: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAC14: 38890001  addi r4, r9, 1
	ctx.r[4].s64 = ctx.r[9].s64 + 1;
	// 821EAC18: 908A2004  stw r4, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[4].u32 ) };
	pc = 0x821EAC1C; continue 'dispatch;
            }
            0x821EAC1C => {
    //   block [0x821EAC1C..0x821EAC40)
	// 821EAC1C: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EAC20: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821EAC24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EAC28: 409A0018  bne cr6, 0x821eac40
	if !ctx.cr[6].eq {
	pc = 0x821EAC40; continue 'dispatch;
	}
	// 821EAC2C: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EAC30: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 821EAC34: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821EAC38: 90B90DB0  stw r5, 0xdb0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(3504 as u32), ctx.r[5].u32 ) };
	// 821EAC3C: 7D6AB12E  stwx r11, r10, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), ctx.r[11].u32) };
	pc = 0x821EAC40; continue 'dispatch;
            }
            0x821EAC40 => {
    //   block [0x821EAC40..0x821EAC80)
	// 821EAC40: 81520000  lwz r10, 0(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EAC44: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821EAC48: 5549077A  rlwinm r9, r10, 0, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821EAC4C: 3B8BB0BC  addi r28, r11, -0x4f44
	ctx.r[28].s64 = ctx.r[11].s64 + -20292;
	// 821EAC50: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821EAC54: 419A0168  beq cr6, 0x821eadbc
	if ctx.cr[6].eq {
	pc = 0x821EADBC; continue 'dispatch;
	}
	// 821EAC58: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821EAC5C: 41980024  blt cr6, 0x821eac80
	if ctx.cr[6].lt {
	pc = 0x821EAC80; continue 'dispatch;
	}
	// 821EAC60: 397D0020  addi r11, r29, 0x20
	ctx.r[11].s64 = ctx.r[29].s64 + 32;
	// 821EAC64: 80750364  lwz r3, 0x364(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EAC68: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821EAC6C: 80B70004  lwz r5, 4(r23)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAC70: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821EAC74: 7F065436  srd r6, r24, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[24].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821EAC78: 4BFCC269  bl 0x821b6ee0
	ctx.lr = 0x821EAC7C;
	sub_821B6EE0(ctx, base);
	// 821EAC7C: 80B90DB0  lwz r5, 0xdb0(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x821EAC80; continue 'dispatch;
            }
            0x821EAC80 => {
    //   block [0x821EAC80..0x821EAD04)
	// 821EAC80: 57AA083C  slwi r10, r29, 1
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EAC84: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EAC88: 397F0AB0  addi r11, r31, 0xab0
	ctx.r[11].s64 = ctx.r[31].s64 + 2736;
	// 821EAC8C: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 821EAC90: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 821EAC94: 55461838  slwi r6, r10, 3
	ctx.r[6].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821EAC98: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 821EAC9C: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821EACA0: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EACA4: 1D482008  mulli r10, r8, 0x2008
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821EACA8: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 821EACAC: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821EACB0: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821EACB4: 419A0074  beq cr6, 0x821ead28
	if ctx.cr[6].eq {
	pc = 0x821EAD28; continue 'dispatch;
	}
	// 821EACB8: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821EACBC: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EACC0: 7CE34038  and r3, r7, r8
	ctx.r[3].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 821EACC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821EACC8: 409A003C  bne cr6, 0x821ead04
	if !ctx.cr[6].eq {
	pc = 0x821EAD04; continue 'dispatch;
	}
	// 821EACCC: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EACD0: 7CE84378  or r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 821EACD4: 55271838  slwi r7, r9, 3
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 821EACD8: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821EACDC: 7D67512E  stwx r11, r7, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821EACE0: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EACE4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EACE8: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EACEC: 7D095214  add r8, r9, r10
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821EACF0: 90680004  stw r3, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 821EACF4: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EACF8: 38E80001  addi r7, r8, 1
	ctx.r[7].s64 = ctx.r[8].s64 + 1;
	// 821EACFC: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EAD00: 90EA2004  stw r7, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[7].u32 ) };
	pc = 0x821EAD04; continue 'dispatch;
            }
            0x821EAD04 => {
    //   block [0x821EAD04..0x821EAD28)
	// 821EAD04: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EAD08: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 821EAD0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EAD10: 409A0018  bne cr6, 0x821ead28
	if !ctx.cr[6].eq {
	pc = 0x821EAD28; continue 'dispatch;
	}
	// 821EAD14: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EAD18: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 821EAD1C: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821EAD20: 90B90DB0  stw r5, 0xdb0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(3504 as u32), ctx.r[5].u32 ) };
	// 821EAD24: 7D6AB12E  stwx r11, r10, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), ctx.r[11].u32) };
	pc = 0x821EAD28; continue 'dispatch;
            }
            0x821EAD28 => {
    //   block [0x821EAD28..0x821EAD94)
	// 821EAD28: 397F0C90  addi r11, r31, 0xc90
	ctx.r[11].s64 = ctx.r[31].s64 + 3216;
	// 821EAD2C: 7D665A14  add r11, r6, r11
	ctx.r[11].u64 = ctx.r[6].u64 + ctx.r[11].u64;
	// 821EAD30: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821EAD34: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAD38: 1D4A2008  mulli r10, r10, 0x2008
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821EAD3C: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 821EAD40: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821EAD44: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821EAD48: 419A009C  beq cr6, 0x821eade4
	if ctx.cr[6].eq {
	pc = 0x821EADE4; continue 'dispatch;
	}
	// 821EAD4C: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821EAD50: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EAD54: 7CE64038  and r6, r7, r8
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 821EAD58: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821EAD5C: 409A0038  bne cr6, 0x821ead94
	if !ctx.cr[6].eq {
	pc = 0x821EAD94; continue 'dispatch;
	}
	// 821EAD60: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAD64: 7CE44378  or r4, r7, r8
	ctx.r[4].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 821EAD68: 54C31838  slwi r3, r6, 3
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821EAD6C: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 821EAD70: 7D63512E  stwx r11, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821EAD74: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAD78: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAD7C: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EAD80: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821EAD84: 90E60004  stw r7, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821EAD88: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAD8C: 38880001  addi r4, r8, 1
	ctx.r[4].s64 = ctx.r[8].s64 + 1;
	// 821EAD90: 908A2004  stw r4, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[4].u32 ) };
	pc = 0x821EAD94; continue 'dispatch;
            }
            0x821EAD94 => {
    //   block [0x821EAD94..0x821EADBC)
	// 821EAD94: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EAD98: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821EAD9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EADA0: 409A0044  bne cr6, 0x821eade4
	if !ctx.cr[6].eq {
	pc = 0x821EADE4; continue 'dispatch;
	}
	// 821EADA4: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EADA8: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 821EADAC: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821EADB0: 90B90DB0  stw r5, 0xdb0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(3504 as u32), ctx.r[5].u32 ) };
	// 821EADB4: 7D6AB12E  stwx r11, r10, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), ctx.r[11].u32) };
	// 821EADB8: 4800002C  b 0x821eade4
	pc = 0x821EADE4; continue 'dispatch;
            }
            0x821EADBC => {
    //   block [0x821EADBC..0x821EADE4)
	// 821EADBC: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821EADC0: 41980024  blt cr6, 0x821eade4
	if ctx.cr[6].lt {
	pc = 0x821EADE4; continue 'dispatch;
	}
	// 821EADC4: 397D0020  addi r11, r29, 0x20
	ctx.r[11].s64 = ctx.r[29].s64 + 32;
	// 821EADC8: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EADCC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821EADD0: 80750364  lwz r3, 0x364(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EADD4: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821EADD8: 7F065436  srd r6, r24, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[24].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821EADDC: 4BFCC105  bl 0x821b6ee0
	ctx.lr = 0x821EADE0;
	sub_821B6EE0(ctx, base);
	// 821EADE0: 80B90DB0  lwz r5, 0xdb0(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x821EADE4; continue 'dispatch;
            }
            0x821EADE4 => {
    //   block [0x821EADE4..0x821EAE2C)
	// 821EADE4: 81720204  lwz r11, 0x204(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(516 as u32) ) } as u64;
	// 821EADE8: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821EADEC: 419A0180  beq cr6, 0x821eaf6c
	if ctx.cr[6].eq {
	pc = 0x821EAF6C; continue 'dispatch;
	}
	// 821EADF0: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 821EADF4: 41980038  blt cr6, 0x821eae2c
	if ctx.cr[6].lt {
	pc = 0x821EAE2C; continue 'dispatch;
	}
	// 821EADF8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 821EADFC: 80750364  lwz r3, 0x364(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EAE00: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EAE04: 390AF7A8  addi r8, r10, -0x858
	ctx.r[8].s64 = ctx.r[10].s64 + -2136;
	// 821EAE08: 38FB0020  addi r7, r27, 0x20
	ctx.r[7].s64 = ctx.r[27].s64 + 32;
	// 821EAE0C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821EAE10: 78E60020  clrldi r6, r7, 0x20
	ctx.r[6].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 821EAE14: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAE18: 7F063436  srd r6, r24, r6
	if (ctx.r[6].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[24].u64) >> ((ctx.r[6].u8 & 0x3F) as u32);
	}
	// 821EAE1C: 7CA9582E  lwzx r5, r9, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821EAE20: 80A50078  lwz r5, 0x78(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(120 as u32) ) } as u64;
	// 821EAE24: 4BFCC0BD  bl 0x821b6ee0
	ctx.lr = 0x821EAE28;
	sub_821B6EE0(ctx, base);
	// 821EAE28: 80B90DB0  lwz r5, 0xdb0(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(3504 as u32) ) } as u64;
	pc = 0x821EAE2C; continue 'dispatch;
            }
            0x821EAE2C => {
    //   block [0x821EAE2C..0x821EAEAC)
	// 821EAE2C: 576A083C  slwi r10, r27, 1
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EAE30: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EAE34: 397F0AB0  addi r11, r31, 0xab0
	ctx.r[11].s64 = ctx.r[31].s64 + 2736;
	// 821EAE38: 7CFB5214  add r7, r27, r10
	ctx.r[7].u64 = ctx.r[27].u64 + ctx.r[10].u64;
	// 821EAE3C: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	// 821EAE40: 54E91838  slwi r9, r7, 3
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EAE44: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821EAE48: 888B0015  lbz r4, 0x15(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821EAE4C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAE50: 1D442008  mulli r10, r4, 0x2008
	ctx.r[10].s32 = ((ctx.r[4].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821EAE54: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 821EAE58: 7F034040  cmplw cr6, r3, r8
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821EAE5C: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821EAE60: 419A0070  beq cr6, 0x821eaed0
	if ctx.cr[6].eq {
	pc = 0x821EAED0; continue 'dispatch;
	}
	// 821EAE64: 810A2000  lwz r8, 0x2000(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821EAE68: 80EB0008  lwz r7, 8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EAE6C: 7CE44038  and r4, r7, r8
	ctx.r[4].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 821EAE70: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821EAE74: 409A0038  bne cr6, 0x821eaeac
	if !ctx.cr[6].eq {
	pc = 0x821EAEAC; continue 'dispatch;
	}
	// 821EAE78: 808A2004  lwz r4, 0x2004(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAE7C: 7CE34378  or r3, r7, r8
	ctx.r[3].u64 = ctx.r[7].u64 | ctx.r[8].u64;
	// 821EAE80: 54881838  slwi r8, r4, 3
	ctx.r[8].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EAE84: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 821EAE88: 7D68512E  stwx r11, r8, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821EAE8C: 80EA2004  lwz r7, 0x2004(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAE90: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAE94: 54E81838  slwi r8, r7, 3
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EAE98: 7C685214  add r3, r8, r10
	ctx.r[3].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821EAE9C: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 821EAEA0: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAEA4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 821EAEA8: 910A2004  stw r8, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[8].u32 ) };
	pc = 0x821EAEAC; continue 'dispatch;
            }
            0x821EAEAC => {
    //   block [0x821EAEAC..0x821EAED0)
	// 821EAEAC: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EAEB0: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 821EAEB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EAEB8: 409A0018  bne cr6, 0x821eaed0
	if !ctx.cr[6].eq {
	pc = 0x821EAED0; continue 'dispatch;
	}
	// 821EAEBC: 54AA103A  slwi r10, r5, 2
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EAEC0: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 821EAEC4: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 821EAEC8: 90B90DB0  stw r5, 0xdb0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(3504 as u32), ctx.r[5].u32 ) };
	// 821EAECC: 7D6AB12E  stwx r11, r10, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[22].u32), ctx.r[11].u32) };
	pc = 0x821EAED0; continue 'dispatch;
            }
            0x821EAED0 => {
    //   block [0x821EAED0..0x821EAF44)
	// 821EAED0: 397F0C90  addi r11, r31, 0xc90
	ctx.r[11].s64 = ctx.r[31].s64 + 3216;
	// 821EAED4: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EAED8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 821EAEDC: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 821EAEE0: 88CB0015  lbz r6, 0x15(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 821EAEE4: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAEE8: 1D462008  mulli r10, r6, 0x2008
	ctx.r[10].s32 = ((ctx.r[6].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821EAEEC: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 821EAEF0: 7F044040  cmplw cr6, r4, r8
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[8].u32, &mut ctx.xer);
	// 821EAEF4: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821EAEF8: 419A0098  beq cr6, 0x821eaf90
	if ctx.cr[6].eq {
	pc = 0x821EAF90; continue 'dispatch;
	}
	// 821EAEFC: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821EAF00: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EAF04: 7D064838  and r6, r8, r9
	ctx.r[6].u64 = ctx.r[8].u64 & ctx.r[9].u64;
	// 821EAF08: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821EAF0C: 409A0038  bne cr6, 0x821eaf44
	if !ctx.cr[6].eq {
	pc = 0x821EAF44; continue 'dispatch;
	}
	// 821EAF10: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAF14: 7D044B78  or r4, r8, r9
	ctx.r[4].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 821EAF18: 54C31838  slwi r3, r6, 3
	ctx.r[3].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821EAF1C: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 821EAF20: 7D63512E  stwx r11, r3, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	// 821EAF24: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAF28: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAF2C: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EAF30: 7CC95214  add r6, r9, r10
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821EAF34: 91060004  stw r8, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821EAF38: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EAF3C: 38890001  addi r4, r9, 1
	ctx.r[4].s64 = ctx.r[9].s64 + 1;
	// 821EAF40: 908A2004  stw r4, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[4].u32 ) };
	pc = 0x821EAF44; continue 'dispatch;
            }
            0x821EAF44 => {
    //   block [0x821EAF44..0x821EAF6C)
	// 821EAF44: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EAF48: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821EAF4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EAF50: 409A0040  bne cr6, 0x821eaf90
	if !ctx.cr[6].eq {
	pc = 0x821EAF90; continue 'dispatch;
	}
	// 821EAF54: 54A9103A  slwi r9, r5, 2
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EAF58: 9A8B0014  stb r20, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[20].u8 ) };
	// 821EAF5C: 39450001  addi r10, r5, 1
	ctx.r[10].s64 = ctx.r[5].s64 + 1;
	// 821EAF60: 91590DB0  stw r10, 0xdb0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(3504 as u32), ctx.r[10].u32 ) };
	// 821EAF64: 7D69B12E  stwx r11, r9, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[22].u32), ctx.r[11].u32) };
	// 821EAF68: 48000028  b 0x821eaf90
	pc = 0x821EAF90; continue 'dispatch;
            }
            0x821EAF6C => {
    //   block [0x821EAF6C..0x821EAF90)
	// 821EAF6C: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 821EAF70: 41980020  blt cr6, 0x821eaf90
	if ctx.cr[6].lt {
	pc = 0x821EAF90; continue 'dispatch;
	}
	// 821EAF74: 397B0020  addi r11, r27, 0x20
	ctx.r[11].s64 = ctx.r[27].s64 + 32;
	// 821EAF78: 80BC0004  lwz r5, 4(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAF7C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821EAF80: 80750364  lwz r3, 0x364(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EAF84: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 821EAF88: 7F065436  srd r6, r24, r10
	if (ctx.r[10].u8 & 0x40) != 0 {
		ctx.r[6].u64 = 0;
	} else {
		ctx.r[6].u64 = (ctx.r[24].u64) >> ((ctx.r[10].u8 & 0x3F) as u32);
	}
	// 821EAF8C: 4BFCBF55  bl 0x821b6ee0
	ctx.lr = 0x821EAF90;
	sub_821B6EE0(ctx, base);
	pc = 0x821EAF90; continue 'dispatch;
            }
            0x821EAF90 => {
    //   block [0x821EAF90..0x821EAFF4)
	// 821EAF90: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 821EAF94: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821EAF98: 394B60B8  addi r10, r11, 0x60b8
	ctx.r[10].s64 = ctx.r[11].s64 + 24760;
	// 821EAF9C: 83EB60B8  lwz r31, 0x60b8(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24760 as u32) ) } as u64;
	// 821EAFA0: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAFA4: 83AA0008  lwz r29, 8(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EAFA8: 838A000C  lwz r28, 0xc(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EAFAC: 48050E05  bl 0x8223bdb0
	ctx.lr = 0x821EAFB0;
	sub_8223BDB0(ctx, base);
	// 821EAFB0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821EAFB4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 821EAFB8: 48085D19  bl 0x82270cd0
	ctx.lr = 0x821EAFBC;
	sub_82270CD0(ctx, base);
	// 821EAFBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821EAFC0: 38600160  li r3, 0x160
	ctx.r[3].s64 = 352;
	// 821EAFC4: 4BFDD14D  bl 0x821c8110
	ctx.lr = 0x821EAFC8;
	sub_821C8110(ctx, base);
	// 821EAFC8: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821EAFCC: E9691760  ld r11, 0x1760(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(5984 as u32) ) };
	// 821EAFD0: 79680004  rldicr r8, r11, 0, 0
	ctx.r[8].u64 = (ctx.r[11].u64).rotate_left(0) & 0x8000000000000000;
	// 821EAFD4: 2B280000  cmpldi cr6, r8, 0
	ctx.cr[6].compare_u64(ctx.r[8].u64, 0, &mut ctx.xer);
	// 821EAFD8: 419A001C  beq cr6, 0x821eaff4
	if ctx.cr[6].eq {
	pc = 0x821EAFF4; continue 'dispatch;
	}
	// 821EAFDC: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 821EAFE0: 80750364  lwz r3, 0x364(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EAFE4: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 821EAFE8: 38B106B0  addi r5, r17, 0x6b0
	ctx.r[5].s64 = ctx.r[17].s64 + 1712;
	// 821EAFEC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821EAFF0: 4802F891  bl 0x8221a880
	ctx.lr = 0x821EAFF4;
	sub_8221A880(ctx, base);
	pc = 0x821EAFF4; continue 'dispatch;
            }
            0x821EAFF4 => {
    //   block [0x821EAFF4..0x821EB118)
	// 821EAFF4: 81710004  lwz r11, 4(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EAFF8: 39400050  li r10, 0x50
	ctx.r[10].s64 = 80;
	// 821EAFFC: 3860001A  li r3, 0x1a
	ctx.r[3].s64 = 26;
	pc = 0x821EB118; continue 'dispatch;
            }
            0x821EB118 => {
    //   block [0x821EB118..0x821EB130)
	// 821EB118: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821EB11C: 480341C5  bl 0x8221f2e0
	ctx.lr = 0x821EB120;
	sub_8221F2E0(ctx, base);
	// 821EB120: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 821EB124: CBC1FF70  lfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 821EB128: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 821EB12C: 48ABE300  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EB130 size=192
    let mut pc: u32 = 0x821EB130;
    'dispatch: loop {
        match pc {
            0x821EB130 => {
    //   block [0x821EB130..0x821EB1F0)
	// 821EB130: 3D40834C  lis r10, -0x7cb4
	ctx.r[10].s64 = -2092171264;
	// 821EB134: 39800020  li r12, 0x20
	ctx.r[12].s64 = 32;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EB1F0 size=108
    let mut pc: u32 = 0x821EB1F0;
    'dispatch: loop {
        match pc {
            0x821EB1F0 => {
    //   block [0x821EB1F0..0x821EB25C)
	// 821EB1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB1F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EB1F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EB1FC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 821EB200: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EB260 size=76
    let mut pc: u32 = 0x821EB260;
    'dispatch: loop {
        match pc {
            0x821EB260 => {
    //   block [0x821EB260..0x821EB2AC)
	// 821EB260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EB268: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EB26C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EB270: 8146001C  lwz r10, 0x1c(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821EB274: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821EB278: 8085001C  lwz r4, 0x1c(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 821EB27C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821EB280: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821EB284: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 821EB288: 386BFFF8  addi r3, r11, -8
	ctx.r[3].s64 = ctx.r[11].s64 + -8;
	// 821EB28C: 480001C5  bl 0x821eb450
	ctx.lr = 0x821EB290;
	sub_821EB450(ctx, base);
	// 821EB290: 987F0000  stb r3, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u8 ) };
	// 821EB294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EB298: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821EB29C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EB2A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EB2A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EB2A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB2B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EB2B0 size=76
    let mut pc: u32 = 0x821EB2B0;
    'dispatch: loop {
        match pc {
            0x821EB2B0 => {
    //   block [0x821EB2B0..0x821EB2FC)
	// 821EB2B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB2B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EB2B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EB2BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EB2C0: 8146001C  lwz r10, 0x1c(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 821EB2C4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 821EB2C8: 80850024  lwz r4, 0x24(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 821EB2CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821EB2D0: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821EB2D4: 7D455378  mr r5, r10
	ctx.r[5].u64 = ctx.r[10].u64;
	// 821EB2D8: 386BFFEC  addi r3, r11, -0x14
	ctx.r[3].s64 = ctx.r[11].s64 + -20;
	// 821EB2DC: 48000175  bl 0x821eb450
	ctx.lr = 0x821EB2E0;
	sub_821EB450(ctx, base);
	// 821EB2E0: 987F0000  stb r3, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u8 ) };
	// 821EB2E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EB2E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821EB2EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EB2F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EB2F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EB2F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EB300 size=332
    let mut pc: u32 = 0x821EB300;
    'dispatch: loop {
        match pc {
            0x821EB300 => {
    //   block [0x821EB300..0x821EB32C)
	// 821EB300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EB308: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EB30C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EB310: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821EB314: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB318: 2F04FFFF  cmpwi cr6, r4, -1
	ctx.cr[6].compare_i32(ctx.r[4].s32, -1, &mut ctx.xer);
	// 821EB31C: 409A0024  bne cr6, 0x821eb340
	if !ctx.cr[6].eq {
	pc = 0x821EB340; continue 'dispatch;
	}
	// 821EB320: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EB324: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB328: 419A0084  beq cr6, 0x821eb3ac
	if ctx.cr[6].eq {
	pc = 0x821EB3AC; continue 'dispatch;
	}
	pc = 0x821EB32C; continue 'dispatch;
            }
            0x821EB32C => {
    //   block [0x821EB32C..0x821EB340)
	// 821EB32C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821EB330: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EB334: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB338: 409AFFF4  bne cr6, 0x821eb32c
	if !ctx.cr[6].eq {
	pc = 0x821EB32C; continue 'dispatch;
	}
	// 821EB33C: 48000070  b 0x821eb3ac
	pc = 0x821EB3AC; continue 'dispatch;
            }
            0x821EB340 => {
    //   block [0x821EB340..0x821EB34C)
	// 821EB340: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EB344: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB348: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	pc = 0x821EB34C; continue 'dispatch;
            }
            0x821EB34C => {
    //   block [0x821EB34C..0x821EB39C)
	// 821EB34C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB350: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EB354: 38EA0044  addi r7, r10, 0x44
	ctx.r[7].s64 = ctx.r[10].s64 + 68;
	// 821EB358: 54E6103A  slwi r6, r7, 2
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 821EB35C: 7D46482E  lwzx r10, r6, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821EB360: 5545077A  rlwinm r5, r10, 0, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821EB364: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 821EB368: 409A005C  bne cr6, 0x821eb3c4
	if !ctx.cr[6].eq {
	pc = 0x821EB3C4; continue 'dispatch;
	}
	// 821EB36C: 55470294  rlwinm r7, r10, 0, 0xa, 0xa
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821EB370: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821EB374: 409A007C  bne cr6, 0x821eb3f0
	if !ctx.cr[6].eq {
	pc = 0x821EB3F0; continue 'dispatch;
	}
	// 821EB378: 554A035A  rlwinm r10, r10, 0, 0xd, 0xd
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821EB37C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821EB380: 409A00AC  bne cr6, 0x821eb42c
	if !ctx.cr[6].eq {
	pc = 0x821EB42C; continue 'dispatch;
	}
	// 821EB384: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EB388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB38C: 409AFFC0  bne cr6, 0x821eb34c
	if !ctx.cr[6].eq {
	pc = 0x821EB34C; continue 'dispatch;
	}
	// 821EB390: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821EB394: 419A0018  beq cr6, 0x821eb3ac
	if ctx.cr[6].eq {
	pc = 0x821EB3AC; continue 'dispatch;
	}
	// 821EB398: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	pc = 0x821EB39C; continue 'dispatch;
            }
            0x821EB39C => {
    //   block [0x821EB39C..0x821EB3AC)
	// 821EB39C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821EB3A0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EB3A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB3A8: 409AFFF4  bne cr6, 0x821eb39c
	if !ctx.cr[6].eq {
	pc = 0x821EB39C; continue 'dispatch;
	}
	pc = 0x821EB3AC; continue 'dispatch;
            }
            0x821EB3AC => {
    //   block [0x821EB3AC..0x821EB3C4)
	// 821EB3AC: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821EB3B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821EB3B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EB3B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EB3BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EB3C0: 4E800020  blr
	return;
            }
            0x821EB3C4 => {
    //   block [0x821EB3C4..0x821EB3F0)
	// 821EB3C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB3C8: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 821EB3CC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB3D0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB3D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821EB3D8: 4E800421  bctrl
	ctx.lr = 0x821EB3DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821EB3DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821EB3E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EB3E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EB3E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EB3EC: 4E800020  blr
	return;
            }
            0x821EB3F0 => {
    //   block [0x821EB3F0..0x821EB42C)
	// 821EB3F0: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB3F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB3F8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EB3FC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821EB400: 4E800421  bctrl
	ctx.lr = 0x821EB404;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821EB404: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB408: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB40C: 81090010  lwz r8, 0x10(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB410: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 821EB414: 4E800421  bctrl
	ctx.lr = 0x821EB418;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821EB418: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821EB41C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EB420: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EB424: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EB428: 4E800020  blr
	return;
            }
            0x821EB42C => {
    //   block [0x821EB42C..0x821EB438)
	// 821EB42C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821EB430: 419AFF7C  beq cr6, 0x821eb3ac
	if ctx.cr[6].eq {
	pc = 0x821EB3AC; continue 'dispatch;
	}
	// 821EB434: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	pc = 0x821EB438; continue 'dispatch;
            }
            0x821EB438 => {
    //   block [0x821EB438..0x821EB44C)
	// 821EB438: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821EB43C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EB440: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB444: 409AFFF4  bne cr6, 0x821eb438
	if !ctx.cr[6].eq {
	pc = 0x821EB438; continue 'dispatch;
	}
	// 821EB448: 4BFFFF64  b 0x821eb3ac
	pc = 0x821EB3AC; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EB450 size=800
    let mut pc: u32 = 0x821EB450;
    'dispatch: loop {
        match pc {
            0x821EB450 => {
    //   block [0x821EB450..0x821EB4BC)
	// 821EB450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB454: 48ABDF99  bl 0x82ca93ec
	ctx.lr = 0x821EB458;
	sub_82CA93D0(ctx, base);
	// 821EB458: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EB45C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821EB460: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 821EB464: 578B06FE  clrlwi r11, r28, 0x1b
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x0000001Fu64;
	// 821EB468: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 821EB46C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 821EB470: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 821EB474: 3AC0001F  li r22, 0x1f
	ctx.r[22].s64 = 31;
	// 821EB478: 571506FE  clrlwi r21, r24, 0x1b
	ctx.r[21].u64 = ctx.r[24].u32 as u64 & 0x0000001Fu64;
	// 821EB47C: 2B0B001F  cmplwi cr6, r11, 0x1f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 31 as u32, &mut ctx.xer);
	// 821EB480: 409A0224  bne cr6, 0x821eb6a4
	if !ctx.cr[6].eq {
	pc = 0x821EB6A4; continue 'dispatch;
	}
	// 821EB484: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 821EB488: 3BF70034  addi r31, r23, 0x34
	ctx.r[31].s64 = ctx.r[23].s64 + 52;
	// 821EB48C: 52CB043E  rlwimi r11, r22, 0, 0x10, 0x1f
	ctx.r[11].u64 = (((ctx.r[22].u32).rotate_left(0) as u64) & 0x000000000000FFFF) | (ctx.r[11].u64 & 0xFFFFFFFFFFFF0000);
	// 821EB490: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 821EB494: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821EB498: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821EB49C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821EB4A0: 48393769  bl 0x8257ec08
	ctx.lr = 0x821EB4A4;
	sub_8257EC08(ctx, base);
	// 821EB4A4: 81770038  lwz r11, 0x38(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(56 as u32) ) } as u64;
	// 821EB4A8: 83210060  lwz r25, 0x60(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821EB4AC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821EB4B0: 419A000C  beq cr6, 0x821eb4bc
	if ctx.cr[6].eq {
	pc = 0x821EB4BC; continue 'dispatch;
	}
	// 821EB4B4: 7F19F840  cmplw cr6, r25, r31
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821EB4B8: 419A0008  beq cr6, 0x821eb4c0
	if ctx.cr[6].eq {
	pc = 0x821EB4C0; continue 'dispatch;
	}
	pc = 0x821EB4BC; continue 'dispatch;
            }
            0x821EB4BC => {
    //   block [0x821EB4BC..0x821EB4C0)
	// 821EB4BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EB4C0; continue 'dispatch;
            }
            0x821EB4C0 => {
    //   block [0x821EB4C0..0x821EB514)
	// 821EB4C0: 83410064  lwz r26, 0x64(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821EB4C4: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EB4C8: 419A01D8  beq cr6, 0x821eb6a0
	if ctx.cr[6].eq {
	pc = 0x821EB6A0; continue 'dispatch;
	}
	// 821EB4CC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821EB4D0: 419A0188  beq cr6, 0x821eb658
	if ctx.cr[6].eq {
	pc = 0x821EB658; continue 'dispatch;
	}
	// 821EB4D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821EB4D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821EB4DC: 4BFD0935  bl 0x821bbe10
	ctx.lr = 0x821EB4E0;
	sub_821BBE10(ctx, base);
	// 821EB4E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821EB4E4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821EB4E8: 419A0170  beq cr6, 0x821eb658
	if ctx.cr[6].eq {
	pc = 0x821EB658; continue 'dispatch;
	}
	// 821EB4EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821EB4F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821EB4F4: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 821EB4F8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 821EB4FC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821EB500: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 821EB504: 48029395  bl 0x82214898
	ctx.lr = 0x821EB508;
	sub_82214898(ctx, base);
	// 821EB508: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821EB50C: 409A0008  bne cr6, 0x821eb514
	if !ctx.cr[6].eq {
	pc = 0x821EB514; continue 'dispatch;
	}
	// 821EB510: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EB514; continue 'dispatch;
            }
            0x821EB514 => {
    //   block [0x821EB514..0x821EB524)
	// 821EB514: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB518: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821EB51C: 409A0008  bne cr6, 0x821eb524
	if !ctx.cr[6].eq {
	pc = 0x821EB524; continue 'dispatch;
	}
	// 821EB520: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EB524; continue 'dispatch;
            }
            0x821EB524 => {
    //   block [0x821EB524..0x821EB540)
	// 821EB524: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB528: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821EB52C: 836B0008  lwz r27, 8(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EB530: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB534: 7F09D840  cmplw cr6, r9, r27
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821EB538: 40990008  ble cr6, 0x821eb540
	if !ctx.cr[6].gt {
	pc = 0x821EB540; continue 'dispatch;
	}
	// 821EB53C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EB540; continue 'dispatch;
            }
            0x821EB540 => {
    //   block [0x821EB540..0x821EB54C)
	// 821EB540: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821EB544: 409A0008  bne cr6, 0x821eb54c
	if !ctx.cr[6].eq {
	pc = 0x821EB54C; continue 'dispatch;
	}
	// 821EB548: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EB54C; continue 'dispatch;
            }
            0x821EB54C => {
    //   block [0x821EB54C..0x821EB560)
	// 821EB54C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB550: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EB554: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821EB558: 40990008  ble cr6, 0x821eb560
	if !ctx.cr[6].gt {
	pc = 0x821EB560; continue 'dispatch;
	}
	// 821EB55C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EB560; continue 'dispatch;
            }
            0x821EB560 => {
    //   block [0x821EB560..0x821EB580)
	// 821EB560: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821EB564: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	// 821EB568: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821EB56C: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821EB570: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821EB574: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821EB578: 419A0074  beq cr6, 0x821eb5ec
	if ctx.cr[6].eq {
	pc = 0x821EB5EC; continue 'dispatch;
	}
	// 821EB57C: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x821EB580; continue 'dispatch;
            }
            0x821EB580 => {
    //   block [0x821EB580..0x821EB5A0)
	// 821EB580: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB584: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB588: 419A0020  beq cr6, 0x821eb5a8
	if ctx.cr[6].eq {
	pc = 0x821EB5A8; continue 'dispatch;
	}
	// 821EB58C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB590: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EB594: 419A000C  beq cr6, 0x821eb5a0
	if ctx.cr[6].eq {
	pc = 0x821EB5A0; continue 'dispatch;
	}
	// 821EB598: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 821EB59C: 48000010  b 0x821eb5ac
	pc = 0x821EB5AC; continue 'dispatch;
            }
            0x821EB5A0 => {
    //   block [0x821EB5A0..0x821EB5A8)
	// 821EB5A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821EB5A4: 4BFA8895  bl 0x82193e38
	ctx.lr = 0x821EB5A8;
	sub_82193E38(ctx, base);
	pc = 0x821EB5A8; continue 'dispatch;
            }
            0x821EB5A8 => {
    //   block [0x821EB5A8..0x821EB5AC)
	// 821EB5A8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x821EB5AC; continue 'dispatch;
            }
            0x821EB5AC => {
    //   block [0x821EB5AC..0x821EB5C8)
	// 821EB5AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821EB5B0: 419A0024  beq cr6, 0x821eb5d4
	if ctx.cr[6].eq {
	pc = 0x821EB5D4; continue 'dispatch;
	}
	// 821EB5B4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB5B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB5BC: 419A000C  beq cr6, 0x821eb5c8
	if ctx.cr[6].eq {
	pc = 0x821EB5C8; continue 'dispatch;
	}
	// 821EB5C0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821EB5C4: 48000014  b 0x821eb5d8
	pc = 0x821EB5D8; continue 'dispatch;
            }
            0x821EB5C8 => {
    //   block [0x821EB5C8..0x821EB5D4)
	// 821EB5C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821EB5CC: 4BFA886D  bl 0x82193e38
	ctx.lr = 0x821EB5D0;
	sub_82193E38(ctx, base);
	// 821EB5D0: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x821EB5D4; continue 'dispatch;
            }
            0x821EB5D4 => {
    //   block [0x821EB5D4..0x821EB5D8)
	// 821EB5D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821EB5D8; continue 'dispatch;
            }
            0x821EB5D8 => {
    //   block [0x821EB5D8..0x821EB5EC)
	// 821EB5D8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EB5DC: 419A0010  beq cr6, 0x821eb5ec
	if ctx.cr[6].eq {
	pc = 0x821EB5EC; continue 'dispatch;
	}
	// 821EB5E0: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 821EB5E4: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 821EB5E8: 409AFF98  bne cr6, 0x821eb580
	if !ctx.cr[6].eq {
	pc = 0x821EB580; continue 'dispatch;
	}
	pc = 0x821EB5EC; continue 'dispatch;
            }
            0x821EB5EC => {
    //   block [0x821EB5EC..0x821EB610)
	// 821EB5EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821EB5F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821EB5F4: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 821EB5F8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 821EB5FC: 4BFA883D  bl 0x82193e38
	ctx.lr = 0x821EB600;
	sub_82193E38(ctx, base);
	// 821EB600: 81390004  lwz r9, 4(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB604: 7F1A4840  cmplw cr6, r26, r9
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821EB608: 409A0008  bne cr6, 0x821eb610
	if !ctx.cr[6].eq {
	pc = 0x821EB610; continue 'dispatch;
	}
	// 821EB60C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EB610; continue 'dispatch;
            }
            0x821EB610 => {
    //   block [0x821EB610..0x821EB62C)
	// 821EB610: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB614: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 821EB618: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EB61C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB620: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821EB624: 40990008  ble cr6, 0x821eb62c
	if !ctx.cr[6].gt {
	pc = 0x821EB62C; continue 'dispatch;
	}
	// 821EB628: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EB62C; continue 'dispatch;
            }
            0x821EB62C => {
    //   block [0x821EB62C..0x821EB640)
	// 821EB62C: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821EB630: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821EB634: 419A000C  beq cr6, 0x821eb640
	if ctx.cr[6].eq {
	pc = 0x821EB640; continue 'dispatch;
	}
	// 821EB638: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EB63C: 419A0008  beq cr6, 0x821eb644
	if ctx.cr[6].eq {
	pc = 0x821EB644; continue 'dispatch;
	}
	pc = 0x821EB640; continue 'dispatch;
            }
            0x821EB640 => {
    //   block [0x821EB640..0x821EB644)
	// 821EB640: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EB644; continue 'dispatch;
            }
            0x821EB644 => {
    //   block [0x821EB644..0x821EB658)
	// 821EB644: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821EB648: 419A0010  beq cr6, 0x821eb658
	if ctx.cr[6].eq {
	pc = 0x821EB658; continue 'dispatch;
	}
	// 821EB64C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821EB650: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821EB654: 48ABDDE8  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821EB658 => {
    //   block [0x821EB658..0x821EB664)
	// 821EB658: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 821EB65C: 409A0008  bne cr6, 0x821eb664
	if !ctx.cr[6].eq {
	pc = 0x821EB664; continue 'dispatch;
	}
	// 821EB660: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EB664; continue 'dispatch;
            }
            0x821EB664 => {
    //   block [0x821EB664..0x821EB674)
	// 821EB664: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB668: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EB66C: 409A0008  bne cr6, 0x821eb674
	if !ctx.cr[6].eq {
	pc = 0x821EB674; continue 'dispatch;
	}
	// 821EB670: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EB674; continue 'dispatch;
            }
            0x821EB674 => {
    //   block [0x821EB674..0x821EB6A0)
	// 821EB674: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB678: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 821EB67C: 578905B4  rlwinm r9, r28, 0, 0x16, 0x1a
	ctx.r[9].u64 = ctx.r[28].u32 as u64 & 0xFFFFFFFFu64;
	// 821EB680: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB684: 510A06FE  rlwimi r10, r8, 0, 0x1b, 0x1f
	ctx.r[10].u64 = (((ctx.r[8].u32).rotate_left(0) as u64) & 0x000000000000001F) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFFE0);
	// 821EB688: 5507001E  rlwinm r7, r8, 0, 0, 0xf
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821EB68C: 5546047E  clrlwi r6, r10, 0x11
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0x00007FFFu64;
	// 821EB690: 54C606EA  rlwinm r6, r6, 0, 0x1b, 0x15
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 821EB694: 7CC53B78  or r5, r6, r7
	ctx.r[5].u64 = ctx.r[6].u64 | ctx.r[7].u64;
	// 821EB698: 7CBC4B78  or r28, r5, r9
	ctx.r[28].u64 = ctx.r[5].u64 | ctx.r[9].u64;
	// 821EB69C: 48000008  b 0x821eb6a4
	pc = 0x821EB6A4; continue 'dispatch;
            }
            0x821EB6A0 => {
    //   block [0x821EB6A0..0x821EB6A4)
	// 821EB6A0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x821EB6A4; continue 'dispatch;
            }
            0x821EB6A4 => {
    //   block [0x821EB6A4..0x821EB6E4)
	// 821EB6A4: 2B15001F  cmplwi cr6, r21, 0x1f
	ctx.cr[6].compare_u32(ctx.r[21].u32, 31 as u32, &mut ctx.xer);
	// 821EB6A8: 409A0098  bne cr6, 0x821eb740
	if !ctx.cr[6].eq {
	pc = 0x821EB740; continue 'dispatch;
	}
	// 821EB6AC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 821EB6B0: 3BF70034  addi r31, r23, 0x34
	ctx.r[31].s64 = ctx.r[23].s64 + 52;
	// 821EB6B4: 52CB043E  rlwimi r11, r22, 0, 0x10, 0x1f
	ctx.r[11].u64 = (((ctx.r[22].u32).rotate_left(0) as u64) & 0x000000000000FFFF) | (ctx.r[11].u64 & 0xFFFFFFFFFFFF0000);
	// 821EB6B8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 821EB6BC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 821EB6C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821EB6C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821EB6C8: 48393541  bl 0x8257ec08
	ctx.lr = 0x821EB6CC;
	sub_8257EC08(ctx, base);
	// 821EB6CC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821EB6D0: 81370038  lwz r9, 0x38(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(56 as u32) ) } as u64;
	// 821EB6D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB6D8: 419A000C  beq cr6, 0x821eb6e4
	if ctx.cr[6].eq {
	pc = 0x821EB6E4; continue 'dispatch;
	}
	// 821EB6DC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821EB6E0: 419A0008  beq cr6, 0x821eb6e8
	if ctx.cr[6].eq {
	pc = 0x821EB6E8; continue 'dispatch;
	}
	pc = 0x821EB6E4; continue 'dispatch;
            }
            0x821EB6E4 => {
    //   block [0x821EB6E4..0x821EB6E8)
	// 821EB6E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EB6E8; continue 'dispatch;
            }
            0x821EB6E8 => {
    //   block [0x821EB6E8..0x821EB700)
	// 821EB6E8: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821EB6EC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821EB6F0: 419A004C  beq cr6, 0x821eb73c
	if ctx.cr[6].eq {
	pc = 0x821EB73C; continue 'dispatch;
	}
	// 821EB6F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB6F8: 409A0008  bne cr6, 0x821eb700
	if !ctx.cr[6].eq {
	pc = 0x821EB700; continue 'dispatch;
	}
	// 821EB6FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EB700; continue 'dispatch;
            }
            0x821EB700 => {
    //   block [0x821EB700..0x821EB710)
	// 821EB700: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EB704: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EB708: 409A0008  bne cr6, 0x821eb710
	if !ctx.cr[6].eq {
	pc = 0x821EB710; continue 'dispatch;
	}
	// 821EB70C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EB710; continue 'dispatch;
            }
            0x821EB710 => {
    //   block [0x821EB710..0x821EB73C)
	// 821EB710: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB714: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 821EB718: 570905B4  rlwinm r9, r24, 0, 0x16, 0x1a
	ctx.r[9].u64 = ctx.r[24].u32 as u64 & 0xFFFFFFFFu64;
	// 821EB71C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB720: 510A06FE  rlwimi r10, r8, 0, 0x1b, 0x1f
	ctx.r[10].u64 = (((ctx.r[8].u32).rotate_left(0) as u64) & 0x000000000000001F) | (ctx.r[10].u64 & 0xFFFFFFFFFFFFFFE0);
	// 821EB724: 5507001E  rlwinm r7, r8, 0, 0, 0xf
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 821EB728: 5546047E  clrlwi r6, r10, 0x11
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0x00007FFFu64;
	// 821EB72C: 54C606EA  rlwinm r6, r6, 0, 0x1b, 0x15
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 821EB730: 7CC53B78  or r5, r6, r7
	ctx.r[5].u64 = ctx.r[6].u64 | ctx.r[7].u64;
	// 821EB734: 7CB84B78  or r24, r5, r9
	ctx.r[24].u64 = ctx.r[5].u64 | ctx.r[9].u64;
	// 821EB738: 48000008  b 0x821eb740
	pc = 0x821EB740; continue 'dispatch;
            }
            0x821EB73C => {
    //   block [0x821EB73C..0x821EB740)
	// 821EB73C: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	pc = 0x821EB740; continue 'dispatch;
            }
            0x821EB740 => {
    //   block [0x821EB740..0x821EB770)
	// 821EB740: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 821EB744: 80970030  lwz r4, 0x30(r23)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(48 as u32) ) } as u64;
	// 821EB748: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821EB74C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821EB750: 48BCB641  bl 0x82db6d90
	ctx.lr = 0x821EB754;
	sub_82DB6D90(ctx, base);
	// 821EB754: 89630000  lbz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB758: 7D6A0774  extsb r10, r11
	ctx.r[10].s64 = ctx.r[11].s8 as i64;
	// 821EB75C: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 821EB760: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 821EB764: 69030001  xori r3, r8, 1
	ctx.r[3].u64 = ctx.r[8].u64 ^ 1;
	// 821EB768: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 821EB76C: 48ABDCD0  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EB770 size=88
    let mut pc: u32 = 0x821EB770;
    'dispatch: loop {
        match pc {
            0x821EB770 => {
    //   block [0x821EB770..0x821EB7C8)
	// 821EB770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB774: 48ABDC99  bl 0x82ca940c
	ctx.lr = 0x821EB778;
	sub_82CA93D0(ctx, base);
	// 821EB778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EB77C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB780: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821EB784: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821EB788: 83A50020  lwz r29, 0x20(r5)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(32 as u32) ) } as u64;
	// 821EB78C: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 821EB790: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821EB794: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB798: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821EB79C: 4E800421  bctrl
	ctx.lr = 0x821EB7A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821EB7A0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821EB7A4: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821EB7A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821EB7AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821EB7B0: 387FFFF0  addi r3, r31, -0x10
	ctx.r[3].s64 = ctx.r[31].s64 + -16;
	// 821EB7B4: 4BFFFC9D  bl 0x821eb450
	ctx.lr = 0x821EB7B8;
	sub_821EB450(ctx, base);
	// 821EB7B8: 987E0000  stb r3, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u8 ) };
	// 821EB7BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821EB7C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821EB7C4: 48ABDC98  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB7C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EB7C8 size=140
    let mut pc: u32 = 0x821EB7C8;
    'dispatch: loop {
        match pc {
            0x821EB7C8 => {
    //   block [0x821EB7C8..0x821EB824)
	// 821EB7C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB7CC: 48ABDC35  bl 0x82ca9400
	ctx.lr = 0x821EB7D0;
	sub_82CA93D0(ctx, base);
	// 821EB7D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EB7D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821EB7D8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821EB7DC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 821EB7E0: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 821EB7E4: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 821EB7E8: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 821EB7EC: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 821EB7F0: 4BFFFB11  bl 0x821eb300
	ctx.lr = 0x821EB7F4;
	sub_821EB300(ctx, base);
	// 821EB7F4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB7F8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821EB7FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821EB800: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821EB804: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB808: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821EB80C: 4E800421  bctrl
	ctx.lr = 0x821EB810;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821EB810: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EB814: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821EB818: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821EB81C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB820: 419A0014  beq cr6, 0x821eb834
	if ctx.cr[6].eq {
	pc = 0x821EB834; continue 'dispatch;
	}
            }
            0x821EB824 => {
    //   block [0x821EB824..0x821EB834)
	// 821EB824: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 821EB828: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EB82C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EB830: 409AFFF4  bne cr6, 0x821eb824
	if !ctx.cr[6].eq {
	pc = 0x821EB824; continue 'dispatch;
	}
	pc = 0x821EB834; continue 'dispatch;
            }
            0x821EB834 => {
    //   block [0x821EB834..0x821EB854)
	// 821EB834: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821EB838: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 821EB83C: 387CFFF4  addi r3, r28, -0xc
	ctx.r[3].s64 = ctx.r[28].s64 + -12;
	// 821EB840: 4BFFFC11  bl 0x821eb450
	ctx.lr = 0x821EB844;
	sub_821EB450(ctx, base);
	// 821EB844: 987D0000  stb r3, 0(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u8 ) };
	// 821EB848: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821EB84C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821EB850: 48ABDC00  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EB858 size=112
    let mut pc: u32 = 0x821EB858;
    'dispatch: loop {
        match pc {
            0x821EB858 => {
    //   block [0x821EB858..0x821EB8B8)
	// 821EB858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB85C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EB860: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EB864: 48BCD455  bl 0x82db8cb8
	ctx.lr = 0x821EB868;
	sub_82DB8CB8(ctx, base);
	// 821EB868: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 821EB86C: 894B8FEF  lbz r10, -0x7011(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28689 as u32) ) } as u64;
	// 821EB870: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EB874: 419A0044  beq cr6, 0x821eb8b8
	if ctx.cr[6].eq {
	pc = 0x821EB8B8; continue 'dispatch;
	}
	// 821EB878: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 821EB87C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821EB880: 392B1210  addi r9, r11, 0x1210
	ctx.r[9].s64 = ctx.r[11].s64 + 4624;
	// 821EB884: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821EB888: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x821EB8B8; continue 'dispatch;
            }
            0x821EB8B8 => {
    //   block [0x821EB8B8..0x821EB8C8)
	// 821EB8B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821EB8BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EB8C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EB8C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821EB8C8 size=88
    let mut pc: u32 = 0x821EB8C8;
    'dispatch: loop {
        match pc {
            0x821EB8C8 => {
    //   block [0x821EB8C8..0x821EB920)
	// 821EB8C8: 81430060  lwz r10, 0x60(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 821EB8CC: 8163006C  lwz r11, 0x6c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 821EB8D0: 81230068  lwz r9, 0x68(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 821EB8D4: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 821EB8D8: 7D292A14  add r9, r9, r5
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[5].u64;
	// 821EB8DC: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB8E0: 7D6859D6  mullw r11, r8, r11
	ctx.r[11].s32 = ((ctx.r[8].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821EB8E4: 7D6B4A15  add. r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821EB8E8: 41800038  blt 0x821eb920
	if ctx.cr[0].lt {
		sub_821EB920(ctx, base);
		return;
	}
	// 821EB8EC: 812A0014  lwz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EB8F0: 3900000C  li r8, 0xc
	ctx.r[8].s64 = 12;
	// 821EB8F4: 80EA0010  lwz r7, 0x10(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EB8F8: 7CC74850  subf r6, r7, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 821EB8FC: 7CA643D6  divw r5, r6, r8
	ctx.r[5].s32 = ctx.r[6].s32 / ctx.r[8].s32;
	// 821EB900: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 821EB904: 4098001C  bge cr6, 0x821eb920
	if !ctx.cr[6].lt {
		sub_821EB920(ctx, base);
		return;
	}
	// 821EB908: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EB90C: 54EA003E  slwi r10, r7, 0
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EB910: 7D2B4A14  add r9, r11, r9
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821EB914: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EB918: 7C28542E  lfsx f1, r8, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821EB91C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821EB920 size=12
    let mut pc: u32 = 0x821EB920;
    'dispatch: loop {
        match pc {
            0x821EB920 => {
    //   block [0x821EB920..0x821EB92C)
	// 821EB920: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821EB924: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821EB928: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821EB930 size=156
    let mut pc: u32 = 0x821EB930;
    'dispatch: loop {
        match pc {
            0x821EB930 => {
    //   block [0x821EB930..0x821EB9CC)
	// 821EB930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB934: 48ABDAD5  bl 0x82ca9408
	ctx.lr = 0x821EB938;
	sub_82CA93D0(ctx, base);
	// 821EB938: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EB93C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821EB940: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821EB944: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 821EB948: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821EB94C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 821EB950: 80BE0008  lwz r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EB954: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EB958: 48B6BA19  bl 0x82d57370
	ctx.lr = 0x821EB95C;
	sub_82D57370(ctx, base);
	// 821EB95C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB960: C03C0004  lfs f1, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821EB964: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821EB968: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821EB96C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EB970: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 821EB974: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821EB978: 4E800421  bctrl
	ctx.lr = 0x821EB97C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821EB97C: 38BC0050  addi r5, r28, 0x50
	ctx.r[5].s64 = ctx.r[28].s64 + 80;
	// 821EB980: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821EB984: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EB988: 48B6AAF1  bl 0x82d56478
	ctx.lr = 0x821EB98C;
	sub_82D56478(ctx, base);
	// 821EB98C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 821EB990: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EB9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EB9D0 size=864
    let mut pc: u32 = 0x821EB9D0;
    'dispatch: loop {
        match pc {
            0x821EB9D0 => {
    //   block [0x821EB9D0..0x821EBD30)
	// 821EB9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EB9D4: 48ABDA05  bl 0x82ca93d8
	ctx.lr = 0x821EB9D8;
	sub_82CA93D0(ctx, base);
	// 821EB9D8: DBA1FF60  stfd f29, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[29].u64 ) };
	// 821EB9DC: DBC1FF68  stfd f30, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[30].u64 ) };
	// 821EB9E0: DBE1FF70  stfd f31, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 821EB9E4: 3980FF50  li r12, -0xb0
	ctx.r[12].s64 = -176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EBD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821EBD30 size=512
    let mut pc: u32 = 0x821EBD30;
    'dispatch: loop {
        match pc {
            0x821EBD30 => {
    //   block [0x821EBD30..0x821EBF24)
	// 821EBD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EBD34: 48ABD6D1  bl 0x82ca9404
	ctx.lr = 0x821EBD38;
	sub_82CA93D0(ctx, base);
	// 821EBD38: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821EBD3C: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EBD40: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821EBD44: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821EBD48: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EBD4C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821EBD50: 409901D4  ble cr6, 0x821ebf24
	if !ctx.cr[6].gt {
	pc = 0x821EBF24; continue 'dispatch;
	}
	// 821EBD54: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821EBD58: 3BFB0030  addi r31, r27, 0x30
	ctx.r[31].s64 = ctx.r[27].s64 + 48;
	// 821EBD5C: C3EB0AFC  lfs f31, 0xafc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2812 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821EBD60: 396100F0  addi r11, r1, 0xf0
	ctx.r[11].s64 = ctx.r[1].s64 + 240;
	pc = 0x821EBF24; continue 'dispatch;
            }
            0x821EBF24 => {
    //   block [0x821EBF24..0x821EBF30)
	// 821EBF24: 38210170  addi r1, r1, 0x170
	ctx.r[1].s64 = ctx.r[1].s64 + 368;
	// 821EBF28: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 821EBF2C: 48ABD528  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EBF30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821EBF30 size=616
    let mut pc: u32 = 0x821EBF30;
    'dispatch: loop {
        match pc {
            0x821EBF30 => {
    //   block [0x821EBF30..0x821EBFC8)
	// 821EBF30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EBF34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EBF38: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821EBF3C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EBF40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EBF44: 3D60834B  lis r11, -0x7cb5
	ctx.r[11].s64 = -2092236800;
	// 821EBF48: 3D408331  lis r10, -0x7ccf
	ctx.r[10].s64 = -2093940736;
	// 821EBF4C: 396B63A0  addi r11, r11, 0x63a0
	ctx.r[11].s64 = ctx.r[11].s64 + 25504;
	// 821EBF50: 38EA7064  addi r7, r10, 0x7064
	ctx.r[7].s64 = ctx.r[10].s64 + 28772;
	// 821EBF54: 3D20834B  lis r9, -0x7cb5
	ctx.r[9].s64 = -2092236800;
	// 821EBF58: 39092390  addi r8, r9, 0x2390
	ctx.r[8].s64 = ctx.r[9].s64 + 9104;
	// 821EBF5C: 88CB008D  lbz r6, 0x8d(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(141 as u32) ) } as u64;
	// 821EBF60: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821EBF64: 1D462008  mulli r10, r6, 0x2008
	ctx.r[10].s32 = ((ctx.r[6].s32 as i64 * 8200 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 821EBF68: 80E70008  lwz r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EBF6C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 821EBF70: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 821EBF74: 394ADFF8  addi r10, r10, -0x2008
	ctx.r[10].s64 = ctx.r[10].s64 + -8200;
	// 821EBF78: 419A008C  beq cr6, 0x821ec004
	if ctx.cr[6].eq {
	pc = 0x821EC004; continue 'dispatch;
	}
	// 821EBF7C: 812A2000  lwz r9, 0x2000(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8192 as u32) ) } as u64;
	// 821EBF80: 810B0080  lwz r8, 0x80(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821EBF84: 7D264038  and r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 & ctx.r[8].u64;
	// 821EBF88: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821EBF8C: 409A003C  bne cr6, 0x821ebfc8
	if !ctx.cr[6].eq {
	pc = 0x821EBFC8; continue 'dispatch;
	}
	// 821EBF90: 80CA2004  lwz r6, 0x2004(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EBF94: 7D294378  or r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[8].u64;
	// 821EBF98: 38AB0078  addi r5, r11, 0x78
	ctx.r[5].s64 = ctx.r[11].s64 + 120;
	// 821EBF9C: 54C41838  slwi r4, r6, 3
	ctx.r[4].u32 = ctx.r[6].u32.wrapping_shl(3);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821EBFA0: 912B0080  stw r9, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 821EBFA4: 7CA4512E  stwx r5, r4, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	// 821EBFA8: 812B007C  lwz r9, 0x7c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821EBFAC: 810A2004  lwz r8, 0x2004(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EBFB0: 55081838  slwi r8, r8, 3
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EBFB4: 7CC85214  add r6, r8, r10
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821EBFB8: 91260004  stw r9, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821EBFBC: 812A2004  lwz r9, 0x2004(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8196 as u32) ) } as u64;
	// 821EBFC0: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 821EBFC4: 90AA2004  stw r5, 0x2004(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8196 as u32), ctx.r[5].u32 ) };
	pc = 0x821EBFC8; continue 'dispatch;
            }
            0x821EBFC8 => {
    //   block [0x821EBFC8..0x821EC004)
	// 821EBFC8: 894B008C  lbz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821EBFCC: 90EB007C  stw r7, 0x7c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(124 as u32), ctx.r[7].u32 ) };
	// 821EBFD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EBFD4: 409A0030  bne cr6, 0x821ec004
	if !ctx.cr[6].eq {
	pc = 0x821EC004; continue 'dispatch;
	}
	// 821EBFD8: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821EBFDC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821EBFE0: 390B0078  addi r8, r11, 0x78
	ctx.r[8].s64 = ctx.r[11].s64 + 120;
	// 821EBFE4: 994B008C  stb r10, 0x8c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[10].u8 ) };
	// 821EBFE8: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 821EBFEC: 81690DB0  lwz r11, 0xdb0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3504 as u32) ) } as u64;
	// 821EBFF0: 38C70DB8  addi r6, r7, 0xdb8
	ctx.r[6].s64 = ctx.r[7].s64 + 3512;
	// 821EBFF4: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 821EBFF8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821EBFFC: 91690DB0  stw r11, 0xdb0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(3504 as u32), ctx.r[11].u32 ) };
	// 821EC000: 7D05312E  stwx r8, r5, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32), ctx.r[8].u32) };
	pc = 0x821EC004; continue 'dispatch;
            }
            0x821EC004 => {
    //   block [0x821EC004..0x821EC020)
	// 821EC004: 3CE0834F  lis r7, -0x7cb1
	ctx.r[7].s64 = -2091974656;
	// 821EC008: 8147D5CC  lwz r10, -0x2a34(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-10804 as u32) ) } as u64;
	// 821EC00C: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 821EC010: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EC014: 409A000C  bne cr6, 0x821ec020
	if !ctx.cr[6].eq {
	pc = 0x821EC020; continue 'dispatch;
	}
	// 821EC018: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 821EC01C: 9147D5CC  stw r10, -0x2a34(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-10804 as u32), ctx.r[10].u32 ) };
	pc = 0x821EC020; continue 'dispatch;
            }
            0x821EC020 => {
    //   block [0x821EC020..0x821EC0EC)
	// 821EC020: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821EC024: C1630000  lfs f11, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821EC028: C1430008  lfs f10, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821EC02C: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 821EC030: 39099484  addi r8, r9, -0x6b7c
	ctx.r[8].s64 = ctx.r[9].s64 + -27516;
	// 821EC034: C1230004  lfs f9, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821EC038: C103000C  lfs f8, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821EC03C: 3BCB3DB8  addi r30, r11, 0x3db8
	ctx.r[30].s64 = ctx.r[11].s64 + 15800;
	// 821EC040: 3D60834F  lis r11, -0x7cb1
	ctx.r[11].s64 = -2091974656;
	// 821EC044: C1899484  lfs f12, -0x6b7c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821EC048: 554607BC  rlwinm r6, r10, 0, 0x1e, 0x1e
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821EC04C: 3BEBD5B8  addi r31, r11, -0x2a48
	ctx.r[31].s64 = ctx.r[11].s64 + -10824;
	// 821EC050: C0081FFC  lfs f0, 0x1ffc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8188 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821EC054: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 821EC058: C1A8000C  lfs f13, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821EC05C: ECEB6838  fmsubs f7, f11, f0, f13
	ctx.f[7].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821EC060: ECCA6838  fmsubs f6, f10, f0, f13
	ctx.f[6].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821EC064: ECA96838  fmsubs f5, f9, f0, f13
	ctx.f[5].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821EC068: EC886838  fmsubs f4, f8, f0, f13
	ctx.f[4].f64 = (((ctx.f[8].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821EC06C: EC663828  fsubs f3, f6, f7
	ctx.f[3].f64 = (((ctx.f[6].f64 - ctx.f[7].f64) as f32) as f64);
	// 821EC070: EC442828  fsubs f2, f4, f5
	ctx.f[2].f64 = (((ctx.f[4].f64 - ctx.f[5].f64) as f32) as f64);
	// 821EC074: EC230332  fmuls f1, f3, f12
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[12].f64) as f32) as f64);
	// 821EC078: EC03382A  fadds f0, f3, f7
	ctx.f[0].f64 = ((ctx.f[3].f64 + ctx.f[7].f64) as f32) as f64;
	// 821EC07C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821EC080: EDA2282A  fadds f13, f2, f5
	ctx.f[13].f64 = ((ctx.f[2].f64 + ctx.f[5].f64) as f32) as f64;
	// 821EC084: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821EC088: ED81382A  fadds f12, f1, f7
	ctx.f[12].f64 = ((ctx.f[1].f64 + ctx.f[7].f64) as f32) as f64;
	// 821EC08C: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821EC090: ED61282A  fadds f11, f1, f5
	ctx.f[11].f64 = ((ctx.f[1].f64 + ctx.f[5].f64) as f32) as f64;
	// 821EC094: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821EC098: E9010058  ld r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821EC09C: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821EC0A0: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821EC0A4: D1610054  stfs f11, 0x54(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821EC0A8: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821EC0AC: F93E0000  std r9, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821EC0B0: F97E0008  std r11, 8(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821EC0B4: F91E0010  std r8, 0x10(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[8].u64 ) };
	// 821EC0B8: 409A0034  bne cr6, 0x821ec0ec
	if !ctx.cr[6].eq {
	pc = 0x821EC0EC; continue 'dispatch;
	}
	// 821EC0BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821EC0C0: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 821EC0C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821EC0C8: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 821EC0CC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821EC0D0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 821EC0D4: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821EC0D8: 9147D5CC  stw r10, -0x2a34(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-10804 as u32), ctx.r[10].u32 ) };
	// 821EC0DC: 3D40832B  lis r10, -0x7cd5
	ctx.r[10].s64 = -2094333952;
	// 821EC0E0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 821EC0E4: 386A61C8  addi r3, r10, 0x61c8
	ctx.r[3].s64 = ctx.r[10].s64 + 25032;
	// 821EC0E8: 48ABDE39  bl 0x82ca9f20
	ctx.lr = 0x821EC0EC;
	sub_82CA9F20(ctx, base);
	pc = 0x821EC0EC; continue 'dispatch;
            }
            0x821EC0EC => {
    //   block [0x821EC0EC..0x821EC124)
	// 821EC0EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC0F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EC0F4: 409A0030  bne cr6, 0x821ec124
	if !ctx.cr[6].eq {
	pc = 0x821EC124; continue 'dispatch;
	}
	// 821EC0F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EC0FC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821EC100: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821EC104: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821EC108: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821EC10C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821EC110: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821EC114: 489A144D  bl 0x82b8d560
	ctx.lr = 0x821EC118;
	sub_82B8D560(ctx, base);
	// 821EC118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EC11C: 489A1585  bl 0x82b8d6a0
	ctx.lr = 0x821EC120;
	sub_82B8D6A0(ctx, base);
	// 821EC120: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821EC124; continue 'dispatch;
            }
            0x821EC124 => {
    //   block [0x821EC124..0x821EC180)
	// 821EC124: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 821EC128: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821EC12C: 815F0364  lwz r10, 0x364(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EC130: 916970B8  stw r11, 0x70b8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28856 as u32), ctx.r[11].u32 ) };
	// 821EC134: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 821EC138: 916A2E2C  stw r11, 0x2e2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(11820 as u32), ctx.r[11].u32 ) };
	// 821EC13C: E8E80010  ld r7, 0x10(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) };
	// 821EC140: 64E60008  oris r6, r7, 8
	ctx.r[6].u64 = ctx.r[7].u64 | 524288;
	// 821EC144: F8C80010  std r6, 0x10(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 821EC148: 48032359  bl 0x8221e4a0
	ctx.lr = 0x821EC14C;
	sub_8221E4A0(ctx, base);
	// 821EC14C: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 821EC150: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 821EC154: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 821EC158: 83FF0364  lwz r31, 0x364(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EC15C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EC160: 48019E09  bl 0x82205f68
	ctx.lr = 0x821EC164;
	sub_82205F68(ctx, base);
	// 821EC164: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821EC168: 419A0018  beq cr6, 0x821ec180
	if ctx.cr[6].eq {
	pc = 0x821EC180; continue 'dispatch;
	}
	// 821EC16C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821EC170: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 821EC174: 48ABD30D  bl 0x82ca9480
	ctx.lr = 0x821EC178;
	sub_82CA9480(ctx, base);
	// 821EC178: 817F3484  lwz r11, 0x3484(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(13444 as u32) ) } as u64;
	// 821EC17C: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	pc = 0x821EC180; continue 'dispatch;
            }
            0x821EC180 => {
    //   block [0x821EC180..0x821EC198)
	// 821EC180: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821EC184: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EC188: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EC18C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821EC190: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EC194: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EC198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821EC198 size=1324
    let mut pc: u32 = 0x821EC198;
    'dispatch: loop {
        match pc {
            0x821EC198 => {
    //   block [0x821EC198..0x821EC20C)
	// 821EC198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EC19C: 48ABD235  bl 0x82ca93d0
	ctx.lr = 0x821EC1A0;
	sub_82CA93D0(ctx, base);
	// 821EC1A0: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EC1A4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821EC1A8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821EC1AC: 3BFC0014  addi r31, r28, 0x14
	ctx.r[31].s64 = ctx.r[28].s64 + 20;
	// 821EC1B0: 83650004  lwz r27, 4(r5)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EC1B4: 807B0014  lwz r3, 0x14(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EC1B8: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 821EC1BC: 3BC30010  addi r30, r3, 0x10
	ctx.r[30].s64 = ctx.r[3].s64 + 16;
	// 821EC1C0: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 821EC1C4: 480A338D  bl 0x8228f550
	ctx.lr = 0x821EC1C8;
	sub_8228F550(ctx, base);
	// 821EC1C8: 897B00A0  lbz r11, 0xa0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(160 as u32) ) } as u64;
	// 821EC1CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821EC1D0: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821EC1D4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821EC1D8: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 821EC1DC: 3BABB46C  addi r29, r11, -0x4b94
	ctx.r[29].s64 = ctx.r[11].s64 + -19348;
	// 821EC1E0: 69280001  xori r8, r9, 1
	ctx.r[8].u64 = ctx.r[9].u64 ^ 1;
	// 821EC1E4: 991C0000  stb r8, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 821EC1E8: 419A0024  beq cr6, 0x821ec20c
	if ctx.cr[6].eq {
	pc = 0x821EC20C; continue 'dispatch;
	}
	// 821EC1EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821EC1F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821EC1F4: 4BF93555  bl 0x8217f748
	ctx.lr = 0x821EC1F8;
	sub_8217F748(ctx, base);
	// 821EC1F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC1FC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821EC200: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EC204: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821EC208: 48000018  b 0x821ec220
	pc = 0x821EC220; continue 'dispatch;
            }
            0x821EC20C => {
    //   block [0x821EC20C..0x821EC220)
	// 821EC20C: C01DDE68  lfs f0, -0x2198(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8600 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821EC210: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821EC214: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821EC218: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821EC21C: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	pc = 0x821EC220; continue 'dispatch;
            }
            0x821EC220 => {
    //   block [0x821EC220..0x821EC6C4)
	// 821EC220: 39600150  li r11, 0x150
	ctx.r[11].s64 = 336;
	// 821EC224: C1BDDE5C  lfs f13, -0x21a4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8612 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821EC228: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 821EC22C: 39200160  li r9, 0x160
	ctx.r[9].s64 = 352;
	// 821EC230: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 821EC234: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EC6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EC6C8 size=204
    let mut pc: u32 = 0x821EC6C8;
    'dispatch: loop {
        match pc {
            0x821EC6C8 => {
    //   block [0x821EC6C8..0x821EC6EC)
	// 821EC6C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EC6CC: 48ABCD41  bl 0x82ca940c
	ctx.lr = 0x821EC6D0;
	sub_82CA93D0(ctx, base);
	// 821EC6D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EC6D4: 81630058  lwz r11, 0x58(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) } as u64;
	// 821EC6D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821EC6DC: 83A30010  lwz r29, 0x10(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EC6E0: 3BE30058  addi r31, r3, 0x58
	ctx.r[31].s64 = ctx.r[3].s64 + 88;
	// 821EC6E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EC6E8: 419A0028  beq cr6, 0x821ec710
	if ctx.cr[6].eq {
	pc = 0x821EC710; continue 'dispatch;
	}
	pc = 0x821EC6EC; continue 'dispatch;
            }
            0x821EC6EC => {
    //   block [0x821EC6EC..0x821EC710)
	// 821EC6EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC6F0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EC6F4: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 821EC6F8: 41980018  blt cr6, 0x821ec710
	if ctx.cr[6].lt {
	pc = 0x821EC710; continue 'dispatch;
	}
	// 821EC6FC: 419A0068  beq cr6, 0x821ec764
	if ctx.cr[6].eq {
	pc = 0x821EC764; continue 'dispatch;
	}
	// 821EC700: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC704: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 821EC708: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EC70C: 409AFFE0  bne cr6, 0x821ec6ec
	if !ctx.cr[6].eq {
	pc = 0x821EC6EC; continue 'dispatch;
	}
	pc = 0x821EC710; continue 'dispatch;
            }
            0x821EC710 => {
    //   block [0x821EC710..0x821EC764)
	// 821EC710: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 821EC714: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821EC718: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821EC71C: 4803B105  bl 0x82227820
	ctx.lr = 0x821EC720;
	sub_82227820(ctx, base);
	// 821EC720: 3960000A  li r11, 0xa
	ctx.r[11].s64 = 10;
	// 821EC724: 395D0068  addi r10, r29, 0x68
	ctx.r[10].s64 = ctx.r[29].s64 + 104;
	// 821EC728: 99630004  stb r11, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 821EC72C: 893D0014  lbz r9, 0x14(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EC730: 552807BE  clrlwi r8, r9, 0x1e
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 821EC734: 99030005  stb r8, 5(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(5 as u32), ctx.r[8].u8 ) };
	// 821EC738: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 821EC73C: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC740: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821EC744: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 821EC748: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821EC74C: 80DD0078  lwz r6, 0x78(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(120 as u32) ) } as u64;
	// 821EC750: 90C30010  stw r6, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 821EC754: 9066000C  stw r3, 0xc(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 821EC758: 907D0078  stw r3, 0x78(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(120 as u32), ctx.r[3].u32 ) };
	// 821EC75C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821EC760: 48ABCCFC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821EC764 => {
    //   block [0x821EC764..0x821EC788)
	// 821EC764: 893D0014  lbz r9, 0x14(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EC768: 894B0005  lbz r10, 5(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 821EC76C: 7D484878  andc r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 & !ctx.r[9].u64;
	// 821EC770: 550707BE  clrlwi r7, r8, 0x1e
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 821EC774: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821EC778: 419A0010  beq cr6, 0x821ec788
	if ctx.cr[6].eq {
	pc = 0x821EC788; continue 'dispatch;
	}
	// 821EC77C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821EC780: 69490003  xori r9, r10, 3
	ctx.r[9].u64 = ctx.r[10].u64 ^ 3;
	// 821EC784: 992B0005  stb r9, 5(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(5 as u32), ctx.r[9].u8 ) };
	pc = 0x821EC788; continue 'dispatch;
            }
            0x821EC788 => {
    //   block [0x821EC788..0x821EC794)
	// 821EC788: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821EC78C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821EC790: 48ABCCCC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EC798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821EC798 size=92
    let mut pc: u32 = 0x821EC798;
    'dispatch: loop {
        match pc {
            0x821EC798 => {
    //   block [0x821EC798..0x821EC7F4)
	// 821EC798: 90A10024  stw r5, 0x24(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(36 as u32), ctx.r[5].u32 ) };
	// 821EC79C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821EC7A0: 39640030  addi r11, r4, 0x30
	ctx.r[11].s64 = ctx.r[4].s64 + 48;
	// 821EC7A4: 39240020  addi r9, r4, 0x20
	ctx.r[9].s64 = ctx.r[4].s64 + 32;
	// 821EC7A8: 1D6B0018  mulli r11, r11, 0x18
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821EC7AC: C00AABC8  lfs f0, -0x5438(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-21560 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821EC7B0: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 821EC7B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821EC7B8: 79290020  clrldi r9, r9, 0x20
	ctx.r[9].u64 = ctx.r[9].u64 & 0x00000000FFFFFFFFu64;
	// 821EC7BC: 794AFFE6  rldicr r10, r10, 0x3f, 0x3f
	ctx.r[10].u64 = (ctx.r[10].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 821EC7C0: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EC7C4: 7D4A4C36  srd r10, r10, r9
	if (ctx.r[9].u8 & 0x40) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = (ctx.r[10].u64) >> ((ctx.r[9].u8 & 0x3F) as u32);
	}
	// 821EC7C8: C1A10024  lfs f13, 0x24(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821EC7CC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821EC7D0: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821EC7D4: D801FFF0  stfd f0, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[0].u64 ) };
	// 821EC7D8: 8121FFF4  lwz r9, -0xc(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 821EC7DC: 512862A6  rlwimi r8, r9, 0xc, 0xa, 0x13
	ctx.r[8].u64 = (((ctx.r[9].u32).rotate_left(12) as u64) & 0x00000000003FF000) | (ctx.r[8].u64 & 0xFFFFFFFFFFC00FFF);
	// 821EC7E0: 910B0010  stw r8, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 821EC7E4: E9630018  ld r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	// 821EC7E8: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 821EC7EC: F9630018  std r11, 0x18(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u64 ) };
	// 821EC7F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EC7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EC7F8 size=176
    let mut pc: u32 = 0x821EC7F8;
    'dispatch: loop {
        match pc {
            0x821EC7F8 => {
    //   block [0x821EC7F8..0x821EC844)
	// 821EC7F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EC7FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EC800: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821EC804: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EC808: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EC80C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821EC810: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821EC814: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EC81C: 419A0038  beq cr6, 0x821ec854
	if ctx.cr[6].eq {
	pc = 0x821EC854; continue 'dispatch;
	}
	// 821EC820: 48041FD9  bl 0x8222e7f8
	ctx.lr = 0x821EC824;
	sub_8222E7F8(ctx, base);
	// 821EC824: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EC82C: 409A0018  bne cr6, 0x821ec844
	if !ctx.cr[6].eq {
	pc = 0x821EC844; continue 'dispatch;
	}
	// 821EC830: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 821EC834: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC838: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 821EC83C: 489520C5  bl 0x82b3e900
	ctx.lr = 0x821EC840;
	sub_82B3E900(ctx, base);
	// 821EC840: 4800004C  b 0x821ec88c
	pc = 0x821EC88C; continue 'dispatch;
            }
            0x821EC844 => {
    //   block [0x821EC844..0x821EC854)
	// 821EC844: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC848: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC84C: 489520B5  bl 0x82b3e900
	ctx.lr = 0x821EC850;
	sub_82B3E900(ctx, base);
	// 821EC850: 4800003C  b 0x821ec88c
	pc = 0x821EC88C; continue 'dispatch;
            }
            0x821EC854 => {
    //   block [0x821EC854..0x821EC870)
	// 821EC854: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821EC858: 419A0034  beq cr6, 0x821ec88c
	if ctx.cr[6].eq {
	pc = 0x821EC88C; continue 'dispatch;
	}
	// 821EC85C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EC864: 419A0028  beq cr6, 0x821ec88c
	if ctx.cr[6].eq {
	pc = 0x821EC88C; continue 'dispatch;
	}
	// 821EC868: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821EC86C: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	pc = 0x821EC870; continue 'dispatch;
            }
            0x821EC870 => {
    //   block [0x821EC870..0x821EC88C)
	// 821EC870: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 821EC874: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821EC878: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 821EC87C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821EC880: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 821EC884: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 821EC888: 4082FFE8  bne 0x821ec870
	if !ctx.cr[0].eq {
	pc = 0x821EC870; continue 'dispatch;
	}
	pc = 0x821EC88C; continue 'dispatch;
            }
            0x821EC88C => {
    //   block [0x821EC88C..0x821EC8A8)
	// 821EC88C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EC890: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821EC894: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EC898: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EC89C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821EC8A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EC8A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EC8A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821EC8A8 size=296
    let mut pc: u32 = 0x821EC8A8;
    'dispatch: loop {
        match pc {
            0x821EC8A8 => {
    //   block [0x821EC8A8..0x821EC8E0)
	// 821EC8A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EC8AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EC8B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821EC8B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EC8B8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EC8BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821EC8C0: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 821EC8C4: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821EC8C8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821EC8CC: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 821EC8D0: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 821EC8D4: 4099000C  ble cr6, 0x821ec8e0
	if !ctx.cr[6].gt {
	pc = 0x821EC8E0; continue 'dispatch;
	}
	// 821EC8D8: 4837DF51  bl 0x8256a828
	ctx.lr = 0x821EC8DC;
	sub_8256A828(ctx, base);
	// 821EC8DC: 480000DC  b 0x821ec9b8
	pc = 0x821EC9B8; continue 'dispatch;
            }
            0x821EC8E0 => {
    //   block [0x821EC8E0..0x821EC93C)
	// 821EC8E0: 897F0043  lbz r11, 0x43(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(67 as u32) ) } as u64;
	// 821EC8E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EC8E8: 419A0054  beq cr6, 0x821ec93c
	if ctx.cr[6].eq {
	pc = 0x821EC93C; continue 'dispatch;
	}
	// 821EC8EC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EC8F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821EC8F4: 83CB007C  lwz r30, 0x7c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821EC8F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821EC8FC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC900: 812A0044  lwz r9, 0x44(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 821EC904: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821EC908: 4E800421  bctrl
	ctx.lr = 0x821EC90C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821EC90C: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 821EC910: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821EC914: 80DE0000  lwz r6, 0(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC918: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821EC91C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821EC920: E8A80000  ld r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 821EC924: E9680008  ld r11, 8(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 821EC928: 81460040  lwz r10, 0x40(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(64 as u32) ) } as u64;
	// 821EC92C: F8A70000  std r5, 0(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 821EC930: F9670008  std r11, 8(r7)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 821EC934: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821EC938: 4800004C  b 0x821ec984
	pc = 0x821EC984; continue 'dispatch;
            }
            0x821EC93C => {
    //   block [0x821EC93C..0x821EC984)
	// 821EC93C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821EC940: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EC944: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 821EC948: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821EC94C: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 821EC950: 38C89160  addi r6, r8, -0x6ea0
	ctx.r[6].s64 = ctx.r[8].s64 + -28320;
	// 821EC954: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821EC958: 808A007C  lwz r4, 0x7c(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(124 as u32) ) } as u64;
	// 821EC95C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821EC960: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	pc = 0x821EC984; continue 'dispatch;
            }
            0x821EC984 => {
    //   block [0x821EC984..0x821EC9B8)
	// 821EC984: 4E800421  bctrl
	ctx.lr = 0x821EC988;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x821EC9B8 => {
    //   block [0x821EC9B8..0x821EC9D0)
	// 821EC9B8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821EC9BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EC9C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EC9C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821EC9C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EC9CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EC9D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EC9D0 size=92
    let mut pc: u32 = 0x821EC9D0;
    'dispatch: loop {
        match pc {
            0x821EC9D0 => {
    //   block [0x821EC9D0..0x821ECA14)
	// 821EC9D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EC9D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EC9D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821EC9DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EC9E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EC9E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821EC9E8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821EC9EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EC9F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EC9F4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EC9F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821EC9FC: 4E800421  bctrl
	ctx.lr = 0x821ECA00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821ECA00: 2F03000A  cmpwi cr6, r3, 0xa
	ctx.cr[6].compare_i32(ctx.r[3].s32, 10, &mut ctx.xer);
	// 821ECA04: 409A0010  bne cr6, 0x821eca14
	if !ctx.cr[6].eq {
	pc = 0x821ECA14; continue 'dispatch;
	}
	// 821ECA08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821ECA0C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821ECA10: 4BFFFE99  bl 0x821ec8a8
	ctx.lr = 0x821ECA14;
	sub_821EC8A8(ctx, base);
            }
            0x821ECA14 => {
    //   block [0x821ECA14..0x821ECA2C)
	// 821ECA14: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821ECA18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ECA1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ECA20: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821ECA24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821ECA28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ECA30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ECA30 size=164
    let mut pc: u32 = 0x821ECA30;
    'dispatch: loop {
        match pc {
            0x821ECA30 => {
    //   block [0x821ECA30..0x821ECA58)
	// 821ECA30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ECA34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821ECA38: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ECA3C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821ECA40: 814B6AB8  lwz r10, 0x6ab8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821ECA44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ECA48: 419A0010  beq cr6, 0x821eca58
	if ctx.cr[6].eq {
	pc = 0x821ECA58; continue 'dispatch;
	}
	// 821ECA4C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 821ECA50: 896B6A5E  lbz r11, 0x6a5e(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27230 as u32) ) } as u64;
	// 821ECA54: 48000008  b 0x821eca5c
	pc = 0x821ECA5C; continue 'dispatch;
            }
            0x821ECA58 => {
    //   block [0x821ECA58..0x821ECA5C)
	// 821ECA58: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821ECA5C; continue 'dispatch;
            }
            0x821ECA5C => {
    //   block [0x821ECA5C..0x821ECA7C)
	// 821ECA5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ECA60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ECA64: 409A0018  bne cr6, 0x821eca7c
	if !ctx.cr[6].eq {
	pc = 0x821ECA7C; continue 'dispatch;
	}
	// 821ECA68: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821ECA6C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821ECA70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ECA74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ECA78: 4E800020  blr
	return;
            }
            0x821ECA7C => {
    //   block [0x821ECA7C..0x821ECAA4)
	// 821ECA7C: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 821ECA80: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821ECA84: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ECA88: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ECA8C: 550A003E  slwi r10, r8, 0
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821ECA90: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ECA94: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821ECA98: 409A000C  bne cr6, 0x821ecaa4
	if !ctx.cr[6].eq {
	pc = 0x821ECAA4; continue 'dispatch;
	}
	// 821ECA9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 821ECAA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821ECAA4; continue 'dispatch;
            }
            0x821ECAA4 => {
    //   block [0x821ECAA4..0x821ECAD4)
	// 821ECAA4: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821ECAA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ECAAC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ECAB0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821ECAB4: 4E800421  bctrl
	ctx.lr = 0x821ECAB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821ECAB8: 3923FFFF  addi r9, r3, -1
	ctx.r[9].s64 = ctx.r[3].s64 + -1;
	// 821ECABC: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 821ECAC0: 5503DFFE  rlwinm r3, r8, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 821ECAC4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821ECAC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ECACC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ECAD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ECAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821ECAD8 size=416
    let mut pc: u32 = 0x821ECAD8;
    'dispatch: loop {
        match pc {
            0x821ECAD8 => {
    //   block [0x821ECAD8..0x821ECC78)
	// 821ECAD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ECADC: 48ABC931  bl 0x82ca940c
	ctx.lr = 0x821ECAE0;
	sub_82CA93D0(ctx, base);
	// 821ECAE0: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 821ECAE4: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 821ECAE8: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ECC78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821ECC78 size=184
    let mut pc: u32 = 0x821ECC78;
    'dispatch: loop {
        match pc {
            0x821ECC78 => {
    //   block [0x821ECC78..0x821ECD30)
	// 821ECC78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ECC7C: 48ABC785  bl 0x82ca9400
	ctx.lr = 0x821ECC80;
	sub_82CA93D0(ctx, base);
	// 821ECC80: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ECD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821ECD30 size=572
    let mut pc: u32 = 0x821ECD30;
    'dispatch: loop {
        match pc {
            0x821ECD30 => {
    //   block [0x821ECD30..0x821ECD78)
	// 821ECD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ECD34: 48ABC6D1  bl 0x82ca9404
	ctx.lr = 0x821ECD38;
	sub_82CA93D0(ctx, base);
	// 821ECD38: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 821ECD3C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821ECD40: 9421F3F0  stwu r1, -0xc10(r1)
	ea = ctx.r[1].u32.wrapping_add(-3088 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ECD44: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821ECD48: 80660014  lwz r3, 0x14(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 821ECD4C: 81460018  lwz r10, 0x18(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 821ECD50: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 821ECD54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821ECD58: 392B2A2C  addi r9, r11, 0x2a2c
	ctx.r[9].s64 = ctx.r[11].s64 + 10796;
	// 821ECD5C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821ECD60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821ECD64: 91210088  stw r9, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[9].u32 ) };
	// 821ECD68: 9061008C  stw r3, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 821ECD6C: 91410090  stw r10, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 821ECD70: 419A0008  beq cr6, 0x821ecd78
	if ctx.cr[6].eq {
	pc = 0x821ECD78; continue 'dispatch;
	}
	// 821ECD74: 4800F405  bl 0x821fc178
	ctx.lr = 0x821ECD78;
	sub_821FC178(ctx, base);
	pc = 0x821ECD78; continue 'dispatch;
            }
            0x821ECD78 => {
    //   block [0x821ECD78..0x821ECF6C)
	// 821ECD78: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 821ECD7C: 4800F625  bl 0x821fc3a0
	ctx.lr = 0x821ECD80;
	sub_821FC3A0(ctx, base);
	// 821ECD80: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821ECD84: 3F60820A  lis r27, -0x7df6
	ctx.r[27].s64 = -2113273856;
	// 821ECD88: 9BE10072  stb r31, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[31].u8 ) };
	// 821ECD8C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821ECD90: 9BE10071  stb r31, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[31].u8 ) };
	// 821ECD94: 397B9484  addi r11, r27, -0x6b7c
	ctx.r[11].s64 = ctx.r[27].s64 + -27516;
	// 821ECD98: 9BE10070  stb r31, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u8 ) };
	// 821ECD9C: 9BE10073  stb r31, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[31].u8 ) };
	// 821ECDA0: C3CB000C  lfs f30, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821ECDA4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821ECDA8: 4BFF5E61  bl 0x821e2c08
	ctx.lr = 0x821ECDAC;
	sub_821E2C08(ctx, base);
	// 821ECDAC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 821ECDB0: 4809EFA9  bl 0x8228bd58
	ctx.lr = 0x821ECDB4;
	sub_8228BD58(ctx, base);
	// 821ECDB4: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 821ECDB8: 39210080  addi r9, r1, 0x80
	ctx.r[9].s64 = ctx.r[1].s64 + 128;
	// 821ECDBC: C3FB9484  lfs f31, -0x6b7c(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821ECDC0: 3901007C  addi r8, r1, 0x7c
	ctx.r[8].s64 = ctx.r[1].s64 + 124;
	// 821ECDC4: D3C10070  stfs f30, 0x70(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821ECDC8: 38C10084  addi r6, r1, 0x84
	ctx.r[6].s64 = ctx.r[1].s64 + 132;
	// 821ECDCC: D3E10080  stfs f31, 0x80(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821ECDD0: 39610074  addi r11, r1, 0x74
	ctx.r[11].s64 = ctx.r[1].s64 + 116;
	// 821ECDD4: D3E10074  stfs f31, 0x74(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ECF70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ECF70 size=96
    let mut pc: u32 = 0x821ECF70;
    'dispatch: loop {
        match pc {
            0x821ECF70 => {
    //   block [0x821ECF70..0x821ECFD0)
	// 821ECF70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ECF74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821ECF78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821ECF7C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ECF80: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 821ECF84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ECF88: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 821ECF8C: 814A0364  lwz r10, 0x364(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(868 as u32) ) } as u64;
	// 821ECF90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ECF94: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 821ECF98: 916A2E2C  stw r11, 0x2e2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(11820 as u32), ctx.r[11].u32 ) };
	// 821ECF9C: E8E80010  ld r7, 0x10(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(16 as u32) ) };
	// 821ECFA0: 64E60008  oris r6, r7, 8
	ctx.r[6].u64 = ctx.r[7].u64 | 524288;
	// 821ECFA4: F8C80010  std r6, 0x10(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[6].u64 ) };
	// 821ECFA8: 916970B8  stw r11, 0x70b8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28856 as u32), ctx.r[11].u32 ) };
	// 821ECFAC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821ECFB0: 4803F261  bl 0x8222c210
	ctx.lr = 0x821ECFB4;
	sub_8222C210(ctx, base);
	// 821ECFB4: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821ECFB8: 4801BB59  bl 0x82208b10
	ctx.lr = 0x821ECFBC;
	sub_82208B10(ctx, base);
	// 821ECFBC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821ECFC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ECFC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ECFC8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821ECFCC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ECFD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821ECFD0 size=856
    let mut pc: u32 = 0x821ECFD0;
    'dispatch: loop {
        match pc {
            0x821ECFD0 => {
    //   block [0x821ECFD0..0x821ED328)
	// 821ECFD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ECFD4: 48ABC431  bl 0x82ca9404
	ctx.lr = 0x821ECFD8;
	sub_82CA93D0(ctx, base);
	// 821ECFD8: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 821ECFDC: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 821ECFE0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ECFE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821ECFE8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 821ECFEC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 821ECFF0: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 821ECFF4: 4BFFFF7D  bl 0x821ecf70
	ctx.lr = 0x821ECFF8;
	sub_821ECF70(ctx, base);
	// 821ECFF8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821ECFFC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ED000: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821ED004: 4800DBCD  bl 0x821fabd0
	ctx.lr = 0x821ED008;
	sub_821FABD0(ctx, base);
	// 821ED008: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 821ED00C: 3F80820A  lis r28, -0x7df6
	ctx.r[28].s64 = -2113273856;
	// 821ED010: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ED014: 7D4907B4  extsw r9, r10
	ctx.r[9].s64 = ctx.r[10].s32 as i64;
	// 821ED018: 397C9484  addi r11, r28, -0x6b7c
	ctx.r[11].s64 = ctx.r[28].s64 + -27516;
	// 821ED01C: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 821ED020: C8010060  lfd f0, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821ED024: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 821ED028: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 821ED02C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821ED030: C3CB000C  lfs f30, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821ED034: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821ED038: ED7E6024  fdivs f11, f30, f12
	ctx.f[11].f64 = ((ctx.f[30].f64 / ctx.f[12].f64) as f32) as f64;
	// 821ED03C: D1610054  stfs f11, 0x54(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821ED040: 4800DB91  bl 0x821fabd0
	ctx.lr = 0x821ED044;
	sub_821FABD0(ctx, base);
	// 821ED044: 8081009C  lwz r4, 0x9c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 821ED048: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821ED04C: C3FC9484  lfs f31, -0x6b7c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821ED050: 7C8B07B4  extsw r11, r4
	ctx.r[11].s64 = ctx.r[4].s32 as i64;
	// 821ED054: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821ED058: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 821ED05C: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821ED060: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821ED064: C9410060  lfd f10, 0x60(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821ED068: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ED328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821ED328 size=80
    let mut pc: u32 = 0x821ED328;
    'dispatch: loop {
        match pc {
            0x821ED328 => {
    //   block [0x821ED328..0x821ED378)
	// 821ED328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ED32C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821ED330: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821ED334: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ED338: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 821ED33C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821ED340: 80640004  lwz r3, 4(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ED344: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821ED348: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 821ED34C: 4800D885  bl 0x821fabd0
	ctx.lr = 0x821ED350;
	sub_821FABD0(ctx, base);
	// 821ED350: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 821ED354: 8121006C  lwz r9, 0x6c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 821ED358: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821ED35C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821ED360: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821ED364: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821ED368: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821ED36C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821ED370: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821ED374: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821ED378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821ED378 size=2844
    let mut pc: u32 = 0x821ED378;
    'dispatch: loop {
        match pc {
            0x821ED378 => {
    //   block [0x821ED378..0x821ED3BC)
	// 821ED378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821ED37C: 48ABC06D  bl 0x82ca93e8
	ctx.lr = 0x821ED380;
	sub_82CA93D0(ctx, base);
	// 821ED380: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821ED384: 3E808349  lis r20, -0x7cb7
	ctx.r[20].s64 = -2092367872;
	// 821ED388: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 821ED38C: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 821ED390: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	// 821ED394: 81746AB8  lwz r11, 0x6ab8(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821ED398: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821ED39C: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 821ED3A0: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 821ED3A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821ED3A8: 419A0014  beq cr6, 0x821ed3bc
	if ctx.cr[6].eq {
	pc = 0x821ED3BC; continue 'dispatch;
	}
	// 821ED3AC: 896B0036  lbz r11, 0x36(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 821ED3B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ED3B4: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 821ED3B8: 409A0008  bne cr6, 0x821ed3c0
	if !ctx.cr[6].eq {
	pc = 0x821ED3C0; continue 'dispatch;
	}
	pc = 0x821ED3BC; continue 'dispatch;
            }
            0x821ED3BC => {
    //   block [0x821ED3BC..0x821ED3C0)
	// 821ED3BC: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x821ED3C0; continue 'dispatch;
            }
            0x821ED3C0 => {
    //   block [0x821ED3C0..0x821ED3EC)
	// 821ED3C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ED3C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ED3C8: 409A0AC4  bne cr6, 0x821ede8c
	if !ctx.cr[6].eq {
	pc = 0x821EDE8C; continue 'dispatch;
	}
	// 821ED3CC: 897A003E  lbz r11, 0x3e(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(62 as u32) ) } as u64;
	// 821ED3D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ED3D4: 419A0018  beq cr6, 0x821ed3ec
	if ctx.cr[6].eq {
	pc = 0x821ED3EC; continue 'dispatch;
	}
	// 821ED3D8: 9AFA003E  stb r23, 0x3e(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(62 as u32), ctx.r[23].u8 ) };
	// 821ED3DC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821ED3E0: 4864F419  bl 0x8283c7f8
	ctx.lr = 0x821ED3E4;
	sub_8283C7F8(ctx, base);
	// 821ED3E4: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 821ED3E8: 48ABC050  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            0x821ED3EC => {
    //   block [0x821ED3EC..0x821ED40C)
	// 821ED3EC: 897A003D  lbz r11, 0x3d(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(61 as u32) ) } as u64;
	// 821ED3F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ED3F4: 419A0018  beq cr6, 0x821ed40c
	if ctx.cr[6].eq {
	pc = 0x821ED40C; continue 'dispatch;
	}
	// 821ED3F8: 9AFA003D  stb r23, 0x3d(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(61 as u32), ctx.r[23].u8 ) };
	// 821ED3FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 821ED400: 4864EAF9  bl 0x8283bef8
	ctx.lr = 0x821ED404;
	sub_8283BEF8(ctx, base);
	// 821ED404: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 821ED408: 48ABC030  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            0x821ED40C => {
    //   block [0x821ED40C..0x821ED44C)
	// 821ED40C: 897A0037  lbz r11, 0x37(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(55 as u32) ) } as u64;
	// 821ED410: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ED414: 419A0A70  beq cr6, 0x821ede84
	if ctx.cr[6].eq {
	pc = 0x821EDE84; continue 'dispatch;
	}
	// 821ED418: 816A0058  lwz r11, 0x58(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 821ED41C: 7EF8BB78  mr r24, r23
	ctx.r[24].u64 = ctx.r[23].u64;
	// 821ED420: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ED424: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ED428: 4803ED91  bl 0x8222c1b8
	ctx.lr = 0x821ED42C;
	sub_8222C1B8(ctx, base);
	// 821ED42C: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 821ED430: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 821ED434: 419A0018  beq cr6, 0x821ed44c
	if ctx.cr[6].eq {
	pc = 0x821ED44C; continue 'dispatch;
	}
	// 821ED438: 89760090  lbz r11, 0x90(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[22].u32.wrapping_add(144 as u32) ) } as u64;
	// 821ED43C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821ED440: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 821ED444: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821ED448: 409A0008  bne cr6, 0x821ed450
	if !ctx.cr[6].eq {
	pc = 0x821ED450; continue 'dispatch;
	}
	pc = 0x821ED44C; continue 'dispatch;
            }
            0x821ED44C => {
    //   block [0x821ED44C..0x821ED450)
	// 821ED44C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x821ED450; continue 'dispatch;
            }
            0x821ED450 => {
    //   block [0x821ED450..0x821EDE84)
	// 821ED450: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821ED454: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821ED458: 419A0A34  beq cr6, 0x821ede8c
	if ctx.cr[6].eq {
	pc = 0x821EDE8C; continue 'dispatch;
	}
	// 821ED45C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 821ED460: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821ED464: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821ED468: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ED46C: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821ED470: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821ED474: 4E800421  bctrl
	ctx.lr = 0x821ED478;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821ED478: 8096007C  lwz r4, 0x7c(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(124 as u32) ) } as u64;
	// 821ED47C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821ED480: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821ED484: 80E80040  lwz r7, 0x40(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(64 as u32) ) } as u64;
	// 821ED488: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 821ED48C: 4E800421  bctrl
	ctx.lr = 0x821ED490;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821ED490: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 821ED494: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 821ED498: C01A0024  lfs f0, 0x24(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821ED49C: ED800032  fmuls f12, f0, f0
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 821ED4A0: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821ED4A4: 393A0024  addi r9, r26, 0x24
	ctx.r[9].s64 = ctx.r[26].s64 + 36;
	// 821ED4A8: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
            }
            0x821EDE84 => {
    //   block [0x821EDE84..0x821EDE8C)
	// 821EDE84: 9AFA0035  stb r23, 0x35(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(53 as u32), ctx.r[23].u8 ) };
	// 821EDE88: 9AFA0036  stb r23, 0x36(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(54 as u32), ctx.r[23].u8 ) };
	pc = 0x821EDE8C; continue 'dispatch;
            }
            0x821EDE8C => {
    //   block [0x821EDE8C..0x821EDE94)
	// 821EDE8C: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 821EDE90: 48ABB5A8  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EDE98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EDE98 size=756
    let mut pc: u32 = 0x821EDE98;
    'dispatch: loop {
        match pc {
            0x821EDE98 => {
    //   block [0x821EDE98..0x821EE18C)
	// 821EDE98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EDE9C: 48ABB551  bl 0x82ca93ec
	ctx.lr = 0x821EDEA0;
	sub_82CA93D0(ctx, base);
	// 821EDEA0: DBA1FF88  stfd f29, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[29].u64 ) };
	// 821EDEA4: DBC1FF90  stfd f30, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 821EDEA8: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 821EDEAC: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EE190 size=116
    let mut pc: u32 = 0x821EE190;
    'dispatch: loop {
        match pc {
            0x821EE190 => {
    //   block [0x821EE190..0x821EE204)
	// 821EE190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EE194: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EE198: DBE1FFF0  stfd f31, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 821EE19C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EE1A0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE1A4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 821EE1A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821EE1AC: 808B007C  lwz r4, 0x7c(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 821EE1B0: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE1B4: 812A0040  lwz r9, 0x40(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821EE1B8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 821EE1BC: 4E800421  bctrl
	ctx.lr = 0x821EE1C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821EE1C0: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 821EE1C4: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 821EE1C8: 81686AB8  lwz r11, 0x6ab8(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27320 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EE208 size=172
    let mut pc: u32 = 0x821EE208;
    'dispatch: loop {
        match pc {
            0x821EE208 => {
    //   block [0x821EE208..0x821EE2B4)
	// 821EE208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EE20C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EE210: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821EE214: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EE218: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE2B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EE2B8 size=140
    let mut pc: u32 = 0x821EE2B8;
    'dispatch: loop {
        match pc {
            0x821EE2B8 => {
    //   block [0x821EE2B8..0x821EE328)
	// 821EE2B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EE2BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EE2C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EE2C4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EE2C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821EE2CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE2D0: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 821EE2D4: 419A0054  beq cr6, 0x821ee328
	if ctx.cr[6].eq {
	pc = 0x821EE328; continue 'dispatch;
	}
	// 821EE2D8: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 821EE2DC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 821EE2E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821EE2E4: 816A6AB8  lwz r11, 0x6ab8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 821EE2E8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EE2EC: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 821EE2F0: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE2F4: 386B00C0  addi r3, r11, 0xc0
	ctx.r[3].s64 = ctx.r[11].s64 + 192;
	// 821EE2F8: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 821EE2FC: 80EB00C4  lwz r7, 0xc4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) } as u64;
	// 821EE300: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 821EE304: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821EE308: 488A9061  bl 0x82a97368
	ctx.lr = 0x821EE30C;
	sub_82A97368(ctx, base);
	// 821EE30C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821EE310: 90DF0000  stw r6, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 821EE314: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821EE318: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EE31C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EE320: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EE324: 4E800020  blr
	return;
            }
            0x821EE328 => {
    //   block [0x821EE328..0x821EE344)
	// 821EE328: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821EE32C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821EE330: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821EE334: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EE338: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EE33C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EE340: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EE348 size=552
    let mut pc: u32 = 0x821EE348;
    'dispatch: loop {
        match pc {
            0x821EE348 => {
    //   block [0x821EE348..0x821EE364)
	// 821EE348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EE34C: 48ABB0BD  bl 0x82ca9408
	ctx.lr = 0x821EE350;
	sub_82CA93D0(ctx, base);
	// 821EE350: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EE354: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 821EE358: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821EE35C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821EE360: 80BD6AB8  lwz r5, 0x6ab8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	pc = 0x821EE364; continue 'dispatch;
            }
            0x821EE364 => {
    //   block [0x821EE364..0x821EE398)
	// 821EE364: 8165000C  lwz r11, 0xc(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EE368: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821EE36C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE370: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE374: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 821EE378: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 821EE37C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE380: 419A0020  beq cr6, 0x821ee3a0
	if ctx.cr[6].eq {
	pc = 0x821EE3A0; continue 'dispatch;
	}
	// 821EE384: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE388: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EE38C: 419A000C  beq cr6, 0x821ee398
	if ctx.cr[6].eq {
	pc = 0x821EE398; continue 'dispatch;
	}
	// 821EE390: 555F003E  slwi r31, r10, 0
	ctx.r[31].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 821EE394: 48000010  b 0x821ee3a4
	pc = 0x821EE3A4; continue 'dispatch;
            }
            0x821EE398 => {
    //   block [0x821EE398..0x821EE3A0)
	// 821EE398: 4BFA5AA1  bl 0x82193e38
	ctx.lr = 0x821EE39C;
	sub_82193E38(ctx, base);
	// 821EE39C: 80BD6AB8  lwz r5, 0x6ab8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	pc = 0x821EE3A0; continue 'dispatch;
            }
            0x821EE3A0 => {
    //   block [0x821EE3A0..0x821EE3A4)
	// 821EE3A0: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	pc = 0x821EE3A4; continue 'dispatch;
            }
            0x821EE3A4 => {
    //   block [0x821EE3A4..0x821EE3D8)
	// 821EE3A4: 8165000C  lwz r11, 0xc(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EE3A8: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 821EE3AC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE3B0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE3B4: 386B0070  addi r3, r11, 0x70
	ctx.r[3].s64 = ctx.r[11].s64 + 112;
	// 821EE3B8: 816B0074  lwz r11, 0x74(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 821EE3BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE3C0: 419A0020  beq cr6, 0x821ee3e0
	if ctx.cr[6].eq {
	pc = 0x821EE3E0; continue 'dispatch;
	}
	// 821EE3C4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE3C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EE3CC: 419A000C  beq cr6, 0x821ee3d8
	if ctx.cr[6].eq {
	pc = 0x821EE3D8; continue 'dispatch;
	}
	// 821EE3D0: 5544003E  slwi r4, r10, 0
	ctx.r[4].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 821EE3D4: 48000010  b 0x821ee3e4
	pc = 0x821EE3E4; continue 'dispatch;
            }
            0x821EE3D8 => {
    //   block [0x821EE3D8..0x821EE3E0)
	// 821EE3D8: 4BFA5A61  bl 0x82193e38
	ctx.lr = 0x821EE3DC;
	sub_82193E38(ctx, base);
	// 821EE3DC: 80BD6AB8  lwz r5, 0x6ab8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	pc = 0x821EE3E0; continue 'dispatch;
            }
            0x821EE3E0 => {
    //   block [0x821EE3E0..0x821EE3E4)
	// 821EE3E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	pc = 0x821EE3E4; continue 'dispatch;
            }
            0x821EE3E4 => {
    //   block [0x821EE3E4..0x821EE41C)
	// 821EE3E4: 8165000C  lwz r11, 0xc(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EE3E8: 814B011C  lwz r10, 0x11c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 821EE3EC: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821EE3F0: 409A0128  bne cr6, 0x821ee518
	if !ctx.cr[6].eq {
	pc = 0x821EE518; continue 'dispatch;
	}
	// 821EE3F4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE3F8: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821EE3FC: 409A011C  bne cr6, 0x821ee518
	if !ctx.cr[6].eq {
	pc = 0x821EE518; continue 'dispatch;
	}
	// 821EE400: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821EE404: 419A0018  beq cr6, 0x821ee41c
	if ctx.cr[6].eq {
	pc = 0x821EE41C; continue 'dispatch;
	}
	// 821EE408: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821EE40C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821EE410: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821EE414: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EE418: 409A0008  bne cr6, 0x821ee420
	if !ctx.cr[6].eq {
	pc = 0x821EE420; continue 'dispatch;
	}
	pc = 0x821EE41C; continue 'dispatch;
            }
            0x821EE41C => {
    //   block [0x821EE41C..0x821EE420)
	// 821EE41C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821EE420; continue 'dispatch;
            }
            0x821EE420 => {
    //   block [0x821EE420..0x821EE460)
	// 821EE420: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821EE424: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE428: 419A00F0  beq cr6, 0x821ee518
	if ctx.cr[6].eq {
	pc = 0x821EE518; continue 'dispatch;
	}
	// 821EE42C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821EE430: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821EE434: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EE438: 419A00E0  beq cr6, 0x821ee518
	if ctx.cr[6].eq {
	pc = 0x821EE518; continue 'dispatch;
	}
	// 821EE43C: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821EE440: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 821EE444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE448: 419A0018  beq cr6, 0x821ee460
	if ctx.cr[6].eq {
	pc = 0x821EE460; continue 'dispatch;
	}
	// 821EE44C: 896B0021  lbz r11, 0x21(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 821EE450: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821EE454: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821EE458: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE45C: 480000AC  b 0x821ee508
	pc = 0x821EE508; continue 'dispatch;
            }
            0x821EE460 => {
    //   block [0x821EE460..0x821EE478)
	// 821EE460: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 821EE464: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 821EE468: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 821EE46C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 821EE470: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821EE474: 40810054  ble 0x821ee4c8
	if !ctx.cr[0].gt {
	pc = 0x821EE4C8; continue 'dispatch;
	}
	pc = 0x821EE478; continue 'dispatch;
            }
            0x821EE478 => {
    //   block [0x821EE478..0x821EE498)
	// 821EE478: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 821EE47C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EE480: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 821EE484: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE488: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 821EE48C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821EE490: 41980008  blt cr6, 0x821ee498
	if ctx.cr[6].lt {
	pc = 0x821EE498; continue 'dispatch;
	}
	// 821EE494: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x821EE498; continue 'dispatch;
            }
            0x821EE498 => {
    //   block [0x821EE498..0x821EE4B4)
	// 821EE498: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 821EE49C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821EE4A0: 419A0014  beq cr6, 0x821ee4b4
	if ctx.cr[6].eq {
	pc = 0x821EE4B4; continue 'dispatch;
	}
	// 821EE4A4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 821EE4A8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 821EE4AC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 821EE4B0: 4800000C  b 0x821ee4bc
	pc = 0x821EE4BC; continue 'dispatch;
            }
            0x821EE4B4 => {
    //   block [0x821EE4B4..0x821EE4BC)
	// 821EE4B4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 821EE4B8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x821EE4BC; continue 'dispatch;
            }
            0x821EE4BC => {
    //   block [0x821EE4BC..0x821EE4C8)
	// 821EE4BC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821EE4C0: 4199FFB8  bgt cr6, 0x821ee478
	if ctx.cr[6].gt {
	pc = 0x821EE478; continue 'dispatch;
	}
	// 821EE4C4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x821EE4C8; continue 'dispatch;
            }
            0x821EE4C8 => {
    //   block [0x821EE4C8..0x821EE4E4)
	// 821EE4C8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 821EE4CC: 419A0034  beq cr6, 0x821ee500
	if ctx.cr[6].eq {
	pc = 0x821EE500; continue 'dispatch;
	}
	// 821EE4D0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE4D4: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 821EE4D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821EE4DC: 41990008  bgt cr6, 0x821ee4e4
	if ctx.cr[6].gt {
	pc = 0x821EE4E4; continue 'dispatch;
	}
	// 821EE4E0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821EE4E4; continue 'dispatch;
            }
            0x821EE4E4 => {
    //   block [0x821EE4E4..0x821EE500)
	// 821EE4E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821EE4E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE4EC: 409A0014  bne cr6, 0x821ee500
	if !ctx.cr[6].eq {
	pc = 0x821EE500; continue 'dispatch;
	}
	// 821EE4F0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821EE4F4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821EE4F8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 821EE4FC: 48000008  b 0x821ee504
	pc = 0x821EE504; continue 'dispatch;
            }
            0x821EE500 => {
    //   block [0x821EE500..0x821EE504)
	// 821EE500: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x821EE504; continue 'dispatch;
            }
            0x821EE504 => {
    //   block [0x821EE504..0x821EE508)
	// 821EE504: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x821EE508; continue 'dispatch;
            }
            0x821EE508 => {
    //   block [0x821EE508..0x821EE518)
	// 821EE508: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE50C: 419A000C  beq cr6, 0x821ee518
	if ctx.cr[6].eq {
	pc = 0x821EE518; continue 'dispatch;
	}
	// 821EE510: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 821EE514: 4BFFFE50  b 0x821ee364
	pc = 0x821EE364; continue 'dispatch;
            }
            0x821EE518 => {
    //   block [0x821EE518..0x821EE538)
	// 821EE518: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE51C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EE520: 419A0018  beq cr6, 0x821ee538
	if ctx.cr[6].eq {
	pc = 0x821EE538; continue 'dispatch;
	}
	// 821EE524: 896A0090  lbz r11, 0x90(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(144 as u32) ) } as u64;
	// 821EE528: 55690672  rlwinm r9, r11, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821EE52C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821EE530: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821EE534: 409A0008  bne cr6, 0x821ee53c
	if !ctx.cr[6].eq {
	pc = 0x821EE53C; continue 'dispatch;
	}
	pc = 0x821EE538; continue 'dispatch;
            }
            0x821EE538 => {
    //   block [0x821EE538..0x821EE53C)
	// 821EE538: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x821EE53C; continue 'dispatch;
            }
            0x821EE53C => {
    //   block [0x821EE53C..0x821EE558)
	// 821EE53C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821EE540: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE544: 419A0020  beq cr6, 0x821ee564
	if ctx.cr[6].eq {
	pc = 0x821EE564; continue 'dispatch;
	}
	// 821EE548: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821EE54C: 419A000C  beq cr6, 0x821ee558
	if ctx.cr[6].eq {
	pc = 0x821EE558; continue 'dispatch;
	}
	// 821EE550: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821EE554: 409A0010  bne cr6, 0x821ee564
	if !ctx.cr[6].eq {
	pc = 0x821EE564; continue 'dispatch;
	}
	pc = 0x821EE558; continue 'dispatch;
            }
            0x821EE558 => {
    //   block [0x821EE558..0x821EE564)
	// 821EE558: 887C0019  lbz r3, 0x19(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(25 as u32) ) } as u64;
	// 821EE55C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821EE560: 48ABAEF8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x821EE564 => {
    //   block [0x821EE564..0x821EE570)
	// 821EE564: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821EE568: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821EE56C: 48ABAEEC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EE570 size=584
    let mut pc: u32 = 0x821EE570;
    'dispatch: loop {
        match pc {
            0x821EE570 => {
    //   block [0x821EE570..0x821EE5AC)
	// 821EE570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EE574: 48ABAE79  bl 0x82ca93ec
	ctx.lr = 0x821EE578;
	sub_82CA93D0(ctx, base);
	// 821EE578: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EE57C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821EE580: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 821EE584: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 821EE588: 397AFFFE  addi r11, r26, -2
	ctx.r[11].s64 = ctx.r[26].s64 + -2;
	// 821EE58C: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 821EE590: 815B0034  lwz r10, 0x34(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) } as u64;
	// 821EE594: 7D690034  cntlzw r9, r11
	ctx.r[9].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821EE598: 7F38CB78  mr r24, r25
	ctx.r[24].u64 = ctx.r[25].u64;
	// 821EE59C: 5535DFFE  rlwinm r21, r9, 0x1b, 0x1f, 0x1f
	ctx.r[21].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 821EE5A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EE5A4: 409901FC  ble cr6, 0x821ee7a0
	if !ctx.cr[6].gt {
	pc = 0x821EE7A0; continue 'dispatch;
	}
	// 821EE5A8: 3ADB0004  addi r22, r27, 4
	ctx.r[22].s64 = ctx.r[27].s64 + 4;
	pc = 0x821EE5AC; continue 'dispatch;
            }
            0x821EE5AC => {
    //   block [0x821EE5AC..0x821EE604)
	// 821EE5AC: 83FB0014  lwz r31, 0x14(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 821EE5B0: 7F1FB040  cmplw cr6, r31, r22
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[22].u32, &mut ctx.xer);
	// 821EE5B4: 419A01EC  beq cr6, 0x821ee7a0
	if ctx.cr[6].eq {
	pc = 0x821EE7A0; continue 'dispatch;
	}
	// 821EE5B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821EE5BC: 419A01E4  beq cr6, 0x821ee7a0
	if ctx.cr[6].eq {
	pc = 0x821EE7A0; continue 'dispatch;
	}
	// 821EE5C0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EE5C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE5C8: 419A0068  beq cr6, 0x821ee630
	if ctx.cr[6].eq {
	pc = 0x821EE630; continue 'dispatch;
	}
	// 821EE5CC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EE5D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE5D4: 419A0038  beq cr6, 0x821ee60c
	if ctx.cr[6].eq {
	pc = 0x821EE60C; continue 'dispatch;
	}
	// 821EE5D8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EE5DC: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EE5E0: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821EE5E4: 409A0020  bne cr6, 0x821ee604
	if !ctx.cr[6].eq {
	pc = 0x821EE604; continue 'dispatch;
	}
	// 821EE5E8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EE5EC: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821EE5F0: 409A0014  bne cr6, 0x821ee604
	if !ctx.cr[6].eq {
	pc = 0x821EE604; continue 'dispatch;
	}
	// 821EE5F4: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821EE5F8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EE5FC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EE600: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x821EE604; continue 'dispatch;
            }
            0x821EE604 => {
    //   block [0x821EE604..0x821EE60C)
	// 821EE604: 933F000C  stw r25, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 821EE608: 933F0010  stw r25, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[25].u32 ) };
	pc = 0x821EE60C; continue 'dispatch;
            }
            0x821EE60C => {
    //   block [0x821EE60C..0x821EE630)
	// 821EE60C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EE610: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 821EE614: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EE618: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 821EE61C: 5528003E  slwi r8, r9, 0
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821EE620: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 821EE624: 93E80010  stw r31, 0x10(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 821EE628: 80FF0010  lwz r7, 0x10(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 821EE62C: 93E7000C  stw r31, 0xc(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	pc = 0x821EE630; continue 'dispatch;
            }
            0x821EE630 => {
    //   block [0x821EE630..0x821EE650)
	// 821EE630: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EE634: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE638: 419A0018  beq cr6, 0x821ee650
	if ctx.cr[6].eq {
	pc = 0x821EE650; continue 'dispatch;
	}
	// 821EE63C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821EE640: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 821EE644: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821EE648: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821EE64C: 419A0144  beq cr6, 0x821ee790
	if ctx.cr[6].eq {
	pc = 0x821EE790; continue 'dispatch;
	}
	pc = 0x821EE650; continue 'dispatch;
            }
            0x821EE650 => {
    //   block [0x821EE650..0x821EE668)
	// 821EE650: 56AB063E  clrlwi r11, r21, 0x18
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0x000000FFu64;
	// 821EE654: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE658: 409A0048  bne cr6, 0x821ee6a0
	if !ctx.cr[6].eq {
	pc = 0x821EE6A0; continue 'dispatch;
	}
	// 821EE65C: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 821EE660: 3BDF0028  addi r30, r31, 0x28
	ctx.r[30].s64 = ctx.r[31].s64 + 40;
	// 821EE664: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	pc = 0x821EE668; continue 'dispatch;
            }
            0x821EE668 => {
    //   block [0x821EE668..0x821EE688)
	// 821EE668: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE66C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821EE670: 419A0018  beq cr6, 0x821ee688
	if ctx.cr[6].eq {
	pc = 0x821EE688; continue 'dispatch;
	}
	// 821EE674: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821EE678: 48000141  bl 0x821ee7b8
	ctx.lr = 0x821EE67C;
	sub_821EE7B8(ctx, base);
	// 821EE67C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 821EE680: 578A063E  clrlwi r10, r28, 0x18
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 821EE684: 7D7C5378  or r28, r11, r10
	ctx.r[28].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	pc = 0x821EE688; continue 'dispatch;
            }
            0x821EE688 => {
    //   block [0x821EE688..0x821EE6A0)
	// 821EE688: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 821EE68C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 821EE690: 4082FFD8  bne 0x821ee668
	if !ctx.cr[0].eq {
	pc = 0x821EE668; continue 'dispatch;
	}
	// 821EE694: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 821EE698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE69C: 409A00F4  bne cr6, 0x821ee790
	if !ctx.cr[6].eq {
	pc = 0x821EE790; continue 'dispatch;
	}
	pc = 0x821EE6A0; continue 'dispatch;
            }
            0x821EE6A0 => {
    //   block [0x821EE6A0..0x821EE700)
	// 821EE6A0: 897F0026  lbz r11, 0x26(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 821EE6A4: 556A06B4  rlwinm r10, r11, 0, 0x1a, 0x1a
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821EE6A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EE6AC: 409A00E4  bne cr6, 0x821ee790
	if !ctx.cr[6].eq {
	pc = 0x821EE790; continue 'dispatch;
	}
	// 821EE6B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821EE6B4: 616A0020  ori r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 | 32;
	// 821EE6B8: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821EE6BC: 995F0026  stb r10, 0x26(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(38 as u32), ctx.r[10].u8 ) };
	// 821EE6C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821EE6C4: 419A00B0  beq cr6, 0x821ee774
	if ctx.cr[6].eq {
	pc = 0x821EE774; continue 'dispatch;
	}
	// 821EE6C8: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 821EE6CC: 556A06F6  rlwinm r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821EE6D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821EE6D4: 419A00A0  beq cr6, 0x821ee774
	if ctx.cr[6].eq {
	pc = 0x821EE774; continue 'dispatch;
	}
	// 821EE6D8: 807F0038  lwz r3, 0x38(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 821EE6DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821EE6E0: 419A0020  beq cr6, 0x821ee700
	if ctx.cr[6].eq {
	pc = 0x821EE700; continue 'dispatch;
	}
	// 821EE6E4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE6E8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821EE6EC: 809B003C  lwz r4, 0x3c(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(60 as u32) ) } as u64;
	// 821EE6F0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE6F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821EE6F8: 4E800421  bctrl
	ctx.lr = 0x821EE6FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821EE6FC: 48000078  b 0x821ee774
	pc = 0x821EE774; continue 'dispatch;
            }
            0x821EE700 => {
    //   block [0x821EE700..0x821EE718)
	// 821EE700: 8177051C  lwz r11, 0x51c(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(1308 as u32) ) } as u64;
	// 821EE704: 38970518  addi r4, r23, 0x518
	ctx.r[4].s64 = ctx.r[23].s64 + 1304;
	// 821EE708: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 821EE70C: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 821EE710: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE714: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x821EE718; continue 'dispatch;
            }
            0x821EE718 => {
    //   block [0x821EE718..0x821EE724)
	// 821EE718: 7F042040  cmplw cr6, r4, r4
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821EE71C: 419A0008  beq cr6, 0x821ee724
	if ctx.cr[6].eq {
	pc = 0x821EE724; continue 'dispatch;
	}
	// 821EE720: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EE724; continue 'dispatch;
            }
            0x821EE724 => {
    //   block [0x821EE724..0x821EE73C)
	// 821EE724: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821EE728: 419A0048  beq cr6, 0x821ee770
	if ctx.cr[6].eq {
	pc = 0x821EE770; continue 'dispatch;
	}
	// 821EE72C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE730: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821EE734: 409A0008  bne cr6, 0x821ee73c
	if !ctx.cr[6].eq {
	pc = 0x821EE73C; continue 'dispatch;
	}
	// 821EE738: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EE73C; continue 'dispatch;
            }
            0x821EE73C => {
    //   block [0x821EE73C..0x821EE754)
	// 821EE73C: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821EE740: 7F08F840  cmplw cr6, r8, r31
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821EE744: 419A0018  beq cr6, 0x821ee75c
	if ctx.cr[6].eq {
	pc = 0x821EE75C; continue 'dispatch;
	}
	// 821EE748: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821EE74C: 409A0008  bne cr6, 0x821ee754
	if !ctx.cr[6].eq {
	pc = 0x821EE754; continue 'dispatch;
	}
	// 821EE750: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EE754; continue 'dispatch;
            }
            0x821EE754 => {
    //   block [0x821EE754..0x821EE75C)
	// 821EE754: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE758: 4BFFFFC0  b 0x821ee718
	pc = 0x821EE718; continue 'dispatch;
            }
            0x821EE75C => {
    //   block [0x821EE75C..0x821EE770)
	// 821EE75C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821EE760: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 821EE764: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821EE768: 48972E89  bl 0x82b615f0
	ctx.lr = 0x821EE76C;
	sub_82B615F0(ctx, base);
	// 821EE76C: 48000008  b 0x821ee774
	pc = 0x821EE774; continue 'dispatch;
            }
            0x821EE770 => {
    //   block [0x821EE770..0x821EE774)
	// 821EE770: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x821EE774; continue 'dispatch;
            }
            0x821EE774 => {
    //   block [0x821EE774..0x821EE790)
	// 821EE774: 897F0026  lbz r11, 0x26(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(38 as u32) ) } as u64;
	// 821EE778: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821EE77C: 554A06F2  rlwinm r10, r10, 0, 0x1b, 0x19
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821EE780: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821EE784: 995F0026  stb r10, 0x26(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(38 as u32), ctx.r[10].u8 ) };
	// 821EE788: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821EE78C: 419A0020  beq cr6, 0x821ee7ac
	if ctx.cr[6].eq {
	pc = 0x821EE7AC; continue 'dispatch;
	}
	pc = 0x821EE790; continue 'dispatch;
            }
            0x821EE790 => {
    //   block [0x821EE790..0x821EE7A0)
	// 821EE790: 817B0034  lwz r11, 0x34(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(52 as u32) ) } as u64;
	// 821EE794: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 821EE798: 7F185840  cmplw cr6, r24, r11
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821EE79C: 4198FE10  blt cr6, 0x821ee5ac
	if ctx.cr[6].lt {
	pc = 0x821EE5AC; continue 'dispatch;
	}
	pc = 0x821EE7A0; continue 'dispatch;
            }
            0x821EE7A0 => {
    //   block [0x821EE7A0..0x821EE7AC)
	// 821EE7A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821EE7A4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821EE7A8: 48ABAC94  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            0x821EE7AC => {
    //   block [0x821EE7AC..0x821EE7B8)
	// 821EE7AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821EE7B0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821EE7B4: 48ABAC88  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE7B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EE7B8 size=136
    let mut pc: u32 = 0x821EE7B8;
    'dispatch: loop {
        match pc {
            0x821EE7B8 => {
    //   block [0x821EE7B8..0x821EE7E4)
	// 821EE7B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EE7BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EE7C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EE7C4: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE7C8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821EE7CC: 409A0018  bne cr6, 0x821ee7e4
	if !ctx.cr[6].eq {
	pc = 0x821EE7E4; continue 'dispatch;
	}
	// 821EE7D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821EE7D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821EE7D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EE7DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EE7E0: 4E800020  blr
	return;
            }
            0x821EE7E4 => {
    //   block [0x821EE7E4..0x821EE81C)
	// 821EE7E4: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 821EE7E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE7EC: 419A0030  beq cr6, 0x821ee81c
	if ctx.cr[6].eq {
	pc = 0x821EE81C; continue 'dispatch;
	}
	// 821EE7F0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 821EE7F4: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821EE7F8: 808B0364  lwz r4, 0x364(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(868 as u32) ) } as u64;
	// 821EE7FC: 480B44F5  bl 0x822a2cf0
	ctx.lr = 0x821EE800;
	sub_822A2CF0(ctx, base);
	// 821EE800: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821EE804: 419A0018  beq cr6, 0x821ee81c
	if ctx.cr[6].eq {
	pc = 0x821EE81C; continue 'dispatch;
	}
	// 821EE808: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821EE80C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821EE810: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EE814: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EE818: 4E800020  blr
	return;
            }
            0x821EE81C => {
    //   block [0x821EE81C..0x821EE840)
	// 821EE81C: 80670008  lwz r3, 8(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EE820: 48007A51  bl 0x821f6270
	ctx.lr = 0x821EE824;
	sub_821F6270(ctx, base);
	// 821EE824: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 821EE828: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821EE82C: 69430001  xori r3, r10, 1
	ctx.r[3].u64 = ctx.r[10].u64 ^ 1;
	// 821EE830: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821EE834: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EE838: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EE83C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE840(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821EE840 size=8
    let mut pc: u32 = 0x821EE840;
    'dispatch: loop {
        match pc {
            0x821EE840 => {
    //   block [0x821EE840..0x821EE848)
	// 821EE840: 80630008  lwz r3, 8(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EE844: 48007A2C  b 0x821f6270
	sub_821F6270(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821EE848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821EE848 size=180
    let mut pc: u32 = 0x821EE848;
    'dispatch: loop {
        match pc {
            0x821EE848 => {
    //   block [0x821EE848..0x821EE874)
	// 821EE848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821EE84C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821EE850: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821EE854: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821EE858: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821EE85C: 8163003C  lwz r11, 0x3c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(60 as u32) ) } as u64;
	// 821EE860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821EE864: 409A0010  bne cr6, 0x821ee874
	if !ctx.cr[6].eq {
	pc = 0x821EE874; continue 'dispatch;
	}
	// 821EE868: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 821EE86C: 480309ED  bl 0x8221f258
	ctx.lr = 0x821EE870;
	sub_8221F258(ctx, base);
	// 821EE870: 48000074  b 0x821ee8e4
	pc = 0x821EE8E4; continue 'dispatch;
            }
            0x821EE874 => {
    //   block [0x821EE874..0x821EE890)
	// 821EE874: 81630038  lwz r11, 0x38(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) } as u64;
	// 821EE878: 3BE30034  addi r31, r3, 0x34
	ctx.r[31].s64 = ctx.r[3].s64 + 52;
	// 821EE87C: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821EE880: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE884: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821EE888: 409A0008  bne cr6, 0x821ee890
	if !ctx.cr[6].eq {
	pc = 0x821EE890; continue 'dispatch;
	}
	// 821EE88C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EE890; continue 'dispatch;
            }
            0x821EE890 => {
    //   block [0x821EE890..0x821EE8AC)
	// 821EE890: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE894: 83CB0008  lwz r30, 8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EE898: 5549003E  slwi r9, r10, 0
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821EE89C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE8A0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821EE8A4: 409A0008  bne cr6, 0x821ee8ac
	if !ctx.cr[6].eq {
	pc = 0x821EE8AC; continue 'dispatch;
	}
	// 821EE8A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x821EE8AC; continue 'dispatch;
            }
            0x821EE8AC => {
    //   block [0x821EE8AC..0x821EE8E0)
	// 821EE8AC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821EE8B0: 419A0030  beq cr6, 0x821ee8e0
	if ctx.cr[6].eq {
	pc = 0x821EE8E0; continue 'dispatch;
	}
	// 821EE8B4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE8B8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 821EE8BC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE8C0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821EE8C4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821EE8C8: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821EE8CC: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 821EE8D0: 4802D469  bl 0x8221bd38
	ctx.lr = 0x821EE8D4;
	sub_8221BD38(ctx, base);
	// 821EE8D4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 821EE8D8: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 821EE8DC: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x821EE8E0; continue 'dispatch;
            }
            0x821EE8E0 => {
    //   block [0x821EE8E0..0x821EE8E4)
	// 821EE8E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x821EE8E4; continue 'dispatch;
            }
            0x821EE8E4 => {
    //   block [0x821EE8E4..0x821EE8FC)
	// 821EE8E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821EE8E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821EE8EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821EE8F0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821EE8F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821EE8F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


