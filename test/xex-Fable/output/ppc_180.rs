pub fn sub_82FBE000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FBE000 size=76
    let mut pc: u32 = 0x82FBE000;
    'dispatch: loop {
        match pc {
            0x82FBE000 => {
    //   block [0x82FBE000..0x82FBE030)
	// 82FBE000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBE004: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FBE008: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FBE00C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FBE010: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBE014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FBE018: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FBE01C: 4BFFFE65  bl 0x82fbde80
	ctx.lr = 0x82FBE020;
	sub_82FBDE80(ctx, base);
	// 82FBE020: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBE024: 4182000C  beq 0x82fbe030
	if ctx.cr[0].eq {
	pc = 0x82FBE030; continue 'dispatch;
	}
	// 82FBE028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBE02C: 4BF3F875  bl 0x82efd8a0
	ctx.lr = 0x82FBE030;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FBE030; continue 'dispatch;
            }
            0x82FBE030 => {
    //   block [0x82FBE030..0x82FBE04C)
	// 82FBE030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBE034: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FBE038: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FBE03C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FBE040: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FBE044: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FBE048: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBE050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FBE050 size=764
    let mut pc: u32 = 0x82FBE050;
    'dispatch: loop {
        match pc {
            0x82FBE050 => {
    //   block [0x82FBE050..0x82FBE100)
	// 82FBE050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBE054: 4BCEB3B9  bl 0x82ca940c
	ctx.lr = 0x82FBE058;
	sub_82CA93D0(ctx, base);
	// 82FBE058: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBE05C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FBE060: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82FBE064: 548B063F  clrlwi. r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBE068: 3FC08204  lis r30, -0x7dfc
	ctx.r[30].s64 = -2113667072;
	// 82FBE06C: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82FBE070: 418200B4  beq 0x82fbe124
	if ctx.cr[0].eq {
	pc = 0x82FBE124; continue 'dispatch;
	}
	// 82FBE074: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBE078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FBE07C: 419A00A8  beq cr6, 0x82fbe124
	if ctx.cr[6].eq {
	pc = 0x82FBE124; continue 'dispatch;
	}
	// 82FBE080: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FBE084: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82FBE088: 80890000  lwz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBE08C: 40990090  ble cr6, 0x82fbe11c
	if !ctx.cr[6].gt {
	pc = 0x82FBE11C; continue 'dispatch;
	}
	// 82FBE090: 556A003E  slwi r10, r11, 0
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82FBE094: C01E67C8  lfs f0, 0x67c8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(26568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBE098: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FBE09C: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 82FBE0A0: 5568E13A  rlwinm r8, r11, 0x1c, 4, 0x1d
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82FBE0A4: 5546E13A  rlwinm r6, r10, 0x1c, 4, 0x1d
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 82FBE0A8: 554A06BE  clrlwi r10, r10, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 82FBE0AC: 556506BE  clrlwi r5, r11, 0x1a
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FBE0B0: 1D6A000C  mulli r11, r10, 0xc
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FBE0B4: 7CE8482E  lwzx r7, r8, r9
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FBE0B8: 7D46482E  lwzx r10, r6, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FBE0BC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FBE0C0: 1D05000C  mulli r8, r5, 0xc
	ctx.r[8].s32 = ((ctx.r[5].s32 as i64 * 12 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82FBE0C4: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBE0C8: 7D87442E  lfsx f12, r7, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBE0CC: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FBE0D0: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBE0D4: 7D474214  add r10, r7, r8
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82FBE0D8: C16A0004  lfs f11, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FBE0DC: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FBE0E0: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FBE0E4: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FBE0E8: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 82FBE0EC: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82FBE0F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FBE0F4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FBE0F8: 41990008  bgt cr6, 0x82fbe100
	if ctx.cr[6].gt {
	pc = 0x82FBE100; continue 'dispatch;
	}
	// 82FBE0FC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82FBE100; continue 'dispatch;
            }
            0x82FBE100 => {
    //   block [0x82FBE100..0x82FBE11C)
	// 82FBE100: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBE104: 40820018  bne 0x82fbe11c
	if !ctx.cr[0].eq {
	pc = 0x82FBE11C; continue 'dispatch;
	}
	// 82FBE108: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBE10C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FBE110: 419A000C  beq cr6, 0x82fbe11c
	if ctx.cr[6].eq {
	pc = 0x82FBE11C; continue 'dispatch;
	}
	// 82FBE114: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FBE118: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82FBE11C; continue 'dispatch;
            }
            0x82FBE11C => {
    //   block [0x82FBE11C..0x82FBE124)
	// 82FBE11C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBE120: 48020949  bl 0x82fdea68
	ctx.lr = 0x82FBE124;
	sub_82FDEA68(ctx, base);
	pc = 0x82FBE124; continue 'dispatch;
            }
            0x82FBE124 => {
    //   block [0x82FBE124..0x82FBE18C)
	// 82FBE124: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBE128: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82FBE12C: 40990170  ble cr6, 0x82fbe29c
	if !ctx.cr[6].gt {
	pc = 0x82FBE29C; continue 'dispatch;
	}
	// 82FBE130: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FBE134: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FBE138: C01E67C8  lfs f0, 0x67c8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(26568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBE13C: 5569E13A  rlwinm r9, r11, 0x1c, 4, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82FBE140: 556B06BE  clrlwi r11, r11, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FBE144: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBE148: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FBE14C: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FBE150: C1A80000  lfs f13, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBE154: C1880004  lfs f12, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBE158: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FBE15C: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FBE160: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82FBE164: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FBE168: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82FBE16C: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FBE170: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FBE174: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 82FBE178: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82FBE17C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FBE180: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FBE184: 41990008  bgt cr6, 0x82fbe18c
	if ctx.cr[6].gt {
	pc = 0x82FBE18C; continue 'dispatch;
	}
	// 82FBE188: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82FBE18C; continue 'dispatch;
            }
            0x82FBE18C => {
    //   block [0x82FBE18C..0x82FBE1AC)
	// 82FBE18C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82FBE190: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBE194: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82FBE198: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82FBE19C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82FBE1A0: 997F0014  stb r11, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u8 ) };
	// 82FBE1A4: 409900FC  ble cr6, 0x82fbe2a0
	if !ctx.cr[6].gt {
	pc = 0x82FBE2A0; continue 'dispatch;
	}
	// 82FBE1A8: 48000008  b 0x82fbe1b0
	pc = 0x82FBE1B0; continue 'dispatch;
            }
            0x82FBE1AC => {
    //   block [0x82FBE1AC..0x82FBE1B0)
	// 82FBE1AC: C01E67C8  lfs f0, 0x67c8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(26568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82FBE1B0; continue 'dispatch;
            }
            0x82FBE1B0 => {
    //   block [0x82FBE1B0..0x82FBE224)
	// 82FBE1B0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBE1B4: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FBE1B8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82FBE1BC: 394AFFFE  addi r10, r10, -2
	ctx.r[10].s64 = ctx.r[10].s64 + -2;
	// 82FBE1C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FBE1C4: 5548E13A  rlwinm r8, r10, 0x1c, 4, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 82FBE1C8: 5567E13A  rlwinm r7, r11, 0x1c, 4, 0x1d
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82FBE1CC: 554A06BE  clrlwi r10, r10, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 82FBE1D0: 556606BE  clrlwi r6, r11, 0x1a
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FBE1D4: 1D6A000C  mulli r11, r10, 0xc
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FBE1D8: 7D48482E  lwzx r10, r8, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FBE1DC: 7D07482E  lwzx r8, r7, r9
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FBE1E0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FBE1E4: 1D26000C  mulli r9, r6, 0xc
	ctx.r[9].s32 = ((ctx.r[6].s32 as i64 * 12 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82FBE1E8: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBE1EC: 7D884C2E  lfsx f12, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBE1F0: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FBE1F4: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBE1F8: 7D484A14  add r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82FBE1FC: C16A0004  lfs f11, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FBE200: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FBE204: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FBE208: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FBE20C: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 82FBE210: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82FBE214: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FBE218: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FBE21C: 41990008  bgt cr6, 0x82fbe224
	if ctx.cr[6].gt {
	pc = 0x82FBE224; continue 'dispatch;
	}
	// 82FBE220: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82FBE224; continue 'dispatch;
            }
            0x82FBE224 => {
    //   block [0x82FBE224..0x82FBE284)
	// 82FBE224: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBE228: 40820078  bne 0x82fbe2a0
	if !ctx.cr[0].eq {
	pc = 0x82FBE2A0; continue 'dispatch;
	}
	// 82FBE22C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBE230: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FBE234: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FBE238: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBE23C: 5568E13A  rlwinm r8, r11, 0x1c, 4, 0x1d
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82FBE240: 556B06BE  clrlwi r11, r11, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FBE244: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82FBE248: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FBE24C: 7D28482E  lwzx r9, r8, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FBE250: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FBE254: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82FBE258: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82FBE25C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBE260: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FBE264: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82FBE268: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82FBE26C: 419A0018  beq cr6, 0x82fbe284
	if ctx.cr[6].eq {
	pc = 0x82FBE284; continue 'dispatch;
	}
	// 82FBE270: 356AFFFF  addic. r11, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBE274: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FBE278: 4182000C  beq 0x82fbe284
	if ctx.cr[0].eq {
	pc = 0x82FBE284; continue 'dispatch;
	}
	// 82FBE27C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FBE280: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82FBE284; continue 'dispatch;
            }
            0x82FBE284 => {
    //   block [0x82FBE284..0x82FBE29C)
	// 82FBE284: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FBE288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBE28C: 480207DD  bl 0x82fdea68
	ctx.lr = 0x82FBE290;
	sub_82FDEA68(ctx, base);
	// 82FBE290: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBE294: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82FBE298: 4199FF14  bgt cr6, 0x82fbe1ac
	if ctx.cr[6].gt {
	pc = 0x82FBE1AC; continue 'dispatch;
	}
	pc = 0x82FBE29C; continue 'dispatch;
            }
            0x82FBE29C => {
    //   block [0x82FBE29C..0x82FBE2A0)
	// 82FBE29C: C01E67C8  lfs f0, 0x67c8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(26568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82FBE2A0; continue 'dispatch;
            }
            0x82FBE2A0 => {
    //   block [0x82FBE2A0..0x82FBE2B0)
	// 82FBE2A0: 897F0014  lbz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FBE2A4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FBE2A8: 4182009C  beq 0x82fbe344
	if ctx.cr[0].eq {
	pc = 0x82FBE344; continue 'dispatch;
	}
	// 82FBE2AC: 4800007C  b 0x82fbe328
	pc = 0x82FBE328; continue 'dispatch;
            }
            0x82FBE2B0 => {
    //   block [0x82FBE2B0..0x82FBE30C)
	// 82FBE2B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBE2B4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FBE2B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FBE2BC: 5569E13A  rlwinm r9, r11, 0x1c, 4, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82FBE2C0: 556B06BE  clrlwi r11, r11, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FBE2C4: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBE2C8: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FBE2CC: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FBE2D0: C1A80000  lfs f13, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBE2D4: C1880004  lfs f12, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBE2D8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FBE2DC: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FBE2E0: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82FBE2E4: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FBE2E8: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82FBE2EC: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FBE2F0: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FBE2F4: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 82FBE2F8: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82FBE2FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FBE300: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FBE304: 41990008  bgt cr6, 0x82fbe30c
	if ctx.cr[6].gt {
	pc = 0x82FBE30C; continue 'dispatch;
	}
	// 82FBE308: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82FBE30C; continue 'dispatch;
            }
            0x82FBE30C => {
    //   block [0x82FBE30C..0x82FBE328)
	// 82FBE30C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBE310: 40820024  bne 0x82fbe334
	if !ctx.cr[0].eq {
	pc = 0x82FBE334; continue 'dispatch;
	}
	// 82FBE314: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBE318: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FBE31C: 419A000C  beq cr6, 0x82fbe328
	if ctx.cr[6].eq {
	pc = 0x82FBE328; continue 'dispatch;
	}
	// 82FBE320: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FBE324: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82FBE328; continue 'dispatch;
            }
            0x82FBE328 => {
    //   block [0x82FBE328..0x82FBE334)
	// 82FBE328: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBE32C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82FBE330: 4199FF80  bgt cr6, 0x82fbe2b0
	if ctx.cr[6].gt {
	pc = 0x82FBE2B0; continue 'dispatch;
	}
	pc = 0x82FBE334; continue 'dispatch;
            }
            0x82FBE334 => {
    //   block [0x82FBE334..0x82FBE344)
	// 82FBE334: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBE338: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82FBE33C: 40980008  bge cr6, 0x82fbe344
	if !ctx.cr[6].lt {
	pc = 0x82FBE344; continue 'dispatch;
	}
	// 82FBE340: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	pc = 0x82FBE344; continue 'dispatch;
            }
            0x82FBE344 => {
    //   block [0x82FBE344..0x82FBE34C)
	// 82FBE344: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FBE348: 4BCEB114  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBE350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FBE350 size=404
    let mut pc: u32 = 0x82FBE350;
    'dispatch: loop {
        match pc {
            0x82FBE350 => {
    //   block [0x82FBE350..0x82FBE414)
	// 82FBE350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBE354: 4BCEB0B5  bl 0x82ca9408
	ctx.lr = 0x82FBE358;
	sub_82CA93D0(ctx, base);
	// 82FBE358: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82FBE35C: 4BCEF96D  bl 0x82cadcc8
	ctx.lr = 0x82FBE360;
	sub_82CADCA0(ctx, base);
	// 82FBE360: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBE364: FF601890  fmr f27, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[3].f64;
	// 82FBE368: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82FBE36C: FF002090  fmr f24, f4
	ctx.f[24].f64 = ctx.f[4].f64;
	// 82FBE370: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82FBE374: FFA00890  fmr f29, f1
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82FBE378: FF801090  fmr f28, f2
	ctx.f[28].f64 = ctx.f[2].f64;
	// 82FBE37C: FF402890  fmr f26, f5
	ctx.f[26].f64 = ctx.f[5].f64;
	// 82FBE380: FF203090  fmr f25, f6
	ctx.f[25].f64 = ctx.f[6].f64;
	// 82FBE384: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 82FBE388: FC20C090  fmr f1, f24
	ctx.f[1].f64 = ctx.f[24].f64;
	// 82FBE38C: 4B1E081D  bl 0x8219eba8
	ctx.lr = 0x82FBE390;
	sub_8219EBA8(ctx, base);
	// 82FBE390: FFC00818  frsp f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FBE394: FC40D090  fmr f2, f26
	ctx.f[2].f64 = ctx.f[26].f64;
	// 82FBE398: FC20C890  fmr f1, f25
	ctx.f[1].f64 = ctx.f[25].f64;
	// 82FBE39C: 4B1E080D  bl 0x8219eba8
	ctx.lr = 0x82FBE3A0;
	sub_8219EBA8(ctx, base);
	// 82FBE3A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBE3A4: C1BC0004  lfs f13, 4(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBE3A8: C19F0000  lfs f12, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBE3AC: FFE00818  frsp f31, f1
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FBE3B0: C00B0A7C  lfs f0, 0xa7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBE3B4: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FBE3B8: EC2D0024  fdivs f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82FBE3BC: 4B2A2585  bl 0x82260940
	ctx.lr = 0x82FBE3C0;
	sub_82260940(ctx, base);
	// 82FBE3C0: EC1DD82A  fadds f0, f29, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[29].f64 + ctx.f[27].f64) as f32) as f64;
	// 82FBE3C4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FBE3C8: EC1CC02A  fadds f0, f28, f24
	ctx.f[0].f64 = ((ctx.f[28].f64 + ctx.f[24].f64) as f32) as f64;
	// 82FBE3CC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FBE3D0: FDA00818  frsp f13, f1
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FBE3D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBE3D8: 3BBF0008  addi r29, r31, 8
	ctx.r[29].s64 = ctx.r[31].s64 + 8;
	// 82FBE3DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FBE3E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FBE3E4: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBE3E8: EF6D0032  fmuls f27, f13, f0
	ctx.f[27].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FBE3EC: 4BF8C98D  bl 0x82f4ad78
	ctx.lr = 0x82FBE3F0;
	sub_82F4AD78(ctx, base);
	// 82FBE3F0: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FBE3F4: FF1EF800  fcmpu cr6, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 82FBE3F8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBE3FC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FBE400: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FBE404: 40990010  ble cr6, 0x82fbe414
	if !ctx.cr[6].gt {
	pc = 0x82FBE414; continue 'dispatch;
	}
	// 82FBE408: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82FBE40C: C00B6924  lfs f0, 0x6924(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26916 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBE410: EFFF002A  fadds f31, f31, f0
	ctx.f[31].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x82FBE414; continue 'dispatch;
            }
            0x82FBE414 => {
    //   block [0x82FBE414..0x82FBE450)
	// 82FBE414: EC1FF028  fsubs f0, f31, f30
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 82FBE418: EDA0D824  fdivs f13, f0, f27
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[27].f64) as f32) as f64;
	// 82FBE41C: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82FBE420: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 82FBE424: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FBE428: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 82FBE42C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FBE430: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82FBE434: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82FBE438: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FBE43C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82FBE440: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82FBE444: EF606824  fdivs f27, f0, f13
	ctx.f[27].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82FBE448: EFFBF02A  fadds f31, f27, f30
	ctx.f[31].f64 = ((ctx.f[27].f64 + ctx.f[30].f64) as f32) as f64;
	// 82FBE44C: 4099005C  ble cr6, 0x82fbe4a8
	if !ctx.cr[6].gt {
	pc = 0x82FBE4A8; continue 'dispatch;
	}
	pc = 0x82FBE450; continue 'dispatch;
            }
            0x82FBE450 => {
    //   block [0x82FBE450..0x82FBE4A8)
	// 82FBE450: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 82FBE454: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82FBE458: 4B27BB39  bl 0x82239f90
	ctx.lr = 0x82FBE45C;
	sub_82239F90(ctx, base);
	// 82FBE45C: FF000818  frsp f24, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[24].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FBE460: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82FBE464: 4B27BA4D  bl 0x82239eb0
	ctx.lr = 0x82FBE468;
	sub_82239EB0(ctx, base);
	// 82FBE468: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FBE46C: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBE470: ED8DE63A  fmadds f12, f13, f24, f28
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[24].f64 + ctx.f[28].f64) as f32) as f64);
	// 82FBE474: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FBE478: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FBE47C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FBE480: EC0DE83A  fmadds f0, f13, f0, f29
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64);
	// 82FBE484: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FBE488: 4BF8C8F1  bl 0x82f4ad78
	ctx.lr = 0x82FBE48C;
	sub_82F4AD78(ctx, base);
	// 82FBE48C: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FBE490: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82FBE494: EFFBF82A  fadds f31, f27, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ((ctx.f[27].f64 + ctx.f[31].f64) as f32) as f64;
	// 82FBE498: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBE49C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FBE4A0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FBE4A4: 4082FFAC  bne 0x82fbe450
	if !ctx.cr[0].eq {
	pc = 0x82FBE450; continue 'dispatch;
	}
	pc = 0x82FBE4A8; continue 'dispatch;
            }
            0x82FBE4A8 => {
    //   block [0x82FBE4A8..0x82FBE4E4)
	// 82FBE4A8: EC1DD02A  fadds f0, f29, f26
	ctx.f[0].f64 = ((ctx.f[29].f64 + ctx.f[26].f64) as f32) as f64;
	// 82FBE4AC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FBE4B0: EC1CC82A  fadds f0, f28, f25
	ctx.f[0].f64 = ((ctx.f[28].f64 + ctx.f[25].f64) as f32) as f64;
	// 82FBE4B4: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FBE4B8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FBE4BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FBE4C0: 4BF8C8B9  bl 0x82f4ad78
	ctx.lr = 0x82FBE4C4;
	sub_82F4AD78(ctx, base);
	// 82FBE4C4: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FBE4C8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBE4CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FBE4D0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FBE4D4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82FBE4D8: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82FBE4DC: 4BCEF839  bl 0x82cadd14
	ctx.lr = 0x82FBE4E0;
	sub_82CADCEC(ctx, base);
	// 82FBE4E0: 4BCEAF78  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBE4E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FBE4E8 size=868
    let mut pc: u32 = 0x82FBE4E8;
    'dispatch: loop {
        match pc {
            0x82FBE4E8 => {
    //   block [0x82FBE4E8..0x82FBE5C4)
	// 82FBE4E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBE4EC: 4BCEAF1D  bl 0x82ca9408
	ctx.lr = 0x82FBE4F0;
	sub_82CA93D0(ctx, base);
	// 82FBE4F0: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82FBE4F4: 4BCEF7B9  bl 0x82cadcac
	ctx.lr = 0x82FBE4F8;
	sub_82CADCA0(ctx, base);
	// 82FBE4F8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBE4FC: FFE01090  fmr f31, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[2].f64;
	// 82FBE500: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82FBE504: FF801890  fmr f28, f3
	ctx.f[28].f64 = ctx.f[3].f64;
	// 82FBE508: C3070000  lfs f24, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82FBE50C: C3450004  lfs f26, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82FBE510: FF602090  fmr f27, f4
	ctx.f[27].f64 = ctx.f[4].f64;
	// 82FBE514: FE802890  fmr f20, f5
	ctx.f[20].f64 = ctx.f[5].f64;
	// 82FBE518: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82FBE51C: FE203890  fmr f17, f7
	ctx.f[17].f64 = ctx.f[7].f64;
	// 82FBE520: C2E70004  lfs f23, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82FBE524: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBE528: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82FBE52C: C3BF0000  lfs f29, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82FBE530: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBE534: C3250000  lfs f25, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82FBE538: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FBE53C: C0BC0004  lfs f5, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82FBE540: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82FBE544: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82FBE548: ECEDF82A  fadds f7, f13, f31
	ctx.f[7].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 82FBE54C: ED9DE02A  fadds f12, f29, f28
	ctx.f[12].f64 = ((ctx.f[29].f64 + ctx.f[28].f64) as f32) as f64;
	// 82FBE550: C26B0C14  lfs f19, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 82FBE554: ED38E02A  fadds f9, f24, f28
	ctx.f[9].f64 = ((ctx.f[24].f64 + ctx.f[28].f64) as f32) as f64;
	// 82FBE558: EC1AF82A  fadds f0, f26, f31
	ctx.f[0].f64 = ((ctx.f[26].f64 + ctx.f[31].f64) as f32) as f64;
	// 82FBE55C: ED6DD82A  fadds f11, f13, f27
	ctx.f[11].f64 = ((ctx.f[13].f64 + ctx.f[27].f64) as f32) as f64;
	// 82FBE560: EE450532  fmuls f18, f5, f20
	ctx.f[18].f64 = (((ctx.f[5].f64 * ctx.f[20].f64) as f32) as f64);
	// 82FBE564: ED5DF02A  fadds f10, f29, f30
	ctx.f[10].f64 = ((ctx.f[29].f64 + ctx.f[30].f64) as f32) as f64;
	// 82FBE568: ED17D82A  fadds f8, f23, f27
	ctx.f[8].f64 = ((ctx.f[23].f64 + ctx.f[27].f64) as f32) as f64;
	// 82FBE56C: EDB9F02A  fadds f13, f25, f30
	ctx.f[13].f64 = ((ctx.f[25].f64 + ctx.f[30].f64) as f32) as f64;
	// 82FBE570: ECA96028  fsubs f5, f9, f12
	ctx.f[5].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FBE574: EC870028  fsubs f4, f7, f0
	ctx.f[4].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 82FBE578: EC685828  fsubs f3, f8, f11
	ctx.f[3].f64 = (((ctx.f[8].f64 - ctx.f[11].f64) as f32) as f64);
	// 82FBE57C: EC4A6828  fsubs f2, f10, f13
	ctx.f[2].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FBE580: EC250132  fmuls f1, f5, f4
	ctx.f[1].f64 = (((ctx.f[5].f64 * ctx.f[4].f64) as f32) as f64);
	// 82FBE584: EC2308B8  fmsubs f1, f3, f2, f1
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[2].f64 - ctx.f[1].f64) as f32) as f64);
	// 82FBE588: FEC00A10  fabs f22, f1
	ctx.f[22].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 82FBE58C: FF163000  fcmpu cr6, f22, f6
	ctx.cr[6].compare_f64(ctx.f[22].f64, ctx.f[6].f64);
	// 82FBE590: 40980034  bge cr6, 0x82fbe5c4
	if !ctx.cr[6].lt {
	pc = 0x82FBE5C4; continue 'dispatch;
	}
	// 82FBE594: ECE0382A  fadds f7, f0, f7
	ctx.f[7].f64 = ((ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64;
	// 82FBE598: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FBE59C: EDAD502A  fadds f13, f13, f10
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82FBE5A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FBE5A4: C00A0A7C  lfs f0, 0xa7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBE5A8: ED67582A  fadds f11, f7, f11
	ctx.f[11].f64 = ((ctx.f[7].f64 + ctx.f[11].f64) as f32) as f64;
	// 82FBE5AC: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82FBE5B0: ED8B402A  fadds f12, f11, f8
	ctx.f[12].f64 = ((ctx.f[11].f64 + ctx.f[8].f64) as f32) as f64;
	// 82FBE5B4: EDAD482A  fadds f13, f13, f9
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64;
	// 82FBE5B8: EEAC0032  fmuls f21, f12, f0
	ctx.f[21].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FBE5BC: EECD0032  fmuls f22, f13, f0
	ctx.f[22].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FBE5C0: 48000024  b 0x82fbe5e4
	pc = 0x82FBE5E4; continue 'dispatch;
            }
            0x82FBE5C4 => {
    //   block [0x82FBE5C4..0x82FBE5E4)
	// 82FBE5C4: ED8D6028  fsubs f12, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FBE5C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FBE5CC: ED605828  fsubs f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82FBE5D0: ED8C00F2  fmuls f12, f12, f3
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[3].f64) as f32) as f64);
	// 82FBE5D4: ED8B6178  fmsubs f12, f11, f5, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[5].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FBE5D8: ED8C0824  fdivs f12, f12, f1
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[1].f64) as f32) as f64;
	// 82FBE5DC: EEC26B3A  fmadds f22, f2, f12, f13
	ctx.f[22].f64 = (((ctx.f[2].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FBE5E0: EEA4033A  fmadds f21, f4, f12, f0
	ctx.f[21].f64 = (((ctx.f[4].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	pc = 0x82FBE5E4; continue 'dispatch;
            }
            0x82FBE5E4 => {
    //   block [0x82FBE5E4..0x82FBE634)
	// 82FBE5E4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBE5E8: 41820054  beq 0x82fbe63c
	if ctx.cr[0].eq {
	pc = 0x82FBE63C; continue 'dispatch;
	}
	// 82FBE5EC: EC16E828  fsubs f0, f22, f29
	ctx.f[0].f64 = (((ctx.f[22].f64 - ctx.f[29].f64) as f32) as f64);
	// 82FBE5F0: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBE5F4: EDB56828  fsubs f13, f21, f13
	ctx.f[13].f64 = (((ctx.f[21].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FBE5F8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FBE5FC: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FBE600: EE60002C  fsqrts f19, f0
	ctx.f[19].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82FBE604: FF139000  fcmpu cr6, f19, f18
	ctx.cr[6].compare_f64(ctx.f[19].f64, ctx.f[18].f64);
	// 82FBE608: 4199002C  bgt cr6, 0x82fbe634
	if ctx.cr[6].gt {
	pc = 0x82FBE634; continue 'dispatch;
	}
	// 82FBE60C: D2C10050  stfs f22, 0x50(r1)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FBE610: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FBE614: D2A10054  stfs f21, 0x54(r1)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FBE618: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82FBE61C: 4BF8C75D  bl 0x82f4ad78
	ctx.lr = 0x82FBE620;
	sub_82F4AD78(ctx, base);
	// 82FBE620: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FBE624: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82FBE628: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBE62C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FBE630: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82FBE634; continue 'dispatch;
            }
            0x82FBE634 => {
    //   block [0x82FBE634..0x82FBE63C)
	// 82FBE634: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82FBE638: 48000084  b 0x82fbe6bc
	pc = 0x82FBE6BC; continue 'dispatch;
            }
            0x82FBE63C => {
    //   block [0x82FBE63C..0x82FBE66C)
	// 82FBE63C: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBE640: ED995028  fsubs f12, f25, f10
	ctx.f[12].f64 = (((ctx.f[25].f64 - ctx.f[10].f64) as f32) as f64);
	// 82FBE644: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82FBE648: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBE64C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82FBE650: C1AB0C18  lfs f13, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBE654: ED7A0028  fsubs f11, f26, f0
	ctx.f[11].f64 = (((ctx.f[26].f64 - ctx.f[0].f64) as f32) as f64);
	// 82FBE658: ED6B07B2  fmuls f11, f11, f30
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[30].f64) as f32) as f64);
	// 82FBE65C: ED8C5FF8  fmsubs f12, f12, f31, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 - ctx.f[11].f64) as f32) as f64);
	// 82FBE660: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82FBE664: 41980008  blt cr6, 0x82fbe66c
	if ctx.cr[6].lt {
	pc = 0x82FBE66C; continue 'dispatch;
	}
	// 82FBE668: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82FBE66C; continue 'dispatch;
            }
            0x82FBE66C => {
    //   block [0x82FBE66C..0x82FBE68C)
	// 82FBE66C: ED970028  fsubs f12, f23, f0
	ctx.f[12].f64 = (((ctx.f[23].f64 - ctx.f[0].f64) as f32) as f64);
	// 82FBE670: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FBE674: ED785028  fsubs f11, f24, f10
	ctx.f[11].f64 = (((ctx.f[24].f64 - ctx.f[10].f64) as f32) as f64);
	// 82FBE678: ED8C07B2  fmuls f12, f12, f30
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[30].f64) as f32) as f64);
	// 82FBE67C: ED8B67F8  fmsubs f12, f11, f31, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[31].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FBE680: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82FBE684: 41980008  blt cr6, 0x82fbe68c
	if ctx.cr[6].lt {
	pc = 0x82FBE68C; continue 'dispatch;
	}
	// 82FBE688: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82FBE68C; continue 'dispatch;
            }
            0x82FBE68C => {
    //   block [0x82FBE68C..0x82FBE6BC)
	// 82FBE68C: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82FBE690: 419A002C  beq cr6, 0x82fbe6bc
	if ctx.cr[6].eq {
	pc = 0x82FBE6BC; continue 'dispatch;
	}
	// 82FBE694: D1410050  stfs f10, 0x50(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FBE698: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FBE69C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FBE6A0: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82FBE6A4: 4BF8C6D5  bl 0x82f4ad78
	ctx.lr = 0x82FBE6A8;
	sub_82F4AD78(ctx, base);
	// 82FBE6A8: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FBE6AC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82FBE6B0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBE6B4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FBE6B8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82FBE6BC; continue 'dispatch;
            }
            0x82FBE6BC => {
    //   block [0x82FBE6BC..0x82FBE738)
	// 82FBE6BC: 552B063F  clrlwi. r11, r9, 0x18
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBE6C0: 4182017C  beq 0x82fbe83c
	if ctx.cr[0].eq {
	pc = 0x82FBE83C; continue 'dispatch;
	}
	// 82FBE6C4: 8161015C  lwz r11, 0x15c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(348 as u32) ) } as u64;
	// 82FBE6C8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82FBE6CC: 419A0104  beq cr6, 0x82fbe7d0
	if ctx.cr[6].eq {
	pc = 0x82FBE7D0; continue 'dispatch;
	}
	// 82FBE6D0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82FBE6D4: 419A00D4  beq cr6, 0x82fbe7a8
	if ctx.cr[6].eq {
	pc = 0x82FBE7A8; continue 'dispatch;
	}
	// 82FBE6D8: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBE6DC: 57AB063F  clrlwi. r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBE6E0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FBE6E4: 41820054  beq 0x82fbe738
	if ctx.cr[0].eq {
	pc = 0x82FBE738; continue 'dispatch;
	}
	// 82FBE6E8: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBE6EC: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82FBE6F0: EDBE6D3A  fmadds f13, f30, f20, f13
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[20].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FBE6F4: 3BBE0008  addi r29, r30, 8
	ctx.r[29].s64 = ctx.r[30].s64 + 8;
	// 82FBE6F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FBE6FC: EC1F053C  fnmsubs f0, f31, f20, f0
	ctx.f[0].f64 = -(((ctx.f[31].f64 * ctx.f[20].f64 - ctx.f[0].f64) as f32) as f64);
	// 82FBE700: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FBE704: EC0DF82A  fadds f0, f13, f31
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 82FBE708: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FBE70C: 4BF8C66D  bl 0x82f4ad78
	ctx.lr = 0x82FBE710;
	sub_82F4AD78(ctx, base);
	// 82FBE710: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FBE714: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBE718: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FBE71C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FBE720: C1BF0000  lfs f13, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBE724: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBE728: EC00D82A  fadds f0, f0, f27
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[27].f64) as f32) as f64;
	// 82FBE72C: EDBB6D3A  fmadds f13, f27, f20, f13
	ctx.f[13].f64 = (((ctx.f[27].f64 * ctx.f[20].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FBE730: EC1C053C  fnmsubs f0, f28, f20, f0
	ctx.f[0].f64 = -(((ctx.f[28].f64 * ctx.f[20].f64 - ctx.f[0].f64) as f32) as f64);
	// 82FBE734: 480000E0  b 0x82fbe814
	pc = 0x82FBE814; continue 'dispatch;
            }
            0x82FBE738 => {
    //   block [0x82FBE738..0x82FBE7A8)
	// 82FBE738: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBE73C: ED60F02A  fadds f11, f0, f30
	ctx.f[11].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82FBE740: EDB28828  fsubs f13, f18, f17
	ctx.f[13].f64 = (((ctx.f[18].f64 - ctx.f[17].f64) as f32) as f64);
	// 82FBE744: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 82FBE748: ED338828  fsubs f9, f19, f17
	ctx.f[9].f64 = (((ctx.f[19].f64 - ctx.f[17].f64) as f32) as f64);
	// 82FBE74C: ED4CF82A  fadds f10, f12, f31
	ctx.f[10].f64 = ((ctx.f[12].f64 + ctx.f[31].f64) as f32) as f64;
	// 82FBE750: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBE754: EFE0E02A  fadds f31, f0, f28
	ctx.f[31].f64 = ((ctx.f[0].f64 + ctx.f[28].f64) as f32) as f64;
	// 82FBE758: EFCCD82A  fadds f30, f12, f27
	ctx.f[30].f64 = ((ctx.f[12].f64 + ctx.f[27].f64) as f32) as f64;
	// 82FBE75C: EC165828  fsubs f0, f22, f11
	ctx.f[0].f64 = (((ctx.f[22].f64 - ctx.f[11].f64) as f32) as f64);
	// 82FBE760: EFAD4824  fdivs f29, f13, f9
	ctx.f[29].f64 = ((ctx.f[13].f64 / ctx.f[9].f64) as f32) as f64;
	// 82FBE764: ED955028  fsubs f12, f21, f10
	ctx.f[12].f64 = (((ctx.f[21].f64 - ctx.f[10].f64) as f32) as f64);
	// 82FBE768: EC005F7A  fmadds f0, f0, f29, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[11].f64) as f32) as f64);
	// 82FBE76C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FBE770: EC0C577A  fmadds f0, f12, f29, f10
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[29].f64 + ctx.f[10].f64) as f32) as f64);
	// 82FBE774: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FBE778: 4BF8C601  bl 0x82f4ad78
	ctx.lr = 0x82FBE77C;
	sub_82F4AD78(ctx, base);
	// 82FBE77C: EC16F828  fsubs f0, f22, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[22].f64 - ctx.f[31].f64) as f32) as f64);
	// 82FBE780: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FBE784: EDB5F028  fsubs f13, f21, f30
	ctx.f[13].f64 = (((ctx.f[21].f64 - ctx.f[30].f64) as f32) as f64);
	// 82FBE788: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBE78C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBE790: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FBE794: EC00FF7A  fmadds f0, f0, f29, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[31].f64) as f32) as f64);
	// 82FBE798: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FBE79C: EC0DF77A  fmadds f0, f13, f29, f30
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[29].f64 + ctx.f[30].f64) as f32) as f64);
	// 82FBE7A0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FBE7A4: 4800007C  b 0x82fbe820
	pc = 0x82FBE820; continue 'dispatch;
            }
            0x82FBE7A8 => {
    //   block [0x82FBE7A8..0x82FBE7D0)
	// 82FBE7A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FBE7AC: C05F0004  lfs f2, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FBE7B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FBE7B4: C03F0000  lfs f1, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FBE7B8: FCC0D890  fmr f6, f27
	ctx.f[6].f64 = ctx.f[27].f64;
	// 82FBE7BC: FCA0E090  fmr f5, f28
	ctx.f[5].f64 = ctx.f[28].f64;
	// 82FBE7C0: FC80F890  fmr f4, f31
	ctx.f[4].f64 = ctx.f[31].f64;
	// 82FBE7C4: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82FBE7C8: 4BFFFB89  bl 0x82fbe350
	ctx.lr = 0x82FBE7CC;
	sub_82FBE350(ctx, base);
	// 82FBE7CC: 48000070  b 0x82fbe83c
	pc = 0x82FBE83C; continue 'dispatch;
            }
            0x82FBE7D0 => {
    //   block [0x82FBE7D0..0x82FBE814)
	// 82FBE7D0: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBE7D4: 3BBE0008  addi r29, r30, 8
	ctx.r[29].s64 = ctx.r[30].s64 + 8;
	// 82FBE7D8: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBE7DC: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82FBE7E0: EDADF82A  fadds f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 82FBE7E4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FBE7E8: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FBE7EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FBE7F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FBE7F4: 4BF8C585  bl 0x82f4ad78
	ctx.lr = 0x82FBE7F8;
	sub_82F4AD78(ctx, base);
	// 82FBE7F8: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FBE7FC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBE800: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FBE804: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FBE808: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBE80C: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBE810: EC00D82A  fadds f0, f0, f27
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[27].f64) as f32) as f64;
	pc = 0x82FBE814; continue 'dispatch;
            }
            0x82FBE814 => {
    //   block [0x82FBE814..0x82FBE820)
	// 82FBE814: EDADE02A  fadds f13, f13, f28
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[28].f64) as f32) as f64;
	// 82FBE818: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FBE81C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x82FBE820; continue 'dispatch;
            }
            0x82FBE820 => {
    //   block [0x82FBE820..0x82FBE83C)
	// 82FBE820: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FBE824: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FBE828: 4BF8C551  bl 0x82f4ad78
	ctx.lr = 0x82FBE82C;
	sub_82F4AD78(ctx, base);
	// 82FBE82C: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FBE830: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBE834: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FBE838: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82FBE83C; continue 'dispatch;
            }
            0x82FBE83C => {
    //   block [0x82FBE83C..0x82FBE84C)
	// 82FBE83C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82FBE840: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82FBE844: 4BCEF4B5  bl 0x82cadcf8
	ctx.lr = 0x82FBE848;
	sub_82CADCEC(ctx, base);
	// 82FBE848: 4BCEAC10  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBE850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FBE850 size=572
    let mut pc: u32 = 0x82FBE850;
    'dispatch: loop {
        match pc {
            0x82FBE850 => {
    //   block [0x82FBE850..0x82FBE8CC)
	// 82FBE850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBE854: 4BCEABB1  bl 0x82ca9404
	ctx.lr = 0x82FBE858;
	sub_82CA93D0(ctx, base);
	// 82FBE858: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82FBE85C: 4BCEF475  bl 0x82cadcd0
	ctx.lr = 0x82FBE860;
	sub_82CADCA0(ctx, base);
	// 82FBE860: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBE864: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82FBE868: C1860004  lfs f12, 4(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBE86C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBE870: C1660000  lfs f11, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FBE874: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82FBE878: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FBE87C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FBE880: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBE884: 2F080002  cmpwi cr6, r8, 2
	ctx.cr[6].compare_i32(ctx.r[8].s32, 2, &mut ctx.xer);
	// 82FBE888: ED4C6828  fsubs f10, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FBE88C: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBE890: C18B0C14  lfs f12, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBE894: ED605828  fsubs f11, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82FBE898: ED8C0824  fdivs f12, f12, f1
	ctx.f[12].f64 = ((ctx.f[12].f64 / ctx.f[1].f64) as f32) as f64;
	// 82FBE89C: C13B0004  lfs f9, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82FBE8A0: C3AA0C18  lfs f29, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82FBE8A4: FF80E890  fmr f28, f29
	ctx.f[28].f64 = ctx.f[29].f64;
	// 82FBE8A8: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FBE8AC: ED8A0332  fmuls f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FBE8B0: EFEB0272  fmuls f31, f11, f9
	ctx.f[31].f64 = (((ctx.f[11].f64 * ctx.f[9].f64) as f32) as f64);
	// 82FBE8B4: EFCC0272  fmuls f30, f12, f9
	ctx.f[30].f64 = (((ctx.f[12].f64 * ctx.f[9].f64) as f32) as f64);
	// 82FBE8B8: 419A0074  beq cr6, 0x82fbe92c
	if ctx.cr[6].eq {
	pc = 0x82FBE92C; continue 'dispatch;
	}
	// 82FBE8BC: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 82FBE8C0: 409A000C  bne cr6, 0x82fbe8cc
	if !ctx.cr[6].eq {
	pc = 0x82FBE8CC; continue 'dispatch;
	}
	// 82FBE8C4: FFA0F890  fmr f29, f31
	ctx.f[29].f64 = ctx.f[31].f64;
	// 82FBE8C8: FF80F090  fmr f28, f30
	ctx.f[28].f64 = ctx.f[30].f64;
	pc = 0x82FBE8CC; continue 'dispatch;
            }
            0x82FBE8CC => {
    //   block [0x82FBE8CC..0x82FBE92C)
	// 82FBE8CC: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82FBE8D0: 3BBE0008  addi r29, r30, 8
	ctx.r[29].s64 = ctx.r[30].s64 + 8;
	// 82FBE8D4: EDADF828  fsubs f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[31].f64) as f32) as f64);
	// 82FBE8D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FBE8DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FBE8E0: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82FBE8E4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FBE8E8: EC0DE028  fsubs f0, f13, f28
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[28].f64) as f32) as f64);
	// 82FBE8EC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FBE8F0: 4BF8C489  bl 0x82f4ad78
	ctx.lr = 0x82FBE8F4;
	sub_82F4AD78(ctx, base);
	// 82FBE8F4: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FBE8F8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FBE8FC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBE900: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FBE904: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FBE908: C1BF0000  lfs f13, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBE90C: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBE910: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82FBE914: EDADE82A  fadds f13, f13, f29
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[29].f64) as f32) as f64;
	// 82FBE918: EC00E028  fsubs f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 82FBE91C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FBE920: EDADF02A  fadds f13, f13, f30
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[30].f64) as f32) as f64;
	// 82FBE924: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FBE928: 4800013C  b 0x82fbea64
	pc = 0x82FBEA64; continue 'dispatch;
            }
            0x82FBE92C => {
    //   block [0x82FBE92C..0x82FBE9E8)
	// 82FBE92C: FC40F050  fneg f2, f30
	ctx.f[2].u64 = ctx.f[30].u64 ^ 0x8000_0000_0000_0000u64;
	// 82FBE930: FC20F850  fneg f1, f31
	ctx.f[1].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
	// 82FBE934: 4B1E0275  bl 0x8219eba8
	ctx.lr = 0x82FBE938;
	sub_8219EBA8(ctx, base);
	// 82FBE938: FF800818  frsp f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FBE93C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBE940: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82FBE944: C19B0004  lfs f12, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBE948: C17E0000  lfs f11, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FBE94C: C00B0A7C  lfs f0, 0xa7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBE950: C1AA67C4  lfs f13, 0x67c4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(26564 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBE954: EC0B603A  fmadds f0, f11, f0, f12
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82FBE958: EDBC682A  fadds f13, f28, f13
	ctx.f[13].f64 = ((ctx.f[28].f64 + ctx.f[13].f64) as f32) as f64;
	// 82FBE95C: EC2C0024  fdivs f1, f12, f0
	ctx.f[1].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 82FBE960: EFADE028  fsubs f29, f13, f28
	ctx.f[29].f64 = (((ctx.f[13].f64 - ctx.f[28].f64) as f32) as f64);
	// 82FBE964: 4B2A1FDD  bl 0x82260940
	ctx.lr = 0x82FBE968;
	sub_82260940(ctx, base);
	// 82FBE968: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FBE96C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBE970: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBE974: 3B9E0008  addi r28, r30, 8
	ctx.r[28].s64 = ctx.r[30].s64 + 8;
	// 82FBE978: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82FBE97C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FBE980: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBE984: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FBE988: ED8CF828  fsubs f12, f12, f31
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[31].f64) as f32) as f64);
	// 82FBE98C: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FBE990: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBE994: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FBE998: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FBE99C: EC1D0024  fdivs f0, f29, f0
	ctx.f[0].f64 = ((ctx.f[29].f64 / ctx.f[0].f64) as f32) as f64;
	// 82FBE9A0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82FBE9A4: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82FBE9A8: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82FBE9AC: 397D0001  addi r11, r29, 1
	ctx.r[11].s64 = ctx.r[29].s64 + 1;
	// 82FBE9B0: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FBE9B4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82FBE9B8: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82FBE9BC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FBE9C0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FBE9C4: EFBD0024  fdivs f29, f29, f0
	ctx.f[29].f64 = ((ctx.f[29].f64 / ctx.f[0].f64) as f32) as f64;
	// 82FBE9C8: EF9DE02A  fadds f28, f29, f28
	ctx.f[28].f64 = ((ctx.f[29].f64 + ctx.f[28].f64) as f32) as f64;
	// 82FBE9CC: 4BF8C3AD  bl 0x82f4ad78
	ctx.lr = 0x82FBE9D0;
	sub_82F4AD78(ctx, base);
	// 82FBE9D0: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FBE9D4: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82FBE9D8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBE9DC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FBE9E0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FBE9E4: 40990064  ble cr6, 0x82fbea48
	if !ctx.cr[6].gt {
	pc = 0x82FBEA48; continue 'dispatch;
	}
	pc = 0x82FBE9E8; continue 'dispatch;
            }
            0x82FBE9E8 => {
    //   block [0x82FBE9E8..0x82FBEA48)
	// 82FBE9E8: FF60E090  fmr f27, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[28].f64;
	// 82FBE9EC: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82FBE9F0: 4B27B5A1  bl 0x82239f90
	ctx.lr = 0x82FBE9F4;
	sub_82239F90(ctx, base);
	// 82FBE9F4: FF400818  frsp f26, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[26].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FBE9F8: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82FBE9FC: 4B27B4B5  bl 0x82239eb0
	ctx.lr = 0x82FBEA00;
	sub_82239EB0(ctx, base);
	// 82FBEA00: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FBEA04: C1BB0004  lfs f13, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBEA08: C19F0000  lfs f12, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBEA0C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FBEA10: C17F0004  lfs f11, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FBEA14: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FBEA18: ED6D5EBA  fmadds f11, f13, f26, f11
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[26].f64 + ctx.f[11].f64) as f32) as f64);
	// 82FBEA1C: D1610054  stfs f11, 0x54(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FBEA20: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82FBEA24: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FBEA28: 4BF8C351  bl 0x82f4ad78
	ctx.lr = 0x82FBEA2C;
	sub_82F4AD78(ctx, base);
	// 82FBEA2C: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FBEA30: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82FBEA34: EF9DE02A  fadds f28, f29, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ((ctx.f[29].f64 + ctx.f[28].f64) as f32) as f64;
	// 82FBEA38: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBEA3C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FBEA40: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FBEA44: 4082FFA4  bne 0x82fbe9e8
	if !ctx.cr[0].eq {
	pc = 0x82FBE9E8; continue 'dispatch;
	}
	pc = 0x82FBEA48; continue 'dispatch;
            }
            0x82FBEA48 => {
    //   block [0x82FBEA48..0x82FBEA64)
	// 82FBEA48: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBEA4C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FBEA50: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBEA54: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82FBEA58: EDADF82A  fadds f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 82FBEA5C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FBEA60: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	pc = 0x82FBEA64; continue 'dispatch;
            }
            0x82FBEA64 => {
    //   block [0x82FBEA64..0x82FBEA8C)
	// 82FBEA64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FBEA68: 4BF8C311  bl 0x82f4ad78
	ctx.lr = 0x82FBEA6C;
	sub_82F4AD78(ctx, base);
	// 82FBEA6C: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FBEA70: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBEA74: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FBEA78: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FBEA7C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82FBEA80: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 82FBEA84: 4BCEF299  bl 0x82cadd1c
	ctx.lr = 0x82FBEA88;
	sub_82CADCEC(ctx, base);
	// 82FBEA88: 4BCEA9CC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBEA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FBEA90 size=720
    let mut pc: u32 = 0x82FBEA90;
    'dispatch: loop {
        match pc {
            0x82FBEA90 => {
    //   block [0x82FBEA90..0x82FBEB48)
	// 82FBEA90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBEA94: 4BCEA979  bl 0x82ca940c
	ctx.lr = 0x82FBEA98;
	sub_82CA93D0(ctx, base);
	// 82FBEA98: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82FBEA9C: 4BCEF23D  bl 0x82cadcd8
	ctx.lr = 0x82FBEAA0;
	sub_82CADCA0(ctx, base);
	// 82FBEAA0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBEAA4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82FBEAA8: C0A50000  lfs f5, 0(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82FBEAAC: C1A70004  lfs f13, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBEAB0: FD800890  fmr f12, f1
	ctx.f[12].f64 = ctx.f[1].f64;
	// 82FBEAB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBEAB8: C0E50004  lfs f7, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82FBEABC: C3A30004  lfs f29, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82FBEAC0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FBEAC4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FBEAC8: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBEACC: C13F0004  lfs f9, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82FBEAD0: ED002828  fsubs f8, f0, f5
	ctx.f[8].f64 = (((ctx.f[0].f64 - ctx.f[5].f64) as f32) as f64);
	// 82FBEAD4: EC6D4828  fsubs f3, f13, f9
	ctx.f[3].f64 = (((ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82FBEAD8: C16B0C14  lfs f11, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FBEADC: C1A70000  lfs f13, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBEAE0: EC850028  fsubs f4, f5, f0
	ctx.f[4].f64 = (((ctx.f[5].f64 - ctx.f[0].f64) as f32) as f64);
	// 82FBEAE4: EFCB1024  fdivs f30, f11, f2
	ctx.f[30].f64 = ((ctx.f[11].f64 / ctx.f[2].f64) as f32) as f64;
	// 82FBEAE8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FBEAEC: ED293828  fsubs f9, f9, f7
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[7].f64) as f32) as f64);
	// 82FBEAF0: C0EA0C18  lfs f7, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82FBEAF4: ED4C102A  fadds f10, f12, f2
	ctx.f[10].f64 = ((ctx.f[12].f64 + ctx.f[2].f64) as f32) as f64;
	// 82FBEAF8: EFEB6024  fdivs f31, f11, f12
	ctx.f[31].f64 = ((ctx.f[11].f64 / ctx.f[12].f64) as f32) as f64;
	// 82FBEAFC: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FBEB00: EF8D0028  fsubs f28, f13, f0
	ctx.f[28].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82FBEB04: C16B67D0  lfs f11, 0x67d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26576 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FBEB08: ED0800F2  fmuls f8, f8, f3
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[3].f64) as f32) as f64);
	// 82FBEB0C: EC7E00F2  fmuls f3, f30, f3
	ctx.f[3].f64 = (((ctx.f[30].f64 * ctx.f[3].f64) as f32) as f64);
	// 82FBEB10: ECCA02F2  fmuls f6, f10, f11
	ctx.f[6].f64 = (((ctx.f[10].f64 * ctx.f[11].f64) as f32) as f64);
	// 82FBEB14: ED4407F2  fmuls f10, f4, f31
	ctx.f[10].f64 = (((ctx.f[4].f64 * ctx.f[31].f64) as f32) as f64);
	// 82FBEB18: EC8107B2  fmuls f4, f1, f30
	ctx.f[4].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 82FBEB1C: ED7F0772  fmuls f11, f31, f29
	ctx.f[11].f64 = (((ctx.f[31].f64 * ctx.f[29].f64) as f32) as f64);
	// 82FBEB20: ED1C4278  fmsubs f8, f28, f9, f8
	ctx.f[8].f64 = (((ctx.f[28].f64 * ctx.f[9].f64 - ctx.f[8].f64) as f32) as f64);
	// 82FBEB24: EFC30772  fmuls f30, f3, f29
	ctx.f[30].f64 = (((ctx.f[3].f64 * ctx.f[29].f64) as f32) as f64);
	// 82FBEB28: ED4A0772  fmuls f10, f10, f29
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[29].f64) as f32) as f64);
	// 82FBEB2C: EFE40772  fmuls f31, f4, f29
	ctx.f[31].f64 = (((ctx.f[4].f64 * ctx.f[29].f64) as f32) as f64);
	// 82FBEB30: EC2B0272  fmuls f1, f11, f9
	ctx.f[1].f64 = (((ctx.f[11].f64 * ctx.f[9].f64) as f32) as f64);
	// 82FBEB34: FF083800  fcmpu cr6, f8, f7
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[7].f64);
	// 82FBEB38: 4099003C  ble cr6, 0x82fbeb74
	if !ctx.cr[6].gt {
	pc = 0x82FBEB74; continue 'dispatch;
	}
	// 82FBEB3C: FF0C1000  fcmpu cr6, f12, f2
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[2].f64);
	// 82FBEB40: 41980008  blt cr6, 0x82fbeb48
	if ctx.cr[6].lt {
	pc = 0x82FBEB48; continue 'dispatch;
	}
	// 82FBEB44: FD801090  fmr f12, f2
	ctx.f[12].f64 = ctx.f[2].f64;
	pc = 0x82FBEB48; continue 'dispatch;
            }
            0x82FBEB48 => {
    //   block [0x82FBEB48..0x82FBEB74)
	// 82FBEB48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FBEB4C: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBEB50: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82FBEB54: ECAC0024  fdivs f5, f12, f0
	ctx.f[5].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 82FBEB58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FBEB5C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82FBEB60: FC80F890  fmr f4, f31
	ctx.f[4].f64 = ctx.f[31].f64;
	// 82FBEB64: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82FBEB68: FC405090  fmr f2, f10
	ctx.f[2].f64 = ctx.f[10].f64;
	// 82FBEB6C: 4BFFF97D  bl 0x82fbe4e8
	ctx.lr = 0x82FBEB70;
	sub_82FBE4E8(ctx, base);
	// 82FBEB70: 480001E0  b 0x82fbed50
	pc = 0x82FBED50; continue 'dispatch;
            }
            0x82FBEB74 => {
    //   block [0x82FBEB74..0x82FBEBAC)
	// 82FBEB74: ED7E082A  fadds f11, f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].f64 = ((ctx.f[30].f64 + ctx.f[1].f64) as f32) as f64;
	// 82FBEB78: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FBEB7C: ED3F502A  fadds f9, f31, f10
	ctx.f[9].f64 = ((ctx.f[31].f64 + ctx.f[10].f64) as f32) as f64;
	// 82FBEB80: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FBEB84: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82FBEB88: C18A0BFC  lfs f12, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBEB8C: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FBEB90: ED890332  fmuls f12, f9, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FBEB94: ED6B02F2  fmuls f11, f11, f11
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82FBEB98: ED8C5B3A  fmadds f12, f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 82FBEB9C: ECE0602C  fsqrts f7, f12
	ctx.f[7].f64 = ((ctx.f[12].f64).sqrt() as f32) as f64;
	// 82FBEBA0: 419A000C  beq cr6, 0x82fbebac
	if ctx.cr[6].eq {
	pc = 0x82FBEBAC; continue 'dispatch;
	}
	// 82FBEBA4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82FBEBA8: 409A00EC  bne cr6, 0x82fbec94
	if !ctx.cr[6].eq {
	pc = 0x82FBEC94; continue 'dispatch;
	}
	pc = 0x82FBEBAC; continue 'dispatch;
            }
            0x82FBEBAC => {
    //   block [0x82FBEBAC..0x82FBEC4C)
	// 82FBEBAC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FBEBB0: C1830004  lfs f12, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBEBB4: ED2C3828  fsubs f9, f12, f7
	ctx.f[9].f64 = (((ctx.f[12].f64 - ctx.f[7].f64) as f32) as f64);
	// 82FBEBB8: C17E0000  lfs f11, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FBEBBC: C18A0C40  lfs f12, 0xc40(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3136 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBEBC0: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FBEBC4: FF096000  fcmpu cr6, f9, f12
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[12].f64);
	// 82FBEBC8: 409800CC  bge cr6, 0x82fbec94
	if !ctx.cr[6].lt {
	pc = 0x82FBEC94; continue 'dispatch;
	}
	// 82FBEBCC: ED2DF02A  fadds f9, f13, f30
	ctx.f[9].f64 = ((ctx.f[13].f64 + ctx.f[30].f64) as f32) as f64;
	// 82FBEBD0: C17F0004  lfs f11, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FBEBD4: C1A50004  lfs f13, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBEBD8: ED80F02A  fadds f12, f0, f30
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82FBEBDC: ED0B502A  fadds f8, f11, f10
	ctx.f[8].f64 = ((ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64;
	// 82FBEBE0: C0E70004  lfs f7, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82FBEBE4: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82FBEBE8: EFC0082A  fadds f30, f0, f1
	ctx.f[30].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 82FBEBEC: EC05082A  fadds f0, f5, f1
	ctx.f[0].f64 = ((ctx.f[5].f64 + ctx.f[1].f64) as f32) as f64;
	// 82FBEBF0: ECE7F82A  fadds f7, f7, f31
	ctx.f[7].f64 = ((ctx.f[7].f64 + ctx.f[31].f64) as f32) as f64;
	// 82FBEBF4: ED6BF82A  fadds f11, f11, f31
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[31].f64) as f32) as f64;
	// 82FBEBF8: ECA96028  fsubs f5, f9, f12
	ctx.f[5].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FBEBFC: EC886828  fsubs f4, f8, f13
	ctx.f[4].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FBEC00: EC5E0028  fsubs f2, f30, f0
	ctx.f[2].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 82FBEC04: EC675828  fsubs f3, f7, f11
	ctx.f[3].f64 = (((ctx.f[7].f64 - ctx.f[11].f64) as f32) as f64);
	// 82FBEC08: EC250132  fmuls f1, f5, f4
	ctx.f[1].f64 = (((ctx.f[5].f64 * ctx.f[4].f64) as f32) as f64);
	// 82FBEC0C: EC2308B8  fmsubs f1, f3, f2, f1
	ctx.f[1].f64 = (((ctx.f[3].f64 * ctx.f[2].f64 - ctx.f[1].f64) as f32) as f64);
	// 82FBEC10: FFE00A10  fabs f31, f1
	ctx.f[31].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 82FBEC14: FF1F3000  fcmpu cr6, f31, f6
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[6].f64);
	// 82FBEC18: 40980034  bge cr6, 0x82fbec4c
	if !ctx.cr[6].lt {
	pc = 0x82FBEC4C; continue 'dispatch;
	}
	// 82FBEC1C: ECC0F02A  fadds f6, f0, f30
	ctx.f[6].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82FBEC20: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FBEC24: EDAD402A  fadds f13, f13, f8
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[8].f64) as f32) as f64;
	// 82FBEC28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FBEC2C: C00A0A7C  lfs f0, 0xa7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBEC30: ED86602A  fadds f12, f6, f12
	ctx.f[12].f64 = ((ctx.f[6].f64 + ctx.f[12].f64) as f32) as f64;
	// 82FBEC34: EDAD582A  fadds f13, f13, f11
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82FBEC38: ED8C482A  fadds f12, f12, f9
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[9].f64) as f32) as f64;
	// 82FBEC3C: EDAD382A  fadds f13, f13, f7
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[7].f64) as f32) as f64;
	// 82FBEC40: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FBEC44: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FBEC48: 48000024  b 0x82fbec6c
	pc = 0x82FBEC6C; continue 'dispatch;
            }
            0x82FBEC4C => {
    //   block [0x82FBEC4C..0x82FBEC6C)
	// 82FBEC4C: ED806028  fsubs f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FBEC50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FBEC54: ED6D5828  fsubs f11, f13, f11
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82FBEC58: ED8C00F2  fmuls f12, f12, f3
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[3].f64) as f32) as f64);
	// 82FBEC5C: ED8B6178  fmsubs f12, f11, f5, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[5].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FBEC60: ED6C0824  fdivs f11, f12, f1
	ctx.f[11].f64 = ((ctx.f[12].f64 / ctx.f[1].f64) as f32) as f64;
	// 82FBEC64: ED8202FA  fmadds f12, f2, f11, f0
	ctx.f[12].f64 = (((ctx.f[2].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FBEC68: EC046AFA  fmadds f0, f4, f11, f13
	ctx.f[0].f64 = (((ctx.f[4].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	pc = 0x82FBEC6C; continue 'dispatch;
            }
            0x82FBEC6C => {
    //   block [0x82FBEC6C..0x82FBEC84)
	// 82FBEC6C: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBEC70: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82FBEC74: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82FBEC78: 4182000C  beq 0x82fbec84
	if ctx.cr[0].eq {
	pc = 0x82FBEC84; continue 'dispatch;
	}
	// 82FBEC7C: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82FBEC80: 48000070  b 0x82fbecf0
	pc = 0x82FBECF0; continue 'dispatch;
            }
            0x82FBEC84 => {
    //   block [0x82FBEC84..0x82FBEC94)
	// 82FBEC84: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBEC88: D3C10080  stfs f30, 0x80(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82FBEC8C: EC00502A  fadds f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 82FBEC90: 48000060  b 0x82fbecf0
	pc = 0x82FBECF0; continue 'dispatch;
            }
            0x82FBEC94 => {
    //   block [0x82FBEC94..0x82FBECF0)
	// 82FBEC94: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82FBEC98: 41980098  blt cr6, 0x82fbed30
	if ctx.cr[6].lt {
	pc = 0x82FBED30; continue 'dispatch;
	}
	// 82FBEC9C: 419A0070  beq cr6, 0x82fbed0c
	if ctx.cr[6].eq {
	pc = 0x82FBED0C; continue 'dispatch;
	}
	// 82FBECA0: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBECA4: EC00082A  fadds f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 82FBECA8: EDAD502A  fadds f13, f13, f10
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82FBECAC: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82FBECB0: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82FBECB4: 3BBE0008  addi r29, r30, 8
	ctx.r[29].s64 = ctx.r[30].s64 + 8;
	// 82FBECB8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82FBECBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FBECC0: 4BF8C0B9  bl 0x82f4ad78
	ctx.lr = 0x82FBECC4;
	sub_82F4AD78(ctx, base);
	// 82FBECC4: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FBECC8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82FBECCC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FBECD0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBECD4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FBECD8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FBECDC: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBECE0: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBECE4: EDADF02A  fadds f13, f13, f30
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[30].f64) as f32) as f64;
	// 82FBECE8: D1A10080  stfs f13, 0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82FBECEC: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	pc = 0x82FBECF0; continue 'dispatch;
            }
            0x82FBECF0 => {
    //   block [0x82FBECF0..0x82FBED0C)
	// 82FBECF0: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82FBECF4: 4BF8C085  bl 0x82f4ad78
	ctx.lr = 0x82FBECF8;
	sub_82F4AD78(ctx, base);
	// 82FBECF8: 815E0030  lwz r10, 0x30(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FBECFC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBED00: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FBED04: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FBED08: 48000048  b 0x82fbed50
	pc = 0x82FBED50; continue 'dispatch;
            }
            0x82FBED0C => {
    //   block [0x82FBED0C..0x82FBED30)
	// 82FBED0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FBED10: FC600890  fmr f3, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[1].f64;
	// 82FBED14: C05F0004  lfs f2, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FBED18: FCC0F890  fmr f6, f31
	ctx.f[6].f64 = ctx.f[31].f64;
	// 82FBED1C: FCA0F090  fmr f5, f30
	ctx.f[5].f64 = ctx.f[30].f64;
	// 82FBED20: FC805090  fmr f4, f10
	ctx.f[4].f64 = ctx.f[10].f64;
	// 82FBED24: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82FBED28: 4BFFF629  bl 0x82fbe350
	ctx.lr = 0x82FBED2C;
	sub_82FBE350(ctx, base);
	// 82FBED2C: 48000024  b 0x82fbed50
	pc = 0x82FBED50; continue 'dispatch;
            }
            0x82FBED30 => {
    //   block [0x82FBED30..0x82FBED50)
	// 82FBED30: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82FBED34: C0A30014  lfs f5, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82FBED38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FBED3C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82FBED40: FC80F890  fmr f4, f31
	ctx.f[4].f64 = ctx.f[31].f64;
	// 82FBED44: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82FBED48: FC405090  fmr f2, f10
	ctx.f[2].f64 = ctx.f[10].f64;
	// 82FBED4C: 4BFFF79D  bl 0x82fbe4e8
	ctx.lr = 0x82FBED50;
	sub_82FBE4E8(ctx, base);
	pc = 0x82FBED50; continue 'dispatch;
            }
            0x82FBED50 => {
    //   block [0x82FBED50..0x82FBED60)
	// 82FBED50: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82FBED54: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82FBED58: 4BCEEFCD  bl 0x82cadd24
	ctx.lr = 0x82FBED5C;
	sub_82CADCEC(ctx, base);
	// 82FBED5C: 4BCEA700  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBED60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FBED60 size=1144
    let mut pc: u32 = 0x82FBED60;
    'dispatch: loop {
        match pc {
            0x82FBED60 => {
    //   block [0x82FBED60..0x82FBEDAC)
	// 82FBED60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBED64: 4BCEA69D  bl 0x82ca9400
	ctx.lr = 0x82FBED68;
	sub_82CA93D0(ctx, base);
	// 82FBED68: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82FBED6C: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBED70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FBED74: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82FBED78: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FBED7C: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82FBED80: 4198044C  blt cr6, 0x82fbf1cc
	if ctx.cr[6].lt {
	pc = 0x82FBF1CC; continue 'dispatch;
	}
	// 82FBED84: 897F002C  lbz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82FBED88: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FBED8C: 41820200  beq 0x82fbef8c
	if ctx.cr[0].eq {
	pc = 0x82FBEF8C; continue 'dispatch;
	}
	// 82FBED90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBED94: 54BC063F  clrlwi. r28, r5, 0x18
	ctx.r[28].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82FBED98: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82FBED9C: 40820010  bne 0x82fbedac
	if !ctx.cr[0].eq {
	pc = 0x82FBEDAC; continue 'dispatch;
	}
	// 82FBEDA0: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBEDA4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82FBEDA8: 409900F4  ble cr6, 0x82fbee9c
	if !ctx.cr[6].gt {
	pc = 0x82FBEE9C; continue 'dispatch;
	}
	pc = 0x82FBEDAC; continue 'dispatch;
            }
            0x82FBEDAC => {
    //   block [0x82FBEDAC..0x82FBEDD0)
	// 82FBEDAC: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82FBEDB0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82FBEDB4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FBEDB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FBEDBC: 48007A15  bl 0x82fc67d0
	ctx.lr = 0x82FBEDC0;
	sub_82FC67D0(ctx, base);
	// 82FBEDC0: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FBEDC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FBEDC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82FBEDCC: 409900C8  ble cr6, 0x82fbee94
	if !ctx.cr[6].gt {
	pc = 0x82FBEE94; continue 'dispatch;
	}
	pc = 0x82FBEDD0; continue 'dispatch;
            }
            0x82FBEDD0 => {
    //   block [0x82FBEDD0..0x82FBEDE0)
	// 82FBEDD0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82FBEDD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FBEDD8: 409A0008  bne cr6, 0x82fbede0
	if !ctx.cr[6].eq {
	pc = 0x82FBEDE0; continue 'dispatch;
	}
	// 82FBEDDC: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	pc = 0x82FBEDE0; continue 'dispatch;
            }
            0x82FBEDE0 => {
    //   block [0x82FBEDE0..0x82FBEDFC)
	// 82FBEDE0: 811F0018  lwz r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FBEDE4: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 82FBEDE8: 392AFFFF  addi r9, r10, -1
	ctx.r[9].s64 = ctx.r[10].s64 + -1;
	// 82FBEDEC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82FBEDF0: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82FBEDF4: 41980008  blt cr6, 0x82fbedfc
	if ctx.cr[6].lt {
	pc = 0x82FBEDFC; continue 'dispatch;
	}
	// 82FBEDF8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	pc = 0x82FBEDFC; continue 'dispatch;
            }
            0x82FBEDFC => {
    //   block [0x82FBEDFC..0x82FBEE0C)
	// 82FBEDFC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82FBEE00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FBEE04: 409A0008  bne cr6, 0x82fbee0c
	if !ctx.cr[6].eq {
	pc = 0x82FBEE0C; continue 'dispatch;
	}
	// 82FBEE08: 811F0018  lwz r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	pc = 0x82FBEE0C; continue 'dispatch;
            }
            0x82FBEE0C => {
    //   block [0x82FBEE0C..0x82FBEE94)
	// 82FBEE0C: 80FF0024  lwz r7, 0x24(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FBEE10: 5566E13A  rlwinm r6, r11, 0x1c, 4, 0x1d
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82FBEE14: 556506BE  clrlwi r5, r11, 0x1a
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FBEE18: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 82FBEE1C: 5523E13A  rlwinm r3, r9, 0x1c, 4, 0x1d
	ctx.r[3].u64 = ctx.r[9].u32 as u64 & 0x0000000Fu64;
	// 82FBEE20: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82FBEE24: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 82FBEE28: 7CE6382E  lwzx r7, r6, r7
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82FBEE2C: 3968FFFF  addi r11, r8, -1
	ctx.r[11].s64 = ctx.r[8].s64 + -1;
	// 82FBEE30: 1D05000C  mulli r8, r5, 0xc
	ctx.r[8].s32 = ((ctx.r[5].s32 as i64 * 12 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82FBEE34: 7CA3202E  lwzx r5, r3, r4
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82FBEE38: 552906BE  clrlwi r9, r9, 0x1a
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000003Fu64;
	// 82FBEE3C: 7CC74214  add r6, r7, r8
	ctx.r[6].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 82FBEE40: 1CE9000C  mulli r7, r9, 0xc
	ctx.r[7].s32 = ((ctx.r[9].s32 as i64 * 12 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 82FBEE44: C0460008  lfs f2, 8(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FBEE48: 5544E13A  rlwinm r4, r10, 0x1c, 4, 0x1d
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 82FBEE4C: 5563E13A  rlwinm r3, r11, 0x1c, 4, 0x1d
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82FBEE50: 7CE53A14  add r7, r5, r7
	ctx.r[7].u64 = ctx.r[5].u64 + ctx.r[7].u64;
	// 82FBEE54: 554A06BE  clrlwi r10, r10, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 82FBEE58: 556B06BE  clrlwi r11, r11, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FBEE5C: 7D04D82E  lwzx r8, r4, r27
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82FBEE60: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FBEE64: 7D23D02E  lwzx r9, r3, r26
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 82FBEE68: C0270008  lfs f1, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FBEE6C: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FBEE70: 7CE85214  add r7, r8, r10
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82FBEE74: 7CA95A14  add r5, r9, r11
	ctx.r[5].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82FBEE78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FBEE7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBEE80: 4BFFFC11  bl 0x82fbea90
	ctx.lr = 0x82FBEE84;
	sub_82FBEA90(ctx, base);
	// 82FBEE84: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FBEE88: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82FBEE8C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FBEE90: 4198FF40  blt cr6, 0x82fbedd0
	if ctx.cr[6].lt {
	pc = 0x82FBEDD0; continue 'dispatch;
	}
	pc = 0x82FBEE94; continue 'dispatch;
            }
            0x82FBEE94 => {
    //   block [0x82FBEE94..0x82FBEE9C)
	// 82FBEE94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FBEE98: 48007A61  bl 0x82fc68f8
	ctx.lr = 0x82FBEE9C;
	sub_82FC68F8(ctx, base);
	pc = 0x82FBEE9C; continue 'dispatch;
            }
            0x82FBEE9C => {
    //   block [0x82FBEE9C..0x82FBEEB0)
	// 82FBEE9C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82FBEEA0: 409A0010  bne cr6, 0x82fbeeb0
	if !ctx.cr[6].eq {
	pc = 0x82FBEEB0; continue 'dispatch;
	}
	// 82FBEEA4: C01F0000  lfs f0, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBEEA8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82FBEEAC: 40980320  bge cr6, 0x82fbf1cc
	if !ctx.cr[6].lt {
	pc = 0x82FBF1CC; continue 'dispatch;
	}
	pc = 0x82FBEEB0; continue 'dispatch;
            }
            0x82FBEEB0 => {
    //   block [0x82FBEEB0..0x82FBEED0)
	// 82FBEEB0: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82FBEEB4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82FBEEB8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FBEEBC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FBEEC0: 48007911  bl 0x82fc67d0
	ctx.lr = 0x82FBEEC4;
	sub_82FC67D0(ctx, base);
	// 82FBEEC4: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FBEEC8: 37CBFFFF  addic. r30, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82FBEECC: 418002F8  blt 0x82fbf1c4
	if ctx.cr[0].lt {
	pc = 0x82FBF1C4; continue 'dispatch;
	}
	pc = 0x82FBEED0; continue 'dispatch;
            }
            0x82FBEED0 => {
    //   block [0x82FBEED0..0x82FBEEE0)
	// 82FBEED0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82FBEED4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82FBEED8: 409A0008  bne cr6, 0x82fbeee0
	if !ctx.cr[6].eq {
	pc = 0x82FBEEE0; continue 'dispatch;
	}
	// 82FBEEDC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	pc = 0x82FBEEE0; continue 'dispatch;
            }
            0x82FBEEE0 => {
    //   block [0x82FBEEE0..0x82FBEEF4)
	// 82FBEEE0: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 82FBEEE4: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82FBEEE8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82FBEEEC: 409A0008  bne cr6, 0x82fbeef4
	if !ctx.cr[6].eq {
	pc = 0x82FBEEF4; continue 'dispatch;
	}
	// 82FBEEF0: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	pc = 0x82FBEEF4; continue 'dispatch;
            }
            0x82FBEEF4 => {
    //   block [0x82FBEEF4..0x82FBEF0C)
	// 82FBEEF4: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FBEEF8: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 82FBEEFC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82FBEF00: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82FBEF04: 41980008  blt cr6, 0x82fbef0c
	if ctx.cr[6].lt {
	pc = 0x82FBEF0C; continue 'dispatch;
	}
	// 82FBEF08: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	pc = 0x82FBEF0C; continue 'dispatch;
            }
            0x82FBEF0C => {
    //   block [0x82FBEF0C..0x82FBEF8C)
	// 82FBEF0C: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FBEF10: 57C7E13A  rlwinm r7, r30, 0x1c, 4, 0x1d
	ctx.r[7].u64 = ctx.r[30].u32 as u64 & 0x0000000Fu64;
	// 82FBEF14: 54C4E13A  rlwinm r4, r6, 0x1c, 4, 0x1d
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x0000000Fu64;
	// 82FBEF18: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 82FBEF1C: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 82FBEF20: 54DC06BE  clrlwi r28, r6, 0x1a
	ctx.r[28].u64 = ctx.r[6].u32 as u64 & 0x0000003Fu64;
	// 82FBEF24: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 82FBEF28: 7D27482E  lwzx r9, r7, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FBEF2C: 57C806BE  clrlwi r8, r30, 0x1a
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x0000003Fu64;
	// 82FBEF30: 7CE4282E  lwzx r7, r4, r5
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 82FBEF34: 1CBC000C  mulli r5, r28, 0xc
	ctx.r[5].s32 = ((ctx.r[28].s32 as i64 * 12 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82FBEF38: 5544E13A  rlwinm r4, r10, 0x1c, 4, 0x1d
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 82FBEF3C: 557AE13A  rlwinm r26, r11, 0x1c, 4, 0x1d
	ctx.r[26].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82FBEF40: 7CE72A14  add r7, r7, r5
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[5].u64;
	// 82FBEF44: 1D08000C  mulli r8, r8, 0xc
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * 12 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82FBEF48: C0470008  lfs f2, 8(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FBEF4C: 554A06BE  clrlwi r10, r10, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 82FBEF50: 556B06BE  clrlwi r11, r11, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FBEF54: 7CC94214  add r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82FBEF58: 7D04182E  lwzx r8, r4, r3
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82FBEF5C: 7D3AD82E  lwzx r9, r26, r27
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82FBEF60: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FBEF64: C0260008  lfs f1, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FBEF68: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FBEF6C: 7CE85214  add r7, r8, r10
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82FBEF70: 7CA95A14  add r5, r9, r11
	ctx.r[5].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82FBEF74: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FBEF78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBEF7C: 4BFFFB15  bl 0x82fbea90
	ctx.lr = 0x82FBEF80;
	sub_82FBEA90(ctx, base);
	// 82FBEF80: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82FBEF84: 4080FF4C  bge 0x82fbeed0
	if !ctx.cr[0].lt {
	pc = 0x82FBEED0; continue 'dispatch;
	}
	// 82FBEF88: 4800023C  b 0x82fbf1c4
	pc = 0x82FBF1C4; continue 'dispatch;
            }
            0x82FBEF8C => {
    //   block [0x82FBEF8C..0x82FBEFD8)
	// 82FBEF8C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82FBEF90: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82FBEF94: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FBEF98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FBEF9C: 48007835  bl 0x82fc67d0
	ctx.lr = 0x82FBEFA0;
	sub_82FC67D0(ctx, base);
	// 82FBEFA0: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FBEFA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FBEFA8: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FBEFAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBEFB0: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBEFB4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82FBEFB8: 38CB000C  addi r6, r11, 0xc
	ctx.r[6].s64 = ctx.r[11].s64 + 12;
	// 82FBEFBC: C0250008  lfs f1, 8(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FBEFC0: 4BFFF891  bl 0x82fbe850
	ctx.lr = 0x82FBEFC4;
	sub_82FBE850(ctx, base);
	// 82FBEFC4: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FBEFC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FBEFCC: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82FBEFD0: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82FBEFD4: 409900CC  ble cr6, 0x82fbf0a0
	if !ctx.cr[6].gt {
	pc = 0x82FBF0A0; continue 'dispatch;
	}
	pc = 0x82FBEFD8; continue 'dispatch;
            }
            0x82FBEFD8 => {
    //   block [0x82FBEFD8..0x82FBEFE8)
	// 82FBEFD8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82FBEFDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FBEFE0: 409A0008  bne cr6, 0x82fbefe8
	if !ctx.cr[6].eq {
	pc = 0x82FBEFE8; continue 'dispatch;
	}
	// 82FBEFE4: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	pc = 0x82FBEFE8; continue 'dispatch;
            }
            0x82FBEFE8 => {
    //   block [0x82FBEFE8..0x82FBF004)
	// 82FBEFE8: 811F0018  lwz r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FBEFEC: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 82FBEFF0: 392AFFFF  addi r9, r10, -1
	ctx.r[9].s64 = ctx.r[10].s64 + -1;
	// 82FBEFF4: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82FBEFF8: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82FBEFFC: 41980008  blt cr6, 0x82fbf004
	if ctx.cr[6].lt {
	pc = 0x82FBF004; continue 'dispatch;
	}
	// 82FBF000: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	pc = 0x82FBF004; continue 'dispatch;
            }
            0x82FBF004 => {
    //   block [0x82FBF004..0x82FBF014)
	// 82FBF004: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82FBF008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FBF00C: 409A0008  bne cr6, 0x82fbf014
	if !ctx.cr[6].eq {
	pc = 0x82FBF014; continue 'dispatch;
	}
	// 82FBF010: 811F0018  lwz r8, 0x18(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	pc = 0x82FBF014; continue 'dispatch;
            }
            0x82FBF014 => {
    //   block [0x82FBF014..0x82FBF0A0)
	// 82FBF014: 80FF0024  lwz r7, 0x24(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FBF018: 5566E13A  rlwinm r6, r11, 0x1c, 4, 0x1d
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82FBF01C: 5523E13A  rlwinm r3, r9, 0x1c, 4, 0x1d
	ctx.r[3].u64 = ctx.r[9].u32 as u64 & 0x0000000Fu64;
	// 82FBF020: 7CE53B78  mr r5, r7
	ctx.r[5].u64 = ctx.r[7].u64;
	// 82FBF024: 556406BE  clrlwi r4, r11, 0x1a
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FBF028: 3968FFFF  addi r11, r8, -1
	ctx.r[11].s64 = ctx.r[8].s64 + -1;
	// 82FBF02C: 552906BE  clrlwi r9, r9, 0x1a
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000003Fu64;
	// 82FBF030: 7D06382E  lwzx r8, r6, r7
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82FBF034: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82FBF038: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82FBF03C: 7CE3282E  lwzx r7, r3, r5
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 82FBF040: 1CC4000C  mulli r6, r4, 0xc
	ctx.r[6].s32 = ((ctx.r[4].s32 as i64 * 12 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 82FBF044: 1CA9000C  mulli r5, r9, 0xc
	ctx.r[5].s32 = ((ctx.r[9].s32 as i64 * 12 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82FBF048: 5544E13A  rlwinm r4, r10, 0x1c, 4, 0x1d
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 82FBF04C: 5563E13A  rlwinm r3, r11, 0x1c, 4, 0x1d
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82FBF050: 7CE72A14  add r7, r7, r5
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[5].u64;
	// 82FBF054: 554A06BE  clrlwi r10, r10, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 82FBF058: 556B06BE  clrlwi r11, r11, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FBF05C: 7CC83214  add r6, r8, r6
	ctx.r[6].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 82FBF060: 7D04E02E  lwzx r8, r4, r28
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82FBF064: 7D23D82E  lwzx r9, r3, r27
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82FBF068: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FBF06C: C0270008  lfs f1, 8(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FBF070: C0460008  lfs f2, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FBF074: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FBF078: 7CE85214  add r7, r8, r10
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82FBF07C: 7CA95A14  add r5, r9, r11
	ctx.r[5].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82FBF080: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FBF084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBF088: 4BFFFA09  bl 0x82fbea90
	ctx.lr = 0x82FBF08C;
	sub_82FBEA90(ctx, base);
	// 82FBF08C: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FBF090: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82FBF094: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82FBF098: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FBF09C: 4198FF3C  blt cr6, 0x82fbefd8
	if ctx.cr[6].lt {
	pc = 0x82FBEFD8; continue 'dispatch;
	}
	pc = 0x82FBF0A0; continue 'dispatch;
            }
            0x82FBF0A0 => {
    //   block [0x82FBF0A0..0x82FBF10C)
	// 82FBF0A0: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FBF0A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FBF0A8: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FBF0AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBF0B0: 396AFFFE  addi r11, r10, -2
	ctx.r[11].s64 = ctx.r[10].s64 + -2;
	// 82FBF0B4: 811F0010  lwz r8, 0x10(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FBF0B8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82FBF0BC: 5567E13A  rlwinm r7, r11, 0x1c, 4, 0x1d
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82FBF0C0: 556606BE  clrlwi r6, r11, 0x1a
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FBF0C4: 557EE13A  rlwinm r30, r11, 0x1c, 4, 0x1d
	ctx.r[30].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82FBF0C8: 1CA6000C  mulli r5, r6, 0xc
	ctx.r[5].s32 = ((ctx.r[6].s32 as i64 * 12 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82FBF0CC: 7CC7482E  lwzx r6, r7, r9
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FBF0D0: 7CFE482E  lwzx r7, r30, r9
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FBF0D4: 555CE13A  rlwinm r28, r10, 0x1c, 4, 0x1d
	ctx.r[28].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 82FBF0D8: 7CC62A14  add r6, r6, r5
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[5].u64;
	// 82FBF0DC: 556B06BE  clrlwi r11, r11, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FBF0E0: 555E06BE  clrlwi r30, r10, 0x1a
	ctx.r[30].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 82FBF0E4: 1D4B000C  mulli r10, r11, 0xc
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FBF0E8: 7D3C482E  lwzx r9, r28, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FBF0EC: C0260008  lfs f1, 8(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FBF0F0: 1D7E000C  mulli r11, r30, 0xc
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FBF0F4: 7CC75214  add r6, r7, r10
	ctx.r[6].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 82FBF0F8: 7CA95A14  add r5, r9, r11
	ctx.r[5].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82FBF0FC: 4BFFF755  bl 0x82fbe850
	ctx.lr = 0x82FBF100;
	sub_82FBE850(ctx, base);
	// 82FBF100: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FBF104: 37CBFFFE  addic. r30, r11, -2
	ctx.xer.ca = (ctx.r[11].u32 > (!(-2 as u32)));
	ctx.r[30].s64 = ctx.r[11].s64 + -2;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82FBF108: 418200BC  beq 0x82fbf1c4
	if ctx.cr[0].eq {
	pc = 0x82FBF1C4; continue 'dispatch;
	}
	pc = 0x82FBF10C; continue 'dispatch;
            }
            0x82FBF10C => {
    //   block [0x82FBF10C..0x82FBF11C)
	// 82FBF10C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82FBF110: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82FBF114: 409A0008  bne cr6, 0x82fbf11c
	if !ctx.cr[6].eq {
	pc = 0x82FBF11C; continue 'dispatch;
	}
	// 82FBF118: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	pc = 0x82FBF11C; continue 'dispatch;
            }
            0x82FBF11C => {
    //   block [0x82FBF11C..0x82FBF130)
	// 82FBF11C: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 82FBF120: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82FBF124: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82FBF128: 409A0008  bne cr6, 0x82fbf130
	if !ctx.cr[6].eq {
	pc = 0x82FBF130; continue 'dispatch;
	}
	// 82FBF12C: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	pc = 0x82FBF130; continue 'dispatch;
            }
            0x82FBF130 => {
    //   block [0x82FBF130..0x82FBF148)
	// 82FBF130: 813F0018  lwz r9, 0x18(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FBF134: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 82FBF138: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82FBF13C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82FBF140: 41980008  blt cr6, 0x82fbf148
	if ctx.cr[6].lt {
	pc = 0x82FBF148; continue 'dispatch;
	}
	// 82FBF144: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	pc = 0x82FBF148; continue 'dispatch;
            }
            0x82FBF148 => {
    //   block [0x82FBF148..0x82FBF1C4)
	// 82FBF148: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FBF14C: 57C7E13A  rlwinm r7, r30, 0x1c, 4, 0x1d
	ctx.r[7].u64 = ctx.r[30].u32 as u64 & 0x0000000Fu64;
	// 82FBF150: 54C4E13A  rlwinm r4, r6, 0x1c, 4, 0x1d
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0x0000000Fu64;
	// 82FBF154: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 82FBF158: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 82FBF15C: 54DC06BE  clrlwi r28, r6, 0x1a
	ctx.r[28].u64 = ctx.r[6].u32 as u64 & 0x0000003Fu64;
	// 82FBF160: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	// 82FBF164: 7D27482E  lwzx r9, r7, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FBF168: 57C806BE  clrlwi r8, r30, 0x1a
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x0000003Fu64;
	// 82FBF16C: 7CE4282E  lwzx r7, r4, r5
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 82FBF170: 1CBC000C  mulli r5, r28, 0xc
	ctx.r[5].s32 = ((ctx.r[28].s32 as i64 * 12 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82FBF174: 5544E13A  rlwinm r4, r10, 0x1c, 4, 0x1d
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 82FBF178: 557AE13A  rlwinm r26, r11, 0x1c, 4, 0x1d
	ctx.r[26].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82FBF17C: 7CE72A14  add r7, r7, r5
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[5].u64;
	// 82FBF180: 1D08000C  mulli r8, r8, 0xc
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * 12 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82FBF184: C0470008  lfs f2, 8(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FBF188: 554A06BE  clrlwi r10, r10, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 82FBF18C: 556B06BE  clrlwi r11, r11, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FBF190: 7CC94214  add r6, r9, r8
	ctx.r[6].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82FBF194: 7D04182E  lwzx r8, r4, r3
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82FBF198: 7D3AD82E  lwzx r9, r26, r27
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82FBF19C: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FBF1A0: C0260008  lfs f1, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FBF1A4: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FBF1A8: 7CE85214  add r7, r8, r10
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82FBF1AC: 7CA95A14  add r5, r9, r11
	ctx.r[5].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82FBF1B0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FBF1B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBF1B8: 4BFFF8D9  bl 0x82fbea90
	ctx.lr = 0x82FBF1BC;
	sub_82FBEA90(ctx, base);
	// 82FBF1BC: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82FBF1C0: 4082FF4C  bne 0x82fbf10c
	if !ctx.cr[0].eq {
	pc = 0x82FBF10C; continue 'dispatch;
	}
	pc = 0x82FBF1C4; continue 'dispatch;
            }
            0x82FBF1C4 => {
    //   block [0x82FBF1C4..0x82FBF1CC)
	// 82FBF1C4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FBF1C8: 48007731  bl 0x82fc68f8
	ctx.lr = 0x82FBF1CC;
	sub_82FC68F8(ctx, base);
	pc = 0x82FBF1CC; continue 'dispatch;
            }
            0x82FBF1CC => {
    //   block [0x82FBF1CC..0x82FBF1D8)
	// 82FBF1CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82FBF1D0: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82FBF1D4: 4BCEA27C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBF1D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FBF1D8 size=896
    let mut pc: u32 = 0x82FBF1D8;
    'dispatch: loop {
        match pc {
            0x82FBF1D8 => {
    //   block [0x82FBF1D8..0x82FBF228)
	// 82FBF1D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBF1DC: 4BCEA211  bl 0x82ca93ec
	ctx.lr = 0x82FBF1E0;
	sub_82CA93D0(ctx, base);
	// 82FBF1E0: DBE1FF98  stfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 82FBF1E4: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBF1E8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82FBF1EC: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82FBF1F0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82FBF1F4: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 82FBF1F8: 7CD53378  mr r21, r6
	ctx.r[21].u64 = ctx.r[6].u64;
	// 82FBF1FC: 935B0018  stw r26, 0x18(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[26].u32 ) };
	// 82FBF200: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 82FBF204: 9B5B002C  stb r26, 0x2c(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(44 as u32), ctx.r[26].u8 ) };
	// 82FBF208: 3BFB0018  addi r31, r27, 0x18
	ctx.r[31].s64 = ctx.r[27].s64 + 24;
	// 82FBF20C: 8178001C  lwz r11, 0x1c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FBF210: 7F59D378  mr r25, r26
	ctx.r[25].u64 = ctx.r[26].u64;
	// 82FBF214: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FBF218: 40990304  ble cr6, 0x82fbf51c
	if !ctx.cr[6].gt {
	pc = 0x82FBF51C; continue 'dispatch;
	}
	// 82FBF21C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBF220: 3F808204  lis r28, -0x7dfc
	ctx.r[28].s64 = -2113667072;
	// 82FBF224: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82FBF228; continue 'dispatch;
            }
            0x82FBF228 => {
    //   block [0x82FBF228..0x82FBF254)
	// 82FBF228: 81580028  lwz r10, 0x28(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FBF22C: 5729E13A  rlwinm r9, r25, 0x1c, 4, 0x1d
	ctx.r[9].u64 = ctx.r[25].u32 as u64 & 0x0000000Fu64;
	// 82FBF230: 572B06BE  clrlwi r11, r25, 0x1a
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x0000003Fu64;
	// 82FBF234: 2F160000  cmpwi cr6, r22, 0
	ctx.cr[6].compare_i32(ctx.r[22].s32, 0, &mut ctx.xer);
	// 82FBF238: 1D6B0018  mulli r11, r11, 0x18
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FBF23C: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FBF240: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FBF244: 41980010  blt cr6, 0x82fbf254
	if ctx.cr[6].lt {
	pc = 0x82FBF254; continue 'dispatch;
	}
	// 82FBF248: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FBF24C: 7F0BB000  cmpw cr6, r11, r22
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[22].s32, &mut ctx.xer);
	// 82FBF250: 409A02BC  bne cr6, 0x82fbf50c
	if !ctx.cr[6].eq {
	pc = 0x82FBF50C; continue 'dispatch;
	}
	pc = 0x82FBF254; continue 'dispatch;
            }
            0x82FBF254 => {
    //   block [0x82FBF254..0x82FBF2E0)
	// 82FBF254: 80FE0004  lwz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBF258: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82FBF25C: 419A02B0  beq cr6, 0x82fbf50c
	if ctx.cr[6].eq {
	pc = 0x82FBF50C; continue 'dispatch;
	}
	// 82FBF260: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBF264: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82FBF268: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82FBF26C: 419A0074  beq cr6, 0x82fbf2e0
	if ctx.cr[6].eq {
	pc = 0x82FBF2E0; continue 'dispatch;
	}
	// 82FBF270: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBF274: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 82FBF278: 80DE0008  lwz r6, 8(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FBF27C: C01C67C8  lfs f0, 0x67c8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBF280: 80BB0024  lwz r5, 0x24(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FBF284: 5564E13A  rlwinm r4, r11, 0x1c, 4, 0x1d
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82FBF288: 54C3D1BA  rlwinm r3, r6, 0x1a, 6, 0x1d
	ctx.r[3].u64 = ctx.r[6].u32 as u64 & 0x0000003Fu64;
	// 82FBF28C: 54C61D78  rlwinm r6, r6, 3, 0x15, 0x1c
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0x1FFFFFFFu64;
	// 82FBF290: 83AA0014  lwz r29, 0x14(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FBF294: 556B06BE  clrlwi r11, r11, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FBF298: 7D44282E  lwzx r10, r4, r5
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 82FBF29C: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FBF2A0: 7CA3E82E  lwzx r5, r3, r29
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82FBF2A4: 7CC5302A  ldx r6, r5, r6
	ctx.r[6].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32)) };
	// 82FBF2A8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FBF2AC: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 82FBF2B0: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBF2B4: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBF2B8: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FBF2BC: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FBF2C0: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FBF2C4: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FBF2C8: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82FBF2CC: EDAD637A  fmadds f13, f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82FBF2D0: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 82FBF2D4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FBF2D8: 41990008  bgt cr6, 0x82fbf2e0
	if ctx.cr[6].gt {
	pc = 0x82FBF2E0; continue 'dispatch;
	}
	// 82FBF2DC: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	pc = 0x82FBF2E0; continue 'dispatch;
            }
            0x82FBF2E0 => {
    //   block [0x82FBF2E0..0x82FBF2F8)
	// 82FBF2E0: 550B063F  clrlwi. r11, r8, 0x18
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBF2E4: 418200FC  beq 0x82fbf3e0
	if ctx.cr[0].eq {
	pc = 0x82FBF3E0; continue 'dispatch;
	}
	// 82FBF2E8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82FBF2EC: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 82FBF2F0: 4099021C  ble cr6, 0x82fbf50c
	if !ctx.cr[6].gt {
	pc = 0x82FBF50C; continue 'dispatch;
	}
	// 82FBF2F4: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	pc = 0x82FBF2F8; continue 'dispatch;
            }
            0x82FBF2F8 => {
    //   block [0x82FBF2F8..0x82FBF3A4)
	// 82FBF2F8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FBF2FC: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBF300: 7D4BEA14  add r10, r11, r29
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82FBF304: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBF308: 5548D1BA  rlwinm r8, r10, 0x1a, 6, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 82FBF30C: 554A1D78  rlwinm r10, r10, 3, 0x15, 0x1c
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 82FBF310: 81290014  lwz r9, 0x14(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FBF314: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82FBF318: 7D28482E  lwzx r9, r8, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FBF31C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82FBF320: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBF324: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBF328: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82FBF32C: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82FBF330: 40990090  ble cr6, 0x82fbf3c0
	if !ctx.cr[6].gt {
	pc = 0x82FBF3C0; continue 'dispatch;
	}
	// 82FBF334: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 82FBF338: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FBF33C: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 82FBF340: C01C67C8  lfs f0, 0x67c8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBF344: 5548E13A  rlwinm r8, r10, 0x1c, 4, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 82FBF348: 5567E13A  rlwinm r7, r11, 0x1c, 4, 0x1d
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82FBF34C: 556B06BE  clrlwi r11, r11, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FBF350: 554606BE  clrlwi r6, r10, 0x1a
	ctx.r[6].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 82FBF354: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FBF358: 7D08482E  lwzx r8, r8, r9
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FBF35C: 7D47482E  lwzx r10, r7, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FBF360: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FBF364: 1D26000C  mulli r9, r6, 0xc
	ctx.r[9].s32 = ((ctx.r[6].s32 as i64 * 12 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82FBF368: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBF36C: 7D884C2E  lfsx f12, r8, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBF370: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FBF374: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBF378: 7D484A14  add r10, r8, r9
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82FBF37C: C16A0004  lfs f11, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FBF380: ED8B6028  fsubs f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FBF384: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FBF388: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FBF38C: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 82FBF390: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82FBF394: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FBF398: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FBF39C: 41990008  bgt cr6, 0x82fbf3a4
	if ctx.cr[6].gt {
	pc = 0x82FBF3A4; continue 'dispatch;
	}
	// 82FBF3A0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82FBF3A4; continue 'dispatch;
            }
            0x82FBF3A4 => {
    //   block [0x82FBF3A4..0x82FBF3C0)
	// 82FBF3A4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBF3A8: 40820018  bne 0x82fbf3c0
	if !ctx.cr[0].eq {
	pc = 0x82FBF3C0; continue 'dispatch;
	}
	// 82FBF3AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBF3B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FBF3B4: 419A000C  beq cr6, 0x82fbf3c0
	if ctx.cr[6].eq {
	pc = 0x82FBF3C0; continue 'dispatch;
	}
	// 82FBF3B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FBF3BC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82FBF3C0; continue 'dispatch;
            }
            0x82FBF3C0 => {
    //   block [0x82FBF3C0..0x82FBF3E0)
	// 82FBF3C0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82FBF3C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBF3C8: 4801F6A1  bl 0x82fdea68
	ctx.lr = 0x82FBF3CC;
	sub_82FDEA68(ctx, base);
	// 82FBF3CC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBF3D0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82FBF3D4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FBF3D8: 4198FF20  blt cr6, 0x82fbf2f8
	if ctx.cr[6].lt {
	pc = 0x82FBF2F8; continue 'dispatch;
	}
	// 82FBF3DC: 48000130  b 0x82fbf50c
	pc = 0x82FBF50C; continue 'dispatch;
            }
            0x82FBF3E0 => {
    //   block [0x82FBF3E0..0x82FBF414)
	// 82FBF3E0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82FBF3E4: 419A0030  beq cr6, 0x82fbf414
	if ctx.cr[6].eq {
	pc = 0x82FBF414; continue 'dispatch;
	}
	// 82FBF3E8: 56EB063E  clrlwi r11, r23, 0x18
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	// 82FBF3EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBF3F0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82FBF3F4: 5564DFFE  rlwinm r4, r11, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82FBF3F8: 4BFFEC59  bl 0x82fbe050
	ctx.lr = 0x82FBF3FC;
	sub_82FBE050(ctx, base);
	// 82FBF3FC: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 82FBF400: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82FBF404: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82FBF408: 4BFFF959  bl 0x82fbed60
	ctx.lr = 0x82FBF40C;
	sub_82FBED60(ctx, base);
	// 82FBF40C: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82FBF410: 9B5F0014  stb r26, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[26].u8 ) };
	pc = 0x82FBF414; continue 'dispatch;
            }
            0x82FBF414 => {
    //   block [0x82FBF414..0x82FBF428)
	// 82FBF414: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBF418: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82FBF41C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FBF420: 409900EC  ble cr6, 0x82fbf50c
	if !ctx.cr[6].gt {
	pc = 0x82FBF50C; continue 'dispatch;
	}
	// 82FBF424: D3E10070  stfs f31, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	pc = 0x82FBF428; continue 'dispatch;
            }
            0x82FBF428 => {
    //   block [0x82FBF428..0x82FBF4D4)
	// 82FBF428: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FBF42C: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBF430: 7D4BEA14  add r10, r11, r29
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82FBF434: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBF438: 5547D1BA  rlwinm r7, r10, 0x1a, 6, 0x1d
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 82FBF43C: 55491D78  rlwinm r9, r10, 3, 0x15, 0x1c
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 82FBF440: 81480014  lwz r10, 0x14(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FBF444: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82FBF448: 7D47502E  lwzx r10, r7, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FBF44C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82FBF450: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBF454: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBF458: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82FBF45C: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82FBF460: 40990090  ble cr6, 0x82fbf4f0
	if !ctx.cr[6].gt {
	pc = 0x82FBF4F0; continue 'dispatch;
	}
	// 82FBF464: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 82FBF468: 811F000C  lwz r8, 0xc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FBF46C: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 82FBF470: C01C67C8  lfs f0, 0x67c8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(26568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBF474: 5547E13A  rlwinm r7, r10, 0x1c, 4, 0x1d
	ctx.r[7].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 82FBF478: 5566E13A  rlwinm r6, r11, 0x1c, 4, 0x1d
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82FBF47C: 554A06BE  clrlwi r10, r10, 0x1a
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 82FBF480: 556506BE  clrlwi r5, r11, 0x1a
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FBF484: 1D2A000C  mulli r9, r10, 0xc
	ctx.r[9].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82FBF488: 7D47402E  lwzx r10, r7, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82FBF48C: 7D66402E  lwzx r11, r6, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82FBF490: 1D05000C  mulli r8, r5, 0xc
	ctx.r[8].s32 = ((ctx.r[5].s32 as i64 * 12 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82FBF494: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82FBF498: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82FBF49C: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBF4A0: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBF4A4: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FBF4A8: C18A0004  lfs f12, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBF4AC: C16B0004  lfs f11, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FBF4B0: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82FBF4B4: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FBF4B8: EDAC6B3A  fmadds f13, f12, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FBF4BC: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 82FBF4C0: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82FBF4C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FBF4C8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FBF4CC: 41990008  bgt cr6, 0x82fbf4d4
	if ctx.cr[6].gt {
	pc = 0x82FBF4D4; continue 'dispatch;
	}
	// 82FBF4D0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x82FBF4D4; continue 'dispatch;
            }
            0x82FBF4D4 => {
    //   block [0x82FBF4D4..0x82FBF4F0)
	// 82FBF4D4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBF4D8: 40820018  bne 0x82fbf4f0
	if !ctx.cr[0].eq {
	pc = 0x82FBF4F0; continue 'dispatch;
	}
	// 82FBF4DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBF4E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FBF4E4: 419A000C  beq cr6, 0x82fbf4f0
	if ctx.cr[6].eq {
	pc = 0x82FBF4F0; continue 'dispatch;
	}
	// 82FBF4E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FBF4EC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82FBF4F0; continue 'dispatch;
            }
            0x82FBF4F0 => {
    //   block [0x82FBF4F0..0x82FBF50C)
	// 82FBF4F0: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82FBF4F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBF4F8: 4801F571  bl 0x82fdea68
	ctx.lr = 0x82FBF4FC;
	sub_82FDEA68(ctx, base);
	// 82FBF4FC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBF500: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82FBF504: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FBF508: 4198FF20  blt cr6, 0x82fbf428
	if ctx.cr[6].lt {
	pc = 0x82FBF428; continue 'dispatch;
	}
	pc = 0x82FBF50C; continue 'dispatch;
            }
            0x82FBF50C => {
    //   block [0x82FBF50C..0x82FBF51C)
	// 82FBF50C: 8178001C  lwz r11, 0x1c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FBF510: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 82FBF514: 7F195840  cmplw cr6, r25, r11
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FBF518: 4198FD10  blt cr6, 0x82fbf228
	if ctx.cr[6].lt {
	pc = 0x82FBF228; continue 'dispatch;
	}
	pc = 0x82FBF51C; continue 'dispatch;
            }
            0x82FBF51C => {
    //   block [0x82FBF51C..0x82FBF54C)
	// 82FBF51C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBF520: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82FBF524: 40990028  ble cr6, 0x82fbf54c
	if !ctx.cr[6].gt {
	pc = 0x82FBF54C; continue 'dispatch;
	}
	// 82FBF528: 56EB063E  clrlwi r11, r23, 0x18
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	// 82FBF52C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBF530: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82FBF534: 5564DFFE  rlwinm r4, r11, 0x1b, 0x1f, 0x1f
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82FBF538: 4BFFEB19  bl 0x82fbe050
	ctx.lr = 0x82FBF53C;
	sub_82FBE050(ctx, base);
	// 82FBF53C: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 82FBF540: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82FBF544: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82FBF548: 4BFFF819  bl 0x82fbed60
	ctx.lr = 0x82FBF54C;
	sub_82FBED60(ctx, base);
	pc = 0x82FBF54C; continue 'dispatch;
            }
            0x82FBF54C => {
    //   block [0x82FBF54C..0x82FBF558)
	// 82FBF54C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82FBF550: CBE1FF98  lfd f31, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 82FBF554: 4BCE9EE8  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBF558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FBF558 size=60
    let mut pc: u32 = 0x82FBF558;
    'dispatch: loop {
        match pc {
            0x82FBF558 => {
    //   block [0x82FBF558..0x82FBF594)
	// 82FBF558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBF55C: 4BCE9EB1  bl 0x82ca940c
	ctx.lr = 0x82FBF560;
	sub_82CA93D0(ctx, base);
	// 82FBF560: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBF564: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FBF568: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FBF56C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FBF570: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FBF574: 4BF4023D  bl 0x82eff7b0
	ctx.lr = 0x82FBF578;
	sub_82EFF7B0(ctx, base);
	// 82FBF578: 987F0000  stb r3, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u8 ) };
	// 82FBF57C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82FBF580: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82FBF584: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FBF588: 4BF85F21  bl 0x82f454a8
	ctx.lr = 0x82FBF58C;
	sub_82F454A8(ctx, base);
	// 82FBF58C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FBF590: 4BCE9ECC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBF598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FBF598 size=76
    let mut pc: u32 = 0x82FBF598;
    'dispatch: loop {
        match pc {
            0x82FBF598 => {
    //   block [0x82FBF598..0x82FBF5C8)
	// 82FBF598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBF59C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FBF5A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FBF5A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBF5A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FBF5AC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FBF5B0: 396B6820  addi r11, r11, 0x6820
	ctx.r[11].s64 = ctx.r[11].s64 + 26656;
	// 82FBF5B4: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FBF5B8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FBF5BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FBF5C0: 419A0008  beq cr6, 0x82fbf5c8
	if ctx.cr[6].eq {
	pc = 0x82FBF5C8; continue 'dispatch;
	}
	// 82FBF5C4: 4BF3E2DD  bl 0x82efd8a0
	ctx.lr = 0x82FBF5C8;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FBF5C8; continue 'dispatch;
            }
            0x82FBF5C8 => {
    //   block [0x82FBF5C8..0x82FBF5E4)
	// 82FBF5C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBF5CC: 4BF3E44D  bl 0x82efda18
	ctx.lr = 0x82FBF5D0;
	sub_82EFDA18(ctx, base);
	// 82FBF5D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FBF5D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FBF5D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FBF5DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FBF5E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBF5E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FBF5E8 size=152
    let mut pc: u32 = 0x82FBF5E8;
    'dispatch: loop {
        match pc {
            0x82FBF5E8 => {
    //   block [0x82FBF5E8..0x82FBF638)
	// 82FBF5E8: C1A30008  lfs f13, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBF5EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBF5F0: ED6D0372  fmuls f11, f13, f13
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FBF5F4: C1230000  lfs f9, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82FBF5F8: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBF5FC: ED490272  fmuls f10, f9, f9
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[9].f64) as f32) as f64);
	// 82FBF600: D143000C  stfs f10, 0xc(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82FBF604: C18B0C18  lfs f12, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBF608: ED60583A  fmadds f11, f0, f0, f11
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82FBF60C: ED6A5828  fsubs f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 82FBF610: FF0B6000  fcmpu cr6, f11, f12
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[12].f64);
	// 82FBF614: 409A0060  bne cr6, 0x82fbf674
	if !ctx.cr[6].eq {
	pc = 0x82FBF674; continue 'dispatch;
	}
	// 82FBF618: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBF61C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82FBF620: C16B0C14  lfs f11, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FBF624: 419A001C  beq cr6, 0x82fbf640
	if ctx.cr[6].eq {
	pc = 0x82FBF640; continue 'dispatch;
	}
	// 82FBF628: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82FBF62C: 4098000C  bge cr6, 0x82fbf638
	if !ctx.cr[6].lt {
	pc = 0x82FBF638; continue 'dispatch;
	}
	// 82FBF630: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82FBF634: 48000008  b 0x82fbf63c
	pc = 0x82FBF63C; continue 'dispatch;
            }
            0x82FBF638 => {
    //   block [0x82FBF638..0x82FBF63C)
	// 82FBF638: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	pc = 0x82FBF63C; continue 'dispatch;
            }
            0x82FBF63C => {
    //   block [0x82FBF63C..0x82FBF640)
	// 82FBF63C: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x82FBF640; continue 'dispatch;
            }
            0x82FBF640 => {
    //   block [0x82FBF640..0x82FBF658)
	// 82FBF640: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82FBF644: 419A001C  beq cr6, 0x82fbf660
	if ctx.cr[6].eq {
	pc = 0x82FBF660; continue 'dispatch;
	}
	// 82FBF648: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82FBF64C: 4098000C  bge cr6, 0x82fbf658
	if !ctx.cr[6].lt {
	pc = 0x82FBF658; continue 'dispatch;
	}
	// 82FBF650: EC0D582A  fadds f0, f13, f11
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 82FBF654: 48000008  b 0x82fbf65c
	pc = 0x82FBF65C; continue 'dispatch;
            }
            0x82FBF658 => {
    //   block [0x82FBF658..0x82FBF65C)
	// 82FBF658: EC0D5828  fsubs f0, f13, f11
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	pc = 0x82FBF65C; continue 'dispatch;
            }
            0x82FBF65C => {
    //   block [0x82FBF65C..0x82FBF660)
	// 82FBF65C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82FBF660; continue 'dispatch;
            }
            0x82FBF660 => {
    //   block [0x82FBF660..0x82FBF674)
	// 82FBF660: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBF664: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FBF668: C1A30004  lfs f13, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBF66C: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FBF670: ED6A0028  fsubs f11, f10, f0
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	pc = 0x82FBF674; continue 'dispatch;
            }
            0x82FBF674 => {
    //   block [0x82FBF674..0x82FBF680)
	// 82FBF674: EC095824  fdivs f0, f9, f11
	ctx.f[0].f64 = ((ctx.f[9].f64 / ctx.f[11].f64) as f32) as f64;
	// 82FBF678: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82FBF67C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBF680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FBF680 size=112
    let mut pc: u32 = 0x82FBF680;
    'dispatch: loop {
        match pc {
            0x82FBF680 => {
    //   block [0x82FBF680..0x82FBF6F0)
	// 82FBF680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBF684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FBF688: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBF68C: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 82FBF690: FC400890  fmr f2, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[1].f64;
	// 82FBF694: 3D408202  lis r10, -0x7dfe
	ctx.r[10].s64 = -2113798144;
	// 82FBF698: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82FBF69C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FBF6A0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FBF6A4: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FBF6A8: C00ACDCC  lfs f0, -0x3234(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12852 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBF6AC: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FBF6B0: 4B23EDF9  bl 0x821fe4a8
	ctx.lr = 0x82FBF6B4;
	sub_821FE4A8(ctx, base);
	// 82FBF6B4: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FBF6B8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBF6BC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FBF6C0: C00B0AE4  lfs f0, 0xae4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2788 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBF6C4: C1AA0BFC  lfs f13, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBF6C8: EC2C683A  fmadds f1, f12, f0, f13
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FBF6CC: 4B26CCC5  bl 0x8222c390
	ctx.lr = 0x82FBF6D0;
	sub_8222C390(ctx, base);
	// 82FBF6D0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FBF6D4: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82FBF6D8: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FBF6DC: 88610057  lbz r3, 0x57(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 82FBF6E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FBF6E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FBF6E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FBF6EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBF6F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FBF6F0 size=420
    let mut pc: u32 = 0x82FBF6F0;
    'dispatch: loop {
        match pc {
            0x82FBF6F0 => {
    //   block [0x82FBF6F0..0x82FBF714)
	// 82FBF6F0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FBF6F4: 419A0028  beq cr6, 0x82fbf71c
	if ctx.cr[6].eq {
	pc = 0x82FBF71C; continue 'dispatch;
	}
	// 82FBF6F8: 89640018  lbz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FBF6FC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FBF700: 4082001C  bne 0x82fbf71c
	if !ctx.cr[0].eq {
	pc = 0x82FBF71C; continue 'dispatch;
	}
	// 82FBF704: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FBF708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FBF70C: 409A0008  bne cr6, 0x82fbf714
	if !ctx.cr[6].eq {
	pc = 0x82FBF714; continue 'dispatch;
	}
	// 82FBF710: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	pc = 0x82FBF714; continue 'dispatch;
            }
            0x82FBF714 => {
    //   block [0x82FBF714..0x82FBF71C)
	// 82FBF714: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FBF718: 4082021C  bne 0x82fbf934
	if !ctx.cr[0].eq {
		sub_82FBF934(ctx, base);
		return;
	}
	pc = 0x82FBF71C; continue 'dispatch;
            }
            0x82FBF71C => {
    //   block [0x82FBF71C..0x82FBF74C)
	// 82FBF71C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBF720: A1430012  lhz r10, 0x12(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(18 as u32) ) } as u64;
	// 82FBF724: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82FBF728: C14B0C18  lfs f10, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82FBF72C: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	// 82FBF730: 4099015C  ble cr6, 0x82fbf88c
	if !ctx.cr[6].gt {
	pc = 0x82FBF88C; continue 'dispatch;
	}
	// 82FBF734: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82FBF738: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FBF73C: 392AFFFF  addi r9, r10, -1
	ctx.r[9].s64 = ctx.r[10].s64 + -1;
	// 82FBF740: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 82FBF744: 396B0006  addi r11, r11, 6
	ctx.r[11].s64 = ctx.r[11].s64 + 6;
	// 82FBF748: C1680C14  lfs f11, 0xc14(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x82FBF74C; continue 'dispatch;
            }
            0x82FBF74C => {
    //   block [0x82FBF74C..0x82FBF7C0)
	// 82FBF74C: 88EA0000  lbz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBF750: 890BFFFA  lbz r8, -6(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-6 as u32) ) } as u64;
	// 82FBF754: F8E1FFD8  std r7, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.r[7].u64 ) };
	// 82FBF758: C981FFD8  lfd f12, -0x28(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82FBF75C: F901FFD0  std r8, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.r[8].u64 ) };
	// 82FBF760: C9A1FFD0  lfd f13, -0x30(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82FBF764: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82FBF768: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82FBF76C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82FBF770: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82FBF774: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FBF778: FF0D5000  fcmpu cr6, f13, f10
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[10].f64);
	// 82FBF77C: 409900F8  ble cr6, 0x82fbf874
	if !ctx.cr[6].gt {
	pc = 0x82FBF874; continue 'dispatch;
	}
	// 82FBF780: 88EBFFFF  lbz r7, -1(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 82FBF784: EDAB6824  fdivs f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 / ctx.f[13].f64) as f32) as f64;
	// 82FBF788: 890B0007  lbz r8, 7(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(7 as u32) ) } as u64;
	// 82FBF78C: 7D083850  subf r8, r8, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 82FBF790: 7D07FE70  srawi r7, r8, 0x1f
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 31) as i64;
	// 82FBF794: 7D083A78  xor r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 ^ ctx.r[7].u64;
	// 82FBF798: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82FBF79C: 7D0807B4  extsw r8, r8
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82FBF7A0: F901FFE0  std r8, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[8].u64 ) };
	// 82FBF7A4: C981FFE0  lfd f12, -0x20(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82FBF7A8: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82FBF7AC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82FBF7B0: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FBF7B4: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82FBF7B8: 40990008  ble cr6, 0x82fbf7c0
	if !ctx.cr[6].gt {
	pc = 0x82FBF7C0; continue 'dispatch;
	}
	// 82FBF7BC: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82FBF7C0; continue 'dispatch;
            }
            0x82FBF7C0 => {
    //   block [0x82FBF7C0..0x82FBF7FC)
	// 82FBF7C0: 88EB0000  lbz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBF7C4: 890B0008  lbz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FBF7C8: 7D083850  subf r8, r8, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 82FBF7CC: 7D07FE70  srawi r7, r8, 0x1f
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 31) as i64;
	// 82FBF7D0: 7D083A78  xor r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 ^ ctx.r[7].u64;
	// 82FBF7D4: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82FBF7D8: 7D0807B4  extsw r8, r8
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82FBF7DC: F901FFE8  std r8, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[8].u64 ) };
	// 82FBF7E0: C981FFE8  lfd f12, -0x18(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FBF7E4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82FBF7E8: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82FBF7EC: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FBF7F0: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82FBF7F4: 40990008  ble cr6, 0x82fbf7fc
	if !ctx.cr[6].gt {
	pc = 0x82FBF7FC; continue 'dispatch;
	}
	// 82FBF7F8: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82FBF7FC; continue 'dispatch;
            }
            0x82FBF7FC => {
    //   block [0x82FBF7FC..0x82FBF838)
	// 82FBF7FC: 88EB0001  lbz r7, 1(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82FBF800: 890B0009  lbz r8, 9(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(9 as u32) ) } as u64;
	// 82FBF804: 7D083850  subf r8, r8, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 82FBF808: 7D07FE70  srawi r7, r8, 0x1f
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 31) as i64;
	// 82FBF80C: 7D083A78  xor r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 ^ ctx.r[7].u64;
	// 82FBF810: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82FBF814: 7D0807B4  extsw r8, r8
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82FBF818: F901FFF0  std r8, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[8].u64 ) };
	// 82FBF81C: C981FFF0  lfd f12, -0x10(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FBF820: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82FBF824: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82FBF828: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FBF82C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82FBF830: 40990008  ble cr6, 0x82fbf838
	if !ctx.cr[6].gt {
	pc = 0x82FBF838; continue 'dispatch;
	}
	// 82FBF834: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82FBF838; continue 'dispatch;
            }
            0x82FBF838 => {
    //   block [0x82FBF838..0x82FBF874)
	// 82FBF838: 88EBFFFE  lbz r7, -2(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 82FBF83C: 890B0006  lbz r8, 6(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82FBF840: 7D083850  subf r8, r8, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[8].s64;
	// 82FBF844: 7D07FE70  srawi r7, r8, 0x1f
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 31) as i64;
	// 82FBF848: 7D083A78  xor r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 ^ ctx.r[7].u64;
	// 82FBF84C: 7D074050  subf r8, r7, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[7].s64;
	// 82FBF850: 7D0807B4  extsw r8, r8
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82FBF854: F901FFF8  std r8, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[8].u64 ) };
	// 82FBF858: C981FFF8  lfd f12, -8(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82FBF85C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82FBF860: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82FBF864: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FBF868: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FBF86C: 40990008  ble cr6, 0x82fbf874
	if !ctx.cr[6].gt {
	pc = 0x82FBF874; continue 'dispatch;
	}
	// 82FBF870: FC006890  fmr f0, f13
	ctx.f[0].f64 = ctx.f[13].f64;
	pc = 0x82FBF874; continue 'dispatch;
            }
            0x82FBF874 => {
    //   block [0x82FBF874..0x82FBF88C)
	// 82FBF874: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FBF878: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82FBF87C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82FBF880: 4082FECC  bne 0x82fbf74c
	if !ctx.cr[0].eq {
	pc = 0x82FBF74C; continue 'dispatch;
	}
	// 82FBF884: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82FBF888: 409A000C  bne cr6, 0x82fbf894
	if !ctx.cr[6].eq {
		sub_82FBF894(ctx, base);
		return;
	}
	pc = 0x82FBF88C; continue 'dispatch;
            }
            0x82FBF88C => {
    //   block [0x82FBF88C..0x82FBF894)
	// 82FBF88C: 38600040  li r3, 0x40
	ctx.r[3].s64 = 64;
	// 82FBF890: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBF894(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FBF894 size=160
    let mut pc: u32 = 0x82FBF894;
    'dispatch: loop {
        match pc {
            0x82FBF894 => {
    //   block [0x82FBF894..0x82FBF8AC)
	// 82FBF894: 89630010  lbz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FBF898: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FBF89C: 41820010  beq 0x82fbf8ac
	if ctx.cr[0].eq {
	pc = 0x82FBF8AC; continue 'dispatch;
	}
	// 82FBF8A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBF8A4: C1AB0A98  lfs f13, 0xa98(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2712 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBF8A8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	pc = 0x82FBF8AC; continue 'dispatch;
            }
            0x82FBF8AC => {
    //   block [0x82FBF8AC..0x82FBF8E0)
	// 82FBF8AC: 89630011  lbz r11, 0x11(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(17 as u32) ) } as u64;
	// 82FBF8B0: 2B0B0013  cmplwi cr6, r11, 0x13
	ctx.cr[6].compare_u32(ctx.r[11].u32, 19 as u32, &mut ctx.xer);
	// 82FBF8B4: 409A002C  bne cr6, 0x82fbf8e0
	if !ctx.cr[6].eq {
	pc = 0x82FBF8E0; continue 'dispatch;
	}
	// 82FBF8B8: C1A30018  lfs f13, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBF8BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBF8C0: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82FBF8C4: C18B0BFC  lfs f12, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBF8C8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82FBF8CC: 40990014  ble cr6, 0x82fbf8e0
	if !ctx.cr[6].gt {
	pc = 0x82FBF8E0; continue 'dispatch;
	}
	// 82FBF8D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBF8D4: C18B0B2C  lfs f12, 0xb2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2860 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBF8D8: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FBF8DC: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	pc = 0x82FBF8E0; continue 'dispatch;
            }
            0x82FBF8E0 => {
    //   block [0x82FBF8E0..0x82FBF8EC)
	// 82FBF8E0: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82FBF8E4: 40980008  bge cr6, 0x82fbf8ec
	if !ctx.cr[6].lt {
	pc = 0x82FBF8EC; continue 'dispatch;
	}
	// 82FBF8E8: FC005090  fmr f0, f10
	ctx.f[0].f64 = ctx.f[10].f64;
	pc = 0x82FBF8EC; continue 'dispatch;
            }
            0x82FBF8EC => {
    //   block [0x82FBF8EC..0x82FBF920)
	// 82FBF8EC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FBF8F0: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82FBF8F4: C1AB6824  lfs f13, 0x6824(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26660 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBF8F8: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82FBF8FC: C00ABE10  lfs f0, -0x41f0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBF900: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FBF904: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82FBF908: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82FBF90C: D801FFF8  stfd f0, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.f[0].u64 ) };
	// 82FBF910: 8161FFFC  lwz r11, -4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82FBF914: 2B0B0012  cmplwi cr6, r11, 0x12
	ctx.cr[6].compare_u32(ctx.r[11].u32, 18 as u32, &mut ctx.xer);
	// 82FBF918: 41980008  blt cr6, 0x82fbf920
	if ctx.cr[6].lt {
	pc = 0x82FBF920; continue 'dispatch;
	}
	// 82FBF91C: 39600011  li r11, 0x11
	ctx.r[11].s64 = 17;
	pc = 0x82FBF920; continue 'dispatch;
            }
            0x82FBF920 => {
    //   block [0x82FBF920..0x82FBF934)
	// 82FBF920: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82FBF924: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FBF928: 394A67D8  addi r10, r10, 0x67d8
	ctx.r[10].s64 = ctx.r[10].s64 + 26584;
	// 82FBF92C: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FBF930: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBF934(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FBF934 size=8
    let mut pc: u32 = 0x82FBF934;
    'dispatch: loop {
        match pc {
            0x82FBF934 => {
    //   block [0x82FBF934..0x82FBF93C)
	// 82FBF934: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82FBF938: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBF940(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FBF940 size=112
    let mut pc: u32 = 0x82FBF940;
    'dispatch: loop {
        match pc {
            0x82FBF940 => {
    //   block [0x82FBF940..0x82FBF980)
	// 82FBF940: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBF944: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FBF948: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FBF94C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBF950: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FBF954: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBF958: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBF95C: 41820024  beq 0x82fbf980
	if ctx.cr[0].eq {
	pc = 0x82FBF980; continue 'dispatch;
	}
	// 82FBF960: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBF964: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FBF968: 419A0018  beq cr6, 0x82fbf980
	if ctx.cr[6].eq {
	pc = 0x82FBF980; continue 'dispatch;
	}
	// 82FBF96C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FBF970: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FBF974: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBF978: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FBF97C: 4E800421  bctrl
	ctx.lr = 0x82FBF980;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FBF980 => {
    //   block [0x82FBF980..0x82FBF99C)
	// 82FBF980: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FBF984: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBF988: 409A0014  bne cr6, 0x82fbf99c
	if !ctx.cr[6].eq {
	pc = 0x82FBF99C; continue 'dispatch;
	}
	// 82FBF98C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FBF990: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FBF994: 419A0008  beq cr6, 0x82fbf99c
	if ctx.cr[6].eq {
	pc = 0x82FBF99C; continue 'dispatch;
	}
	// 82FBF998: 4BF38901  bl 0x82ef8298
	ctx.lr = 0x82FBF99C;
	sub_82EF8298(ctx, base);
	pc = 0x82FBF99C; continue 'dispatch;
            }
            0x82FBF99C => {
    //   block [0x82FBF99C..0x82FBF9B0)
	// 82FBF99C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FBF9A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FBF9A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FBF9A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FBF9AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBF9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FBF9B0 size=100
    let mut pc: u32 = 0x82FBF9B0;
    'dispatch: loop {
        match pc {
            0x82FBF9B0 => {
    //   block [0x82FBF9B0..0x82FBF9F8)
	// 82FBF9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBF9B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FBF9B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FBF9BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FBF9C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBF9C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FBF9C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FBF9CC: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBF9D0: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBF9D4: 41820024  beq 0x82fbf9f8
	if ctx.cr[0].eq {
	pc = 0x82FBF9F8; continue 'dispatch;
	}
	// 82FBF9D8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBF9DC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FBF9E0: 419A0018  beq cr6, 0x82fbf9f8
	if ctx.cr[6].eq {
	pc = 0x82FBF9F8; continue 'dispatch;
	}
	// 82FBF9E4: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FBF9E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FBF9EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBF9F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FBF9F4: 4E800421  bctrl
	ctx.lr = 0x82FBF9F8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FBF9F8 => {
    //   block [0x82FBF9F8..0x82FBFA14)
	// 82FBF9F8: 9BDF0000  stb r30, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 82FBF9FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FBFA00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FBFA04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FBFA08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FBFA0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FBFA10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBFA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FBFA18 size=44
    let mut pc: u32 = 0x82FBFA18;
    'dispatch: loop {
        match pc {
            0x82FBFA18 => {
    //   block [0x82FBFA18..0x82FBFA44)
	// 82FBFA18: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FBFA1C: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82FBFA20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FBFA24: 39296828  addi r9, r9, 0x6828
	ctx.r[9].s64 = ctx.r[9].s64 + 26664;
	// 82FBFA28: B1630004  sth r11, 4(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 82FBFA2C: C00A0C14  lfs f0, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBFA30: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82FBFA34: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82FBFA38: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82FBFA3C: B1630010  sth r11, 0x10(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 82FBFA40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBFA48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FBFA48 size=76
    let mut pc: u32 = 0x82FBFA48;
    'dispatch: loop {
        match pc {
            0x82FBFA48 => {
    //   block [0x82FBFA48..0x82FBFA78)
	// 82FBFA48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBFA4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FBFA50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FBFA54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FBFA58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBFA5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FBFA60: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FBFA64: 4BFFFB35  bl 0x82fbf598
	ctx.lr = 0x82FBFA68;
	sub_82FBF598(ctx, base);
	// 82FBFA68: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBFA6C: 4182000C  beq 0x82fbfa78
	if ctx.cr[0].eq {
	pc = 0x82FBFA78; continue 'dispatch;
	}
	// 82FBFA70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBFA74: 4BF3DE2D  bl 0x82efd8a0
	ctx.lr = 0x82FBFA78;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FBFA78; continue 'dispatch;
            }
            0x82FBFA78 => {
    //   block [0x82FBFA78..0x82FBFA94)
	// 82FBFA78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBFA7C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FBFA80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FBFA84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FBFA88: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FBFA8C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FBFA90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBFA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FBFA98 size=188
    let mut pc: u32 = 0x82FBFA98;
    'dispatch: loop {
        match pc {
            0x82FBFA98 => {
    //   block [0x82FBFA98..0x82FBFAE0)
	// 82FBFA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBFA9C: 4BCE996D  bl 0x82ca9408
	ctx.lr = 0x82FBFAA0;
	sub_82CA93D0(ctx, base);
	// 82FBFAA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBFAA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FBFAA8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82FBFAAC: 579F043E  clrlwi r31, r28, 0x10
	ctx.r[31].u64 = ctx.r[28].u32 as u64 & 0x0000FFFFu64;
	// 82FBFAB0: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82FBFAB4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FBFAB8: 419A0090  beq cr6, 0x82fbfb48
	if ctx.cr[6].eq {
	pc = 0x82FBFB48; continue 'dispatch;
	}
	// 82FBFABC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82FBFAC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82FBFAC4: 419A001C  beq cr6, 0x82fbfae0
	if ctx.cr[6].eq {
	pc = 0x82FBFAE0; continue 'dispatch;
	}
	// 82FBFAC8: 57E31838  slwi r3, r31, 3
	ctx.r[3].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82FBFACC: 4BF3DD95  bl 0x82efd860
	ctx.lr = 0x82FBFAD0;
	sub_82EFD860(ctx, base);
	// 82FBFAD0: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82FBFAD4: 4082000C  bne 0x82fbfae0
	if !ctx.cr[0].eq {
	pc = 0x82FBFAE0; continue 'dispatch;
	}
	// 82FBFAD8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82FBFADC: 48000070  b 0x82fbfb4c
	pc = 0x82FBFB4C; continue 'dispatch;
            }
            0x82FBFAE0 => {
    //   block [0x82FBFAE0..0x82FBFB00)
	// 82FBFAE0: 817E0014  lwz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FBFAE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FBFAE8: 419A0058  beq cr6, 0x82fbfb40
	if ctx.cr[6].eq {
	pc = 0x82FBFB40; continue 'dispatch;
	}
	// 82FBFAEC: A17E0012  lhz r11, 0x12(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82FBFAF0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82FBFAF4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FBFAF8: 40980008  bge cr6, 0x82fbfb00
	if !ctx.cr[6].lt {
	pc = 0x82FBFB00; continue 'dispatch;
	}
	// 82FBFAFC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82FBFB00; continue 'dispatch;
            }
            0x82FBFB00 => {
    //   block [0x82FBFB00..0x82FBFB10)
	// 82FBFB00: 556A043F  clrlwi. r10, r11, 0x10
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FBFB04: 41820034  beq 0x82fbfb38
	if ctx.cr[0].eq {
	pc = 0x82FBFB38; continue 'dispatch;
	}
	// 82FBFB08: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82FBFB0C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82FBFB10; continue 'dispatch;
            }
            0x82FBFB10 => {
    //   block [0x82FBFB10..0x82FBFB38)
	// 82FBFB10: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FBFB14: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FBFB18: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82FBFB1C: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82FBFB20: 88E80000  lbz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBFB24: 98EB0000  stb r7, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u8 ) };
	// 82FBFB28: 81080004  lwz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBFB2C: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82FBFB30: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82FBFB34: 4082FFDC  bne 0x82fbfb10
	if !ctx.cr[0].eq {
	pc = 0x82FBFB10; continue 'dispatch;
	}
	pc = 0x82FBFB38; continue 'dispatch;
            }
            0x82FBFB38 => {
    //   block [0x82FBFB38..0x82FBFB40)
	// 82FBFB38: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FBFB3C: 4BF3DD65  bl 0x82efd8a0
	ctx.lr = 0x82FBFB40;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FBFB40; continue 'dispatch;
            }
            0x82FBFB40 => {
    //   block [0x82FBFB40..0x82FBFB48)
	// 82FBFB40: 93BE0014  stw r29, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 82FBFB44: B39E0012  sth r28, 0x12(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(18 as u32), ctx.r[28].u16 ) };
	pc = 0x82FBFB48; continue 'dispatch;
            }
            0x82FBFB48 => {
    //   block [0x82FBFB48..0x82FBFB4C)
	// 82FBFB48: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82FBFB4C; continue 'dispatch;
            }
            0x82FBFB4C => {
    //   block [0x82FBFB4C..0x82FBFB54)
	// 82FBFB4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FBFB50: 4BCE9908  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBFB58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FBFB58 size=168
    let mut pc: u32 = 0x82FBFB58;
    'dispatch: loop {
        match pc {
            0x82FBFB58 => {
    //   block [0x82FBFB58..0x82FBFBB4)
	// 82FBFB58: A0C30012  lhz r6, 0x12(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(18 as u32) ) } as u64;
	// 82FBFB5C: A1640012  lhz r11, 0x12(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82FBFB60: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FBFB64: 409A009C  bne cr6, 0x82fbfc00
	if !ctx.cr[6].eq {
		sub_82FBFC00(ctx, base);
		return;
	}
	// 82FBFB68: 89640011  lbz r11, 0x11(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(17 as u32) ) } as u64;
	// 82FBFB6C: 89430011  lbz r10, 0x11(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(17 as u32) ) } as u64;
	// 82FBFB70: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FBFB74: 409A008C  bne cr6, 0x82fbfc00
	if !ctx.cr[6].eq {
		sub_82FBFC00(ctx, base);
		return;
	}
	// 82FBFB78: C0030018  lfs f0, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBFB7C: C1A40018  lfs f13, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBFB80: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82FBFB84: 409A007C  bne cr6, 0x82fbfc00
	if !ctx.cr[6].eq {
		sub_82FBFC00(ctx, base);
		return;
	}
	// 82FBFB88: 89640010  lbz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FBFB8C: 89430010  lbz r10, 0x10(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FBFB90: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FBFB94: 409A006C  bne cr6, 0x82fbfc00
	if !ctx.cr[6].eq {
		sub_82FBFC00(ctx, base);
		return;
	}
	// 82FBFB98: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82FBFB9C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82FBFBA0: 419A0058  beq cr6, 0x82fbfbf8
	if ctx.cr[6].eq {
	pc = 0x82FBFBF8; continue 'dispatch;
	}
	// 82FBFBA4: 81440014  lwz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FBFBA8: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FBFBAC: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 82FBFBB0: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	pc = 0x82FBFBB4; continue 'dispatch;
            }
            0x82FBFBB4 => {
    //   block [0x82FBFBB4..0x82FBFBD8)
	// 82FBFBB4: 7D4758AE  lbzx r10, r7, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FBFBB8: 88AB0000  lbz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBFBBC: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FBFBC0: 409A0018  bne cr6, 0x82fbfbd8
	if !ctx.cr[6].eq {
	pc = 0x82FBFBD8; continue 'dispatch;
	}
	// 82FBFBC4: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBFBC8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBFBCC: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FBFBD0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82FBFBD4: 419A0008  beq cr6, 0x82fbfbdc
	if ctx.cr[6].eq {
	pc = 0x82FBFBDC; continue 'dispatch;
	}
	pc = 0x82FBFBD8; continue 'dispatch;
            }
            0x82FBFBD8 => {
    //   block [0x82FBFBD8..0x82FBFBDC)
	// 82FBFBD8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82FBFBDC; continue 'dispatch;
            }
            0x82FBFBDC => {
    //   block [0x82FBFBDC..0x82FBFBF8)
	// 82FBFBDC: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FBFBE0: 41820020  beq 0x82fbfc00
	if ctx.cr[0].eq {
		sub_82FBFC00(ctx, base);
		return;
	}
	// 82FBFBE4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82FBFBE8: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 82FBFBEC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82FBFBF0: 7F083040  cmplw cr6, r8, r6
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82FBFBF4: 4198FFC0  blt cr6, 0x82fbfbb4
	if ctx.cr[6].lt {
	pc = 0x82FBFBB4; continue 'dispatch;
	}
	pc = 0x82FBFBF8; continue 'dispatch;
            }
            0x82FBFBF8 => {
    //   block [0x82FBFBF8..0x82FBFC00)
	// 82FBFBF8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82FBFBFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBFC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FBFC00 size=8
    let mut pc: u32 = 0x82FBFC00;
    'dispatch: loop {
        match pc {
            0x82FBFC00 => {
    //   block [0x82FBFC00..0x82FBFC08)
	// 82FBFC00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82FBFC04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBFC08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FBFC08 size=8
    let mut pc: u32 = 0x82FBFC08;
    'dispatch: loop {
        match pc {
            0x82FBFC08 => {
    //   block [0x82FBFC08..0x82FBFC10)
	// 82FBFC08: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 82FBFC0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBFC10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FBFC10 size=60
    let mut pc: u32 = 0x82FBFC10;
    'dispatch: loop {
        match pc {
            0x82FBFC10 => {
    //   block [0x82FBFC10..0x82FBFC24)
	// 82FBFC10: A1440012  lhz r10, 0x12(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 82FBFC14: 88640011  lbz r3, 0x11(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(17 as u32) ) } as u64;
	// 82FBFC18: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FBFC1C: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82FBFC20: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	pc = 0x82FBFC24; continue 'dispatch;
            }
            0x82FBFC24 => {
    //   block [0x82FBFC24..0x82FBFC4C)
	// 82FBFC24: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBFC28: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FBFC2C: 890B0000  lbz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBFC30: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82FBFC34: 5527843E  srwi r7, r9, 0x10
	ctx.r[7].u32 = ctx.r[9].u32.wrapping_shr(16);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82FBFC38: 7CE84278  xor r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 ^ ctx.r[8].u64;
	// 82FBFC3C: 7D094A78  xor r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 ^ ctx.r[9].u64;
	// 82FBFC40: 7D231A78  xor r3, r9, r3
	ctx.r[3].u64 = ctx.r[9].u64 ^ ctx.r[3].u64;
	// 82FBFC44: 4082FFE0  bne 0x82fbfc24
	if !ctx.cr[0].eq {
	pc = 0x82FBFC24; continue 'dispatch;
	}
	// 82FBFC48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBFC50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FBFC50 size=20
    let mut pc: u32 = 0x82FBFC50;
    'dispatch: loop {
        match pc {
            0x82FBFC50 => {
    //   block [0x82FBFC50..0x82FBFC64)
	// 82FBFC50: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBFC54: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FBFC58: 419A000C  beq cr6, 0x82fbfc64
	if ctx.cr[6].eq {
		sub_82FBFC64(ctx, base);
		return;
	}
	// 82FBFC5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82FBFC60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBFC64(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FBFC64 size=12
    let mut pc: u32 = 0x82FBFC64;
    'dispatch: loop {
        match pc {
            0x82FBFC64 => {
    //   block [0x82FBFC64..0x82FBFC70)
	// 82FBFC64: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82FBFC68: 80850004  lwz r4, 4(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBFC6C: 4BFFFEEC  b 0x82fbfb58
	sub_82FBFB58(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBFC70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FBFC70 size=88
    let mut pc: u32 = 0x82FBFC70;
    'dispatch: loop {
        match pc {
            0x82FBFC70 => {
    //   block [0x82FBFC70..0x82FBFCC8)
	// 82FBFC70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBFC74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FBFC78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FBFC7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FBFC80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBFC84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FBFC88: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82FBFC8C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82FBFC90: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82FBFC94: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82FBFC98: 4BFACCE1  bl 0x82f6c978
	ctx.lr = 0x82FBFC9C;
	sub_82F6C978(ctx, base);
	// 82FBFC9C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82FBFCA0: 9BDF0000  stb r30, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 82FBFCA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBFCA8: 997F0001  stb r11, 1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82FBFCAC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82FBFCB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FBFCB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FBFCB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FBFCBC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FBFCC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FBFCC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBFCC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FBFCC8 size=188
    let mut pc: u32 = 0x82FBFCC8;
    'dispatch: loop {
        match pc {
            0x82FBFCC8 => {
    //   block [0x82FBFCC8..0x82FBFD0C)
	// 82FBFCC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBFCCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FBFCD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FBFCD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FBFCD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBFCDC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FBFCE0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FBFCE4: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBFCE8: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBFCEC: 41820020  beq 0x82fbfd0c
	if ctx.cr[0].eq {
	pc = 0x82FBFD0C; continue 'dispatch;
	}
	// 82FBFCF0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBFCF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FBFCF8: 419A0014  beq cr6, 0x82fbfd0c
	if ctx.cr[6].eq {
	pc = 0x82FBFD0C; continue 'dispatch;
	}
	// 82FBFCFC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FBFD00: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBFD04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FBFD08: 4E800421  bctrl
	ctx.lr = 0x82FBFD0C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FBFD0C => {
    //   block [0x82FBFD0C..0x82FBFD38)
	// 82FBFD0C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBFD10: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBFD14: 41820024  beq 0x82fbfd38
	if ctx.cr[0].eq {
	pc = 0x82FBFD38; continue 'dispatch;
	}
	// 82FBFD18: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBFD1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FBFD20: 419A0018  beq cr6, 0x82fbfd38
	if ctx.cr[6].eq {
	pc = 0x82FBFD38; continue 'dispatch;
	}
	// 82FBFD24: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FBFD28: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FBFD2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBFD30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FBFD34: 4E800421  bctrl
	ctx.lr = 0x82FBFD38;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FBFD38 => {
    //   block [0x82FBFD38..0x82FBFD84)
	// 82FBFD38: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBFD3C: 389E0008  addi r4, r30, 8
	ctx.r[4].s64 = ctx.r[30].s64 + 8;
	// 82FBFD40: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82FBFD44: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82FBFD48: 897E0001  lbz r11, 1(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1 as u32) ) } as u64;
	// 82FBFD4C: 997F0001  stb r11, 1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82FBFD50: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBFD54: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FBFD58: 4BF3F8A1  bl 0x82eff5f8
	ctx.lr = 0x82FBFD5C;
	sub_82EFF5F8(ctx, base);
	// 82FBFD5C: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 82FBFD60: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82FBFD64: 4BFACA95  bl 0x82f6c7f8
	ctx.lr = 0x82FBFD68;
	sub_82F6C7F8(ctx, base);
	// 82FBFD68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBFD6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FBFD70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FBFD74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FBFD78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FBFD7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FBFD80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBFD88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FBFD88 size=92
    let mut pc: u32 = 0x82FBFD88;
    'dispatch: loop {
        match pc {
            0x82FBFD88 => {
    //   block [0x82FBFD88..0x82FBFDE4)
	// 82FBFD88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBFD8C: 4BCE967D  bl 0x82ca9408
	ctx.lr = 0x82FBFD90;
	sub_82CA93D0(ctx, base);
	// 82FBFD90: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBFD94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FBFD98: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FBFD9C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82FBFDA0: 4BFFFC11  bl 0x82fbf9b0
	ctx.lr = 0x82FBFDA4;
	sub_82FBF9B0(ctx, base);
	// 82FBFDA4: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82FBFDA8: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82FBFDAC: 997F0001  stb r11, 1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82FBFDB0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82FBFDB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FBFDB8: 4BFACA41  bl 0x82f6c7f8
	ctx.lr = 0x82FBFDBC;
	sub_82F6C7F8(ctx, base);
	// 82FBFDBC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBFDC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FBFDC4: C04B0AC8  lfs f2, 0xac8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FBFDC8: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82FBFDCC: 4BFACAD5  bl 0x82f6c8a0
	ctx.lr = 0x82FBFDD0;
	sub_82F6C8A0(ctx, base);
	// 82FBFDD0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FBFDD4: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82FBFDD8: 4BF8D251  bl 0x82f4d028
	ctx.lr = 0x82FBFDDC;
	sub_82F4D028(ctx, base);
	// 82FBFDDC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FBFDE0: 4BCE9678  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBFDE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FBFDE8 size=140
    let mut pc: u32 = 0x82FBFDE8;
    'dispatch: loop {
        match pc {
            0x82FBFDE8 => {
    //   block [0x82FBFDE8..0x82FBFE18)
	// 82FBFDE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBFDEC: 4BCE9621  bl 0x82ca940c
	ctx.lr = 0x82FBFDF0;
	sub_82CA93D0(ctx, base);
	// 82FBFDF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBFDF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FBFDF8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82FBFDFC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82FBFE00: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBFE04: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FBFE08: 41820010  beq 0x82fbfe18
	if ctx.cr[0].eq {
	pc = 0x82FBFE18; continue 'dispatch;
	}
	// 82FBFE0C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FBFE10: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FBFE14: 419A002C  beq cr6, 0x82fbfe40
	if ctx.cr[6].eq {
	pc = 0x82FBFE40; continue 'dispatch;
	}
	pc = 0x82FBFE18; continue 'dispatch;
            }
            0x82FBFE18 => {
    //   block [0x82FBFE18..0x82FBFE40)
	// 82FBFE18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBFE1C: 4BFFFB95  bl 0x82fbf9b0
	ctx.lr = 0x82FBFE20;
	sub_82FBF9B0(ctx, base);
	// 82FBFE20: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82FBFE24: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82FBFE28: 419A0018  beq cr6, 0x82fbfe40
	if ctx.cr[6].eq {
	pc = 0x82FBFE40; continue 'dispatch;
	}
	// 82FBFE2C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FBFE30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FBFE34: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBFE38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FBFE3C: 4E800421  bctrl
	ctx.lr = 0x82FBFE40;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FBFE40 => {
    //   block [0x82FBFE40..0x82FBFE74)
	// 82FBFE40: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FBFE44: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82FBFE48: 4BFAC9B1  bl 0x82f6c7f8
	ctx.lr = 0x82FBFE4C;
	sub_82F6C7F8(ctx, base);
	// 82FBFE4C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBFE50: C1BF0018  lfs f13, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FBFE54: C19F0028  lfs f12, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FBFE58: C00B0AC8  lfs f0, 0xac8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBFE5C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FBFE60: D1BF0018  stfs f13, 0x18(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82FBFE64: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FBFE68: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82FBFE6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FBFE70: 4BCE95EC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBFE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FBFE78 size=76
    let mut pc: u32 = 0x82FBFE78;
    'dispatch: loop {
        match pc {
            0x82FBFE78 => {
    //   block [0x82FBFE78..0x82FBFEB0)
	// 82FBFE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBFE7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FBFE80: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FBFE84: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBFE88: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FBFE8C: 83E3000C  lwz r31, 0xc(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FBFE90: 396B6828  addi r11, r11, 0x6828
	ctx.r[11].s64 = ctx.r[11].s64 + 26664;
	// 82FBFE94: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82FBFE98: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FBFE9C: 419A0014  beq cr6, 0x82fbfeb0
	if ctx.cr[6].eq {
	pc = 0x82FBFEB0; continue 'dispatch;
	}
	// 82FBFEA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBFEA4: 4BFFFA9D  bl 0x82fbf940
	ctx.lr = 0x82FBFEA8;
	sub_82FBF940(ctx, base);
	// 82FBFEA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBFEAC: 4BF3D9F5  bl 0x82efd8a0
	ctx.lr = 0x82FBFEB0;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FBFEB0; continue 'dispatch;
            }
            0x82FBFEB0 => {
    //   block [0x82FBFEB0..0x82FBFEC4)
	// 82FBFEB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FBFEB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FBFEB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FBFEBC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FBFEC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBFEC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FBFEC8 size=88
    let mut pc: u32 = 0x82FBFEC8;
    'dispatch: loop {
        match pc {
            0x82FBFEC8 => {
    //   block [0x82FBFEC8..0x82FBFF00)
	// 82FBFEC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBFECC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FBFED0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FBFED4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBFED8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FBFEDC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FBFEE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FBFEE4: 409A0024  bne cr6, 0x82fbff08
	if !ctx.cr[6].eq {
	pc = 0x82FBFF08; continue 'dispatch;
	}
	// 82FBFEE8: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82FBFEEC: 4BF3D975  bl 0x82efd860
	ctx.lr = 0x82FBFEF0;
	sub_82EFD860(ctx, base);
	// 82FBFEF0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FBFEF4: 4182000C  beq 0x82fbff00
	if ctx.cr[0].eq {
	pc = 0x82FBFF00; continue 'dispatch;
	}
	// 82FBFEF8: 4BFFFD79  bl 0x82fbfc70
	ctx.lr = 0x82FBFEFC;
	sub_82FBFC70(ctx, base);
	// 82FBFEFC: 48000008  b 0x82fbff04
	pc = 0x82FBFF04; continue 'dispatch;
            }
            0x82FBFF00 => {
    //   block [0x82FBFF00..0x82FBFF04)
	// 82FBFF00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82FBFF04; continue 'dispatch;
            }
            0x82FBFF04 => {
    //   block [0x82FBFF04..0x82FBFF08)
	// 82FBFF04: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	pc = 0x82FBFF08; continue 'dispatch;
            }
            0x82FBFF08 => {
    //   block [0x82FBFF08..0x82FBFF20)
	// 82FBFF08: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FBFF0C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FBFF10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FBFF14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FBFF18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FBFF1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBFF20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FBFF20 size=64
    let mut pc: u32 = 0x82FBFF20;
    'dispatch: loop {
        match pc {
            0x82FBFF20 => {
    //   block [0x82FBFF20..0x82FBFF60)
	// 82FBFF20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBFF24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FBFF28: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBFF2C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82FBFF30: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FBFF34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FBFF38: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82FBFF3C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FBFF40: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82FBFF44: 816A0048  lwz r11, 0x48(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(72 as u32) ) } as u64;
	// 82FBFF48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FBFF4C: 4E800421  bctrl
	ctx.lr = 0x82FBFF50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FBFF50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FBFF54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FBFF58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FBFF5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBFF60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FBFF60 size=112
    let mut pc: u32 = 0x82FBFF60;
    'dispatch: loop {
        match pc {
            0x82FBFF60 => {
    //   block [0x82FBFF60..0x82FBFFD0)
	// 82FBFF60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBFF64: 4BCE94A5  bl 0x82ca9408
	ctx.lr = 0x82FBFF68;
	sub_82CA93D0(ctx, base);
	// 82FBFF68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBFF6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FBFF70: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FBFF74: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FBFF78: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82FBFF7C: 4BF3D9CD  bl 0x82efd948
	ctx.lr = 0x82FBFF80;
	sub_82EFD948(ctx, base);
	// 82FBFF80: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FBFF84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBFF88: 396B6820  addi r11, r11, 0x6820
	ctx.r[11].s64 = ctx.r[11].s64 + 26656;
	// 82FBFF8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82FBFF90: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FBFF94: 4BF3DAC5  bl 0x82efda58
	ctx.lr = 0x82FBFF98;
	sub_82EFDA58(ctx, base);
	// 82FBFF98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FBFF9C: 9BDF0011  stb r30, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[30].u8 ) };
	// 82FBFFA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBFFA4: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82FBFFA8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FBFFAC: B17F0012  sth r11, 0x12(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(18 as u32), ctx.r[11].u16 ) };
	// 82FBFFB0: 4BFFFAE9  bl 0x82fbfa98
	ctx.lr = 0x82FBFFB4;
	sub_82FBFA98(ctx, base);
	// 82FBFFB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FBFFB8: 9B9F0010  stb r28, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[28].u8 ) };
	// 82FBFFBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FBFFC0: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FBFFC4: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82FBFFC8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FBFFCC: 4BCE948C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FBFFD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FBFFD0 size=120
    let mut pc: u32 = 0x82FBFFD0;
    'dispatch: loop {
        match pc {
            0x82FBFFD0 => {
    //   block [0x82FBFFD0..0x82FC001C)
	// 82FBFFD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FBFFD4: 4BCE9439  bl 0x82ca940c
	ctx.lr = 0x82FBFFD8;
	sub_82CA93D0(ctx, base);
	// 82FBFFD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FBFFDC: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82FBFFE0: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82FBFFE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FBFFE8: 3BEB96B8  addi r31, r11, -0x6948
	ctx.r[31].s64 = ctx.r[11].s64 + -26952;
	// 82FBFFEC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82FBFFF0: 816A96BC  lwz r11, -0x6944(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-26948 as u32) ) } as u64;
	// 82FBFFF4: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FBFFF8: 40820024  bne 0x82fc001c
	if !ctx.cr[0].eq {
	pc = 0x82FC001C; continue 'dispatch;
	}
	// 82FBFFFC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82FC0000: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82FC0004: 39296830  addi r9, r9, 0x6830
	ctx.r[9].s64 = ctx.r[9].s64 + 26672;
	// 82FC0008: 916A96BC  stw r11, -0x6944(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-26948 as u32), ctx.r[11].u32 ) };
	// 82FC000C: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 82FC0010: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82FC0014: 386B9298  addi r3, r11, -0x6d68
	ctx.r[3].s64 = ctx.r[11].s64 + -28008;
	// 82FC0018: 4BCE9F09  bl 0x82ca9f20
	ctx.lr = 0x82FC001C;
	sub_82CA9F20(ctx, base);
	pc = 0x82FC001C; continue 'dispatch;
            }
            0x82FC001C => {
    //   block [0x82FC001C..0x82FC0048)
	// 82FC001C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC0020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC0024: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC0028: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC002C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC0030: 4E800421  bctrl
	ctx.lr = 0x82FC0034;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC0034: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82FC0038: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC003C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82FC0040: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC0044: 4BCE9418  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC0048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC0048 size=120
    let mut pc: u32 = 0x82FC0048;
    'dispatch: loop {
        match pc {
            0x82FC0048 => {
    //   block [0x82FC0048..0x82FC0094)
	// 82FC0048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC004C: 4BCE93C1  bl 0x82ca940c
	ctx.lr = 0x82FC0050;
	sub_82CA93D0(ctx, base);
	// 82FC0050: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC0054: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82FC0058: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82FC005C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC0060: 3BEB96C0  addi r31, r11, -0x6940
	ctx.r[31].s64 = ctx.r[11].s64 + -26944;
	// 82FC0064: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82FC0068: 816A96C4  lwz r11, -0x693c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-26940 as u32) ) } as u64;
	// 82FC006C: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC0070: 40820024  bne 0x82fc0094
	if !ctx.cr[0].eq {
	pc = 0x82FC0094; continue 'dispatch;
	}
	// 82FC0074: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82FC0078: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82FC007C: 39296840  addi r9, r9, 0x6840
	ctx.r[9].s64 = ctx.r[9].s64 + 26688;
	// 82FC0080: 916A96C4  stw r11, -0x693c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-26940 as u32), ctx.r[11].u32 ) };
	// 82FC0084: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 82FC0088: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82FC008C: 386B92B0  addi r3, r11, -0x6d50
	ctx.r[3].s64 = ctx.r[11].s64 + -27984;
	// 82FC0090: 4BCE9E91  bl 0x82ca9f20
	ctx.lr = 0x82FC0094;
	sub_82CA9F20(ctx, base);
	pc = 0x82FC0094; continue 'dispatch;
            }
            0x82FC0094 => {
    //   block [0x82FC0094..0x82FC00C0)
	// 82FC0094: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC0098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC009C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC00A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC00A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC00A8: 4E800421  bctrl
	ctx.lr = 0x82FC00AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC00AC: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82FC00B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC00B4: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82FC00B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC00BC: 4BCE93A0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC00C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC00C0 size=300
    let mut pc: u32 = 0x82FC00C0;
    'dispatch: loop {
        match pc {
            0x82FC00C0 => {
    //   block [0x82FC00C0..0x82FC01EC)
	// 82FC00C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC00C4: 4BCE9339  bl 0x82ca93fc
	ctx.lr = 0x82FC00C8;
	sub_82CA93D0(ctx, base);
	// 82FC00C8: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82FC00CC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC00D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC00D4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82FC00D8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FC00DC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82FC00E0: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82FC00E4: 576A402E  slwi r10, r27, 8
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82FC00E8: A0DE0006  lhz r6, 6(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 82FC00EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC00F0: A13D0006  lhz r9, 6(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(6 as u32) ) } as u64;
	// 82FC00F4: 7D45DB78  or r5, r10, r27
	ctx.r[5].u64 = ctx.r[10].u64 | ctx.r[27].u64;
	// 82FC00F8: A17E0004  lhz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC00FC: 0CDB0000  twi 6, r27, 0
	// 82FC0100: A0FD0004  lhz r7, 4(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0104: 7D464850  subf r10, r6, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 82FC0108: 0CC50000  twi 6, r5, 0
	// 82FC010C: 7D2B3850  subf r9, r11, r7
	ctx.r[9].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 82FC0110: 7CEAE1D6  mullw r7, r10, r28
	ctx.r[7].s32 = ((ctx.r[10].s32 as i64 * ctx.r[28].s32 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 82FC0114: 7D09E1D6  mullw r8, r9, r28
	ctx.r[8].s32 = ((ctx.r[9].s32 as i64 * ctx.r[28].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82FC0118: 5509083E  rotlwi r9, r8, 1
	ctx.r[9].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 82FC011C: 54EA083E  rotlwi r10, r7, 1
	ctx.r[10].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 82FC0120: 7D08DBD6  divw r8, r8, r27
	ctx.r[8].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	// 82FC0124: 388AFFFF  addi r4, r10, -1
	ctx.r[4].s64 = ctx.r[10].s64 + -1;
	// 82FC0128: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82FC012C: 7D685A14  add r11, r8, r11
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82FC0130: 7CE72BD6  divw r7, r7, r5
	ctx.r[7].s32 = ctx.r[7].s32 / ctx.r[5].s32;
	// 82FC0134: 7CA82078  andc r8, r5, r4
	ctx.r[8].u64 = ctx.r[5].u64 & !ctx.r[4].u64;
	// 82FC0138: 7F694878  andc r9, r27, r9
	ctx.r[9].u64 = ctx.r[27].u64 & !ctx.r[9].u64;
	// 82FC013C: 5563043E  clrlwi r3, r11, 0x10
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82FC0140: 7F473214  add r26, r7, r6
	ctx.r[26].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 82FC0144: 0CA8FFFF  twi 5, r8, -1
	// 82FC0148: 0CA9FFFF  twi 5, r9, -1
	// 82FC014C: 4BFFF535  bl 0x82fbf680
	ctx.lr = 0x82FC0150;
	sub_82FBF680(ctx, base);
	// 82FC0150: A17E0002  lhz r11, 2(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 82FC0154: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82FC0158: A15D0002  lhz r10, 2(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(2 as u32) ) } as u64;
	// 82FC015C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82FC0160: 0CDB0000  twi 6, r27, 0
	// 82FC0164: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82FC0168: 7D2AE1D6  mullw r9, r10, r28
	ctx.r[9].s32 = ((ctx.r[10].s32 as i64 * ctx.r[28].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82FC016C: 552A083E  rotlwi r10, r9, 1
	ctx.r[10].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 82FC0170: 7D29DBD6  divw r9, r9, r27
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	// 82FC0174: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82FC0178: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82FC017C: 7F6A5078  andc r10, r27, r10
	ctx.r[10].u64 = ctx.r[27].u64 & !ctx.r[10].u64;
	// 82FC0180: 5563043E  clrlwi r3, r11, 0x10
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82FC0184: 0CAAFFFF  twi 5, r10, -1
	// 82FC0188: 4BFFF4F9  bl 0x82fbf680
	ctx.lr = 0x82FC018C;
	sub_82FBF680(ctx, base);
	// 82FC018C: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC0190: A13D0000  lhz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC0194: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC0198: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82FC019C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82FC01A0: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82FC01A4: 0CDB0000  twi 6, r27, 0
	// 82FC01A8: 7D2BE1D6  mullw r9, r11, r28
	ctx.r[9].s32 = ((ctx.r[11].s32 as i64 * ctx.r[28].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82FC01AC: 552B083E  rotlwi r11, r9, 1
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 82FC01B0: 7D29DBD6  divw r9, r9, r27
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	// 82FC01B4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FC01B8: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82FC01BC: 7F6B5878  andc r11, r27, r11
	ctx.r[11].u64 = ctx.r[27].u64 & !ctx.r[11].u64;
	// 82FC01C0: 5543043E  clrlwi r3, r10, 0x10
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82FC01C4: 0CABFFFF  twi 5, r11, -1
	// 82FC01C8: 4BFFF4B9  bl 0x82fbf680
	ctx.lr = 0x82FC01CC;
	sub_82FBF680(ctx, base);
	// 82FC01CC: 987F0001  stb r3, 1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(1 as u32), ctx.r[3].u8 ) };
	// 82FC01D0: 9BDF0002  stb r30, 2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(2 as u32), ctx.r[30].u8 ) };
	// 82FC01D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC01D8: 9B3F0003  stb r25, 3(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(3 as u32), ctx.r[25].u8 ) };
	// 82FC01DC: 9B5F0000  stb r26, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 82FC01E0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82FC01E4: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82FC01E8: 4BCE9264  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC01F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC01F0 size=236
    let mut pc: u32 = 0x82FC01F0;
    'dispatch: loop {
        match pc {
            0x82FC01F0 => {
    //   block [0x82FC01F0..0x82FC02DC)
	// 82FC01F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC01F4: 4BCE9209  bl 0x82ca93fc
	ctx.lr = 0x82FC01F8;
	sub_82CA93D0(ctx, base);
	// 82FC01F8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82FC01FC: A0650000  lhz r3, 0(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC0200: A1640000  lhz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC0204: 54EA402E  slwi r10, r7, 8
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82FC0208: A3650002  lhz r27, 2(r5)
	ctx.r[27].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 82FC020C: A3250004  lhz r25, 4(r5)
	ctx.r[25].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0210: 7D2B1850  subf r9, r11, r3
	ctx.r[9].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82FC0214: A3C40004  lhz r30, 4(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0218: A3E40002  lhz r31, 2(r4)
	ctx.r[31].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(2 as u32) ) } as u64;
	// 82FC021C: A1040006  lhz r8, 6(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 82FC0220: 7C7EC850  subf r3, r30, r25
	ctx.r[3].s64 = ctx.r[25].s64 - ctx.r[30].s64;
	// 82FC0224: A0A50006  lhz r5, 6(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[5].u32.wrapping_add(6 as u32) ) } as u64;
	// 82FC0228: 7C9FD850  subf r4, r31, r27
	ctx.r[4].s64 = ctx.r[27].s64 - ctx.r[31].s64;
	// 82FC022C: 7D5B3B78  or r27, r10, r7
	ctx.r[27].u64 = ctx.r[10].u64 | ctx.r[7].u64;
	// 82FC0230: 7D4931D6  mullw r10, r9, r6
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * ctx.r[6].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC0234: 7CA82850  subf r5, r8, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[8].s64;
	// 82FC0238: 7F4331D6  mullw r26, r3, r6
	ctx.r[26].s32 = ((ctx.r[3].s32 as i64 * ctx.r[6].s32 as i64) as i32);
	ctx.r[26].s64 = ctx.r[26].s32 as i64;
	// 82FC023C: 7FA431D6  mullw r29, r4, r6
	ctx.r[29].s32 = ((ctx.r[4].s32 as i64 * ctx.r[6].s32 as i64) as i32);
	ctx.r[29].s64 = ctx.r[29].s32 as i64;
	// 82FC0240: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 82FC0244: 7F2531D6  mullw r25, r5, r6
	ctx.r[25].s32 = ((ctx.r[5].s32 as i64 * ctx.r[6].s32 as i64) as i32);
	ctx.r[25].s64 = ctx.r[25].s32 as i64;
	// 82FC0248: 7D0ADBD6  divw r8, r10, r27
	ctx.r[8].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 82FC024C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82FC0250: 7CDDDBD6  divw r6, r29, r27
	ctx.r[6].s32 = ctx.r[29].s32 / ctx.r[27].s32;
	// 82FC0254: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 82FC0258: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82FC025C: 555E083E  rotlwi r30, r10, 1
	ctx.r[30].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82FC0260: 7C9ADBD6  divw r4, r26, r27
	ctx.r[4].s32 = ctx.r[26].s32 / ctx.r[27].s32;
	// 82FC0264: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82FC0268: 57BD083E  rotlwi r29, r29, 1
	ctx.r[29].u64 = ((ctx.r[29].u32).rotate_left(1)) as u64;
	// 82FC026C: 574A083E  rotlwi r10, r26, 1
	ctx.r[10].u64 = ((ctx.r[26].u32).rotate_left(1)) as u64;
	// 82FC0270: 993C0001  stb r9, 1(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(1 as u32), ctx.r[9].u8 ) };
	// 82FC0274: 572B083E  rotlwi r11, r25, 1
	ctx.r[11].u64 = ((ctx.r[25].u32).rotate_left(1)) as u64;
	// 82FC0278: 7D063A14  add r8, r6, r7
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 82FC027C: 7CE42A14  add r7, r4, r5
	ctx.r[7].u64 = ctx.r[4].u64 + ctx.r[5].u64;
	// 82FC0280: 7FF9DBD6  divw r31, r25, r27
	ctx.r[31].s32 = ctx.r[25].s32 / ctx.r[27].s32;
	// 82FC0284: 991C0002  stb r8, 2(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(2 as u32), ctx.r[8].u8 ) };
	// 82FC0288: 38DEFFFF  addi r6, r30, -1
	ctx.r[6].s64 = ctx.r[30].s64 + -1;
	// 82FC028C: 98FC0003  stb r7, 3(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(3 as u32), ctx.r[7].u8 ) };
	// 82FC0290: 38BDFFFF  addi r5, r29, -1
	ctx.r[5].s64 = ctx.r[29].s64 + -1;
	// 82FC0294: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82FC0298: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FC029C: 7C7F1A14  add r3, r31, r3
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[3].u64;
	// 82FC02A0: 7F683078  andc r8, r27, r6
	ctx.r[8].u64 = ctx.r[27].u64 & !ctx.r[6].u64;
	// 82FC02A4: 7F672878  andc r7, r27, r5
	ctx.r[7].u64 = ctx.r[27].u64 & !ctx.r[5].u64;
	// 82FC02A8: 987C0000  stb r3, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u8 ) };
	// 82FC02AC: 7F6A5078  andc r10, r27, r10
	ctx.r[10].u64 = ctx.r[27].u64 & !ctx.r[10].u64;
	// 82FC02B0: 7F6B5878  andc r11, r27, r11
	ctx.r[11].u64 = ctx.r[27].u64 & !ctx.r[11].u64;
	// 82FC02B4: 0CDB0000  twi 6, r27, 0
	// 82FC02B8: 0CDB0000  twi 6, r27, 0
	// 82FC02BC: 0CDB0000  twi 6, r27, 0
	// 82FC02C0: 0CDB0000  twi 6, r27, 0
	// 82FC02C4: 0CA8FFFF  twi 5, r8, -1
	// 82FC02C8: 0CA7FFFF  twi 5, r7, -1
	// 82FC02CC: 0CAAFFFF  twi 5, r10, -1
	// 82FC02D0: 0CABFFFF  twi 5, r11, -1
	// 82FC02D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC02D8: 4BCE9174  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC02E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC02E0 size=772
    let mut pc: u32 = 0x82FC02E0;
    'dispatch: loop {
        match pc {
            0x82FC02E0 => {
    //   block [0x82FC02E0..0x82FC0318)
	// 82FC02E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC02E4: 4BCE9111  bl 0x82ca93f4
	ctx.lr = 0x82FC02E8;
	sub_82CA93D0(ctx, base);
	// 82FC02E8: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82FC02EC: 4BCED9E9  bl 0x82cadcd4
	ctx.lr = 0x82FC02F0;
	sub_82CADCA0(ctx, base);
	// 82FC02F0: 9421FD10  stwu r1, -0x2f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-752 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC02F4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82FC02F8: FF600890  fmr f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = ctx.f[1].f64;
	// 82FC02FC: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82FC0300: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82FC0304: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82FC0308: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82FC030C: 419A000C  beq cr6, 0x82fc0318
	if ctx.cr[6].eq {
	pc = 0x82FC0318; continue 'dispatch;
	}
	// 82FC0310: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82FC0314: 409A0018  bne cr6, 0x82fc032c
	if !ctx.cr[6].eq {
	pc = 0x82FC032C; continue 'dispatch;
	}
	pc = 0x82FC0318; continue 'dispatch;
            }
            0x82FC0318 => {
    //   block [0x82FC0318..0x82FC032C)
	// 82FC0318: 3D60FF00  lis r11, -0x100
	ctx.r[11].s64 = -16777216;
	// 82FC031C: 9B410060  stb r26, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u8 ) };
	// 82FC0320: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82FC0324: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82FC0328: 3BA10060  addi r29, r1, 0x60
	ctx.r[29].s64 = ctx.r[1].s64 + 96;
	pc = 0x82FC032C; continue 'dispatch;
            }
            0x82FC032C => {
    //   block [0x82FC032C..0x82FC0350)
	// 82FC032C: 2B1C0001  cmplwi cr6, r28, 1
	ctx.cr[6].compare_u32(ctx.r[28].u32, 1 as u32, &mut ctx.xer);
	// 82FC0330: 40990288  ble cr6, 0x82fc05b8
	if !ctx.cr[6].gt {
	pc = 0x82FC05B8; continue 'dispatch;
	}
	// 82FC0334: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC0338: C38B0C14  lfs f28, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82FC033C: FFE0E090  fmr f31, f28
	ctx.f[31].f64 = ctx.f[28].f64;
	// 82FC0340: FF1BE000  fcmpu cr6, f27, f28
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[28].f64);
	// 82FC0344: 409A002C  bne cr6, 0x82fc0370
	if !ctx.cr[6].eq {
	pc = 0x82FC0370; continue 'dispatch;
	}
	// 82FC0348: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82FC034C: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	pc = 0x82FC0350; continue 'dispatch;
            }
            0x82FC0350 => {
    //   block [0x82FC0350..0x82FC0370)
	// 82FC0350: 5569402E  slwi r9, r11, 8
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82FC0354: 7D295B78  or r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 | ctx.r[11].u64;
	// 82FC0358: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FC035C: B12A0000  sth r9, 0(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 82FC0360: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 82FC0364: 2B0B0100  cmplwi cr6, r11, 0x100
	ctx.cr[6].compare_u32(ctx.r[11].u32, 256 as u32, &mut ctx.xer);
	// 82FC0368: 4198FFE8  blt cr6, 0x82fc0350
	if ctx.cr[6].lt {
	pc = 0x82FC0350; continue 'dispatch;
	}
	// 82FC036C: 48000078  b 0x82fc03e4
	pc = 0x82FC03E4; continue 'dispatch;
            }
            0x82FC0370 => {
    //   block [0x82FC0370..0x82FC0390)
	// 82FC0370: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC0374: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC0378: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82FC037C: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 82FC0380: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 82FC0384: C3AB0BFC  lfs f29, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82FC0388: C3CA0DB4  lfs f30, 0xdb4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3508 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82FC038C: C3E90B98  lfs f31, 0xb98(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2968 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82FC0390; continue 'dispatch;
            }
            0x82FC0390 => {
    //   block [0x82FC0390..0x82FC03E4)
	// 82FC0390: 7BEB0020  clrldi r11, r31, 0x20
	ctx.r[11].u64 = ctx.r[31].u64 & 0x00000000FFFFFFFFu64;
	// 82FC0394: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 82FC0398: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82FC039C: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82FC03A0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC03A4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC03A8: EC2007F2  fmuls f1, f0, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82FC03AC: 4B23E0FD  bl 0x821fe4a8
	ctx.lr = 0x82FC03B0;
	sub_821FE4A8(ctx, base);
	// 82FC03B0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FC03B4: EC20EFBA  fmadds f1, f0, f30, f29
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[29].f64) as f32) as f64);
	// 82FC03B8: 4B26BFD9  bl 0x8222c390
	ctx.lr = 0x82FC03BC;
	sub_8222C390(ctx, base);
	// 82FC03BC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FC03C0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82FC03C4: 2B1F0100  cmplwi cr6, r31, 0x100
	ctx.cr[6].compare_u32(ctx.r[31].u32, 256 as u32, &mut ctx.xer);
	// 82FC03C8: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82FC03CC: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FC03D0: A1610056  lhz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82FC03D4: B17E0000  sth r11, 0(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 82FC03D8: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 82FC03DC: 4198FFB4  blt cr6, 0x82fc0390
	if ctx.cr[6].lt {
	pc = 0x82FC0390; continue 'dispatch;
	}
	// 82FC03E0: EFFCD824  fdivs f31, f28, f27
	ctx.f[31].f64 = ((ctx.f[28].f64 / ctx.f[27].f64) as f32) as f64;
	pc = 0x82FC03E4; continue 'dispatch;
            }
            0x82FC03E4 => {
    //   block [0x82FC03E4..0x82FC03FC)
	// 82FC03E4: 8BFD0000  lbz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC03E8: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC03EC: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC03F0: 41820018  beq 0x82fc0408
	if ctx.cr[0].eq {
	pc = 0x82FC0408; continue 'dispatch;
	}
	// 82FC03F4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 82FC03F8: 7FE903A6  mtctr r31
	ctx.ctr.u64 = ctx.r[31].u64;
	pc = 0x82FC03FC; continue 'dispatch;
            }
            0x82FC03FC => {
    //   block [0x82FC03FC..0x82FC0408)
	// 82FC03FC: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82FC0400: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82FC0404: 4200FFF8  bdnz 0x82fc03fc
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82FC03FC; continue 'dispatch;
	}
	pc = 0x82FC0408; continue 'dispatch;
            }
            0x82FC0408 => {
    //   block [0x82FC0408..0x82FC0418)
	// 82FC0408: 2B1C0001  cmplwi cr6, r28, 1
	ctx.cr[6].compare_u32(ctx.r[28].u32, 1 as u32, &mut ctx.xer);
	// 82FC040C: 40990184  ble cr6, 0x82fc0590
	if !ctx.cr[6].gt {
	pc = 0x82FC0590; continue 'dispatch;
	}
	// 82FC0410: 397D0006  addi r11, r29, 6
	ctx.r[11].s64 = ctx.r[29].s64 + 6;
	// 82FC0414: 3AFCFFFF  addi r23, r28, -1
	ctx.r[23].s64 = ctx.r[28].s64 + -1;
	pc = 0x82FC0418; continue 'dispatch;
            }
            0x82FC0418 => {
    //   block [0x82FC0418..0x82FC0428)
	// 82FC0418: 8B4B0002  lbz r26, 2(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82FC041C: 7F1AF840  cmplw cr6, r26, r31
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82FC0420: 40980008  bge cr6, 0x82fc0428
	if !ctx.cr[6].lt {
	pc = 0x82FC0428; continue 'dispatch;
	}
	// 82FC0424: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	pc = 0x82FC0428; continue 'dispatch;
            }
            0x82FC0428 => {
    //   block [0x82FC0428..0x82FC04F0)
	// 82FC0428: 894BFFFF  lbz r10, -1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 82FC042C: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82FC0430: 88EB0000  lbz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC0434: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82FC0438: 88AB0001  lbz r5, 1(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82FC043C: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82FC0440: 886B0007  lbz r3, 7(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(7 as u32) ) } as u64;
	// 82FC0444: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82FC0448: 54E7083E  rotlwi r7, r7, 1
	ctx.r[7].u64 = ((ctx.r[7].u32).rotate_left(1)) as u64;
	// 82FC044C: 8BAB0008  lbz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC0450: 54A5083E  rotlwi r5, r5, 1
	ctx.r[5].u64 = ((ctx.r[5].u32).rotate_left(1)) as u64;
	// 82FC0454: 8BCB0009  lbz r30, 9(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(9 as u32) ) } as u64;
	// 82FC0458: 3B210070  addi r25, r1, 0x70
	ctx.r[25].s64 = ctx.r[1].s64 + 112;
	// 82FC045C: 8B8BFFFE  lbz r28, -2(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 82FC0460: 5463083E  rotlwi r3, r3, 1
	ctx.r[3].u64 = ((ctx.r[3].u32).rotate_left(1)) as u64;
	// 82FC0464: 7D4A422E  lhzx r10, r10, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82FC0468: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 82FC046C: 8B6B0006  lbz r27, 6(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 82FC0470: 57BD083E  rotlwi r29, r29, 1
	ctx.r[29].u64 = ((ctx.r[29].u32).rotate_left(1)) as u64;
	// 82FC0474: 7CE7322E  lhzx r7, r7, r6
	ctx.r[7].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82FC0478: 7CA5222E  lhzx r5, r5, r4
	ctx.r[5].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82FC047C: 57C6083E  rotlwi r6, r30, 1
	ctx.r[6].u64 = ((ctx.r[30].u32).rotate_left(1)) as u64;
	// 82FC0480: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82FC0484: FF1BE000  fcmpu cr6, f27, f28
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[28].f64);
	// 82FC0488: 7C63CA2E  lhzx r3, r3, r25
	ctx.r[3].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 82FC048C: 579E403E  rotlwi r30, r28, 8
	ctx.r[30].u64 = ((ctx.r[28].u32).rotate_left(8)) as u64;
	// 82FC0490: 5779403E  rotlwi r25, r27, 8
	ctx.r[25].u64 = ((ctx.r[27].u32).rotate_left(8)) as u64;
	// 82FC0494: B1410058  sth r10, 0x58(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u16 ) };
	// 82FC0498: 7D5D422E  lhzx r10, r29, r8
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82FC049C: 7FC8E378  or r8, r30, r28
	ctx.r[8].u64 = ctx.r[30].u64 | ctx.r[28].u64;
	// 82FC04A0: B0E1005A  sth r7, 0x5a(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(90 as u32), ctx.r[7].u16 ) };
	// 82FC04A4: 7F3EDB78  or r30, r25, r27
	ctx.r[30].u64 = ctx.r[25].u64 | ctx.r[27].u64;
	// 82FC04A8: 7CE6222E  lhzx r7, r6, r4
	ctx.r[7].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82FC04AC: 3B2B0008  addi r25, r11, 8
	ctx.r[25].s64 = ctx.r[11].s64 + 8;
	// 82FC04B0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82FC04B4: B0A1005C  sth r5, 0x5c(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u16 ) };
	// 82FC04B8: B0610050  sth r3, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u16 ) };
	// 82FC04BC: 7FDFD050  subf r30, r31, r26
	ctx.r[30].s64 = ctx.r[26].s64 - ctx.r[31].s64;
	// 82FC04C0: B1410052  sth r10, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[10].u16 ) };
	// 82FC04C4: B101005E  sth r8, 0x5e(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(94 as u32), ctx.r[8].u16 ) };
	// 82FC04C8: B0E10054  sth r7, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u16 ) };
	// 82FC04CC: B0C10056  sth r6, 0x56(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[6].u16 ) };
	// 82FC04D0: 409A0058  bne cr6, 0x82fc0528
	if !ctx.cr[6].eq {
	pc = 0x82FC0528; continue 'dispatch;
	}
	// 82FC04D4: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82FC04D8: 409800A4  bge cr6, 0x82fc057c
	if !ctx.cr[6].lt {
	pc = 0x82FC057C; continue 'dispatch;
	}
	// 82FC04DC: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC04E0: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82FC04E4: 7F6BC214  add r27, r11, r24
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 82FC04E8: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82FC04EC: 7FFEFA14  add r31, r30, r31
	ctx.r[31].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	pc = 0x82FC04F0; continue 'dispatch;
            }
            0x82FC04F0 => {
    //   block [0x82FC04F0..0x82FC0528)
	// 82FC04F0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82FC04F4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82FC04F8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82FC04FC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82FC0500: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82FC0504: 4BFFFCED  bl 0x82fc01f0
	ctx.lr = 0x82FC0508;
	sub_82FC01F0(ctx, base);
	// 82FC0508: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC050C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82FC0510: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82FC0514: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82FC0518: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC051C: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82FC0520: 4082FFD0  bne 0x82fc04f0
	if !ctx.cr[0].eq {
	pc = 0x82FC04F0; continue 'dispatch;
	}
	// 82FC0524: 48000058  b 0x82fc057c
	pc = 0x82FC057C; continue 'dispatch;
            }
            0x82FC0528 => {
    //   block [0x82FC0528..0x82FC0544)
	// 82FC0528: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82FC052C: 40980050  bge cr6, 0x82fc057c
	if !ctx.cr[6].lt {
	pc = 0x82FC057C; continue 'dispatch;
	}
	// 82FC0530: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC0534: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 82FC0538: 7F6BC214  add r27, r11, r24
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 82FC053C: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82FC0540: 7FFEFA14  add r31, r30, r31
	ctx.r[31].u64 = ctx.r[30].u64 + ctx.r[31].u64;
	pc = 0x82FC0544; continue 'dispatch;
            }
            0x82FC0544 => {
    //   block [0x82FC0544..0x82FC057C)
	// 82FC0544: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82FC0548: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82FC054C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82FC0550: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82FC0554: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82FC0558: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82FC055C: 4BFFFB65  bl 0x82fc00c0
	ctx.lr = 0x82FC0560;
	sub_82FC00C0(ctx, base);
	// 82FC0560: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC0564: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82FC0568: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82FC056C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82FC0570: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC0574: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82FC0578: 4082FFCC  bne 0x82fc0544
	if !ctx.cr[0].eq {
	pc = 0x82FC0544; continue 'dispatch;
	}
	pc = 0x82FC057C; continue 'dispatch;
            }
            0x82FC057C => {
    //   block [0x82FC057C..0x82FC0590)
	// 82FC057C: 36F7FFFF  addic. r23, r23, -1
	ctx.xer.ca = (ctx.r[23].u32 > (!(-1 as u32)));
	ctx.r[23].s64 = ctx.r[23].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 82FC0580: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82FC0584: 4082FE94  bne 0x82fc0418
	if !ctx.cr[0].eq {
	pc = 0x82FC0418; continue 'dispatch;
	}
	// 82FC0588: 2B1A0100  cmplwi cr6, r26, 0x100
	ctx.cr[6].compare_u32(ctx.r[26].u32, 256 as u32, &mut ctx.xer);
	// 82FC058C: 40980048  bge cr6, 0x82fc05d4
	if !ctx.cr[6].lt {
	pc = 0x82FC05D4; continue 'dispatch;
	}
	pc = 0x82FC0590; continue 'dispatch;
            }
            0x82FC0590 => {
    //   block [0x82FC0590..0x82FC05A8)
	// 82FC0590: 574A103A  slwi r10, r26, 2
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82FC0594: 217A0100  subfic r11, r26, 0x100
	ctx.xer.ca = ctx.r[26].u32 <= 256 as u32;
	ctx.r[11].s64 = (256 as i64) - ctx.r[26].s64;
	// 82FC0598: 7D4AC214  add r10, r10, r24
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[24].u64;
	// 82FC059C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC05A0: 419A0034  beq cr6, 0x82fc05d4
	if ctx.cr[6].eq {
	pc = 0x82FC05D4; continue 'dispatch;
	}
	// 82FC05A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x82FC05A8; continue 'dispatch;
            }
            0x82FC05A8 => {
    //   block [0x82FC05A8..0x82FC05B8)
	// 82FC05A8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82FC05AC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82FC05B0: 4200FFF8  bdnz 0x82fc05a8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82FC05A8; continue 'dispatch;
	}
	// 82FC05B4: 48000020  b 0x82fc05d4
	pc = 0x82FC05D4; continue 'dispatch;
            }
            0x82FC05B8 => {
    //   block [0x82FC05B8..0x82FC05C0)
	// 82FC05B8: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	// 82FC05BC: 39600100  li r11, 0x100
	ctx.r[11].s64 = 256;
	pc = 0x82FC05C0; continue 'dispatch;
            }
            0x82FC05C0 => {
    //   block [0x82FC05C0..0x82FC05D4)
	// 82FC05C0: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC05C4: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC05C8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82FC05CC: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82FC05D0: 4082FFF0  bne 0x82fc05c0
	if !ctx.cr[0].eq {
	pc = 0x82FC05C0; continue 'dispatch;
	}
	pc = 0x82FC05D4; continue 'dispatch;
            }
            0x82FC05D4 => {
    //   block [0x82FC05D4..0x82FC05E4)
	// 82FC05D4: 382102F0  addi r1, r1, 0x2f0
	ctx.r[1].s64 = ctx.r[1].s64 + 752;
	// 82FC05D8: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82FC05DC: 4BCED745  bl 0x82cadd20
	ctx.lr = 0x82FC05E0;
	sub_82CADCEC(ctx, base);
	// 82FC05E0: 4BCE8E64  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC05E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC05E8 size=952
    let mut pc: u32 = 0x82FC05E8;
    'dispatch: loop {
        match pc {
            0x82FC05E8 => {
    //   block [0x82FC05E8..0x82FC0684)
	// 82FC05E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC05EC: 4BCE8E09  bl 0x82ca93f4
	ctx.lr = 0x82FC05F0;
	sub_82CA93D0(ctx, base);
	// 82FC05F0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC05F4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82FC05F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC05FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC0600: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82FC0604: 4BF3F1AD  bl 0x82eff7b0
	ctx.lr = 0x82FC0608;
	sub_82EFF7B0(ctx, base);
	// 82FC0608: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 82FC060C: 987E0000  stb r3, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[3].u8 ) };
	// 82FC0610: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FC0614: 9AFE0001  stb r23, 1(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(1 as u32), ctx.r[23].u8 ) };
	// 82FC0618: 3B1F0018  addi r24, r31, 0x18
	ctx.r[24].s64 = ctx.r[31].s64 + 24;
	// 82FC061C: 5465063E  clrlwi r5, r3, 0x18
	ctx.r[5].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82FC0620: 388B689C  addi r4, r11, 0x689c
	ctx.r[4].s64 = ctx.r[11].s64 + 26780;
	// 82FC0624: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82FC0628: 4BF3FC89  bl 0x82f002b0
	ctx.lr = 0x82FC062C;
	sub_82F002B0(ctx, base);
	// 82FC062C: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC0630: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC0634: 4082005C  bne 0x82fc0690
	if !ctx.cr[0].eq {
	pc = 0x82FC0690; continue 'dispatch;
	}
	// 82FC0638: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82FC063C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FC0640: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC0644: 4BF84E65  bl 0x82f454a8
	ctx.lr = 0x82FC0648;
	sub_82F454A8(ctx, base);
	// 82FC0648: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FC064C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82FC0650: 388B6890  addi r4, r11, 0x6890
	ctx.r[4].s64 = ctx.r[11].s64 + 26768;
	// 82FC0654: 4BF3FC5D  bl 0x82f002b0
	ctx.lr = 0x82FC0658;
	sub_82F002B0(ctx, base);
	// 82FC0658: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC065C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82FC0660: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 82FC0664: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82FC0668: 4BF70AE9  bl 0x82f31150
	ctx.lr = 0x82FC066C;
	sub_82F31150(ctx, base);
	// 82FC066C: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC0670: 2B0B00FF  cmplwi cr6, r11, 0xff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 255 as u32, &mut ctx.xer);
	// 82FC0674: 40980010  bge cr6, 0x82fc0684
	if !ctx.cr[6].lt {
	pc = 0x82FC0684; continue 'dispatch;
	}
	// 82FC0678: 897E0001  lbz r11, 1(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1 as u32) ) } as u64;
	// 82FC067C: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 82FC0680: 997E0001  stb r11, 1(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	pc = 0x82FC0684; continue 'dispatch;
            }
            0x82FC0684 => {
    //   block [0x82FC0684..0x82FC0690)
	// 82FC0684: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC0688: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC068C: 4800030C  b 0x82fc0998
	pc = 0x82FC0998; continue 'dispatch;
            }
            0x82FC0690 => {
    //   block [0x82FC0690..0x82FC06C4)
	// 82FC0690: 556A06F7  rlwinm. r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC0694: 4182029C  beq 0x82fc0930
	if ctx.cr[0].eq {
	pc = 0x82FC0930; continue 'dispatch;
	}
	// 82FC0698: 389E0010  addi r4, r30, 0x10
	ctx.r[4].s64 = ctx.r[30].s64 + 16;
	// 82FC069C: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 82FC06A0: 4BF70391  bl 0x82f30a30
	ctx.lr = 0x82FC06A4;
	sub_82F30A30(ctx, base);
	// 82FC06A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC06A8: 4BF3F109  bl 0x82eff7b0
	ctx.lr = 0x82FC06AC;
	sub_82EFF7B0(ctx, base);
	// 82FC06AC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82FC06B0: 556A06F7  rlwinm. r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC06B4: 41820010  beq 0x82fc06c4
	if ctx.cr[0].eq {
	pc = 0x82FC06C4; continue 'dispatch;
	}
	// 82FC06B8: 895E0001  lbz r10, 1(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1 as u32) ) } as u64;
	// 82FC06BC: 614A0001  ori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 | 1;
	// 82FC06C0: 995E0001  stb r10, 1(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(1 as u32), ctx.r[10].u8 ) };
	pc = 0x82FC06C4; continue 'dispatch;
            }
            0x82FC06C4 => {
    //   block [0x82FC06C4..0x82FC0708)
	// 82FC06C4: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82FC06C8: 557D073E  clrlwi r29, r11, 0x1c
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82FC06CC: 4BF3D195  bl 0x82efd860
	ctx.lr = 0x82FC06D0;
	sub_82EFD860(ctx, base);
	// 82FC06D0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC06D4: 41820034  beq 0x82fc0708
	if ctx.cr[0].eq {
	pc = 0x82FC0708; continue 'dispatch;
	}
	// 82FC06D8: 3D605647  lis r11, 0x5647
	ctx.r[11].s64 = 1447493632;
	// 82FC06DC: 3D409FE1  lis r10, -0x601f
	ctx.r[10].s64 = -1612644352;
	// 82FC06E0: 616B1E89  ori r11, r11, 0x1e89
	ctx.r[11].u64 = ctx.r[11].u64 | 7817;
	// 82FC06E4: 614A234A  ori r10, r10, 0x234a
	ctx.r[10].u64 = ctx.r[10].u64 | 9034;
	// 82FC06E8: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC06EC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82FC06F0: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82FC06F4: 889E0000  lbz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC06F8: 897E0001  lbz r11, 1(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1 as u32) ) } as u64;
	// 82FC06FC: 556607FE  clrlwi r6, r11, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82FC0700: 4BFFF861  bl 0x82fbff60
	ctx.lr = 0x82FC0704;
	sub_82FBFF60(ctx, base);
	// 82FC0704: 48000008  b 0x82fc070c
	pc = 0x82FC070C; continue 'dispatch;
            }
            0x82FC0708 => {
    //   block [0x82FC0708..0x82FC070C)
	// 82FC0708: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	pc = 0x82FC070C; continue 'dispatch;
            }
            0x82FC070C => {
    //   block [0x82FC070C..0x82FC073C)
	// 82FC070C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC0710: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82FC0714: 419A0210  beq cr6, 0x82fc0924
	if ctx.cr[6].eq {
	pc = 0x82FC0924; continue 'dispatch;
	}
	// 82FC0718: A1630012  lhz r11, 0x12(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(18 as u32) ) } as u64;
	// 82FC071C: 57BB043E  clrlwi r27, r29, 0x10
	ctx.r[27].u64 = ctx.r[29].u32 as u64 & 0x0000FFFFu64;
	// 82FC0720: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82FC0724: 409A01E4  bne cr6, 0x82fc0908
	if !ctx.cr[6].eq {
	pc = 0x82FC0908; continue 'dispatch;
	}
	// 82FC0728: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82FC072C: 40990068  ble cr6, 0x82fc0794
	if !ctx.cr[6].gt {
	pc = 0x82FC0794; continue 'dispatch;
	}
	// 82FC0730: 39630014  addi r11, r3, 0x14
	ctx.r[11].s64 = ctx.r[3].s64 + 20;
	// 82FC0734: 7EFDBB78  mr r29, r23
	ctx.r[29].u64 = ctx.r[23].u64;
	// 82FC0738: 7F7ADB78  mr r26, r27
	ctx.r[26].u64 = ctx.r[27].u64;
	pc = 0x82FC073C; continue 'dispatch;
            }
            0x82FC073C => {
    //   block [0x82FC073C..0x82FC0788)
	// 82FC073C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC0740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC0744: 7F9D5A14  add r28, r29, r11
	ctx.r[28].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82FC0748: 4BF3F069  bl 0x82eff7b0
	ctx.lr = 0x82FC074C;
	sub_82EFF7B0(ctx, base);
	// 82FC074C: 987C0000  stb r3, 0(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u8 ) };
	// 82FC0750: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82FC0754: 389C0004  addi r4, r28, 4
	ctx.r[4].s64 = ctx.r[28].s64 + 4;
	// 82FC0758: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC075C: 4BF84D4D  bl 0x82f454a8
	ctx.lr = 0x82FC0760;
	sub_82F454A8(ctx, base);
	// 82FC0760: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0764: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82FC0768: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC076C: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 82FC0770: 894A0004  lbz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0774: 2B0A00FF  cmplwi cr6, r10, 0xff
	ctx.cr[6].compare_u32(ctx.r[10].u32, 255 as u32, &mut ctx.xer);
	// 82FC0778: 40980010  bge cr6, 0x82fc0788
	if !ctx.cr[6].lt {
	pc = 0x82FC0788; continue 'dispatch;
	}
	// 82FC077C: 895E0001  lbz r10, 1(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1 as u32) ) } as u64;
	// 82FC0780: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 82FC0784: 995E0001  stb r10, 1(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(1 as u32), ctx.r[10].u8 ) };
	pc = 0x82FC0788; continue 'dispatch;
            }
            0x82FC0788 => {
    //   block [0x82FC0788..0x82FC0794)
	// 82FC0788: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82FC078C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82FC0790: 4082FFAC  bne 0x82fc073c
	if !ctx.cr[0].eq {
	pc = 0x82FC073C; continue 'dispatch;
	}
	pc = 0x82FC0794; continue 'dispatch;
            }
            0x82FC0794 => {
    //   block [0x82FC0794..0x82FC07E4)
	// 82FC0794: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FC0798: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82FC079C: 388B6870  addi r4, r11, 0x6870
	ctx.r[4].s64 = ctx.r[11].s64 + 26736;
	// 82FC07A0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82FC07A4: 4BF3FB0D  bl 0x82f002b0
	ctx.lr = 0x82FC07A8;
	sub_82F002B0(ctx, base);
	// 82FC07A8: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC07AC: 2B0B0013  cmplwi cr6, r11, 0x13
	ctx.cr[6].compare_u32(ctx.r[11].u32, 19 as u32, &mut ctx.xer);
	// 82FC07B0: 409A0034  bne cr6, 0x82fc07e4
	if !ctx.cr[6].eq {
	pc = 0x82FC07E4; continue 'dispatch;
	}
	// 82FC07B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC07B8: 4BF3F059  bl 0x82eff810
	ctx.lr = 0x82FC07BC;
	sub_82EFF810(ctx, base);
	// 82FC07BC: 7C6B0734  extsh r11, r3
	ctx.r[11].s64 = ctx.r[3].s16 as i64;
	// 82FC07C0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC07C4: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC07C8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82FC07CC: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82FC07D0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC07D4: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC07D8: C00A0A90  lfs f0, 0xa90(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2704 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC07DC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC07E0: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	pc = 0x82FC07E4; continue 'dispatch;
            }
            0x82FC07E4 => {
    //   block [0x82FC07E4..0x82FC0814)
	// 82FC07E4: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC07E8: 83AB0128  lwz r29, 0x128(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(296 as u32) ) } as u64;
	// 82FC07EC: 395D0001  addi r10, r29, 1
	ctx.r[10].s64 = ctx.r[29].s64 + 1;
	// 82FC07F0: 914B0128  stw r10, 0x128(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(296 as u32), ctx.r[10].u32 ) };
	// 82FC07F4: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC07F8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82FC07FC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC0800: 419A0014  beq cr6, 0x82fc0814
	if ctx.cr[6].eq {
	pc = 0x82FC0814; continue 'dispatch;
	}
	// 82FC0804: 816B0058  lwz r11, 0x58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 82FC0808: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC080C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FC0810: 40820008  bne 0x82fc0818
	if !ctx.cr[0].eq {
	pc = 0x82FC0818; continue 'dispatch;
	}
	pc = 0x82FC0814; continue 'dispatch;
            }
            0x82FC0814 => {
    //   block [0x82FC0814..0x82FC0818)
	// 82FC0814: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x82FC0818; continue 'dispatch;
            }
            0x82FC0818 => {
    //   block [0x82FC0818..0x82FC0850)
	// 82FC0818: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC081C: 41820054  beq 0x82fc0870
	if ctx.cr[0].eq {
	pc = 0x82FC0870; continue 'dispatch;
	}
	// 82FC0820: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82FC0824: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82FC0828: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 82FC082C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82FC0830: 92E10064  stw r23, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[23].u32 ) };
	// 82FC0834: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC0838: 4BF75239  bl 0x82f35a70
	ctx.lr = 0x82FC083C;
	sub_82F35A70(ctx, base);
	// 82FC083C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC0840: 41820010  beq 0x82fc0850
	if ctx.cr[0].eq {
	pc = 0x82FC0850; continue 'dispatch;
	}
	// 82FC0844: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82FC0848: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82FC084C: 4BF3EDAD  bl 0x82eff5f8
	ctx.lr = 0x82FC0850;
	sub_82EFF5F8(ctx, base);
	pc = 0x82FC0850; continue 'dispatch;
            }
            0x82FC0850 => {
    //   block [0x82FC0850..0x82FC0870)
	// 82FC0850: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82FC0854: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC0858: 409A0140  bne cr6, 0x82fc0998
	if !ctx.cr[6].eq {
	pc = 0x82FC0998; continue 'dispatch;
	}
	// 82FC085C: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82FC0860: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC0864: 419A0134  beq cr6, 0x82fc0998
	if ctx.cr[6].eq {
	pc = 0x82FC0998; continue 'dispatch;
	}
	// 82FC0868: 4BF37A31  bl 0x82ef8298
	ctx.lr = 0x82FC086C;
	sub_82EF8298(ctx, base);
	// 82FC086C: 4800012C  b 0x82fc0998
	pc = 0x82FC0998; continue 'dispatch;
            }
            0x82FC0870 => {
    //   block [0x82FC0870..0x82FC08B0)
	// 82FC0870: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82FC0874: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0878: 4BFFF759  bl 0x82fbffd0
	ctx.lr = 0x82FC087C;
	sub_82FBFFD0(ctx, base);
	// 82FC087C: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82FC0880: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82FC0884: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82FC0888: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC088C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82FC0890: 4BF86339  bl 0x82f46bc8
	ctx.lr = 0x82FC0894;
	sub_82F46BC8(ctx, base);
	// 82FC0894: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82FC0898: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82FC089C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC08A0: 409A0010  bne cr6, 0x82fc08b0
	if !ctx.cr[6].eq {
	pc = 0x82FC08B0; continue 'dispatch;
	}
	// 82FC08A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC08A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FC08AC: 419A0008  beq cr6, 0x82fc08b4
	if ctx.cr[6].eq {
	pc = 0x82FC08B4; continue 'dispatch;
	}
	pc = 0x82FC08B0; continue 'dispatch;
            }
            0x82FC08B0 => {
    //   block [0x82FC08B0..0x82FC08B4)
	// 82FC08B0: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x82FC08B4; continue 'dispatch;
            }
            0x82FC08B4 => {
    //   block [0x82FC08B4..0x82FC08CC)
	// 82FC08B4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC08B8: 40820014  bne 0x82fc08cc
	if !ctx.cr[0].eq {
	pc = 0x82FC08CC; continue 'dispatch;
	}
	// 82FC08BC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82FC08C0: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82FC08C4: 4BF3ED35  bl 0x82eff5f8
	ctx.lr = 0x82FC08C8;
	sub_82EFF5F8(ctx, base);
	// 82FC08C8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	pc = 0x82FC08CC; continue 'dispatch;
            }
            0x82FC08CC => {
    //   block [0x82FC08CC..0x82FC08E4)
	// 82FC08CC: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82FC08D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC08D4: 409A0010  bne cr6, 0x82fc08e4
	if !ctx.cr[6].eq {
	pc = 0x82FC08E4; continue 'dispatch;
	}
	// 82FC08D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC08DC: 419A0008  beq cr6, 0x82fc08e4
	if ctx.cr[6].eq {
	pc = 0x82FC08E4; continue 'dispatch;
	}
	// 82FC08E0: 4BF379B9  bl 0x82ef8298
	ctx.lr = 0x82FC08E4;
	sub_82EF8298(ctx, base);
	pc = 0x82FC08E4; continue 'dispatch;
            }
            0x82FC08E4 => {
    //   block [0x82FC08E4..0x82FC0908)
	// 82FC08E4: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82FC08E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC08EC: 419A00AC  beq cr6, 0x82fc0998
	if ctx.cr[6].eq {
	pc = 0x82FC0998; continue 'dispatch;
	}
	// 82FC08F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC08F4: 80810074  lwz r4, 0x74(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82FC08F8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC08FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC0900: 4E800421  bctrl
	ctx.lr = 0x82FC0904;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC0904: 48000094  b 0x82fc0998
	pc = 0x82FC0998; continue 'dispatch;
            }
            0x82FC0908 => {
    //   block [0x82FC0908..0x82FC0924)
	// 82FC0908: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC090C: 419A0018  beq cr6, 0x82fc0924
	if ctx.cr[6].eq {
	pc = 0x82FC0924; continue 'dispatch;
	}
	// 82FC0910: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC0914: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC0918: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC091C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC0920: 4E800421  bctrl
	ctx.lr = 0x82FC0924;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC0924 => {
    //   block [0x82FC0924..0x82FC0930)
	// 82FC0924: 92FE0004  stw r23, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[23].u32 ) };
	// 82FC0928: 9AFE0000  stb r23, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[23].u8 ) };
	// 82FC092C: 4800006C  b 0x82fc0998
	pc = 0x82FC0998; continue 'dispatch;
            }
            0x82FC0930 => {
    //   block [0x82FC0930..0x82FC0998)
	// 82FC0930: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC0934: 41820064  beq 0x82fc0998
	if ctx.cr[0].eq {
	pc = 0x82FC0998; continue 'dispatch;
	}
	// 82FC0938: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC093C: 4BF3EED5  bl 0x82eff810
	ctx.lr = 0x82FC0940;
	sub_82EFF810(ctx, base);
	// 82FC0940: 547D043E  clrlwi r29, r3, 0x10
	ctx.r[29].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 82FC0944: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FC0948: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82FC094C: 388B685C  addi r4, r11, 0x685c
	ctx.r[4].s64 = ctx.r[11].s64 + 26716;
	// 82FC0950: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82FC0954: 4BF3F95D  bl 0x82f002b0
	ctx.lr = 0x82FC0958;
	sub_82F002B0(ctx, base);
	// 82FC0958: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82FC095C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82FC0960: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC0964: 389E0008  addi r4, r30, 8
	ctx.r[4].s64 = ctx.r[30].s64 + 8;
	// 82FC0968: 4BF75109  bl 0x82f35a70
	ctx.lr = 0x82FC096C;
	sub_82F35A70(ctx, base);
	// 82FC096C: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 82FC0970: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 82FC0974: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC0978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC097C: 4BF700B5  bl 0x82f30a30
	ctx.lr = 0x82FC0980;
	sub_82F30A30(ctx, base);
	// 82FC0980: 897E0001  lbz r11, 1(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1 as u32) ) } as u64;
	// 82FC0984: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC0988: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 82FC098C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC0990: 997E0001  stb r11, 1(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(1 as u32), ctx.r[11].u8 ) };
	// 82FC0994: 4BF708D5  bl 0x82f31268
	ctx.lr = 0x82FC0998;
	sub_82F31268(ctx, base);
	pc = 0x82FC0998; continue 'dispatch;
            }
            0x82FC0998 => {
    //   block [0x82FC0998..0x82FC09A0)
	// 82FC0998: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82FC099C: 4BCE8AA8  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC09A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC09A0 size=528
    let mut pc: u32 = 0x82FC09A0;
    'dispatch: loop {
        match pc {
            0x82FC09A0 => {
    //   block [0x82FC09A0..0x82FC0A00)
	// 82FC09A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC09A4: 4BCE8A55  bl 0x82ca93f8
	ctx.lr = 0x82FC09A8;
	sub_82CA93D0(ctx, base);
	// 82FC09A8: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 82FC09AC: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82FC09B0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC09B4: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82FC09B8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82FC09BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC09C0: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 82FC09C4: 89590000  lbz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC09C8: 7D4B5379  or. r11, r10, r10
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC09CC: 995E0000  stb r10, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82FC09D0: 40820030  bne 0x82fc0a00
	if !ctx.cr[0].eq {
	pc = 0x82FC0A00; continue 'dispatch;
	}
	// 82FC09D4: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC09D8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82FC09DC: 81590004  lwz r10, 4(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC09E0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82FC09E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82FC09E8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82FC09EC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82FC09F0: 4BFF9209  bl 0x82fb9bf8
	ctx.lr = 0x82FC09F4;
	sub_82FB9BF8(ctx, base);
	// 82FC09F4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC09F8: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC09FC: 480001A4  b 0x82fc0ba0
	pc = 0x82FC0BA0; continue 'dispatch;
            }
            0x82FC0A00 => {
    //   block [0x82FC0A00..0x82FC0A30)
	// 82FC0A00: 556A06F7  rlwinm. r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC0A04: 41820174  beq 0x82fc0b78
	if ctx.cr[0].eq {
	pc = 0x82FC0B78; continue 'dispatch;
	}
	// 82FC0A08: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0A0C: 83990004  lwz r28, 4(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0A10: 83580004  lwz r26, 4(r24)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0A14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC0A18: 419A0018  beq cr6, 0x82fc0a30
	if ctx.cr[6].eq {
	pc = 0x82FC0A30; continue 'dispatch;
	}
	// 82FC0A1C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC0A20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC0A24: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0A28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC0A2C: 4E800421  bctrl
	ctx.lr = 0x82FC0A30;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC0A30 => {
    //   block [0x82FC0A30..0x82FC0A70)
	// 82FC0A30: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82FC0A34: 4BF3CE2D  bl 0x82efd860
	ctx.lr = 0x82FC0A38;
	sub_82EFD860(ctx, base);
	// 82FC0A38: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC0A3C: 41820034  beq 0x82fc0a70
	if ctx.cr[0].eq {
	pc = 0x82FC0A70; continue 'dispatch;
	}
	// 82FC0A40: 3D605647  lis r11, 0x5647
	ctx.r[11].s64 = 1447493632;
	// 82FC0A44: 3D409FE1  lis r10, -0x601f
	ctx.r[10].s64 = -1612644352;
	// 82FC0A48: 616B1E89  ori r11, r11, 0x1e89
	ctx.r[11].u64 = ctx.r[11].u64 | 7817;
	// 82FC0A4C: 614A234A  ori r10, r10, 0x234a
	ctx.r[10].u64 = ctx.r[10].u64 | 9034;
	// 82FC0A50: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC0A54: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82FC0A58: A0BC0012  lhz r5, 0x12(r28)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(18 as u32) ) } as u64;
	// 82FC0A5C: 88990000  lbz r4, 0(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC0A60: 89790001  lbz r11, 1(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(1 as u32) ) } as u64;
	// 82FC0A64: 556607FE  clrlwi r6, r11, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82FC0A68: 4BFFF4F9  bl 0x82fbff60
	ctx.lr = 0x82FC0A6C;
	sub_82FBFF60(ctx, base);
	// 82FC0A6C: 48000008  b 0x82fc0a74
	pc = 0x82FC0A74; continue 'dispatch;
            }
            0x82FC0A70 => {
    //   block [0x82FC0A70..0x82FC0A74)
	// 82FC0A70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82FC0A74; continue 'dispatch;
            }
            0x82FC0A74 => {
    //   block [0x82FC0A74..0x82FC0A9C)
	// 82FC0A74: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82FC0A78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC0A7C: 419A00D4  beq cr6, 0x82fc0b50
	if ctx.cr[6].eq {
	pc = 0x82FC0B50; continue 'dispatch;
	}
	// 82FC0A80: A1630012  lhz r11, 0x12(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(18 as u32) ) } as u64;
	// 82FC0A84: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82FC0A88: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC0A8C: 418200C4  beq 0x82fc0b50
	if ctx.cr[0].eq {
	pc = 0x82FC0B50; continue 'dispatch;
	}
	// 82FC0A90: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC0A94: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82FC0A98: C3CB0BFC  lfs f30, 0xbfc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x82FC0A9C; continue 'dispatch;
            }
            0x82FC0A9C => {
    //   block [0x82FC0A9C..0x82FC0B50)
	// 82FC0A9C: 815C0014  lwz r10, 0x14(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC0AA0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82FC0AA4: 817A0014  lwz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC0AA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FC0AAC: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0AB0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82FC0AB4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82FC0AB8: 7D5F50AE  lbzx r10, r31, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FC0ABC: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FC0AC0: 81290014  lwz r9, 0x14(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC0AC4: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 82FC0AC8: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 82FC0ACC: C9A10068  lfd f13, 0x68(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82FC0AD0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82FC0AD4: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82FC0AD8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82FC0ADC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC0AE0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC0AE4: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82FC0AE8: EC0D07FA  fmadds f0, f13, f31, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FC0AEC: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82FC0AF0: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82FC0AF4: D8010070  stfd f0, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[0].u64 ) };
	// 82FC0AF8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82FC0AFC: 7D69F9AE  stbx r11, r9, r31
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u8) };
	// 82FC0B00: 817A0014  lwz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC0B04: 815C0014  lwz r10, 0x14(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC0B08: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82FC0B0C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0B10: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 82FC0B14: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0B18: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82FC0B1C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0B20: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82FC0B24: 81690014  lwz r11, 0x14(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC0B28: 7F6BFA14  add r27, r11, r31
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82FC0B2C: 4BFF90CD  bl 0x82fb9bf8
	ctx.lr = 0x82FC0B30;
	sub_82FB9BF8(ctx, base);
	// 82FC0B30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC0B34: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82FC0B38: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82FC0B3C: 917B0004  stw r11, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC0B40: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0B44: A16B0012  lhz r11, 0x12(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82FC0B48: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC0B4C: 4198FF50  blt cr6, 0x82fc0a9c
	if ctx.cr[6].lt {
	pc = 0x82FC0A9C; continue 'dispatch;
	}
	pc = 0x82FC0B50; continue 'dispatch;
            }
            0x82FC0B50 => {
    //   block [0x82FC0B50..0x82FC0B78)
	// 82FC0B50: C01C0018  lfs f0, 0x18(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC0B54: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0B58: C1BA0018  lfs f13, 0x18(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC0B5C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC0B60: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82FC0B64: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82FC0B68: EC0D07FA  fmadds f0, f13, f31, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FC0B6C: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82FC0B70: 4BF8C4B9  bl 0x82f4d028
	ctx.lr = 0x82FC0B74;
	sub_82F4D028(ctx, base);
	// 82FC0B74: 48000018  b 0x82fc0b8c
	pc = 0x82FC0B8C; continue 'dispatch;
            }
            0x82FC0B78 => {
    //   block [0x82FC0B78..0x82FC0B8C)
	// 82FC0B78: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC0B7C: 41820010  beq 0x82fc0b8c
	if ctx.cr[0].eq {
	pc = 0x82FC0B8C; continue 'dispatch;
	}
	// 82FC0B80: 38990008  addi r4, r25, 8
	ctx.r[4].s64 = ctx.r[25].s64 + 8;
	// 82FC0B84: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 82FC0B88: 4BF3EA71  bl 0x82eff5f8
	ctx.lr = 0x82FC0B8C;
	sub_82EFF5F8(ctx, base);
	pc = 0x82FC0B8C; continue 'dispatch;
            }
            0x82FC0B8C => {
    //   block [0x82FC0B8C..0x82FC0BA0)
	// 82FC0B8C: 38B80010  addi r5, r24, 0x10
	ctx.r[5].s64 = ctx.r[24].s64 + 16;
	// 82FC0B90: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82FC0B94: 38990010  addi r4, r25, 0x10
	ctx.r[4].s64 = ctx.r[25].s64 + 16;
	// 82FC0B98: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 82FC0B9C: 4BFABF15  bl 0x82f6cab0
	ctx.lr = 0x82FC0BA0;
	sub_82F6CAB0(ctx, base);
	pc = 0x82FC0BA0; continue 'dispatch;
            }
            0x82FC0BA0 => {
    //   block [0x82FC0BA0..0x82FC0BB0)
	// 82FC0BA0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82FC0BA4: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82FC0BA8: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82FC0BAC: 4BCE889C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC0BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC0BB0 size=76
    let mut pc: u32 = 0x82FC0BB0;
    'dispatch: loop {
        match pc {
            0x82FC0BB0 => {
    //   block [0x82FC0BB0..0x82FC0BE0)
	// 82FC0BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC0BB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC0BB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC0BBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC0BC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC0BC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC0BC8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC0BCC: 4BFFF2AD  bl 0x82fbfe78
	ctx.lr = 0x82FC0BD0;
	sub_82FBFE78(ctx, base);
	// 82FC0BD0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC0BD4: 4182000C  beq 0x82fc0be0
	if ctx.cr[0].eq {
	pc = 0x82FC0BE0; continue 'dispatch;
	}
	// 82FC0BD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC0BDC: 4B884BD5  bl 0x828457b0
	ctx.lr = 0x82FC0BE0;
	sub_828457B0(ctx, base);
	pc = 0x82FC0BE0; continue 'dispatch;
            }
            0x82FC0BE0 => {
    //   block [0x82FC0BE0..0x82FC0BFC)
	// 82FC0BE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC0BE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC0BE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC0BEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC0BF0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC0BF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC0BF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC0C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC0C00 size=176
    let mut pc: u32 = 0x82FC0C00;
    'dispatch: loop {
        match pc {
            0x82FC0C00 => {
    //   block [0x82FC0C00..0x82FC0C58)
	// 82FC0C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC0C04: 4BCE8805  bl 0x82ca9408
	ctx.lr = 0x82FC0C08;
	sub_82CA93D0(ctx, base);
	// 82FC0C08: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC0C0C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82FC0C10: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC0C14: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82FC0C18: A17D0004  lhz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0C1C: B17E0004  sth r11, 4(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 82FC0C20: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC0C24: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC0C28: A17D0010  lhz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC0C2C: B17E0010  sth r11, 0x10(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 82FC0C30: C01D0014  lfs f0, 0x14(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC0C34: 83FE000C  lwz r31, 0xc(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC0C38: D01E0014  stfs f0, 0x14(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82FC0C3C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82FC0C40: 419A0018  beq cr6, 0x82fc0c58
	if ctx.cr[6].eq {
	pc = 0x82FC0C58; continue 'dispatch;
	}
	// 82FC0C44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC0C48: 4BFFECF9  bl 0x82fbf940
	ctx.lr = 0x82FC0C4C;
	sub_82FBF940(ctx, base);
	// 82FC0C4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC0C50: 4BF3CC51  bl 0x82efd8a0
	ctx.lr = 0x82FC0C54;
	sub_82EFD8A0(ctx, base);
	// 82FC0C54: 939E000C  stw r28, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	pc = 0x82FC0C58; continue 'dispatch;
            }
            0x82FC0C58 => {
    //   block [0x82FC0C58..0x82FC0C9C)
	// 82FC0C58: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC0C5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC0C60: 419A0044  beq cr6, 0x82fc0ca4
	if ctx.cr[6].eq {
	pc = 0x82FC0CA4; continue 'dispatch;
	}
	// 82FC0C64: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82FC0C68: 4BF3CBF9  bl 0x82efd860
	ctx.lr = 0x82FC0C6C;
	sub_82EFD860(ctx, base);
	// 82FC0C6C: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82FC0C70: 4182002C  beq 0x82fc0c9c
	if ctx.cr[0].eq {
	pc = 0x82FC0C9C; continue 'dispatch;
	}
	// 82FC0C74: 83BD000C  lwz r29, 0xc(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC0C78: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82FC0C7C: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82FC0C80: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82FC0C84: 4BFABCF5  bl 0x82f6c978
	ctx.lr = 0x82FC0C88;
	sub_82F6C978(ctx, base);
	// 82FC0C88: 9B9F0000  stb r28, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u8 ) };
	// 82FC0C8C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC0C90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC0C94: 4BFFF035  bl 0x82fbfcc8
	ctx.lr = 0x82FC0C98;
	sub_82FBFCC8(ctx, base);
	// 82FC0C98: 48000008  b 0x82fc0ca0
	pc = 0x82FC0CA0; continue 'dispatch;
            }
            0x82FC0C9C => {
    //   block [0x82FC0C9C..0x82FC0CA0)
	// 82FC0C9C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	pc = 0x82FC0CA0; continue 'dispatch;
            }
            0x82FC0CA0 => {
    //   block [0x82FC0CA0..0x82FC0CA4)
	// 82FC0CA0: 93FE000C  stw r31, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	pc = 0x82FC0CA4; continue 'dispatch;
            }
            0x82FC0CA4 => {
    //   block [0x82FC0CA4..0x82FC0CB0)
	// 82FC0CA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC0CA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC0CAC: 4BCE87AC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC0CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC0CB0 size=120
    let mut pc: u32 = 0x82FC0CB0;
    'dispatch: loop {
        match pc {
            0x82FC0CB0 => {
    //   block [0x82FC0CB0..0x82FC0CE0)
	// 82FC0CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC0CB4: 4BCE8755  bl 0x82ca9408
	ctx.lr = 0x82FC0CB8;
	sub_82CA93D0(ctx, base);
	// 82FC0CB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC0CBC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82FC0CC0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82FC0CC4: 83FC000C  lwz r31, 0xc(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC0CC8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82FC0CCC: 419A0014  beq cr6, 0x82fc0ce0
	if ctx.cr[6].eq {
	pc = 0x82FC0CE0; continue 'dispatch;
	}
	// 82FC0CD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC0CD4: 4BFFEC6D  bl 0x82fbf940
	ctx.lr = 0x82FC0CD8;
	sub_82FBF940(ctx, base);
	// 82FC0CD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC0CDC: 4BF3CBC5  bl 0x82efd8a0
	ctx.lr = 0x82FC0CE0;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC0CE0; continue 'dispatch;
            }
            0x82FC0CE0 => {
    //   block [0x82FC0CE0..0x82FC0D18)
	// 82FC0CE0: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82FC0CE4: 4BF3CB7D  bl 0x82efd860
	ctx.lr = 0x82FC0CE8;
	sub_82EFD860(ctx, base);
	// 82FC0CE8: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82FC0CEC: 4182002C  beq 0x82fc0d18
	if ctx.cr[0].eq {
	pc = 0x82FC0D18; continue 'dispatch;
	}
	// 82FC0CF0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82FC0CF4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82FC0CF8: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82FC0CFC: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82FC0D00: 4BFABC79  bl 0x82f6c978
	ctx.lr = 0x82FC0D04;
	sub_82F6C978(ctx, base);
	// 82FC0D04: 9BDF0000  stb r30, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u8 ) };
	// 82FC0D08: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC0D0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC0D10: 4BFFEFB9  bl 0x82fbfcc8
	ctx.lr = 0x82FC0D14;
	sub_82FBFCC8(ctx, base);
	// 82FC0D14: 48000008  b 0x82fc0d1c
	pc = 0x82FC0D1C; continue 'dispatch;
            }
            0x82FC0D18 => {
    //   block [0x82FC0D18..0x82FC0D1C)
	// 82FC0D18: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82FC0D1C; continue 'dispatch;
            }
            0x82FC0D1C => {
    //   block [0x82FC0D1C..0x82FC0D28)
	// 82FC0D1C: 93FC000C  stw r31, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82FC0D20: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC0D24: 4BCE8734  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC0D28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC0D28 size=296
    let mut pc: u32 = 0x82FC0D28;
    'dispatch: loop {
        match pc {
            0x82FC0D28 => {
    //   block [0x82FC0D28..0x82FC0D9C)
	// 82FC0D28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC0D2C: 4BCE86DD  bl 0x82ca9408
	ctx.lr = 0x82FC0D30;
	sub_82CA93D0(ctx, base);
	// 82FC0D30: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC0D34: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC0D38: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82FC0D3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC0D40: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82FC0D44: 4BF3EACD  bl 0x82eff810
	ctx.lr = 0x82FC0D48;
	sub_82EFF810(ctx, base);
	// 82FC0D48: B07D0004  sth r3, 4(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u16 ) };
	// 82FC0D4C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82FC0D50: 2F1C0053  cmpwi cr6, r28, 0x53
	ctx.cr[6].compare_i32(ctx.r[28].s32, 83, &mut ctx.xer);
	// 82FC0D54: 409A0048  bne cr6, 0x82fc0d9c
	if !ctx.cr[6].eq {
	pc = 0x82FC0D9C; continue 'dispatch;
	}
	// 82FC0D58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC0D5C: 4BF3EAB5  bl 0x82eff810
	ctx.lr = 0x82FC0D60;
	sub_82EFF810(ctx, base);
	// 82FC0D60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC0D64: 57EB06B5  rlwinm. r11, r31, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC0D68: B3FD0010  sth r31, 0x10(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[31].u16 ) };
	// 82FC0D6C: 41820030  beq 0x82fc0d9c
	if ctx.cr[0].eq {
	pc = 0x82FC0D9C; continue 'dispatch;
	}
	// 82FC0D70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC0D74: 4BF3EA9D  bl 0x82eff810
	ctx.lr = 0x82FC0D78;
	sub_82EFF810(ctx, base);
	// 82FC0D78: 546B043E  clrlwi r11, r3, 0x10
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 82FC0D7C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC0D80: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82FC0D84: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FC0D88: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC0D8C: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC0D90: C00A0A90  lfs f0, 0xa90(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2704 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC0D94: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC0D98: D01D0014  stfs f0, 0x14(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	pc = 0x82FC0D9C; continue 'dispatch;
            }
            0x82FC0D9C => {
    //   block [0x82FC0D9C..0x82FC0DC4)
	// 82FC0D9C: 57EB0739  rlwinm. r11, r31, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC0DA0: 41820098  beq 0x82fc0e38
	if ctx.cr[0].eq {
	pc = 0x82FC0E38; continue 'dispatch;
	}
	// 82FC0DA4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82FC0DA8: 4BFFEEC9  bl 0x82fbfc70
	ctx.lr = 0x82FC0DAC;
	sub_82FBFC70(ctx, base);
	// 82FC0DAC: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 82FC0DB0: 4BF3CAB1  bl 0x82efd860
	ctx.lr = 0x82FC0DB4;
	sub_82EFD860(ctx, base);
	// 82FC0DB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC0DB8: 4182000C  beq 0x82fc0dc4
	if ctx.cr[0].eq {
	pc = 0x82FC0DC4; continue 'dispatch;
	}
	// 82FC0DBC: 4BFFEEB5  bl 0x82fbfc70
	ctx.lr = 0x82FC0DC0;
	sub_82FBFC70(ctx, base);
	// 82FC0DC0: 48000008  b 0x82fc0dc8
	pc = 0x82FC0DC8; continue 'dispatch;
            }
            0x82FC0DC4 => {
    //   block [0x82FC0DC4..0x82FC0DC8)
	// 82FC0DC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82FC0DC8; continue 'dispatch;
            }
            0x82FC0DC8 => {
    //   block [0x82FC0DC8..0x82FC0DDC)
	// 82FC0DC8: 907D000C  stw r3, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82FC0DCC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC0DD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC0DD4: 409A0008  bne cr6, 0x82fc0ddc
	if !ctx.cr[6].eq {
	pc = 0x82FC0DDC; continue 'dispatch;
	}
	// 82FC0DD8: 3BE10060  addi r31, r1, 0x60
	ctx.r[31].s64 = ctx.r[1].s64 + 96;
	pc = 0x82FC0DDC; continue 'dispatch;
            }
            0x82FC0DDC => {
    //   block [0x82FC0DDC..0x82FC0E00)
	// 82FC0DDC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82FC0DE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC0DE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC0DE8: 4BFFF801  bl 0x82fc05e8
	ctx.lr = 0x82FC0DEC;
	sub_82FC05E8(ctx, base);
	// 82FC0DEC: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC0DF0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC0DF4: 4082000C  bne 0x82fc0e00
	if !ctx.cr[0].eq {
	pc = 0x82FC0E00; continue 'dispatch;
	}
	// 82FC0DF8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0DFC: 4800002C  b 0x82fc0e28
	pc = 0x82FC0E28; continue 'dispatch;
            }
            0x82FC0E00 => {
    //   block [0x82FC0E00..0x82FC0E28)
	// 82FC0E00: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC0E04: 41820028  beq 0x82fc0e2c
	if ctx.cr[0].eq {
	pc = 0x82FC0E2C; continue 'dispatch;
	}
	// 82FC0E08: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC0E0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC0E10: 419A001C  beq cr6, 0x82fc0e2c
	if ctx.cr[6].eq {
	pc = 0x82FC0E2C; continue 'dispatch;
	}
	// 82FC0E14: A14B0012  lhz r10, 0x12(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 82FC0E18: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC0E1C: 41820010  beq 0x82fc0e2c
	if ctx.cr[0].eq {
	pc = 0x82FC0E2C; continue 'dispatch;
	}
	// 82FC0E20: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC0E24: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82FC0E28; continue 'dispatch;
            }
            0x82FC0E28 => {
    //   block [0x82FC0E28..0x82FC0E2C)
	// 82FC0E28: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82FC0E2C; continue 'dispatch;
            }
            0x82FC0E2C => {
    //   block [0x82FC0E2C..0x82FC0E38)
	// 82FC0E2C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82FC0E30: 4BFFEB11  bl 0x82fbf940
	ctx.lr = 0x82FC0E34;
	sub_82FBF940(ctx, base);
	// 82FC0E34: 48000014  b 0x82fc0e48
	pc = 0x82FC0E48; continue 'dispatch;
            }
            0x82FC0E38 => {
    //   block [0x82FC0E38..0x82FC0E48)
	// 82FC0E38: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82FC0E3C: 389D0008  addi r4, r29, 8
	ctx.r[4].s64 = ctx.r[29].s64 + 8;
	// 82FC0E40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC0E44: 4BF84665  bl 0x82f454a8
	ctx.lr = 0x82FC0E48;
	sub_82F454A8(ctx, base);
	pc = 0x82FC0E48; continue 'dispatch;
            }
            0x82FC0E48 => {
    //   block [0x82FC0E48..0x82FC0E50)
	// 82FC0E48: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82FC0E4C: 4BCE860C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC0E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC0E50 size=1344
    let mut pc: u32 = 0x82FC0E50;
    'dispatch: loop {
        match pc {
            0x82FC0E50 => {
    //   block [0x82FC0E50..0x82FC0E90)
	// 82FC0E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC0E54: 4BCE85AD  bl 0x82ca9400
	ctx.lr = 0x82FC0E58;
	sub_82CA93D0(ctx, base);
	// 82FC0E58: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82FC0E5C: 4BCECE69  bl 0x82cadcc4
	ctx.lr = 0x82FC0E60;
	sub_82CADCA0(ctx, base);
	// 82FC0E60: 9421FAF0  stwu r1, -0x510(r1)
	ea = ctx.r[1].u32.wrapping_add(-1296 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC0E64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC0E68: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC0E6C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82FC0E70: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82FC0E74: 895E0010  lbz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC0E78: C3CB0C14  lfs f30, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82FC0E7C: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC0E80: 41820010  beq 0x82fc0e90
	if ctx.cr[0].eq {
	pc = 0x82FC0E90; continue 'dispatch;
	}
	// 82FC0E84: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FC0E88: C02B68BC  lfs f1, 0x68bc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26812 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC0E8C: 48000008  b 0x82fc0e94
	pc = 0x82FC0E94; continue 'dispatch;
            }
            0x82FC0E90 => {
    //   block [0x82FC0E90..0x82FC0E94)
	// 82FC0E90: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	pc = 0x82FC0E94; continue 'dispatch;
            }
            0x82FC0E94 => {
    //   block [0x82FC0E94..0x82FC0F58)
	// 82FC0E94: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82FC0E98: A0BE0012  lhz r5, 0x12(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 82FC0E9C: 809E0014  lwz r4, 0x14(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC0EA0: 4BFFF441  bl 0x82fc02e0
	ctx.lr = 0x82FC0EA4;
	sub_82FC02E0(ctx, base);
	// 82FC0EA4: 897E0011  lbz r11, 0x11(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(17 as u32) ) } as u64;
	// 82FC0EA8: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 82FC0EAC: 419A0444  beq cr6, 0x82fc12f0
	if ctx.cr[6].eq {
	pc = 0x82FC12F0; continue 'dispatch;
	}
	// 82FC0EB0: 2F0B0012  cmpwi cr6, r11, 0x12
	ctx.cr[6].compare_i32(ctx.r[11].s32, 18, &mut ctx.xer);
	// 82FC0EB4: 419A0254  beq cr6, 0x82fc1108
	if ctx.cr[6].eq {
	pc = 0x82FC1108; continue 'dispatch;
	}
	// 82FC0EB8: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 82FC0EBC: 409A04C0  bne cr6, 0x82fc137c
	if !ctx.cr[6].eq {
	pc = 0x82FC137C; continue 'dispatch;
	}
	// 82FC0EC0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC0EC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC0EC8: 4BFFE829  bl 0x82fbf6f0
	ctx.lr = 0x82FC0ECC;
	sub_82FBF6F0(ctx, base);
	// 82FC0ECC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82FC0ED0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82FC0ED4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82FC0ED8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82FC0EDC: 4BF451A5  bl 0x82f06080
	ctx.lr = 0x82FC0EE0;
	sub_82F06080(ctx, base);
	// 82FC0EE0: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82FC0EE4: 41820498  beq 0x82fc137c
	if ctx.cr[0].eq {
	pc = 0x82FC137C; continue 'dispatch;
	}
	// 82FC0EE8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC0EEC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC0EF0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82FC0EF4: C1BE0018  lfs f13, 0x18(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC0EF8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82FC0EFC: 3B9BFFFF  addi r28, r27, -1
	ctx.r[28].s64 = ctx.r[27].s64 + -1;
	// 82FC0F00: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82FC0F04: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FC0F08: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC0F0C: C3EA0BFC  lfs f31, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82FC0F10: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC0F14: C0090C18  lfs f0, 0xc18(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC0F18: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82FC0F1C: EF8C07F2  fmuls f28, f12, f31
	ctx.f[28].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 82FC0F20: ED1CF028  fsubs f8, f28, f30
	ctx.f[8].f64 = (((ctx.f[28].f64 - ctx.f[30].f64) as f32) as f64);
	// 82FC0F24: D1010070  stfs f8, 0x70(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82FC0F28: EC0D0232  fmuls f0, f13, f8
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[8].f64) as f32) as f64);
	// 82FC0F2C: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82FC0F30: 4BFFE6B9  bl 0x82fbf5e8
	ctx.lr = 0x82FC0F34;
	sub_82FBF5E8(ctx, base);
	// 82FC0F34: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82FC0F38: 2B1C0001  cmplwi cr6, r28, 1
	ctx.cr[6].compare_u32(ctx.r[28].u32, 1 as u32, &mut ctx.xer);
	// 82FC0F3C: 40990124  ble cr6, 0x82fc1060
	if !ctx.cr[6].gt {
	pc = 0x82FC1060; continue 'dispatch;
	}
	// 82FC0F40: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC0F44: EEFE4024  fdivs f23, f30, f8
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[23].f64 = ((ctx.f[30].f64 / ctx.f[8].f64) as f32) as f64;
	// 82FC0F48: C3A10078  lfs f29, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82FC0F4C: 3B5F0010  addi r26, r31, 0x10
	ctx.r[26].s64 = ctx.r[31].s64 + 16;
	// 82FC0F50: C3C10074  lfs f30, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82FC0F54: C30B0AE0  lfs f24, 0xae0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2784 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	pc = 0x82FC0F58; continue 'dispatch;
            }
            0x82FC0F58 => {
    //   block [0x82FC0F58..0x82FC0F88)
	// 82FC0F58: 7BAB0020  clrldi r11, r29, 0x20
	ctx.r[11].u64 = ctx.r[29].u64 & 0x00000000FFFFFFFFu64;
	// 82FC0F5C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82FC0F60: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82FC0F64: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82FC0F68: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC0F6C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC0F70: EC00E028  fsubs f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 82FC0F74: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82FC0F78: EC00E828  fsubs f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 82FC0F7C: EF7E0032  fmuls f27, f30, f0
	ctx.f[27].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC0F80: EF400032  fmuls f26, f0, f0
	ctx.f[26].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC0F84: EF3D0032  fmuls f25, f29, f0
	ctx.f[25].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82FC0F88; continue 'dispatch;
            }
            0x82FC0F88 => {
    //   block [0x82FC0F88..0x82FC0FFC)
	// 82FC0F88: 7BCB0020  clrldi r11, r30, 0x20
	ctx.r[11].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 82FC0F8C: C001007C  lfs f0, 0x7c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC0F90: C1A10080  lfs f13, 0x80(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC0F94: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82FC0F98: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82FC0F9C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82FC0FA0: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82FC0FA4: ED8CE028  fsubs f12, f12, f28
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[28].f64) as f32) as f64);
	// 82FC0FA8: ED8CF82A  fadds f12, f12, f31
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[31].f64) as f32) as f64;
	// 82FC0FAC: ED8CF028  fsubs f12, f12, f30
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[30].f64) as f32) as f64);
	// 82FC0FB0: ED7DDB38  fmsubs f11, f29, f12, f27
	ctx.f[11].f64 = (((ctx.f[29].f64 * ctx.f[12].f64 - ctx.f[27].f64) as f32) as f64);
	// 82FC0FB4: ED4CD33A  fmadds f10, f12, f12, f26
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[26].f64) as f32) as f64);
	// 82FC0FB8: ED6B02F2  fmuls f11, f11, f11
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82FC0FBC: EC0A5838  fmsubs f0, f10, f0, f11
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 82FC0FC0: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82FC0FC4: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82FC0FC8: EC1E033A  fmadds f0, f30, f12, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FC0FCC: EC00C82A  fadds f0, f0, f25
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[25].f64) as f32) as f64;
	// 82FC0FD0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FC0FD4: EC0005F2  fmuls f0, f0, f23
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[23].f64) as f32) as f64);
	// 82FC0FD8: EC20FE3A  fmadds f1, f0, f24, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[24].f64 + ctx.f[31].f64) as f32) as f64);
	// 82FC0FDC: 4B26B3B5  bl 0x8222c390
	ctx.lr = 0x82FC0FE0;
	sub_8222C390(ctx, base);
	// 82FC0FE0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FC0FE4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82FC0FE8: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FC0FEC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC0FF0: 2F0B00FF  cmpwi cr6, r11, 0xff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 255, &mut ctx.xer);
	// 82FC0FF4: 40990008  ble cr6, 0x82fc0ffc
	if !ctx.cr[6].gt {
	pc = 0x82FC0FFC; continue 'dispatch;
	}
	// 82FC0FF8: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	pc = 0x82FC0FFC; continue 'dispatch;
            }
            0x82FC0FFC => {
    //   block [0x82FC0FFC..0x82FC1008)
	// 82FC0FFC: 2B0B0100  cmplwi cr6, r11, 0x100
	ctx.cr[6].compare_u32(ctx.r[11].u32, 256 as u32, &mut ctx.xer);
	// 82FC1000: 41980008  blt cr6, 0x82fc1008
	if ctx.cr[6].lt {
	pc = 0x82FC1008; continue 'dispatch;
	}
	// 82FC1004: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	pc = 0x82FC1008; continue 'dispatch;
            }
            0x82FC1008 => {
    //   block [0x82FC1008..0x82FC1060)
	// 82FC1008: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC100C: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82FC1010: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82FC1014: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC1018: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82FC101C: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FC1020: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82FC1024: 89610052  lbz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82FC1028: 89210050  lbz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC102C: 89410053  lbz r10, 0x53(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(83 as u32) ) } as u64;
	// 82FC1030: 512A442E  rlwimi r10, r9, 8, 0x10, 0x17
	ctx.r[10].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[10].u64 & 0xFFFFFFFFFFFF00FF);
	// 82FC1034: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82FC1038: 88C10051  lbz r6, 0x51(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82FC103C: 514B402E  rlwimi r11, r10, 8, 0, 0x17
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[11].u64 & 0xFFFFFFFF000000FF);
	// 82FC1040: 5166402E  rlwimi r6, r11, 8, 0, 0x17
	ctx.r[6].u64 = (((ctx.r[11].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[6].u64 & 0xFFFFFFFF000000FF);
	// 82FC1044: 4BF442BD  bl 0x82f05300
	ctx.lr = 0x82FC1048;
	sub_82F05300(ctx, base);
	// 82FC1048: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82FC104C: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82FC1050: 4198FF38  blt cr6, 0x82fc0f88
	if ctx.cr[6].lt {
	pc = 0x82FC0F88; continue 'dispatch;
	}
	// 82FC1054: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82FC1058: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82FC105C: 4198FEFC  blt cr6, 0x82fc0f58
	if ctx.cr[6].lt {
	pc = 0x82FC0F58; continue 'dispatch;
	}
	pc = 0x82FC1060; continue 'dispatch;
            }
            0x82FC1060 => {
    //   block [0x82FC1060..0x82FC1090)
	// 82FC1060: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82FC1064: 2B1B0001  cmplwi cr6, r27, 1
	ctx.cr[6].compare_u32(ctx.r[27].u32, 1 as u32, &mut ctx.xer);
	// 82FC1068: 40990314  ble cr6, 0x82fc137c
	if !ctx.cr[6].gt {
	pc = 0x82FC137C; continue 'dispatch;
	}
	// 82FC106C: 8961048F  lbz r11, 0x48f(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(1167 as u32) ) } as u64;
	// 82FC1070: 3B9F0010  addi r28, r31, 0x10
	ctx.r[28].s64 = ctx.r[31].s64 + 16;
	// 82FC1074: 8941048C  lbz r10, 0x48c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(1164 as u32) ) } as u64;
	// 82FC1078: 8921048E  lbz r9, 0x48e(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(1166 as u32) ) } as u64;
	// 82FC107C: 514B442E  rlwimi r11, r10, 8, 0x10, 0x17
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[11].u64 & 0xFFFFFFFFFFFF00FF);
	// 82FC1080: 8BA1048D  lbz r29, 0x48d(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(1165 as u32) ) } as u64;
	// 82FC1084: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82FC1088: 5169402E  rlwimi r9, r11, 8, 0, 0x17
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[9].u64 & 0xFFFFFFFF000000FF);
	// 82FC108C: 513D402E  rlwimi r29, r9, 8, 0, 0x17
	ctx.r[29].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[29].u64 & 0xFFFFFFFF000000FF);
	pc = 0x82FC1090; continue 'dispatch;
            }
            0x82FC1090 => {
    //   block [0x82FC1090..0x82FC1108)
	// 82FC1090: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82FC1094: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82FC1098: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC109C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC10A0: 4BF44261  bl 0x82f05300
	ctx.lr = 0x82FC10A4;
	sub_82F05300(ctx, base);
	// 82FC10A4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC10A8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82FC10AC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82FC10B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC10B4: 388BFFFF  addi r4, r11, -1
	ctx.r[4].s64 = ctx.r[11].s64 + -1;
	// 82FC10B8: 4BF44249  bl 0x82f05300
	ctx.lr = 0x82FC10BC;
	sub_82F05300(ctx, base);
	// 82FC10BC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC10C0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82FC10C4: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 82FC10C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC10CC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC10D0: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82FC10D4: 388AFFFF  addi r4, r10, -1
	ctx.r[4].s64 = ctx.r[10].s64 + -1;
	// 82FC10D8: 4BF44229  bl 0x82f05300
	ctx.lr = 0x82FC10DC;
	sub_82F05300(ctx, base);
	// 82FC10DC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC10E0: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82FC10E4: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82FC10E8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC10EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC10F0: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 82FC10F4: 4BF4420D  bl 0x82f05300
	ctx.lr = 0x82FC10F8;
	sub_82F05300(ctx, base);
	// 82FC10F8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82FC10FC: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82FC1100: 4198FF90  blt cr6, 0x82fc1090
	if ctx.cr[6].lt {
	pc = 0x82FC1090; continue 'dispatch;
	}
	// 82FC1104: 48000278  b 0x82fc137c
	pc = 0x82FC137C; continue 'dispatch;
            }
            0x82FC1108 => {
    //   block [0x82FC1108..0x82FC1174)
	// 82FC1108: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC110C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC1110: 4BFFE5E1  bl 0x82fbf6f0
	ctx.lr = 0x82FC1114;
	sub_82FBF6F0(ctx, base);
	// 82FC1114: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82FC1118: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82FC111C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82FC1120: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82FC1124: 4BF44F5D  bl 0x82f06080
	ctx.lr = 0x82FC1128;
	sub_82F06080(ctx, base);
	// 82FC1128: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82FC112C: 41820250  beq 0x82fc137c
	if ctx.cr[0].eq {
	pc = 0x82FC137C; continue 'dispatch;
	}
	// 82FC1130: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC1134: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC1138: 3B9BFFFF  addi r28, r27, -1
	ctx.r[28].s64 = ctx.r[27].s64 + -1;
	// 82FC113C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82FC1140: 2B1C0001  cmplwi cr6, r28, 1
	ctx.cr[6].compare_u32(ctx.r[28].u32, 1 as u32, &mut ctx.xer);
	// 82FC1144: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82FC1148: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82FC114C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC1150: C3EA0BFC  lfs f31, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82FC1154: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC1158: EFA007F2  fmuls f29, f0, f31
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82FC115C: EC1DF028  fsubs f0, f29, f30
	ctx.f[0].f64 = (((ctx.f[29].f64 - ctx.f[30].f64) as f32) as f64);
	// 82FC1160: 409900E8  ble cr6, 0x82fc1248
	if !ctx.cr[6].gt {
	pc = 0x82FC1248; continue 'dispatch;
	}
	// 82FC1164: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC1168: EF9E0024  fdivs f28, f30, f0
	ctx.f[28].f64 = ((ctx.f[30].f64 / ctx.f[0].f64) as f32) as f64;
	// 82FC116C: 3B5F0010  addi r26, r31, 0x10
	ctx.r[26].s64 = ctx.r[31].s64 + 16;
	// 82FC1170: C36B0AE0  lfs f27, 0xae0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2784 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	pc = 0x82FC1174; continue 'dispatch;
            }
            0x82FC1174 => {
    //   block [0x82FC1174..0x82FC1198)
	// 82FC1174: 7BAB0020  clrldi r11, r29, 0x20
	ctx.r[11].u64 = ctx.r[29].u64 & 0x00000000FFFFFFFFu64;
	// 82FC1178: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82FC117C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82FC1180: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82FC1184: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC1188: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC118C: EC00E828  fsubs f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 82FC1190: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82FC1194: EFC00032  fmuls f30, f0, f0
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82FC1198; continue 'dispatch;
            }
            0x82FC1198 => {
    //   block [0x82FC1198..0x82FC11E4)
	// 82FC1198: 7BCB0020  clrldi r11, r30, 0x20
	ctx.r[11].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 82FC119C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82FC11A0: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82FC11A4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC11A8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC11AC: EC00E828  fsubs f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 82FC11B0: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82FC11B4: EC00F03A  fmadds f0, f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64);
	// 82FC11B8: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82FC11BC: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82FC11C0: EC20FEFA  fmadds f1, f0, f27, f31
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[27].f64 + ctx.f[31].f64) as f32) as f64);
	// 82FC11C4: 4B26B1CD  bl 0x8222c390
	ctx.lr = 0x82FC11C8;
	sub_8222C390(ctx, base);
	// 82FC11C8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FC11CC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82FC11D0: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FC11D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC11D8: 2F0B00FF  cmpwi cr6, r11, 0xff
	ctx.cr[6].compare_i32(ctx.r[11].s32, 255, &mut ctx.xer);
	// 82FC11DC: 40990008  ble cr6, 0x82fc11e4
	if !ctx.cr[6].gt {
	pc = 0x82FC11E4; continue 'dispatch;
	}
	// 82FC11E0: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	pc = 0x82FC11E4; continue 'dispatch;
            }
            0x82FC11E4 => {
    //   block [0x82FC11E4..0x82FC11F0)
	// 82FC11E4: 2B0B0100  cmplwi cr6, r11, 0x100
	ctx.cr[6].compare_u32(ctx.r[11].u32, 256 as u32, &mut ctx.xer);
	// 82FC11E8: 41980008  blt cr6, 0x82fc11f0
	if ctx.cr[6].lt {
	pc = 0x82FC11F0; continue 'dispatch;
	}
	// 82FC11EC: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	pc = 0x82FC11F0; continue 'dispatch;
            }
            0x82FC11F0 => {
    //   block [0x82FC11F0..0x82FC1248)
	// 82FC11F0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC11F4: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82FC11F8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82FC11FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC1200: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82FC1204: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FC1208: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82FC120C: 89610052  lbz r11, 0x52(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82FC1210: 88C10051  lbz r6, 0x51(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82FC1214: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC1218: 89210053  lbz r9, 0x53(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(83 as u32) ) } as u64;
	// 82FC121C: 5149442E  rlwimi r9, r10, 8, 0x10, 0x17
	ctx.r[9].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[9].u64 & 0xFFFFFFFFFFFF00FF);
	// 82FC1220: 552A043E  clrlwi r10, r9, 0x10
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 82FC1224: 514B402E  rlwimi r11, r10, 8, 0, 0x17
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[11].u64 & 0xFFFFFFFF000000FF);
	// 82FC1228: 5166402E  rlwimi r6, r11, 8, 0, 0x17
	ctx.r[6].u64 = (((ctx.r[11].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[6].u64 & 0xFFFFFFFF000000FF);
	// 82FC122C: 4BF440D5  bl 0x82f05300
	ctx.lr = 0x82FC1230;
	sub_82F05300(ctx, base);
	// 82FC1230: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82FC1234: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82FC1238: 4198FF60  blt cr6, 0x82fc1198
	if ctx.cr[6].lt {
	pc = 0x82FC1198; continue 'dispatch;
	}
	// 82FC123C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82FC1240: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82FC1244: 4198FF30  blt cr6, 0x82fc1174
	if ctx.cr[6].lt {
	pc = 0x82FC1174; continue 'dispatch;
	}
	pc = 0x82FC1248; continue 'dispatch;
            }
            0x82FC1248 => {
    //   block [0x82FC1248..0x82FC1278)
	// 82FC1248: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82FC124C: 2B1B0001  cmplwi cr6, r27, 1
	ctx.cr[6].compare_u32(ctx.r[27].u32, 1 as u32, &mut ctx.xer);
	// 82FC1250: 4099012C  ble cr6, 0x82fc137c
	if !ctx.cr[6].gt {
	pc = 0x82FC137C; continue 'dispatch;
	}
	// 82FC1254: 8961048F  lbz r11, 0x48f(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(1167 as u32) ) } as u64;
	// 82FC1258: 3B9F0010  addi r28, r31, 0x10
	ctx.r[28].s64 = ctx.r[31].s64 + 16;
	// 82FC125C: 8941048C  lbz r10, 0x48c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(1164 as u32) ) } as u64;
	// 82FC1260: 8921048E  lbz r9, 0x48e(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(1166 as u32) ) } as u64;
	// 82FC1264: 514B442E  rlwimi r11, r10, 8, 0x10, 0x17
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[11].u64 & 0xFFFFFFFFFFFF00FF);
	// 82FC1268: 8BA1048D  lbz r29, 0x48d(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(1165 as u32) ) } as u64;
	// 82FC126C: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82FC1270: 5169402E  rlwimi r9, r11, 8, 0, 0x17
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[9].u64 & 0xFFFFFFFF000000FF);
	// 82FC1274: 513D402E  rlwimi r29, r9, 8, 0, 0x17
	ctx.r[29].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[29].u64 & 0xFFFFFFFF000000FF);
	pc = 0x82FC1278; continue 'dispatch;
            }
            0x82FC1278 => {
    //   block [0x82FC1278..0x82FC12F0)
	// 82FC1278: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82FC127C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82FC1280: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC1284: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC1288: 4BF44079  bl 0x82f05300
	ctx.lr = 0x82FC128C;
	sub_82F05300(ctx, base);
	// 82FC128C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC1290: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82FC1294: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82FC1298: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC129C: 388BFFFF  addi r4, r11, -1
	ctx.r[4].s64 = ctx.r[11].s64 + -1;
	// 82FC12A0: 4BF44061  bl 0x82f05300
	ctx.lr = 0x82FC12A4;
	sub_82F05300(ctx, base);
	// 82FC12A4: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC12A8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82FC12AC: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 82FC12B0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC12B4: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC12B8: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82FC12BC: 388AFFFF  addi r4, r10, -1
	ctx.r[4].s64 = ctx.r[10].s64 + -1;
	// 82FC12C0: 4BF44041  bl 0x82f05300
	ctx.lr = 0x82FC12C4;
	sub_82F05300(ctx, base);
	// 82FC12C4: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC12C8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82FC12CC: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82FC12D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC12D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC12D8: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 82FC12DC: 4BF44025  bl 0x82f05300
	ctx.lr = 0x82FC12E0;
	sub_82F05300(ctx, base);
	// 82FC12E0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82FC12E4: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82FC12E8: 4198FF90  blt cr6, 0x82fc1278
	if ctx.cr[6].lt {
	pc = 0x82FC1278; continue 'dispatch;
	}
	// 82FC12EC: 48000090  b 0x82fc137c
	pc = 0x82FC137C; continue 'dispatch;
            }
            0x82FC12F0 => {
    //   block [0x82FC12F0..0x82FC131C)
	// 82FC12F0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82FC12F4: 38800100  li r4, 0x100
	ctx.r[4].s64 = 256;
	// 82FC12F8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82FC12FC: 4BF44D85  bl 0x82f06080
	ctx.lr = 0x82FC1300;
	sub_82F06080(ctx, base);
	// 82FC1300: 7C7F1B79  or. r31, r3, r3
	ctx.r[31].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82FC1304: 41820078  beq 0x82fc137c
	if ctx.cr[0].eq {
	pc = 0x82FC137C; continue 'dispatch;
	}
	// 82FC1308: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC130C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82FC1310: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC1314: 40990068  ble cr6, 0x82fc137c
	if !ctx.cr[6].gt {
	pc = 0x82FC137C; continue 'dispatch;
	}
	// 82FC1318: 3BBF0010  addi r29, r31, 0x10
	ctx.r[29].s64 = ctx.r[31].s64 + 16;
	pc = 0x82FC131C; continue 'dispatch;
            }
            0x82FC131C => {
    //   block [0x82FC131C..0x82FC132C)
	// 82FC131C: 2B1E0100  cmplwi cr6, r30, 0x100
	ctx.cr[6].compare_u32(ctx.r[30].u32, 256 as u32, &mut ctx.xer);
	// 82FC1320: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82FC1324: 41980008  blt cr6, 0x82fc132c
	if ctx.cr[6].lt {
	pc = 0x82FC132C; continue 'dispatch;
	}
	// 82FC1328: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	pc = 0x82FC132C; continue 'dispatch;
            }
            0x82FC132C => {
    //   block [0x82FC132C..0x82FC137C)
	// 82FC132C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC1330: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82FC1334: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82FC1338: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC133C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC1340: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FC1344: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82FC1348: 88C10051  lbz r6, 0x51(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82FC134C: 89210052  lbz r9, 0x52(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 82FC1350: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC1354: 89610053  lbz r11, 0x53(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(83 as u32) ) } as u64;
	// 82FC1358: 514B442E  rlwimi r11, r10, 8, 0x10, 0x17
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(8) as u64) & 0x000000000000FF00) | (ctx.r[11].u64 & 0xFFFFFFFFFFFF00FF);
	// 82FC135C: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82FC1360: 5169402E  rlwimi r9, r11, 8, 0, 0x17
	ctx.r[9].u64 = (((ctx.r[11].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[9].u64 & 0xFFFFFFFF000000FF);
	// 82FC1364: 5126402E  rlwimi r6, r9, 8, 0, 0x17
	ctx.r[6].u64 = (((ctx.r[9].u32).rotate_left(8) as u64) & 0x00000000FFFFFF00) | (ctx.r[6].u64 & 0xFFFFFFFF000000FF);
	// 82FC1368: 4BF43F99  bl 0x82f05300
	ctx.lr = 0x82FC136C;
	sub_82F05300(ctx, base);
	// 82FC136C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC1370: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82FC1374: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC1378: 4198FFA4  blt cr6, 0x82fc131c
	if ctx.cr[6].lt {
	pc = 0x82FC131C; continue 'dispatch;
	}
	pc = 0x82FC137C; continue 'dispatch;
            }
            0x82FC137C => {
    //   block [0x82FC137C..0x82FC1390)
	// 82FC137C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC1380: 38210510  addi r1, r1, 0x510
	ctx.r[1].s64 = ctx.r[1].s64 + 1296;
	// 82FC1384: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82FC1388: 4BCEC989  bl 0x82cadd10
	ctx.lr = 0x82FC138C;
	sub_82CADCEC(ctx, base);
	// 82FC138C: 4BCE80C4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC1390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC1390 size=440
    let mut pc: u32 = 0x82FC1390;
    'dispatch: loop {
        match pc {
            0x82FC1390 => {
    //   block [0x82FC1390..0x82FC1444)
	// 82FC1390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC1394: 4BCE8069  bl 0x82ca93fc
	ctx.lr = 0x82FC1398;
	sub_82CA93D0(ctx, base);
	// 82FC1398: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC139C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC13A0: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82FC13A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC13A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82FC13AC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82FC13B0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82FC13B4: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82FC13B8: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82FC13BC: 4BFFEC8D  bl 0x82fc0048
	ctx.lr = 0x82FC13C0;
	sub_82FC0048(ctx, base);
	// 82FC13C0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82FC13C4: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82FC13C8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82FC13CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FC13D0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82FC13D4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82FC13D8: 4BF37359  bl 0x82ef8730
	ctx.lr = 0x82FC13DC;
	sub_82EF8730(ctx, base);
	// 82FC13DC: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 82FC13E0: 409A00F8  bne cr6, 0x82fc14d8
	if !ctx.cr[6].eq {
	pc = 0x82FC14D8; continue 'dispatch;
	}
	// 82FC13E4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82FC13E8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC13EC: 4BFFFA65  bl 0x82fc0e50
	ctx.lr = 0x82FC13F0;
	sub_82FC0E50(ctx, base);
	// 82FC13F0: 7C7C1B79  or. r28, r3, r3
	ctx.r[28].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82FC13F4: 418200B0  beq 0x82fc14a4
	if ctx.cr[0].eq {
	pc = 0x82FC14A4; continue 'dispatch;
	}
	// 82FC13F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FC13FC: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 82FC1400: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82FC1404: 93610074  stw r27, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[27].u32 ) };
	// 82FC1408: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82FC140C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82FC1410: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 82FC1414: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82FC1418: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82FC141C: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 82FC1420: 9B410078  stb r26, 0x78(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[26].u8 ) };
	// 82FC1424: 419A0020  beq cr6, 0x82fc1444
	if ctx.cr[6].eq {
	pc = 0x82FC1444; continue 'dispatch;
	}
	// 82FC1428: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC142C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82FC1430: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC1434: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC1438: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC143C: 4E800421  bctrl
	ctx.lr = 0x82FC1440;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC1440: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
            }
            0x82FC1444 => {
    //   block [0x82FC1444..0x82FC1468)
	// 82FC1444: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82FC1448: 4BF3C419  bl 0x82efd860
	ctx.lr = 0x82FC144C;
	sub_82EFD860(ctx, base);
	// 82FC144C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC1450: 41820018  beq 0x82fc1468
	if ctx.cr[0].eq {
	pc = 0x82FC1468; continue 'dispatch;
	}
	// 82FC1454: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 82FC1458: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82FC145C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC1460: 4BF847D9  bl 0x82f45c38
	ctx.lr = 0x82FC1464;
	sub_82F45C38(ctx, base);
	// 82FC1464: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x82FC1468; continue 'dispatch;
            }
            0x82FC1468 => {
    //   block [0x82FC1468..0x82FC147C)
	// 82FC1468: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82FC146C: 419A0010  beq cr6, 0x82fc147c
	if ctx.cr[6].eq {
	pc = 0x82FC147C; continue 'dispatch;
	}
	// 82FC1470: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC1474: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC1478: 4BF36FB9  bl 0x82ef8430
	ctx.lr = 0x82FC147C;
	sub_82EF8430(ctx, base);
	pc = 0x82FC147C; continue 'dispatch;
            }
            0x82FC147C => {
    //   block [0x82FC147C..0x82FC149C)
	// 82FC147C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82FC1480: 419A001C  beq cr6, 0x82fc149c
	if ctx.cr[6].eq {
	pc = 0x82FC149C; continue 'dispatch;
	}
	// 82FC1484: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC1488: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC148C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC1490: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC1494: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC1498: 4E800421  bctrl
	ctx.lr = 0x82FC149C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC149C => {
    //   block [0x82FC149C..0x82FC14A4)
	// 82FC149C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82FC14A0: 409A0014  bne cr6, 0x82fc14b4
	if !ctx.cr[6].eq {
	pc = 0x82FC14B4; continue 'dispatch;
	}
	pc = 0x82FC14A4; continue 'dispatch;
            }
            0x82FC14A4 => {
    //   block [0x82FC14A4..0x82FC14B4)
	// 82FC14A4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FC14A8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC14AC: 388B68C0  addi r4, r11, 0x68c0
	ctx.r[4].s64 = ctx.r[11].s64 + 26816;
	// 82FC14B0: 4BF37011  bl 0x82ef84c0
	ctx.lr = 0x82FC14B4;
	sub_82EF84C0(ctx, base);
	pc = 0x82FC14B4; continue 'dispatch;
            }
            0x82FC14B4 => {
    //   block [0x82FC14B4..0x82FC14D8)
	// 82FC14B4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82FC14B8: 419A002C  beq cr6, 0x82fc14e4
	if ctx.cr[6].eq {
	pc = 0x82FC14E4; continue 'dispatch;
	}
	// 82FC14BC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC14C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC14C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC14C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC14CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC14D0: 4E800421  bctrl
	ctx.lr = 0x82FC14D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC14D4: 48000010  b 0x82fc14e4
	pc = 0x82FC14E4; continue 'dispatch;
            }
            0x82FC14D8 => {
    //   block [0x82FC14D8..0x82FC14E4)
	// 82FC14D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82FC14DC: 4BF369DD  bl 0x82ef7eb8
	ctx.lr = 0x82FC14E0;
	sub_82EF7EB8(ctx, base);
	// 82FC14E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x82FC14E4; continue 'dispatch;
            }
            0x82FC14E4 => {
    //   block [0x82FC14E4..0x82FC14FC)
	// 82FC14E4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC14E8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82FC14EC: 409A0010  bne cr6, 0x82fc14fc
	if !ctx.cr[6].eq {
	pc = 0x82FC14FC; continue 'dispatch;
	}
	// 82FC14F0: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC14F4: 4BF36DA5  bl 0x82ef8298
	ctx.lr = 0x82FC14F8;
	sub_82EF8298(ctx, base);
	// 82FC14F8: 48000024  b 0x82fc151c
	pc = 0x82FC151C; continue 'dispatch;
            }
            0x82FC14FC => {
    //   block [0x82FC14FC..0x82FC151C)
	// 82FC14FC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82FC1500: 4198001C  blt cr6, 0x82fc151c
	if ctx.cr[6].lt {
	pc = 0x82FC151C; continue 'dispatch;
	}
	// 82FC1504: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC1508: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC150C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC1510: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC1514: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC1518: 4E800421  bctrl
	ctx.lr = 0x82FC151C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC151C => {
    //   block [0x82FC151C..0x82FC153C)
	// 82FC151C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82FC1520: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC1524: 419A0018  beq cr6, 0x82fc153c
	if ctx.cr[6].eq {
	pc = 0x82FC153C; continue 'dispatch;
	}
	// 82FC1528: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC152C: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82FC1530: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC1534: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC1538: 4E800421  bctrl
	ctx.lr = 0x82FC153C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC153C => {
    //   block [0x82FC153C..0x82FC1548)
	// 82FC153C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC1540: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82FC1544: 4BCE7F08  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC1548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC1548 size=120
    let mut pc: u32 = 0x82FC1548;
    'dispatch: loop {
        match pc {
            0x82FC1548 => {
    //   block [0x82FC1548..0x82FC1598)
	// 82FC1548: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC154C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC1550: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC1554: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC1558: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC155C: 81660010  lwz r11, 0x10(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC1560: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82FC1564: 80E60028  lwz r7, 0x28(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC1568: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82FC156C: 8086002C  lwz r4, 0x2c(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(44 as u32) ) } as u64;
	// 82FC1570: 89060038  lbz r8, 0x38(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(56 as u32) ) } as u64;
	// 82FC1574: 80CB0018  lwz r6, 0x18(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC1578: 80AB0020  lwz r5, 0x20(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FC157C: 4BFFFE15  bl 0x82fc1390
	ctx.lr = 0x82FC1580;
	sub_82FC1390(ctx, base);
	// 82FC1580: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC1584: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC1588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC158C: 419A000C  beq cr6, 0x82fc1598
	if ctx.cr[6].eq {
	pc = 0x82FC1598; continue 'dispatch;
	}
	// 82FC1590: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82FC1594: 4BF36D05  bl 0x82ef8298
	ctx.lr = 0x82FC1598;
	sub_82EF8298(ctx, base);
	pc = 0x82FC1598; continue 'dispatch;
            }
            0x82FC1598 => {
    //   block [0x82FC1598..0x82FC15C0)
	// 82FC1598: 7FCB0034  cntlzw r11, r30
	ctx.r[11].u64 = if ctx.r[30].u32 == 0 { 32 } else { ctx.r[30].u32.leading_zeros() as u64 };
	// 82FC159C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82FC15A0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82FC15A4: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82FC15A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC15AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC15B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC15B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC15B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC15BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC15C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC15C0 size=872
    let mut pc: u32 = 0x82FC15C0;
    'dispatch: loop {
        match pc {
            0x82FC15C0 => {
    //   block [0x82FC15C0..0x82FC1660)
	// 82FC15C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC15C4: 4BCE7E39  bl 0x82ca93fc
	ctx.lr = 0x82FC15C8;
	sub_82CA93D0(ctx, base);
	// 82FC15C8: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 82FC15CC: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82FC15D0: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC15D4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82FC15D8: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82FC15DC: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82FC15E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82FC15E4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82FC15E8: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 82FC15EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC15F0: 834B0014  lwz r26, 0x14(r11)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC15F4: 4BFAB385  bl 0x82f6c978
	ctx.lr = 0x82FC15F8;
	sub_82F6C978(ctx, base);
	// 82FC15F8: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC15FC: 556A06F7  rlwinm. r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC1600: 41820204  beq 0x82fc1804
	if ctx.cr[0].eq {
	pc = 0x82FC1804; continue 'dispatch;
	}
	// 82FC1604: 3BBB0008  addi r29, r27, 8
	ctx.r[29].s64 = ctx.r[27].s64 + 8;
	// 82FC1608: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC160C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC1610: 4BF71701  bl 0x82f32d10
	ctx.lr = 0x82FC1614;
	sub_82F32D10(ctx, base);
	// 82FC1614: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82FC1618: 40820048  bne 0x82fc1660
	if !ctx.cr[0].eq {
	pc = 0x82FC1660; continue 'dispatch;
	}
	// 82FC161C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC1620: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82FC1624: 419A02F0  beq cr6, 0x82fc1914
	if ctx.cr[6].eq {
	pc = 0x82FC1914; continue 'dispatch;
	}
	// 82FC1628: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82FC162C: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC1630: 80DF000C  lwz r6, 0xc(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC1634: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC1638: 809F0018  lwz r4, 0x18(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC163C: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC1640: 4BFFFD51  bl 0x82fc1390
	ctx.lr = 0x82FC1644;
	sub_82FC1390(ctx, base);
	// 82FC1644: 7C7E1B79  or. r30, r3, r3
	ctx.r[30].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82FC1648: 418202CC  beq 0x82fc1914
	if ctx.cr[0].eq {
	pc = 0x82FC1914; continue 'dispatch;
	}
	// 82FC164C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC1650: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC1654: 4BF8B9D5  bl 0x82f4d028
	ctx.lr = 0x82FC1658;
	sub_82F4D028(ctx, base);
	// 82FC1658: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC165C: 4BF36C3D  bl 0x82ef8298
	ctx.lr = 0x82FC1660;
	sub_82EF8298(ctx, base);
	pc = 0x82FC1660; continue 'dispatch;
            }
            0x82FC1660 => {
    //   block [0x82FC1660..0x82FC1690)
	// 82FC1660: 83DE000C  lwz r30, 0xc(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC1664: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82FC1668: 419A02AC  beq cr6, 0x82fc1914
	if ctx.cr[6].eq {
	pc = 0x82FC1914; continue 'dispatch;
	}
	// 82FC166C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC1670: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82FC1674: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC1678: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC167C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC1680: 4E800421  bctrl
	ctx.lr = 0x82FC1684;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC1684: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC1688: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82FC168C: 409A000C  bne cr6, 0x82fc1698
	if !ctx.cr[6].eq {
	pc = 0x82FC1698; continue 'dispatch;
	}
            }
            0x82FC1690 => {
    //   block [0x82FC1690..0x82FC1698)
	// 82FC1690: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82FC1694: 48000284  b 0x82fc1918
	pc = 0x82FC1918; continue 'dispatch;
            }
            0x82FC1698 => {
    //   block [0x82FC1698..0x82FC1704)
	// 82FC1698: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC169C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82FC16A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC16A4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC16A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC16AC: 4E800421  bctrl
	ctx.lr = 0x82FC16B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC16B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FC16B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82FC16B8: 907C0000  stw r3, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82FC16BC: 917C0030  stw r11, 0x30(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82FC16C0: 3BFC0010  addi r31, r28, 0x10
	ctx.r[31].s64 = ctx.r[28].s64 + 16;
	// 82FC16C4: 915C0034  stw r10, 0x34(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 82FC16C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC16CC: 4BFAB2AD  bl 0x82f6c978
	ctx.lr = 0x82FC16D0;
	sub_82F6C978(ctx, base);
	// 82FC16D0: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC16D4: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 82FC16D8: 409A002C  bne cr6, 0x82fc1704
	if !ctx.cr[6].eq {
	pc = 0x82FC1704; continue 'dispatch;
	}
	// 82FC16DC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82FC16E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC16E4: C04B67A0  lfs f2, 0x67a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26528 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FC16E8: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 82FC16EC: 4BFAB1B5  bl 0x82f6c8a0
	ctx.lr = 0x82FC16F0;
	sub_82F6C8A0(ctx, base);
	// 82FC16F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82FC16F4: C1BF0008  lfs f13, 8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC16F8: C00B67A4  lfs f0, 0x67a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC16FC: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82FC1700: 4800008C  b 0x82fc178c
	pc = 0x82FC178C; continue 'dispatch;
            }
            0x82FC1704 => {
    //   block [0x82FC1704..0x82FC178C)
	// 82FC1704: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC1708: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC170C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC1710: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC1714: 4E800421  bctrl
	ctx.lr = 0x82FC1718;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC1718: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82FC171C: 3943FFFE  addi r10, r3, -2
	ctx.r[10].s64 = ctx.r[3].s64 + -2;
	// 82FC1720: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 82FC1724: 78690020  clrldi r9, r3, 0x20
	ctx.r[9].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 82FC1728: 7D6B5396  divwu r11, r11, r10
	ctx.r[11].u32 = ctx.r[11].u32 / ctx.r[10].u32;
	// 82FC172C: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82FC1730: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FC1734: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82FC1738: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82FC173C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82FC1740: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FC1744: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC1748: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC174C: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC1750: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC1754: FD606818  frsp f11, f13
	ctx.f[11].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82FC1758: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC175C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC1760: 0CCA0000  twi 6, r10, 0
	// 82FC1764: C1AB0BFC  lfs f13, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC1768: EC206024  fdivs f1, f0, f12
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 82FC176C: EFCB0372  fmuls f30, f11, f13
	ctx.f[30].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FC1770: FC400890  fmr f2, f1
	ctx.f[2].f64 = ctx.f[1].f64;
	// 82FC1774: 4BFAB12D  bl 0x82f6c8a0
	ctx.lr = 0x82FC1778;
	sub_82F6C8A0(ctx, base);
	// 82FC1778: C1BF0018  lfs f13, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC177C: C01F0008  lfs f0, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC1780: EDBE682A  fadds f13, f30, f13
	ctx.f[13].f64 = ((ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64;
	// 82FC1784: D1BF0018  stfs f13, 0x18(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82FC1788: EC1E002A  fadds f0, f30, f0
	ctx.f[0].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
            }
            0x82FC178C => {
    //   block [0x82FC178C..0x82FC17B0)
	// 82FC178C: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82FC1790: 389B0010  addi r4, r27, 0x10
	ctx.r[4].s64 = ctx.r[27].s64 + 16;
	// 82FC1794: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82FC1798: 4BFAB061  bl 0x82f6c7f8
	ctx.lr = 0x82FC179C;
	sub_82F6C7F8(ctx, base);
	// 82FC179C: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82FC17A0: 419A0010  beq cr6, 0x82fc17b0
	if ctx.cr[6].eq {
	pc = 0x82FC17B0; continue 'dispatch;
	}
	// 82FC17A4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82FC17A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82FC17AC: 4BFAB27D  bl 0x82f6ca28
	ctx.lr = 0x82FC17B0;
	sub_82F6CA28(ctx, base);
	pc = 0x82FC17B0; continue 'dispatch;
            }
            0x82FC17B0 => {
    //   block [0x82FC17B0..0x82FC1804)
	// 82FC17B0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82FC17B4: 4BFAB1C5  bl 0x82f6c978
	ctx.lr = 0x82FC17B8;
	sub_82F6C978(ctx, base);
	// 82FC17B8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82FC17BC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82FC17C0: 4BFAB459  bl 0x82f6cc18
	ctx.lr = 0x82FC17C4;
	sub_82F6CC18(ctx, base);
	// 82FC17C4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82FC17C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC17CC: 4BFAB1D5  bl 0x82f6c9a0
	ctx.lr = 0x82FC17D0;
	sub_82F6C9A0(ctx, base);
	// 82FC17D0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC17D4: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82FC17D8: FC80F890  fmr f4, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[4].f64 = ctx.f[31].f64;
	// 82FC17DC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82FC17E0: C0CB0C18  lfs f6, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82FC17E4: FCA03090  fmr f5, f6
	ctx.f[5].f64 = ctx.f[6].f64;
	// 82FC17E8: FC603090  fmr f3, f6
	ctx.f[3].f64 = ctx.f[6].f64;
	// 82FC17EC: FC403090  fmr f2, f6
	ctx.f[2].f64 = ctx.f[6].f64;
	// 82FC17F0: 4BFAB021  bl 0x82f6c810
	ctx.lr = 0x82FC17F4;
	sub_82F6C810(ctx, base);
	// 82FC17F4: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82FC17F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC17FC: 4BFAB1A5  bl 0x82f6c9a0
	ctx.lr = 0x82FC1800;
	sub_82F6C9A0(ctx, base);
	// 82FC1800: 4BFFFE90  b 0x82fc1690
	pc = 0x82FC1690; continue 'dispatch;
            }
            0x82FC1804 => {
    //   block [0x82FC1804..0x82FC1828)
	// 82FC1804: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC1808: 4182010C  beq 0x82fc1914
	if ctx.cr[0].eq {
	pc = 0x82FC1914; continue 'dispatch;
	}
	// 82FC180C: 387B0008  addi r3, r27, 8
	ctx.r[3].s64 = ctx.r[27].s64 + 8;
	// 82FC1810: 809F001C  lwz r4, 0x1c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC1814: 4BF714FD  bl 0x82f32d10
	ctx.lr = 0x82FC1818;
	sub_82F32D10(ctx, base);
	// 82FC1818: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC181C: 4182000C  beq 0x82fc1828
	if ctx.cr[0].eq {
	pc = 0x82FC1828; continue 'dispatch;
	}
	// 82FC1820: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC1824: 48000008  b 0x82fc182c
	pc = 0x82FC182C; continue 'dispatch;
            }
            0x82FC1828 => {
    //   block [0x82FC1828..0x82FC182C)
	// 82FC1828: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82FC182C; continue 'dispatch;
            }
            0x82FC182C => {
    //   block [0x82FC182C..0x82FC1888)
	// 82FC182C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC1830: 419A00E4  beq cr6, 0x82fc1914
	if ctx.cr[6].eq {
	pc = 0x82FC1914; continue 'dispatch;
	}
	// 82FC1834: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC1838: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82FC183C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC1840: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC1844: 4E800421  bctrl
	ctx.lr = 0x82FC1848;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC1848: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82FC184C: 418200C8  beq 0x82fc1914
	if ctx.cr[0].eq {
	pc = 0x82FC1914; continue 'dispatch;
	}
	// 82FC1850: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC1854: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82FC1858: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82FC185C: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 82FC1860: 419A003C  beq cr6, 0x82fc189c
	if ctx.cr[6].eq {
	pc = 0x82FC189C; continue 'dispatch;
	}
	// 82FC1864: 2F0B0041  cmpwi cr6, r11, 0x41
	ctx.cr[6].compare_i32(ctx.r[11].s32, 65, &mut ctx.xer);
	// 82FC1868: 419A0028  beq cr6, 0x82fc1890
	if ctx.cr[6].eq {
	pc = 0x82FC1890; continue 'dispatch;
	}
	// 82FC186C: 2F0B0042  cmpwi cr6, r11, 0x42
	ctx.cr[6].compare_i32(ctx.r[11].s32, 66, &mut ctx.xer);
	// 82FC1870: 419A0018  beq cr6, 0x82fc1888
	if ctx.cr[6].eq {
	pc = 0x82FC1888; continue 'dispatch;
	}
	// 82FC1874: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 82FC1878: 409A002C  bne cr6, 0x82fc18a4
	if !ctx.cr[6].eq {
	pc = 0x82FC18A4; continue 'dispatch;
	}
	// 82FC187C: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82FC1880: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82FC1884: 48000020  b 0x82fc18a4
	pc = 0x82FC18A4; continue 'dispatch;
            }
            0x82FC1888 => {
    //   block [0x82FC1888..0x82FC1890)
	// 82FC1888: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82FC188C: 48000014  b 0x82fc18a0
	pc = 0x82FC18A0; continue 'dispatch;
            }
            0x82FC1890 => {
    //   block [0x82FC1890..0x82FC189C)
	// 82FC1890: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 82FC1894: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82FC1898: 4800000C  b 0x82fc18a4
	pc = 0x82FC18A4; continue 'dispatch;
            }
            0x82FC189C => {
    //   block [0x82FC189C..0x82FC18A0)
	// 82FC189C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	pc = 0x82FC18A0; continue 'dispatch;
            }
            0x82FC18A0 => {
    //   block [0x82FC18A0..0x82FC18A4)
	// 82FC18A0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82FC18A4; continue 'dispatch;
            }
            0x82FC18A4 => {
    //   block [0x82FC18A4..0x82FC18C4)
	// 82FC18A4: 389B0010  addi r4, r27, 0x10
	ctx.r[4].s64 = ctx.r[27].s64 + 16;
	// 82FC18A8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82FC18AC: 4BFAAF4D  bl 0x82f6c7f8
	ctx.lr = 0x82FC18B0;
	sub_82F6C7F8(ctx, base);
	// 82FC18B0: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82FC18B4: 419A0010  beq cr6, 0x82fc18c4
	if ctx.cr[6].eq {
	pc = 0x82FC18C4; continue 'dispatch;
	}
	// 82FC18B8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82FC18BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82FC18C0: 4BFAB169  bl 0x82f6ca28
	ctx.lr = 0x82FC18C4;
	sub_82F6CA28(ctx, base);
	pc = 0x82FC18C4; continue 'dispatch;
            }
            0x82FC18C4 => {
    //   block [0x82FC18C4..0x82FC1914)
	// 82FC18C4: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82FC18C8: 3BBC0010  addi r29, r28, 0x10
	ctx.r[29].s64 = ctx.r[28].s64 + 16;
	// 82FC18CC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82FC18D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC18D4: 4BFAB345  bl 0x82f6cc18
	ctx.lr = 0x82FC18D8;
	sub_82F6CC18(ctx, base);
	// 82FC18D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC18DC: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82FC18E0: FC80F890  fmr f4, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[4].f64 = ctx.f[31].f64;
	// 82FC18E4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82FC18E8: C0CB0C18  lfs f6, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82FC18EC: FCA03090  fmr f5, f6
	ctx.f[5].f64 = ctx.f[6].f64;
	// 82FC18F0: FC603090  fmr f3, f6
	ctx.f[3].f64 = ctx.f[6].f64;
	// 82FC18F4: FC403090  fmr f2, f6
	ctx.f[2].f64 = ctx.f[6].f64;
	// 82FC18F8: 4BFAAF19  bl 0x82f6c810
	ctx.lr = 0x82FC18FC;
	sub_82F6C810(ctx, base);
	// 82FC18FC: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82FC1900: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC1904: 4BFAB09D  bl 0x82f6c9a0
	ctx.lr = 0x82FC1908;
	sub_82F6C9A0(ctx, base);
	// 82FC1908: 93FC0030  stw r31, 0x30(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(48 as u32), ctx.r[31].u32 ) };
	// 82FC190C: 93DC0034  stw r30, 0x34(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82FC1910: 4BFFFD80  b 0x82fc1690
	pc = 0x82FC1690; continue 'dispatch;
            }
            0x82FC1914 => {
    //   block [0x82FC1914..0x82FC1918)
	// 82FC1914: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82FC1918; continue 'dispatch;
            }
            0x82FC1918 => {
    //   block [0x82FC1918..0x82FC1928)
	// 82FC1918: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82FC191C: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82FC1920: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82FC1924: 4BCE7B28  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC1928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC1928 size=164
    let mut pc: u32 = 0x82FC1928;
    'dispatch: loop {
        match pc {
            0x82FC1928 => {
    //   block [0x82FC1928..0x82FC1974)
	// 82FC1928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC192C: 4BCE7ADD  bl 0x82ca9408
	ctx.lr = 0x82FC1930;
	sub_82CA93D0(ctx, base);
	// 82FC1930: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82FC1934: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC1938: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC193C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82FC1940: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC1944: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82FC1948: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC194C: 895F0000  lbz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC1950: 280A0000  cmplwi r10, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC1954: 838B0014  lwz r28, 0x14(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC1958: 4082001C  bne 0x82fc1974
	if !ctx.cr[0].eq {
	pc = 0x82FC1974; continue 'dispatch;
	}
	// 82FC195C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC1960: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FC1964: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC1968: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC196C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82FC1970: 48000044  b 0x82fc19b4
	pc = 0x82FC19B4; continue 'dispatch;
            }
            0x82FC1974 => {
    //   block [0x82FC1974..0x82FC19B4)
	// 82FC1974: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82FC1978: 4BFAB001  bl 0x82f6c978
	ctx.lr = 0x82FC197C;
	sub_82F6C978(ctx, base);
	// 82FC197C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC1980: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82FC1984: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82FC1988: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82FC198C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82FC1990: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82FC1994: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC1998: 4BFFFC29  bl 0x82fc15c0
	ctx.lr = 0x82FC199C;
	sub_82FC15C0(ctx, base);
	// 82FC199C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82FC19A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC19A4: 419A001C  beq cr6, 0x82fc19c0
	if ctx.cr[6].eq {
	pc = 0x82FC19C0; continue 'dispatch;
	}
	// 82FC19A8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC19AC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82FC19B0: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82FC19B4; continue 'dispatch;
            }
            0x82FC19B4 => {
    //   block [0x82FC19B4..0x82FC19C0)
	// 82FC19B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC19B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC19BC: 4E800421  bctrl
	ctx.lr = 0x82FC19C0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC19C0 => {
    //   block [0x82FC19C0..0x82FC19CC)
	// 82FC19C0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82FC19C4: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82FC19C8: 4BCE7A90  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC19D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC19D0 size=84
    let mut pc: u32 = 0x82FC19D0;
    'dispatch: loop {
        match pc {
            0x82FC19D0 => {
    //   block [0x82FC19D0..0x82FC1A24)
	// 82FC19D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC19D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC19D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC19DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC19E0: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82FC19E4: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82FC19E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC19EC: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82FC19F0: C00B11B0  lfs f0, 0x11b0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4528 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC19F4: C1AA127C  lfs f13, 0x127c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4732 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC19F8: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC19FC: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82FC1A00: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82FC1A04: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82FC1A08: 4BFAAF71  bl 0x82f6c978
	ctx.lr = 0x82FC1A0C;
	sub_82F6C978(ctx, base);
	// 82FC1A0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC1A10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FC1A14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC1A18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC1A1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC1A20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC1A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC1A28 size=1376
    let mut pc: u32 = 0x82FC1A28;
    'dispatch: loop {
        match pc {
            0x82FC1A28 => {
    //   block [0x82FC1A28..0x82FC1AB0)
	// 82FC1A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC1A2C: 4BCE79E1  bl 0x82ca940c
	ctx.lr = 0x82FC1A30;
	sub_82CA93D0(ctx, base);
	// 82FC1A30: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82FC1A34: 4BCEC26D  bl 0x82cadca0
	ctx.lr = 0x82FC1A38;
	sub_82CADCA0(ctx, base);
	// 82FC1A38: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC1A3C: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82FC1A40: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC1A44: 396BF030  addi r11, r11, -0xfd0
	ctx.r[11].s64 = ctx.r[11].s64 + -4048;
	// 82FC1A48: 3BDF0040  addi r30, r31, 0x40
	ctx.r[30].s64 = ctx.r[31].s64 + 64;
	// 82FC1A4C: C1BF0040  lfs f13, 0x40(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC1A50: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC1A54: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FC1A58: 409A0058  bne cr6, 0x82fc1ab0
	if !ctx.cr[6].eq {
	pc = 0x82FC1AB0; continue 'dispatch;
	}
	// 82FC1A5C: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC1A60: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC1A64: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FC1A68: 409A0048  bne cr6, 0x82fc1ab0
	if !ctx.cr[6].eq {
	pc = 0x82FC1AB0; continue 'dispatch;
	}
	// 82FC1A6C: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC1A70: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC1A74: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FC1A78: 409A0038  bne cr6, 0x82fc1ab0
	if !ctx.cr[6].eq {
	pc = 0x82FC1AB0; continue 'dispatch;
	}
	// 82FC1A7C: C1BE0010  lfs f13, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC1A80: C00B0010  lfs f0, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC1A84: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FC1A88: 409A0028  bne cr6, 0x82fc1ab0
	if !ctx.cr[6].eq {
	pc = 0x82FC1AB0; continue 'dispatch;
	}
	// 82FC1A8C: C1BE0014  lfs f13, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC1A90: C00B0014  lfs f0, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC1A94: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FC1A98: 409A0018  bne cr6, 0x82fc1ab0
	if !ctx.cr[6].eq {
	pc = 0x82FC1AB0; continue 'dispatch;
	}
	// 82FC1A9C: C00B0018  lfs f0, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC1AA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FC1AA4: C1BE0018  lfs f13, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC1AA8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FC1AAC: 419A0008  beq cr6, 0x82fc1ab4
	if ctx.cr[6].eq {
	pc = 0x82FC1AB4; continue 'dispatch;
	}
	pc = 0x82FC1AB0; continue 'dispatch;
            }
            0x82FC1AB0 => {
    //   block [0x82FC1AB0..0x82FC1AB4)
	// 82FC1AB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82FC1AB4; continue 'dispatch;
            }
            0x82FC1AB4 => {
    //   block [0x82FC1AB4..0x82FC1CA8)
	// 82FC1AB4: 997F0074  stb r11, 0x74(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u8 ) };
	// 82FC1AB8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82FC1ABC: 4BFAAEBD  bl 0x82f6c978
	ctx.lr = 0x82FC1AC0;
	sub_82F6C978(ctx, base);
	// 82FC1AC0: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 82FC1AC4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82FC1AC8: 4BFAB151  bl 0x82f6cc18
	ctx.lr = 0x82FC1ACC;
	sub_82F6CC18(ctx, base);
	// 82FC1ACC: 3BBF0090  addi r29, r31, 0x90
	ctx.r[29].s64 = ctx.r[31].s64 + 144;
	// 82FC1AD0: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82FC1AD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC1AD8: 4BFAAD21  bl 0x82f6c7f8
	ctx.lr = 0x82FC1ADC;
	sub_82F6C7F8(ctx, base);
	// 82FC1ADC: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82FC1AE0: 4BFAAE99  bl 0x82f6c978
	ctx.lr = 0x82FC1AE4;
	sub_82F6C978(ctx, base);
	// 82FC1AE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC1AE8: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 82FC1AEC: 4BFAB12D  bl 0x82f6cc18
	ctx.lr = 0x82FC1AF0;
	sub_82F6CC18(ctx, base);
	// 82FC1AF0: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 82FC1AF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC1AF8: 4BFAAF31  bl 0x82f6ca28
	ctx.lr = 0x82FC1AFC;
	sub_82F6CA28(ctx, base);
	// 82FC1AFC: C15F0020  lfs f10, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82FC1B00: FD205090  fmr f9, f10
	ctx.f[9].f64 = ctx.f[10].f64;
	// 82FC1B04: C01F006C  lfs f0, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC1B08: C03F0064  lfs f1, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC1B0C: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC1B10: C0FF0024  lfs f7, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82FC1B14: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC1B18: C19F0020  lfs f12, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC1B1C: FFA03890  fmr f29, f7
	ctx.f[29].f64 = ctx.f[7].f64;
	// 82FC1B20: C11F0030  lfs f8, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82FC1B24: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC1B28: C0DF0030  lfs f6, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82FC1B2C: ED080072  fmuls f8, f8, f1
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[1].f64) as f32) as f64);
	// 82FC1B30: FCA03890  fmr f5, f7
	ctx.f[5].f64 = ctx.f[7].f64;
	// 82FC1B34: C05F0068  lfs f2, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FC1B38: FFE03090  fmr f31, f6
	ctx.f[31].f64 = ctx.f[6].f64;
	// 82FC1B3C: C17F0034  lfs f11, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC1B40: C1BF0070  lfs f13, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC1B44: ED6B00B2  fmuls f11, f11, f2
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[2].f64) as f32) as f64);
	// 82FC1B48: C07F0010  lfs f3, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82FC1B4C: ED290072  fmuls f9, f9, f1
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[1].f64) as f32) as f64);
	// 82FC1B50: C09F0014  lfs f4, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82FC1B54: D0210074  stfs f1, 0x74(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82FC1B58: D0410078  stfs f2, 0x78(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82FC1B5C: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82FC1B60: ED8760BA  fmadds f12, f7, f2, f12
	ctx.f[12].f64 = (((ctx.f[7].f64 * ctx.f[2].f64 + ctx.f[12].f64) as f32) as f64);
	// 82FC1B64: D1A10098  stfs f13, 0x98(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82FC1B68: D0610084  stfs f3, 0x84(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82FC1B6C: ED45537A  fmadds f10, f5, f13, f10
	ctx.f[10].f64 = (((ctx.f[5].f64 * ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64);
	// 82FC1B70: D0810068  stfs f4, 0x68(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82FC1B74: EFFF0032  fmuls f31, f31, f0
	ctx.f[31].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC1B78: ED66583A  fmadds f11, f6, f0, f11
	ctx.f[11].f64 = (((ctx.f[6].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82FC1B7C: C39F0034  lfs f28, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82FC1B80: ED3D48BA  fmadds f9, f29, f2, f9
	ctx.f[9].f64 = (((ctx.f[29].f64 * ctx.f[2].f64 + ctx.f[9].f64) as f32) as f64);
	// 82FC1B84: C0FF0028  lfs f7, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82FC1B88: EFBC40BA  fmadds f29, f28, f2, f8
	ctx.f[29].f64 = (((ctx.f[28].f64 * ctx.f[2].f64 + ctx.f[8].f64) as f32) as f64);
	// 82FC1B8C: C0DF0038  lfs f6, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82FC1B90: FD00E090  fmr f8, f28
	ctx.f[8].f64 = ctx.f[28].f64;
	// 82FC1B94: C3DF0020  lfs f30, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82FC1B98: FCA03890  fmr f5, f7
	ctx.f[5].f64 = ctx.f[7].f64;
	// 82FC1B9C: C39F0024  lfs f28, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82FC1BA0: FF603890  fmr f27, f7
	ctx.f[27].f64 = ctx.f[7].f64;
	// 82FC1BA4: C33F0018  lfs f25, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82FC1BA8: FF403090  fmr f26, f6
	ctx.f[26].f64 = ctx.f[6].f64;
	// 82FC1BAC: C31F001C  lfs f24, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82FC1BB0: EFDE0072  fmuls f30, f30, f1
	ctx.f[30].f64 = (((ctx.f[30].f64 * ctx.f[1].f64) as f32) as f64);
	// 82FC1BB4: C2FF0030  lfs f23, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82FC1BB8: ED8C382A  fadds f12, f12, f7
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[7].f64) as f32) as f64;
	// 82FC1BBC: C2DF0034  lfs f22, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 82FC1BC0: ED6B302A  fadds f11, f11, f6
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[6].f64) as f32) as f64;
	// 82FC1BC4: D18100B4  stfs f12, 0xb4(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82FC1BC8: FCE03090  fmr f7, f6
	ctx.f[7].f64 = ctx.f[6].f64;
	// 82FC1BCC: D1610088  stfs f11, 0x88(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82FC1BD0: FEA03090  fmr f21, f6
	ctx.f[21].f64 = ctx.f[6].f64;
	// 82FC1BD4: ECD9182A  fadds f6, f25, f3
	ctx.f[6].f64 = ((ctx.f[25].f64 + ctx.f[3].f64) as f32) as f64;
	// 82FC1BD8: EFE8FB7A  fmadds f31, f8, f13, f31
	ctx.f[31].f64 = (((ctx.f[8].f64 * ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64);
	// 82FC1BDC: ED0A282A  fadds f8, f10, f5
	ctx.f[8].f64 = ((ctx.f[10].f64 + ctx.f[5].f64) as f32) as f64;
	// 82FC1BE0: D10100A0  stfs f8, 0xa0(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82FC1BE4: ED49D82A  fadds f10, f9, f27
	ctx.f[10].f64 = ((ctx.f[9].f64 + ctx.f[27].f64) as f32) as f64;
	// 82FC1BE8: ED3DD02A  fadds f9, f29, f26
	ctx.f[9].f64 = ((ctx.f[29].f64 + ctx.f[26].f64) as f32) as f64;
	// 82FC1BEC: EFDCF37A  fmadds f30, f28, f13, f30
	ctx.f[30].f64 = (((ctx.f[28].f64 * ctx.f[13].f64 + ctx.f[30].f64) as f32) as f64);
	// 82FC1BF0: FF80D890  fmr f28, f27
	ctx.f[28].f64 = ctx.f[27].f64;
	// 82FC1BF4: EFAC5028  fsubs f29, f12, f10
	ctx.f[29].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82FC1BF8: ECB8202A  fadds f5, f24, f4
	ctx.f[5].f64 = ((ctx.f[24].f64 + ctx.f[4].f64) as f32) as f64;
	// 82FC1BFC: D0A100A4  stfs f5, 0xa4(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82FC1C00: EF170072  fmuls f24, f23, f1
	ctx.f[24].f64 = (((ctx.f[23].f64 * ctx.f[1].f64) as f32) as f64);
	// 82FC1C04: D0C1006C  stfs f6, 0x6c(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82FC1C08: EFBD0772  fmuls f29, f29, f29
	ctx.f[29].f64 = (((ctx.f[29].f64 * ctx.f[29].f64) as f32) as f64);
	// 82FC1C0C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC1C10: EF4B4828  fsubs f26, f11, f9
	ctx.f[26].f64 = (((ctx.f[11].f64 - ctx.f[9].f64) as f32) as f64);
	// 82FC1C14: ECFF382A  fadds f7, f31, f7
	ctx.f[7].f64 = ((ctx.f[31].f64 + ctx.f[7].f64) as f32) as f64;
	// 82FC1C18: C3EB0C14  lfs f31, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82FC1C1C: EF286028  fsubs f25, f8, f12
	ctx.f[25].f64 = (((ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FC1C20: D0E100A8  stfs f7, 0xa8(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82FC1C24: EFDEE02A  fadds f30, f30, f28
	ctx.f[30].f64 = ((ctx.f[30].f64 + ctx.f[28].f64) as f32) as f64;
	// 82FC1C28: D3C1008C  stfs f30, 0x8c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82FC1C2C: ECC03028  fsubs f6, f0, f6
	ctx.f[6].f64 = (((ctx.f[0].f64 - ctx.f[6].f64) as f32) as f64);
	// 82FC1C30: C36A0AB4  lfs f27, 0xab4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2740 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82FC1C34: EC030828  fsubs f0, f3, f1
	ctx.f[0].f64 = (((ctx.f[3].f64 - ctx.f[1].f64) as f32) as f64);
	// 82FC1C38: EEE41028  fsubs f23, f4, f2
	ctx.f[23].f64 = (((ctx.f[4].f64 - ctx.f[2].f64) as f32) as f64);
	// 82FC1C3C: ECAD2828  fsubs f5, f13, f5
	ctx.f[5].f64 = (((ctx.f[13].f64 - ctx.f[5].f64) as f32) as f64);
	// 82FC1C40: EDB6C37A  fmadds f13, f22, f13, f24
	ctx.f[13].f64 = (((ctx.f[22].f64 * ctx.f[13].f64 + ctx.f[24].f64) as f32) as f64);
	// 82FC1C44: EF5AEEBA  fmadds f26, f26, f26, f29
	ctx.f[26].f64 = (((ctx.f[26].f64 * ctx.f[26].f64 + ctx.f[29].f64) as f32) as f64);
	// 82FC1C48: EF875828  fsubs f28, f7, f11
	ctx.f[28].f64 = (((ctx.f[7].f64 - ctx.f[11].f64) as f32) as f64);
	// 82FC1C4C: EF390672  fmuls f25, f25, f25
	ctx.f[25].f64 = (((ctx.f[25].f64 * ctx.f[25].f64) as f32) as f64);
	// 82FC1C50: EFADA82A  fadds f29, f13, f21
	ctx.f[29].f64 = ((ctx.f[13].f64 + ctx.f[21].f64) as f32) as f64;
	// 82FC1C54: D3A10090  stfs f29, 0x90(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82FC1C58: EDA0D02C  fsqrts f13, f26
	ctx.f[13].f64 = ((ctx.f[26].f64).sqrt() as f32) as f64;
	// 82FC1C5C: EF9CCF3A  fmadds f28, f28, f28, f25
	ctx.f[28].f64 = (((ctx.f[28].f64 * ctx.f[28].f64 + ctx.f[25].f64) as f32) as f64);
	// 82FC1C60: EDBF6824  fdivs f13, f31, f13
	ctx.f[13].f64 = ((ctx.f[31].f64 / ctx.f[13].f64) as f32) as f64;
	// 82FC1C64: EF80E02C  fsqrts f28, f28
	ctx.f[28].f64 = ((ctx.f[28].f64).sqrt() as f32) as f64;
	// 82FC1C68: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FC1C6C: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82FC1C70: EDA60372  fmuls f13, f6, f13
	ctx.f[13].f64 = (((ctx.f[6].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FC1C74: D1A1007C  stfs f13, 0x7c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82FC1C78: EF5FE024  fdivs f26, f31, f28
	ctx.f[26].f64 = ((ctx.f[31].f64 / ctx.f[28].f64) as f32) as f64;
	// 82FC1C7C: EF8D002A  fadds f28, f13, f0
	ctx.f[28].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82FC1C80: ECD706B2  fmuls f6, f23, f26
	ctx.f[6].f64 = (((ctx.f[23].f64 * ctx.f[26].f64) as f32) as f64);
	// 82FC1C84: ECA506B2  fmuls f5, f5, f26
	ctx.f[5].f64 = (((ctx.f[5].f64 * ctx.f[26].f64) as f32) as f64);
	// 82FC1C88: FF1CF800  fcmpu cr6, f28, f31
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[31].f64);
	// 82FC1C8C: 4099001C  ble cr6, 0x82fc1ca8
	if !ctx.cr[6].gt {
	pc = 0x82FC1CA8; continue 'dispatch;
	}
	// 82FC1C90: EF9CD82A  fadds f28, f28, f27
	ctx.f[28].f64 = ((ctx.f[28].f64 + ctx.f[27].f64) as f32) as f64;
	// 82FC1C94: EF9FE024  fdivs f28, f31, f28
	ctx.f[28].f64 = ((ctx.f[31].f64 / ctx.f[28].f64) as f32) as f64;
	// 82FC1C98: EC1C0032  fmuls f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC1C9C: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82FC1CA0: EDBC0372  fmuls f13, f28, f13
	ctx.f[13].f64 = (((ctx.f[28].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FC1CA4: D1A1007C  stfs f13, 0x7c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	pc = 0x82FC1CA8; continue 'dispatch;
            }
            0x82FC1CA8 => {
    //   block [0x82FC1CA8..0x82FC1CC4)
	// 82FC1CA8: EF85302A  fadds f28, f5, f6
	ctx.f[28].f64 = ((ctx.f[5].f64 + ctx.f[6].f64) as f32) as f64;
	// 82FC1CAC: FF1CF800  fcmpu cr6, f28, f31
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[31].f64);
	// 82FC1CB0: 40990014  ble cr6, 0x82fc1cc4
	if !ctx.cr[6].gt {
	pc = 0x82FC1CC4; continue 'dispatch;
	}
	// 82FC1CB4: EF9CD82A  fadds f28, f28, f27
	ctx.f[28].f64 = ((ctx.f[28].f64 + ctx.f[27].f64) as f32) as f64;
	// 82FC1CB8: EFFFE024  fdivs f31, f31, f28
	ctx.f[31].f64 = ((ctx.f[31].f64 / ctx.f[28].f64) as f32) as f64;
	// 82FC1CBC: ECDF01B2  fmuls f6, f31, f6
	ctx.f[6].f64 = (((ctx.f[31].f64 * ctx.f[6].f64) as f32) as f64);
	// 82FC1CC0: ECBF0172  fmuls f5, f31, f5
	ctx.f[5].f64 = (((ctx.f[31].f64 * ctx.f[5].f64) as f32) as f64);
	pc = 0x82FC1CC4; continue 'dispatch;
            }
            0x82FC1CC4 => {
    //   block [0x82FC1CC4..0x82FC1F88)
	// 82FC1CC4: EFFE5028  fsubs f31, f30, f10
	ctx.f[31].f64 = (((ctx.f[30].f64 - ctx.f[10].f64) as f32) as f64);
	// 82FC1CC8: D1410050  stfs f10, 0x50(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FC1CCC: EF9D4828  fsubs f28, f29, f9
	ctx.f[28].f64 = (((ctx.f[29].f64 - ctx.f[9].f64) as f32) as f64);
	// 82FC1CD0: D1210054  stfs f9, 0x54(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FC1CD4: EF6C5028  fsubs f27, f12, f10
	ctx.f[27].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 82FC1CD8: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82FC1CDC: EF075828  fsubs f24, f7, f11
	ctx.f[24].f64 = (((ctx.f[7].f64 - ctx.f[11].f64) as f32) as f64);
	// 82FC1CE0: 387F00B0  addi r3, r31, 0xb0
	ctx.r[3].s64 = ctx.r[31].s64 + 176;
	// 82FC1CE4: EF4B4828  fsubs f26, f11, f9
	ctx.f[26].f64 = (((ctx.f[11].f64 - ctx.f[9].f64) as f32) as f64);
	// 82FC1CE8: EF286028  fsubs f25, f8, f12
	ctx.f[25].f64 = (((ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FC1CEC: EEC7E828  fsubs f22, f7, f29
	ctx.f[22].f64 = (((ctx.f[7].f64 - ctx.f[29].f64) as f32) as f64);
	// 82FC1CF0: EEE8F028  fsubs f23, f8, f30
	ctx.f[23].f64 = (((ctx.f[8].f64 - ctx.f[30].f64) as f32) as f64);
	// 82FC1CF4: EEBF51BA  fmadds f21, f31, f6, f10
	ctx.f[21].f64 = (((ctx.f[31].f64 * ctx.f[6].f64 + ctx.f[10].f64) as f32) as f64);
	// 82FC1CF8: D2A100AC  stfs f21, 0xac(r1)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82FC1CFC: EE9C49BA  fmadds f20, f28, f6, f9
	ctx.f[20].f64 = (((ctx.f[28].f64 * ctx.f[6].f64 + ctx.f[9].f64) as f32) as f64);
	// 82FC1D00: ED5B503A  fmadds f10, f27, f0, f10
	ctx.f[10].f64 = (((ctx.f[27].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 82FC1D04: D1410058  stfs f10, 0x58(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82FC1D08: EE5859BA  fmadds f18, f24, f6, f11
	ctx.f[18].f64 = (((ctx.f[24].f64 * ctx.f[6].f64 + ctx.f[11].f64) as f32) as f64);
	// 82FC1D0C: D1410094  stfs f10, 0x94(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82FC1D10: EE18397C  fnmsubs f16, f24, f5, f7
	ctx.f[16].f64 = -(((ctx.f[24].f64 * ctx.f[5].f64 - ctx.f[7].f64) as f32) as f64);
	// 82FC1D14: EF1CE97C  fnmsubs f24, f28, f5, f29
	ctx.f[24].f64 = -(((ctx.f[28].f64 * ctx.f[5].f64 - ctx.f[29].f64) as f32) as f64);
	// 82FC1D18: ED3A483A  fmadds f9, f26, f0, f9
	ctx.f[9].f64 = (((ctx.f[26].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 82FC1D1C: D121005C  stfs f9, 0x5c(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82FC1D20: EE7961BA  fmadds f19, f25, f6, f12
	ctx.f[19].f64 = (((ctx.f[25].f64 * ctx.f[6].f64 + ctx.f[12].f64) as f32) as f64);
	// 82FC1D24: D12100B0  stfs f9, 0xb0(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82FC1D28: EE39417C  fnmsubs f17, f25, f5, f8
	ctx.f[17].f64 = -(((ctx.f[25].f64 * ctx.f[5].f64 - ctx.f[8].f64) as f32) as f64);
	// 82FC1D2C: EF3FF17C  fnmsubs f25, f31, f5, f30
	ctx.f[25].f64 = -(((ctx.f[31].f64 * ctx.f[5].f64 - ctx.f[30].f64) as f32) as f64);
	// 82FC1D30: ED5BA83A  fmadds f10, f27, f0, f21
	ctx.f[10].f64 = (((ctx.f[27].f64 * ctx.f[0].f64 + ctx.f[21].f64) as f32) as f64);
	// 82FC1D34: D1410060  stfs f10, 0x60(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82FC1D38: EFBAA03A  fmadds f29, f26, f0, f20
	ctx.f[29].f64 = (((ctx.f[26].f64 * ctx.f[0].f64 + ctx.f[20].f64) as f32) as f64);
	// 82FC1D3C: D3A10064  stfs f29, 0x64(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82FC1D40: EFFB637C  fnmsubs f31, f27, f13, f12
	ctx.f[31].f64 = -(((ctx.f[27].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FC1D44: D141009C  stfs f10, 0x9c(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82FC1D48: EFDA5B7C  fnmsubs f30, f26, f13, f11
	ctx.f[30].f64 = -(((ctx.f[26].f64 * ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 82FC1D4C: EF5A937C  fnmsubs f26, f26, f13, f18
	ctx.f[26].f64 = -(((ctx.f[26].f64 * ctx.f[13].f64 - ctx.f[18].f64) as f32) as f64);
	// 82FC1D50: EDF6837C  fnmsubs f15, f22, f13, f16
	ctx.f[15].f64 = -(((ctx.f[22].f64 * ctx.f[13].f64 - ctx.f[16].f64) as f32) as f64);
	// 82FC1D54: EF7B9B7C  fnmsubs f27, f27, f13, f19
	ctx.f[27].f64 = -(((ctx.f[27].f64 * ctx.f[13].f64 - ctx.f[19].f64) as f32) as f64);
	// 82FC1D58: EEB78B7C  fnmsubs f21, f23, f13, f17
	ctx.f[21].f64 = -(((ctx.f[23].f64 * ctx.f[13].f64 - ctx.f[17].f64) as f32) as f64);
	// 82FC1D5C: EDD7C83A  fmadds f14, f23, f0, f25
	ctx.f[14].f64 = (((ctx.f[23].f64 * ctx.f[0].f64 + ctx.f[25].f64) as f32) as f64);
	// 82FC1D60: EC16C03A  fmadds f0, f22, f0, f24
	ctx.f[0].f64 = (((ctx.f[22].f64 * ctx.f[0].f64 + ctx.f[24].f64) as f32) as f64);
	// 82FC1D64: D00100B8  stfs f0, 0xb8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82FC1D68: 4BFAB209  bl 0x82f6cf70
	ctx.lr = 0x82FC1D6C;
	sub_82F6CF70(ctx, base);
	// 82FC1D6C: C0010094  lfs f0, 0x94(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC1D70: C1A100B0  lfs f13, 0xb0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC1D74: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82FC1D78: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FC1D7C: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 82FC1D80: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FC1D84: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82FC1D88: D3C1005C  stfs f30, 0x5c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82FC1D8C: D3610060  stfs f27, 0x60(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82FC1D90: D3410064  stfs f26, 0x64(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82FC1D94: C0810068  lfs f4, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82FC1D98: C061006C  lfs f3, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82FC1D9C: C0410078  lfs f2, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FC1DA0: C0210084  lfs f1, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC1DA4: 4BFAB1CD  bl 0x82f6cf70
	ctx.lr = 0x82FC1DA8;
	sub_82F6CF70(ctx, base);
	// 82FC1DA8: C00100B4  lfs f0, 0xb4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC1DAC: C1A10088  lfs f13, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC1DB0: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82FC1DB4: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FC1DB8: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 82FC1DBC: D3C10054  stfs f30, 0x54(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FC1DC0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82FC1DC4: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82FC1DC8: D2610060  stfs f19, 0x60(r1)
	tmp.f32 = (ctx.f[19].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82FC1DCC: D2410064  stfs f18, 0x64(r1)
	tmp.f32 = (ctx.f[18].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82FC1DD0: C0810068  lfs f4, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82FC1DD4: C0610070  lfs f3, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82FC1DD8: C0410078  lfs f2, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FC1DDC: C021006C  lfs f1, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC1DE0: 4BFAB191  bl 0x82f6cf70
	ctx.lr = 0x82FC1DE4;
	sub_82F6CF70(ctx, base);
	// 82FC1DE4: C00100AC  lfs f0, 0xac(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC1DE8: C381009C  lfs f28, 0x9c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82FC1DEC: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82FC1DF0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FC1DF4: 387F0110  addi r3, r31, 0x110
	ctx.r[3].s64 = ctx.r[31].s64 + 272;
	// 82FC1DF8: D2810054  stfs f20, 0x54(r1)
	tmp.f32 = (ctx.f[20].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FC1DFC: D3810058  stfs f28, 0x58(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82FC1E00: D3A1005C  stfs f29, 0x5c(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82FC1E04: D1C10060  stfs f14, 0x60(r1)
	tmp.f32 = (ctx.f[14].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82FC1E08: C28100B8  lfs f20, 0xb8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 82FC1E0C: D2810064  stfs f20, 0x64(r1)
	tmp.f32 = (ctx.f[20].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82FC1E10: C3E100A4  lfs f31, 0xa4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82FC1E14: C3C10084  lfs f30, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82FC1E18: FC80F890  fmr f4, f31
	ctx.f[4].f64 = ctx.f[31].f64;
	// 82FC1E1C: C0410068  lfs f2, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FC1E20: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82FC1E24: C0210074  lfs f1, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC1E28: 4BFAB149  bl 0x82f6cf70
	ctx.lr = 0x82FC1E2C;
	sub_82F6CF70(ctx, base);
	// 82FC1E2C: D3810050  stfs f28, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FC1E30: D3A10054  stfs f29, 0x54(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FC1E34: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82FC1E38: D3610058  stfs f27, 0x58(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82FC1E3C: 387F0130  addi r3, r31, 0x130
	ctx.r[3].s64 = ctx.r[31].s64 + 304;
	// 82FC1E40: D341005C  stfs f26, 0x5c(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82FC1E44: FC80F890  fmr f4, f31
	ctx.f[4].f64 = ctx.f[31].f64;
	// 82FC1E48: D2A10060  stfs f21, 0x60(r1)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82FC1E4C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82FC1E50: D1E10064  stfs f15, 0x64(r1)
	tmp.f32 = (ctx.f[15].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82FC1E54: C3A1006C  lfs f29, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82FC1E58: C3810068  lfs f28, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82FC1E5C: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82FC1E60: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 82FC1E64: 4BFAB10D  bl 0x82f6cf70
	ctx.lr = 0x82FC1E68;
	sub_82F6CF70(ctx, base);
	// 82FC1E68: D3410054  stfs f26, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FC1E6C: D3610050  stfs f27, 0x50(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FC1E70: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82FC1E74: D2610058  stfs f19, 0x58(r1)
	tmp.f32 = (ctx.f[19].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82FC1E78: 387F0150  addi r3, r31, 0x150
	ctx.r[3].s64 = ctx.r[31].s64 + 336;
	// 82FC1E7C: D241005C  stfs f18, 0x5c(r1)
	tmp.f32 = (ctx.f[18].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82FC1E80: FC80F890  fmr f4, f31
	ctx.f[4].f64 = ctx.f[31].f64;
	// 82FC1E84: D2210060  stfs f17, 0x60(r1)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82FC1E88: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82FC1E8C: D2010064  stfs f16, 0x64(r1)
	tmp.f32 = (ctx.f[16].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82FC1E90: FC40E090  fmr f2, f28
	ctx.f[2].f64 = ctx.f[28].f64;
	// 82FC1E94: C3410070  lfs f26, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82FC1E98: FC60D090  fmr f3, f26
	ctx.f[3].f64 = ctx.f[26].f64;
	// 82FC1E9C: 4BFAB0D5  bl 0x82f6cf70
	ctx.lr = 0x82FC1EA0;
	sub_82F6CF70(ctx, base);
	// 82FC1EA0: C0010080  lfs f0, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC1EA4: C1A1008C  lfs f13, 0x8c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC1EA8: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82FC1EAC: C1810090  lfs f12, 0x90(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC1EB0: EDB7683A  fmadds f13, f23, f0, f13
	ctx.f[13].f64 = (((ctx.f[23].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FC1EB4: EC16603A  fmadds f0, f22, f0, f12
	ctx.f[0].f64 = (((ctx.f[22].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82FC1EB8: D3210050  stfs f25, 0x50(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FC1EBC: D3010054  stfs f24, 0x54(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FC1EC0: 387F0170  addi r3, r31, 0x170
	ctx.r[3].s64 = ctx.r[31].s64 + 368;
	// 82FC1EC4: D1C10058  stfs f14, 0x58(r1)
	tmp.f32 = (ctx.f[14].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82FC1EC8: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 82FC1ECC: D281005C  stfs f20, 0x5c(r1)
	tmp.f32 = (ctx.f[20].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82FC1ED0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82FC1ED4: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82FC1ED8: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82FC1EDC: C3610098  lfs f27, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82FC1EE0: C0210074  lfs f1, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC1EE4: FC80D890  fmr f4, f27
	ctx.f[4].f64 = ctx.f[27].f64;
	// 82FC1EE8: 4BFAB089  bl 0x82f6cf70
	ctx.lr = 0x82FC1EEC;
	sub_82F6CF70(ctx, base);
	// 82FC1EEC: C001007C  lfs f0, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC1EF0: C32100A0  lfs f25, 0xa0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82FC1EF4: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82FC1EF8: C30100A8  lfs f24, 0xa8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82FC1EFC: EDB7C83C  fnmsubs f13, f23, f0, f25
	ctx.f[13].f64 = -(((ctx.f[23].f64 * ctx.f[0].f64 - ctx.f[25].f64) as f32) as f64);
	// 82FC1F00: EC16C03C  fnmsubs f0, f22, f0, f24
	ctx.f[0].f64 = -(((ctx.f[22].f64 * ctx.f[0].f64 - ctx.f[24].f64) as f32) as f64);
	// 82FC1F04: D1C10050  stfs f14, 0x50(r1)
	tmp.f32 = (ctx.f[14].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FC1F08: D2810054  stfs f20, 0x54(r1)
	tmp.f32 = (ctx.f[20].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FC1F0C: 387F0190  addi r3, r31, 0x190
	ctx.r[3].s64 = ctx.r[31].s64 + 400;
	// 82FC1F10: D2A10058  stfs f21, 0x58(r1)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82FC1F14: FC80D890  fmr f4, f27
	ctx.f[4].f64 = ctx.f[27].f64;
	// 82FC1F18: D1E1005C  stfs f15, 0x5c(r1)
	tmp.f32 = (ctx.f[15].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82FC1F1C: FC60E890  fmr f3, f29
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82FC1F20: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82FC1F24: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82FC1F28: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82FC1F2C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82FC1F30: 4BFAB041  bl 0x82f6cf70
	ctx.lr = 0x82FC1F34;
	sub_82F6CF70(ctx, base);
	// 82FC1F34: D2A10050  stfs f21, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FC1F38: D1E10054  stfs f15, 0x54(r1)
	tmp.f32 = (ctx.f[15].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FC1F3C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82FC1F40: D2210058  stfs f17, 0x58(r1)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82FC1F44: 387F01B0  addi r3, r31, 0x1b0
	ctx.r[3].s64 = ctx.r[31].s64 + 432;
	// 82FC1F48: D201005C  stfs f16, 0x5c(r1)
	tmp.f32 = (ctx.f[16].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82FC1F4C: D3210060  stfs f25, 0x60(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82FC1F50: FC80D890  fmr f4, f27
	ctx.f[4].f64 = ctx.f[27].f64;
	// 82FC1F54: D3010064  stfs f24, 0x64(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82FC1F58: FC60D090  fmr f3, f26
	ctx.f[3].f64 = ctx.f[26].f64;
	// 82FC1F5C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82FC1F60: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82FC1F64: 4BFAB00D  bl 0x82f6cf70
	ctx.lr = 0x82FC1F68;
	sub_82F6CF70(ctx, base);
	// 82FC1F68: D3DF0078  stfs f30, 0x78(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82FC1F6C: D39F007C  stfs f28, 0x7c(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82FC1F70: D3BF0080  stfs f29, 0x80(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82FC1F74: D3FF0084  stfs f31, 0x84(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82FC1F78: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 82FC1F7C: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82FC1F80: 4BCEBD6D  bl 0x82cadcec
	ctx.lr = 0x82FC1F84;
	sub_82CADCEC(ctx, base);
	// 82FC1F84: 4BCE74D8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC1F88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FC1F88 size=316
    let mut pc: u32 = 0x82FC1F88;
    'dispatch: loop {
        match pc {
            0x82FC1F88 => {
    //   block [0x82FC1F88..0x82FC1FE0)
	// 82FC1F88: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC1F8C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82FC1F90: C1A30040  lfs f13, 0x40(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC1F94: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC1F98: C1850000  lfs f12, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC1F9C: C1630044  lfs f11, 0x44(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC1FA0: C1430048  lfs f10, 0x48(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82FC1FA4: EDAB6B3A  fmadds f13, f11, f12, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FC1FA8: EDAD502A  fadds f13, f13, f10
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82FC1FAC: D1A40000  stfs f13, 0(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC1FB0: C1A30054  lfs f13, 0x54(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC1FB4: C1630058  lfs f11, 0x58(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC1FB8: C1430050  lfs f10, 0x50(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82FC1FBC: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC1FC0: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FC1FC4: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82FC1FC8: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC1FCC: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC1FD0: C1830080  lfs f12, 0x80(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC1FD4: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82FC1FD8: 41990008  bgt cr6, 0x82fc1fe0
	if ctx.cr[6].gt {
	pc = 0x82FC1FE0; continue 'dispatch;
	}
	// 82FC1FDC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x82FC1FE0; continue 'dispatch;
            }
            0x82FC1FE0 => {
    //   block [0x82FC1FE0..0x82FC1FF4)
	// 82FC1FE0: C1830084  lfs f12, 0x84(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC1FE4: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82FC1FE8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82FC1FEC: 41990008  bgt cr6, 0x82fc1ff4
	if ctx.cr[6].gt {
	pc = 0x82FC1FF4; continue 'dispatch;
	}
	// 82FC1FF0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82FC1FF4; continue 'dispatch;
            }
            0x82FC1FF4 => {
    //   block [0x82FC1FF4..0x82FC2008)
	// 82FC1FF4: C1830078  lfs f12, 0x78(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC1FF8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82FC1FFC: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82FC2000: 41980008  blt cr6, 0x82fc2008
	if ctx.cr[6].lt {
	pc = 0x82FC2008; continue 'dispatch;
	}
	// 82FC2004: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82FC2008; continue 'dispatch;
            }
            0x82FC2008 => {
    //   block [0x82FC2008..0x82FC201C)
	// 82FC2008: C183007C  lfs f12, 0x7c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC200C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FC2010: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82FC2014: 41980008  blt cr6, 0x82fc201c
	if ctx.cr[6].lt {
	pc = 0x82FC201C; continue 'dispatch;
	}
	// 82FC2018: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82FC201C; continue 'dispatch;
            }
            0x82FC201C => {
    //   block [0x82FC201C..0x82FC20C4)
	// 82FC201C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC2020: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82FC2024: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82FC2028: 394768DC  addi r10, r7, 0x68dc
	ctx.r[10].s64 = ctx.r[7].s64 + 26844;
	// 82FC202C: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC2030: 7D6B4B78  or r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 82FC2034: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC2038: 7D6B4378  or r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[8].u64;
	// 82FC203C: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FC2040: 556B283E  rotlwi r11, r11, 5
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(5)) as u64;
	// 82FC2044: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82FC2048: 394B00B0  addi r10, r11, 0xb0
	ctx.r[10].s64 = ctx.r[11].s64 + 176;
	// 82FC204C: C18B00B0  lfs f12, 0xb0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC2050: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FC2054: C16B00B4  lfs f11, 0xb4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC2058: C14B00B8  lfs f10, 0xb8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82FC205C: ED8B603A  fmadds f12, f11, f0, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82FC2060: ED8C502A  fadds f12, f12, f10
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[10].f64) as f32) as f64;
	// 82FC2064: D1840000  stfs f12, 0(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC2068: C18B00C4  lfs f12, 0xc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(196 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC206C: C16B00C8  lfs f11, 0xc8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC2070: C14B00C0  lfs f10, 0xc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(192 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82FC2074: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FC2078: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FC207C: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 82FC2080: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC2084: C1A30094  lfs f13, 0x94(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC2088: C1830098  lfs f12, 0x98(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC208C: C1640000  lfs f11, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC2090: C1430090  lfs f10, 0x90(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82FC2094: ED4A02F2  fmuls f10, f10, f11
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[11].f64) as f32) as f64);
	// 82FC2098: EDAD503A  fmadds f13, f13, f0, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 82FC209C: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82FC20A0: D1A40000  stfs f13, 0(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC20A4: C1A300A4  lfs f13, 0xa4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(164 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC20A8: C18300A8  lfs f12, 0xa8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC20AC: C14300A0  lfs f10, 0xa0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(160 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82FC20B0: ED6A02F2  fmuls f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[11].f64) as f32) as f64);
	// 82FC20B4: EC0D583A  fmadds f0, f13, f0, f11
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 82FC20B8: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82FC20BC: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC20C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC20C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC20C8 size=200
    let mut pc: u32 = 0x82FC20C8;
    'dispatch: loop {
        match pc {
            0x82FC20C8 => {
    //   block [0x82FC20C8..0x82FC20EC)
	// 82FC20C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC20CC: 4BCE7341  bl 0x82ca940c
	ctx.lr = 0x82FC20D0;
	sub_82CA93D0(ctx, base);
	// 82FC20D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC20D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC20D8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82FC20DC: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82FC20E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC20E4: 409900A4  ble cr6, 0x82fc2188
	if !ctx.cr[6].gt {
	pc = 0x82FC2188; continue 'dispatch;
	}
	// 82FC20E8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82FC20EC; continue 'dispatch;
            }
            0x82FC20EC => {
    //   block [0x82FC20EC..0x82FC2174)
	// 82FC20EC: 817F01D0  lwz r11, 0x1d0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) } as u64;
	// 82FC20F0: 7CDE5A14  add r6, r30, r11
	ctx.r[6].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82FC20F4: 7DBE5C2E  lfsx f13, r30, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC20F8: C0060008  lfs f0, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC20FC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FC2100: 40980074  bge cr6, 0x82fc2174
	if !ctx.cr[6].lt {
	pc = 0x82FC2174; continue 'dispatch;
	}
	// 82FC2104: C1860004  lfs f12, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC2108: C006000C  lfs f0, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC210C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82FC2110: 40980064  bge cr6, 0x82fc2174
	if !ctx.cr[6].lt {
	pc = 0x82FC2174; continue 'dispatch;
	}
	// 82FC2114: C1660008  lfs f11, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC2118: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82FC211C: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FC2120: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FC2124: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FC2128: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC212C: D1610058  stfs f11, 0x58(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82FC2130: D181005C  stfs f12, 0x5c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82FC2134: D1610060  stfs f11, 0x60(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82FC2138: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82FC213C: 4BFFFE4D  bl 0x82fc1f88
	ctx.lr = 0x82FC2140;
	sub_82FC1F88(ctx, base);
	// 82FC2140: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82FC2144: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82FC2148: 4BFFFE41  bl 0x82fc1f88
	ctx.lr = 0x82FC214C;
	sub_82FC1F88(ctx, base);
	// 82FC214C: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 82FC2150: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82FC2154: 4BFFFE35  bl 0x82fc1f88
	ctx.lr = 0x82FC2158;
	sub_82FC1F88(ctx, base);
	// 82FC2158: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82FC215C: 38660010  addi r3, r6, 0x10
	ctx.r[3].s64 = ctx.r[6].s64 + 16;
	// 82FC2160: C086000C  lfs f4, 0xc(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82FC2164: C0660008  lfs f3, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82FC2168: C0460004  lfs f2, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FC216C: C0260000  lfs f1, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC2170: 4BFAAE01  bl 0x82f6cf70
	ctx.lr = 0x82FC2174;
	sub_82F6CF70(ctx, base);
	pc = 0x82FC2174; continue 'dispatch;
            }
            0x82FC2174 => {
    //   block [0x82FC2174..0x82FC2188)
	// 82FC2174: 817F01D4  lwz r11, 0x1d4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) } as u64;
	// 82FC2178: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82FC217C: 3BDE0030  addi r30, r30, 0x30
	ctx.r[30].s64 = ctx.r[30].s64 + 48;
	// 82FC2180: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC2184: 4198FF68  blt cr6, 0x82fc20ec
	if ctx.cr[6].lt {
	pc = 0x82FC20EC; continue 'dispatch;
	}
	pc = 0x82FC2188; continue 'dispatch;
            }
            0x82FC2188 => {
    //   block [0x82FC2188..0x82FC2190)
	// 82FC2188: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82FC218C: 4BCE72D0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC2190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC2190 size=288
    let mut pc: u32 = 0x82FC2190;
    'dispatch: loop {
        match pc {
            0x82FC2190 => {
    //   block [0x82FC2190..0x82FC2228)
	// 82FC2190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC2194: 4BCE7275  bl 0x82ca9408
	ctx.lr = 0x82FC2198;
	sub_82CA93D0(ctx, base);
	// 82FC2198: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC219C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82FC21A0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC21A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82FC21A8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82FC21AC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC21B0: 83EB0014  lwz r31, 0x14(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC21B4: 4BFAA7C5  bl 0x82f6c978
	ctx.lr = 0x82FC21B8;
	sub_82F6C978(ctx, base);
	// 82FC21B8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82FC21BC: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC21C0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82FC21C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FC21C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC21CC: 4BFFF3F5  bl 0x82fc15c0
	ctx.lr = 0x82FC21D0;
	sub_82FC15C0(ctx, base);
	// 82FC21D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC21D4: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 82FC21D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC21DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC21E0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82FC21E4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FC21E8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82FC21EC: 38A00024  li r5, 0x24
	ctx.r[5].s64 = 36;
	// 82FC21F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC21F4: 4E800421  bctrl
	ctx.lr = 0x82FC21F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC21F8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FC21FC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82FC2200: 388B68F0  addi r4, r11, 0x68f0
	ctx.r[4].s64 = ctx.r[11].s64 + 26864;
	// 82FC2204: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82FC2208: 38A00036  li r5, 0x36
	ctx.r[5].s64 = 54;
	// 82FC220C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC2210: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC2214: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82FC2218: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC221C: 4E800421  bctrl
	ctx.lr = 0x82FC2220;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC2220: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82FC2224: 3BDE00A0  addi r30, r30, 0xa0
	ctx.r[30].s64 = ctx.r[30].s64 + 160;
            }
            0x82FC2228 => {
    //   block [0x82FC2228..0x82FC2294)
	// 82FC2228: A17D0008  lhz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC222C: A15D0000  lhz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC2230: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC2234: 419A0060  beq cr6, 0x82fc2294
	if ctx.cr[6].eq {
	pc = 0x82FC2294; continue 'dispatch;
	}
	// 82FC2238: A17D000A  lhz r11, 0xa(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(10 as u32) ) } as u64;
	// 82FC223C: A15D0002  lhz r10, 2(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(2 as u32) ) } as u64;
	// 82FC2240: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC2244: 419A0050  beq cr6, 0x82fc2294
	if ctx.cr[6].eq {
	pc = 0x82FC2294; continue 'dispatch;
	}
	// 82FC2248: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC224C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82FC2250: 4BFAA5A9  bl 0x82f6c7f8
	ctx.lr = 0x82FC2254;
	sub_82F6C7F8(ctx, base);
	// 82FC2254: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC2258: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FC225C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC2260: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC2264: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC2268: 4E800421  bctrl
	ctx.lr = 0x82FC226C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC226C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC2270: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 82FC2274: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82FC2278: 38C00036  li r6, 0x36
	ctx.r[6].s64 = 54;
	// 82FC227C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82FC2280: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82FC2284: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC2288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC228C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC2290: 4E800421  bctrl
	ctx.lr = 0x82FC2294;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC2294 => {
    //   block [0x82FC2294..0x82FC22B0)
	// 82FC2294: 3B9C0006  addi r28, r28, 6
	ctx.r[28].s64 = ctx.r[28].s64 + 6;
	// 82FC2298: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 82FC229C: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 82FC22A0: 2B1C0036  cmplwi cr6, r28, 0x36
	ctx.cr[6].compare_u32(ctx.r[28].u32, 54 as u32, &mut ctx.xer);
	// 82FC22A4: 4198FF84  blt cr6, 0x82fc2228
	if ctx.cr[6].lt {
	pc = 0x82FC2228; continue 'dispatch;
	}
	// 82FC22A8: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82FC22AC: 4BCE71AC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC22B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC22B0 size=360
    let mut pc: u32 = 0x82FC22B0;
    'dispatch: loop {
        match pc {
            0x82FC22B0 => {
    //   block [0x82FC22B0..0x82FC2358)
	// 82FC22B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC22B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC22B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC22BC: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC22C0: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 82FC22C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82FC22C8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82FC22CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC22D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82FC22D4: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC22D8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82FC22DC: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC22E0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FC22E4: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FC22E8: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC22EC: C16B000C  lfs f11, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC22F0: D1810058  stfs f12, 0x58(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82FC22F4: D1A1005C  stfs f13, 0x5c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82FC22F8: D1810060  stfs f12, 0x60(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82FC22FC: D1610064  stfs f11, 0x64(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82FC2300: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82FC2304: D161006C  stfs f11, 0x6c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82FC2308: 4BFFFC81  bl 0x82fc1f88
	ctx.lr = 0x82FC230C;
	sub_82FC1F88(ctx, base);
	// 82FC230C: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 82FC2310: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82FC2314: 4BFFFC75  bl 0x82fc1f88
	ctx.lr = 0x82FC2318;
	sub_82FC1F88(ctx, base);
	// 82FC2318: 38A10064  addi r5, r1, 0x64
	ctx.r[5].s64 = ctx.r[1].s64 + 100;
	// 82FC231C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82FC2320: 4BFFFC69  bl 0x82fc1f88
	ctx.lr = 0x82FC2324;
	sub_82FC1F88(ctx, base);
	// 82FC2324: 38A1006C  addi r5, r1, 0x6c
	ctx.r[5].s64 = ctx.r[1].s64 + 108;
	// 82FC2328: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82FC232C: 4BFFFC5D  bl 0x82fc1f88
	ctx.lr = 0x82FC2330;
	sub_82FC1F88(ctx, base);
	// 82FC2330: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC2334: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC2338: FCE00090  fmr f7, f0
	ctx.f[7].f64 = ctx.f[0].f64;
	// 82FC233C: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC2340: FD006890  fmr f8, f13
	ctx.f[8].f64 = ctx.f[13].f64;
	// 82FC2344: FD200090  fmr f9, f0
	ctx.f[9].f64 = ctx.f[0].f64;
	// 82FC2348: FD406890  fmr f10, f13
	ctx.f[10].f64 = ctx.f[13].f64;
	// 82FC234C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82FC2350: 40980008  bge cr6, 0x82fc2358
	if !ctx.cr[6].lt {
	pc = 0x82FC2358; continue 'dispatch;
	}
	// 82FC2354: FCE06090  fmr f7, f12
	ctx.f[7].f64 = ctx.f[12].f64;
	pc = 0x82FC2358; continue 'dispatch;
            }
            0x82FC2358 => {
    //   block [0x82FC2358..0x82FC2368)
	// 82FC2358: C161005C  lfs f11, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC235C: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 82FC2360: 40980008  bge cr6, 0x82fc2368
	if !ctx.cr[6].lt {
	pc = 0x82FC2368; continue 'dispatch;
	}
	// 82FC2364: FD005890  fmr f8, f11
	ctx.f[8].f64 = ctx.f[11].f64;
	pc = 0x82FC2368; continue 'dispatch;
            }
            0x82FC2368 => {
    //   block [0x82FC2368..0x82FC2374)
	// 82FC2368: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82FC236C: 40990008  ble cr6, 0x82fc2374
	if !ctx.cr[6].gt {
	pc = 0x82FC2374; continue 'dispatch;
	}
	// 82FC2370: FD206090  fmr f9, f12
	ctx.f[9].f64 = ctx.f[12].f64;
	pc = 0x82FC2374; continue 'dispatch;
            }
            0x82FC2374 => {
    //   block [0x82FC2374..0x82FC2380)
	// 82FC2374: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 82FC2378: 40990008  ble cr6, 0x82fc2380
	if !ctx.cr[6].gt {
	pc = 0x82FC2380; continue 'dispatch;
	}
	// 82FC237C: FD405890  fmr f10, f11
	ctx.f[10].f64 = ctx.f[11].f64;
	pc = 0x82FC2380; continue 'dispatch;
            }
            0x82FC2380 => {
    //   block [0x82FC2380..0x82FC2390)
	// 82FC2380: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC2384: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82FC2388: 40980008  bge cr6, 0x82fc2390
	if !ctx.cr[6].lt {
	pc = 0x82FC2390; continue 'dispatch;
	}
	// 82FC238C: FCE06890  fmr f7, f13
	ctx.f[7].f64 = ctx.f[13].f64;
	pc = 0x82FC2390; continue 'dispatch;
            }
            0x82FC2390 => {
    //   block [0x82FC2390..0x82FC23A0)
	// 82FC2390: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC2394: FF004000  fcmpu cr6, f0, f8
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[8].f64);
	// 82FC2398: 40980008  bge cr6, 0x82fc23a0
	if !ctx.cr[6].lt {
	pc = 0x82FC23A0; continue 'dispatch;
	}
	// 82FC239C: FD000090  fmr f8, f0
	ctx.f[8].f64 = ctx.f[0].f64;
	pc = 0x82FC23A0; continue 'dispatch;
            }
            0x82FC23A0 => {
    //   block [0x82FC23A0..0x82FC23AC)
	// 82FC23A0: FF0D4800  fcmpu cr6, f13, f9
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[9].f64);
	// 82FC23A4: 40990008  ble cr6, 0x82fc23ac
	if !ctx.cr[6].gt {
	pc = 0x82FC23AC; continue 'dispatch;
	}
	// 82FC23A8: FD206890  fmr f9, f13
	ctx.f[9].f64 = ctx.f[13].f64;
	pc = 0x82FC23AC; continue 'dispatch;
            }
            0x82FC23AC => {
    //   block [0x82FC23AC..0x82FC23B8)
	// 82FC23AC: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82FC23B0: 40990008  ble cr6, 0x82fc23b8
	if !ctx.cr[6].gt {
	pc = 0x82FC23B8; continue 'dispatch;
	}
	// 82FC23B4: FD400090  fmr f10, f0
	ctx.f[10].f64 = ctx.f[0].f64;
	pc = 0x82FC23B8; continue 'dispatch;
            }
            0x82FC23B8 => {
    //   block [0x82FC23B8..0x82FC23C8)
	// 82FC23B8: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC23BC: FF0D3800  fcmpu cr6, f13, f7
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[7].f64);
	// 82FC23C0: 40980008  bge cr6, 0x82fc23c8
	if !ctx.cr[6].lt {
	pc = 0x82FC23C8; continue 'dispatch;
	}
	// 82FC23C4: FCE06890  fmr f7, f13
	ctx.f[7].f64 = ctx.f[13].f64;
	pc = 0x82FC23C8; continue 'dispatch;
            }
            0x82FC23C8 => {
    //   block [0x82FC23C8..0x82FC23D8)
	// 82FC23C8: C001006C  lfs f0, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC23CC: FF004000  fcmpu cr6, f0, f8
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[8].f64);
	// 82FC23D0: 40980008  bge cr6, 0x82fc23d8
	if !ctx.cr[6].lt {
	pc = 0x82FC23D8; continue 'dispatch;
	}
	// 82FC23D4: FD000090  fmr f8, f0
	ctx.f[8].f64 = ctx.f[0].f64;
	pc = 0x82FC23D8; continue 'dispatch;
            }
            0x82FC23D8 => {
    //   block [0x82FC23D8..0x82FC23E4)
	// 82FC23D8: FF0D4800  fcmpu cr6, f13, f9
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[9].f64);
	// 82FC23DC: 40990008  ble cr6, 0x82fc23e4
	if !ctx.cr[6].gt {
	pc = 0x82FC23E4; continue 'dispatch;
	}
	// 82FC23E0: FD206890  fmr f9, f13
	ctx.f[9].f64 = ctx.f[13].f64;
	pc = 0x82FC23E4; continue 'dispatch;
            }
            0x82FC23E4 => {
    //   block [0x82FC23E4..0x82FC23F0)
	// 82FC23E4: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 82FC23E8: 40990008  ble cr6, 0x82fc23f0
	if !ctx.cr[6].gt {
	pc = 0x82FC23F0; continue 'dispatch;
	}
	// 82FC23EC: FD400090  fmr f10, f0
	ctx.f[10].f64 = ctx.f[0].f64;
	pc = 0x82FC23F0; continue 'dispatch;
            }
            0x82FC23F0 => {
    //   block [0x82FC23F0..0x82FC2418)
	// 82FC23F0: D0E60000  stfs f7, 0(r6)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC23F4: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82FC23F8: D1060004  stfs f8, 4(r6)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82FC23FC: D1260008  stfs f9, 8(r6)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82FC2400: D146000C  stfs f10, 0xc(r6)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82FC2404: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC2408: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC240C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC2410: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC2414: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC2418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC2418 size=200
    let mut pc: u32 = 0x82FC2418;
    'dispatch: loop {
        match pc {
            0x82FC2418 => {
    //   block [0x82FC2418..0x82FC245C)
	// 82FC2418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC241C: 4BCE6FED  bl 0x82ca9408
	ctx.lr = 0x82FC2420;
	sub_82CA93D0(ctx, base);
	// 82FC2420: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC2424: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC2428: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82FC242C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82FC2430: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC2434: 839E0004  lwz r28, 4(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC2438: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82FC243C: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82FC2440: 409A0048  bne cr6, 0x82fc2488
	if !ctx.cr[6].eq {
	pc = 0x82FC2488; continue 'dispatch;
	}
	// 82FC2444: 556917BF  rlwinm. r9, r11, 2, 0x1e, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC2448: 4182001C  beq 0x82fc2464
	if ctx.cr[0].eq {
	pc = 0x82FC2464; continue 'dispatch;
	}
	// 82FC244C: 55680FFF  rlwinm. r8, r11, 1, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82FC2450: 4182000C  beq 0x82fc245c
	if ctx.cr[0].eq {
	pc = 0x82FC245C; continue 'dispatch;
	}
	// 82FC2454: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82FC2458: 409A0054  bne cr6, 0x82fc24ac
	if !ctx.cr[6].eq {
	pc = 0x82FC24AC; continue 'dispatch;
	}
	pc = 0x82FC245C; continue 'dispatch;
            }
            0x82FC245C => {
    //   block [0x82FC245C..0x82FC2464)
	// 82FC245C: 552A07FF  clrlwi. r10, r9, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC2460: 4082004C  bne 0x82fc24ac
	if !ctx.cr[0].eq {
	pc = 0x82FC24AC; continue 'dispatch;
	}
	pc = 0x82FC2464; continue 'dispatch;
            }
            0x82FC2464 => {
    //   block [0x82FC2464..0x82FC247C)
	// 82FC2464: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC2468: 556B0002  rlwinm r11, r11, 0, 0, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC246C: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC2470: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC2474: 419A0008  beq cr6, 0x82fc247c
	if ctx.cr[6].eq {
	pc = 0x82FC247C; continue 'dispatch;
	}
	// 82FC2478: 4BF3B429  bl 0x82efd8a0
	ctx.lr = 0x82FC247C;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC247C; continue 'dispatch;
            }
            0x82FC247C => {
    //   block [0x82FC247C..0x82FC2488)
	// 82FC247C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC2480: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC2484: 48000028  b 0x82fc24ac
	pc = 0x82FC24AC; continue 'dispatch;
            }
            0x82FC2488 => {
    //   block [0x82FC2488..0x82FC249C)
	// 82FC2488: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC248C: 41990010  bgt cr6, 0x82fc249c
	if ctx.cr[6].gt {
	pc = 0x82FC249C; continue 'dispatch;
	}
	// 82FC2490: 554BF87E  srwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC2494: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC2498: 41990014  bgt cr6, 0x82fc24ac
	if ctx.cr[6].gt {
	pc = 0x82FC24AC; continue 'dispatch;
	}
	pc = 0x82FC249C; continue 'dispatch;
            }
            0x82FC249C => {
    //   block [0x82FC249C..0x82FC24AC)
	// 82FC249C: 57EBF0BE  srwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC24A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC24A4: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82FC24A8: 4BF3DAD1  bl 0x82efff78
	ctx.lr = 0x82FC24AC;
	sub_82EFFF78(ctx, base);
	pc = 0x82FC24AC; continue 'dispatch;
            }
            0x82FC24AC => {
    //   block [0x82FC24AC..0x82FC24BC)
	// 82FC24AC: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82FC24B0: 40980028  bge cr6, 0x82fc24d8
	if !ctx.cr[6].lt {
	pc = 0x82FC24D8; continue 'dispatch;
	}
	// 82FC24B4: 1FBC0030  mulli r29, r28, 0x30
	ctx.r[29].s32 = ((ctx.r[28].s32 as i64 * 48 as i64) as i32);
	ctx.r[29].s64 = ctx.r[29].s32 as i64;
	// 82FC24B8: 7FFCF850  subf r31, r28, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[28].s64;
	pc = 0x82FC24BC; continue 'dispatch;
            }
            0x82FC24BC => {
    //   block [0x82FC24BC..0x82FC24CC)
	// 82FC24BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC24C0: 7C7D5A15  add. r3, r29, r11
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82FC24C4: 41820008  beq 0x82fc24cc
	if ctx.cr[0].eq {
	pc = 0x82FC24CC; continue 'dispatch;
	}
	// 82FC24C8: 4BFFF509  bl 0x82fc19d0
	ctx.lr = 0x82FC24CC;
	sub_82FC19D0(ctx, base);
	pc = 0x82FC24CC; continue 'dispatch;
            }
            0x82FC24CC => {
    //   block [0x82FC24CC..0x82FC24D8)
	// 82FC24CC: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82FC24D0: 3BBD0030  addi r29, r29, 0x30
	ctx.r[29].s64 = ctx.r[29].s64 + 48;
	// 82FC24D4: 4082FFE8  bne 0x82fc24bc
	if !ctx.cr[0].eq {
	pc = 0x82FC24BC; continue 'dispatch;
	}
	pc = 0x82FC24D8; continue 'dispatch;
            }
            0x82FC24D8 => {
    //   block [0x82FC24D8..0x82FC24E0)
	// 82FC24D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC24DC: 4BCE6F7C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC24E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC24E0 size=288
    let mut pc: u32 = 0x82FC24E0;
    'dispatch: loop {
        match pc {
            0x82FC24E0 => {
    //   block [0x82FC24E0..0x82FC2508)
	// 82FC24E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC24E4: 4BCE6F21  bl 0x82ca9404
	ctx.lr = 0x82FC24E8;
	sub_82CA93D0(ctx, base);
	// 82FC24E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC24EC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82FC24F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC24F4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FC24F8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82FC24FC: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC2500: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC2504: 409900F4  ble cr6, 0x82fc25f8
	if !ctx.cr[6].gt {
	pc = 0x82FC25F8; continue 'dispatch;
	}
	pc = 0x82FC2508; continue 'dispatch;
            }
            0x82FC2508 => {
    //   block [0x82FC2508..0x82FC2548)
	// 82FC2508: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC250C: 5789E13A  rlwinm r9, r28, 0x1c, 4, 0x1d
	ctx.r[9].u64 = ctx.r[28].u32 as u64 & 0x0000000Fu64;
	// 82FC2510: 578A06BE  clrlwi r10, r28, 0x1a
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x0000003Fu64;
	// 82FC2514: 1D4A0018  mulli r10, r10, 0x18
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 24 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC2518: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FC251C: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC2520: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC2524: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC2528: 4198005C  blt cr6, 0x82fc2584
	if ctx.cr[6].lt {
	pc = 0x82FC2584; continue 'dispatch;
	}
	// 82FC252C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC2530: 1D6B0030  mulli r11, r11, 0x30
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 48 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC2534: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FC2538: 556A06F7  rlwinm. r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC253C: 4082000C  bne 0x82fc2548
	if !ctx.cr[0].eq {
	pc = 0x82FC2548; continue 'dispatch;
	}
	// 82FC2540: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC2544: 41820040  beq 0x82fc2584
	if ctx.cr[0].eq {
	pc = 0x82FC2584; continue 'dispatch;
	}
	pc = 0x82FC2548; continue 'dispatch;
            }
            0x82FC2548 => {
    //   block [0x82FC2548..0x82FC2560)
	// 82FC2548: 817E01D4  lwz r11, 0x1d4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(468 as u32) ) } as u64;
	// 82FC254C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC2550: 409A0010  bne cr6, 0x82fc2560
	if !ctx.cr[6].eq {
	pc = 0x82FC2560; continue 'dispatch;
	}
	// 82FC2554: 387E01D0  addi r3, r30, 0x1d0
	ctx.r[3].s64 = ctx.r[30].s64 + 464;
	// 82FC2558: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC255C: 4BFFFEBD  bl 0x82fc2418
	ctx.lr = 0x82FC2560;
	sub_82FC2418(ctx, base);
	pc = 0x82FC2560; continue 'dispatch;
            }
            0x82FC2560 => {
    //   block [0x82FC2560..0x82FC2584)
	// 82FC2560: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC2564: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC2568: 815E01D0  lwz r10, 0x1d0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(464 as u32) ) } as u64;
	// 82FC256C: 1D6B0030  mulli r11, r11, 0x30
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 48 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC2570: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC2574: 38E4000C  addi r7, r4, 0xc
	ctx.r[7].s64 = ctx.r[4].s64 + 12;
	// 82FC2578: 38C40008  addi r6, r4, 8
	ctx.r[6].s64 = ctx.r[4].s64 + 8;
	// 82FC257C: 38A40004  addi r5, r4, 4
	ctx.r[5].s64 = ctx.r[4].s64 + 4;
	// 82FC2580: 48003FC9  bl 0x82fc6548
	ctx.lr = 0x82FC2584;
	sub_82FC6548(ctx, base);
	pc = 0x82FC2584; continue 'dispatch;
            }
            0x82FC2584 => {
    //   block [0x82FC2584..0x82FC25AC)
	// 82FC2584: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC2588: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC258C: 4198005C  blt cr6, 0x82fc25e8
	if ctx.cr[6].lt {
	pc = 0x82FC25E8; continue 'dispatch;
	}
	// 82FC2590: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC2594: 1D6B0030  mulli r11, r11, 0x30
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 48 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC2598: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FC259C: 556A06F7  rlwinm. r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC25A0: 4082000C  bne 0x82fc25ac
	if !ctx.cr[0].eq {
	pc = 0x82FC25AC; continue 'dispatch;
	}
	// 82FC25A4: 556B0673  rlwinm. r11, r11, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC25A8: 41820040  beq 0x82fc25e8
	if ctx.cr[0].eq {
	pc = 0x82FC25E8; continue 'dispatch;
	}
	pc = 0x82FC25AC; continue 'dispatch;
            }
            0x82FC25AC => {
    //   block [0x82FC25AC..0x82FC25C4)
	// 82FC25AC: 817E01D4  lwz r11, 0x1d4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(468 as u32) ) } as u64;
	// 82FC25B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC25B4: 409A0010  bne cr6, 0x82fc25c4
	if !ctx.cr[6].eq {
	pc = 0x82FC25C4; continue 'dispatch;
	}
	// 82FC25B8: 387E01D0  addi r3, r30, 0x1d0
	ctx.r[3].s64 = ctx.r[30].s64 + 464;
	// 82FC25BC: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC25C0: 4BFFFE59  bl 0x82fc2418
	ctx.lr = 0x82FC25C4;
	sub_82FC2418(ctx, base);
	pc = 0x82FC25C4; continue 'dispatch;
            }
            0x82FC25C4 => {
    //   block [0x82FC25C4..0x82FC25E8)
	// 82FC25C4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC25C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC25CC: 815E01D0  lwz r10, 0x1d0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(464 as u32) ) } as u64;
	// 82FC25D0: 1D6B0030  mulli r11, r11, 0x30
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 48 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC25D4: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC25D8: 38E4000C  addi r7, r4, 0xc
	ctx.r[7].s64 = ctx.r[4].s64 + 12;
	// 82FC25DC: 38C40008  addi r6, r4, 8
	ctx.r[6].s64 = ctx.r[4].s64 + 8;
	// 82FC25E0: 38A40004  addi r5, r4, 4
	ctx.r[5].s64 = ctx.r[4].s64 + 4;
	// 82FC25E4: 48003F65  bl 0x82fc6548
	ctx.lr = 0x82FC25E8;
	sub_82FC6548(ctx, base);
	pc = 0x82FC25E8; continue 'dispatch;
            }
            0x82FC25E8 => {
    //   block [0x82FC25E8..0x82FC25F8)
	// 82FC25E8: 817B001C  lwz r11, 0x1c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC25EC: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82FC25F0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC25F4: 4198FF14  blt cr6, 0x82fc2508
	if ctx.cr[6].lt {
	pc = 0x82FC2508; continue 'dispatch;
	}
	pc = 0x82FC25F8; continue 'dispatch;
            }
            0x82FC25F8 => {
    //   block [0x82FC25F8..0x82FC2600)
	// 82FC25F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC25FC: 4BCE6E58  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC2600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC2600 size=908
    let mut pc: u32 = 0x82FC2600;
    'dispatch: loop {
        match pc {
            0x82FC2600 => {
    //   block [0x82FC2600..0x82FC2708)
	// 82FC2600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC2604: 4BCE6DF5  bl 0x82ca93f8
	ctx.lr = 0x82FC2608;
	sub_82CA93D0(ctx, base);
	// 82FC2608: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 82FC260C: 9421FE10  stwu r1, -0x1f0(r1)
	ea = ctx.r[1].u32.wrapping_add(-496 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC2610: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC2614: C0C10058  lfs f6, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82FC2618: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82FC261C: C0A10050  lfs f5, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82FC2620: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82FC2624: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82FC2628: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 82FC262C: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC2630: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC2634: EC000824  fdivs f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 82FC2638: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC263C: 911C01C0  stw r8, 0x1c0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(448 as u32), ctx.r[8].u32 ) };
	// 82FC2640: C13F006C  lfs f9, 0x6c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82FC2644: C01F0080  lfs f0, 0x80(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC2648: 3BA10098  addi r29, r1, 0x98
	ctx.r[29].s64 = ctx.r[1].s64 + 152;
	// 82FC264C: C1BF0084  lfs f13, 0x84(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC2650: 3B7C0004  addi r27, r28, 4
	ctx.r[27].s64 = ctx.r[28].s64 + 4;
	// 82FC2654: C19F0078  lfs f12, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC2658: 3B400009  li r26, 9
	ctx.r[26].s64 = 9;
	// 82FC265C: C17F0064  lfs f11, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC2660: C15F0068  lfs f10, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82FC2664: C11F0070  lfs f8, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82FC2668: C0FF007C  lfs f7, 0x7c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82FC266C: D0E1009C  stfs f7, 0x9c(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82FC2670: D0E100AC  stfs f7, 0xac(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82FC2674: D12100B8  stfs f9, 0xb8(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82FC2678: D0E100BC  stfs f7, 0xbc(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82FC267C: D0E100C4  stfs f7, 0xc4(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82FC2680: D0E100D4  stfs f7, 0xd4(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82FC2684: D0E100E4  stfs f7, 0xe4(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82FC2688: D12100E8  stfs f9, 0xe8(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82FC268C: D1210118  stfs f9, 0x118(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82FC2690: C121005C  lfs f9, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82FC2694: C0E10054  lfs f7, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82FC2698: C3EB0C18  lfs f31, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82FC269C: D1810098  stfs f12, 0x98(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82FC26A0: D18100A0  stfs f12, 0xa0(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82FC26A4: D00100A8  stfs f0, 0xa8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82FC26A8: D1610090  stfs f11, 0x90(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82FC26AC: D1410094  stfs f10, 0x94(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82FC26B0: D14100A4  stfs f10, 0xa4(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82FC26B4: D00100B0  stfs f0, 0xb0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82FC26B8: D14100B4  stfs f10, 0xb4(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82FC26BC: D16100C0  stfs f11, 0xc0(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82FC26C0: D18100C8  stfs f12, 0xc8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 82FC26C4: D1A100CC  stfs f13, 0xcc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 82FC26C8: D18100D0  stfs f12, 0xd0(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 82FC26CC: D00100D8  stfs f0, 0xd8(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 82FC26D0: D1A100DC  stfs f13, 0xdc(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 82FC26D4: D00100E0  stfs f0, 0xe0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82FC26D8: D1A100EC  stfs f13, 0xec(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 82FC26DC: D16100F0  stfs f11, 0xf0(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82FC26E0: D1A100F4  stfs f13, 0xf4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82FC26E4: D18100F8  stfs f12, 0xf8(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82FC26E8: D10100FC  stfs f8, 0xfc(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82FC26EC: D1810100  stfs f12, 0x100(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82FC26F0: D1A10104  stfs f13, 0x104(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82FC26F4: D0010108  stfs f0, 0x108(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82FC26F8: D101010C  stfs f8, 0x10c(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82FC26FC: D0010110  stfs f0, 0x110(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82FC2700: D1A10114  stfs f13, 0x114(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82FC2704: D101011C  stfs f8, 0x11c(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), tmp.u32 ) };
	pc = 0x82FC2708; continue 'dispatch;
            }
            0x82FC2708 => {
    //   block [0x82FC2708..0x82FC274C)
	// 82FC2708: C1790004  lfs f11, 4(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC270C: C15D0004  lfs f10, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82FC2710: C0190000  lfs f0, 0(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC2714: FF0A5800  fcmpu cr6, f10, f11
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[11].f64);
	// 82FC2718: C1990008  lfs f12, 8(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC271C: C119000C  lfs f8, 0xc(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82FC2720: 4198002C  blt cr6, 0x82fc274c
	if ctx.cr[6].lt {
	pc = 0x82FC274C; continue 'dispatch;
	}
	// 82FC2724: C1BDFFFC  lfs f13, -4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC2728: FF086800  fcmpu cr6, f8, f13
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[13].f64);
	// 82FC272C: 41980020  blt cr6, 0x82fc274c
	if ctx.cr[6].lt {
	pc = 0x82FC274C; continue 'dispatch;
	}
	// 82FC2730: C1BDFFF8  lfs f13, -8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC2734: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82FC2738: 41980014  blt cr6, 0x82fc274c
	if ctx.cr[6].lt {
	pc = 0x82FC274C; continue 'dispatch;
	}
	// 82FC273C: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC2740: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FC2744: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FC2748: 40980008  bge cr6, 0x82fc2750
	if !ctx.cr[6].lt {
	pc = 0x82FC2750; continue 'dispatch;
	}
	pc = 0x82FC274C; continue 'dispatch;
            }
            0x82FC274C => {
    //   block [0x82FC274C..0x82FC2750)
	// 82FC274C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82FC2750; continue 'dispatch;
            }
            0x82FC2750 => {
    //   block [0x82FC2750..0x82FC2760)
	// 82FC2750: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC2754: 4082000C  bne 0x82fc2760
	if !ctx.cr[0].eq {
	pc = 0x82FC2760; continue 'dispatch;
	}
	// 82FC2758: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC275C: 48000064  b 0x82fc27c0
	pc = 0x82FC27C0; continue 'dispatch;
            }
            0x82FC2760 => {
    //   block [0x82FC2760..0x82FC2774)
	// 82FC2760: C1BDFFF8  lfs f13, -8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC2764: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FC2768: 4099000C  ble cr6, 0x82fc2774
	if !ctx.cr[6].gt {
	pc = 0x82FC2774; continue 'dispatch;
	}
	// 82FC276C: FCA06890  fmr f5, f13
	ctx.f[5].f64 = ctx.f[13].f64;
	// 82FC2770: 48000008  b 0x82fc2778
	pc = 0x82FC2778; continue 'dispatch;
            }
            0x82FC2774 => {
    //   block [0x82FC2774..0x82FC2778)
	// 82FC2774: FCA00090  fmr f5, f0
	ctx.f[5].f64 = ctx.f[0].f64;
	pc = 0x82FC2778; continue 'dispatch;
            }
            0x82FC2778 => {
    //   block [0x82FC2778..0x82FC278C)
	// 82FC2778: C01D0000  lfs f0, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC277C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82FC2780: 4099000C  ble cr6, 0x82fc278c
	if !ctx.cr[6].gt {
	pc = 0x82FC278C; continue 'dispatch;
	}
	// 82FC2784: FCC06090  fmr f6, f12
	ctx.f[6].f64 = ctx.f[12].f64;
	// 82FC2788: 48000008  b 0x82fc2790
	pc = 0x82FC2790; continue 'dispatch;
            }
            0x82FC278C => {
    //   block [0x82FC278C..0x82FC2790)
	// 82FC278C: FCC00090  fmr f6, f0
	ctx.f[6].f64 = ctx.f[0].f64;
	pc = 0x82FC2790; continue 'dispatch;
            }
            0x82FC2790 => {
    //   block [0x82FC2790..0x82FC27A4)
	// 82FC2790: C01DFFFC  lfs f0, -4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC2794: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82FC2798: 4099000C  ble cr6, 0x82fc27a4
	if !ctx.cr[6].gt {
	pc = 0x82FC27A4; continue 'dispatch;
	}
	// 82FC279C: FCE00090  fmr f7, f0
	ctx.f[7].f64 = ctx.f[0].f64;
	// 82FC27A0: 48000008  b 0x82fc27a8
	pc = 0x82FC27A8; continue 'dispatch;
            }
            0x82FC27A4 => {
    //   block [0x82FC27A4..0x82FC27A8)
	// 82FC27A4: FCE05890  fmr f7, f11
	ctx.f[7].f64 = ctx.f[11].f64;
	pc = 0x82FC27A8; continue 'dispatch;
            }
            0x82FC27A8 => {
    //   block [0x82FC27A8..0x82FC27B8)
	// 82FC27A8: FF0A4000  fcmpu cr6, f10, f8
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[8].f64);
	// 82FC27AC: 4099000C  ble cr6, 0x82fc27b8
	if !ctx.cr[6].gt {
	pc = 0x82FC27B8; continue 'dispatch;
	}
	// 82FC27B0: FD204090  fmr f9, f8
	ctx.f[9].f64 = ctx.f[8].f64;
	// 82FC27B4: 48000008  b 0x82fc27bc
	pc = 0x82FC27BC; continue 'dispatch;
            }
            0x82FC27B8 => {
    //   block [0x82FC27B8..0x82FC27BC)
	// 82FC27B8: FD205090  fmr f9, f10
	ctx.f[9].f64 = ctx.f[10].f64;
	pc = 0x82FC27BC; continue 'dispatch;
            }
            0x82FC27BC => {
    //   block [0x82FC27BC..0x82FC27C0)
	// 82FC27BC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82FC27C0; continue 'dispatch;
            }
            0x82FC27C0 => {
    //   block [0x82FC27C0..0x82FC27DC)
	// 82FC27C0: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC27C4: 40820018  bne 0x82fc27dc
	if !ctx.cr[0].eq {
	pc = 0x82FC27DC; continue 'dispatch;
	}
	// 82FC27C8: D3FD0000  stfs f31, 0(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC27CC: D3FD0004  stfs f31, 4(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82FC27D0: D3FDFFF8  stfs f31, -8(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82FC27D4: D3FDFFFC  stfs f31, -4(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82FC27D8: 48000014  b 0x82fc27ec
	pc = 0x82FC27EC; continue 'dispatch;
            }
            0x82FC27DC => {
    //   block [0x82FC27DC..0x82FC27EC)
	// 82FC27DC: D0DD0000  stfs f6, 0(r29)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC27E0: D13D0004  stfs f9, 4(r29)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82FC27E4: D0BDFFF8  stfs f5, -8(r29)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82FC27E8: D0FDFFFC  stfs f7, -4(r29)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	pc = 0x82FC27EC; continue 'dispatch;
            }
            0x82FC27EC => {
    //   block [0x82FC27EC..0x82FC2810)
	// 82FC27EC: C01DFFF8  lfs f0, -8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC27F0: C1BD0000  lfs f13, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC27F4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82FC27F8: 40980018  bge cr6, 0x82fc2810
	if !ctx.cr[6].lt {
	pc = 0x82FC2810; continue 'dispatch;
	}
	// 82FC27FC: C19DFFFC  lfs f12, -4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC2800: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC2804: C17D0004  lfs f11, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC2808: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 82FC280C: 41980008  blt cr6, 0x82fc2814
	if ctx.cr[6].lt {
	pc = 0x82FC2814; continue 'dispatch;
	}
	pc = 0x82FC2810; continue 'dispatch;
            }
            0x82FC2810 => {
    //   block [0x82FC2810..0x82FC2814)
	// 82FC2810: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82FC2814; continue 'dispatch;
            }
            0x82FC2814 => {
    //   block [0x82FC2814..0x82FC2850)
	// 82FC2814: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC2818: 40820088  bne 0x82fc28a0
	if !ctx.cr[0].eq {
	pc = 0x82FC28A0; continue 'dispatch;
	}
	// 82FC281C: C19DFFFC  lfs f12, -4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC2820: 38A10074  addi r5, r1, 0x74
	ctx.r[5].s64 = ctx.r[1].s64 + 116;
	// 82FC2824: C17D0004  lfs f11, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC2828: 38DB0002  addi r6, r27, 2
	ctx.r[6].s64 = ctx.r[27].s64 + 2;
	// 82FC282C: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82FC2830: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	// 82FC2834: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82FC2838: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82FC283C: D181007C  stfs f12, 0x7c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82FC2840: D1A10080  stfs f13, 0x80(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82FC2844: D1610084  stfs f11, 0x84(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82FC2848: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82FC284C: D161008C  stfs f11, 0x8c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	pc = 0x82FC2850; continue 'dispatch;
            }
            0x82FC2850 => {
    //   block [0x82FC2850..0x82FC28A0)
	// 82FC2850: 3885FFFC  addi r4, r5, -4
	ctx.r[4].s64 = ctx.r[5].s64 + -4;
	// 82FC2854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC2858: 4BFFF731  bl 0x82fc1f88
	ctx.lr = 0x82FC285C;
	sub_82FC1F88(ctx, base);
	// 82FC285C: C005FFFC  lfs f0, -4(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC2860: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82FC2864: C1A50000  lfs f13, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC2868: EDA10372  fmuls f13, f1, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FC286C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82FC2870: 38A50008  addi r5, r5, 8
	ctx.r[5].s64 = ctx.r[5].s64 + 8;
	// 82FC2874: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82FC2878: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FC287C: FC00681E  fctiwz f0, f13
	ctx.f[0].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82FC2880: A1610056  lhz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82FC2884: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FC2888: B166FFFE  sth r11, -2(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(-2 as u32), ctx.r[11].u16 ) };
	// 82FC288C: A1410056  lhz r10, 0x56(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82FC2890: B1460000  sth r10, 0(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 82FC2894: 38C60004  addi r6, r6, 4
	ctx.r[6].s64 = ctx.r[6].s64 + 4;
	// 82FC2898: 4082FFB8  bne 0x82fc2850
	if !ctx.cr[0].eq {
	pc = 0x82FC2850; continue 'dispatch;
	}
	// 82FC289C: 48000020  b 0x82fc28bc
	pc = 0x82FC28BC; continue 'dispatch;
            }
            0x82FC28A0 => {
    //   block [0x82FC28A0..0x82FC28B0)
	// 82FC28A0: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 82FC28A4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82FC28A8: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 82FC28AC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x82FC28B0; continue 'dispatch;
            }
            0x82FC28B0 => {
    //   block [0x82FC28B0..0x82FC28BC)
	// 82FC28B0: B12B0000  sth r9, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 82FC28B4: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82FC28B8: 4200FFF8  bdnz 0x82fc28b0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82FC28B0; continue 'dispatch;
	}
	pc = 0x82FC28BC; continue 'dispatch;
            }
            0x82FC28BC => {
    //   block [0x82FC28BC..0x82FC2928)
	// 82FC28BC: 375AFFFF  addic. r26, r26, -1
	ctx.xer.ca = (ctx.r[26].u32 > (!(-1 as u32)));
	ctx.r[26].s64 = ctx.r[26].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82FC28C0: 3B7B0010  addi r27, r27, 0x10
	ctx.r[27].s64 = ctx.r[27].s64 + 16;
	// 82FC28C4: 3BBD0010  addi r29, r29, 0x10
	ctx.r[29].s64 = ctx.r[29].s64 + 16;
	// 82FC28C8: 4082FE40  bne 0x82fc2708
	if !ctx.cr[0].eq {
	pc = 0x82FC2708; continue 'dispatch;
	}
	// 82FC28CC: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 82FC28D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82FC28D4: 4BFA9F25  bl 0x82f6c7f8
	ctx.lr = 0x82FC28D8;
	sub_82F6C7F8(ctx, base);
	// 82FC28D8: C03C0000  lfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC28DC: 38610140  addi r3, r1, 0x140
	ctx.r[3].s64 = ctx.r[1].s64 + 320;
	// 82FC28E0: FCC0F890  fmr f6, f31
	ctx.f[6].f64 = ctx.f[31].f64;
	// 82FC28E4: FCA0F890  fmr f5, f31
	ctx.f[5].f64 = ctx.f[31].f64;
	// 82FC28E8: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82FC28EC: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82FC28F0: FC800890  fmr f4, f1
	ctx.f[4].f64 = ctx.f[1].f64;
	// 82FC28F4: 4BFA9F1D  bl 0x82f6c810
	ctx.lr = 0x82FC28F8;
	sub_82F6C810(ctx, base);
	// 82FC28F8: 38810140  addi r4, r1, 0x140
	ctx.r[4].s64 = ctx.r[1].s64 + 320;
	// 82FC28FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82FC2900: 4BFAA0A1  bl 0x82f6c9a0
	ctx.lr = 0x82FC2904;
	sub_82F6C9A0(ctx, base);
	// 82FC2904: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FC2908: 38610180  addi r3, r1, 0x180
	ctx.r[3].s64 = ctx.r[1].s64 + 384;
	// 82FC290C: 4BFA9EED  bl 0x82f6c7f8
	ctx.lr = 0x82FC2910;
	sub_82F6C7F8(ctx, base);
	// 82FC2910: 38810180  addi r4, r1, 0x180
	ctx.r[4].s64 = ctx.r[1].s64 + 384;
	// 82FC2914: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82FC2918: 4BFAA301  bl 0x82f6cc18
	ctx.lr = 0x82FC291C;
	sub_82F6CC18(ctx, base);
	// 82FC291C: 3BBF00B0  addi r29, r31, 0xb0
	ctx.r[29].s64 = ctx.r[31].s64 + 176;
	// 82FC2920: 3BDC00A0  addi r30, r28, 0xa0
	ctx.r[30].s64 = ctx.r[28].s64 + 160;
	// 82FC2924: 3BE00009  li r31, 9
	ctx.r[31].s64 = 9;
	pc = 0x82FC2928; continue 'dispatch;
            }
            0x82FC2928 => {
    //   block [0x82FC2928..0x82FC298C)
	// 82FC2928: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC292C: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82FC2930: 4BFA9EC9  bl 0x82f6c7f8
	ctx.lr = 0x82FC2934;
	sub_82F6C7F8(ctx, base);
	// 82FC2934: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FC2938: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82FC293C: 4BFAA0ED  bl 0x82f6ca28
	ctx.lr = 0x82FC2940;
	sub_82F6CA28(ctx, base);
	// 82FC2940: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 82FC2944: 38610160  addi r3, r1, 0x160
	ctx.r[3].s64 = ctx.r[1].s64 + 352;
	// 82FC2948: 4BFA9EB1  bl 0x82f6c7f8
	ctx.lr = 0x82FC294C;
	sub_82F6C7F8(ctx, base);
	// 82FC294C: 38810160  addi r4, r1, 0x160
	ctx.r[4].s64 = ctx.r[1].s64 + 352;
	// 82FC2950: 38610120  addi r3, r1, 0x120
	ctx.r[3].s64 = ctx.r[1].s64 + 288;
	// 82FC2954: 4BFAA2C5  bl 0x82f6cc18
	ctx.lr = 0x82FC2958;
	sub_82F6CC18(ctx, base);
	// 82FC2958: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82FC295C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC2960: 4BFA9E99  bl 0x82f6c7f8
	ctx.lr = 0x82FC2964;
	sub_82F6C7F8(ctx, base);
	// 82FC2964: 38810120  addi r4, r1, 0x120
	ctx.r[4].s64 = ctx.r[1].s64 + 288;
	// 82FC2968: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC296C: 4BFAA035  bl 0x82f6c9a0
	ctx.lr = 0x82FC2970;
	sub_82F6C9A0(ctx, base);
	// 82FC2970: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82FC2974: 3BBD0020  addi r29, r29, 0x20
	ctx.r[29].s64 = ctx.r[29].s64 + 32;
	// 82FC2978: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 82FC297C: 4082FFAC  bne 0x82fc2928
	if !ctx.cr[0].eq {
	pc = 0x82FC2928; continue 'dispatch;
	}
	// 82FC2980: 382101F0  addi r1, r1, 0x1f0
	ctx.r[1].s64 = ctx.r[1].s64 + 496;
	// 82FC2984: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82FC2988: 4BCE6AC0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC2990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC2990 size=248
    let mut pc: u32 = 0x82FC2990;
    'dispatch: loop {
        match pc {
            0x82FC2990 => {
    //   block [0x82FC2990..0x82FC29F0)
	// 82FC2990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC2994: 4BCE6A61  bl 0x82ca93f4
	ctx.lr = 0x82FC2998;
	sub_82CA93D0(ctx, base);
	// 82FC2998: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 82FC299C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC29A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC29A4: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82FC29A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC29AC: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 82FC29B0: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 82FC29B4: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 82FC29B8: 4BF3AF91  bl 0x82efd948
	ctx.lr = 0x82FC29BC;
	sub_82EFD948(ctx, base);
	// 82FC29BC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FC29C0: 3B7F0020  addi r27, r31, 0x20
	ctx.r[27].s64 = ctx.r[31].s64 + 32;
	// 82FC29C4: 396B695C  addi r11, r11, 0x695c
	ctx.r[11].s64 = ctx.r[11].s64 + 26972;
	// 82FC29C8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82FC29CC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC29D0: 4BFA9FA9  bl 0x82f6c978
	ctx.lr = 0x82FC29D4;
	sub_82F6C978(ctx, base);
	// 82FC29D4: 3B5F0040  addi r26, r31, 0x40
	ctx.r[26].s64 = ctx.r[31].s64 + 64;
	// 82FC29D8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82FC29DC: 4BFA9F9D  bl 0x82f6c978
	ctx.lr = 0x82FC29E0;
	sub_82F6C978(ctx, base);
	// 82FC29E0: 387F0090  addi r3, r31, 0x90
	ctx.r[3].s64 = ctx.r[31].s64 + 144;
	// 82FC29E4: 4BFA9F95  bl 0x82f6c978
	ctx.lr = 0x82FC29E8;
	sub_82F6C978(ctx, base);
	// 82FC29E8: 3B3F00B0  addi r25, r31, 0xb0
	ctx.r[25].s64 = ctx.r[31].s64 + 176;
	// 82FC29EC: 3B800008  li r28, 8
	ctx.r[28].s64 = 8;
	pc = 0x82FC29F0; continue 'dispatch;
            }
            0x82FC29F0 => {
    //   block [0x82FC29F0..0x82FC2A88)
	// 82FC29F0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82FC29F4: 4BFA9F85  bl 0x82f6c978
	ctx.lr = 0x82FC29F8;
	sub_82F6C978(ctx, base);
	// 82FC29F8: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82FC29FC: 3B390020  addi r25, r25, 0x20
	ctx.r[25].s64 = ctx.r[25].s64 + 32;
	// 82FC2A00: 4080FFF0  bge 0x82fc29f0
	if !ctx.cr[0].lt {
	pc = 0x82FC29F0; continue 'dispatch;
	}
	// 82FC2A04: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82FC2A08: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 82FC2A0C: 939F01D0  stw r28, 0x1d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), ctx.r[28].u32 ) };
	// 82FC2A10: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82FC2A14: 939F01D4  stw r28, 0x1d4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), ctx.r[28].u32 ) };
	// 82FC2A18: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82FC2A1C: 939F01D8  stw r28, 0x1d8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), ctx.r[28].u32 ) };
	// 82FC2A20: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC2A24: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82FC2A28: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC2A2C: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82FC2A30: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC2A34: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82FC2A38: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC2A3C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82FC2A40: 4BFA9DB9  bl 0x82f6c7f8
	ctx.lr = 0x82FC2A44;
	sub_82F6C7F8(ctx, base);
	// 82FC2A44: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82FC2A48: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82FC2A4C: 4BFA9DAD  bl 0x82f6c7f8
	ctx.lr = 0x82FC2A50;
	sub_82F6C7F8(ctx, base);
	// 82FC2A50: D3FF0060  stfs f31, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82FC2A54: C01D000C  lfs f0, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC2A58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC2A5C: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC2A60: C19D0004  lfs f12, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC2A64: C17D0000  lfs f11, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC2A68: D17F0064  stfs f11, 0x64(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82FC2A6C: D19F0068  stfs f12, 0x68(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82FC2A70: D1BF006C  stfs f13, 0x6c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82FC2A74: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82FC2A78: 9B9F0074  stb r28, 0x74(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[28].u8 ) };
	// 82FC2A7C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82FC2A80: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 82FC2A84: 4BCE69C0  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC2A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC2A88 size=76
    let mut pc: u32 = 0x82FC2A88;
    'dispatch: loop {
        match pc {
            0x82FC2A88 => {
    //   block [0x82FC2A88..0x82FC2AB8)
	// 82FC2A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC2A8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC2A90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC2A94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC2A98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC2A9C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC2AA0: 387F01D0  addi r3, r31, 0x1d0
	ctx.r[3].s64 = ctx.r[31].s64 + 464;
	// 82FC2AA4: 4BFFF975  bl 0x82fc2418
	ctx.lr = 0x82FC2AA8;
	sub_82FC2418(ctx, base);
	// 82FC2AA8: 807F01D0  lwz r3, 0x1d0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) } as u64;
	// 82FC2AAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC2AB0: 419A0008  beq cr6, 0x82fc2ab8
	if ctx.cr[6].eq {
	pc = 0x82FC2AB8; continue 'dispatch;
	}
	// 82FC2AB4: 4BF3ADED  bl 0x82efd8a0
	ctx.lr = 0x82FC2AB8;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC2AB8; continue 'dispatch;
            }
            0x82FC2AB8 => {
    //   block [0x82FC2AB8..0x82FC2AD4)
	// 82FC2AB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC2ABC: 4BF3AF5D  bl 0x82efda18
	ctx.lr = 0x82FC2AC0;
	sub_82EFDA18(ctx, base);
	// 82FC2AC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FC2AC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC2AC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC2ACC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC2AD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC2AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC2AD8 size=76
    let mut pc: u32 = 0x82FC2AD8;
    'dispatch: loop {
        match pc {
            0x82FC2AD8 => {
    //   block [0x82FC2AD8..0x82FC2B08)
	// 82FC2AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC2ADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC2AE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC2AE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC2AE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC2AEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC2AF0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC2AF4: 4BFFFF95  bl 0x82fc2a88
	ctx.lr = 0x82FC2AF8;
	sub_82FC2A88(ctx, base);
	// 82FC2AF8: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC2AFC: 4182000C  beq 0x82fc2b08
	if ctx.cr[0].eq {
	pc = 0x82FC2B08; continue 'dispatch;
	}
	// 82FC2B00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC2B04: 4BF3AD9D  bl 0x82efd8a0
	ctx.lr = 0x82FC2B08;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC2B08; continue 'dispatch;
            }
            0x82FC2B08 => {
    //   block [0x82FC2B08..0x82FC2B24)
	// 82FC2B08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC2B0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC2B10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC2B14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC2B18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC2B1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC2B20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC2B28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC2B28 size=124
    let mut pc: u32 = 0x82FC2B28;
    'dispatch: loop {
        match pc {
            0x82FC2B28 => {
    //   block [0x82FC2B28..0x82FC2B44)
	// 82FC2B28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC2B2C: 4BCE68DD  bl 0x82ca9408
	ctx.lr = 0x82FC2B30;
	sub_82CA93D0(ctx, base);
	// 82FC2B30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC2B34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC2B38: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 82FC2B3C: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82FC2B40: 3B9E0010  addi r28, r30, 0x10
	ctx.r[28].s64 = ctx.r[30].s64 + 16;
	pc = 0x82FC2B44; continue 'dispatch;
            }
            0x82FC2B44 => {
    //   block [0x82FC2B44..0x82FC2B88)
	// 82FC2B44: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC2B48: 4BFA9E31  bl 0x82f6c978
	ctx.lr = 0x82FC2B4C;
	sub_82F6C978(ctx, base);
	// 82FC2B4C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82FC2B50: 3B9C0040  addi r28, r28, 0x40
	ctx.r[28].s64 = ctx.r[28].s64 + 64;
	// 82FC2B54: 4080FFF0  bge 0x82fc2b44
	if !ctx.cr[0].lt {
	pc = 0x82FC2B44; continue 'dispatch;
	}
	// 82FC2B58: 387F00D4  addi r3, r31, 0xd4
	ctx.r[3].s64 = ctx.r[31].s64 + 212;
	// 82FC2B5C: 480042A5  bl 0x82fc6e00
	ctx.lr = 0x82FC2B60;
	sub_82FC6E00(ctx, base);
	// 82FC2B60: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82FC2B64: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82FC2B68: 915F00F0  stw r10, 0xf0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 82FC2B6C: 915F00F4  stw r10, 0xf4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), ctx.r[10].u32 ) };
	// 82FC2B70: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC2B74: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC2B78: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82FC2B7C: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82FC2B80: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82FC2B84: 915F00D0  stw r10, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	pc = 0x82FC2B88; continue 'dispatch;
            }
            0x82FC2B88 => {
    //   block [0x82FC2B88..0x82FC2BA4)
	// 82FC2B88: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82FC2B8C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC2B90: 3BDE0040  addi r30, r30, 0x40
	ctx.r[30].s64 = ctx.r[30].s64 + 64;
	// 82FC2B94: 4082FFF4  bne 0x82fc2b88
	if !ctx.cr[0].eq {
	pc = 0x82FC2B88; continue 'dispatch;
	}
	// 82FC2B98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC2B9C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC2BA0: 4BCE68B8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC2BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC2BA8 size=20
    let mut pc: u32 = 0x82FC2BA8;
    'dispatch: loop {
        match pc {
            0x82FC2BA8 => {
    //   block [0x82FC2BA8..0x82FC2BBC)
	// 82FC2BA8: 90830000  stw r4, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82FC2BAC: 90A30004  stw r5, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82FC2BB0: 90C30008  stw r6, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82FC2BB4: 90E3000C  stw r7, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82FC2BB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC2BC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC2BC0 size=8
    let mut pc: u32 = 0x82FC2BC0;
    'dispatch: loop {
        match pc {
            0x82FC2BC0 => {
    //   block [0x82FC2BC0..0x82FC2BC8)
	// 82FC2BC0: 908300D0  stw r4, 0xd0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), ctx.r[4].u32 ) };
	// 82FC2BC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC2BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FC2BC8 size=92
    let mut pc: u32 = 0x82FC2BC8;
    'dispatch: loop {
        match pc {
            0x82FC2BC8 => {
    //   block [0x82FC2BC8..0x82FC2BF8)
	// 82FC2BC8: C1A40000  lfs f13, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC2BCC: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82FC2BD0: FD606A10  fabs f11, f13
	ctx.f[11].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82FC2BD4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82FC2BD8: C00B0E70  lfs f0, 0xe70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC2BDC: C18A0C98  lfs f12, 0xc98(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3224 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC2BE0: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82FC2BE4: 4099001C  ble cr6, 0x82fc2c00
	if !ctx.cr[6].gt {
	pc = 0x82FC2C00; continue 'dispatch;
	}
	// 82FC2BE8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FC2BEC: 4099000C  ble cr6, 0x82fc2bf8
	if !ctx.cr[6].gt {
	pc = 0x82FC2BF8; continue 'dispatch;
	}
	// 82FC2BF0: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82FC2BF4: 48000008  b 0x82fc2bfc
	pc = 0x82FC2BFC; continue 'dispatch;
            }
            0x82FC2BF8 => {
    //   block [0x82FC2BF8..0x82FC2BFC)
	// 82FC2BF8: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	pc = 0x82FC2BFC; continue 'dispatch;
            }
            0x82FC2BFC => {
    //   block [0x82FC2BFC..0x82FC2C00)
	// 82FC2BFC: D1A40000  stfs f13, 0(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82FC2C00; continue 'dispatch;
            }
            0x82FC2C00 => {
    //   block [0x82FC2C00..0x82FC2C1C)
	// 82FC2C00: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC2C04: FD606A10  fabs f11, f13
	ctx.f[11].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82FC2C08: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82FC2C0C: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	// 82FC2C10: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FC2C14: 41990008  bgt cr6, 0x82fc2c1c
	if ctx.cr[6].gt {
	pc = 0x82FC2C1C; continue 'dispatch;
	}
	// 82FC2C18: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	pc = 0x82FC2C1C; continue 'dispatch;
            }
            0x82FC2C1C => {
    //   block [0x82FC2C1C..0x82FC2C24)
	// 82FC2C1C: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82FC2C20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC2C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FC2C28 size=160
    let mut pc: u32 = 0x82FC2C28;
    'dispatch: loop {
        match pc {
            0x82FC2C28 => {
    //   block [0x82FC2C28..0x82FC2C80)
	// 82FC2C28: C004000C  lfs f0, 0xc(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC2C2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC2C30: C1A40004  lfs f13, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC2C34: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82FC2C38: C0040008  lfs f0, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC2C3C: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82FC2C40: C1640000  lfs f11, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC2C44: FD400210  fabs f10, f0
	ctx.f[10].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82FC2C48: FD205A10  fabs f9, f11
	ctx.f[9].u64 = ctx.f[11].u64 & !0x8000_0000_0000_0000u64;
	// 82FC2C4C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC2C50: C00B0BE8  lfs f0, 0xbe8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3048 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC2C54: C16A0C14  lfs f11, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC2C58: ED0D6028  fsubs f8, f13, f12
	ctx.f[8].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FC2C5C: ECE95028  fsubs f7, f9, f10
	ctx.f[7].f64 = (((ctx.f[9].f64 - ctx.f[10].f64) as f32) as f64);
	// 82FC2C60: FDA8636E  fsel f13, f8, f13, f12
	ctx.f[13].f64 = if ctx.f[8].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[12].f64 };
	// 82FC2C64: FD87526E  fsel f12, f7, f9, f10
	ctx.f[12].f64 = if ctx.f[7].f64 >= 0.0 { ctx.f[9].f64 } else { ctx.f[10].f64 };
	// 82FC2C68: ED4C6828  fsubs f10, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FC2C6C: FDAA6B2E  fsel f13, f10, f12, f13
	ctx.f[13].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[13].f64 };
	// 82FC2C70: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FC2C74: 4098000C  bge cr6, 0x82fc2c80
	if !ctx.cr[6].lt {
	pc = 0x82FC2C80; continue 'dispatch;
	}
	// 82FC2C78: D163000C  stfs f11, 0xc(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82FC2C7C: 4800003C  b 0x82fc2cb8
	pc = 0x82FC2CB8; continue 'dispatch;
            }
            0x82FC2C80 => {
    //   block [0x82FC2C80..0x82FC2CB8)
	// 82FC2C80: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC2C84: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC2C88: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82FC2C8C: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82FC2C90: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC2C94: C18A0BF4  lfs f12, 0xbf4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3060 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC2C98: ED41603A  fmadds f10, f1, f0, f12
	ctx.f[10].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82FC2C9C: C0090C78  lfs f0, 0xc78(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3192 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC2CA0: C188696C  lfs f12, 0x696c(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(26988 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC2CA4: ED205028  fsubs f9, f0, f10
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 82FC2CA8: FC09502E  fsel f0, f9, f0, f10
	ctx.f[0].f64 = if ctx.f[9].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[10].f64 };
	// 82FC2CAC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82FC2CB0: EC0C0024  fdivs f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 82FC2CB4: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x82FC2CB8; continue 'dispatch;
            }
            0x82FC2CB8 => {
    //   block [0x82FC2CB8..0x82FC2CC8)
	// 82FC2CB8: C003000C  lfs f0, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC2CBC: EC0B0024  fdivs f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	// 82FC2CC0: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82FC2CC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC2CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC2CC8 size=88
    let mut pc: u32 = 0x82FC2CC8;
    'dispatch: loop {
        match pc {
            0x82FC2CC8 => {
    //   block [0x82FC2CC8..0x82FC2CF8)
	// 82FC2CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC2CCC: 4BCE6741  bl 0x82ca940c
	ctx.lr = 0x82FC2CD0;
	sub_82CA93D0(ctx, base);
	// 82FC2CD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC2CD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC2CD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC2CDC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FC2CE0: 817F0064  lwz r11, 0x64(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82FC2CE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC2CE8: 409A0010  bne cr6, 0x82fc2cf8
	if !ctx.cr[6].eq {
	pc = 0x82FC2CF8; continue 'dispatch;
	}
	// 82FC2CEC: 3860004C  li r3, 0x4c
	ctx.r[3].s64 = 76;
	// 82FC2CF0: 4BF3AB71  bl 0x82efd860
	ctx.lr = 0x82FC2CF4;
	sub_82EFD860(ctx, base);
	// 82FC2CF4: 907F0064  stw r3, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[3].u32 ) };
	pc = 0x82FC2CF8; continue 'dispatch;
            }
            0x82FC2CF8 => {
    //   block [0x82FC2CF8..0x82FC2CFC)
	// 82FC2CF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82FC2CFC; continue 'dispatch;
            }
            0x82FC2CFC => {
    //   block [0x82FC2CFC..0x82FC2D20)
	// 82FC2CFC: 815F0064  lwz r10, 0x64(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82FC2D00: 7C0BF42E  lfsx f0, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC2D04: 7C0B552E  stfsx f0, r11, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82FC2D08: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82FC2D0C: 2B0B004C  cmplwi cr6, r11, 0x4c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 76 as u32, &mut ctx.xer);
	// 82FC2D10: 4198FFEC  blt cr6, 0x82fc2cfc
	if ctx.cr[6].lt {
	pc = 0x82FC2CFC; continue 'dispatch;
	}
	// 82FC2D14: 93BF0068  stw r29, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82FC2D18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC2D1C: 4BCE6740  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC2D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC2D20 size=24
    let mut pc: u32 = 0x82FC2D20;
    'dispatch: loop {
        match pc {
            0x82FC2D20 => {
    //   block [0x82FC2D20..0x82FC2D38)
	// 82FC2D20: 81630064  lwz r11, 0x64(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as u64;
	// 82FC2D24: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 82FC2D28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC2D2C: 409A000C  bne cr6, 0x82fc2d38
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82FC2D38);
		return;
	}
	// 82FC2D30: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82FC2D34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC2D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC2D68 size=112
    let mut pc: u32 = 0x82FC2D68;
    'dispatch: loop {
        match pc {
            0x82FC2D68 => {
    //   block [0x82FC2D68..0x82FC2D90)
	// 82FC2D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC2D6C: 4BCE6699  bl 0x82ca9404
	ctx.lr = 0x82FC2D70;
	sub_82CA93D0(ctx, base);
	// 82FC2D70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC2D74: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82FC2D78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC2D7C: 39400048  li r10, 0x48
	ctx.r[10].s64 = 72;
	// 82FC2D80: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82FC2D84: 7F7FE050  subf r27, r31, r28
	ctx.r[27].s64 = ctx.r[28].s64 - ctx.r[31].s64;
	// 82FC2D88: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC2D8C: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82FC2D90; continue 'dispatch;
            }
            0x82FC2D90 => {
    //   block [0x82FC2D90..0x82FC2DAC)
	// 82FC2D90: 7D3B5A2E  lhzx r9, r27, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FC2D94: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC2D98: B12B0000  sth r9, 0(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 82FC2D9C: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82FC2DA0: 4082FFF0  bne 0x82fc2d90
	if !ctx.cr[0].eq {
	pc = 0x82FC2D90; continue 'dispatch;
	}
	// 82FC2DA4: 3BDF00A0  addi r30, r31, 0xa0
	ctx.r[30].s64 = ctx.r[31].s64 + 160;
	// 82FC2DA8: 3BA00009  li r29, 9
	ctx.r[29].s64 = 9;
	pc = 0x82FC2DAC; continue 'dispatch;
            }
            0x82FC2DAC => {
    //   block [0x82FC2DAC..0x82FC2DD8)
	// 82FC2DAC: 7C9EDA14  add r4, r30, r27
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[27].u64;
	// 82FC2DB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC2DB4: 4BFA9A45  bl 0x82f6c7f8
	ctx.lr = 0x82FC2DB8;
	sub_82F6C7F8(ctx, base);
	// 82FC2DB8: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82FC2DBC: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 82FC2DC0: 4082FFEC  bne 0x82fc2dac
	if !ctx.cr[0].eq {
	pc = 0x82FC2DAC; continue 'dispatch;
	}
	// 82FC2DC4: 817C01C0  lwz r11, 0x1c0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(448 as u32) ) } as u64;
	// 82FC2DC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC2DCC: 917F01C0  stw r11, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[11].u32 ) };
	// 82FC2DD0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC2DD4: 4BCE6680  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC2DD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC2DD8 size=188
    let mut pc: u32 = 0x82FC2DD8;
    'dispatch: loop {
        match pc {
            0x82FC2DD8 => {
    //   block [0x82FC2DD8..0x82FC2E10)
	// 82FC2DD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC2DDC: 4BCE6629  bl 0x82ca9404
	ctx.lr = 0x82FC2DE0;
	sub_82CA93D0(ctx, base);
	// 82FC2DE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC2DE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC2DE8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82FC2DEC: 3BDF00D4  addi r30, r31, 0xd4
	ctx.r[30].s64 = ctx.r[31].s64 + 212;
	// 82FC2DF0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82FC2DF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC2DF8: 480040D1  bl 0x82fc6ec8
	ctx.lr = 0x82FC2DFC;
	sub_82FC6EC8(ctx, base);
	// 82FC2DFC: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC2E00: 40820010  bne 0x82fc2e10
	if !ctx.cr[0].eq {
	pc = 0x82FC2E10; continue 'dispatch;
	}
	// 82FC2E04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FC2E08: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82FC2E0C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82FC2E10; continue 'dispatch;
            }
            0x82FC2E10 => {
    //   block [0x82FC2E10..0x82FC2E38)
	// 82FC2E10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC2E14: 839B01B4  lwz r28, 0x1b4(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(436 as u32) ) } as u64;
	// 82FC2E18: 480040B1  bl 0x82fc6ec8
	ctx.lr = 0x82FC2E1C;
	sub_82FC6EC8(ctx, base);
	// 82FC2E1C: 1D7C0003  mulli r11, r28, 3
	ctx.r[11].s32 = ((ctx.r[28].s32 as i64 * 3 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC2E20: 7C8B1A14  add r4, r11, r3
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82FC2E24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC2E28: 480044B1  bl 0x82fc72d8
	ctx.lr = 0x82FC2E2C;
	sub_82FC72D8(ctx, base);
	// 82FC2E2C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82FC2E30: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82FC2E34: 419A0058  beq cr6, 0x82fc2e8c
	if ctx.cr[6].eq {
	pc = 0x82FC2E8C; continue 'dispatch;
	}
	pc = 0x82FC2E38; continue 'dispatch;
            }
            0x82FC2E38 => {
    //   block [0x82FC2E38..0x82FC2E8C)
	// 82FC2E38: 817B01C0  lwz r11, 0x1c0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(448 as u32) ) } as u64;
	// 82FC2E3C: 57E9C23A  rlwinm r9, r31, 0x18, 8, 0x1d
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 82FC2E40: 57EA05BE  clrlwi r10, r31, 0x16
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x000003FFu64;
	// 82FC2E44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC2E48: 1D4A000C  mulli r10, r10, 0xc
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 12 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC2E4C: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FC2E50: 7D2B502E  lwzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FC2E54: 7FAB5214  add r29, r11, r10
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC2E58: 5524043E  clrlwi r4, r9, 0x10
	ctx.r[4].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 82FC2E5C: 48004515  bl 0x82fc7370
	ctx.lr = 0x82FC2E60;
	sub_82FC7370(ctx, base);
	// 82FC2E60: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC2E64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC2E68: 5564043E  clrlwi r4, r11, 0x10
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82FC2E6C: 48004505  bl 0x82fc7370
	ctx.lr = 0x82FC2E70;
	sub_82FC7370(ctx, base);
	// 82FC2E70: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC2E74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC2E78: 5564043E  clrlwi r4, r11, 0x10
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82FC2E7C: 480044F5  bl 0x82fc7370
	ctx.lr = 0x82FC2E80;
	sub_82FC7370(ctx, base);
	// 82FC2E80: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82FC2E84: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82FC2E88: 4198FFB0  blt cr6, 0x82fc2e38
	if ctx.cr[6].lt {
	pc = 0x82FC2E38; continue 'dispatch;
	}
	pc = 0x82FC2E8C; continue 'dispatch;
            }
            0x82FC2E8C => {
    //   block [0x82FC2E8C..0x82FC2E94)
	// 82FC2E8C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC2E90: 4BCE65C4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC2E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC2E98 size=108
    let mut pc: u32 = 0x82FC2E98;
    'dispatch: loop {
        match pc {
            0x82FC2E98 => {
    //   block [0x82FC2E98..0x82FC2ED0)
	// 82FC2E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC2E9C: 4BCE6571  bl 0x82ca940c
	ctx.lr = 0x82FC2EA0;
	sub_82CA93D0(ctx, base);
	// 82FC2EA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC2EA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC2EA8: 3BDF00F0  addi r30, r31, 0xf0
	ctx.r[30].s64 = ctx.r[31].s64 + 240;
	// 82FC2EAC: 807F00F0  lwz r3, 0xf0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(240 as u32) ) } as u64;
	// 82FC2EB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC2EB4: 419A001C  beq cr6, 0x82fc2ed0
	if ctx.cr[6].eq {
	pc = 0x82FC2ED0; continue 'dispatch;
	}
	// 82FC2EB8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC2EBC: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82FC2EC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC2EC4: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82FC2EC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC2ECC: 4E800421  bctrl
	ctx.lr = 0x82FC2ED0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC2ED0 => {
    //   block [0x82FC2ED0..0x82FC2F04)
	// 82FC2ED0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82FC2ED4: 387F00D4  addi r3, r31, 0xd4
	ctx.r[3].s64 = ctx.r[31].s64 + 212;
	// 82FC2ED8: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82FC2EDC: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82FC2EE0: 480043A9  bl 0x82fc7288
	ctx.lr = 0x82FC2EE4;
	sub_82FC7288(ctx, base);
	// 82FC2EE4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82FC2EE8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82FC2EEC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC2EF0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC2EF4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82FC2EF8: 93BF00D0  stw r29, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[29].u32 ) };
	// 82FC2EFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC2F00: 4BCE655C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC2F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC2F08 size=428
    let mut pc: u32 = 0x82FC2F08;
    'dispatch: loop {
        match pc {
            0x82FC2F08 => {
    //   block [0x82FC2F08..0x82FC2F94)
	// 82FC2F08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC2F0C: 4BCE64D9  bl 0x82ca93e4
	ctx.lr = 0x82FC2F10;
	sub_82CA93D0(ctx, base);
	// 82FC2F10: DBE1FF88  stfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 82FC2F14: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC2F18: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82FC2F1C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82FC2F20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC2F24: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 82FC2F28: 3ADF00D4  addi r22, r31, 0xd4
	ctx.r[22].s64 = ctx.r[31].s64 + 212;
	// 82FC2F2C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82FC2F30: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC2F34: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82FC2F38: 7CF53B78  mr r21, r7
	ctx.r[21].u64 = ctx.r[7].u64;
	// 82FC2F3C: 7D144378  mr r20, r8
	ctx.r[20].u64 = ctx.r[8].u64;
	// 82FC2F40: 7D595378  mr r25, r10
	ctx.r[25].u64 = ctx.r[10].u64;
	// 82FC2F44: 830B0014  lwz r24, 0x14(r11)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC2F48: 48003F81  bl 0x82fc6ec8
	ctx.lr = 0x82FC2F4C;
	sub_82FC6EC8(ctx, base);
	// 82FC2F4C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC2F50: 41820158  beq 0x82fc30a8
	if ctx.cr[0].eq {
	pc = 0x82FC30A8; continue 'dispatch;
	}
	// 82FC2F54: 89610137  lbz r11, 0x137(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(311 as u32) ) } as u64;
	// 82FC2F58: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 82FC2F5C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC2F60: 418200C4  beq 0x82fc3024
	if ctx.cr[0].eq {
	pc = 0x82FC3024; continue 'dispatch;
	}
	// 82FC2F64: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82FC2F68: 92610058  stw r19, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[19].u32 ) };
	// 82FC2F6C: 9261005C  stw r19, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[19].u32 ) };
	// 82FC2F70: 92610060  stw r19, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[19].u32 ) };
	// 82FC2F74: 419A0088  beq cr6, 0x82fc2ffc
	if ctx.cr[6].eq {
	pc = 0x82FC2FFC; continue 'dispatch;
	}
	// 82FC2F78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC2F7C: 7E7B9B78  mr r27, r19
	ctx.r[27].u64 = ctx.r[19].u64;
	// 82FC2F80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC2F84: 40990078  ble cr6, 0x82fc2ffc
	if !ctx.cr[6].gt {
	pc = 0x82FC2FFC; continue 'dispatch;
	}
	// 82FC2F88: 3B810058  addi r28, r1, 0x58
	ctx.r[28].s64 = ctx.r[1].s64 + 88;
	// 82FC2F8C: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82FC2F90: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	pc = 0x82FC2F94; continue 'dispatch;
            }
            0x82FC2F94 => {
    //   block [0x82FC2F94..0x82FC2FAC)
	// 82FC2F94: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82FC2F98: 419A0014  beq cr6, 0x82fc2fac
	if ctx.cr[6].eq {
	pc = 0x82FC2FAC; continue 'dispatch;
	}
	// 82FC2F9C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC2FA0: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC2FA4: 7CEBCA14  add r7, r11, r25
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 82FC2FA8: 48000008  b 0x82fc2fb0
	pc = 0x82FC2FB0; continue 'dispatch;
            }
            0x82FC2FAC => {
    //   block [0x82FC2FAC..0x82FC2FB0)
	// 82FC2FAC: 7E679B78  mr r7, r19
	ctx.r[7].u64 = ctx.r[19].u64;
	pc = 0x82FC2FB0; continue 'dispatch;
            }
            0x82FC2FB0 => {
    //   block [0x82FC2FB0..0x82FC2FE0)
	// 82FC2FB0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC2FB4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82FC2FB8: 419A0028  beq cr6, 0x82fc2fe0
	if ctx.cr[6].eq {
	pc = 0x82FC2FE0; continue 'dispatch;
	}
	// 82FC2FBC: 1D6B0030  mulli r11, r11, 0x30
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 48 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC2FC0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82FC2FC4: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82FC2FC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC2FCC: 7C6BBA14  add r3, r11, r23
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 82FC2FD0: 4BFFE5F1  bl 0x82fc15c0
	ctx.lr = 0x82FC2FD4;
	sub_82FC15C0(ctx, base);
	// 82FC2FD4: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC2FD8: 41820008  beq 0x82fc2fe0
	if ctx.cr[0].eq {
	pc = 0x82FC2FE0; continue 'dispatch;
	}
	// 82FC2FDC: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x82FC2FE0; continue 'dispatch;
            }
            0x82FC2FE0 => {
    //   block [0x82FC2FE0..0x82FC2FFC)
	// 82FC2FE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC2FE4: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82FC2FE8: 3BDE0040  addi r30, r30, 0x40
	ctx.r[30].s64 = ctx.r[30].s64 + 64;
	// 82FC2FEC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82FC2FF0: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82FC2FF4: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC2FF8: 4198FF9C  blt cr6, 0x82fc2f94
	if ctx.cr[6].lt {
	pc = 0x82FC2F94; continue 'dispatch;
	}
	pc = 0x82FC2FFC; continue 'dispatch;
            }
            0x82FC2FFC => {
    //   block [0x82FC2FFC..0x82FC3024)
	// 82FC2FFC: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3000: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82FC3004: 80E10060  lwz r7, 0x60(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82FC3008: 809F00D0  lwz r4, 0xd0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 82FC300C: 80C1005C  lwz r6, 0x5c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82FC3010: 80A10058  lwz r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82FC3014: 816B0058  lwz r11, 0x58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 82FC3018: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC301C: 4E800421  bctrl
	ctx.lr = 0x82FC3020;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC3020: 48000038  b 0x82fc3058
	pc = 0x82FC3058; continue 'dispatch;
            }
            0x82FC3024 => {
    //   block [0x82FC3024..0x82FC303C)
	// 82FC3024: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82FC3028: 419A0014  beq cr6, 0x82fc303c
	if ctx.cr[6].eq {
	pc = 0x82FC303C; continue 'dispatch;
	}
	// 82FC302C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC3030: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC3034: 7CCBCA14  add r6, r11, r25
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 82FC3038: 48000008  b 0x82fc3040
	pc = 0x82FC3040; continue 'dispatch;
            }
            0x82FC303C => {
    //   block [0x82FC303C..0x82FC3040)
	// 82FC303C: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	pc = 0x82FC3040; continue 'dispatch;
            }
            0x82FC3040 => {
    //   block [0x82FC3040..0x82FC3058)
	// 82FC3040: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC3044: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82FC3048: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82FC304C: 1D6B0030  mulli r11, r11, 0x30
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 48 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC3050: 7C6BBA14  add r3, r11, r23
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 82FC3054: 4BFFE8D5  bl 0x82fc1928
	ctx.lr = 0x82FC3058;
	sub_82FC1928(ctx, base);
	pc = 0x82FC3058; continue 'dispatch;
            }
            0x82FC3058 => {
    //   block [0x82FC3058..0x82FC30A8)
	// 82FC3058: 397F00F0  addi r11, r31, 0xf0
	ctx.r[11].s64 = ctx.r[31].s64 + 240;
	// 82FC305C: 9A610054  stb r19, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[19].u8 ) };
	// 82FC3060: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82FC3064: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82FC3068: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82FC306C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82FC3070: 48003E61  bl 0x82fc6ed0
	ctx.lr = 0x82FC3074;
	sub_82FC6ED0(ctx, base);
	// 82FC3074: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82FC3078: 83F80000  lwz r31, 0(r24)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC307C: 48003E4D  bl 0x82fc6ec8
	ctx.lr = 0x82FC3080;
	sub_82FC6EC8(ctx, base);
	// 82FC3080: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82FC3084: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 82FC3088: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82FC308C: 7D035B96  divwu r8, r3, r11
	ctx.r[8].u32 = ctx.r[3].u32 / ctx.r[11].u32;
	// 82FC3090: 7E86A378  mr r6, r20
	ctx.r[6].u64 = ctx.r[20].u64;
	// 82FC3094: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82FC3098: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 82FC309C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82FC30A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82FC30A4: 4E800421  bctrl
	ctx.lr = 0x82FC30A8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC30A8 => {
    //   block [0x82FC30A8..0x82FC30B4)
	// 82FC30A8: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82FC30AC: CBE1FF88  lfd f31, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 82FC30B0: 4BCE6384  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC30B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC30B8 size=108
    let mut pc: u32 = 0x82FC30B8;
    'dispatch: loop {
        match pc {
            0x82FC30B8 => {
    //   block [0x82FC30B8..0x82FC30F4)
	// 82FC30B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC30BC: 4BCE6351  bl 0x82ca940c
	ctx.lr = 0x82FC30C0;
	sub_82CA93D0(ctx, base);
	// 82FC30C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC30C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC30C8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82FC30CC: 3BFE00F0  addi r31, r30, 0xf0
	ctx.r[31].s64 = ctx.r[30].s64 + 240;
	// 82FC30D0: 807E00F0  lwz r3, 0xf0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(240 as u32) ) } as u64;
	// 82FC30D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC30D8: 419A001C  beq cr6, 0x82fc30f4
	if ctx.cr[6].eq {
	pc = 0x82FC30F4; continue 'dispatch;
	}
	// 82FC30DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC30E0: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 82FC30E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC30E8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82FC30EC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC30F0: 4E800421  bctrl
	ctx.lr = 0x82FC30F4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC30F4 => {
    //   block [0x82FC30F4..0x82FC3118)
	// 82FC30F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC30F8: 387E00D4  addi r3, r30, 0xd4
	ctx.r[3].s64 = ctx.r[30].s64 + 212;
	// 82FC30FC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC3100: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC3104: 48003E2D  bl 0x82fc6f30
	ctx.lr = 0x82FC3108;
	sub_82FC6F30(ctx, base);
	// 82FC3108: 57AB07FF  clrlwi. r11, r29, 0x1f
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC310C: 4182000C  beq 0x82fc3118
	if ctx.cr[0].eq {
	pc = 0x82FC3118; continue 'dispatch;
	}
	// 82FC3110: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC3114: 4BF3A78D  bl 0x82efd8a0
	ctx.lr = 0x82FC3118;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC3118; continue 'dispatch;
            }
            0x82FC3118 => {
    //   block [0x82FC3118..0x82FC3124)
	// 82FC3118: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC311C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC3120: 4BCE633C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC3128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC3128 size=148
    let mut pc: u32 = 0x82FC3128;
    'dispatch: loop {
        match pc {
            0x82FC3128 => {
    //   block [0x82FC3128..0x82FC315C)
	// 82FC3128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC312C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC3130: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC3134: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC3138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC313C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC3140: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC3144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC3148: 419A005C  beq cr6, 0x82fc31a4
	if ctx.cr[6].eq {
	pc = 0x82FC31A4; continue 'dispatch;
	}
	// 82FC314C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC3150: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC3154: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC3158: 3BCBFFFC  addi r30, r11, -4
	ctx.r[30].s64 = ctx.r[11].s64 + -4;
	pc = 0x82FC315C; continue 'dispatch;
            }
            0x82FC315C => {
    //   block [0x82FC315C..0x82FC3178)
	// 82FC315C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC3160: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FC3164: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC3168: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC316C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC3170: 419A0008  beq cr6, 0x82fc3178
	if ctx.cr[6].eq {
	pc = 0x82FC3178; continue 'dispatch;
	}
	// 82FC3174: 4BF3A72D  bl 0x82efd8a0
	ctx.lr = 0x82FC3178;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC3178; continue 'dispatch;
            }
            0x82FC3178 => {
    //   block [0x82FC3178..0x82FC31A4)
	// 82FC3178: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC317C: 3BDEFFFC  addi r30, r30, -4
	ctx.r[30].s64 = ctx.r[30].s64 + -4;
	// 82FC3180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC3184: 409AFFD8  bne cr6, 0x82fc315c
	if !ctx.cr[6].eq {
	pc = 0x82FC315C; continue 'dispatch;
	}
	// 82FC3188: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC318C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC3190: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FC3194: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC3198: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC319C: 419A0008  beq cr6, 0x82fc31a4
	if ctx.cr[6].eq {
	pc = 0x82FC31A4; continue 'dispatch;
	}
	// 82FC31A0: 4BF3A701  bl 0x82efd8a0
	ctx.lr = 0x82FC31A4;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC31A4; continue 'dispatch;
            }
            0x82FC31A4 => {
    //   block [0x82FC31A4..0x82FC31BC)
	// 82FC31A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC31A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC31AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC31B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC31B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC31B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC31C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC31C0 size=196
    let mut pc: u32 = 0x82FC31C0;
    'dispatch: loop {
        match pc {
            0x82FC31C0 => {
    //   block [0x82FC31C0..0x82FC31F8)
	// 82FC31C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC31C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC31C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC31CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC31D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC31D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC31D8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC31DC: 556A17BF  rlwinm. r10, r11, 2, 0x1e, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC31E0: 41820028  beq 0x82fc3208
	if ctx.cr[0].eq {
	pc = 0x82FC3208; continue 'dispatch;
	}
	// 82FC31E4: 55690FFF  rlwinm. r9, r11, 1, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC31E8: 41820010  beq 0x82fc31f8
	if ctx.cr[0].eq {
	pc = 0x82FC31F8; continue 'dispatch;
	}
	// 82FC31EC: 556900BE  clrlwi r9, r11, 2
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82FC31F0: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82FC31F4: 41980078  blt cr6, 0x82fc326c
	if ctx.cr[6].lt {
	pc = 0x82FC326C; continue 'dispatch;
	}
	pc = 0x82FC31F8; continue 'dispatch;
            }
            0x82FC31F8 => {
    //   block [0x82FC31F8..0x82FC3208)
	// 82FC31F8: 554A07FF  clrlwi. r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC31FC: 4182000C  beq 0x82fc3208
	if ctx.cr[0].eq {
	pc = 0x82FC3208; continue 'dispatch;
	}
	// 82FC3200: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FC3204: 419A0068  beq cr6, 0x82fc326c
	if ctx.cr[6].eq {
	pc = 0x82FC326C; continue 'dispatch;
	}
	pc = 0x82FC3208; continue 'dispatch;
            }
            0x82FC3208 => {
    //   block [0x82FC3208..0x82FC322C)
	// 82FC3208: 556B0002  rlwinm r11, r11, 0, 0, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC320C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3210: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FC3214: 7D6B2378  or r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[4].u64;
	// 82FC3218: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC321C: 409A001C  bne cr6, 0x82fc3238
	if !ctx.cr[6].eq {
	pc = 0x82FC3238; continue 'dispatch;
	}
	// 82FC3220: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC3224: 419A0008  beq cr6, 0x82fc322c
	if ctx.cr[6].eq {
	pc = 0x82FC322C; continue 'dispatch;
	}
	// 82FC3228: 4BF3A679  bl 0x82efd8a0
	ctx.lr = 0x82FC322C;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC322C; continue 'dispatch;
            }
            0x82FC322C => {
    //   block [0x82FC322C..0x82FC3238)
	// 82FC322C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC3230: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC3234: 48000038  b 0x82fc326c
	pc = 0x82FC326C; continue 'dispatch;
            }
            0x82FC3238 => {
    //   block [0x82FC3238..0x82FC3250)
	// 82FC3238: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC323C: 419A0014  beq cr6, 0x82fc3250
	if ctx.cr[6].eq {
	pc = 0x82FC3250; continue 'dispatch;
	}
	// 82FC3240: 5484083C  slwi r4, r4, 1
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82FC3244: 4BF3A63D  bl 0x82efd880
	ctx.lr = 0x82FC3248;
	sub_82EFD880(ctx, base);
	// 82FC3248: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82FC324C: 48000020  b 0x82fc326c
	pc = 0x82FC326C; continue 'dispatch;
            }
            0x82FC3250 => {
    //   block [0x82FC3250..0x82FC326C)
	// 82FC3250: 549E083C  slwi r30, r4, 1
	ctx.r[30].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82FC3254: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC3258: 4BF3A609  bl 0x82efd860
	ctx.lr = 0x82FC325C;
	sub_82EFD860(ctx, base);
	// 82FC325C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82FC3260: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC3264: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82FC3268: 4BCE6749  bl 0x82ca99b0
	ctx.lr = 0x82FC326C;
	sub_82CA99B0(ctx, base);
	pc = 0x82FC326C; continue 'dispatch;
            }
            0x82FC326C => {
    //   block [0x82FC326C..0x82FC3284)
	// 82FC326C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC3270: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC3274: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC3278: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC327C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC3280: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC3288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC3288 size=196
    let mut pc: u32 = 0x82FC3288;
    'dispatch: loop {
        match pc {
            0x82FC3288 => {
    //   block [0x82FC3288..0x82FC32C0)
	// 82FC3288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC328C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC3290: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC3294: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC3298: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC329C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC32A0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC32A4: 556A17BF  rlwinm. r10, r11, 2, 0x1e, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC32A8: 41820028  beq 0x82fc32d0
	if ctx.cr[0].eq {
	pc = 0x82FC32D0; continue 'dispatch;
	}
	// 82FC32AC: 55690FFF  rlwinm. r9, r11, 1, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC32B0: 41820010  beq 0x82fc32c0
	if ctx.cr[0].eq {
	pc = 0x82FC32C0; continue 'dispatch;
	}
	// 82FC32B4: 556900BE  clrlwi r9, r11, 2
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82FC32B8: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82FC32BC: 41980078  blt cr6, 0x82fc3334
	if ctx.cr[6].lt {
	pc = 0x82FC3334; continue 'dispatch;
	}
	pc = 0x82FC32C0; continue 'dispatch;
            }
            0x82FC32C0 => {
    //   block [0x82FC32C0..0x82FC32D0)
	// 82FC32C0: 554A07FF  clrlwi. r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC32C4: 4182000C  beq 0x82fc32d0
	if ctx.cr[0].eq {
	pc = 0x82FC32D0; continue 'dispatch;
	}
	// 82FC32C8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FC32CC: 419A0068  beq cr6, 0x82fc3334
	if ctx.cr[6].eq {
	pc = 0x82FC3334; continue 'dispatch;
	}
	pc = 0x82FC32D0; continue 'dispatch;
            }
            0x82FC32D0 => {
    //   block [0x82FC32D0..0x82FC32F4)
	// 82FC32D0: 556B0002  rlwinm r11, r11, 0, 0, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC32D4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC32D8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FC32DC: 7D6B2378  or r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[4].u64;
	// 82FC32E0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC32E4: 409A001C  bne cr6, 0x82fc3300
	if !ctx.cr[6].eq {
	pc = 0x82FC3300; continue 'dispatch;
	}
	// 82FC32E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC32EC: 419A0008  beq cr6, 0x82fc32f4
	if ctx.cr[6].eq {
	pc = 0x82FC32F4; continue 'dispatch;
	}
	// 82FC32F0: 4BF3A5B1  bl 0x82efd8a0
	ctx.lr = 0x82FC32F4;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC32F4; continue 'dispatch;
            }
            0x82FC32F4 => {
    //   block [0x82FC32F4..0x82FC3300)
	// 82FC32F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC32F8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC32FC: 48000038  b 0x82fc3334
	pc = 0x82FC3334; continue 'dispatch;
            }
            0x82FC3300 => {
    //   block [0x82FC3300..0x82FC3318)
	// 82FC3300: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC3304: 419A0014  beq cr6, 0x82fc3318
	if ctx.cr[6].eq {
	pc = 0x82FC3318; continue 'dispatch;
	}
	// 82FC3308: 5484402E  slwi r4, r4, 8
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shl(8);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82FC330C: 4BF3A575  bl 0x82efd880
	ctx.lr = 0x82FC3310;
	sub_82EFD880(ctx, base);
	// 82FC3310: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82FC3314: 48000020  b 0x82fc3334
	pc = 0x82FC3334; continue 'dispatch;
            }
            0x82FC3318 => {
    //   block [0x82FC3318..0x82FC3334)
	// 82FC3318: 549E402E  slwi r30, r4, 8
	ctx.r[30].u32 = ctx.r[4].u32.wrapping_shl(8);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82FC331C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC3320: 4BF3A541  bl 0x82efd860
	ctx.lr = 0x82FC3324;
	sub_82EFD860(ctx, base);
	// 82FC3324: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82FC3328: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC332C: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82FC3330: 4BCE6681  bl 0x82ca99b0
	ctx.lr = 0x82FC3334;
	sub_82CA99B0(ctx, base);
	pc = 0x82FC3334; continue 'dispatch;
            }
            0x82FC3334 => {
    //   block [0x82FC3334..0x82FC334C)
	// 82FC3334: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC3338: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC333C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC3340: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC3344: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC3348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC3350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC3350 size=196
    let mut pc: u32 = 0x82FC3350;
    'dispatch: loop {
        match pc {
            0x82FC3350 => {
    //   block [0x82FC3350..0x82FC3388)
	// 82FC3350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC3354: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC3358: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC335C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC3360: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC3364: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC3368: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC336C: 556A17BF  rlwinm. r10, r11, 2, 0x1e, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC3370: 41820028  beq 0x82fc3398
	if ctx.cr[0].eq {
	pc = 0x82FC3398; continue 'dispatch;
	}
	// 82FC3374: 55690FFF  rlwinm. r9, r11, 1, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC3378: 41820010  beq 0x82fc3388
	if ctx.cr[0].eq {
	pc = 0x82FC3388; continue 'dispatch;
	}
	// 82FC337C: 556900BE  clrlwi r9, r11, 2
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82FC3380: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82FC3384: 41980078  blt cr6, 0x82fc33fc
	if ctx.cr[6].lt {
	pc = 0x82FC33FC; continue 'dispatch;
	}
	pc = 0x82FC3388; continue 'dispatch;
            }
            0x82FC3388 => {
    //   block [0x82FC3388..0x82FC3398)
	// 82FC3388: 554A07FF  clrlwi. r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC338C: 4182000C  beq 0x82fc3398
	if ctx.cr[0].eq {
	pc = 0x82FC3398; continue 'dispatch;
	}
	// 82FC3390: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FC3394: 419A0068  beq cr6, 0x82fc33fc
	if ctx.cr[6].eq {
	pc = 0x82FC33FC; continue 'dispatch;
	}
	pc = 0x82FC3398; continue 'dispatch;
            }
            0x82FC3398 => {
    //   block [0x82FC3398..0x82FC33BC)
	// 82FC3398: 556B0002  rlwinm r11, r11, 0, 0, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC339C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC33A0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FC33A4: 7D6B2378  or r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[4].u64;
	// 82FC33A8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC33AC: 409A001C  bne cr6, 0x82fc33c8
	if !ctx.cr[6].eq {
	pc = 0x82FC33C8; continue 'dispatch;
	}
	// 82FC33B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC33B4: 419A0008  beq cr6, 0x82fc33bc
	if ctx.cr[6].eq {
	pc = 0x82FC33BC; continue 'dispatch;
	}
	// 82FC33B8: 4BF3A4E9  bl 0x82efd8a0
	ctx.lr = 0x82FC33BC;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC33BC; continue 'dispatch;
            }
            0x82FC33BC => {
    //   block [0x82FC33BC..0x82FC33C8)
	// 82FC33BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC33C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC33C4: 48000038  b 0x82fc33fc
	pc = 0x82FC33FC; continue 'dispatch;
            }
            0x82FC33C8 => {
    //   block [0x82FC33C8..0x82FC33E0)
	// 82FC33C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC33CC: 419A0014  beq cr6, 0x82fc33e0
	if ctx.cr[6].eq {
	pc = 0x82FC33E0; continue 'dispatch;
	}
	// 82FC33D0: 1C840060  mulli r4, r4, 0x60
	ctx.r[4].s32 = ((ctx.r[4].s32 as i64 * 96 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82FC33D4: 4BF3A4AD  bl 0x82efd880
	ctx.lr = 0x82FC33D8;
	sub_82EFD880(ctx, base);
	// 82FC33D8: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82FC33DC: 48000020  b 0x82fc33fc
	pc = 0x82FC33FC; continue 'dispatch;
            }
            0x82FC33E0 => {
    //   block [0x82FC33E0..0x82FC33FC)
	// 82FC33E0: 1FC40060  mulli r30, r4, 0x60
	ctx.r[30].s32 = ((ctx.r[4].s32 as i64 * 96 as i64) as i32);
	ctx.r[30].s64 = ctx.r[30].s32 as i64;
	// 82FC33E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC33E8: 4BF3A479  bl 0x82efd860
	ctx.lr = 0x82FC33EC;
	sub_82EFD860(ctx, base);
	// 82FC33EC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82FC33F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC33F4: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82FC33F8: 4BCE65B9  bl 0x82ca99b0
	ctx.lr = 0x82FC33FC;
	sub_82CA99B0(ctx, base);
	pc = 0x82FC33FC; continue 'dispatch;
            }
            0x82FC33FC => {
    //   block [0x82FC33FC..0x82FC3414)
	// 82FC33FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC3400: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC3404: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC3408: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC340C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC3410: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC3418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC3418 size=196
    let mut pc: u32 = 0x82FC3418;
    'dispatch: loop {
        match pc {
            0x82FC3418 => {
    //   block [0x82FC3418..0x82FC3450)
	// 82FC3418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC341C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC3420: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC3424: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC3428: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC342C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC3430: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC3434: 556A17BF  rlwinm. r10, r11, 2, 0x1e, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC3438: 41820028  beq 0x82fc3460
	if ctx.cr[0].eq {
	pc = 0x82FC3460; continue 'dispatch;
	}
	// 82FC343C: 55690FFF  rlwinm. r9, r11, 1, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC3440: 41820010  beq 0x82fc3450
	if ctx.cr[0].eq {
	pc = 0x82FC3450; continue 'dispatch;
	}
	// 82FC3444: 556900BE  clrlwi r9, r11, 2
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82FC3448: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82FC344C: 41980078  blt cr6, 0x82fc34c4
	if ctx.cr[6].lt {
	pc = 0x82FC34C4; continue 'dispatch;
	}
	pc = 0x82FC3450; continue 'dispatch;
            }
            0x82FC3450 => {
    //   block [0x82FC3450..0x82FC3460)
	// 82FC3450: 554A07FF  clrlwi. r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC3454: 4182000C  beq 0x82fc3460
	if ctx.cr[0].eq {
	pc = 0x82FC3460; continue 'dispatch;
	}
	// 82FC3458: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FC345C: 419A0068  beq cr6, 0x82fc34c4
	if ctx.cr[6].eq {
	pc = 0x82FC34C4; continue 'dispatch;
	}
	pc = 0x82FC3460; continue 'dispatch;
            }
            0x82FC3460 => {
    //   block [0x82FC3460..0x82FC3484)
	// 82FC3460: 556B0002  rlwinm r11, r11, 0, 0, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC3464: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3468: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FC346C: 7D6B2378  or r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[4].u64;
	// 82FC3470: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC3474: 409A001C  bne cr6, 0x82fc3490
	if !ctx.cr[6].eq {
	pc = 0x82FC3490; continue 'dispatch;
	}
	// 82FC3478: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC347C: 419A0008  beq cr6, 0x82fc3484
	if ctx.cr[6].eq {
	pc = 0x82FC3484; continue 'dispatch;
	}
	// 82FC3480: 4BF3A421  bl 0x82efd8a0
	ctx.lr = 0x82FC3484;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC3484; continue 'dispatch;
            }
            0x82FC3484 => {
    //   block [0x82FC3484..0x82FC3490)
	// 82FC3484: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC3488: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC348C: 48000038  b 0x82fc34c4
	pc = 0x82FC34C4; continue 'dispatch;
            }
            0x82FC3490 => {
    //   block [0x82FC3490..0x82FC34A8)
	// 82FC3490: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC3494: 419A0014  beq cr6, 0x82fc34a8
	if ctx.cr[6].eq {
	pc = 0x82FC34A8; continue 'dispatch;
	}
	// 82FC3498: 54842834  slwi r4, r4, 5
	ctx.r[4].u32 = ctx.r[4].u32.wrapping_shl(5);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82FC349C: 4BF3A3E5  bl 0x82efd880
	ctx.lr = 0x82FC34A0;
	sub_82EFD880(ctx, base);
	// 82FC34A0: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82FC34A4: 48000020  b 0x82fc34c4
	pc = 0x82FC34C4; continue 'dispatch;
            }
            0x82FC34A8 => {
    //   block [0x82FC34A8..0x82FC34C4)
	// 82FC34A8: 549E2834  slwi r30, r4, 5
	ctx.r[30].u32 = ctx.r[4].u32.wrapping_shl(5);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82FC34AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC34B0: 4BF3A3B1  bl 0x82efd860
	ctx.lr = 0x82FC34B4;
	sub_82EFD860(ctx, base);
	// 82FC34B4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82FC34B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC34BC: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82FC34C0: 4BCE64F1  bl 0x82ca99b0
	ctx.lr = 0x82FC34C4;
	sub_82CA99B0(ctx, base);
	pc = 0x82FC34C4; continue 'dispatch;
            }
            0x82FC34C4 => {
    //   block [0x82FC34C4..0x82FC34DC)
	// 82FC34C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC34C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC34CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC34D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC34D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC34D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC34E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC34E0 size=196
    let mut pc: u32 = 0x82FC34E0;
    'dispatch: loop {
        match pc {
            0x82FC34E0 => {
    //   block [0x82FC34E0..0x82FC3518)
	// 82FC34E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC34E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC34E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC34EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC34F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC34F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC34F8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC34FC: 556A17BF  rlwinm. r10, r11, 2, 0x1e, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC3500: 41820028  beq 0x82fc3528
	if ctx.cr[0].eq {
	pc = 0x82FC3528; continue 'dispatch;
	}
	// 82FC3504: 55690FFF  rlwinm. r9, r11, 1, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC3508: 41820010  beq 0x82fc3518
	if ctx.cr[0].eq {
	pc = 0x82FC3518; continue 'dispatch;
	}
	// 82FC350C: 556900BE  clrlwi r9, r11, 2
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82FC3510: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82FC3514: 41980078  blt cr6, 0x82fc358c
	if ctx.cr[6].lt {
	pc = 0x82FC358C; continue 'dispatch;
	}
	pc = 0x82FC3518; continue 'dispatch;
            }
            0x82FC3518 => {
    //   block [0x82FC3518..0x82FC3528)
	// 82FC3518: 554A07FF  clrlwi. r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC351C: 4182000C  beq 0x82fc3528
	if ctx.cr[0].eq {
	pc = 0x82FC3528; continue 'dispatch;
	}
	// 82FC3520: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FC3524: 419A0068  beq cr6, 0x82fc358c
	if ctx.cr[6].eq {
	pc = 0x82FC358C; continue 'dispatch;
	}
	pc = 0x82FC3528; continue 'dispatch;
            }
            0x82FC3528 => {
    //   block [0x82FC3528..0x82FC354C)
	// 82FC3528: 556B0002  rlwinm r11, r11, 0, 0, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC352C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3530: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FC3534: 7D6B2378  or r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[4].u64;
	// 82FC3538: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC353C: 409A001C  bne cr6, 0x82fc3558
	if !ctx.cr[6].eq {
	pc = 0x82FC3558; continue 'dispatch;
	}
	// 82FC3540: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC3544: 419A0008  beq cr6, 0x82fc354c
	if ctx.cr[6].eq {
	pc = 0x82FC354C; continue 'dispatch;
	}
	// 82FC3548: 4BF3A359  bl 0x82efd8a0
	ctx.lr = 0x82FC354C;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC354C; continue 'dispatch;
            }
            0x82FC354C => {
    //   block [0x82FC354C..0x82FC3558)
	// 82FC354C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC3550: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC3554: 48000038  b 0x82fc358c
	pc = 0x82FC358C; continue 'dispatch;
            }
            0x82FC3558 => {
    //   block [0x82FC3558..0x82FC3570)
	// 82FC3558: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC355C: 419A0014  beq cr6, 0x82fc3570
	if ctx.cr[6].eq {
	pc = 0x82FC3570; continue 'dispatch;
	}
	// 82FC3560: 1C8401D0  mulli r4, r4, 0x1d0
	ctx.r[4].s32 = ((ctx.r[4].s32 as i64 * 464 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82FC3564: 4BF3A31D  bl 0x82efd880
	ctx.lr = 0x82FC3568;
	sub_82EFD880(ctx, base);
	// 82FC3568: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82FC356C: 48000020  b 0x82fc358c
	pc = 0x82FC358C; continue 'dispatch;
            }
            0x82FC3570 => {
    //   block [0x82FC3570..0x82FC358C)
	// 82FC3570: 1FC401D0  mulli r30, r4, 0x1d0
	ctx.r[30].s32 = ((ctx.r[4].s32 as i64 * 464 as i64) as i32);
	ctx.r[30].s64 = ctx.r[30].s32 as i64;
	// 82FC3574: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC3578: 4BF3A2E9  bl 0x82efd860
	ctx.lr = 0x82FC357C;
	sub_82EFD860(ctx, base);
	// 82FC357C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82FC3580: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC3584: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82FC3588: 4BCE6429  bl 0x82ca99b0
	ctx.lr = 0x82FC358C;
	sub_82CA99B0(ctx, base);
	pc = 0x82FC358C; continue 'dispatch;
            }
            0x82FC358C => {
    //   block [0x82FC358C..0x82FC35A4)
	// 82FC358C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC3590: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC3594: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC3598: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC359C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC35A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC35A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FC35A8 size=160
    let mut pc: u32 = 0x82FC35A8;
    'dispatch: loop {
        match pc {
            0x82FC35A8 => {
    //   block [0x82FC35A8..0x82FC3648)
	// 82FC35A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC35AC: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82FC35B0: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82FC35B4: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82FC35B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC35BC: C18A0A4C  lfs f12, 0xa4c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2636 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC35C0: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82FC35C4: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82FC35C8: C0080C18  lfs f0, 0xc18(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC35CC: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 82FC35D0: C1A70BFC  lfs f13, 0xbfc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC35D4: C1660C14  lfs f11, 0xc14(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3092 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC35D8: 90A30000  stw r5, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82FC35DC: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82FC35E0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82FC35E4: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82FC35E8: 91230008  stw r9, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82FC35EC: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82FC35F0: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82FC35F4: D1A30020  stfs f13, 0x20(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82FC35F8: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82FC35FC: D1A30024  stfs f13, 0x24(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82FC3600: D1630028  stfs f11, 0x28(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82FC3604: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82FC3608: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82FC360C: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82FC3610: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82FC3614: 9143003C  stw r10, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[10].u32 ) };
	// 82FC3618: 99630040  stb r11, 0x40(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u8 ) };
	// 82FC361C: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82FC3620: 91630048  stw r11, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82FC3624: 9163004C  stw r11, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82FC3628: 91630050  stw r11, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82FC362C: 91430054  stw r10, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82FC3630: 91630058  stw r11, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82FC3634: 9163005C  stw r11, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82FC3638: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82FC363C: 91630064  stw r11, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82FC3640: 91430068  stw r10, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82FC3644: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC3648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FC3648 size=596
    let mut pc: u32 = 0x82FC3648;
    'dispatch: loop {
        match pc {
            0x82FC3648 => {
    //   block [0x82FC3648..0x82FC389C)
	// 82FC3648: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC364C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82FC3650: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC3654: 39400100  li r10, 0x100
	ctx.r[10].s64 = 256;
	// 82FC3658: 99030004  stb r8, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u8 ) };
	// 82FC365C: 39200040  li r9, 0x40
	ctx.r[9].s64 = 64;
	// 82FC3660: 99030005  stb r8, 5(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(5 as u32), ctx.r[8].u8 ) };
	// 82FC3664: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82FC3668: 99030006  stb r8, 6(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(6 as u32), ctx.r[8].u8 ) };
	// 82FC366C: 38C00400  li r6, 0x400
	ctx.r[6].s64 = 1024;
	// 82FC3670: 99030007  stb r8, 7(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(7 as u32), ctx.r[8].u8 ) };
	// 82FC3674: 39076964  addi r8, r7, 0x6964
	ctx.r[8].s64 = ctx.r[7].s64 + 26980;
	// 82FC3678: 99630008  stb r11, 8(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 82FC367C: 3CA08200  lis r5, -0x7e00
	ctx.r[5].s64 = -2113929216;
	// 82FC3680: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82FC3684: 3C803FFF  lis r4, 0x3fff
	ctx.r[4].s64 = 1073676288;
	// 82FC3688: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82FC368C: C1A76964  lfs f13, 0x6964(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(26980 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC3690: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82FC3694: 6087FFFF  ori r7, r4, 0xffff
	ctx.r[7].u64 = ctx.r[4].u64 | 65535;
	// 82FC3698: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82FC369C: C0080004  lfs f0, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC36A0: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82FC36A4: C1850C18  lfs f12, 0xc18(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(3096 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC36A8: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82FC36AC: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82FC36B0: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82FC36B4: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82FC36B8: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82FC36BC: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82FC36C0: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82FC36C4: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82FC36C8: 91430040  stw r10, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 82FC36CC: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82FC36D0: 91630048  stw r11, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82FC36D4: 9163004C  stw r11, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82FC36D8: 91630050  stw r11, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82FC36DC: 91230054  stw r9, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82FC36E0: 91630058  stw r11, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82FC36E4: 9163005C  stw r11, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82FC36E8: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82FC36EC: 91630064  stw r11, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82FC36F0: 91430068  stw r10, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 82FC36F4: 9163006C  stw r11, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82FC36F8: 91630070  stw r11, 0x70(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82FC36FC: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82FC3700: 91630078  stw r11, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 82FC3704: 9123007C  stw r9, 0x7c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	// 82FC3708: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82FC370C: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82FC3710: 91630088  stw r11, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82FC3714: 9163008C  stw r11, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82FC3718: 91630090  stw r11, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82FC371C: 91630094  stw r11, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82FC3720: 91630098  stw r11, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82FC3724: 90C3009C  stw r6, 0x9c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(156 as u32), ctx.r[6].u32 ) };
	// 82FC3728: 916300A0  stw r11, 0xa0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[11].u32 ) };
	// 82FC372C: 916300A4  stw r11, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 82FC3730: 916300A8  stw r11, 0xa8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), ctx.r[11].u32 ) };
	// 82FC3734: 916300AC  stw r11, 0xac(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 82FC3738: 916300B0  stw r11, 0xb0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 82FC373C: 916300B4  stw r11, 0xb4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 82FC3740: 916300B8  stw r11, 0xb8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 82FC3744: 916300BC  stw r11, 0xbc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), ctx.r[11].u32 ) };
	// 82FC3748: 916300C0  stw r11, 0xc0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82FC374C: 916300C4  stw r11, 0xc4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), ctx.r[11].u32 ) };
	// 82FC3750: 916300C8  stw r11, 0xc8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 82FC3754: 916300CC  stw r11, 0xcc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(204 as u32), ctx.r[11].u32 ) };
	// 82FC3758: 916300D0  stw r11, 0xd0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82FC375C: 916300D4  stw r11, 0xd4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 82FC3760: 916300D8  stw r11, 0xd8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	// 82FC3764: 916300DC  stw r11, 0xdc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	// 82FC3768: 912300E0  stw r9, 0xe0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), ctx.r[9].u32 ) };
	// 82FC376C: 916300E4  stw r11, 0xe4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), ctx.r[11].u32 ) };
	// 82FC3770: 916300E8  stw r11, 0xe8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82FC3774: 916300EC  stw r11, 0xec(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(236 as u32), ctx.r[11].u32 ) };
	// 82FC3778: D00300F8  stfs f0, 0xf8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82FC377C: D00300FC  stfs f0, 0xfc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(252 as u32), tmp.u32 ) };
	// 82FC3780: D1A30100  stfs f13, 0x100(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82FC3784: D1A30104  stfs f13, 0x104(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82FC3788: D1830108  stfs f12, 0x108(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82FC378C: D183010C  stfs f12, 0x10c(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82FC3790: 90E300F0  stw r7, 0xf0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(240 as u32), ctx.r[7].u32 ) };
	// 82FC3794: 916300F4  stw r11, 0xf4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(244 as u32), ctx.r[11].u32 ) };
	// 82FC3798: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82FC379C: 91630110  stw r11, 0x110(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 82FC37A0: 91630114  stw r11, 0x114(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(276 as u32), ctx.r[11].u32 ) };
	// 82FC37A4: 91630118  stw r11, 0x118(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(280 as u32), ctx.r[11].u32 ) };
	// 82FC37A8: 9163011C  stw r11, 0x11c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(284 as u32), ctx.r[11].u32 ) };
	// 82FC37AC: 91630120  stw r11, 0x120(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(288 as u32), ctx.r[11].u32 ) };
	// 82FC37B0: 91630124  stw r11, 0x124(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 82FC37B4: 91630128  stw r11, 0x128(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(296 as u32), ctx.r[11].u32 ) };
	// 82FC37B8: 9143012C  stw r10, 0x12c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(300 as u32), ctx.r[10].u32 ) };
	// 82FC37BC: 91630138  stw r11, 0x138(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(312 as u32), ctx.r[11].u32 ) };
	// 82FC37C0: 9163013C  stw r11, 0x13c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 82FC37C4: 91630140  stw r11, 0x140(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82FC37C8: 91630144  stw r11, 0x144(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(324 as u32), ctx.r[11].u32 ) };
	// 82FC37CC: 91630148  stw r11, 0x148(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 82FC37D0: 9163014C  stw r11, 0x14c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(332 as u32), ctx.r[11].u32 ) };
	// 82FC37D4: 91630150  stw r11, 0x150(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(336 as u32), ctx.r[11].u32 ) };
	// 82FC37D8: 91630154  stw r11, 0x154(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(340 as u32), ctx.r[11].u32 ) };
	// 82FC37DC: 91630158  stw r11, 0x158(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(344 as u32), ctx.r[11].u32 ) };
	// 82FC37E0: 9163015C  stw r11, 0x15c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(348 as u32), ctx.r[11].u32 ) };
	// 82FC37E4: 91030160  stw r8, 0x160(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(352 as u32), ctx.r[8].u32 ) };
	// 82FC37E8: 91630164  stw r11, 0x164(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(356 as u32), ctx.r[11].u32 ) };
	// 82FC37EC: 91630168  stw r11, 0x168(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(360 as u32), ctx.r[11].u32 ) };
	// 82FC37F0: 9163016C  stw r11, 0x16c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 82FC37F4: 91630170  stw r11, 0x170(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(368 as u32), ctx.r[11].u32 ) };
	// 82FC37F8: 91230174  stw r9, 0x174(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(372 as u32), ctx.r[9].u32 ) };
	// 82FC37FC: 91630178  stw r11, 0x178(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(376 as u32), ctx.r[11].u32 ) };
	// 82FC3800: 9163017C  stw r11, 0x17c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(380 as u32), ctx.r[11].u32 ) };
	// 82FC3804: 91630180  stw r11, 0x180(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(384 as u32), ctx.r[11].u32 ) };
	// 82FC3808: 91630184  stw r11, 0x184(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 82FC380C: 91230188  stw r9, 0x188(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(392 as u32), ctx.r[9].u32 ) };
	// 82FC3810: 9163018C  stw r11, 0x18c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 82FC3814: 91630190  stw r11, 0x190(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(400 as u32), ctx.r[11].u32 ) };
	// 82FC3818: 91630194  stw r11, 0x194(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82FC381C: 91630198  stw r11, 0x198(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(408 as u32), ctx.r[11].u32 ) };
	// 82FC3820: 9143019C  stw r10, 0x19c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(412 as u32), ctx.r[10].u32 ) };
	// 82FC3824: 916301A0  stw r11, 0x1a0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(416 as u32), ctx.r[11].u32 ) };
	// 82FC3828: 916301A4  stw r11, 0x1a4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 82FC382C: 916301A8  stw r11, 0x1a8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
	// 82FC3830: 916301AC  stw r11, 0x1ac(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(428 as u32), ctx.r[11].u32 ) };
	// 82FC3834: 914301B0  stw r10, 0x1b0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(432 as u32), ctx.r[10].u32 ) };
	// 82FC3838: 916301B4  stw r11, 0x1b4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(436 as u32), ctx.r[11].u32 ) };
	// 82FC383C: 916301B8  stw r11, 0x1b8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(440 as u32), ctx.r[11].u32 ) };
	// 82FC3840: 916301BC  stw r11, 0x1bc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(444 as u32), ctx.r[11].u32 ) };
	// 82FC3844: 916301C0  stw r11, 0x1c0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(448 as u32), ctx.r[11].u32 ) };
	// 82FC3848: 914301C4  stw r10, 0x1c4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(452 as u32), ctx.r[10].u32 ) };
	// 82FC384C: 916301C8  stw r11, 0x1c8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(456 as u32), ctx.r[11].u32 ) };
	// 82FC3850: 916301CC  stw r11, 0x1cc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(460 as u32), ctx.r[11].u32 ) };
	// 82FC3854: 916301D0  stw r11, 0x1d0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(464 as u32), ctx.r[11].u32 ) };
	// 82FC3858: 916301D4  stw r11, 0x1d4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(468 as u32), ctx.r[11].u32 ) };
	// 82FC385C: 914301D8  stw r10, 0x1d8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(472 as u32), ctx.r[10].u32 ) };
	// 82FC3860: 916301DC  stw r11, 0x1dc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(476 as u32), ctx.r[11].u32 ) };
	// 82FC3864: 916301E0  stw r11, 0x1e0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(480 as u32), ctx.r[11].u32 ) };
	// 82FC3868: 916301E4  stw r11, 0x1e4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(484 as u32), ctx.r[11].u32 ) };
	// 82FC386C: 916301E8  stw r11, 0x1e8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(488 as u32), ctx.r[11].u32 ) };
	// 82FC3870: 914301EC  stw r10, 0x1ec(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(492 as u32), ctx.r[10].u32 ) };
	// 82FC3874: 916301F0  stw r11, 0x1f0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(496 as u32), ctx.r[11].u32 ) };
	// 82FC3878: 916301F4  stw r11, 0x1f4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(500 as u32), ctx.r[11].u32 ) };
	// 82FC387C: 916301F8  stw r11, 0x1f8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(504 as u32), ctx.r[11].u32 ) };
	// 82FC3880: 916301FC  stw r11, 0x1fc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(508 as u32), ctx.r[11].u32 ) };
	// 82FC3884: 91430200  stw r10, 0x200(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(512 as u32), ctx.r[10].u32 ) };
	// 82FC3888: 91630204  stw r11, 0x204(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(516 as u32), ctx.r[11].u32 ) };
	// 82FC388C: 91630208  stw r11, 0x208(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(520 as u32), ctx.r[11].u32 ) };
	// 82FC3890: 9163020C  stw r11, 0x20c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(524 as u32), ctx.r[11].u32 ) };
	// 82FC3894: 91630210  stw r11, 0x210(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(528 as u32), ctx.r[11].u32 ) };
	// 82FC3898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC38A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC38A0 size=360
    let mut pc: u32 = 0x82FC38A0;
    'dispatch: loop {
        match pc {
            0x82FC38A0 => {
    //   block [0x82FC38A0..0x82FC390C)
	// 82FC38A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC38A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC38A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC38AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC38B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC38B4: 387F01F0  addi r3, r31, 0x1f0
	ctx.r[3].s64 = ctx.r[31].s64 + 496;
	// 82FC38B8: 4BFFF871  bl 0x82fc3128
	ctx.lr = 0x82FC38BC;
	sub_82FC3128(ctx, base);
	// 82FC38BC: 387F01DC  addi r3, r31, 0x1dc
	ctx.r[3].s64 = ctx.r[31].s64 + 476;
	// 82FC38C0: 4BFFF869  bl 0x82fc3128
	ctx.lr = 0x82FC38C4;
	sub_82FC3128(ctx, base);
	// 82FC38C4: 387F01C8  addi r3, r31, 0x1c8
	ctx.r[3].s64 = ctx.r[31].s64 + 456;
	// 82FC38C8: 4BFFF861  bl 0x82fc3128
	ctx.lr = 0x82FC38CC;
	sub_82FC3128(ctx, base);
	// 82FC38CC: 387F01B4  addi r3, r31, 0x1b4
	ctx.r[3].s64 = ctx.r[31].s64 + 436;
	// 82FC38D0: 4BFFF859  bl 0x82fc3128
	ctx.lr = 0x82FC38D4;
	sub_82FC3128(ctx, base);
	// 82FC38D4: 387F01A0  addi r3, r31, 0x1a0
	ctx.r[3].s64 = ctx.r[31].s64 + 416;
	// 82FC38D8: 4BFFF851  bl 0x82fc3128
	ctx.lr = 0x82FC38DC;
	sub_82FC3128(ctx, base);
	// 82FC38DC: 387F018C  addi r3, r31, 0x18c
	ctx.r[3].s64 = ctx.r[31].s64 + 396;
	// 82FC38E0: 4BFFF849  bl 0x82fc3128
	ctx.lr = 0x82FC38E4;
	sub_82FC3128(ctx, base);
	// 82FC38E4: 387F0178  addi r3, r31, 0x178
	ctx.r[3].s64 = ctx.r[31].s64 + 376;
	// 82FC38E8: 4BFFF841  bl 0x82fc3128
	ctx.lr = 0x82FC38EC;
	sub_82FC3128(ctx, base);
	// 82FC38EC: 387F0164  addi r3, r31, 0x164
	ctx.r[3].s64 = ctx.r[31].s64 + 356;
	// 82FC38F0: 4BFFF839  bl 0x82fc3128
	ctx.lr = 0x82FC38F4;
	sub_82FC3128(ctx, base);
	// 82FC38F4: 387F0150  addi r3, r31, 0x150
	ctx.r[3].s64 = ctx.r[31].s64 + 336;
	// 82FC38F8: 4BFFF831  bl 0x82fc3128
	ctx.lr = 0x82FC38FC;
	sub_82FC3128(ctx, base);
	// 82FC38FC: 807F014C  lwz r3, 0x14c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(332 as u32) ) } as u64;
	// 82FC3900: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC3904: 419A0008  beq cr6, 0x82fc390c
	if ctx.cr[6].eq {
	pc = 0x82FC390C; continue 'dispatch;
	}
	// 82FC3908: 4BF39F99  bl 0x82efd8a0
	ctx.lr = 0x82FC390C;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC390C; continue 'dispatch;
            }
            0x82FC390C => {
    //   block [0x82FC390C..0x82FC391C)
	// 82FC390C: 807F0140  lwz r3, 0x140(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(320 as u32) ) } as u64;
	// 82FC3910: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC3914: 419A0008  beq cr6, 0x82fc391c
	if ctx.cr[6].eq {
	pc = 0x82FC391C; continue 'dispatch;
	}
	// 82FC3918: 4BF39F89  bl 0x82efd8a0
	ctx.lr = 0x82FC391C;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC391C; continue 'dispatch;
            }
            0x82FC391C => {
    //   block [0x82FC391C..0x82FC3934)
	// 82FC391C: 387F011C  addi r3, r31, 0x11c
	ctx.r[3].s64 = ctx.r[31].s64 + 284;
	// 82FC3920: 4BFFF809  bl 0x82fc3128
	ctx.lr = 0x82FC3924;
	sub_82FC3128(ctx, base);
	// 82FC3924: 807F0118  lwz r3, 0x118(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(280 as u32) ) } as u64;
	// 82FC3928: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC392C: 419A0008  beq cr6, 0x82fc3934
	if ctx.cr[6].eq {
	pc = 0x82FC3934; continue 'dispatch;
	}
	// 82FC3930: 4BF39F71  bl 0x82efd8a0
	ctx.lr = 0x82FC3934;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC3934; continue 'dispatch;
            }
            0x82FC3934 => {
    //   block [0x82FC3934..0x82FC3944)
	// 82FC3934: 807F00EC  lwz r3, 0xec(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(236 as u32) ) } as u64;
	// 82FC3938: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC393C: 419A0008  beq cr6, 0x82fc3944
	if ctx.cr[6].eq {
	pc = 0x82FC3944; continue 'dispatch;
	}
	// 82FC3940: 4BF39F61  bl 0x82efd8a0
	ctx.lr = 0x82FC3944;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC3944; continue 'dispatch;
            }
            0x82FC3944 => {
    //   block [0x82FC3944..0x82FC395C)
	// 82FC3944: 387F00D0  addi r3, r31, 0xd0
	ctx.r[3].s64 = ctx.r[31].s64 + 208;
	// 82FC3948: 4BFFF7E1  bl 0x82fc3128
	ctx.lr = 0x82FC394C;
	sub_82FC3128(ctx, base);
	// 82FC394C: 807F00CC  lwz r3, 0xcc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 82FC3950: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC3954: 419A0008  beq cr6, 0x82fc395c
	if ctx.cr[6].eq {
	pc = 0x82FC395C; continue 'dispatch;
	}
	// 82FC3958: 4BF39F49  bl 0x82efd8a0
	ctx.lr = 0x82FC395C;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC395C; continue 'dispatch;
            }
            0x82FC395C => {
    //   block [0x82FC395C..0x82FC396C)
	// 82FC395C: 807F00C0  lwz r3, 0xc0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82FC3960: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC3964: 419A0008  beq cr6, 0x82fc396c
	if ctx.cr[6].eq {
	pc = 0x82FC396C; continue 'dispatch;
	}
	// 82FC3968: 4BF39F39  bl 0x82efd8a0
	ctx.lr = 0x82FC396C;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC396C; continue 'dispatch;
            }
            0x82FC396C => {
    //   block [0x82FC396C..0x82FC397C)
	// 82FC396C: 807F00B4  lwz r3, 0xb4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) } as u64;
	// 82FC3970: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC3974: 419A0008  beq cr6, 0x82fc397c
	if ctx.cr[6].eq {
	pc = 0x82FC397C; continue 'dispatch;
	}
	// 82FC3978: 4BF39F29  bl 0x82efd8a0
	ctx.lr = 0x82FC397C;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC397C; continue 'dispatch;
            }
            0x82FC397C => {
    //   block [0x82FC397C..0x82FC398C)
	// 82FC397C: 807F00A8  lwz r3, 0xa8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 82FC3980: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC3984: 419A0008  beq cr6, 0x82fc398c
	if ctx.cr[6].eq {
	pc = 0x82FC398C; continue 'dispatch;
	}
	// 82FC3988: 4BF39F19  bl 0x82efd8a0
	ctx.lr = 0x82FC398C;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC398C; continue 'dispatch;
            }
            0x82FC398C => {
    //   block [0x82FC398C..0x82FC39A4)
	// 82FC398C: 387F008C  addi r3, r31, 0x8c
	ctx.r[3].s64 = ctx.r[31].s64 + 140;
	// 82FC3990: 4BFFF799  bl 0x82fc3128
	ctx.lr = 0x82FC3994;
	sub_82FC3128(ctx, base);
	// 82FC3994: 807F0088  lwz r3, 0x88(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 82FC3998: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC399C: 419A0008  beq cr6, 0x82fc39a4
	if ctx.cr[6].eq {
	pc = 0x82FC39A4; continue 'dispatch;
	}
	// 82FC39A0: 4BF39F01  bl 0x82efd8a0
	ctx.lr = 0x82FC39A4;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC39A4; continue 'dispatch;
            }
            0x82FC39A4 => {
    //   block [0x82FC39A4..0x82FC39D4)
	// 82FC39A4: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 82FC39A8: 4BFFF781  bl 0x82fc3128
	ctx.lr = 0x82FC39AC;
	sub_82FC3128(ctx, base);
	// 82FC39AC: 387F0058  addi r3, r31, 0x58
	ctx.r[3].s64 = ctx.r[31].s64 + 88;
	// 82FC39B0: 4BFFF779  bl 0x82fc3128
	ctx.lr = 0x82FC39B4;
	sub_82FC3128(ctx, base);
	// 82FC39B4: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 82FC39B8: 4BFFF771  bl 0x82fc3128
	ctx.lr = 0x82FC39BC;
	sub_82FC3128(ctx, base);
	// 82FC39BC: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 82FC39C0: 4BFFF769  bl 0x82fc3128
	ctx.lr = 0x82FC39C4;
	sub_82FC3128(ctx, base);
	// 82FC39C4: 807F002C  lwz r3, 0x2c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 82FC39C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC39CC: 419A0008  beq cr6, 0x82fc39d4
	if ctx.cr[6].eq {
	pc = 0x82FC39D4; continue 'dispatch;
	}
	// 82FC39D0: 4BF39ED1  bl 0x82efd8a0
	ctx.lr = 0x82FC39D4;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC39D4; continue 'dispatch;
            }
            0x82FC39D4 => {
    //   block [0x82FC39D4..0x82FC39E4)
	// 82FC39D4: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FC39D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC39DC: 419A0008  beq cr6, 0x82fc39e4
	if ctx.cr[6].eq {
	pc = 0x82FC39E4; continue 'dispatch;
	}
	// 82FC39E0: 4BF39EC1  bl 0x82efd8a0
	ctx.lr = 0x82FC39E4;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC39E4; continue 'dispatch;
            }
            0x82FC39E4 => {
    //   block [0x82FC39E4..0x82FC39F4)
	// 82FC39E4: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC39E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC39EC: 419A0008  beq cr6, 0x82fc39f4
	if ctx.cr[6].eq {
	pc = 0x82FC39F4; continue 'dispatch;
	}
	// 82FC39F0: 4BF39EB1  bl 0x82efd8a0
	ctx.lr = 0x82FC39F4;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC39F4; continue 'dispatch;
            }
            0x82FC39F4 => {
    //   block [0x82FC39F4..0x82FC3A08)
	// 82FC39F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FC39F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC39FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC3A00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC3A04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC3A08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC3A08 size=164
    let mut pc: u32 = 0x82FC3A08;
    'dispatch: loop {
        match pc {
            0x82FC3A08 => {
    //   block [0x82FC3A08..0x82FC3A48)
	// 82FC3A08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC3A0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC3A10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC3A14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC3A18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC3A1C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FC3A20: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC3A24: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 82FC3A28: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82FC3A2C: 409A0048  bne cr6, 0x82fc3a74
	if !ctx.cr[6].eq {
	pc = 0x82FC3A74; continue 'dispatch;
	}
	// 82FC3A30: 556917BF  rlwinm. r9, r11, 2, 0x1e, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC3A34: 4182001C  beq 0x82fc3a50
	if ctx.cr[0].eq {
	pc = 0x82FC3A50; continue 'dispatch;
	}
	// 82FC3A38: 55680FFF  rlwinm. r8, r11, 1, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82FC3A3C: 4182000C  beq 0x82fc3a48
	if ctx.cr[0].eq {
	pc = 0x82FC3A48; continue 'dispatch;
	}
	// 82FC3A40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82FC3A44: 409A0054  bne cr6, 0x82fc3a98
	if !ctx.cr[6].eq {
	pc = 0x82FC3A98; continue 'dispatch;
	}
	pc = 0x82FC3A48; continue 'dispatch;
            }
            0x82FC3A48 => {
    //   block [0x82FC3A48..0x82FC3A50)
	// 82FC3A48: 552A07FF  clrlwi. r10, r9, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC3A4C: 4082004C  bne 0x82fc3a98
	if !ctx.cr[0].eq {
	pc = 0x82FC3A98; continue 'dispatch;
	}
	pc = 0x82FC3A50; continue 'dispatch;
            }
            0x82FC3A50 => {
    //   block [0x82FC3A50..0x82FC3A68)
	// 82FC3A50: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3A54: 556B0002  rlwinm r11, r11, 0, 0, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC3A58: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC3A5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC3A60: 419A0008  beq cr6, 0x82fc3a68
	if ctx.cr[6].eq {
	pc = 0x82FC3A68; continue 'dispatch;
	}
	// 82FC3A64: 4BF39E3D  bl 0x82efd8a0
	ctx.lr = 0x82FC3A68;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC3A68; continue 'dispatch;
            }
            0x82FC3A68 => {
    //   block [0x82FC3A68..0x82FC3A74)
	// 82FC3A68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC3A6C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC3A70: 48000028  b 0x82fc3a98
	pc = 0x82FC3A98; continue 'dispatch;
            }
            0x82FC3A74 => {
    //   block [0x82FC3A74..0x82FC3A88)
	// 82FC3A74: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC3A78: 41990010  bgt cr6, 0x82fc3a88
	if ctx.cr[6].gt {
	pc = 0x82FC3A88; continue 'dispatch;
	}
	// 82FC3A7C: 554BF87E  srwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC3A80: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC3A84: 41990014  bgt cr6, 0x82fc3a98
	if ctx.cr[6].gt {
	pc = 0x82FC3A98; continue 'dispatch;
	}
	pc = 0x82FC3A88; continue 'dispatch;
            }
            0x82FC3A88 => {
    //   block [0x82FC3A88..0x82FC3A98)
	// 82FC3A88: 548BF0BE  srwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC3A8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC3A90: 7C8B2214  add r4, r11, r4
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82FC3A94: 4BFFF72D  bl 0x82fc31c0
	ctx.lr = 0x82FC3A98;
	sub_82FC31C0(ctx, base);
	pc = 0x82FC3A98; continue 'dispatch;
            }
            0x82FC3A98 => {
    //   block [0x82FC3A98..0x82FC3AAC)
	// 82FC3A98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FC3A9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC3AA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC3AA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC3AA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC3AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC3AB0 size=248
    let mut pc: u32 = 0x82FC3AB0;
    'dispatch: loop {
        match pc {
            0x82FC3AB0 => {
    //   block [0x82FC3AB0..0x82FC3ADC)
	// 82FC3AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC3AB4: 4BCE5951  bl 0x82ca9404
	ctx.lr = 0x82FC3AB8;
	sub_82CA93D0(ctx, base);
	// 82FC3AB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC3ABC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82FC3AC0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82FC3AC4: 837D0004  lwz r27, 4(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC3AC8: 939D0004  stw r28, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82FC3ACC: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82FC3AD0: 40980028  bge cr6, 0x82fc3af8
	if !ctx.cr[6].lt {
	pc = 0x82FC3AF8; continue 'dispatch;
	}
	// 82FC3AD4: 579E402E  slwi r30, r28, 8
	ctx.r[30].u32 = ctx.r[28].u32.wrapping_shl(8);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82FC3AD8: 7FFCD850  subf r31, r28, r27
	ctx.r[31].s64 = ctx.r[27].s64 - ctx.r[28].s64;
	pc = 0x82FC3ADC; continue 'dispatch;
            }
            0x82FC3ADC => {
    //   block [0x82FC3ADC..0x82FC3AF8)
	// 82FC3ADC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3AE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC3AE4: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82FC3AE8: 4BFFF5D1  bl 0x82fc30b8
	ctx.lr = 0x82FC3AEC;
	sub_82FC30B8(ctx, base);
	// 82FC3AEC: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82FC3AF0: 3BDE0100  addi r30, r30, 0x100
	ctx.r[30].s64 = ctx.r[30].s64 + 256;
	// 82FC3AF4: 4082FFE8  bne 0x82fc3adc
	if !ctx.cr[0].eq {
	pc = 0x82FC3ADC; continue 'dispatch;
	}
	pc = 0x82FC3AF8; continue 'dispatch;
            }
            0x82FC3AF8 => {
    //   block [0x82FC3AF8..0x82FC3B20)
	// 82FC3AF8: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC3AFC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82FC3B00: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82FC3B04: 409A0048  bne cr6, 0x82fc3b4c
	if !ctx.cr[6].eq {
	pc = 0x82FC3B4C; continue 'dispatch;
	}
	// 82FC3B08: 556917BF  rlwinm. r9, r11, 2, 0x1e, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC3B0C: 4182001C  beq 0x82fc3b28
	if ctx.cr[0].eq {
	pc = 0x82FC3B28; continue 'dispatch;
	}
	// 82FC3B10: 55680FFF  rlwinm. r8, r11, 1, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82FC3B14: 4182000C  beq 0x82fc3b20
	if ctx.cr[0].eq {
	pc = 0x82FC3B20; continue 'dispatch;
	}
	// 82FC3B18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82FC3B1C: 409A0058  bne cr6, 0x82fc3b74
	if !ctx.cr[6].eq {
	pc = 0x82FC3B74; continue 'dispatch;
	}
	pc = 0x82FC3B20; continue 'dispatch;
            }
            0x82FC3B20 => {
    //   block [0x82FC3B20..0x82FC3B28)
	// 82FC3B20: 552A07FF  clrlwi. r10, r9, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC3B24: 40820050  bne 0x82fc3b74
	if !ctx.cr[0].eq {
	pc = 0x82FC3B74; continue 'dispatch;
	}
	pc = 0x82FC3B28; continue 'dispatch;
            }
            0x82FC3B28 => {
    //   block [0x82FC3B28..0x82FC3B40)
	// 82FC3B28: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3B2C: 556B0002  rlwinm r11, r11, 0, 0, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC3B30: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC3B34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC3B38: 419A0008  beq cr6, 0x82fc3b40
	if ctx.cr[6].eq {
	pc = 0x82FC3B40; continue 'dispatch;
	}
	// 82FC3B3C: 4BF39D65  bl 0x82efd8a0
	ctx.lr = 0x82FC3B40;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC3B40; continue 'dispatch;
            }
            0x82FC3B40 => {
    //   block [0x82FC3B40..0x82FC3B4C)
	// 82FC3B40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC3B44: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC3B48: 4800002C  b 0x82fc3b74
	pc = 0x82FC3B74; continue 'dispatch;
            }
            0x82FC3B4C => {
    //   block [0x82FC3B4C..0x82FC3B64)
	// 82FC3B4C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC3B50: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC3B54: 41990010  bgt cr6, 0x82fc3b64
	if ctx.cr[6].gt {
	pc = 0x82FC3B64; continue 'dispatch;
	}
	// 82FC3B58: 554AF87E  srwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82FC3B5C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC3B60: 41990014  bgt cr6, 0x82fc3b74
	if ctx.cr[6].gt {
	pc = 0x82FC3B74; continue 'dispatch;
	}
	pc = 0x82FC3B64; continue 'dispatch;
            }
            0x82FC3B64 => {
    //   block [0x82FC3B64..0x82FC3B74)
	// 82FC3B64: 556AF0BE  srwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82FC3B68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC3B6C: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC3B70: 4BFFF719  bl 0x82fc3288
	ctx.lr = 0x82FC3B74;
	sub_82FC3288(ctx, base);
	pc = 0x82FC3B74; continue 'dispatch;
            }
            0x82FC3B74 => {
    //   block [0x82FC3B74..0x82FC3B84)
	// 82FC3B74: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82FC3B78: 40980028  bge cr6, 0x82fc3ba0
	if !ctx.cr[6].lt {
	pc = 0x82FC3BA0; continue 'dispatch;
	}
	// 82FC3B7C: 577F402E  slwi r31, r27, 8
	ctx.r[31].u32 = ctx.r[27].u32.wrapping_shl(8);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82FC3B80: 7FDBE050  subf r30, r27, r28
	ctx.r[30].s64 = ctx.r[28].s64 - ctx.r[27].s64;
	pc = 0x82FC3B84; continue 'dispatch;
            }
            0x82FC3B84 => {
    //   block [0x82FC3B84..0x82FC3B94)
	// 82FC3B84: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3B88: 7C7F5A15  add. r3, r31, r11
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82FC3B8C: 41820008  beq 0x82fc3b94
	if ctx.cr[0].eq {
	pc = 0x82FC3B94; continue 'dispatch;
	}
	// 82FC3B90: 4BFFEF99  bl 0x82fc2b28
	ctx.lr = 0x82FC3B94;
	sub_82FC2B28(ctx, base);
	pc = 0x82FC3B94; continue 'dispatch;
            }
            0x82FC3B94 => {
    //   block [0x82FC3B94..0x82FC3BA0)
	// 82FC3B94: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82FC3B98: 3BFF0100  addi r31, r31, 0x100
	ctx.r[31].s64 = ctx.r[31].s64 + 256;
	// 82FC3B9C: 4082FFE8  bne 0x82fc3b84
	if !ctx.cr[0].eq {
	pc = 0x82FC3B84; continue 'dispatch;
	}
	pc = 0x82FC3BA0; continue 'dispatch;
            }
            0x82FC3BA0 => {
    //   block [0x82FC3BA0..0x82FC3BA8)
	// 82FC3BA0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC3BA4: 4BCE58B0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC3BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC3BA8 size=212
    let mut pc: u32 = 0x82FC3BA8;
    'dispatch: loop {
        match pc {
            0x82FC3BA8 => {
    //   block [0x82FC3BA8..0x82FC3BF0)
	// 82FC3BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC3BAC: 4BCE585D  bl 0x82ca9408
	ctx.lr = 0x82FC3BB0;
	sub_82CA93D0(ctx, base);
	// 82FC3BB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC3BB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC3BB8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82FC3BBC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82FC3BC0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82FC3BC4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC3BC8: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC3BCC: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82FC3BD0: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82FC3BD4: 409A0044  bne cr6, 0x82fc3c18
	if !ctx.cr[6].eq {
	pc = 0x82FC3C18; continue 'dispatch;
	}
	// 82FC3BD8: 556917BF  rlwinm. r9, r11, 2, 0x1e, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC3BDC: 4182001C  beq 0x82fc3bf8
	if ctx.cr[0].eq {
	pc = 0x82FC3BF8; continue 'dispatch;
	}
	// 82FC3BE0: 55680FFF  rlwinm. r8, r11, 1, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82FC3BE4: 4182000C  beq 0x82fc3bf0
	if ctx.cr[0].eq {
	pc = 0x82FC3BF0; continue 'dispatch;
	}
	// 82FC3BE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82FC3BEC: 409A0050  bne cr6, 0x82fc3c3c
	if !ctx.cr[6].eq {
	pc = 0x82FC3C3C; continue 'dispatch;
	}
	pc = 0x82FC3BF0; continue 'dispatch;
            }
            0x82FC3BF0 => {
    //   block [0x82FC3BF0..0x82FC3BF8)
	// 82FC3BF0: 552A07FF  clrlwi. r10, r9, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC3BF4: 40820048  bne 0x82fc3c3c
	if !ctx.cr[0].eq {
	pc = 0x82FC3C3C; continue 'dispatch;
	}
	pc = 0x82FC3BF8; continue 'dispatch;
            }
            0x82FC3BF8 => {
    //   block [0x82FC3BF8..0x82FC3C10)
	// 82FC3BF8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3BFC: 556B0002  rlwinm r11, r11, 0, 0, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC3C00: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC3C04: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC3C08: 419A0008  beq cr6, 0x82fc3c10
	if ctx.cr[6].eq {
	pc = 0x82FC3C10; continue 'dispatch;
	}
	// 82FC3C0C: 4BF39C95  bl 0x82efd8a0
	ctx.lr = 0x82FC3C10;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC3C10; continue 'dispatch;
            }
            0x82FC3C10 => {
    //   block [0x82FC3C10..0x82FC3C18)
	// 82FC3C10: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82FC3C14: 48000028  b 0x82fc3c3c
	pc = 0x82FC3C3C; continue 'dispatch;
            }
            0x82FC3C18 => {
    //   block [0x82FC3C18..0x82FC3C2C)
	// 82FC3C18: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC3C1C: 41990010  bgt cr6, 0x82fc3c2c
	if ctx.cr[6].gt {
	pc = 0x82FC3C2C; continue 'dispatch;
	}
	// 82FC3C20: 554BF87E  srwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC3C24: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC3C28: 41990014  bgt cr6, 0x82fc3c3c
	if ctx.cr[6].gt {
	pc = 0x82FC3C3C; continue 'dispatch;
	}
	pc = 0x82FC3C2C; continue 'dispatch;
            }
            0x82FC3C2C => {
    //   block [0x82FC3C2C..0x82FC3C3C)
	// 82FC3C2C: 57EBF0BE  srwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC3C30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC3C34: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82FC3C38: 4BF86149  bl 0x82f49d80
	ctx.lr = 0x82FC3C3C;
	sub_82F49D80(ctx, base);
	pc = 0x82FC3C3C; continue 'dispatch;
            }
            0x82FC3C3C => {
    //   block [0x82FC3C3C..0x82FC3C4C)
	// 82FC3C3C: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82FC3C40: 40980034  bge cr6, 0x82fc3c74
	if !ctx.cr[6].lt {
	pc = 0x82FC3C74; continue 'dispatch;
	}
	// 82FC3C44: 1D5D0014  mulli r10, r29, 0x14
	ctx.r[10].s32 = ((ctx.r[29].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC3C48: 7D3DF850  subf r9, r29, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[29].s64;
	pc = 0x82FC3C4C; continue 'dispatch;
            }
            0x82FC3C4C => {
    //   block [0x82FC3C4C..0x82FC3C68)
	// 82FC3C4C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3C50: 7D6A5A15  add. r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC3C54: 41820014  beq 0x82fc3c68
	if ctx.cr[0].eq {
	pc = 0x82FC3C68; continue 'dispatch;
	}
	// 82FC3C58: 938B000C  stw r28, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82FC3C5C: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82FC3C60: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82FC3C64: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x82FC3C68; continue 'dispatch;
            }
            0x82FC3C68 => {
    //   block [0x82FC3C68..0x82FC3C74)
	// 82FC3C68: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC3C6C: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 82FC3C70: 4082FFDC  bne 0x82fc3c4c
	if !ctx.cr[0].eq {
	pc = 0x82FC3C4C; continue 'dispatch;
	}
	pc = 0x82FC3C74; continue 'dispatch;
            }
            0x82FC3C74 => {
    //   block [0x82FC3C74..0x82FC3C7C)
	// 82FC3C74: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC3C78: 4BCE57E0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC3C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC3C80 size=200
    let mut pc: u32 = 0x82FC3C80;
    'dispatch: loop {
        match pc {
            0x82FC3C80 => {
    //   block [0x82FC3C80..0x82FC3CC4)
	// 82FC3C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC3C84: 4BCE5785  bl 0x82ca9408
	ctx.lr = 0x82FC3C88;
	sub_82CA93D0(ctx, base);
	// 82FC3C88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC3C8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC3C90: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82FC3C94: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82FC3C98: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC3C9C: 839E0004  lwz r28, 4(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC3CA0: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82FC3CA4: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82FC3CA8: 409A0048  bne cr6, 0x82fc3cf0
	if !ctx.cr[6].eq {
	pc = 0x82FC3CF0; continue 'dispatch;
	}
	// 82FC3CAC: 556917BF  rlwinm. r9, r11, 2, 0x1e, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC3CB0: 4182001C  beq 0x82fc3ccc
	if ctx.cr[0].eq {
	pc = 0x82FC3CCC; continue 'dispatch;
	}
	// 82FC3CB4: 55680FFF  rlwinm. r8, r11, 1, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82FC3CB8: 4182000C  beq 0x82fc3cc4
	if ctx.cr[0].eq {
	pc = 0x82FC3CC4; continue 'dispatch;
	}
	// 82FC3CBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82FC3CC0: 409A0054  bne cr6, 0x82fc3d14
	if !ctx.cr[6].eq {
	pc = 0x82FC3D14; continue 'dispatch;
	}
	pc = 0x82FC3CC4; continue 'dispatch;
            }
            0x82FC3CC4 => {
    //   block [0x82FC3CC4..0x82FC3CCC)
	// 82FC3CC4: 552A07FF  clrlwi. r10, r9, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC3CC8: 4082004C  bne 0x82fc3d14
	if !ctx.cr[0].eq {
	pc = 0x82FC3D14; continue 'dispatch;
	}
	pc = 0x82FC3CCC; continue 'dispatch;
            }
            0x82FC3CCC => {
    //   block [0x82FC3CCC..0x82FC3CE4)
	// 82FC3CCC: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3CD0: 556B0002  rlwinm r11, r11, 0, 0, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC3CD4: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC3CD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC3CDC: 419A0008  beq cr6, 0x82fc3ce4
	if ctx.cr[6].eq {
	pc = 0x82FC3CE4; continue 'dispatch;
	}
	// 82FC3CE0: 4BF39BC1  bl 0x82efd8a0
	ctx.lr = 0x82FC3CE4;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC3CE4; continue 'dispatch;
            }
            0x82FC3CE4 => {
    //   block [0x82FC3CE4..0x82FC3CF0)
	// 82FC3CE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC3CE8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC3CEC: 48000028  b 0x82fc3d14
	pc = 0x82FC3D14; continue 'dispatch;
            }
            0x82FC3CF0 => {
    //   block [0x82FC3CF0..0x82FC3D04)
	// 82FC3CF0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC3CF4: 41990010  bgt cr6, 0x82fc3d04
	if ctx.cr[6].gt {
	pc = 0x82FC3D04; continue 'dispatch;
	}
	// 82FC3CF8: 554BF87E  srwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC3CFC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC3D00: 41990014  bgt cr6, 0x82fc3d14
	if ctx.cr[6].gt {
	pc = 0x82FC3D14; continue 'dispatch;
	}
	pc = 0x82FC3D04; continue 'dispatch;
            }
            0x82FC3D04 => {
    //   block [0x82FC3D04..0x82FC3D14)
	// 82FC3D04: 57EBF0BE  srwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC3D08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC3D0C: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82FC3D10: 4BFFF709  bl 0x82fc3418
	ctx.lr = 0x82FC3D14;
	sub_82FC3418(ctx, base);
	pc = 0x82FC3D14; continue 'dispatch;
            }
            0x82FC3D14 => {
    //   block [0x82FC3D14..0x82FC3D24)
	// 82FC3D14: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82FC3D18: 40980028  bge cr6, 0x82fc3d40
	if !ctx.cr[6].lt {
	pc = 0x82FC3D40; continue 'dispatch;
	}
	// 82FC3D1C: 579D2834  slwi r29, r28, 5
	ctx.r[29].u32 = ctx.r[28].u32.wrapping_shl(5);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82FC3D20: 7FFCF850  subf r31, r28, r31
	ctx.r[31].s64 = ctx.r[31].s64 - ctx.r[28].s64;
	pc = 0x82FC3D24; continue 'dispatch;
            }
            0x82FC3D24 => {
    //   block [0x82FC3D24..0x82FC3D34)
	// 82FC3D24: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3D28: 7C7D5A15  add. r3, r29, r11
	ctx.r[3].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82FC3D2C: 41820008  beq 0x82fc3d34
	if ctx.cr[0].eq {
	pc = 0x82FC3D34; continue 'dispatch;
	}
	// 82FC3D30: 4BFA8C49  bl 0x82f6c978
	ctx.lr = 0x82FC3D34;
	sub_82F6C978(ctx, base);
	pc = 0x82FC3D34; continue 'dispatch;
            }
            0x82FC3D34 => {
    //   block [0x82FC3D34..0x82FC3D40)
	// 82FC3D34: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82FC3D38: 3BBD0020  addi r29, r29, 0x20
	ctx.r[29].s64 = ctx.r[29].s64 + 32;
	// 82FC3D3C: 4082FFE8  bne 0x82fc3d24
	if !ctx.cr[0].eq {
	pc = 0x82FC3D24; continue 'dispatch;
	}
	pc = 0x82FC3D40; continue 'dispatch;
            }
            0x82FC3D40 => {
    //   block [0x82FC3D40..0x82FC3D48)
	// 82FC3D40: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC3D44: 4BCE5714  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC3D48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC3D48 size=224
    let mut pc: u32 = 0x82FC3D48;
    'dispatch: loop {
        match pc {
            0x82FC3D48 => {
    //   block [0x82FC3D48..0x82FC3D8C)
	// 82FC3D48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC3D4C: 4BCE56B9  bl 0x82ca9404
	ctx.lr = 0x82FC3D50;
	sub_82CA93D0(ctx, base);
	// 82FC3D50: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC3D54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC3D58: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82FC3D5C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82FC3D60: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC3D64: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC3D68: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82FC3D6C: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82FC3D70: 409A0048  bne cr6, 0x82fc3db8
	if !ctx.cr[6].eq {
	pc = 0x82FC3DB8; continue 'dispatch;
	}
	// 82FC3D74: 556917BF  rlwinm. r9, r11, 2, 0x1e, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC3D78: 4182001C  beq 0x82fc3d94
	if ctx.cr[0].eq {
	pc = 0x82FC3D94; continue 'dispatch;
	}
	// 82FC3D7C: 55680FFF  rlwinm. r8, r11, 1, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82FC3D80: 4182000C  beq 0x82fc3d8c
	if ctx.cr[0].eq {
	pc = 0x82FC3D8C; continue 'dispatch;
	}
	// 82FC3D84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82FC3D88: 409A0054  bne cr6, 0x82fc3ddc
	if !ctx.cr[6].eq {
	pc = 0x82FC3DDC; continue 'dispatch;
	}
	pc = 0x82FC3D8C; continue 'dispatch;
            }
            0x82FC3D8C => {
    //   block [0x82FC3D8C..0x82FC3D94)
	// 82FC3D8C: 552A07FF  clrlwi. r10, r9, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC3D90: 4082004C  bne 0x82fc3ddc
	if !ctx.cr[0].eq {
	pc = 0x82FC3DDC; continue 'dispatch;
	}
	pc = 0x82FC3D94; continue 'dispatch;
            }
            0x82FC3D94 => {
    //   block [0x82FC3D94..0x82FC3DAC)
	// 82FC3D94: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3D98: 556B0002  rlwinm r11, r11, 0, 0, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC3D9C: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC3DA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC3DA4: 419A0008  beq cr6, 0x82fc3dac
	if ctx.cr[6].eq {
	pc = 0x82FC3DAC; continue 'dispatch;
	}
	// 82FC3DA8: 4BF39AF9  bl 0x82efd8a0
	ctx.lr = 0x82FC3DAC;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC3DAC; continue 'dispatch;
            }
            0x82FC3DAC => {
    //   block [0x82FC3DAC..0x82FC3DB8)
	// 82FC3DAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC3DB0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC3DB4: 48000028  b 0x82fc3ddc
	pc = 0x82FC3DDC; continue 'dispatch;
            }
            0x82FC3DB8 => {
    //   block [0x82FC3DB8..0x82FC3DCC)
	// 82FC3DB8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC3DBC: 41990010  bgt cr6, 0x82fc3dcc
	if ctx.cr[6].gt {
	pc = 0x82FC3DCC; continue 'dispatch;
	}
	// 82FC3DC0: 554BF87E  srwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC3DC4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC3DC8: 41990014  bgt cr6, 0x82fc3ddc
	if ctx.cr[6].gt {
	pc = 0x82FC3DDC; continue 'dispatch;
	}
	pc = 0x82FC3DCC; continue 'dispatch;
            }
            0x82FC3DCC => {
    //   block [0x82FC3DCC..0x82FC3DDC)
	// 82FC3DCC: 57EBF0BE  srwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC3DD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC3DD4: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82FC3DD8: 4BFFF709  bl 0x82fc34e0
	ctx.lr = 0x82FC3DDC;
	sub_82FC34E0(ctx, base);
	pc = 0x82FC3DDC; continue 'dispatch;
            }
            0x82FC3DDC => {
    //   block [0x82FC3DDC..0x82FC3DEC)
	// 82FC3DDC: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82FC3DE0: 40980040  bge cr6, 0x82fc3e20
	if !ctx.cr[6].lt {
	pc = 0x82FC3E20; continue 'dispatch;
	}
	// 82FC3DE4: 1F9D01D0  mulli r28, r29, 0x1d0
	ctx.r[28].s32 = ((ctx.r[29].s32 as i64 * 464 as i64) as i32);
	ctx.r[28].s64 = ctx.r[28].s32 as i64;
	// 82FC3DE8: 7F7DF850  subf r27, r29, r31
	ctx.r[27].s64 = ctx.r[31].s64 - ctx.r[29].s64;
	pc = 0x82FC3DEC; continue 'dispatch;
            }
            0x82FC3DEC => {
    //   block [0x82FC3DEC..0x82FC3E00)
	// 82FC3DEC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3DF0: 7D7C5A15  add. r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC3DF4: 41820020  beq 0x82fc3e14
	if ctx.cr[0].eq {
	pc = 0x82FC3E14; continue 'dispatch;
	}
	// 82FC3DF8: 3BAB00A0  addi r29, r11, 0xa0
	ctx.r[29].s64 = ctx.r[11].s64 + 160;
	// 82FC3DFC: 3BE00008  li r31, 8
	ctx.r[31].s64 = 8;
	pc = 0x82FC3E00; continue 'dispatch;
            }
            0x82FC3E00 => {
    //   block [0x82FC3E00..0x82FC3E14)
	// 82FC3E00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC3E04: 4BFA8B75  bl 0x82f6c978
	ctx.lr = 0x82FC3E08;
	sub_82F6C978(ctx, base);
	// 82FC3E08: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82FC3E0C: 3BBD0020  addi r29, r29, 0x20
	ctx.r[29].s64 = ctx.r[29].s64 + 32;
	// 82FC3E10: 4080FFF0  bge 0x82fc3e00
	if !ctx.cr[0].lt {
	pc = 0x82FC3E00; continue 'dispatch;
	}
	pc = 0x82FC3E14; continue 'dispatch;
            }
            0x82FC3E14 => {
    //   block [0x82FC3E14..0x82FC3E20)
	// 82FC3E14: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82FC3E18: 3B9C01D0  addi r28, r28, 0x1d0
	ctx.r[28].s64 = ctx.r[28].s64 + 464;
	// 82FC3E1C: 4082FFD0  bne 0x82fc3dec
	if !ctx.cr[0].eq {
	pc = 0x82FC3DEC; continue 'dispatch;
	}
	pc = 0x82FC3E20; continue 'dispatch;
            }
            0x82FC3E20 => {
    //   block [0x82FC3E20..0x82FC3E28)
	// 82FC3E20: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC3E24: 4BCE5630  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC3E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC3E28 size=88
    let mut pc: u32 = 0x82FC3E28;
    'dispatch: loop {
        match pc {
            0x82FC3E28 => {
    //   block [0x82FC3E28..0x82FC3E64)
	// 82FC3E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC3E2C: 4BCE55E1  bl 0x82ca940c
	ctx.lr = 0x82FC3E30;
	sub_82CA93D0(ctx, base);
	// 82FC3E30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC3E34: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82FC3E38: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC3E3C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC3E40: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 82FC3E44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC3E48: 4BFFFD61  bl 0x82fc3ba8
	ctx.lr = 0x82FC3E4C;
	sub_82FC3BA8(ctx, base);
	// 82FC3E4C: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3E50: 1D5F0014  mulli r10, r31, 0x14
	ctx.r[10].s32 = ((ctx.r[31].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC3E54: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82FC3E58: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82FC3E5C: 394AFFEC  addi r10, r10, -0x14
	ctx.r[10].s64 = ctx.r[10].s64 + -20;
	// 82FC3E60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x82FC3E64; continue 'dispatch;
            }
            0x82FC3E64 => {
    //   block [0x82FC3E64..0x82FC3E80)
	// 82FC3E64: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3E68: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82FC3E6C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC3E70: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82FC3E74: 4200FFF0  bdnz 0x82fc3e64
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82FC3E64; continue 'dispatch;
	}
	// 82FC3E78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC3E7C: 4BCE55E0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC3E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC3E80 size=292
    let mut pc: u32 = 0x82FC3E80;
    'dispatch: loop {
        match pc {
            0x82FC3E80 => {
    //   block [0x82FC3E80..0x82FC3EC4)
	// 82FC3E80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC3E84: 4BCE557D  bl 0x82ca9400
	ctx.lr = 0x82FC3E88;
	sub_82CA93D0(ctx, base);
	// 82FC3E88: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 82FC3E8C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC3E90: 81440028  lwz r10, 0x28(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC3E94: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82FC3E98: 54A9E13A  rlwinm r9, r5, 0x1c, 4, 0x1d
	ctx.r[9].u64 = ctx.r[5].u32 as u64 & 0x0000000Fu64;
	// 82FC3E9C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82FC3EA0: 54AB06BE  clrlwi r11, r5, 0x1a
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x0000003Fu64;
	// 82FC3EA4: 1D6B0018  mulli r11, r11, 0x18
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC3EA8: 837C0008  lwz r27, 8(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC3EAC: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FC3EB0: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC3EB4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82FC3EB8: 409A000C  bne cr6, 0x82fc3ec4
	if !ctx.cr[6].eq {
	pc = 0x82FC3EC4; continue 'dispatch;
	}
	// 82FC3EBC: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC3EC0: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82FC3EC4; continue 'dispatch;
            }
            0x82FC3EC4 => {
    //   block [0x82FC3EC4..0x82FC3EEC)
	// 82FC3EC4: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC3EC8: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82FC3ECC: 57BA083C  slwi r26, r29, 1
	ctx.r[26].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 82FC3ED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC3ED4: 7C9ADA14  add r4, r26, r27
	ctx.r[4].u64 = ctx.r[26].u64 + ctx.r[27].u64;
	// 82FC3ED8: 4BFFFB31  bl 0x82fc3a08
	ctx.lr = 0x82FC3EDC;
	sub_82FC3A08(ctx, base);
	// 82FC3EDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC3EE0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82FC3EE4: 419A0090  beq cr6, 0x82fc3f74
	if ctx.cr[6].eq {
	pc = 0x82FC3F74; continue 'dispatch;
	}
	// 82FC3EE8: 576A083C  slwi r10, r27, 1
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	pc = 0x82FC3EEC; continue 'dispatch;
            }
            0x82FC3EEC => {
    //   block [0x82FC3EEC..0x82FC3F74)
	// 82FC3EEC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC3EF0: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3EF4: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82FC3EF8: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3EFC: 5526D1BA  rlwinm r6, r9, 0x1a, 6, 0x1d
	ctx.r[6].u64 = ctx.r[9].u32 as u64 & 0x0000003Fu64;
	// 82FC3F00: 55291D78  rlwinm r9, r9, 3, 0x15, 0x1c
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 82FC3F04: 81080014  lwz r8, 0x14(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC3F08: 7D06402E  lwzx r8, r6, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[6].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82FC3F0C: 7C084C2E  lfsx f0, r8, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC3F10: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82FC3F14: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82FC3F18: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FC3F1C: A1210056  lhz r9, 0x56(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82FC3F20: 7D2A3B2E  sthx r9, r10, r7
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[7].u32), ctx.r[9].u16) };
	// 82FC3F24: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC3F28: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3F2C: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82FC3F30: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC3F34: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FC3F38: 5525D1BA  rlwinm r5, r9, 0x1a, 6, 0x1d
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0x0000003Fu64;
	// 82FC3F3C: 55281D78  rlwinm r8, r9, 3, 0x15, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 82FC3F40: 81260014  lwz r9, 0x14(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC3F44: 7CEA3A14  add r7, r10, r7
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82FC3F48: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82FC3F4C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82FC3F50: 7D25482E  lwzx r9, r5, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FC3F54: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82FC3F58: C0090004  lfs f0, 4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC3F5C: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82FC3F60: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82FC3F64: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FC3F68: A1210056  lhz r9, 0x56(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82FC3F6C: B1270002  sth r9, 2(r7)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[7].u32.wrapping_add(2 as u32), ctx.r[9].u16 ) };
	// 82FC3F70: 4198FF7C  blt cr6, 0x82fc3eec
	if ctx.cr[6].lt {
	pc = 0x82FC3EEC; continue 'dispatch;
	}
	pc = 0x82FC3F74; continue 'dispatch;
            }
            0x82FC3F74 => {
    //   block [0x82FC3F74..0x82FC3FA4)
	// 82FC3F74: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC3F78: 387C0018  addi r3, r28, 0x18
	ctx.r[3].s64 = ctx.r[28].s64 + 24;
	// 82FC3F7C: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 82FC3F80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC3F84: 4BF57A1D  bl 0x82f1b9a0
	ctx.lr = 0x82FC3F88;
	sub_82F1B9A0(ctx, base);
	// 82FC3F88: 815C0018  lwz r10, 0x18(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC3F8C: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC3F90: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC3F94: 934BFFFC  stw r26, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[26].u32 ) };
	// 82FC3F98: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82FC3F9C: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82FC3FA0: 4BCE54B0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC3FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC3FA8 size=172
    let mut pc: u32 = 0x82FC3FA8;
    'dispatch: loop {
        match pc {
            0x82FC3FA8 => {
    //   block [0x82FC3FA8..0x82FC4054)
	// 82FC3FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC3FAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC3FB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC3FB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC3FB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC3FBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC3FC0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82FC3FC4: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 82FC3FC8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82FC3FCC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC3FD0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82FC3FD4: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82FC3FD8: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82FC3FDC: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82FC3FE0: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82FC3FE4: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82FC3FE8: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82FC3FEC: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82FC3FF0: 48003541  bl 0x82fc7530
	ctx.lr = 0x82FC3FF4;
	sub_82FC7530(ctx, base);
	// 82FC3FF4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC3FF8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC3FFC: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82FC4000: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 82FC4004: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82FC4008: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82FC400C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC4010: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82FC4014: C1AB0BE0  lfs f13, 0xbe0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3040 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC4018: 9BDF0030  stb r30, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u8 ) };
	// 82FC401C: C00A0C18  lfs f0, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC4020: 9BDF002C  stb r30, 0x2c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u8 ) };
	// 82FC4024: D1BF0028  stfs f13, 0x28(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82FC4028: 9BDF002F  stb r30, 0x2f(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(47 as u32), ctx.r[30].u8 ) };
	// 82FC402C: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82FC4030: 9BDF002D  stb r30, 0x2d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(45 as u32), ctx.r[30].u8 ) };
	// 82FC4034: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82FC4038: 9BDF002E  stb r30, 0x2e(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(46 as u32), ctx.r[30].u8 ) };
	// 82FC403C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC4040: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC4044: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC4048: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC404C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC4050: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC4058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC4058 size=208
    let mut pc: u32 = 0x82FC4058;
    'dispatch: loop {
        match pc {
            0x82FC4058 => {
    //   block [0x82FC4058..0x82FC4090)
	// 82FC4058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC405C: 4BCE53AD  bl 0x82ca9408
	ctx.lr = 0x82FC4060;
	sub_82CA93D0(ctx, base);
	// 82FC4060: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC4064: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC4068: 3BBF0058  addi r29, r31, 0x58
	ctx.r[29].s64 = ctx.r[31].s64 + 88;
	// 82FC406C: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82FC4070: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC4074: 419A001C  beq cr6, 0x82fc4090
	if ctx.cr[6].eq {
	pc = 0x82FC4090; continue 'dispatch;
	}
	// 82FC4078: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC407C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82FC4080: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC4084: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82FC4088: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC408C: 4E800421  bctrl
	ctx.lr = 0x82FC4090;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC4090 => {
    //   block [0x82FC4090..0x82FC40C4)
	// 82FC4090: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82FC4094: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82FC4098: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82FC409C: 939D0004  stw r28, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82FC40A0: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC40A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC40A8: 419A001C  beq cr6, 0x82fc40c4
	if ctx.cr[6].eq {
	pc = 0x82FC40C4; continue 'dispatch;
	}
	// 82FC40AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC40B0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82FC40B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC40B8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82FC40BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC40C0: 4E800421  bctrl
	ctx.lr = 0x82FC40C4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC40C4 => {
    //   block [0x82FC40C4..0x82FC40E0)
	// 82FC40C4: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82FC40C8: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82FC40CC: 807F0024  lwz r3, 0x24(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC40D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC40D4: 419A000C  beq cr6, 0x82fc40e0
	if ctx.cr[6].eq {
	pc = 0x82FC40E0; continue 'dispatch;
	}
	// 82FC40D8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82FC40DC: 4BFFEFDD  bl 0x82fc30b8
	ctx.lr = 0x82FC40E0;
	sub_82FC30B8(ctx, base);
	pc = 0x82FC40E0; continue 'dispatch;
            }
            0x82FC40E0 => {
    //   block [0x82FC40E0..0x82FC4104)
	// 82FC40E0: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 82FC40E4: 48002E4D  bl 0x82fc6f30
	ctx.lr = 0x82FC40E8;
	sub_82FC6F30(ctx, base);
	// 82FC40E8: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82FC40EC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC40F0: 4BF578B1  bl 0x82f1b9a0
	ctx.lr = 0x82FC40F4;
	sub_82F1B9A0(ctx, base);
	// 82FC40F4: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC40F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC40FC: 419A0008  beq cr6, 0x82fc4104
	if ctx.cr[6].eq {
	pc = 0x82FC4104; continue 'dispatch;
	}
	// 82FC4100: 4BF397A1  bl 0x82efd8a0
	ctx.lr = 0x82FC4104;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC4104; continue 'dispatch;
            }
            0x82FC4104 => {
    //   block [0x82FC4104..0x82FC4120)
	// 82FC4104: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82FC4108: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC410C: 4BFFF8FD  bl 0x82fc3a08
	ctx.lr = 0x82FC4110;
	sub_82FC3A08(ctx, base);
	// 82FC4110: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC4114: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC4118: 419A0008  beq cr6, 0x82fc4120
	if ctx.cr[6].eq {
	pc = 0x82FC4120; continue 'dispatch;
	}
	// 82FC411C: 4BF39785  bl 0x82efd8a0
	ctx.lr = 0x82FC4120;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC4120; continue 'dispatch;
            }
            0x82FC4120 => {
    //   block [0x82FC4120..0x82FC4128)
	// 82FC4120: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC4124: 4BCE5334  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC4128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC4128 size=4796
    let mut pc: u32 = 0x82FC4128;
    'dispatch: loop {
        match pc {
            0x82FC4128 => {
    //   block [0x82FC4128..0x82FC41C4)
	// 82FC4128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC412C: 4BCE52A5  bl 0x82ca93d0
	ctx.lr = 0x82FC4130;
	sub_82CA93D0(ctx, base);
	// 82FC4130: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82FC4134: 4BCE9B8D  bl 0x82cadcc0
	ctx.lr = 0x82FC4138;
	sub_82CADCA0(ctx, base);
	// 82FC4138: 9421F9A0  stwu r1, -0x660(r1)
	ea = ctx.r[1].u32.wrapping_add(-1632 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC413C: 7CB22B78  mr r18, r5
	ctx.r[18].u64 = ctx.r[5].u64;
	// 82FC4140: FF000890  fmr f24, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[24].f64 = ctx.f[1].f64;
	// 82FC4144: 7D374B78  mr r23, r9
	ctx.r[23].u64 = ctx.r[9].u64;
	// 82FC4148: FEC01090  fmr f22, f2
	ctx.f[22].f64 = ctx.f[2].f64;
	// 82FC414C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82FC4150: 7C902378  mr r16, r4
	ctx.r[16].u64 = ctx.r[4].u64;
	// 82FC4154: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82FC4158: A1320004  lhz r9, 4(r18)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[18].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC415C: 39E00001  li r15, 1
	ctx.r[15].s64 = 1;
	// 82FC4160: 8172000C  lwz r11, 0xc(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC4164: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82FC4168: 7D2707B4  extsw r7, r9
	ctx.r[7].s64 = ctx.r[9].s32 as i64;
	// 82FC416C: C2E80C14  lfs f23, 0xc14(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3092 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82FC4170: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82FC4174: 82300000  lwz r17, 0(r16)
	ctx.r[17].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC4178: F8E10088  std r7, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[7].u64 ) };
	// 82FC417C: C8010088  lfd f0, 0x88(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 82FC4180: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC4184: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82FC4188: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82FC418C: FFE0B890  fmr f31, f23
	ctx.f[31].f64 = ctx.f[23].f64;
	// 82FC4190: 99E10060  stb r15, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[15].u8 ) };
	// 82FC4194: FFC0B890  fmr f30, f23
	ctx.f[30].f64 = ctx.f[23].f64;
	// 82FC4198: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82FC419C: FF800018  frsp f28, f0
	ctx.f[28].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC41A0: 554EDFFE  rlwinm r14, r10, 0x1b, 0x1f, 0x1f
	ctx.r[14].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82FC41A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC41A8: 409A001C  bne cr6, 0x82fc41c4
	if !ctx.cr[6].eq {
	pc = 0x82FC41C4; continue 'dispatch;
	}
	// 82FC41AC: 89520008  lbz r10, 8(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC41B0: 390000FF  li r8, 0xff
	ctx.r[8].s64 = 255;
	// 82FC41B4: 7D485010  subfc r10, r8, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[8].u32;
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82FC41B8: 7D4A5110  subfe r10, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[10].u32 = res;
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82FC41BC: 554A07FE  clrlwi r10, r10, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 82FC41C0: 4800000C  b 0x82fc41cc
	pc = 0x82FC41CC; continue 'dispatch;
            }
            0x82FC41C4 => {
    //   block [0x82FC41C4..0x82FC41CC)
	// 82FC41C4: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82FC41C8: 554AFFFE  rlwinm r10, r10, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	pc = 0x82FC41CC; continue 'dispatch;
            }
            0x82FC41CC => {
    //   block [0x82FC41CC..0x82FC41D8)
	// 82FC41CC: 554A063F  clrlwi. r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC41D0: 41820008  beq 0x82fc41d8
	if ctx.cr[0].eq {
	pc = 0x82FC41D8; continue 'dispatch;
	}
	// 82FC41D4: 7FAEEB78  mr r14, r29
	ctx.r[14].u64 = ctx.r[29].u64;
	pc = 0x82FC41D8; continue 'dispatch;
            }
            0x82FC41D8 => {
    //   block [0x82FC41D8..0x82FC41F4)
	// 82FC41D8: 8111001C  lwz r8, 0x1c(r17)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC41DC: 550A06F7  rlwinm. r10, r8, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC41E0: 41820014  beq 0x82fc41f4
	if ctx.cr[0].eq {
	pc = 0x82FC41F4; continue 'dispatch;
	}
	// 82FC41E4: 81510024  lwz r10, 0x24(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC41E8: 554A05EF  rlwinm. r10, r10, 0, 0x17, 0x17
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC41EC: 7DEA7B78  mr r10, r15
	ctx.r[10].u64 = ctx.r[15].u64;
	// 82FC41F0: 40820008  bne 0x82fc41f8
	if !ctx.cr[0].eq {
	pc = 0x82FC41F8; continue 'dispatch;
	}
	pc = 0x82FC41F4; continue 'dispatch;
            }
            0x82FC41F4 => {
    //   block [0x82FC41F4..0x82FC41F8)
	// 82FC41F4: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x82FC41F8; continue 'dispatch;
            }
            0x82FC41F8 => {
    //   block [0x82FC41F8..0x82FC4214)
	// 82FC41F8: 555E063E  clrlwi r30, r10, 0x18
	ctx.r[30].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82FC41FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC4200: 419A0014  beq cr6, 0x82fc4214
	if ctx.cr[6].eq {
	pc = 0x82FC4214; continue 'dispatch;
	}
	// 82FC4204: 81710024  lwz r11, 0x24(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC4208: 556BBFFF  rlwinm. r11, r11, 0x17, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000001FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC420C: 40820008  bne 0x82fc4214
	if !ctx.cr[0].eq {
	pc = 0x82FC4214; continue 'dispatch;
	}
	// 82FC4210: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x82FC4214; continue 'dispatch;
            }
            0x82FC4214 => {
    //   block [0x82FC4214..0x82FC423C)
	// 82FC4214: 550B07BE  clrlwi r11, r8, 0x1e
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 82FC4218: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82FC421C: 419A111C  beq cr6, 0x82fc5338
	if ctx.cr[6].eq {
	pc = 0x82FC5338; continue 'dispatch;
	}
	// 82FC4220: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82FC4224: 419A1114  beq cr6, 0x82fc5338
	if ctx.cr[6].eq {
	pc = 0x82FC5338; continue 'dispatch;
	}
	// 82FC4228: 8BE106B7  lbz r31, 0x6b7(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(1719 as u32) ) } as u64;
	// 82FC422C: 281F0000  cmplwi r31, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC4230: 4182000C  beq 0x82fc423c
	if ctx.cr[0].eq {
	pc = 0x82FC423C; continue 'dispatch;
	}
	// 82FC4234: FF60B890  fmr f27, f23
	ctx.f[27].f64 = ctx.f[23].f64;
	// 82FC4238: 48000010  b 0x82fc4248
	pc = 0x82FC4248; continue 'dispatch;
            }
            0x82FC423C => {
    //   block [0x82FC423C..0x82FC4248)
	// 82FC423C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82FC4240: 4BFA8B21  bl 0x82f6cd60
	ctx.lr = 0x82FC4244;
	sub_82F6CD60(ctx, base);
	// 82FC4244: FF600818  frsp f27, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[27].f64 = (ctx.f[1].f64 as f32) as f64;
	pc = 0x82FC4248; continue 'dispatch;
            }
            0x82FC4248 => {
    //   block [0x82FC4248..0x82FC4258)
	// 82FC4248: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82FC424C: 419A000C  beq cr6, 0x82fc4258
	if ctx.cr[6].eq {
	pc = 0x82FC4258; continue 'dispatch;
	}
	// 82FC4250: FF40B890  fmr f26, f23
	ctx.f[26].f64 = ctx.f[23].f64;
	// 82FC4254: 48000010  b 0x82fc4264
	pc = 0x82FC4264; continue 'dispatch;
            }
            0x82FC4258 => {
    //   block [0x82FC4258..0x82FC4264)
	// 82FC4258: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82FC425C: 4BFA8B1D  bl 0x82f6cd78
	ctx.lr = 0x82FC4260;
	sub_82F6CD78(ctx, base);
	// 82FC4260: FF400818  frsp f26, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[26].f64 = (ctx.f[1].f64 as f32) as f64;
	pc = 0x82FC4264; continue 'dispatch;
            }
            0x82FC4264 => {
    //   block [0x82FC4264..0x82FC42B0)
	// 82FC4264: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC4268: A1720010  lhz r11, 0x10(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[18].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC426C: 556B077D  rlwinm. r11, r11, 0, 0x1d, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC4270: C32A0C18  lfs f25, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82FC4274: 418200F4  beq 0x82fc4368
	if ctx.cr[0].eq {
	pc = 0x82FC4368; continue 'dispatch;
	}
	// 82FC4278: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82FC427C: 419A00A4  beq cr6, 0x82fc4320
	if ctx.cr[6].eq {
	pc = 0x82FC4320; continue 'dispatch;
	}
	// 82FC4280: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82FC4284: 419A002C  beq cr6, 0x82fc42b0
	if ctx.cr[6].eq {
	pc = 0x82FC42B0; continue 'dispatch;
	}
	// 82FC4288: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 82FC428C: 409A0110  bne cr6, 0x82fc439c
	if !ctx.cr[6].eq {
	pc = 0x82FC439C; continue 'dispatch;
	}
	// 82FC4290: EDBB06F2  fmuls f13, f27, f27
	ctx.f[13].f64 = (((ctx.f[27].f64 * ctx.f[27].f64) as f32) as f64);
	// 82FC4294: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82FC4298: FFE0B890  fmr f31, f23
	ctx.f[31].f64 = ctx.f[23].f64;
	// 82FC429C: C00B23F8  lfs f0, 0x23f8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC42A0: EDBA6EBA  fmadds f13, f26, f26, f13
	ctx.f[13].f64 = (((ctx.f[26].f64 * ctx.f[26].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FC42A4: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 82FC42A8: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC42AC: 480000F0  b 0x82fc439c
	pc = 0x82FC439C; continue 'dispatch;
            }
            0x82FC42B0 => {
    //   block [0x82FC42B0..0x82FC42DC)
	// 82FC42B0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82FC42B4: 4BFA8ADD  bl 0x82f6cd90
	ctx.lr = 0x82FC42B8;
	sub_82F6CD90(ctx, base);
	// 82FC42B8: FFC00818  frsp f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FC42BC: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82FC42C0: C00B0E60  lfs f0, 0xe60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3680 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC42C4: EC3E0028  fsubs f1, f30, f0
	ctx.f[1].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 82FC42C8: 4B275BE9  bl 0x82239eb0
	ctx.lr = 0x82FC42CC;
	sub_82239EB0(ctx, base);
	// 82FC42CC: FFE00818  frsp f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FC42D0: FF1FC800  fcmpu cr6, f31, f25
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[25].f64);
	// 82FC42D4: 41990008  bgt cr6, 0x82fc42dc
	if ctx.cr[6].gt {
	pc = 0x82FC42DC; continue 'dispatch;
	}
	// 82FC42D8: FFE0C890  fmr f31, f25
	ctx.f[31].f64 = ctx.f[25].f64;
	pc = 0x82FC42DC; continue 'dispatch;
            }
            0x82FC42DC => {
    //   block [0x82FC42DC..0x82FC42F4)
	// 82FC42DC: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82FC42E0: 4B275CB1  bl 0x82239f90
	ctx.lr = 0x82FC42E4;
	sub_82239F90(ctx, base);
	// 82FC42E4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FC42E8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82FC42EC: EFC006F2  fmuls f30, f0, f27
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82FC42F0: 4B275BC1  bl 0x82239eb0
	ctx.lr = 0x82FC42F4;
	sub_82239EB0(ctx, base);
	pc = 0x82FC42F4; continue 'dispatch;
            }
            0x82FC42F4 => {
    //   block [0x82FC42F4..0x82FC4320)
	// 82FC42F4: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FC42F8: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82FC42FC: ED9E07B2  fmuls f12, f30, f30
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[30].f64) as f32) as f64);
	// 82FC4300: C00B23DC  lfs f0, 0x23dc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9180 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC4304: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC4308: EDAD06B2  fmuls f13, f13, f26
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[26].f64) as f32) as f64);
	// 82FC430C: EDAD637A  fmadds f13, f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82FC4310: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 82FC4314: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC4318: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 82FC431C: 48000080  b 0x82fc439c
	pc = 0x82FC439C; continue 'dispatch;
            }
            0x82FC4320 => {
    //   block [0x82FC4320..0x82FC434C)
	// 82FC4320: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82FC4324: 4BFA8A6D  bl 0x82f6cd90
	ctx.lr = 0x82FC4328;
	sub_82F6CD90(ctx, base);
	// 82FC4328: FFC00818  frsp f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FC432C: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82FC4330: C00B0E60  lfs f0, 0xe60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3680 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC4334: EC3E002A  fadds f1, f30, f0
	ctx.f[1].f64 = ((ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64;
	// 82FC4338: 4B275B79  bl 0x82239eb0
	ctx.lr = 0x82FC433C;
	sub_82239EB0(ctx, base);
	// 82FC433C: FFE00818  frsp f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FC4340: FF1FC800  fcmpu cr6, f31, f25
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[25].f64);
	// 82FC4344: 41990008  bgt cr6, 0x82fc434c
	if ctx.cr[6].gt {
	pc = 0x82FC434C; continue 'dispatch;
	}
	// 82FC4348: FFE0C890  fmr f31, f25
	ctx.f[31].f64 = ctx.f[25].f64;
	pc = 0x82FC434C; continue 'dispatch;
            }
            0x82FC434C => {
    //   block [0x82FC434C..0x82FC4368)
	// 82FC434C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82FC4350: 4B275B61  bl 0x82239eb0
	ctx.lr = 0x82FC4354;
	sub_82239EB0(ctx, base);
	// 82FC4354: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FC4358: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82FC435C: EFC006F2  fmuls f30, f0, f27
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82FC4360: 4B275C31  bl 0x82239f90
	ctx.lr = 0x82FC4364;
	sub_82239F90(ctx, base);
	// 82FC4364: 4BFFFF90  b 0x82fc42f4
	pc = 0x82FC42F4; continue 'dispatch;
            }
            0x82FC4368 => {
    //   block [0x82FC4368..0x82FC4398)
	// 82FC4368: EDBB06F2  fmuls f13, f27, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[27].f64 * ctx.f[27].f64) as f32) as f64);
	// 82FC436C: 3D608202  lis r11, -0x7dfe
	ctx.r[11].s64 = -2113798144;
	// 82FC4370: 8151001C  lwz r10, 0x1c(r17)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC4374: 554A07BF  clrlwi. r10, r10, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC4378: EDBA6EBA  fmadds f13, f26, f26, f13
	ctx.f[13].f64 = (((ctx.f[26].f64 * ctx.f[26].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FC437C: C00B23F8  lfs f0, 0x23f8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC4380: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 82FC4384: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC4388: 41820010  beq 0x82fc4398
	if ctx.cr[0].eq {
	pc = 0x82FC4398; continue 'dispatch;
	}
	// 82FC438C: 9BA10060  stb r29, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u8 ) };
	// 82FC4390: FFE0B890  fmr f31, f23
	ctx.f[31].f64 = ctx.f[23].f64;
	// 82FC4394: 48000008  b 0x82fc439c
	pc = 0x82FC439C; continue 'dispatch;
            }
            0x82FC4398 => {
    //   block [0x82FC4398..0x82FC439C)
	// 82FC4398: FFE0F090  fmr f31, f30
	ctx.f[31].f64 = ctx.f[30].f64;
	pc = 0x82FC439C; continue 'dispatch;
            }
            0x82FC439C => {
    //   block [0x82FC439C..0x82FC43C4)
	// 82FC439C: C0100020  lfs f0, 0x20(r16)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC43A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC43A4: EDA00732  fmuls f13, f0, f28
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82FC43A8: C1910020  lfs f12, 0x20(r17)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC43AC: C3AB0AC8  lfs f29, 0xac8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2760 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82FC43B0: ED8C0772  fmuls f12, f12, f29
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[29].f64) as f32) as f64);
	// 82FC43B4: EDAD07B2  fmuls f13, f13, f30
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[30].f64) as f32) as f64);
	// 82FC43B8: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 82FC43BC: 41990008  bgt cr6, 0x82fc43c4
	if ctx.cr[6].gt {
	pc = 0x82FC43C4; continue 'dispatch;
	}
	// 82FC43C0: 7DEE7B78  mr r14, r15
	ctx.r[14].u64 = ctx.r[15].u64;
	pc = 0x82FC43C4; continue 'dispatch;
            }
            0x82FC43C4 => {
    //   block [0x82FC43C4..0x82FC43D4)
	// 82FC43C4: FF0DE800  fcmpu cr6, f13, f29
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[29].f64);
	// 82FC43C8: 4098000C  bge cr6, 0x82fc43d4
	if !ctx.cr[6].lt {
	pc = 0x82FC43D4; continue 'dispatch;
	}
	// 82FC43CC: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82FC43D0: EF9D0024  fdivs f28, f29, f0
	ctx.f[28].f64 = ((ctx.f[29].f64 / ctx.f[0].f64) as f32) as f64;
	pc = 0x82FC43D4; continue 'dispatch;
            }
            0x82FC43D4 => {
    //   block [0x82FC43D4..0x82FC4414)
	// 82FC43D4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC43D8: 80790024  lwz r3, 0x24(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC43DC: EF9C07F2  fmuls f28, f28, f31
	ctx.f[28].f64 = (((ctx.f[28].f64 * ctx.f[31].f64) as f32) as f64);
	// 82FC43E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC43E4: C3EB0A4C  lfs f31, 0xa4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2636 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82FC43E8: 419A012C  beq cr6, 0x82fc4514
	if ctx.cr[6].eq {
	pc = 0x82FC4514; continue 'dispatch;
	}
	// 82FC43EC: 89410060  lbz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82FC43F0: 89390030  lbz r9, 0x30(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FC43F4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82FC43F8: 409A00D4  bne cr6, 0x82fc44cc
	if !ctx.cr[6].eq {
	pc = 0x82FC44CC; continue 'dispatch;
	}
	// 82FC43FC: 8979002F  lbz r11, 0x2f(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(47 as u32) ) } as u64;
	// 82FC4400: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC4404: 41820010  beq 0x82fc4414
	if ctx.cr[0].eq {
	pc = 0x82FC4414; continue 'dispatch;
	}
	// 82FC4408: 55C9063E  clrlwi r9, r14, 0x18
	ctx.r[9].u64 = ctx.r[14].u32 as u64 & 0x000000FFu64;
	// 82FC440C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC4410: 409A00BC  bne cr6, 0x82fc44cc
	if !ctx.cr[6].eq {
	pc = 0x82FC44CC; continue 'dispatch;
	}
	pc = 0x82FC4414; continue 'dispatch;
            }
            0x82FC4414 => {
    //   block [0x82FC4414..0x82FC4438)
	// 82FC4414: 8979002D  lbz r11, 0x2d(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(45 as u32) ) } as u64;
	// 82FC4418: 57C9063E  clrlwi r9, r30, 0x18
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 82FC441C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC4420: 409A00AC  bne cr6, 0x82fc44cc
	if !ctx.cr[6].eq {
	pc = 0x82FC44CC; continue 'dispatch;
	}
	// 82FC4424: 56EB063F  clrlwi. r11, r23, 0x18
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC4428: 41820010  beq 0x82fc4438
	if ctx.cr[0].eq {
	pc = 0x82FC4438; continue 'dispatch;
	}
	// 82FC442C: 8979002E  lbz r11, 0x2e(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(46 as u32) ) } as u64;
	// 82FC4430: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC4434: 41820098  beq 0x82fc44cc
	if ctx.cr[0].eq {
	pc = 0x82FC44CC; continue 'dispatch;
	}
	pc = 0x82FC4438; continue 'dispatch;
            }
            0x82FC4438 => {
    //   block [0x82FC4438..0x82FC44AC)
	// 82FC4438: 8171001C  lwz r11, 0x1c(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC443C: 556BF7FF  rlwinm. r11, r11, 0x1e, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC4440: 41820088  beq 0x82fc44c8
	if ctx.cr[0].eq {
	pc = 0x82FC44C8; continue 'dispatch;
	}
	// 82FC4444: C0190028  lfs f0, 0x28(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC4448: EDA0F828  fsubs f13, f0, f31
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 82FC444C: FF1C6800  fcmpu cr6, f28, f13
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[13].f64);
	// 82FC4450: 4099007C  ble cr6, 0x82fc44cc
	if !ctx.cr[6].gt {
	pc = 0x82FC44CC; continue 'dispatch;
	}
	// 82FC4454: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 82FC4458: FF1C0000  fcmpu cr6, f28, f0
	ctx.cr[6].compare_f64(ctx.f[28].f64, ctx.f[0].f64);
	// 82FC445C: 40980070  bge cr6, 0x82fc44cc
	if !ctx.cr[6].lt {
	pc = 0x82FC44CC; continue 'dispatch;
	}
	// 82FC4460: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82FC4464: 419A0064  beq cr6, 0x82fc44c8
	if ctx.cr[6].eq {
	pc = 0x82FC44C8; continue 'dispatch;
	}
	// 82FC4468: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FC446C: C1B90038  lfs f13, 0x38(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC4470: C00B6970  lfs f0, 0x6970(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(26992 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC4474: EC180032  fmuls f0, f24, f0
	ctx.f[0].f64 = (((ctx.f[24].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC4478: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82FC447C: FF1A6000  fcmpu cr6, f26, f12
	ctx.cr[6].compare_f64(ctx.f[26].f64, ctx.f[12].f64);
	// 82FC4480: 4198004C  blt cr6, 0x82fc44cc
	if ctx.cr[6].lt {
	pc = 0x82FC44CC; continue 'dispatch;
	}
	// 82FC4484: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82FC4488: FF1A6800  fcmpu cr6, f26, f13
	ctx.cr[6].compare_f64(ctx.f[26].f64, ctx.f[13].f64);
	// 82FC448C: 41990040  bgt cr6, 0x82fc44cc
	if ctx.cr[6].gt {
	pc = 0x82FC44CC; continue 'dispatch;
	}
	// 82FC4490: C1B90034  lfs f13, 0x34(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC4494: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82FC4498: FF1B6000  fcmpu cr6, f27, f12
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[12].f64);
	// 82FC449C: 41980010  blt cr6, 0x82fc44ac
	if ctx.cr[6].lt {
	pc = 0x82FC44AC; continue 'dispatch;
	}
	// 82FC44A0: ED8D002A  fadds f12, f13, f0
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82FC44A4: FF1B6000  fcmpu cr6, f27, f12
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[12].f64);
	// 82FC44A8: 40990020  ble cr6, 0x82fc44c8
	if !ctx.cr[6].gt {
	pc = 0x82FC44C8; continue 'dispatch;
	}
	pc = 0x82FC44AC; continue 'dispatch;
            }
            0x82FC44AC => {
    //   block [0x82FC44AC..0x82FC44C8)
	// 82FC44AC: FD806850  fneg f12, f13
	ctx.f[12].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82FC44B0: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82FC44B4: FF1B6000  fcmpu cr6, f27, f12
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[12].f64);
	// 82FC44B8: 41980014  blt cr6, 0x82fc44cc
	if ctx.cr[6].lt {
	pc = 0x82FC44CC; continue 'dispatch;
	}
	// 82FC44BC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FC44C0: FF1B0000  fcmpu cr6, f27, f0
	ctx.cr[6].compare_f64(ctx.f[27].f64, ctx.f[0].f64);
	// 82FC44C4: 41990008  bgt cr6, 0x82fc44cc
	if ctx.cr[6].gt {
	pc = 0x82FC44CC; continue 'dispatch;
	}
	pc = 0x82FC44C8; continue 'dispatch;
            }
            0x82FC44C8 => {
    //   block [0x82FC44C8..0x82FC44CC)
	// 82FC44C8: 7DFC7B78  mr r28, r15
	ctx.r[28].u64 = ctx.r[15].u64;
	pc = 0x82FC44CC; continue 'dispatch;
            }
            0x82FC44CC => {
    //   block [0x82FC44CC..0x82FC4508)
	// 82FC44CC: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC44D0: 4082006C  bne 0x82fc453c
	if !ctx.cr[0].eq {
	pc = 0x82FC453C; continue 'dispatch;
	}
	// 82FC44D4: 4BFFE9C5  bl 0x82fc2e98
	ctx.lr = 0x82FC44D8;
	sub_82FC2E98(ctx, base);
	// 82FC44D8: 3879003C  addi r3, r25, 0x3c
	ctx.r[3].s64 = ctx.r[25].s64 + 60;
	// 82FC44DC: 48002BD5  bl 0x82fc70b0
	ctx.lr = 0x82FC44E0;
	sub_82FC70B0(ctx, base);
	// 82FC44E0: 80790058  lwz r3, 0x58(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(88 as u32) ) } as u64;
	// 82FC44E4: 3BF90058  addi r31, r25, 0x58
	ctx.r[31].s64 = ctx.r[25].s64 + 88;
	// 82FC44E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC44EC: 419A001C  beq cr6, 0x82fc4508
	if ctx.cr[6].eq {
	pc = 0x82FC4508; continue 'dispatch;
	}
	// 82FC44F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC44F4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82FC44F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC44FC: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82FC4500: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC4504: 4E800421  bctrl
	ctx.lr = 0x82FC4508;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC4508 => {
    //   block [0x82FC4508..0x82FC4514)
	// 82FC4508: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82FC450C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82FC4510: 4800002C  b 0x82fc453c
	pc = 0x82FC453C; continue 'dispatch;
            }
            0x82FC4514 => {
    //   block [0x82FC4514..0x82FC452C)
	// 82FC4514: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 82FC4518: 4BF39349  bl 0x82efd860
	ctx.lr = 0x82FC451C;
	sub_82EFD860(ctx, base);
	// 82FC451C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC4520: 4182000C  beq 0x82fc452c
	if ctx.cr[0].eq {
	pc = 0x82FC452C; continue 'dispatch;
	}
	// 82FC4524: 4BFFE605  bl 0x82fc2b28
	ctx.lr = 0x82FC4528;
	sub_82FC2B28(ctx, base);
	// 82FC4528: 48000008  b 0x82fc4530
	pc = 0x82FC4530; continue 'dispatch;
            }
            0x82FC452C => {
    //   block [0x82FC452C..0x82FC4530)
	// 82FC452C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x82FC4530; continue 'dispatch;
            }
            0x82FC4530 => {
    //   block [0x82FC4530..0x82FC453C)
	// 82FC4530: 90790024  stw r3, 0x24(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 82FC4534: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC4538: 419A0E9C  beq cr6, 0x82fc53d4
	if ctx.cr[6].eq {
	pc = 0x82FC53D4; continue 'dispatch;
	}
	pc = 0x82FC453C; continue 'dispatch;
            }
            0x82FC453C => {
    //   block [0x82FC453C..0x82FC4570)
	// 82FC453C: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC4540: 40820D5C  bne 0x82fc529c
	if !ctx.cr[0].eq {
	pc = 0x82FC529C; continue 'dispatch;
	}
	// 82FC4544: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 82FC4548: 4BFA8431  bl 0x82f6c978
	ctx.lr = 0x82FC454C;
	sub_82F6C978(ctx, base);
	// 82FC454C: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 82FC4550: 4BFA8429  bl 0x82f6c978
	ctx.lr = 0x82FC4554;
	sub_82F6C978(ctx, base);
	// 82FC4554: 8171001C  lwz r11, 0x1c(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC4558: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC455C: 41820014  beq 0x82fc4570
	if ctx.cr[0].eq {
	pc = 0x82FC4570; continue 'dispatch;
	}
	// 82FC4560: 81710024  lwz r11, 0x24(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC4564: 556B05EF  rlwinm. r11, r11, 0, 0x17, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC4568: 7DEB7B78  mr r11, r15
	ctx.r[11].u64 = ctx.r[15].u64;
	// 82FC456C: 40820008  bne 0x82fc4574
	if !ctx.cr[0].eq {
	pc = 0x82FC4574; continue 'dispatch;
	}
	pc = 0x82FC4570; continue 'dispatch;
            }
            0x82FC4570 => {
    //   block [0x82FC4570..0x82FC4574)
	// 82FC4570: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82FC4574; continue 'dispatch;
            }
            0x82FC4574 => {
    //   block [0x82FC4574..0x82FC458C)
	// 82FC4574: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC4578: 41820014  beq 0x82fc458c
	if ctx.cr[0].eq {
	pc = 0x82FC458C; continue 'dispatch;
	}
	// 82FC457C: 8979002C  lbz r11, 0x2c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) } as u64;
	// 82FC4580: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC4584: 7DEB7B78  mr r11, r15
	ctx.r[11].u64 = ctx.r[15].u64;
	// 82FC4588: 41820008  beq 0x82fc4590
	if ctx.cr[0].eq {
	pc = 0x82FC4590; continue 'dispatch;
	}
	pc = 0x82FC458C; continue 'dispatch;
            }
            0x82FC458C => {
    //   block [0x82FC458C..0x82FC4590)
	// 82FC458C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82FC4590; continue 'dispatch;
            }
            0x82FC4590 => {
    //   block [0x82FC4590..0x82FC45B0)
	// 82FC4590: 8152000C  lwz r10, 0xc(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC4594: 5578063E  clrlwi r24, r11, 0x18
	ctx.r[24].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82FC4598: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82FC459C: 419A0014  beq cr6, 0x82fc45b0
	if ctx.cr[6].eq {
	pc = 0x82FC45B0; continue 'dispatch;
	}
	// 82FC45A0: 81710024  lwz r11, 0x24(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC45A4: 556BBFFF  rlwinm. r11, r11, 0x17, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000001FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC45A8: 40820008  bne 0x82fc45b0
	if !ctx.cr[0].eq {
	pc = 0x82FC45B0; continue 'dispatch;
	}
	// 82FC45AC: 7FB8EB78  mr r24, r29
	ctx.r[24].u64 = ctx.r[29].u64;
	pc = 0x82FC45B0; continue 'dispatch;
            }
            0x82FC45B0 => {
    //   block [0x82FC45B0..0x82FC45D8)
	// 82FC45B0: 56EB063F  clrlwi. r11, r23, 0x18
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC45B4: 41820028  beq 0x82fc45dc
	if ctx.cr[0].eq {
	pc = 0x82FC45DC; continue 'dispatch;
	}
	// 82FC45B8: 81710028  lwz r11, 0x28(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC45BC: 556BE7FF  rlwinm. r11, r11, 0x1c, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC45C0: 4082001C  bne 0x82fc45dc
	if !ctx.cr[0].eq {
	pc = 0x82FC45DC; continue 'dispatch;
	}
	// 82FC45C4: 81710024  lwz r11, 0x24(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC45C8: 556BA7FF  rlwinm. r11, r11, 0x14, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC45CC: 4182000C  beq 0x82fc45d8
	if ctx.cr[0].eq {
	pc = 0x82FC45D8; continue 'dispatch;
	}
	// 82FC45D0: 7FB8EB78  mr r24, r29
	ctx.r[24].u64 = ctx.r[29].u64;
	// 82FC45D4: 48000008  b 0x82fc45dc
	pc = 0x82FC45DC; continue 'dispatch;
            }
            0x82FC45D8 => {
    //   block [0x82FC45D8..0x82FC45DC)
	// 82FC45D8: 7FB7EB78  mr r23, r29
	ctx.r[23].u64 = ctx.r[29].u64;
	pc = 0x82FC45DC; continue 'dispatch;
            }
            0x82FC45DC => {
    //   block [0x82FC45DC..0x82FC4614)
	// 82FC45DC: 8A810060  lbz r20, 0x60(r1)
	ctx.r[20].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82FC45E0: 28140000  cmplwi r20, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC45E4: 41820030  beq 0x82fc4614
	if ctx.cr[0].eq {
	pc = 0x82FC4614; continue 'dispatch;
	}
	// 82FC45E8: C01B0000  lfs f0, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC45EC: 38810190  addi r4, r1, 0x190
	ctx.r[4].s64 = ctx.r[1].s64 + 400;
	// 82FC45F0: C1BB0010  lfs f13, 0x10(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC45F4: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 82FC45F8: C19B0004  lfs f12, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC45FC: C17B0014  lfs f11, 0x14(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC4600: D0010190  stfs f0, 0x190(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82FC4604: D1A101A0  stfs f13, 0x1a0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82FC4608: D1810194  stfs f12, 0x194(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 82FC460C: D16101A4  stfs f11, 0x1a4(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 82FC4610: 4BFA8609  bl 0x82f6cc18
	ctx.lr = 0x82FC4614;
	sub_82F6CC18(ctx, base);
	pc = 0x82FC4614; continue 'dispatch;
            }
            0x82FC4614 => {
    //   block [0x82FC4614..0x82FC4634)
	// 82FC4614: 386101D0  addi r3, r1, 0x1d0
	ctx.r[3].s64 = ctx.r[1].s64 + 464;
	// 82FC4618: 4BF85921  bl 0x82f49f38
	ctx.lr = 0x82FC461C;
	sub_82F49F38(ctx, base);
	// 82FC461C: 8179001C  lwz r11, 0x1c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC4620: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 82FC4624: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 82FC4628: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC462C: 40990164  ble cr6, 0x82fc4790
	if !ctx.cr[6].gt {
	pc = 0x82FC4790; continue 'dispatch;
	}
	// 82FC4630: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	pc = 0x82FC4634; continue 'dispatch;
            }
            0x82FC4634 => {
    //   block [0x82FC4634..0x82FC4678)
	// 82FC4634: 81790018  lwz r11, 0x18(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC4638: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82FC463C: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 82FC4640: 80D90000  lwz r6, 0(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC4644: 386101D0  addi r3, r1, 0x1d0
	ctx.r[3].s64 = ctx.r[1].s64 + 464;
	// 82FC4648: 7FEBD82E  lwzx r31, r11, r27
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82FC464C: 48002185  bl 0x82fc67d0
	ctx.lr = 0x82FC4650;
	sub_82FC67D0(ctx, base);
	// 82FC4650: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 82FC4654: 419A00A8  beq cr6, 0x82fc46fc
	if ctx.cr[6].eq {
	pc = 0x82FC46FC; continue 'dispatch;
	}
	// 82FC4658: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82FC465C: 419A0120  beq cr6, 0x82fc477c
	if ctx.cr[6].eq {
	pc = 0x82FC477C; continue 'dispatch;
	}
	// 82FC4660: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 82FC4664: 579E083C  slwi r30, r28, 1
	ctx.r[30].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82FC4668: 556BF87E  srwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC466C: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 82FC4670: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC4674: 7F8BE214  add r28, r11, r28
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x82FC4678; continue 'dispatch;
            }
            0x82FC4678 => {
    //   block [0x82FC4678..0x82FC46FC)
	// 82FC4678: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC467C: 38A10098  addi r5, r1, 0x98
	ctx.r[5].s64 = ctx.r[1].s64 + 152;
	// 82FC4680: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82FC4684: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82FC4688: 38610190  addi r3, r1, 0x190
	ctx.r[3].s64 = ctx.r[1].s64 + 400;
	// 82FC468C: A94B0000  lha r10, 0(r11)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 82FC4690: A96B0002  lha r11, 2(r11)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as i16) as i64;
	// 82FC4694: F9610188  std r11, 0x188(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[11].u64 ) };
	// 82FC4698: C9A10188  lfd f13, 0x188(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) };
	// 82FC469C: F9410178  std r10, 0x178(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[10].u64 ) };
	// 82FC46A0: C8010178  lfd f0, 0x178(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) };
	// 82FC46A4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC46A8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82FC46AC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC46B0: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82FC46B4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82FC46B8: D1A1009C  stfs f13, 0x9c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82FC46BC: 4BFA84CD  bl 0x82f6cb88
	ctx.lr = 0x82FC46C0;
	sub_82F6CB88(ctx, base);
	// 82FC46C0: C0010068  lfs f0, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC46C4: C1A1006C  lfs f13, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC46C8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82FC46CC: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82FC46D0: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 82FC46D4: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82FC46D8: 4BF866A1  bl 0x82f4ad78
	ctx.lr = 0x82FC46DC;
	sub_82F4AD78(ctx, base);
	// 82FC46DC: 81610200  lwz r11, 0x200(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(512 as u32) ) } as u64;
	// 82FC46E0: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82FC46E4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82FC46E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC46EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82FC46F0: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82FC46F4: 4082FF84  bne 0x82fc4678
	if !ctx.cr[0].eq {
	pc = 0x82FC4678; continue 'dispatch;
	}
	// 82FC46F8: 48000084  b 0x82fc477c
	pc = 0x82FC477C; continue 'dispatch;
            }
            0x82FC46FC => {
    //   block [0x82FC46FC..0x82FC471C)
	// 82FC46FC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82FC4700: 419A007C  beq cr6, 0x82fc477c
	if ctx.cr[6].eq {
	pc = 0x82FC477C; continue 'dispatch;
	}
	// 82FC4704: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 82FC4708: 579E083C  slwi r30, r28, 1
	ctx.r[30].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82FC470C: 556BF87E  srwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC4710: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 82FC4714: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC4718: 7F8BE214  add r28, r11, r28
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x82FC471C; continue 'dispatch;
            }
            0x82FC471C => {
    //   block [0x82FC471C..0x82FC477C)
	// 82FC471C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC4720: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 82FC4724: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 82FC4728: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82FC472C: A94B0000  lha r10, 0(r11)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 82FC4730: F9410170  std r10, 0x170(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[10].u64 ) };
	// 82FC4734: A96B0002  lha r11, 2(r11)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as i16) as i64;
	// 82FC4738: F9610180  std r11, 0x180(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[11].u64 ) };
	// 82FC473C: C9A10180  lfd f13, 0x180(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(384 as u32) ) };
	// 82FC4740: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82FC4744: C8010170  lfd f0, 0x170(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) };
	// 82FC4748: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC474C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC4750: D00100A0  stfs f0, 0xa0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82FC4754: FC006818  frsp f0, f13
	ctx.f[0].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82FC4758: D00100A4  stfs f0, 0xa4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82FC475C: 4BF8661D  bl 0x82f4ad78
	ctx.lr = 0x82FC4760;
	sub_82F4AD78(ctx, base);
	// 82FC4760: 81610200  lwz r11, 0x200(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(512 as u32) ) } as u64;
	// 82FC4764: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82FC4768: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82FC476C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC4770: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82FC4774: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82FC4778: 4082FFA4  bne 0x82fc471c
	if !ctx.cr[0].eq {
	pc = 0x82FC471C; continue 'dispatch;
	}
	pc = 0x82FC477C; continue 'dispatch;
            }
            0x82FC477C => {
    //   block [0x82FC477C..0x82FC4790)
	// 82FC477C: 8179001C  lwz r11, 0x1c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC4780: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82FC4784: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 82FC4788: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC478C: 4198FEA8  blt cr6, 0x82fc4634
	if ctx.cr[6].lt {
	pc = 0x82FC4634; continue 'dispatch;
	}
	pc = 0x82FC4790; continue 'dispatch;
            }
            0x82FC4790 => {
    //   block [0x82FC4790..0x82FC47C8)
	// 82FC4790: 55CB063F  clrlwi. r11, r14, 0x18
	ctx.r[11].u64 = ctx.r[14].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC4794: 418205BC  beq 0x82fc4d50
	if ctx.cr[0].eq {
	pc = 0x82FC4D50; continue 'dispatch;
	}
	// 82FC4798: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82FC479C: 4BFFEE0D  bl 0x82fc35a8
	ctx.lr = 0x82FC47A0;
	sub_82FC35A8(ctx, base);
	// 82FC47A0: A1320010  lhz r9, 0x10(r18)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[18].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC47A4: 552B0632  rlwinm r11, r9, 0, 0x18, 0x19
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC47A8: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 82FC47AC: 419A001C  beq cr6, 0x82fc47c8
	if ctx.cr[6].eq {
	pc = 0x82FC47C8; continue 'dispatch;
	}
	// 82FC47B0: 396BFF80  addi r11, r11, -0x80
	ctx.r[11].s64 = ctx.r[11].s64 + -128;
	// 82FC47B4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82FC47B8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82FC47BC: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82FC47C0: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82FC47C4: 48000008  b 0x82fc47cc
	pc = 0x82FC47CC; continue 'dispatch;
            }
            0x82FC47C8 => {
    //   block [0x82FC47C8..0x82FC47CC)
	// 82FC47C8: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x82FC47CC; continue 'dispatch;
            }
            0x82FC47CC => {
    //   block [0x82FC47CC..0x82FC47F4)
	// 82FC47CC: 552BF632  rlwinm r11, r9, 0x1e, 0x18, 0x19
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 82FC47D0: 914100F4  stw r10, 0xf4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(244 as u32), ctx.r[10].u32 ) };
	// 82FC47D4: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 82FC47D8: 419A001C  beq cr6, 0x82fc47f4
	if ctx.cr[6].eq {
	pc = 0x82FC47F4; continue 'dispatch;
	}
	// 82FC47DC: 396BFF80  addi r11, r11, -0x80
	ctx.r[11].s64 = ctx.r[11].s64 + -128;
	// 82FC47E0: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82FC47E4: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82FC47E8: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82FC47EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FC47F0: 48000008  b 0x82fc47f8
	pc = 0x82FC47F8; continue 'dispatch;
            }
            0x82FC47F4 => {
    //   block [0x82FC47F4..0x82FC47F8)
	// 82FC47F4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82FC47F8; continue 'dispatch;
            }
            0x82FC47F8 => {
    //   block [0x82FC47F8..0x82FC481C)
	// 82FC47F8: 552A06B6  rlwinm r10, r9, 0, 0x1a, 0x1b
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC47FC: 916100F8  stw r11, 0xf8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[11].u32 ) };
	// 82FC4800: 3A600003  li r19, 3
	ctx.r[19].s64 = 3;
	// 82FC4804: 2F0A0010  cmpwi cr6, r10, 0x10
	ctx.cr[6].compare_i32(ctx.r[10].s32, 16, &mut ctx.xer);
	// 82FC4808: 419A001C  beq cr6, 0x82fc4824
	if ctx.cr[6].eq {
	pc = 0x82FC4824; continue 'dispatch;
	}
	// 82FC480C: 2F0A0020  cmpwi cr6, r10, 0x20
	ctx.cr[6].compare_i32(ctx.r[10].s32, 32, &mut ctx.xer);
	// 82FC4810: 419A000C  beq cr6, 0x82fc481c
	if ctx.cr[6].eq {
	pc = 0x82FC481C; continue 'dispatch;
	}
	// 82FC4814: 7E6B9B78  mr r11, r19
	ctx.r[11].u64 = ctx.r[19].u64;
	// 82FC4818: 48000010  b 0x82fc4828
	pc = 0x82FC4828; continue 'dispatch;
            }
            0x82FC481C => {
    //   block [0x82FC481C..0x82FC4824)
	// 82FC481C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82FC4820: 48000008  b 0x82fc4828
	pc = 0x82FC4828; continue 'dispatch;
            }
            0x82FC4824 => {
    //   block [0x82FC4824..0x82FC4828)
	// 82FC4824: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	pc = 0x82FC4828; continue 'dispatch;
            }
            0x82FC4828 => {
    //   block [0x82FC4828..0x82FC4840)
	// 82FC4828: 554A043E  clrlwi r10, r10, 0x10
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82FC482C: 916100F0  stw r11, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 82FC4830: 2B0A0020  cmplwi cr6, r10, 0x20
	ctx.cr[6].compare_u32(ctx.r[10].u32, 32 as u32, &mut ctx.xer);
	// 82FC4834: 409A000C  bne cr6, 0x82fc4840
	if !ctx.cr[6].eq {
	pc = 0x82FC4840; continue 'dispatch;
	}
	// 82FC4838: C0120014  lfs f0, 0x14(r18)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC483C: D00100FC  stfs f0, 0xfc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), tmp.u32 ) };
	pc = 0x82FC4840; continue 'dispatch;
            }
            0x82FC4840 => {
    //   block [0x82FC4840..0x82FC4868)
	// 82FC4840: EC1805B2  fmuls f0, f24, f22
	ctx.f[0].f64 = (((ctx.f[24].f64 * ctx.f[22].f64) as f32) as f64);
	// 82FC4844: D0010118  stfs f0, 0x118(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82FC4848: 571F063F  clrlwi. r31, r24, 0x18
	ctx.r[31].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82FC484C: 41820030  beq 0x82fc487c
	if ctx.cr[0].eq {
	pc = 0x82FC487C; continue 'dispatch;
	}
	// 82FC4850: C0100020  lfs f0, 0x20(r16)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC4854: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 82FC4858: EC180024  fdivs f0, f24, f0
	ctx.f[0].f64 = ((ctx.f[24].f64 / ctx.f[0].f64) as f32) as f64;
	// 82FC485C: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82FC4860: 409A0008  bne cr6, 0x82fc4868
	if !ctx.cr[6].eq {
	pc = 0x82FC4868; continue 'dispatch;
	}
	// 82FC4864: EC00F024  fdivs f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[30].f64) as f32) as f64;
	pc = 0x82FC4868; continue 'dispatch;
            }
            0x82FC4868 => {
    //   block [0x82FC4868..0x82FC487C)
	// 82FC4868: EDBC0638  fmsubs f13, f28, f24, f0
	ctx.f[13].f64 = (((ctx.f[28].f64 * ctx.f[24].f64 - ctx.f[0].f64) as f32) as f64);
	// 82FC486C: D0010114  stfs f0, 0x114(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82FC4870: D0010110  stfs f0, 0x110(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82FC4874: FDADCB6E  fsel f13, f13, f13, f25
	ctx.f[13].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[25].f64 };
	// 82FC4878: 48000010  b 0x82fc4888
	pc = 0x82FC4888; continue 'dispatch;
            }
            0x82FC487C => {
    //   block [0x82FC487C..0x82FC4888)
	// 82FC487C: D3210114  stfs f25, 0x114(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82FC4880: EDBC0632  fmuls f13, f28, f24
	ctx.f[13].f64 = (((ctx.f[28].f64 * ctx.f[24].f64) as f32) as f64);
	// 82FC4884: D3210110  stfs f25, 0x110(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	pc = 0x82FC4888; continue 'dispatch;
            }
            0x82FC4888 => {
    //   block [0x82FC4888..0x82FC4910)
	// 82FC4888: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC488C: 80B90000  lwz r5, 0(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC4890: 388101D0  addi r4, r1, 0x1d0
	ctx.r[4].s64 = ctx.r[1].s64 + 464;
	// 82FC4894: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82FC4898: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC489C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC48A0: D0010108  stfs f0, 0x108(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82FC48A4: D001010C  stfs f0, 0x10c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), tmp.u32 ) };
	// 82FC48A8: 48017941  bl 0x82fdc1e8
	ctx.lr = 0x82FC48AC;
	sub_82FDC1E8(ctx, base);
	// 82FC48AC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82FC48B0: 419A0280  beq cr6, 0x82fc4b30
	if ctx.cr[6].eq {
	pc = 0x82FC4B30; continue 'dispatch;
	}
	// 82FC48B4: 9AF9002E  stb r23, 0x2e(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(46 as u32), ctx.r[23].u8 ) };
	// 82FC48B8: 56EA063F  clrlwi. r10, r23, 0x18
	ctx.r[10].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC48BC: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 82FC48C0: 7FB8EB78  mr r24, r29
	ctx.r[24].u64 = ctx.r[29].u64;
	// 82FC48C4: 7FB7EB78  mr r23, r29
	ctx.r[23].u64 = ctx.r[29].u64;
	// 82FC48C8: 81720008  lwz r11, 8(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC48CC: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82FC48D0: 89210073  lbz r9, 0x73(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(115 as u32) ) } as u64;
	// 82FC48D4: 89010071  lbz r8, 0x71(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(113 as u32) ) } as u64;
	// 82FC48D8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82FC48DC: 99210071  stb r9, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[9].u8 ) };
	// 82FC48E0: 99010073  stb r8, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[8].u8 ) };
	// 82FC48E4: 4082002C  bne 0x82fc4910
	if !ctx.cr[0].eq {
	pc = 0x82FC4910; continue 'dispatch;
	}
	// 82FC48E8: 8172000C  lwz r11, 0xc(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC48EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC48F0: 409A0020  bne cr6, 0x82fc4910
	if !ctx.cr[6].eq {
	pc = 0x82FC4910; continue 'dispatch;
	}
	// 82FC48F4: 3B99003C  addi r28, r25, 0x3c
	ctx.r[28].s64 = ctx.r[25].s64 + 60;
	// 82FC48F8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82FC48FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC4900: 48002C81  bl 0x82fc7580
	ctx.lr = 0x82FC4904;
	sub_82FC7580(ctx, base);
	// 82FC4904: 82C10070  lwz r22, 0x70(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82FC4908: 56D5023E  clrlwi r21, r22, 8
	ctx.r[21].u64 = ctx.r[22].u32 as u64 & 0x00FFFFFFu64;
	// 82FC490C: 48000040  b 0x82fc494c
	pc = 0x82FC494C; continue 'dispatch;
            }
            0x82FC4910 => {
    //   block [0x82FC4910..0x82FC493C)
	// 82FC4910: 3B99003C  addi r28, r25, 0x3c
	ctx.r[28].s64 = ctx.r[25].s64 + 60;
	// 82FC4914: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82FC4918: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC491C: 48002C65  bl 0x82fc7580
	ctx.lr = 0x82FC4920;
	sub_82FC7580(ctx, base);
	// 82FC4920: 8172000C  lwz r11, 0xc(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC4924: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC4928: 419A0014  beq cr6, 0x82fc493c
	if ctx.cr[6].eq {
	pc = 0x82FC493C; continue 'dispatch;
	}
	// 82FC492C: 3EE000FF  lis r23, 0xff
	ctx.r[23].s64 = 16711680;
	// 82FC4930: 7FF8FB78  mr r24, r31
	ctx.r[24].u64 = ctx.r[31].u64;
	// 82FC4934: 62F7FFFF  ori r23, r23, 0xffff
	ctx.r[23].u64 = ctx.r[23].u64 | 65535;
	// 82FC4938: 4800000C  b 0x82fc4944
	pc = 0x82FC4944; continue 'dispatch;
            }
            0x82FC493C => {
    //   block [0x82FC493C..0x82FC4944)
	// 82FC493C: 3F00FF00  lis r24, -0x100
	ctx.r[24].s64 = -16777216;
	// 82FC4940: 7FB7EB78  mr r23, r29
	ctx.r[23].u64 = ctx.r[29].u64;
	pc = 0x82FC4944; continue 'dispatch;
            }
            0x82FC4944 => {
    //   block [0x82FC4944..0x82FC494C)
	// 82FC4944: 82C10070  lwz r22, 0x70(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 82FC4948: 7ED5B378  mr r21, r22
	ctx.r[21].u64 = ctx.r[22].u64;
	pc = 0x82FC494C; continue 'dispatch;
            }
            0x82FC494C => {
    //   block [0x82FC494C..0x82FC49A4)
	// 82FC494C: 81790024  lwz r11, 0x24(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC4950: 93EB000C  stw r31, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82FC4954: 91EB0000  stw r15, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[15].u32 ) };
	// 82FC4958: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82FC495C: 93EB0008  stw r31, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82FC4960: 81790024  lwz r11, 0x24(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC4964: 8152000C  lwz r10, 0xc(r18)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC4968: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82FC496C: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 82FC4970: 694A0001  xori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 ^ 1;
	// 82FC4974: 914B00D0  stw r10, 0xd0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), ctx.r[10].u32 ) };
	// 82FC4978: 80810134  lwz r4, 0x134(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82FC497C: 2B04FFFE  cmplwi cr6, r4, 0xfffe
	ctx.cr[6].compare_u32(ctx.r[4].u32, 65534 as u32, &mut ctx.xer);
	// 82FC4980: 419902E8  bgt cr6, 0x82fc4c68
	if ctx.cr[6].gt {
	pc = 0x82FC4C68; continue 'dispatch;
	}
	// 82FC4984: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC4988: 480025C1  bl 0x82fc6f48
	ctx.lr = 0x82FC498C;
	sub_82FC6F48(ctx, base);
	// 82FC498C: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82FC4990: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 82FC4994: 419A00E8  beq cr6, 0x82fc4a7c
	if ctx.cr[6].eq {
	pc = 0x82FC4A7C; continue 'dispatch;
	}
	// 82FC4998: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82FC499C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC49A0: 419A0188  beq cr6, 0x82fc4b28
	if ctx.cr[6].eq {
	pc = 0x82FC4B28; continue 'dispatch;
	}
	pc = 0x82FC49A4; continue 'dispatch;
            }
            0x82FC49A4 => {
    //   block [0x82FC49A4..0x82FC4A20)
	// 82FC49A4: 81410140  lwz r10, 0x140(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(320 as u32) ) } as u64;
	// 82FC49A8: 57C9E13A  rlwinm r9, r30, 0x1c, 4, 0x1d
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x0000000Fu64;
	// 82FC49AC: 57CB06BE  clrlwi r11, r30, 0x1a
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x0000003Fu64;
	// 82FC49B0: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82FC49B4: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC49B8: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FC49BC: 7C0A5C2E  lfsx f0, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC49C0: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC49C4: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82FC49C8: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 82FC49CC: C1BF0004  lfs f13, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC49D0: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82FC49D4: D1A10094  stfs f13, 0x94(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82FC49D8: 4BFA81B1  bl 0x82f6cb88
	ctx.lr = 0x82FC49DC;
	sub_82F6CB88(ctx, base);
	// 82FC49DC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82FC49E0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82FC49E4: FC40D090  fmr f2, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[26].f64;
	// 82FC49E8: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82FC49EC: 4BFFE1DD  bl 0x82fc2bc8
	ctx.lr = 0x82FC49F0;
	sub_82FC2BC8(ctx, base);
	// 82FC49F0: 811C0010  lwz r8, 0x10(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC49F4: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC49F8: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 82FC49FC: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC4A00: 7D4AF1D6  mullw r10, r10, r30
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC4A04: 7F6A5A14  add r27, r10, r11
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC4A08: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC4A0C: 83E80008  lwz r31, 8(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC4A10: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 82FC4A14: 419A000C  beq cr6, 0x82fc4a20
	if ctx.cr[6].eq {
	pc = 0x82FC4A20; continue 'dispatch;
	}
	// 82FC4A18: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 82FC4A1C: 409A000C  bne cr6, 0x82fc4a28
	if !ctx.cr[6].eq {
	pc = 0x82FC4A28; continue 'dispatch;
	}
	pc = 0x82FC4A20; continue 'dispatch;
            }
            0x82FC4A20 => {
    //   block [0x82FC4A20..0x82FC4A28)
	// 82FC4A20: 7EFABB78  mr r26, r23
	ctx.r[26].u64 = ctx.r[23].u64;
	// 82FC4A24: 48000008  b 0x82fc4a2c
	pc = 0x82FC4A2C; continue 'dispatch;
            }
            0x82FC4A28 => {
    //   block [0x82FC4A28..0x82FC4A2C)
	// 82FC4A28: 7F1AC378  mr r26, r24
	ctx.r[26].u64 = ctx.r[24].u64;
	pc = 0x82FC4A2C; continue 'dispatch;
            }
            0x82FC4A2C => {
    //   block [0x82FC4A2C..0x82FC4A7C)
	// 82FC4A2C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC4A30: C041006C  lfs f2, 0x6c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FC4A34: C0210068  lfs f1, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC4A38: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82FC4A3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC4A40: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC4A44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC4A48: 4E800421  bctrl
	ctx.lr = 0x82FC4A4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC4A4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC4A50: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82FC4A54: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82FC4A58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC4A5C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC4A60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC4A64: 4E800421  bctrl
	ctx.lr = 0x82FC4A68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC4A68: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82FC4A6C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82FC4A70: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC4A74: 4198FF30  blt cr6, 0x82fc49a4
	if ctx.cr[6].lt {
	pc = 0x82FC49A4; continue 'dispatch;
	}
	// 82FC4A78: 480000B0  b 0x82fc4b28
	pc = 0x82FC4B28; continue 'dispatch;
            }
            0x82FC4A7C => {
    //   block [0x82FC4A7C..0x82FC4A88)
	// 82FC4A7C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82FC4A80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC4A84: 419A00A4  beq cr6, 0x82fc4b28
	if ctx.cr[6].eq {
	pc = 0x82FC4B28; continue 'dispatch;
	}
	pc = 0x82FC4A88; continue 'dispatch;
            }
            0x82FC4A88 => {
    //   block [0x82FC4A88..0x82FC4AD0)
	// 82FC4A88: 81410140  lwz r10, 0x140(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(320 as u32) ) } as u64;
	// 82FC4A8C: 57E8E13A  rlwinm r8, r31, 0x1c, 4, 0x1d
	ctx.r[8].u64 = ctx.r[31].u32 as u64 & 0x0000000Fu64;
	// 82FC4A90: 57EB06BE  clrlwi r11, r31, 0x1a
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x0000003Fu64;
	// 82FC4A94: 80FC0010  lwz r7, 0x10(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC4A98: 813C000C  lwz r9, 0xc(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC4A9C: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC4AA0: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FC4AA4: 81070004  lwz r8, 4(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC4AA8: 83C70008  lwz r30, 8(r7)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC4AAC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC4AB0: 7D48F9D6  mullw r10, r8, r31
	ctx.r[10].s32 = ((ctx.r[8].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC4AB4: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC4AB8: 7F6A4A14  add r27, r10, r9
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82FC4ABC: 2F08FFFF  cmpwi cr6, r8, -1
	ctx.cr[6].compare_i32(ctx.r[8].s32, -1, &mut ctx.xer);
	// 82FC4AC0: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 82FC4AC4: 419A000C  beq cr6, 0x82fc4ad0
	if ctx.cr[6].eq {
	pc = 0x82FC4AD0; continue 'dispatch;
	}
	// 82FC4AC8: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 82FC4ACC: 409A000C  bne cr6, 0x82fc4ad8
	if !ctx.cr[6].eq {
	pc = 0x82FC4AD8; continue 'dispatch;
	}
	pc = 0x82FC4AD0; continue 'dispatch;
            }
            0x82FC4AD0 => {
    //   block [0x82FC4AD0..0x82FC4AD8)
	// 82FC4AD0: 7EFABB78  mr r26, r23
	ctx.r[26].u64 = ctx.r[23].u64;
	// 82FC4AD4: 48000008  b 0x82fc4adc
	pc = 0x82FC4ADC; continue 'dispatch;
            }
            0x82FC4AD8 => {
    //   block [0x82FC4AD8..0x82FC4ADC)
	// 82FC4AD8: 7F1AC378  mr r26, r24
	ctx.r[26].u64 = ctx.r[24].u64;
	pc = 0x82FC4ADC; continue 'dispatch;
            }
            0x82FC4ADC => {
    //   block [0x82FC4ADC..0x82FC4B28)
	// 82FC4ADC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC4AE0: C04B0004  lfs f2, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FC4AE4: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC4AE8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82FC4AEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC4AF0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC4AF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC4AF8: 4E800421  bctrl
	ctx.lr = 0x82FC4AFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC4AFC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC4B00: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82FC4B04: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82FC4B08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC4B0C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC4B10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC4B14: 4E800421  bctrl
	ctx.lr = 0x82FC4B18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC4B18: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82FC4B1C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82FC4B20: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC4B24: 4198FF64  blt cr6, 0x82fc4a88
	if ctx.cr[6].lt {
	pc = 0x82FC4A88; continue 'dispatch;
	}
            }
            0x82FC4B28 => {
    //   block [0x82FC4B28..0x82FC4B30)
	// 82FC4B28: 99F9002D  stb r15, 0x2d(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(45 as u32), ctx.r[15].u8 ) };
	// 82FC4B2C: 4800013C  b 0x82fc4c68
	pc = 0x82FC4C68; continue 'dispatch;
            }
            0x82FC4B30 => {
    //   block [0x82FC4B30..0x82FC4B70)
	// 82FC4B30: 3BD9003C  addi r30, r25, 0x3c
	ctx.r[30].s64 = ctx.r[25].s64 + 60;
	// 82FC4B34: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82FC4B38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC4B3C: 48002A45  bl 0x82fc7580
	ctx.lr = 0x82FC4B40;
	sub_82FC7580(ctx, base);
	// 82FC4B40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC4B44: 80810134  lwz r4, 0x134(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82FC4B48: 48002401  bl 0x82fc6f48
	ctx.lr = 0x82FC4B4C;
	sub_82FC6F48(ctx, base);
	// 82FC4B4C: 81790024  lwz r11, 0x24(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC4B50: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 82FC4B54: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82FC4B58: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82FC4B5C: 91EB0000  stw r15, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[15].u32 ) };
	// 82FC4B60: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82FC4B64: 419A00A0  beq cr6, 0x82fc4c04
	if ctx.cr[6].eq {
	pc = 0x82FC4C04; continue 'dispatch;
	}
	// 82FC4B68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC4B6C: 419A00FC  beq cr6, 0x82fc4c68
	if ctx.cr[6].eq {
	pc = 0x82FC4C68; continue 'dispatch;
	}
	pc = 0x82FC4B70; continue 'dispatch;
            }
            0x82FC4B70 => {
    //   block [0x82FC4B70..0x82FC4C04)
	// 82FC4B70: 81410140  lwz r10, 0x140(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(320 as u32) ) } as u64;
	// 82FC4B74: 57E9E13A  rlwinm r9, r31, 0x1c, 4, 0x1d
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0x0000000Fu64;
	// 82FC4B78: 57EB06BE  clrlwi r11, r31, 0x1a
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x0000003Fu64;
	// 82FC4B7C: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 82FC4B80: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC4B84: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FC4B88: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC4B8C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82FC4B90: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 82FC4B94: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC4B98: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC4B9C: D1A100B0  stfs f13, 0xb0(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82FC4BA0: D00100B4  stfs f0, 0xb4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82FC4BA4: 4BFA7FE5  bl 0x82f6cb88
	ctx.lr = 0x82FC4BA8;
	sub_82F6CB88(ctx, base);
	// 82FC4BA8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82FC4BAC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82FC4BB0: FC40D090  fmr f2, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[26].f64;
	// 82FC4BB4: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82FC4BB8: 4BFFE011  bl 0x82fc2bc8
	ctx.lr = 0x82FC4BBC;
	sub_82FC2BC8(ctx, base);
	// 82FC4BBC: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC4BC0: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC4BC4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82FC4BC8: 806A0008  lwz r3, 8(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC4BCC: C041006C  lfs f2, 0x6c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FC4BD0: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC4BD4: C0210068  lfs f1, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC4BD8: 7D4AF9D6  mullw r10, r10, r31
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC4BDC: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC4BE0: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC4BE4: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC4BE8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82FC4BEC: 4E800421  bctrl
	ctx.lr = 0x82FC4BF0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC4BF0: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82FC4BF4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82FC4BF8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC4BFC: 4198FF74  blt cr6, 0x82fc4b70
	if ctx.cr[6].lt {
	pc = 0x82FC4B70; continue 'dispatch;
	}
	// 82FC4C00: 48000068  b 0x82fc4c68
	pc = 0x82FC4C68; continue 'dispatch;
            }
            0x82FC4C04 => {
    //   block [0x82FC4C04..0x82FC4C0C)
	// 82FC4C04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC4C08: 419A0060  beq cr6, 0x82fc4c68
	if ctx.cr[6].eq {
	pc = 0x82FC4C68; continue 'dispatch;
	}
	pc = 0x82FC4C0C; continue 'dispatch;
            }
            0x82FC4C0C => {
    //   block [0x82FC4C0C..0x82FC4C68)
	// 82FC4C0C: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC4C10: 57E8E13A  rlwinm r8, r31, 0x1c, 4, 0x1d
	ctx.r[8].u64 = ctx.r[31].u32 as u64 & 0x0000000Fu64;
	// 82FC4C14: 80C10140  lwz r6, 0x140(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(320 as u32) ) } as u64;
	// 82FC4C18: 57E906BE  clrlwi r9, r31, 0x1a
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0x0000003Fu64;
	// 82FC4C1C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC4C20: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82FC4C24: 1D29000C  mulli r9, r9, 0xc
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * 12 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82FC4C28: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC4C2C: 806A0008  lwz r3, 8(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC4C30: 7D08302E  lwzx r8, r8, r6
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82FC4C34: 7D45F9D6  mullw r10, r5, r31
	ctx.r[10].s32 = ((ctx.r[5].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC4C38: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC4C3C: 7C284C2E  lfsx f1, r8, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC4C40: 80C60004  lwz r6, 4(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC4C44: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC4C48: 7D684A14  add r11, r8, r9
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82FC4C4C: C04B0004  lfs f2, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FC4C50: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82FC4C54: 4E800421  bctrl
	ctx.lr = 0x82FC4C58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC4C58: 81610134  lwz r11, 0x134(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 82FC4C5C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82FC4C60: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC4C64: 4198FFA8  blt cr6, 0x82fc4c0c
	if ctx.cr[6].lt {
	pc = 0x82FC4C0C; continue 'dispatch;
	}
            }
            0x82FC4C68 => {
    //   block [0x82FC4C68..0x82FC4CA4)
	// 82FC4C68: 81790040  lwz r11, 0x40(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(64 as u32) ) } as u64;
	// 82FC4C6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC4C70: 419A009C  beq cr6, 0x82fc4d0c
	if ctx.cr[6].eq {
	pc = 0x82FC4D0C; continue 'dispatch;
	}
	// 82FC4C74: 81790024  lwz r11, 0x24(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC4C78: 83C10148  lwz r30, 0x148(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(328 as u32) ) } as u64;
	// 82FC4C7C: 3BEB00D4  addi r31, r11, 0xd4
	ctx.r[31].s64 = ctx.r[11].s64 + 212;
	// 82FC4C80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC4C84: 48002245  bl 0x82fc6ec8
	ctx.lr = 0x82FC4C88;
	sub_82FC6EC8(ctx, base);
	// 82FC4C88: 7C83F214  add r4, r3, r30
	ctx.r[4].u64 = ctx.r[3].u64 + ctx.r[30].u64;
	// 82FC4C8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC4C90: 48002649  bl 0x82fc72d8
	ctx.lr = 0x82FC4C94;
	sub_82FC72D8(ctx, base);
	// 82FC4C94: 81610148  lwz r11, 0x148(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(328 as u32) ) } as u64;
	// 82FC4C98: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82FC4C9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC4CA0: 419A006C  beq cr6, 0x82fc4d0c
	if ctx.cr[6].eq {
	pc = 0x82FC4D0C; continue 'dispatch;
	}
	pc = 0x82FC4CA4; continue 'dispatch;
            }
            0x82FC4CA4 => {
    //   block [0x82FC4CA4..0x82FC4D0C)
	// 82FC4CA4: 81210154  lwz r9, 0x154(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82FC4CA8: 57E8E13A  rlwinm r8, r31, 0x1c, 4, 0x1d
	ctx.r[8].u64 = ctx.r[31].u32 as u64 & 0x0000000Fu64;
	// 82FC4CAC: 57EB06BE  clrlwi r11, r31, 0x1a
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x0000003Fu64;
	// 82FC4CB0: 81590024  lwz r10, 0x24(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC4CB4: 1D6B000C  mulli r11, r11, 0xc
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 12 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC4CB8: 7D28482E  lwzx r9, r8, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FC4CBC: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82FC4CC0: 3BCA00D4  addi r30, r10, 0xd4
	ctx.r[30].s64 = ctx.r[10].s64 + 212;
	// 82FC4CC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC4CC8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC4CCC: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC4CD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC4CD4: 5544043E  clrlwi r4, r10, 0x10
	ctx.r[4].u64 = ctx.r[10].u32 as u64 & 0x0000FFFFu64;
	// 82FC4CD8: 553C043E  clrlwi r28, r9, 0x10
	ctx.r[28].u64 = ctx.r[9].u32 as u64 & 0x0000FFFFu64;
	// 82FC4CDC: 557B043E  clrlwi r27, r11, 0x10
	ctx.r[27].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82FC4CE0: 48002691  bl 0x82fc7370
	ctx.lr = 0x82FC4CE4;
	sub_82FC7370(ctx, base);
	// 82FC4CE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC4CE8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82FC4CEC: 48002685  bl 0x82fc7370
	ctx.lr = 0x82FC4CF0;
	sub_82FC7370(ctx, base);
	// 82FC4CF0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82FC4CF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC4CF8: 48002679  bl 0x82fc7370
	ctx.lr = 0x82FC4CFC;
	sub_82FC7370(ctx, base);
	// 82FC4CFC: 81610148  lwz r11, 0x148(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(328 as u32) ) } as u64;
	// 82FC4D00: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82FC4D04: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC4D08: 4198FF9C  blt cr6, 0x82fc4ca4
	if ctx.cr[6].lt {
	pc = 0x82FC4CA4; continue 'dispatch;
	}
	pc = 0x82FC4D0C; continue 'dispatch;
            }
            0x82FC4D0C => {
    //   block [0x82FC4D0C..0x82FC4D34)
	// 82FC4D0C: 81790024  lwz r11, 0x24(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC4D10: 386B00D4  addi r3, r11, 0xd4
	ctx.r[3].s64 = ctx.r[11].s64 + 212;
	// 82FC4D14: 480021B5  bl 0x82fc6ec8
	ctx.lr = 0x82FC4D18;
	sub_82FC6EC8(ctx, base);
	// 82FC4D18: 81700004  lwz r11, 4(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC4D1C: 7D439B96  divwu r10, r3, r19
	ctx.r[10].u32 = ctx.r[3].u32 / ctx.r[19].u32;
	// 82FC4D20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC4D24: 419A0010  beq cr6, 0x82fc4d34
	if ctx.cr[6].eq {
	pc = 0x82FC4D34; continue 'dispatch;
	}
	// 82FC4D28: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC4D2C: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82FC4D30: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	pc = 0x82FC4D34; continue 'dispatch;
            }
            0x82FC4D34 => {
    //   block [0x82FC4D34..0x82FC4D50)
	// 82FC4D34: 38610148  addi r3, r1, 0x148
	ctx.r[3].s64 = ctx.r[1].s64 + 328;
	// 82FC4D38: 4BFFE3F1  bl 0x82fc3128
	ctx.lr = 0x82FC4D3C;
	sub_82FC3128(ctx, base);
	// 82FC4D3C: 38610134  addi r3, r1, 0x134
	ctx.r[3].s64 = ctx.r[1].s64 + 308;
	// 82FC4D40: 4BFFE3E9  bl 0x82fc3128
	ctx.lr = 0x82FC4D44;
	sub_82FC3128(ctx, base);
	// 82FC4D44: 3861011C  addi r3, r1, 0x11c
	ctx.r[3].s64 = ctx.r[1].s64 + 284;
	// 82FC4D48: 4BFFE3E1  bl 0x82fc3128
	ctx.lr = 0x82FC4D4C;
	sub_82FC3128(ctx, base);
	// 82FC4D4C: 48000528  b 0x82fc5274
	pc = 0x82FC5274; continue 'dispatch;
            }
            0x82FC4D50 => {
    //   block [0x82FC4D50..0x82FC4DA0)
	// 82FC4D50: 38610360  addi r3, r1, 0x360
	ctx.r[3].s64 = ctx.r[1].s64 + 864;
	// 82FC4D54: 4BFFE8F5  bl 0x82fc3648
	ctx.lr = 0x82FC4D58;
	sub_82FC3648(ctx, base);
	// 82FC4D58: 39600040  li r11, 0x40
	ctx.r[11].s64 = 64;
	// 82FC4D5C: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 82FC4D60: D3E100D4  stfs f31, 0xd4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82FC4D64: 93A100D8  stw r29, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[29].u32 ) };
	// 82FC4D68: 93A100DC  stw r29, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[29].u32 ) };
	// 82FC4D6C: 93A100E0  stw r29, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[29].u32 ) };
	// 82FC4D70: 93A100E4  stw r29, 0xe4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[29].u32 ) };
	// 82FC4D74: 916100E8  stw r11, 0xe8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[11].u32 ) };
	// 82FC4D78: 9BA100EC  stb r29, 0xec(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[29].u8 ) };
	// 82FC4D7C: 4BF851BD  bl 0x82f49f38
	ctx.lr = 0x82FC4D80;
	sub_82F49F38(ctx, base);
	// 82FC4D80: C1B00020  lfs f13, 0x20(r16)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC4D84: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC4D88: EDB86824  fdivs f13, f24, f13
	ctx.f[13].f64 = ((ctx.f[24].f64 / ctx.f[13].f64) as f32) as f64;
	// 82FC4D8C: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 82FC4D90: C00B0C54  lfs f0, 0xc54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC4D94: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC4D98: 409A0008  bne cr6, 0x82fc4da0
	if !ctx.cr[6].eq {
	pc = 0x82FC4DA0; continue 'dispatch;
	}
	// 82FC4D9C: EFFFF024  fdivs f31, f31, f30
	ctx.f[31].f64 = ((ctx.f[31].f64 / ctx.f[30].f64) as f32) as f64;
	pc = 0x82FC4DA0; continue 'dispatch;
            }
            0x82FC4DA0 => {
    //   block [0x82FC4DA0..0x82FC4DC4)
	// 82FC4DA0: 571E063F  clrlwi. r30, r24, 0x18
	ctx.r[30].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82FC4DA4: EC1C0632  fmuls f0, f28, f24
	ctx.f[0].f64 = (((ctx.f[28].f64 * ctx.f[24].f64) as f32) as f64);
	// 82FC4DA8: 4182001C  beq 0x82fc4dc4
	if ctx.cr[0].eq {
	pc = 0x82FC4DC4; continue 'dispatch;
	}
	// 82FC4DAC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC4DB0: C1AB0C4C  lfs f13, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC4DB4: EC1F037A  fmadds f0, f31, f13, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FC4DB8: FF00B800  fcmpu cr6, f0, f23
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[23].f64);
	// 82FC4DBC: 40980008  bge cr6, 0x82fc4dc4
	if !ctx.cr[6].lt {
	pc = 0x82FC4DC4; continue 'dispatch;
	}
	// 82FC4DC0: FC00B890  fmr f0, f23
	ctx.f[0].f64 = ctx.f[23].f64;
	pc = 0x82FC4DC4; continue 'dispatch;
            }
            0x82FC4DC4 => {
    //   block [0x82FC4DC4..0x82FC4DE8)
	// 82FC4DC4: A1320010  lhz r9, 0x10(r18)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[18].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC4DC8: 3A600003  li r19, 3
	ctx.r[19].s64 = 3;
	// 82FC4DCC: 552806B6  rlwinm r8, r9, 0, 0x1a, 0x1b
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC4DD0: 2F080010  cmpwi cr6, r8, 0x10
	ctx.cr[6].compare_i32(ctx.r[8].s32, 16, &mut ctx.xer);
	// 82FC4DD4: 419A001C  beq cr6, 0x82fc4df0
	if ctx.cr[6].eq {
	pc = 0x82FC4DF0; continue 'dispatch;
	}
	// 82FC4DD8: 2F080020  cmpwi cr6, r8, 0x20
	ctx.cr[6].compare_i32(ctx.r[8].s32, 32, &mut ctx.xer);
	// 82FC4DDC: 419A000C  beq cr6, 0x82fc4de8
	if ctx.cr[6].eq {
	pc = 0x82FC4DE8; continue 'dispatch;
	}
	// 82FC4DE0: 7E6A9B78  mr r10, r19
	ctx.r[10].u64 = ctx.r[19].u64;
	// 82FC4DE4: 48000010  b 0x82fc4df4
	pc = 0x82FC4DF4; continue 'dispatch;
            }
            0x82FC4DE8 => {
    //   block [0x82FC4DE8..0x82FC4DF0)
	// 82FC4DE8: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82FC4DEC: 48000008  b 0x82fc4df4
	pc = 0x82FC4DF4; continue 'dispatch;
            }
            0x82FC4DF0 => {
    //   block [0x82FC4DF0..0x82FC4DF4)
	// 82FC4DF0: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	pc = 0x82FC4DF4; continue 'dispatch;
            }
            0x82FC4DF4 => {
    //   block [0x82FC4DF4..0x82FC4E1C)
	// 82FC4DF4: 552B0632  rlwinm r11, r9, 0, 0x18, 0x19
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC4DF8: 914100C8  stw r10, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[10].u32 ) };
	// 82FC4DFC: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 82FC4E00: 419A001C  beq cr6, 0x82fc4e1c
	if ctx.cr[6].eq {
	pc = 0x82FC4E1C; continue 'dispatch;
	}
	// 82FC4E04: 396BFF80  addi r11, r11, -0x80
	ctx.r[11].s64 = ctx.r[11].s64 + -128;
	// 82FC4E08: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82FC4E0C: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82FC4E10: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82FC4E14: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82FC4E18: 48000008  b 0x82fc4e20
	pc = 0x82FC4E20; continue 'dispatch;
            }
            0x82FC4E1C => {
    //   block [0x82FC4E1C..0x82FC4E20)
	// 82FC4E1C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x82FC4E20; continue 'dispatch;
            }
            0x82FC4E20 => {
    //   block [0x82FC4E20..0x82FC4E48)
	// 82FC4E20: 552BF632  rlwinm r11, r9, 0x1e, 0x18, 0x19
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 82FC4E24: 914100CC  stw r10, 0xcc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[10].u32 ) };
	// 82FC4E28: 2F0B0040  cmpwi cr6, r11, 0x40
	ctx.cr[6].compare_i32(ctx.r[11].s32, 64, &mut ctx.xer);
	// 82FC4E2C: 419A001C  beq cr6, 0x82fc4e48
	if ctx.cr[6].eq {
	pc = 0x82FC4E48; continue 'dispatch;
	}
	// 82FC4E30: 396BFF80  addi r11, r11, -0x80
	ctx.r[11].s64 = ctx.r[11].s64 + -128;
	// 82FC4E34: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82FC4E38: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82FC4E3C: 696B0001  xori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 ^ 1;
	// 82FC4E40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FC4E44: 48000008  b 0x82fc4e4c
	pc = 0x82FC4E4C; continue 'dispatch;
            }
            0x82FC4E48 => {
    //   block [0x82FC4E48..0x82FC4E4C)
	// 82FC4E48: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x82FC4E4C; continue 'dispatch;
            }
            0x82FC4E4C => {
    //   block [0x82FC4E4C..0x82FC4E6C)
	// 82FC4E4C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC4E50: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 82FC4E54: C1AA0BFC  lfs f13, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC4E58: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FC4E5C: D00100C0  stfs f0, 0xc0(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 82FC4E60: FF00C800  fcmpu cr6, f0, f25
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[25].f64);
	// 82FC4E64: 40980008  bge cr6, 0x82fc4e6c
	if !ctx.cr[6].lt {
	pc = 0x82FC4E6C; continue 'dispatch;
	}
	// 82FC4E68: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82FC4E6C; continue 'dispatch;
            }
            0x82FC4E6C => {
    //   block [0x82FC4E6C..0x82FC4E84)
	// 82FC4E6C: 550B043E  clrlwi r11, r8, 0x10
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x0000FFFFu64;
	// 82FC4E70: D00100C4  stfs f0, 0xc4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82FC4E74: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 82FC4E78: 409A000C  bne cr6, 0x82fc4e84
	if !ctx.cr[6].eq {
	pc = 0x82FC4E84; continue 'dispatch;
	}
	// 82FC4E7C: C0120014  lfs f0, 0x14(r18)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC4E80: D00100D4  stfs f0, 0xd4(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	pc = 0x82FC4E84; continue 'dispatch;
            }
            0x82FC4E84 => {
    //   block [0x82FC4E84..0x82FC4F10)
	// 82FC4E84: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 82FC4E88: EC3805B2  fmuls f1, f24, f22
	ctx.f[1].f64 = (((ctx.f[24].f64 * ctx.f[22].f64) as f32) as f64);
	// 82FC4E8C: 48001485  bl 0x82fc6310
	ctx.lr = 0x82FC4E90;
	sub_82FC6310(ctx, base);
	// 82FC4E90: 38610220  addi r3, r1, 0x220
	ctx.r[3].s64 = ctx.r[1].s64 + 544;
	// 82FC4E94: 4800149D  bl 0x82fc6330
	ctx.lr = 0x82FC4E98;
	sub_82FC6330(ctx, base);
	// 82FC4E98: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82FC4E9C: 38C10220  addi r6, r1, 0x220
	ctx.r[6].s64 = ctx.r[1].s64 + 544;
	// 82FC4EA0: 80B90000  lwz r5, 0(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC4EA4: 388101D0  addi r4, r1, 0x1d0
	ctx.r[4].s64 = ctx.r[1].s64 + 464;
	// 82FC4EA8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82FC4EAC: 4BFFA32D  bl 0x82fbf1d8
	ctx.lr = 0x82FC4EB0;
	sub_82FBF1D8(ctx, base);
	// 82FC4EB0: 93A10360  stw r29, 0x360(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(864 as u32), ctx.r[29].u32 ) };
	// 82FC4EB4: 8171001C  lwz r11, 0x1c(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC4EB8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82FC4EBC: 99E10364  stb r15, 0x364(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(868 as u32), ctx.r[15].u8 ) };
	// 82FC4EC0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82FC4EC4: 99610365  stb r11, 0x365(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(869 as u32), ctx.r[11].u8 ) };
	// 82FC4EC8: 38810220  addi r4, r1, 0x220
	ctx.r[4].s64 = ctx.r[1].s64 + 544;
	// 82FC4ECC: 99610366  stb r11, 0x366(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(870 as u32), ctx.r[11].u8 ) };
	// 82FC4ED0: 38610360  addi r3, r1, 0x360
	ctx.r[3].s64 = ctx.r[1].s64 + 864;
	// 82FC4ED4: 99610367  stb r11, 0x367(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(871 as u32), ctx.r[11].u8 ) };
	// 82FC4ED8: 48011F31  bl 0x82fd6e08
	ctx.lr = 0x82FC4EDC;
	sub_82FD6E08(ctx, base);
	// 82FC4EDC: 8161047C  lwz r11, 0x47c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1148 as u32) ) } as u64;
	// 82FC4EE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC4EE4: 419A0370  beq cr6, 0x82fc5254
	if ctx.cr[6].eq {
	pc = 0x82FC5254; continue 'dispatch;
	}
	// 82FC4EE8: 80790058  lwz r3, 0x58(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(88 as u32) ) } as u64;
	// 82FC4EEC: 3BF90058  addi r31, r25, 0x58
	ctx.r[31].s64 = ctx.r[25].s64 + 88;
	// 82FC4EF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC4EF4: 419A001C  beq cr6, 0x82fc4f10
	if ctx.cr[6].eq {
	pc = 0x82FC4F10; continue 'dispatch;
	}
	// 82FC4EF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC4EFC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82FC4F00: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC4F04: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82FC4F08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC4F0C: 4E800421  bctrl
	ctx.lr = 0x82FC4F10;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC4F10 => {
    //   block [0x82FC4F10..0x82FC4F58)
	// 82FC4F10: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82FC4F14: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82FC4F18: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82FC4F1C: 9BB9002D  stb r29, 0x2d(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(45 as u32), ctx.r[29].u8 ) };
	// 82FC4F20: 419A01A0  beq cr6, 0x82fc50c0
	if ctx.cr[6].eq {
	pc = 0x82FC50C0; continue 'dispatch;
	}
	// 82FC4F24: 83F2000C  lwz r31, 0xc(r18)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC4F28: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 82FC4F2C: 93A1007C  stw r29, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	// 82FC4F30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82FC4F34: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 82FC4F38: 419A0020  beq cr6, 0x82fc4f58
	if ctx.cr[6].eq {
	pc = 0x82FC4F58; continue 'dispatch;
	}
	// 82FC4F3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82FC4F40: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82FC4F44: 4BF858BD  bl 0x82f4a800
	ctx.lr = 0x82FC4F48;
	sub_82F4A800(ctx, base);
	// 82FC4F48: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC4F4C: 80610078  lwz r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82FC4F50: 4BFFAD79  bl 0x82fbfcc8
	ctx.lr = 0x82FC4F54;
	sub_82FBFCC8(ctx, base);
	// 82FC4F54: 48000048  b 0x82fc4f9c
	pc = 0x82FC4F9C; continue 'dispatch;
            }
            0x82FC4F58 => {
    //   block [0x82FC4F58..0x82FC4F9C)
	// 82FC4F58: 386102A0  addi r3, r1, 0x2a0
	ctx.r[3].s64 = ctx.r[1].s64 + 672;
	// 82FC4F5C: 4BFFAD15  bl 0x82fbfc70
	ctx.lr = 0x82FC4F60;
	sub_82FBFC70(ctx, base);
	// 82FC4F60: 81720008  lwz r11, 8(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC4F64: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 82FC4F68: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82FC4F6C: 3BEA0001  addi r31, r10, 1
	ctx.r[31].s64 = ctx.r[10].s64 + 1;
	// 82FC4F70: 916102A4  stw r11, 0x2a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(676 as u32), ctx.r[11].u32 ) };
	// 82FC4F74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC4F78: 4BF85889  bl 0x82f4a800
	ctx.lr = 0x82FC4F7C;
	sub_82F4A800(ctx, base);
	// 82FC4F7C: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82FC4F80: 1D5F0030  mulli r10, r31, 0x30
	ctx.r[10].s32 = ((ctx.r[31].s32 as i64 * 48 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC4F84: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC4F88: 388102A0  addi r4, r1, 0x2a0
	ctx.r[4].s64 = ctx.r[1].s64 + 672;
	// 82FC4F8C: 386BFFD0  addi r3, r11, -0x30
	ctx.r[3].s64 = ctx.r[11].s64 + -48;
	// 82FC4F90: 4BFFAD39  bl 0x82fbfcc8
	ctx.lr = 0x82FC4F94;
	sub_82FBFCC8(ctx, base);
	// 82FC4F94: 386102A0  addi r3, r1, 0x2a0
	ctx.r[3].s64 = ctx.r[1].s64 + 672;
	// 82FC4F98: 4BFFA9A9  bl 0x82fbf940
	ctx.lr = 0x82FC4F9C;
	sub_82FBF940(ctx, base);
	pc = 0x82FC4F9C; continue 'dispatch;
            }
            0x82FC4F9C => {
    //   block [0x82FC4F9C..0x82FC4FC4)
	// 82FC4F9C: 38A10078  addi r5, r1, 0x78
	ctx.r[5].s64 = ctx.r[1].s64 + 120;
	// 82FC4FA0: 38810360  addi r4, r1, 0x360
	ctx.r[4].s64 = ctx.r[1].s64 + 864;
	// 82FC4FA4: 386102D0  addi r3, r1, 0x2d0
	ctx.r[3].s64 = ctx.r[1].s64 + 720;
	// 82FC4FA8: 48012119  bl 0x82fd70c0
	ctx.lr = 0x82FC4FAC;
	sub_82FD70C0(ctx, base);
	// 82FC4FAC: 8172000C  lwz r11, 0xc(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC4FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC4FB4: 419A0010  beq cr6, 0x82fc4fc4
	if ctx.cr[6].eq {
	pc = 0x82FC4FC4; continue 'dispatch;
	}
	// 82FC4FB8: 3D6000FF  lis r11, 0xff
	ctx.r[11].s64 = 16711680;
	// 82FC4FBC: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82FC4FC0: 9161035C  stw r11, 0x35c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(860 as u32), ctx.r[11].u32 ) };
	pc = 0x82FC4FC4; continue 'dispatch;
            }
            0x82FC4FC4 => {
    //   block [0x82FC4FC4..0x82FC5000)
	// 82FC4FC4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82FC4FC8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82FC4FCC: 386102D0  addi r3, r1, 0x2d0
	ctx.r[3].s64 = ctx.r[1].s64 + 720;
	// 82FC4FD0: 48011EC9  bl 0x82fd6e98
	ctx.lr = 0x82FC4FD4;
	sub_82FD6E98(ctx, base);
	// 82FC4FD4: 386102D0  addi r3, r1, 0x2d0
	ctx.r[3].s64 = ctx.r[1].s64 + 720;
	// 82FC4FD8: 48011F01  bl 0x82fd6ed8
	ctx.lr = 0x82FC4FDC;
	sub_82FD6ED8(ctx, base);
	// 82FC4FDC: 2B03FFFE  cmplwi cr6, r3, 0xfffe
	ctx.cr[6].compare_u32(ctx.r[3].u32, 65534 as u32, &mut ctx.xer);
	// 82FC4FE0: 419900BC  bgt cr6, 0x82fc509c
	if ctx.cr[6].gt {
	pc = 0x82FC509C; continue 'dispatch;
	}
	// 82FC4FE4: 56EB063F  clrlwi. r11, r23, 0x18
	ctx.r[11].u64 = ctx.r[23].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC4FE8: 9AF9002E  stb r23, 0x2e(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(46 as u32), ctx.r[23].u8 ) };
	// 82FC4FEC: 40820014  bne 0x82fc5000
	if !ctx.cr[0].eq {
	pc = 0x82FC5000; continue 'dispatch;
	}
	// 82FC4FF0: 8172000C  lwz r11, 0xc(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC4FF4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82FC4FF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC4FFC: 419A0008  beq cr6, 0x82fc5004
	if ctx.cr[6].eq {
	pc = 0x82FC5004; continue 'dispatch;
	}
	pc = 0x82FC5000; continue 'dispatch;
            }
            0x82FC5000 => {
    //   block [0x82FC5000..0x82FC5004)
	// 82FC5000: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	pc = 0x82FC5004; continue 'dispatch;
            }
            0x82FC5004 => {
    //   block [0x82FC5004..0x82FC5030)
	// 82FC5004: 3BF9003C  addi r31, r25, 0x3c
	ctx.r[31].s64 = ctx.r[25].s64 + 60;
	// 82FC5008: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC500C: 48002575  bl 0x82fc7580
	ctx.lr = 0x82FC5010;
	sub_82FC7580(ctx, base);
	// 82FC5010: 80B90024  lwz r5, 0x24(r25)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC5014: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 82FC5018: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC501C: 386102D0  addi r3, r1, 0x2d0
	ctx.r[3].s64 = ctx.r[1].s64 + 720;
	// 82FC5020: 419A0010  beq cr6, 0x82fc5030
	if ctx.cr[6].eq {
	pc = 0x82FC5030; continue 'dispatch;
	}
	// 82FC5024: 38C101B0  addi r6, r1, 0x1b0
	ctx.r[6].s64 = ctx.r[1].s64 + 432;
	// 82FC5028: 48012DC1  bl 0x82fd7de8
	ctx.lr = 0x82FC502C;
	sub_82FD7DE8(ctx, base);
	// 82FC502C: 4800000C  b 0x82fc5038
	pc = 0x82FC5038; continue 'dispatch;
            }
            0x82FC5030 => {
    //   block [0x82FC5030..0x82FC5038)
	// 82FC5030: FC20B890  fmr f1, f23
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[23].f64;
	// 82FC5034: 48012C2D  bl 0x82fd7c60
	ctx.lr = 0x82FC5038;
	sub_82FD7C60(ctx, base);
	pc = 0x82FC5038; continue 'dispatch;
            }
            0x82FC5038 => {
    //   block [0x82FC5038..0x82FC5064)
	// 82FC5038: 81790024  lwz r11, 0x24(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC503C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC5040: 386B00D4  addi r3, r11, 0xd4
	ctx.r[3].s64 = ctx.r[11].s64 + 212;
	// 82FC5044: 48001E85  bl 0x82fc6ec8
	ctx.lr = 0x82FC5048;
	sub_82FC6EC8(ctx, base);
	// 82FC5048: 81700004  lwz r11, 4(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC504C: 7D439B96  divwu r10, r3, r19
	ctx.r[10].u32 = ctx.r[3].u32 / ctx.r[19].u32;
	// 82FC5050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC5054: 419A0010  beq cr6, 0x82fc5064
	if ctx.cr[6].eq {
	pc = 0x82FC5064; continue 'dispatch;
	}
	// 82FC5058: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC505C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82FC5060: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	pc = 0x82FC5064; continue 'dispatch;
            }
            0x82FC5064 => {
    //   block [0x82FC5064..0x82FC509C)
	// 82FC5064: 57EB063F  clrlwi. r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC5068: 41820034  beq 0x82fc509c
	if ctx.cr[0].eq {
	pc = 0x82FC509C; continue 'dispatch;
	}
	// 82FC506C: 99F9002D  stb r15, 0x2d(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(45 as u32), ctx.r[15].u8 ) };
	// 82FC5070: 8172000C  lwz r11, 0xc(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC5074: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC5078: 419A0024  beq cr6, 0x82fc509c
	if ctx.cr[6].eq {
	pc = 0x82FC509C; continue 'dispatch;
	}
	// 82FC507C: 81790024  lwz r11, 0x24(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC5080: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 82FC5084: 93EB0008  stw r31, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82FC5088: 93EB000C  stw r31, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82FC508C: 91EB0000  stw r15, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[15].u32 ) };
	// 82FC5090: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82FC5094: 81790024  lwz r11, 0x24(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC5098: 91EB00D0  stw r15, 0xd0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), ctx.r[15].u32 ) };
	pc = 0x82FC509C; continue 'dispatch;
            }
            0x82FC509C => {
    //   block [0x82FC509C..0x82FC50C0)
	// 82FC509C: 386102D0  addi r3, r1, 0x2d0
	ctx.r[3].s64 = ctx.r[1].s64 + 720;
	// 82FC50A0: 48012189  bl 0x82fd7228
	ctx.lr = 0x82FC50A4;
	sub_82FD7228(ctx, base);
	// 82FC50A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC50A8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 82FC50AC: 4BF85755  bl 0x82f4a800
	ctx.lr = 0x82FC50B0;
	sub_82F4A800(ctx, base);
	// 82FC50B0: 80610078  lwz r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 82FC50B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC50B8: 419A0008  beq cr6, 0x82fc50c0
	if ctx.cr[6].eq {
	pc = 0x82FC50C0; continue 'dispatch;
	}
	// 82FC50BC: 4BF387E5  bl 0x82efd8a0
	ctx.lr = 0x82FC50C0;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC50C0; continue 'dispatch;
            }
            0x82FC50C0 => {
    //   block [0x82FC50C0..0x82FC5100)
	// 82FC50C0: 8979002D  lbz r11, 0x2d(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(45 as u32) ) } as u64;
	// 82FC50C4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC50C8: 4082018C  bne 0x82fc5254
	if !ctx.cr[0].eq {
	pc = 0x82FC5254; continue 'dispatch;
	}
	// 82FC50CC: 3BD9003C  addi r30, r25, 0x3c
	ctx.r[30].s64 = ctx.r[25].s64 + 60;
	// 82FC50D0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82FC50D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC50D8: 480024A9  bl 0x82fc7580
	ctx.lr = 0x82FC50DC;
	sub_82FC7580(ctx, base);
	// 82FC50DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC50E0: 8081047C  lwz r4, 0x47c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1148 as u32) ) } as u64;
	// 82FC50E4: 48001E65  bl 0x82fc6f48
	ctx.lr = 0x82FC50E8;
	sub_82FC6F48(ctx, base);
	// 82FC50E8: 8161047C  lwz r11, 0x47c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1148 as u32) ) } as u64;
	// 82FC50EC: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 82FC50F0: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82FC50F4: 419A009C  beq cr6, 0x82fc5190
	if ctx.cr[6].eq {
	pc = 0x82FC5190; continue 'dispatch;
	}
	// 82FC50F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC50FC: 419A00F4  beq cr6, 0x82fc51f0
	if ctx.cr[6].eq {
	pc = 0x82FC51F0; continue 'dispatch;
	}
	pc = 0x82FC5100; continue 'dispatch;
            }
            0x82FC5100 => {
    //   block [0x82FC5100..0x82FC5190)
	// 82FC5100: 81410488  lwz r10, 0x488(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82FC5104: 57E9C23A  rlwinm r9, r31, 0x18, 8, 0x1d
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 82FC5108: 57EB1CF8  rlwinm r11, r31, 3, 0x13, 0x1c
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x1FFFFFFFu64;
	// 82FC510C: 38A100A8  addi r5, r1, 0xa8
	ctx.r[5].s64 = ctx.r[1].s64 + 168;
	// 82FC5110: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82FC5114: 386101B0  addi r3, r1, 0x1b0
	ctx.r[3].s64 = ctx.r[1].s64 + 432;
	// 82FC5118: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FC511C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC5120: C00B0004  lfs f0, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC5124: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC5128: D1A100A8  stfs f13, 0xa8(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82FC512C: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82FC5130: 4BFA7A59  bl 0x82f6cb88
	ctx.lr = 0x82FC5134;
	sub_82F6CB88(ctx, base);
	// 82FC5134: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 82FC5138: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82FC513C: FC40D090  fmr f2, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[26].f64;
	// 82FC5140: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82FC5144: 4BFFDA85  bl 0x82fc2bc8
	ctx.lr = 0x82FC5148;
	sub_82FC2BC8(ctx, base);
	// 82FC5148: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC514C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC5150: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82FC5154: 806A0008  lwz r3, 8(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC5158: C041006C  lfs f2, 0x6c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FC515C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC5160: C0210068  lfs f1, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC5164: 7D4AF9D6  mullw r10, r10, r31
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC5168: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC516C: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC5170: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC5174: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82FC5178: 4E800421  bctrl
	ctx.lr = 0x82FC517C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC517C: 8161047C  lwz r11, 0x47c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1148 as u32) ) } as u64;
	// 82FC5180: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82FC5184: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC5188: 4198FF78  blt cr6, 0x82fc5100
	if ctx.cr[6].lt {
	pc = 0x82FC5100; continue 'dispatch;
	}
	// 82FC518C: 48000064  b 0x82fc51f0
	pc = 0x82FC51F0; continue 'dispatch;
            }
            0x82FC5190 => {
    //   block [0x82FC5190..0x82FC5198)
	// 82FC5190: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC5194: 419A005C  beq cr6, 0x82fc51f0
	if ctx.cr[6].eq {
	pc = 0x82FC51F0; continue 'dispatch;
	}
	pc = 0x82FC5198; continue 'dispatch;
            }
            0x82FC5198 => {
    //   block [0x82FC5198..0x82FC51F0)
	// 82FC5198: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC519C: 57E8C23A  rlwinm r8, r31, 0x18, 8, 0x1d
	ctx.r[8].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 82FC51A0: 80C10488  lwz r6, 0x488(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1160 as u32) ) } as u64;
	// 82FC51A4: 57E91CF8  rlwinm r9, r31, 3, 0x13, 0x1c
	ctx.r[9].u64 = ctx.r[31].u32 as u64 & 0x1FFFFFFFu64;
	// 82FC51A8: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC51AC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82FC51B0: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC51B4: 806A0008  lwz r3, 8(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC51B8: 7D45F9D6  mullw r10, r5, r31
	ctx.r[10].s32 = ((ctx.r[5].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC51BC: 7D08302E  lwzx r8, r8, r6
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82FC51C0: 80C30000  lwz r6, 0(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC51C4: 7C284C2E  lfsx f1, r8, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC51C8: 80C60004  lwz r6, 4(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC51CC: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC51D0: 7D684A14  add r11, r8, r9
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82FC51D4: C04B0004  lfs f2, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FC51D8: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82FC51DC: 4E800421  bctrl
	ctx.lr = 0x82FC51E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC51E0: 8161047C  lwz r11, 0x47c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1148 as u32) ) } as u64;
	// 82FC51E4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82FC51E8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC51EC: 4198FFAC  blt cr6, 0x82fc5198
	if ctx.cr[6].lt {
	pc = 0x82FC5198; continue 'dispatch;
	}
            }
            0x82FC51F0 => {
    //   block [0x82FC51F0..0x82FC5200)
	// 82FC51F0: 816104D8  lwz r11, 0x4d8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1240 as u32) ) } as u64;
	// 82FC51F4: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82FC51F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC51FC: 419A0030  beq cr6, 0x82fc522c
	if ctx.cr[6].eq {
	pc = 0x82FC522C; continue 'dispatch;
	}
	pc = 0x82FC5200; continue 'dispatch;
            }
            0x82FC5200 => {
    //   block [0x82FC5200..0x82FC522C)
	// 82FC5200: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC5204: 38610360  addi r3, r1, 0x360
	ctx.r[3].s64 = ctx.r[1].s64 + 864;
	// 82FC5208: 480110A1  bl 0x82fd62a8
	ctx.lr = 0x82FC520C;
	sub_82FD62A8(ctx, base);
	// 82FC520C: 38A10360  addi r5, r1, 0x360
	ctx.r[5].s64 = ctx.r[1].s64 + 864;
	// 82FC5210: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC5214: 80790024  lwz r3, 0x24(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC5218: 4BFFDBC1  bl 0x82fc2dd8
	ctx.lr = 0x82FC521C;
	sub_82FC2DD8(ctx, base);
	// 82FC521C: 816104D8  lwz r11, 0x4d8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(1240 as u32) ) } as u64;
	// 82FC5220: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82FC5224: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC5228: 4198FFD8  blt cr6, 0x82fc5200
	if ctx.cr[6].lt {
	pc = 0x82FC5200; continue 'dispatch;
	}
	pc = 0x82FC522C; continue 'dispatch;
            }
            0x82FC522C => {
    //   block [0x82FC522C..0x82FC5254)
	// 82FC522C: 81790024  lwz r11, 0x24(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC5230: 386B00D4  addi r3, r11, 0xd4
	ctx.r[3].s64 = ctx.r[11].s64 + 212;
	// 82FC5234: 48001C95  bl 0x82fc6ec8
	ctx.lr = 0x82FC5238;
	sub_82FC6EC8(ctx, base);
	// 82FC5238: 81700004  lwz r11, 4(r16)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[16].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC523C: 7D439B96  divwu r10, r3, r19
	ctx.r[10].u32 = ctx.r[3].u32 / ctx.r[19].u32;
	// 82FC5240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC5244: 419A0010  beq cr6, 0x82fc5254
	if ctx.cr[6].eq {
	pc = 0x82FC5254; continue 'dispatch;
	}
	// 82FC5248: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC524C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82FC5250: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	pc = 0x82FC5254; continue 'dispatch;
            }
            0x82FC5254 => {
    //   block [0x82FC5254..0x82FC5274)
	// 82FC5254: 3861023C  addi r3, r1, 0x23c
	ctx.r[3].s64 = ctx.r[1].s64 + 572;
	// 82FC5258: 4BFFDED1  bl 0x82fc3128
	ctx.lr = 0x82FC525C;
	sub_82FC3128(ctx, base);
	// 82FC525C: 38610228  addi r3, r1, 0x228
	ctx.r[3].s64 = ctx.r[1].s64 + 552;
	// 82FC5260: 4BFFDEC9  bl 0x82fc3128
	ctx.lr = 0x82FC5264;
	sub_82FC3128(ctx, base);
	// 82FC5264: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 82FC5268: 4BFFDEC1  bl 0x82fc3128
	ctx.lr = 0x82FC526C;
	sub_82FC3128(ctx, base);
	// 82FC526C: 38610360  addi r3, r1, 0x360
	ctx.r[3].s64 = ctx.r[1].s64 + 864;
	// 82FC5270: 4BFFE631  bl 0x82fc38a0
	ctx.lr = 0x82FC5274;
	sub_82FC38A0(ctx, base);
	pc = 0x82FC5274; continue 'dispatch;
            }
            0x82FC5274 => {
    //   block [0x82FC5274..0x82FC529C)
	// 82FC5274: 89610060  lbz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82FC5278: D3990028  stfs f28, 0x28(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82FC527C: D3790034  stfs f27, 0x34(r25)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82FC5280: 99D9002F  stb r14, 0x2f(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(47 as u32), ctx.r[14].u8 ) };
	// 82FC5284: D3590038  stfs f26, 0x38(r25)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82FC5288: 386101EC  addi r3, r1, 0x1ec
	ctx.r[3].s64 = ctx.r[1].s64 + 492;
	// 82FC528C: 99790030  stb r11, 0x30(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 82FC5290: 4BFFDE99  bl 0x82fc3128
	ctx.lr = 0x82FC5294;
	sub_82FC3128(ctx, base);
	// 82FC5294: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 82FC5298: 4BFFDE91  bl 0x82fc3128
	ctx.lr = 0x82FC529C;
	sub_82FC3128(ctx, base);
	pc = 0x82FC529C; continue 'dispatch;
            }
            0x82FC529C => {
    //   block [0x82FC529C..0x82FC52F4)
	// 82FC529C: 81790040  lwz r11, 0x40(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(64 as u32) ) } as u64;
	// 82FC52A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC52A4: 419A0130  beq cr6, 0x82fc53d4
	if ctx.cr[6].eq {
	pc = 0x82FC53D4; continue 'dispatch;
	}
	// 82FC52A8: 39790058  addi r11, r25, 0x58
	ctx.r[11].s64 = ctx.r[25].s64 + 88;
	// 82FC52AC: 9BA1008C  stb r29, 0x8c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[29].u8 ) };
	// 82FC52B0: 38A10088  addi r5, r1, 0x88
	ctx.r[5].s64 = ctx.r[1].s64 + 136;
	// 82FC52B4: 91610088  stw r11, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82FC52B8: 3879003C  addi r3, r25, 0x3c
	ctx.r[3].s64 = ctx.r[25].s64 + 60;
	// 82FC52BC: 80910014  lwz r4, 0x14(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC52C0: 48001AD9  bl 0x82fc6d98
	ctx.lr = 0x82FC52C4;
	sub_82FC6D98(ctx, base);
	// 82FC52C4: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82FC52C8: 4BFFA9A9  bl 0x82fbfc70
	ctx.lr = 0x82FC52CC;
	sub_82FBFC70(ctx, base);
	// 82FC52CC: 8172000C  lwz r11, 0xc(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC52D0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82FC52D4: FC20B890  fmr f1, f23
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[23].f64;
	// 82FC52D8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82FC52DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC52E0: 419A0014  beq cr6, 0x82fc52f4
	if ctx.cr[6].eq {
	pc = 0x82FC52F4; continue 'dispatch;
	}
	// 82FC52E4: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 82FC52E8: EC37C024  fdivs f1, f23, f24
	ctx.f[1].f64 = ((ctx.f[23].f64 / ctx.f[24].f64) as f32) as f64;
	// 82FC52EC: 7DE67B78  mr r6, r15
	ctx.r[6].u64 = ctx.r[15].u64;
	// 82FC52F0: 4800001C  b 0x82fc530c
	pc = 0x82FC530C; continue 'dispatch;
            }
            0x82FC52F4 => {
    //   block [0x82FC52F4..0x82FC530C)
	// 82FC52F4: 8979002D  lbz r11, 0x2d(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(45 as u32) ) } as u64;
	// 82FC52F8: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC52FC: 40820010  bne 0x82fc530c
	if !ctx.cr[0].eq {
	pc = 0x82FC530C; continue 'dispatch;
	}
	// 82FC5300: 81720008  lwz r11, 8(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC5304: 38A10270  addi r5, r1, 0x270
	ctx.r[5].s64 = ctx.r[1].s64 + 624;
	// 82FC5308: 91610274  stw r11, 0x274(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(628 as u32), ctx.r[11].u32 ) };
	pc = 0x82FC530C; continue 'dispatch;
            }
            0x82FC530C => {
    //   block [0x82FC530C..0x82FC5338)
	// 82FC530C: 8979002D  lbz r11, 0x2d(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(45 as u32) ) } as u64;
	// 82FC5310: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82FC5314: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82FC5318: 81190040  lwz r8, 0x40(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(64 as u32) ) } as u64;
	// 82FC531C: 7E048378  mr r4, r16
	ctx.r[4].u64 = ctx.r[16].u64;
	// 82FC5320: 80790024  lwz r3, 0x24(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC5324: 99610057  stb r11, 0x57(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(87 as u32), ctx.r[11].u8 ) };
	// 82FC5328: 4BFFDBE1  bl 0x82fc2f08
	ctx.lr = 0x82FC532C;
	sub_82FC2F08(ctx, base);
	// 82FC532C: 38610270  addi r3, r1, 0x270
	ctx.r[3].s64 = ctx.r[1].s64 + 624;
	// 82FC5330: 4BFFA611  bl 0x82fbf940
	ctx.lr = 0x82FC5334;
	sub_82FBF940(ctx, base);
	// 82FC5334: 480000A0  b 0x82fc53d4
	pc = 0x82FC53D4; continue 'dispatch;
            }
            0x82FC5338 => {
    //   block [0x82FC5338..0x82FC5390)
	// 82FC5338: 81720000  lwz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC533C: 7E439378  mr r3, r18
	ctx.r[3].u64 = ctx.r[18].u64;
	// 82FC5340: 80910014  lwz r4, 0x14(r17)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC5344: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC5348: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC534C: 4E800421  bctrl
	ctx.lr = 0x82FC5350;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC5350: 80710014  lwz r3, 0x14(r17)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC5354: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC5358: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82FC535C: 80990004  lwz r4, 4(r25)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC5360: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82FC5364: 5565F87E  srwi r5, r11, 1
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82FC5368: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC536C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FC5370: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC5374: 4E800421  bctrl
	ctx.lr = 0x82FC5378;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC5378: 8179001C  lwz r11, 0x1c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC537C: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	// 82FC5380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC5384: 40990050  ble cr6, 0x82fc53d4
	if !ctx.cr[6].gt {
	pc = 0x82FC53D4; continue 'dispatch;
	}
	// 82FC5388: 81790018  lwz r11, 0x18(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC538C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
            }
            0x82FC5390 => {
    //   block [0x82FC5390..0x82FC53D4)
	// 82FC5390: 80710014  lwz r3, 0x14(r17)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC5394: 57A4F87E  srwi r4, r29, 1
	ctx.r[4].u32 = ctx.r[29].u32.wrapping_shr(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82FC5398: 7D6BF82E  lwzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82FC539C: 556BF87E  srwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC53A0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC53A4: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 82FC53A8: 816A0040  lwz r11, 0x40(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 82FC53AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC53B0: 4E800421  bctrl
	ctx.lr = 0x82FC53B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC53B4: 81790018  lwz r11, 0x18(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC53B8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82FC53BC: 7D4BF82E  lwzx r10, r11, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82FC53C0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82FC53C4: 7FAAEA14  add r29, r10, r29
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 82FC53C8: 8159001C  lwz r10, 0x1c(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC53CC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC53D0: 4198FFC0  blt cr6, 0x82fc5390
	if ctx.cr[6].lt {
	pc = 0x82FC5390; continue 'dispatch;
	}
            }
            0x82FC53D4 => {
    //   block [0x82FC53D4..0x82FC53E4)
	// 82FC53D4: 38210660  addi r1, r1, 0x660
	ctx.r[1].s64 = ctx.r[1].s64 + 1632;
	// 82FC53D8: 3981FF68  addi r12, r1, -0x98
	ctx.r[12].s64 = ctx.r[1].s64 + -152;
	// 82FC53DC: 4BCE8931  bl 0x82cadd0c
	ctx.lr = 0x82FC53E0;
	sub_82CADCEC(ctx, base);
	// 82FC53E0: 4BCE4040  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC53E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC53E8 size=96
    let mut pc: u32 = 0x82FC53E8;
    'dispatch: loop {
        match pc {
            0x82FC53E8 => {
    //   block [0x82FC53E8..0x82FC541C)
	// 82FC53E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC53EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC53F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC53F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC53F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC53FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC5400: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC5404: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC5408: 4BFFE941  bl 0x82fc3d48
	ctx.lr = 0x82FC540C;
	sub_82FC3D48(ctx, base);
	// 82FC540C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC5410: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC5414: 419A0008  beq cr6, 0x82fc541c
	if ctx.cr[6].eq {
	pc = 0x82FC541C; continue 'dispatch;
	}
	// 82FC5418: 4BF38489  bl 0x82efd8a0
	ctx.lr = 0x82FC541C;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC541C; continue 'dispatch;
            }
            0x82FC541C => {
    //   block [0x82FC541C..0x82FC542C)
	// 82FC541C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC5420: 4182000C  beq 0x82fc542c
	if ctx.cr[0].eq {
	pc = 0x82FC542C; continue 'dispatch;
	}
	// 82FC5424: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC5428: 4BF38479  bl 0x82efd8a0
	ctx.lr = 0x82FC542C;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC542C; continue 'dispatch;
            }
            0x82FC542C => {
    //   block [0x82FC542C..0x82FC5448)
	// 82FC542C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC5430: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC5434: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC5438: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC543C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC5440: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC5444: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC5448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC5448 size=96
    let mut pc: u32 = 0x82FC5448;
    'dispatch: loop {
        match pc {
            0x82FC5448 => {
    //   block [0x82FC5448..0x82FC547C)
	// 82FC5448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC544C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC5450: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC5454: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC5458: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC545C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC5460: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC5464: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC5468: 4BFFE819  bl 0x82fc3c80
	ctx.lr = 0x82FC546C;
	sub_82FC3C80(ctx, base);
	// 82FC546C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC5470: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC5474: 419A0008  beq cr6, 0x82fc547c
	if ctx.cr[6].eq {
	pc = 0x82FC547C; continue 'dispatch;
	}
	// 82FC5478: 4BF38429  bl 0x82efd8a0
	ctx.lr = 0x82FC547C;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC547C; continue 'dispatch;
            }
            0x82FC547C => {
    //   block [0x82FC547C..0x82FC548C)
	// 82FC547C: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC5480: 4182000C  beq 0x82fc548c
	if ctx.cr[0].eq {
	pc = 0x82FC548C; continue 'dispatch;
	}
	// 82FC5484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC5488: 4BF38419  bl 0x82efd8a0
	ctx.lr = 0x82FC548C;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC548C; continue 'dispatch;
            }
            0x82FC548C => {
    //   block [0x82FC548C..0x82FC54A8)
	// 82FC548C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC5490: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC5494: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC5498: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC549C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC54A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC54A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC54A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC54A8 size=784
    let mut pc: u32 = 0x82FC54A8;
    'dispatch: loop {
        match pc {
            0x82FC54A8 => {
    //   block [0x82FC54A8..0x82FC57B8)
	// 82FC54A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC54AC: 4BCE3F2D  bl 0x82ca93d8
	ctx.lr = 0x82FC54B0;
	sub_82CA93D0(ctx, base);
	// 82FC54B0: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC54B4: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82FC54B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC54BC: 7D515378  mr r17, r10
	ctx.r[17].u64 = ctx.r[10].u64;
	// 82FC54C0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC54C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC54C8: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82FC54CC: 80F90000  lwz r7, 0(r25)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC54D0: 7D134378  mr r19, r8
	ctx.r[19].u64 = ctx.r[8].u64;
	// 82FC54D4: C01F0010  lfs f0, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC54D8: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82FC54DC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82FC54E0: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82FC54E4: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 82FC54E8: C00B0C14  lfs f0, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC54EC: 7D324B78  mr r18, r9
	ctx.r[18].u64 = ctx.r[9].u64;
	// 82FC54F0: C1AA0C18  lfs f13, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC54F4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 82FC54F8: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82FC54FC: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82FC5500: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82FC5504: 83470014  lwz r26, 0x14(r7)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC5508: 13C0A8C7  vcmpequd (lvx128) v30, v0, v21
	tmp.u32 = ctx.r[21].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82FC550C: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82FC5510: 13E040C7  vcmpequd (lvx128) v31, v0, v8
	tmp.u32 = ctx.r[8].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC57B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC57B8 size=188
    let mut pc: u32 = 0x82FC57B8;
    'dispatch: loop {
        match pc {
            0x82FC57B8 => {
    //   block [0x82FC57B8..0x82FC5800)
	// 82FC57B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC57BC: 4BCE3C49  bl 0x82ca9404
	ctx.lr = 0x82FC57C0;
	sub_82CA93D0(ctx, base);
	// 82FC57C0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC57C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC57C8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82FC57CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82FC57D0: 817E006C  lwz r11, 0x6c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82FC57D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC57D8: 409A0030  bne cr6, 0x82fc5808
	if !ctx.cr[6].eq {
	pc = 0x82FC5808; continue 'dispatch;
	}
	// 82FC57DC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82FC57E0: 4BF38081  bl 0x82efd860
	ctx.lr = 0x82FC57E4;
	sub_82EFD860(ctx, base);
	// 82FC57E4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC57E8: 41820018  beq 0x82fc5800
	if ctx.cr[0].eq {
	pc = 0x82FC5800; continue 'dispatch;
	}
	// 82FC57EC: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82FC57F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82FC57F4: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82FC57F8: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82FC57FC: 48000008  b 0x82fc5804
	pc = 0x82FC5804; continue 'dispatch;
            }
            0x82FC5800 => {
    //   block [0x82FC5800..0x82FC5804)
	// 82FC5800: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82FC5804; continue 'dispatch;
            }
            0x82FC5804 => {
    //   block [0x82FC5804..0x82FC5808)
	// 82FC5804: 917E006C  stw r11, 0x6c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	pc = 0x82FC5808; continue 'dispatch;
            }
            0x82FC5808 => {
    //   block [0x82FC5808..0x82FC5874)
	// 82FC5808: 837E006C  lwz r27, 0x6c(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(108 as u32) ) } as u64;
	// 82FC580C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82FC5810: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82FC5814: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82FC5818: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82FC581C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82FC5820: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC5824: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 82FC5828: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82FC582C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC5830: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 82FC5834: 4BFFE515  bl 0x82fc3d48
	ctx.lr = 0x82FC5838;
	sub_82FC3D48(ctx, base);
	// 82FC5838: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC583C: 1D7D01D0  mulli r11, r29, 0x1d0
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * 464 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC5840: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC5844: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82FC5848: 386BFE30  addi r3, r11, -0x1d0
	ctx.r[3].s64 = ctx.r[11].s64 + -464;
	// 82FC584C: 4BFFD51D  bl 0x82fc2d68
	ctx.lr = 0x82FC5850;
	sub_82FC2D68(ctx, base);
	// 82FC5850: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FC5854: 387E0058  addi r3, r30, 0x58
	ctx.r[3].s64 = ctx.r[30].s64 + 88;
	// 82FC5858: 4BFFE5D1  bl 0x82fc3e28
	ctx.lr = 0x82FC585C;
	sub_82FC3E28(ctx, base);
	// 82FC585C: 897E0014  lbz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC5860: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82FC5864: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82FC5868: 997E0015  stb r11, 0x15(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(21 as u32), ctx.r[11].u8 ) };
	// 82FC586C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82FC5870: 4BCE3BE4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC5878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC5878 size=172
    let mut pc: u32 = 0x82FC5878;
    'dispatch: loop {
        match pc {
            0x82FC5878 => {
    //   block [0x82FC5878..0x82FC58C0)
	// 82FC5878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC587C: 4BCE3B89  bl 0x82ca9404
	ctx.lr = 0x82FC5880;
	sub_82CA93D0(ctx, base);
	// 82FC5880: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC5884: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82FC5888: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82FC588C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82FC5890: 817B0070  lwz r11, 0x70(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(112 as u32) ) } as u64;
	// 82FC5894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC5898: 409A0030  bne cr6, 0x82fc58c8
	if !ctx.cr[6].eq {
	pc = 0x82FC58C8; continue 'dispatch;
	}
	// 82FC589C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82FC58A0: 4BF37FC1  bl 0x82efd860
	ctx.lr = 0x82FC58A4;
	sub_82EFD860(ctx, base);
	// 82FC58A4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC58A8: 41820018  beq 0x82fc58c0
	if ctx.cr[0].eq {
	pc = 0x82FC58C0; continue 'dispatch;
	}
	// 82FC58AC: 93E30000  stw r31, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82FC58B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82FC58B4: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82FC58B8: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82FC58BC: 48000008  b 0x82fc58c4
	pc = 0x82FC58C4; continue 'dispatch;
            }
            0x82FC58C0 => {
    //   block [0x82FC58C0..0x82FC58C4)
	// 82FC58C0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82FC58C4; continue 'dispatch;
            }
            0x82FC58C4 => {
    //   block [0x82FC58C4..0x82FC58C8)
	// 82FC58C4: 917B0070  stw r11, 0x70(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	pc = 0x82FC58C8; continue 'dispatch;
            }
            0x82FC58C8 => {
    //   block [0x82FC58C8..0x82FC58E8)
	// 82FC58C8: 807B0070  lwz r3, 0x70(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(112 as u32) ) } as u64;
	// 82FC58CC: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC58D0: 4BFFE3B1  bl 0x82fc3c80
	ctx.lr = 0x82FC58D4;
	sub_82FC3C80(ctx, base);
	// 82FC58D4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC58D8: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82FC58DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC58E0: 4099003C  ble cr6, 0x82fc591c
	if !ctx.cr[6].gt {
	pc = 0x82FC591C; continue 'dispatch;
	}
	// 82FC58E4: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	pc = 0x82FC58E8; continue 'dispatch;
            }
            0x82FC58E8 => {
    //   block [0x82FC58E8..0x82FC591C)
	// 82FC58E8: 813B0070  lwz r9, 0x70(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(112 as u32) ) } as u64;
	// 82FC58EC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC58F0: 7D4BFA14  add r10, r11, r31
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82FC58F4: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC58F8: 388A0010  addi r4, r10, 0x10
	ctx.r[4].s64 = ctx.r[10].s64 + 16;
	// 82FC58FC: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82FC5900: 4BFA6EF9  bl 0x82f6c7f8
	ctx.lr = 0x82FC5904;
	sub_82F6C7F8(ctx, base);
	// 82FC5904: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC5908: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82FC590C: 3BFF0030  addi r31, r31, 0x30
	ctx.r[31].s64 = ctx.r[31].s64 + 48;
	// 82FC5910: 3BDE0020  addi r30, r30, 0x20
	ctx.r[30].s64 = ctx.r[30].s64 + 32;
	// 82FC5914: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC5918: 4198FFD0  blt cr6, 0x82fc58e8
	if ctx.cr[6].lt {
	pc = 0x82FC58E8; continue 'dispatch;
	}
	pc = 0x82FC591C; continue 'dispatch;
            }
            0x82FC591C => {
    //   block [0x82FC591C..0x82FC5924)
	// 82FC591C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC5920: 4BCE3B34  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC5928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC5928 size=244
    let mut pc: u32 = 0x82FC5928;
    'dispatch: loop {
        match pc {
            0x82FC5928 => {
    //   block [0x82FC5928..0x82FC5954)
	// 82FC5928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC592C: 4BCE3AD9  bl 0x82ca9404
	ctx.lr = 0x82FC5930;
	sub_82CA93D0(ctx, base);
	// 82FC5930: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC5934: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82FC5938: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82FC593C: 837D0004  lwz r27, 4(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC5940: 939D0004  stw r28, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82FC5944: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82FC5948: 40980024  bge cr6, 0x82fc596c
	if !ctx.cr[6].lt {
	pc = 0x82FC596C; continue 'dispatch;
	}
	// 82FC594C: 1FDC0060  mulli r30, r28, 0x60
	ctx.r[30].s32 = ((ctx.r[28].s32 as i64 * 96 as i64) as i32);
	ctx.r[30].s64 = ctx.r[30].s32 as i64;
	// 82FC5950: 7FFCD850  subf r31, r28, r27
	ctx.r[31].s64 = ctx.r[27].s64 - ctx.r[28].s64;
	pc = 0x82FC5954; continue 'dispatch;
            }
            0x82FC5954 => {
    //   block [0x82FC5954..0x82FC596C)
	// 82FC5954: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC5958: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82FC595C: 4BFFE6FD  bl 0x82fc4058
	ctx.lr = 0x82FC5960;
	sub_82FC4058(ctx, base);
	// 82FC5960: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82FC5964: 3BDE0060  addi r30, r30, 0x60
	ctx.r[30].s64 = ctx.r[30].s64 + 96;
	// 82FC5968: 4082FFEC  bne 0x82fc5954
	if !ctx.cr[0].eq {
	pc = 0x82FC5954; continue 'dispatch;
	}
	pc = 0x82FC596C; continue 'dispatch;
            }
            0x82FC596C => {
    //   block [0x82FC596C..0x82FC5994)
	// 82FC596C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC5970: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82FC5974: 556A00BE  clrlwi r10, r11, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	// 82FC5978: 409A0048  bne cr6, 0x82fc59c0
	if !ctx.cr[6].eq {
	pc = 0x82FC59C0; continue 'dispatch;
	}
	// 82FC597C: 556917BF  rlwinm. r9, r11, 2, 0x1e, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x3FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC5980: 4182001C  beq 0x82fc599c
	if ctx.cr[0].eq {
	pc = 0x82FC599C; continue 'dispatch;
	}
	// 82FC5984: 55680FFF  rlwinm. r8, r11, 1, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x7FFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82FC5988: 4182000C  beq 0x82fc5994
	if ctx.cr[0].eq {
	pc = 0x82FC5994; continue 'dispatch;
	}
	// 82FC598C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82FC5990: 409A0058  bne cr6, 0x82fc59e8
	if !ctx.cr[6].eq {
	pc = 0x82FC59E8; continue 'dispatch;
	}
	pc = 0x82FC5994; continue 'dispatch;
            }
            0x82FC5994 => {
    //   block [0x82FC5994..0x82FC599C)
	// 82FC5994: 552A07FF  clrlwi. r10, r9, 0x1f
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC5998: 40820050  bne 0x82fc59e8
	if !ctx.cr[0].eq {
	pc = 0x82FC59E8; continue 'dispatch;
	}
	pc = 0x82FC599C; continue 'dispatch;
            }
            0x82FC599C => {
    //   block [0x82FC599C..0x82FC59B4)
	// 82FC599C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC59A0: 556B0002  rlwinm r11, r11, 0, 0, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC59A4: 917D0008  stw r11, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC59A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC59AC: 419A0008  beq cr6, 0x82fc59b4
	if ctx.cr[6].eq {
	pc = 0x82FC59B4; continue 'dispatch;
	}
	// 82FC59B0: 4BF37EF1  bl 0x82efd8a0
	ctx.lr = 0x82FC59B4;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC59B4; continue 'dispatch;
            }
            0x82FC59B4 => {
    //   block [0x82FC59B4..0x82FC59C0)
	// 82FC59B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC59B8: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC59BC: 4800002C  b 0x82fc59e8
	pc = 0x82FC59E8; continue 'dispatch;
            }
            0x82FC59C0 => {
    //   block [0x82FC59C0..0x82FC59D8)
	// 82FC59C0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC59C4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC59C8: 41990010  bgt cr6, 0x82fc59d8
	if ctx.cr[6].gt {
	pc = 0x82FC59D8; continue 'dispatch;
	}
	// 82FC59CC: 554AF87E  srwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82FC59D0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC59D4: 41990014  bgt cr6, 0x82fc59e8
	if ctx.cr[6].gt {
	pc = 0x82FC59E8; continue 'dispatch;
	}
	pc = 0x82FC59D8; continue 'dispatch;
            }
            0x82FC59D8 => {
    //   block [0x82FC59D8..0x82FC59E8)
	// 82FC59D8: 556AF0BE  srwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82FC59DC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC59E0: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC59E4: 4BFFD96D  bl 0x82fc3350
	ctx.lr = 0x82FC59E8;
	sub_82FC3350(ctx, base);
	pc = 0x82FC59E8; continue 'dispatch;
            }
            0x82FC59E8 => {
    //   block [0x82FC59E8..0x82FC59F8)
	// 82FC59E8: 7F1BE040  cmplw cr6, r27, r28
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82FC59EC: 40980028  bge cr6, 0x82fc5a14
	if !ctx.cr[6].lt {
	pc = 0x82FC5A14; continue 'dispatch;
	}
	// 82FC59F0: 1FFB0060  mulli r31, r27, 0x60
	ctx.r[31].s32 = ((ctx.r[27].s32 as i64 * 96 as i64) as i32);
	ctx.r[31].s64 = ctx.r[31].s32 as i64;
	// 82FC59F4: 7FDBE050  subf r30, r27, r28
	ctx.r[30].s64 = ctx.r[28].s64 - ctx.r[27].s64;
	pc = 0x82FC59F8; continue 'dispatch;
            }
            0x82FC59F8 => {
    //   block [0x82FC59F8..0x82FC5A08)
	// 82FC59F8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC59FC: 7C7F5A15  add. r3, r31, r11
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82FC5A00: 41820008  beq 0x82fc5a08
	if ctx.cr[0].eq {
	pc = 0x82FC5A08; continue 'dispatch;
	}
	// 82FC5A04: 4BFFE5A5  bl 0x82fc3fa8
	ctx.lr = 0x82FC5A08;
	sub_82FC3FA8(ctx, base);
	pc = 0x82FC5A08; continue 'dispatch;
            }
            0x82FC5A08 => {
    //   block [0x82FC5A08..0x82FC5A14)
	// 82FC5A08: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82FC5A0C: 3BFF0060  addi r31, r31, 0x60
	ctx.r[31].s64 = ctx.r[31].s64 + 96;
	// 82FC5A10: 4082FFE8  bne 0x82fc59f8
	if !ctx.cr[0].eq {
	pc = 0x82FC59F8; continue 'dispatch;
	}
	pc = 0x82FC5A14; continue 'dispatch;
            }
            0x82FC5A14 => {
    //   block [0x82FC5A14..0x82FC5A1C)
	// 82FC5A14: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC5A18: 4BCE3A3C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC5A20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC5A20 size=1732
    let mut pc: u32 = 0x82FC5A20;
    'dispatch: loop {
        match pc {
            0x82FC5A20 => {
    //   block [0x82FC5A20..0x82FC5AE0)
	// 82FC5A20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC5A24: 4BCE39C9  bl 0x82ca93ec
	ctx.lr = 0x82FC5A28;
	sub_82CA93D0(ctx, base);
	// 82FC5A28: 9421FC50  stwu r1, -0x3b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-944 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC5A2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC5A30: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82FC5A34: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82FC5A38: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FC5A3C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82FC5A40: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 82FC5A44: 4BFFDC05  bl 0x82fc3648
	ctx.lr = 0x82FC5A48;
	sub_82FC3648(ctx, base);
	// 82FC5A48: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82FC5A4C: 895E0018  lbz r10, 0x18(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC5A50: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	// 82FC5A54: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82FC5A58: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82FC5A5C: 9AA10134  stb r21, 0x134(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[21].u8 ) };
	// 82FC5A60: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82FC5A64: 7F36CB78  mr r22, r25
	ctx.r[22].u64 = ctx.r[25].u64;
	// 82FC5A68: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 82FC5A6C: 99410135  stb r10, 0x135(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(309 as u32), ctx.r[10].u8 ) };
	// 82FC5A70: 7F37CB78  mr r23, r25
	ctx.r[23].u64 = ctx.r[25].u64;
	// 82FC5A74: 99410136  stb r10, 0x136(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(310 as u32), ctx.r[10].u8 ) };
	// 82FC5A78: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82FC5A7C: 99410137  stb r10, 0x137(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(311 as u32), ctx.r[10].u8 ) };
	// 82FC5A80: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82FC5A84: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82FC5A88: 92C10054  stw r22, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[22].u32 ) };
	// 82FC5A8C: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82FC5A90: 8978004C  lbz r11, 0x4c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(76 as u32) ) } as u64;
	// 82FC5A94: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82FC5A98: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82FC5A9C: 91610130  stw r11, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 82FC5AA0: 48011369  bl 0x82fd6e08
	ctx.lr = 0x82FC5AA4;
	sub_82FD6E08(ctx, base);
	// 82FC5AA4: 8161024C  lwz r11, 0x24c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(588 as u32) ) } as u64;
	// 82FC5AA8: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82FC5AAC: 2B0BFFFE  cmplwi cr6, r11, 0xfffe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65534 as u32, &mut ctx.xer);
	// 82FC5AB0: 41990628  bgt cr6, 0x82fc60d8
	if ctx.cr[6].gt {
	pc = 0x82FC60D8; continue 'dispatch;
	}
	// 82FC5AB4: 4800CB9D  bl 0x82fd2650
	ctx.lr = 0x82FC5AB8;
	sub_82FD2650(ctx, base);
	// 82FC5AB8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC5ABC: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC5AC0: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 82FC5AC4: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC5AC8: 555CE7FE  rlwinm r28, r10, 0x1c, 0x1f, 0x1f
	ctx.r[28].u64 = ctx.r[10].u32 as u64 & 0x0000000Fu64;
	// 82FC5ACC: 41820014  beq 0x82fc5ae0
	if ctx.cr[0].eq {
	pc = 0x82FC5AE0; continue 'dispatch;
	}
	// 82FC5AD0: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC5AD4: 556B05EF  rlwinm. r11, r11, 0, 0x17, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC5AD8: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 82FC5ADC: 40820008  bne 0x82fc5ae4
	if !ctx.cr[0].eq {
	pc = 0x82FC5AE4; continue 'dispatch;
	}
	pc = 0x82FC5AE0; continue 'dispatch;
            }
            0x82FC5AE0 => {
    //   block [0x82FC5AE0..0x82FC5AE4)
	// 82FC5AE0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x82FC5AE4; continue 'dispatch;
            }
            0x82FC5AE4 => {
    //   block [0x82FC5AE4..0x82FC5B1C)
	// 82FC5AE4: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC5AE8: 41820078  beq 0x82fc5b60
	if ctx.cr[0].eq {
	pc = 0x82FC5B60; continue 'dispatch;
	}
	// 82FC5AEC: 897E0014  lbz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC5AF0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC5AF4: 4082006C  bne 0x82fc5b60
	if !ctx.cr[0].eq {
	pc = 0x82FC5B60; continue 'dispatch;
	}
	// 82FC5AF8: 897E0017  lbz r11, 0x17(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(23 as u32) ) } as u64;
	// 82FC5AFC: 7EBBAB78  mr r27, r21
	ctx.r[27].u64 = ctx.r[21].u64;
	// 82FC5B00: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC5B04: 41820018  beq 0x82fc5b1c
	if ctx.cr[0].eq {
	pc = 0x82FC5B1C; continue 'dispatch;
	}
	// 82FC5B08: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC5B0C: 556BA7FF  rlwinm. r11, r11, 0x14, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000FFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC5B10: 4182000C  beq 0x82fc5b1c
	if ctx.cr[0].eq {
	pc = 0x82FC5B1C; continue 'dispatch;
	}
	// 82FC5B14: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC5B18: 41820044  beq 0x82fc5b5c
	if ctx.cr[0].eq {
	pc = 0x82FC5B5C; continue 'dispatch;
	}
	pc = 0x82FC5B1C; continue 'dispatch;
            }
            0x82FC5B1C => {
    //   block [0x82FC5B1C..0x82FC5B3C)
	// 82FC5B1C: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC5B20: 556BBFFF  rlwinm. r11, r11, 0x17, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000001FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC5B24: 4082003C  bne 0x82fc5b60
	if !ctx.cr[0].eq {
	pc = 0x82FC5B60; continue 'dispatch;
	}
	// 82FC5B28: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC5B2C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82FC5B30: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82FC5B34: 419A002C  beq cr6, 0x82fc5b60
	if ctx.cr[6].eq {
	pc = 0x82FC5B60; continue 'dispatch;
	}
	// 82FC5B38: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82FC5B3C; continue 'dispatch;
            }
            0x82FC5B3C => {
    //   block [0x82FC5B3C..0x82FC5B5C)
	// 82FC5B3C: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC5B40: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC5B44: 40820018  bne 0x82fc5b5c
	if !ctx.cr[0].eq {
	pc = 0x82FC5B5C; continue 'dispatch;
	}
	// 82FC5B48: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FC5B4C: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 82FC5B50: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82FC5B54: 4198FFE8  blt cr6, 0x82fc5b3c
	if ctx.cr[6].lt {
	pc = 0x82FC5B3C; continue 'dispatch;
	}
	// 82FC5B58: 48000008  b 0x82fc5b60
	pc = 0x82FC5B60; continue 'dispatch;
            }
            0x82FC5B5C => {
    //   block [0x82FC5B5C..0x82FC5B60)
	// 82FC5B5C: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	pc = 0x82FC5B60; continue 'dispatch;
            }
            0x82FC5B60 => {
    //   block [0x82FC5B60..0x82FC5BFC)
	// 82FC5B60: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC5B64: 41820220  beq 0x82fc5d84
	if ctx.cr[0].eq {
	pc = 0x82FC5D84; continue 'dispatch;
	}
	// 82FC5B68: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82FC5B6C: 38810130  addi r4, r1, 0x130
	ctx.r[4].s64 = ctx.r[1].s64 + 304;
	// 82FC5B70: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82FC5B74: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 82FC5B78: 48011549  bl 0x82fd70c0
	ctx.lr = 0x82FC5B7C;
	sub_82FD70C0(ctx, base);
	// 82FC5B7C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82FC5B80: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC5B84: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82FC5B88: 480019A9  bl 0x82fc7530
	ctx.lr = 0x82FC5B8C;
	sub_82FC7530(ctx, base);
	// 82FC5B8C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC5B90: C1BE0004  lfs f13, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC5B94: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82FC5B98: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82FC5B9C: C00B0C8C  lfs f0, 0xc8c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC5BA0: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC5BA4: 480112F5  bl 0x82fd6e98
	ctx.lr = 0x82FC5BA8;
	sub_82FD6E98(ctx, base);
	// 82FC5BA8: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82FC5BAC: 83FE0038  lwz r31, 0x38(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 82FC5BB0: 48011329  bl 0x82fd6ed8
	ctx.lr = 0x82FC5BB4;
	sub_82FD6ED8(ctx, base);
	// 82FC5BB4: 7D63FA14  add r11, r3, r31
	ctx.r[11].u64 = ctx.r[3].u64 + ctx.r[31].u64;
	// 82FC5BB8: 2B0BFFFE  cmplwi cr6, r11, 0xfffe
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65534 as u32, &mut ctx.xer);
	// 82FC5BBC: 419901B4  bgt cr6, 0x82fc5d70
	if ctx.cr[6].gt {
	pc = 0x82FC5D70; continue 'dispatch;
	}
	// 82FC5BC0: 817E0044  lwz r11, 0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 82FC5BC4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC5BC8: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82FC5BCC: 409A0058  bne cr6, 0x82fc5c24
	if !ctx.cr[6].eq {
	pc = 0x82FC5C24; continue 'dispatch;
	}
	// 82FC5BD0: 578B063F  clrlwi. r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC5BD4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82FC5BD8: 4182004C  beq 0x82fc5c24
	if ctx.cr[0].eq {
	pc = 0x82FC5C24; continue 'dispatch;
	}
	// 82FC5BDC: 897E0017  lbz r11, 0x17(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(23 as u32) ) } as u64;
	// 82FC5BE0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC5BE4: 40820038  bne 0x82fc5c1c
	if !ctx.cr[0].eq {
	pc = 0x82FC5C1C; continue 'dispatch;
	}
	// 82FC5BE8: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC5BEC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82FC5BF0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82FC5BF4: 419A0030  beq cr6, 0x82fc5c24
	if ctx.cr[6].eq {
	pc = 0x82FC5C24; continue 'dispatch;
	}
	// 82FC5BF8: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82FC5BFC; continue 'dispatch;
            }
            0x82FC5BFC => {
    //   block [0x82FC5BFC..0x82FC5C1C)
	// 82FC5BFC: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC5C00: 28080000  cmplwi r8, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC5C04: 40820018  bne 0x82fc5c1c
	if !ctx.cr[0].eq {
	pc = 0x82FC5C1C; continue 'dispatch;
	}
	// 82FC5C08: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FC5C0C: 394A0030  addi r10, r10, 0x30
	ctx.r[10].s64 = ctx.r[10].s64 + 48;
	// 82FC5C10: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82FC5C14: 4198FFE8  blt cr6, 0x82fc5bfc
	if ctx.cr[6].lt {
	pc = 0x82FC5BFC; continue 'dispatch;
	}
	// 82FC5C18: 4800000C  b 0x82fc5c24
	pc = 0x82FC5C24; continue 'dispatch;
            }
            0x82FC5C1C => {
    //   block [0x82FC5C1C..0x82FC5C24)
	// 82FC5C1C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82FC5C20: 9ABE0017  stb r21, 0x17(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(23 as u32), ctx.r[21].u8 ) };
	pc = 0x82FC5C24; continue 'dispatch;
            }
            0x82FC5C24 => {
    //   block [0x82FC5C24..0x82FC5C68)
	// 82FC5C24: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82FC5C28: 48001959  bl 0x82fc7580
	ctx.lr = 0x82FC5C2C;
	sub_82FC7580(ctx, base);
	// 82FC5C2C: 89610128  lbz r11, 0x128(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(296 as u32) ) } as u64;
	// 82FC5C30: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC5C34: 41820034  beq 0x82fc5c68
	if ctx.cr[0].eq {
	pc = 0x82FC5C68; continue 'dispatch;
	}
	// 82FC5C38: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82FC5C3C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC5C40: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82FC5C44: 419A0024  beq cr6, 0x82fc5c68
	if ctx.cr[6].eq {
	pc = 0x82FC5C68; continue 'dispatch;
	}
	// 82FC5C48: 3BFE001C  addi r31, r30, 0x1c
	ctx.r[31].s64 = ctx.r[30].s64 + 28;
	// 82FC5C4C: C03E000C  lfs f1, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC5C50: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82FC5C54: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82FC5C58: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82FC5C5C: 480125E5  bl 0x82fd8240
	ctx.lr = 0x82FC5C60;
	sub_82FD8240(ctx, base);
	// 82FC5C60: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82FC5C64: 48000040  b 0x82fc5ca4
	pc = 0x82FC5CA4; continue 'dispatch;
            }
            0x82FC5C68 => {
    //   block [0x82FC5C68..0x82FC5CA4)
	// 82FC5C68: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FC5C6C: 3BFE001C  addi r31, r30, 0x1c
	ctx.r[31].s64 = ctx.r[30].s64 + 28;
	// 82FC5C70: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82FC5C74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC5C78: 4BFFDE39  bl 0x82fc3ab0
	ctx.lr = 0x82FC5C7C;
	sub_82FC3AB0(ctx, base);
	// 82FC5C7C: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FC5C80: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC5C84: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82FC5C88: 554A402E  slwi r10, r10, 8
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(8);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82FC5C8C: C03E000C  lfs f1, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC5C90: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82FC5C94: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC5C98: 7EBCAB78  mr r28, r21
	ctx.r[28].u64 = ctx.r[21].u64;
	// 82FC5C9C: 38ABFF00  addi r5, r11, -0x100
	ctx.r[5].s64 = ctx.r[11].s64 + -256;
	// 82FC5CA0: 48011FC1  bl 0x82fd7c60
	ctx.lr = 0x82FC5CA4;
	sub_82FD7C60(ctx, base);
	pc = 0x82FC5CA4; continue 'dispatch;
            }
            0x82FC5CA4 => {
    //   block [0x82FC5CA4..0x82FC5CB8)
	// 82FC5CA4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82FC5CA8: 419A005C  beq cr6, 0x82fc5d04
	if ctx.cr[6].eq {
	pc = 0x82FC5D04; continue 'dispatch;
	}
	// 82FC5CAC: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82FC5CB0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82FC5CB4: 419A0050  beq cr6, 0x82fc5d04
	if ctx.cr[6].eq {
	pc = 0x82FC5D04; continue 'dispatch;
	}
	pc = 0x82FC5CB8; continue 'dispatch;
            }
            0x82FC5CB8 => {
    //   block [0x82FC5CB8..0x82FC5CF8)
	// 82FC5CB8: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FC5CBC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC5CC0: 7D7D5850  subf r11, r29, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 82FC5CC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FC5CC8: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC5CCC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC5CD0: 386B00D4  addi r3, r11, 0xd4
	ctx.r[3].s64 = ctx.r[11].s64 + 212;
	// 82FC5CD4: 480011F5  bl 0x82fc6ec8
	ctx.lr = 0x82FC5CD8;
	sub_82FC6EC8(ctx, base);
	// 82FC5CD8: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC5CDC: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82FC5CE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC5CE4: 7D435396  divwu r10, r3, r10
	ctx.r[10].u32 = ctx.r[3].u32 / ctx.r[10].u32;
	// 82FC5CE8: 419A0010  beq cr6, 0x82fc5cf8
	if ctx.cr[6].eq {
	pc = 0x82FC5CF8; continue 'dispatch;
	}
	// 82FC5CEC: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC5CF0: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82FC5CF4: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	pc = 0x82FC5CF8; continue 'dispatch;
            }
            0x82FC5CF8 => {
    //   block [0x82FC5CF8..0x82FC5D04)
	// 82FC5CF8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82FC5CFC: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82FC5D00: 4198FFB8  blt cr6, 0x82fc5cb8
	if ctx.cr[6].lt {
	pc = 0x82FC5CB8; continue 'dispatch;
	}
	pc = 0x82FC5D04; continue 'dispatch;
            }
            0x82FC5D04 => {
    //   block [0x82FC5D04..0x82FC5D2C)
	// 82FC5D04: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 82FC5D08: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 82FC5D0C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC5D10: 2B09FFFE  cmplwi cr6, r9, 0xfffe
	ctx.cr[6].compare_u32(ctx.r[9].u32, 65534 as u32, &mut ctx.xer);
	// 82FC5D14: 40990018  ble cr6, 0x82fc5d2c
	if !ctx.cr[6].gt {
	pc = 0x82FC5D2C; continue 'dispatch;
	}
	// 82FC5D18: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FC5D1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC5D20: 7C9C5850  subf r4, r28, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82FC5D24: 4BFFDD8D  bl 0x82fc3ab0
	ctx.lr = 0x82FC5D28;
	sub_82FC3AB0(ctx, base);
	// 82FC5D28: 4800004C  b 0x82fc5d74
	pc = 0x82FC5D74; continue 'dispatch;
            }
            0x82FC5D2C => {
    //   block [0x82FC5D2C..0x82FC5D5C)
	// 82FC5D2C: 813E0044  lwz r9, 0x44(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 82FC5D30: 7F97E378  mr r23, r28
	ctx.r[23].u64 = ctx.r[28].u64;
	// 82FC5D34: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82FC5D38: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82FC5D3C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82FC5D40: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC5D44: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC5D48: 409A0014  bne cr6, 0x82fc5d5c
	if !ctx.cr[6].eq {
	pc = 0x82FC5D5C; continue 'dispatch;
	}
	// 82FC5D4C: 81610090  lwz r11, 0x90(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 82FC5D50: 387E0034  addi r3, r30, 0x34
	ctx.r[3].s64 = ctx.r[30].s64 + 52;
	// 82FC5D54: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC5D58: 48001829  bl 0x82fc7580
	ctx.lr = 0x82FC5D5C;
	sub_82FC7580(ctx, base);
	pc = 0x82FC5D5C; continue 'dispatch;
            }
            0x82FC5D5C => {
    //   block [0x82FC5D5C..0x82FC5D70)
	// 82FC5D5C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82FC5D60: 387E0034  addi r3, r30, 0x34
	ctx.r[3].s64 = ctx.r[30].s64 + 52;
	// 82FC5D64: 4800146D  bl 0x82fc71d0
	ctx.lr = 0x82FC5D68;
	sub_82FC71D0(ctx, base);
	// 82FC5D68: 7EBBAB78  mr r27, r21
	ctx.r[27].u64 = ctx.r[21].u64;
	// 82FC5D6C: 48000008  b 0x82fc5d74
	pc = 0x82FC5D74; continue 'dispatch;
            }
            0x82FC5D70 => {
    //   block [0x82FC5D70..0x82FC5D74)
	// 82FC5D70: 9ABE0016  stb r21, 0x16(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(22 as u32), ctx.r[21].u8 ) };
	pc = 0x82FC5D74; continue 'dispatch;
            }
            0x82FC5D74 => {
    //   block [0x82FC5D74..0x82FC5D84)
	// 82FC5D74: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82FC5D78: 480011B9  bl 0x82fc6f30
	ctx.lr = 0x82FC5D7C;
	sub_82FC6F30(ctx, base);
	// 82FC5D7C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82FC5D80: 480114A9  bl 0x82fd7228
	ctx.lr = 0x82FC5D84;
	sub_82FD7228(ctx, base);
	pc = 0x82FC5D84; continue 'dispatch;
            }
            0x82FC5D84 => {
    //   block [0x82FC5D84..0x82FC5D90)
	// 82FC5D84: 576B063F  clrlwi. r11, r27, 0x18
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC5D88: 41820008  beq 0x82fc5d90
	if ctx.cr[0].eq {
	pc = 0x82FC5D90; continue 'dispatch;
	}
	// 82FC5D8C: 9ABE0015  stb r21, 0x15(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(21 as u32), ctx.r[21].u8 ) };
	pc = 0x82FC5D90; continue 'dispatch;
            }
            0x82FC5D90 => {
    //   block [0x82FC5D90..0x82FC5DC8)
	// 82FC5D90: 897E0015  lbz r11, 0x15(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(21 as u32) ) } as u64;
	// 82FC5D94: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC5D98: 40820190  bne 0x82fc5f28
	if !ctx.cr[0].eq {
	pc = 0x82FC5F28; continue 'dispatch;
	}
	// 82FC5D9C: 817E0044  lwz r11, 0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 82FC5DA0: 8381024C  lwz r28, 0x24c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(588 as u32) ) } as u64;
	// 82FC5DA4: 837E0038  lwz r27, 0x38(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 82FC5DA8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC5DAC: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 82FC5DB0: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 82FC5DB4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC5DB8: 409A0010  bne cr6, 0x82fc5dc8
	if !ctx.cr[6].eq {
	pc = 0x82FC5DC8; continue 'dispatch;
	}
	// 82FC5DBC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82FC5DC0: 387E0034  addi r3, r30, 0x34
	ctx.r[3].s64 = ctx.r[30].s64 + 52;
	// 82FC5DC4: 480017BD  bl 0x82fc7580
	ctx.lr = 0x82FC5DC8;
	sub_82FC7580(ctx, base);
	pc = 0x82FC5DC8; continue 'dispatch;
            }
            0x82FC5DC8 => {
    //   block [0x82FC5DC8..0x82FC5DF4)
	// 82FC5DC8: 7FFCDA14  add r31, r28, r27
	ctx.r[31].u64 = ctx.r[28].u64 + ctx.r[27].u64;
	// 82FC5DCC: 3BBE0034  addi r29, r30, 0x34
	ctx.r[29].s64 = ctx.r[30].s64 + 52;
	// 82FC5DD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC5DD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC5DD8: 48001171  bl 0x82fc6f48
	ctx.lr = 0x82FC5DDC;
	sub_82FC6F48(ctx, base);
	// 82FC5DDC: 817E0038  lwz r11, 0x38(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 82FC5DE0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82FC5DE4: 409A02F0  bne cr6, 0x82fc60d4
	if !ctx.cr[6].eq {
	pc = 0x82FC60D4; continue 'dispatch;
	}
	// 82FC5DE8: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 82FC5DEC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82FC5DF0: 419A0068  beq cr6, 0x82fc5e58
	if ctx.cr[6].eq {
	pc = 0x82FC5E58; continue 'dispatch;
	}
	pc = 0x82FC5DF4; continue 'dispatch;
            }
            0x82FC5DF4 => {
    //   block [0x82FC5DF4..0x82FC5E58)
	// 82FC5DF4: 813D0010  lwz r9, 0x10(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC5DF8: 57EBC23A  rlwinm r11, r31, 0x18, 8, 0x1d
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 82FC5DFC: 80C10258  lwz r6, 0x258(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(600 as u32) ) } as u64;
	// 82FC5E00: 57EA1CF8  rlwinm r10, r31, 3, 0x13, 0x1c
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x1FFFFFFFu64;
	// 82FC5E04: 7CBBFA14  add r5, r27, r31
	ctx.r[5].u64 = ctx.r[27].u64 + ctx.r[31].u64;
	// 82FC5E08: 811D000C  lwz r8, 0xc(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC5E0C: C01E000C  lfs f0, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC5E10: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82FC5E14: 80690008  lwz r3, 8(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC5E18: 7D6B302E  lwzx r11, r11, r6
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82FC5E1C: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC5E20: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC5E24: 7D2549D6  mullw r9, r5, r9
	ctx.r[9].s32 = ((ctx.r[5].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82FC5E28: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC5E2C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC5E30: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC5E34: EC4D0032  fmuls f2, f13, f0
	ctx.f[2].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC5E38: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC5E3C: EC2C0032  fmuls f1, f12, f0
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC5E40: 7C894214  add r4, r9, r8
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82FC5E44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC5E48: 4E800421  bctrl
	ctx.lr = 0x82FC5E4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC5E4C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82FC5E50: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82FC5E54: 4198FFA0  blt cr6, 0x82fc5df4
	if ctx.cr[6].lt {
	pc = 0x82FC5DF4; continue 'dispatch;
	}
            }
            0x82FC5E58 => {
    //   block [0x82FC5E58..0x82FC5E6C)
	// 82FC5E58: 816102A8  lwz r11, 0x2a8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(680 as u32) ) } as u64;
	// 82FC5E5C: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 82FC5E60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC5E64: 419A00C4  beq cr6, 0x82fc5f28
	if ctx.cr[6].eq {
	pc = 0x82FC5F28; continue 'dispatch;
	}
	// 82FC5E68: 3BFE001C  addi r31, r30, 0x1c
	ctx.r[31].s64 = ctx.r[30].s64 + 28;
	pc = 0x82FC5E6C; continue 'dispatch;
            }
            0x82FC5E6C => {
    //   block [0x82FC5E6C..0x82FC5EBC)
	// 82FC5E6C: 816102B4  lwz r11, 0x2b4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(692 as u32) ) } as u64;
	// 82FC5E70: 5789E13A  rlwinm r9, r28, 0x1c, 4, 0x1d
	ctx.r[9].u64 = ctx.r[28].u32 as u64 & 0x0000000Fu64;
	// 82FC5E74: 578A06BE  clrlwi r10, r28, 0x1a
	ctx.r[10].u64 = ctx.r[28].u32 as u64 & 0x0000003Fu64;
	// 82FC5E78: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82FC5E7C: 1D4A0018  mulli r10, r10, 0x18
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 24 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC5E80: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FC5E84: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC5E88: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	// 82FC5E8C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC5E90: 3BABFFFF  addi r29, r11, -1
	ctx.r[29].s64 = ctx.r[11].s64 + -1;
	// 82FC5E94: 48010415  bl 0x82fd62a8
	ctx.lr = 0x82FC5E98;
	sub_82FD62A8(ctx, base);
	// 82FC5E98: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82FC5E9C: 419A0020  beq cr6, 0x82fc5ebc
	if ctx.cr[6].eq {
	pc = 0x82FC5EBC; continue 'dispatch;
	}
	// 82FC5EA0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC5EA4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC5EA8: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC5EAC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC5EB0: 816BFF04  lwz r11, -0xfc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-252 as u32) ) } as u64;
	// 82FC5EB4: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82FC5EB8: 419A0018  beq cr6, 0x82fc5ed0
	if ctx.cr[6].eq {
	pc = 0x82FC5ED0; continue 'dispatch;
	}
	pc = 0x82FC5EBC; continue 'dispatch;
            }
            0x82FC5EBC => {
    //   block [0x82FC5EBC..0x82FC5ED0)
	// 82FC5EBC: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FC5EC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC5EC4: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82FC5EC8: 4BFFDBE9  bl 0x82fc3ab0
	ctx.lr = 0x82FC5ECC;
	sub_82FC3AB0(ctx, base);
	// 82FC5ECC: 3AF70001  addi r23, r23, 1
	ctx.r[23].s64 = ctx.r[23].s64 + 1;
	pc = 0x82FC5ED0; continue 'dispatch;
            }
            0x82FC5ED0 => {
    //   block [0x82FC5ED0..0x82FC5F14)
	// 82FC5ED0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC5ED4: 38A10130  addi r5, r1, 0x130
	ctx.r[5].s64 = ctx.r[1].s64 + 304;
	// 82FC5ED8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC5EDC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC5EE0: 556B402E  slwi r11, r11, 8
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(8);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC5EE4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC5EE8: 386BFF00  addi r3, r11, -0x100
	ctx.r[3].s64 = ctx.r[11].s64 + -256;
	// 82FC5EEC: 4BFFCEED  bl 0x82fc2dd8
	ctx.lr = 0x82FC5EF0;
	sub_82FC2DD8(ctx, base);
	// 82FC5EF0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82FC5EF4: 419A0020  beq cr6, 0x82fc5f14
	if ctx.cr[6].eq {
	pc = 0x82FC5F14; continue 'dispatch;
	}
	// 82FC5EF8: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC5EFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC5F00: 419A0014  beq cr6, 0x82fc5f14
	if ctx.cr[6].eq {
	pc = 0x82FC5F14; continue 'dispatch;
	}
	// 82FC5F04: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC5F08: 812102E4  lwz r9, 0x2e4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(740 as u32) ) } as u64;
	// 82FC5F0C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82FC5F10: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	pc = 0x82FC5F14; continue 'dispatch;
            }
            0x82FC5F14 => {
    //   block [0x82FC5F14..0x82FC5F28)
	// 82FC5F14: 816102A8  lwz r11, 0x2a8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(680 as u32) ) } as u64;
	// 82FC5F18: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82FC5F1C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC5F20: 4198FF4C  blt cr6, 0x82fc5e6c
	if ctx.cr[6].lt {
	pc = 0x82FC5E6C; continue 'dispatch;
	}
	// 82FC5F24: 92E10050  stw r23, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	pc = 0x82FC5F28; continue 'dispatch;
            }
            0x82FC5F28 => {
    //   block [0x82FC5F28..0x82FC5F54)
	// 82FC5F28: 93210068  stw r25, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 82FC5F2C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82FC5F30: 9321006C  stw r25, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[25].u32 ) };
	// 82FC5F34: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 82FC5F38: 8098001C  lwz r4, 0x1c(r24)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC5F3C: 4BF9367D  bl 0x82f595b8
	ctx.lr = 0x82FC5F40;
	sub_82F595B8(ctx, base);
	// 82FC5F40: 8158001C  lwz r10, 0x1c(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC5F44: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82FC5F48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82FC5F4C: 83410068  lwz r26, 0x68(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82FC5F50: 40990018  ble cr6, 0x82fc5f68
	if !ctx.cr[6].gt {
	pc = 0x82FC5F68; continue 'dispatch;
	}
	pc = 0x82FC5F54; continue 'dispatch;
            }
            0x82FC5F54 => {
    //   block [0x82FC5F54..0x82FC5F68)
	// 82FC5F54: 7F3A59AE  stbx r25, r26, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32), ctx.r[25].u8) };
	// 82FC5F58: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FC5F5C: 8158001C  lwz r10, 0x1c(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC5F60: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC5F64: 4198FFF0  blt cr6, 0x82fc5f54
	if ctx.cr[6].lt {
	pc = 0x82FC5F54; continue 'dispatch;
	}
	pc = 0x82FC5F68; continue 'dispatch;
            }
            0x82FC5F68 => {
    //   block [0x82FC5F68..0x82FC5F7C)
	// 82FC5F68: 8178001C  lwz r11, 0x1c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC5F6C: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 82FC5F70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC5F74: 40990138  ble cr6, 0x82fc60ac
	if !ctx.cr[6].gt {
	pc = 0x82FC60AC; continue 'dispatch;
	}
	// 82FC5F78: 3B3AFFFF  addi r25, r26, -1
	ctx.r[25].s64 = ctx.r[26].s64 + -1;
	pc = 0x82FC5F7C; continue 'dispatch;
            }
            0x82FC5F7C => {
    //   block [0x82FC5F7C..0x82FC6020)
	// 82FC5F7C: 3B9D0001  addi r28, r29, 1
	ctx.r[28].s64 = ctx.r[29].s64 + 1;
	// 82FC5F80: 7D7CC8AE  lbzx r11, r28, r25
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[25].u32)) } as u64;
	// 82FC5F84: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC5F88: 40820110  bne 0x82fc6098
	if !ctx.cr[0].eq {
	pc = 0x82FC6098; continue 'dispatch;
	}
	// 82FC5F8C: 81780028  lwz r11, 0x28(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC5F90: 57A9E13A  rlwinm r9, r29, 0x1c, 4, 0x1d
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x0000000Fu64;
	// 82FC5F94: 57AA06BE  clrlwi r10, r29, 0x1a
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x0000003Fu64;
	// 82FC5F98: 1D4A0018  mulli r10, r10, 0x18
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 24 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC5F9C: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FC5FA0: 7F6B5214  add r27, r11, r10
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC5FA4: 817B0014  lwz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC5FA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC5FAC: 419800EC  blt cr6, 0x82fc6098
	if ctx.cr[6].lt {
	pc = 0x82FC6098; continue 'dispatch;
	}
	// 82FC5FB0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC5FB4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82FC5FB8: 409900E0  ble cr6, 0x82fc6098
	if !ctx.cr[6].gt {
	pc = 0x82FC6098; continue 'dispatch;
	}
	// 82FC5FBC: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82FC5FC0: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 82FC5FC4: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82FC5FC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC5FCC: 4BFFF95D  bl 0x82fc5928
	ctx.lr = 0x82FC5FD0;
	sub_82FC5928(ctx, base);
	// 82FC5FD0: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82FC5FD4: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC5FD8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82FC5FDC: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC5FE0: 893E0014  lbz r9, 0x14(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC5FE4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC5FE8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82FC5FEC: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 82FC5FF0: 992BFFCC  stb r9, -0x34(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-52 as u32), ctx.r[9].u8 ) };
	// 82FC5FF4: C03E000C  lfs f1, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC5FF8: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC5FFC: 817E002C  lwz r11, 0x2c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) } as u64;
	// 82FC6000: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC6004: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC6008: 386BFFA0  addi r3, r11, -0x60
	ctx.r[3].s64 = ctx.r[11].s64 + -96;
	// 82FC600C: 4BFFDE75  bl 0x82fc3e80
	ctx.lr = 0x82FC6010;
	sub_82FC3E80(ctx, base);
	// 82FC6010: 8178001C  lwz r11, 0x1c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC6014: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82FC6018: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC601C: 4098007C  bge cr6, 0x82fc6098
	if !ctx.cr[6].lt {
	pc = 0x82FC6098; continue 'dispatch;
	}
	pc = 0x82FC6020; continue 'dispatch;
            }
            0x82FC6020 => {
    //   block [0x82FC6020..0x82FC6088)
	// 82FC6020: 81780028  lwz r11, 0x28(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC6024: 57A9E13A  rlwinm r9, r29, 0x1c, 4, 0x1d
	ctx.r[9].u64 = ctx.r[29].u32 as u64 & 0x0000000Fu64;
	// 82FC6028: 57AA06BE  clrlwi r10, r29, 0x1a
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x0000003Fu64;
	// 82FC602C: 811B0014  lwz r8, 0x14(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC6030: 1D4A0018  mulli r10, r10, 0x18
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 24 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC6034: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FC6038: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC603C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC6040: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82FC6044: 409A0044  bne cr6, 0x82fc6088
	if !ctx.cr[6].eq {
	pc = 0x82FC6088; continue 'dispatch;
	}
	// 82FC6048: 7EBAE9AE  stbx r21, r26, r29
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[29].u32), ctx.r[21].u8) };
	// 82FC604C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC6050: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC6054: 41980034  blt cr6, 0x82fc6088
	if ctx.cr[6].lt {
	pc = 0x82FC6088; continue 'dispatch;
	}
	// 82FC6058: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC605C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82FC6060: 40990028  ble cr6, 0x82fc6088
	if !ctx.cr[6].gt {
	pc = 0x82FC6088; continue 'dispatch;
	}
	// 82FC6064: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6068: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82FC606C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC6070: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 82FC6074: 1D6B0060  mulli r11, r11, 0x60
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 96 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC6078: C03E000C  lfs f1, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC607C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC6080: 386BFFA0  addi r3, r11, -0x60
	ctx.r[3].s64 = ctx.r[11].s64 + -96;
	// 82FC6084: 4BFFDDFD  bl 0x82fc3e80
	ctx.lr = 0x82FC6088;
	sub_82FC3E80(ctx, base);
	pc = 0x82FC6088; continue 'dispatch;
            }
            0x82FC6088 => {
    //   block [0x82FC6088..0x82FC6098)
	// 82FC6088: 8178001C  lwz r11, 0x1c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC608C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82FC6090: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC6094: 4198FF8C  blt cr6, 0x82fc6020
	if ctx.cr[6].lt {
	pc = 0x82FC6020; continue 'dispatch;
	}
	pc = 0x82FC6098; continue 'dispatch;
            }
            0x82FC6098 => {
    //   block [0x82FC6098..0x82FC60AC)
	// 82FC6098: 8178001C  lwz r11, 0x1c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC609C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82FC60A0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC60A4: 4198FED8  blt cr6, 0x82fc5f7c
	if ctx.cr[6].lt {
	pc = 0x82FC5F7C; continue 'dispatch;
	}
	// 82FC60A8: 92C10054  stw r22, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[22].u32 ) };
	pc = 0x82FC60AC; continue 'dispatch;
            }
            0x82FC60AC => {
    //   block [0x82FC60AC..0x82FC60D4)
	// 82FC60AC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FC60B0: 387E0058  addi r3, r30, 0x58
	ctx.r[3].s64 = ctx.r[30].s64 + 88;
	// 82FC60B4: 4BFFDD75  bl 0x82fc3e28
	ctx.lr = 0x82FC60B8;
	sub_82FC3E28(ctx, base);
	// 82FC60B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC60BC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82FC60C0: 4BF934F9  bl 0x82f595b8
	ctx.lr = 0x82FC60C4;
	sub_82F595B8(ctx, base);
	// 82FC60C4: 80610068  lwz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82FC60C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC60CC: 419A0008  beq cr6, 0x82fc60d4
	if ctx.cr[6].eq {
	pc = 0x82FC60D4; continue 'dispatch;
	}
	// 82FC60D0: 4BF377D1  bl 0x82efd8a0
	ctx.lr = 0x82FC60D4;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC60D4; continue 'dispatch;
            }
            0x82FC60D4 => {
    //   block [0x82FC60D4..0x82FC60D8)
	// 82FC60D4: 38610130  addi r3, r1, 0x130
	ctx.r[3].s64 = ctx.r[1].s64 + 304;
	pc = 0x82FC60D8; continue 'dispatch;
            }
            0x82FC60D8 => {
    //   block [0x82FC60D8..0x82FC60E4)
	// 82FC60D8: 4BFFD7C9  bl 0x82fc38a0
	ctx.lr = 0x82FC60DC;
	sub_82FC38A0(ctx, base);
	// 82FC60DC: 382103B0  addi r1, r1, 0x3b0
	ctx.r[1].s64 = ctx.r[1].s64 + 944;
	// 82FC60E0: 4BCE335C  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC60E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC60E8 size=8
    let mut pc: u32 = 0x82FC60E8;
    'dispatch: loop {
        match pc {
            0x82FC60E8 => {
    //   block [0x82FC60E8..0x82FC60F0)
	// 82FC60E8: 80E60000  lwz r7, 0(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC60EC: 4BFFF934  b 0x82fc5a20
	sub_82FC5A20(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC60F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC60F0 size=196
    let mut pc: u32 = 0x82FC60F0;
    'dispatch: loop {
        match pc {
            0x82FC60F0 => {
    //   block [0x82FC60F0..0x82FC61B4)
	// 82FC60F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC60F4: 4BCE3315  bl 0x82ca9408
	ctx.lr = 0x82FC60F8;
	sub_82CA93D0(ctx, base);
	// 82FC60F8: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82FC60FC: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82FC6100: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC6104: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC6108: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82FC610C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FC6110: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82FC6114: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82FC6118: 396B6974  addi r11, r11, 0x6974
	ctx.r[11].s64 = ctx.r[11].s64 + 26996;
	// 82FC611C: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 82FC6120: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC6124: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82FC6128: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82FC612C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC6130: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82FC6134: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82FC6138: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82FC613C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82FC6140: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82FC6144: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82FC6148: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82FC614C: 480013E5  bl 0x82fc7530
	ctx.lr = 0x82FC6150;
	sub_82FC7530(ctx, base);
	// 82FC6150: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC6154: 93DF0050  stw r30, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82FC6158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC615C: 93DF0054  stw r30, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82FC6160: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82FC6164: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82FC6168: 93DF0060  stw r30, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82FC616C: C00B0C14  lfs f0, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC6170: D3FF0004  stfs f31, 4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82FC6174: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82FC6178: D3DF0008  stfs f30, 8(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82FC617C: 9BDF0015  stb r30, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[30].u8 ) };
	// 82FC6180: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82FC6184: 9BDF0016  stb r30, 0x16(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(22 as u32), ctx.r[30].u8 ) };
	// 82FC6188: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82FC618C: 9BDF0017  stb r30, 0x17(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(23 as u32), ctx.r[30].u8 ) };
	// 82FC6190: 9B9F0018  stb r28, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[28].u8 ) };
	// 82FC6194: 93DF0064  stw r30, 0x64(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	// 82FC6198: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82FC619C: 93DF006C  stw r30, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 82FC61A0: 93DF0070  stw r30, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82FC61A4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82FC61A8: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82FC61AC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82FC61B0: 4BCE32A8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC61B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC61B8 size=260
    let mut pc: u32 = 0x82FC61B8;
    'dispatch: loop {
        match pc {
            0x82FC61B8 => {
    //   block [0x82FC61B8..0x82FC6204)
	// 82FC61B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC61BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC61C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC61C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC61C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC61CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC61D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FC61D4: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 82FC61D8: 396B6974  addi r11, r11, 0x6974
	ctx.r[11].s64 = ctx.r[11].s64 + 26996;
	// 82FC61DC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC61E0: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC61E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC61E8: 419A001C  beq cr6, 0x82fc6204
	if ctx.cr[6].eq {
	pc = 0x82FC6204; continue 'dispatch;
	}
	// 82FC61EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC61F0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82FC61F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC61F8: 816B0038  lwz r11, 0x38(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82FC61FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC6200: 4E800421  bctrl
	ctx.lr = 0x82FC6204;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC6204 => {
    //   block [0x82FC6204..0x82FC6220)
	// 82FC6204: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC6208: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC620C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC6210: 807F0064  lwz r3, 0x64(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 82FC6214: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC6218: 419A0008  beq cr6, 0x82fc6220
	if ctx.cr[6].eq {
	pc = 0x82FC6220; continue 'dispatch;
	}
	// 82FC621C: 4BF37685  bl 0x82efd8a0
	ctx.lr = 0x82FC6220;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC6220; continue 'dispatch;
            }
            0x82FC6220 => {
    //   block [0x82FC6220..0x82FC6234)
	// 82FC6220: 807F006C  lwz r3, 0x6c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82FC6224: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC6228: 419A000C  beq cr6, 0x82fc6234
	if ctx.cr[6].eq {
	pc = 0x82FC6234; continue 'dispatch;
	}
	// 82FC622C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82FC6230: 4BFFF1B9  bl 0x82fc53e8
	ctx.lr = 0x82FC6234;
	sub_82FC53E8(ctx, base);
	pc = 0x82FC6234; continue 'dispatch;
            }
            0x82FC6234 => {
    //   block [0x82FC6234..0x82FC6248)
	// 82FC6234: 807F0070  lwz r3, 0x70(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) } as u64;
	// 82FC6238: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC623C: 419A000C  beq cr6, 0x82fc6248
	if ctx.cr[6].eq {
	pc = 0x82FC6248; continue 'dispatch;
	}
	// 82FC6240: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82FC6244: 4BFFF205  bl 0x82fc5448
	ctx.lr = 0x82FC6248;
	sub_82FC5448(ctx, base);
	pc = 0x82FC6248; continue 'dispatch;
            }
            0x82FC6248 => {
    //   block [0x82FC6248..0x82FC6264)
	// 82FC6248: 387F0058  addi r3, r31, 0x58
	ctx.r[3].s64 = ctx.r[31].s64 + 88;
	// 82FC624C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC6250: 4BFFD959  bl 0x82fc3ba8
	ctx.lr = 0x82FC6254;
	sub_82FC3BA8(ctx, base);
	// 82FC6254: 807F0058  lwz r3, 0x58(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82FC6258: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC625C: 419A0008  beq cr6, 0x82fc6264
	if ctx.cr[6].eq {
	pc = 0x82FC6264; continue 'dispatch;
	}
	// 82FC6260: 4BF37641  bl 0x82efd8a0
	ctx.lr = 0x82FC6264;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC6264; continue 'dispatch;
            }
            0x82FC6264 => {
    //   block [0x82FC6264..0x82FC6288)
	// 82FC6264: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 82FC6268: 48000CC9  bl 0x82fc6f30
	ctx.lr = 0x82FC626C;
	sub_82FC6F30(ctx, base);
	// 82FC626C: 387F0028  addi r3, r31, 0x28
	ctx.r[3].s64 = ctx.r[31].s64 + 40;
	// 82FC6270: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC6274: 4BFFF6B5  bl 0x82fc5928
	ctx.lr = 0x82FC6278;
	sub_82FC5928(ctx, base);
	// 82FC6278: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC627C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC6280: 419A0008  beq cr6, 0x82fc6288
	if ctx.cr[6].eq {
	pc = 0x82FC6288; continue 'dispatch;
	}
	// 82FC6284: 4BF3761D  bl 0x82efd8a0
	ctx.lr = 0x82FC6288;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC6288; continue 'dispatch;
            }
            0x82FC6288 => {
    //   block [0x82FC6288..0x82FC62A4)
	// 82FC6288: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82FC628C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC6290: 4BFFD821  bl 0x82fc3ab0
	ctx.lr = 0x82FC6294;
	sub_82FC3AB0(ctx, base);
	// 82FC6294: 807F001C  lwz r3, 0x1c(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC6298: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC629C: 419A0008  beq cr6, 0x82fc62a4
	if ctx.cr[6].eq {
	pc = 0x82FC62A4; continue 'dispatch;
	}
	// 82FC62A0: 4BF37601  bl 0x82efd8a0
	ctx.lr = 0x82FC62A4;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC62A4; continue 'dispatch;
            }
            0x82FC62A4 => {
    //   block [0x82FC62A4..0x82FC62BC)
	// 82FC62A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC62A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC62AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC62B0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC62B4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC62B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC62C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC62C0 size=76
    let mut pc: u32 = 0x82FC62C0;
    'dispatch: loop {
        match pc {
            0x82FC62C0 => {
    //   block [0x82FC62C0..0x82FC62F0)
	// 82FC62C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC62C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC62C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC62CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC62D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC62D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC62D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC62DC: 4BFFFEDD  bl 0x82fc61b8
	ctx.lr = 0x82FC62E0;
	sub_82FC61B8(ctx, base);
	// 82FC62E0: 57CB07FF  clrlwi. r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC62E4: 4182000C  beq 0x82fc62f0
	if ctx.cr[0].eq {
	pc = 0x82FC62F0; continue 'dispatch;
	}
	// 82FC62E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC62EC: 4BF375B5  bl 0x82efd8a0
	ctx.lr = 0x82FC62F0;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC62F0; continue 'dispatch;
            }
            0x82FC62F0 => {
    //   block [0x82FC62F0..0x82FC630C)
	// 82FC62F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC62F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC62F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC62FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC6300: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC6304: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC6308: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FC6310 size=28
    let mut pc: u32 = 0x82FC6310;
    'dispatch: loop {
        match pc {
            0x82FC6310 => {
    //   block [0x82FC6310..0x82FC632C)
	// 82FC6310: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC6314: D0230000  stfs f1, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC6318: C00B0A7C  lfs f0, 0xa7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC631C: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC6320: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC6324: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82FC6328: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FC6330 size=76
    let mut pc: u32 = 0x82FC6330;
    'dispatch: loop {
        match pc {
            0x82FC6330 => {
    //   block [0x82FC6330..0x82FC637C)
	// 82FC6330: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC6334: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82FC6338: 3D007FFF  lis r8, 0x7fff
	ctx.r[8].s64 = 2147418112;
	// 82FC633C: 3CE08000  lis r7, -0x8000
	ctx.r[7].s64 = -2147483648;
	// 82FC6340: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC6344: C00A0C14  lfs f0, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC6348: 6108FFFF  ori r8, r8, 0xffff
	ctx.r[8].u64 = ctx.r[8].u64 | 65535;
	// 82FC634C: 60EA0001  ori r10, r7, 1
	ctx.r[10].u64 = ctx.r[7].u64 | 1;
	// 82FC6350: C1A90C18  lfs f13, 0xc18(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC6354: D003003C  stfs f0, 0x3c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82FC6358: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC635C: D0030040  stfs f0, 0x40(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82FC6360: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82FC6364: D1A30044  stfs f13, 0x44(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82FC6368: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82FC636C: D1A30048  stfs f13, 0x48(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82FC6370: 91030034  stw r8, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[8].u32 ) };
	// 82FC6374: 91430038  stw r10, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	// 82FC6378: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6380(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FC6380 size=220
    let mut pc: u32 = 0x82FC6380;
    'dispatch: loop {
        match pc {
            0x82FC6380 => {
    //   block [0x82FC6380..0x82FC63E4)
	// 82FC6380: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC6384: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC6388: C00B0C14  lfs f0, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC638C: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC6390: C1AA0C18  lfs f13, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC6394: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC6398: D1A60000  stfs f13, 0(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC639C: D1A70000  stfs f13, 0(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC63A0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC63A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC63A8: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82FC63AC: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC63B0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82FC63B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC63B8: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC63BC: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC63C0: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC63C4: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC63C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC63CC: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC63D0: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC63D4: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC63D8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC63DC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82FC63E0: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82FC63E4; continue 'dispatch;
            }
            0x82FC63E4 => {
    //   block [0x82FC63E4..0x82FC640C)
	// 82FC63E4: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC63E8: 5548D1BA  rlwinm r8, r10, 0x1a, 6, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 82FC63EC: 554B1D78  rlwinm r11, r10, 3, 0x15, 0x1c
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 82FC63F0: C1A40000  lfs f13, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC63F4: 7D28482E  lwzx r9, r8, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FC63F8: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82FC63FC: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC6400: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82FC6404: 40980008  bge cr6, 0x82fc640c
	if !ctx.cr[6].lt {
	pc = 0x82FC640C; continue 'dispatch;
	}
	// 82FC6408: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82FC640C; continue 'dispatch;
            }
            0x82FC640C => {
    //   block [0x82FC640C..0x82FC6420)
	// 82FC640C: C1A50000  lfs f13, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC6410: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC6414: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82FC6418: 40980008  bge cr6, 0x82fc6420
	if !ctx.cr[6].lt {
	pc = 0x82FC6420; continue 'dispatch;
	}
	// 82FC641C: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82FC6420; continue 'dispatch;
            }
            0x82FC6420 => {
    //   block [0x82FC6420..0x82FC6434)
	// 82FC6420: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC6424: C1A60000  lfs f13, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC6428: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82FC642C: 40990008  ble cr6, 0x82fc6434
	if !ctx.cr[6].gt {
	pc = 0x82FC6434; continue 'dispatch;
	}
	// 82FC6430: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82FC6434; continue 'dispatch;
            }
            0x82FC6434 => {
    //   block [0x82FC6434..0x82FC6448)
	// 82FC6434: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC6438: C1A70000  lfs f13, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC643C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82FC6440: 40990008  ble cr6, 0x82fc6448
	if !ctx.cr[6].gt {
	pc = 0x82FC6448; continue 'dispatch;
	}
	// 82FC6444: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82FC6448; continue 'dispatch;
            }
            0x82FC6448 => {
    //   block [0x82FC6448..0x82FC645C)
	// 82FC6448: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC644C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82FC6450: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC6454: 4198FF90  blt cr6, 0x82fc63e4
	if ctx.cr[6].lt {
	pc = 0x82FC63E4; continue 'dispatch;
	}
	// 82FC6458: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FC6460 size=80
    let mut pc: u32 = 0x82FC6460;
    'dispatch: loop {
        match pc {
            0x82FC6460 => {
    //   block [0x82FC6460..0x82FC6470)
	// 82FC6460: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC6464: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82FC6468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC646C: 4C990020  blelr cr6
	if !ctx.cr[6].gt { return; }
	pc = 0x82FC6470; continue 'dispatch;
            }
            0x82FC6470 => {
    //   block [0x82FC6470..0x82FC64B0)
	// 82FC6470: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC6474: 5548D1BA  rlwinm r8, r10, 0x1a, 6, 0x1d
	ctx.r[8].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 82FC6478: 55491D78  rlwinm r9, r10, 3, 0x15, 0x1c
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 82FC647C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82FC6480: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FC6484: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82FC6488: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC648C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC6490: EC00187A  fmadds f0, f0, f1, f3
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64 + ctx.f[3].f64) as f32) as f64);
	// 82FC6494: EDAD20BA  fmadds f13, f13, f2, f4
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[2].f64 + ctx.f[4].f64) as f32) as f64);
	// 82FC6498: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC649C: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82FC64A0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC64A4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC64A8: 4198FFC8  blt cr6, 0x82fc6470
	if ctx.cr[6].lt {
	pc = 0x82FC6470; continue 'dispatch;
	}
	// 82FC64AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC64B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC64B0 size=152
    let mut pc: u32 = 0x82FC64B0;
    'dispatch: loop {
        match pc {
            0x82FC64B0 => {
    //   block [0x82FC64B0..0x82FC650C)
	// 82FC64B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC64B4: 4BCE2F59  bl 0x82ca940c
	ctx.lr = 0x82FC64B8;
	sub_82CA93D0(ctx, base);
	// 82FC64B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC64BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC64C0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82FC64C4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC64C8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC64CC: 41980054  blt cr6, 0x82fc6520
	if ctx.cr[6].lt {
	pc = 0x82FC6520; continue 'dispatch;
	}
	// 82FC64D0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC64D4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC64D8: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82FC64DC: 4BF37385  bl 0x82efd860
	ctx.lr = 0x82FC64E0;
	sub_82EFD860(ctx, base);
	// 82FC64E0: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC64E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC64E8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FC64EC: 419A0020  beq cr6, 0x82fc650c
	if ctx.cr[6].eq {
	pc = 0x82FC650C; continue 'dispatch;
	}
	// 82FC64F0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC64F4: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82FC64F8: 4BCE2F89  bl 0x82ca9480
	ctx.lr = 0x82FC64FC;
	sub_82CA9480(ctx, base);
	// 82FC64FC: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC6500: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC6504: 419A0008  beq cr6, 0x82fc650c
	if ctx.cr[6].eq {
	pc = 0x82FC650C; continue 'dispatch;
	}
	// 82FC6508: 4BF37399  bl 0x82efd8a0
	ctx.lr = 0x82FC650C;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC650C; continue 'dispatch;
            }
            0x82FC650C => {
    //   block [0x82FC650C..0x82FC6520)
	// 82FC650C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC6510: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC6514: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82FC6518: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC651C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82FC6520; continue 'dispatch;
            }
            0x82FC6520 => {
    //   block [0x82FC6520..0x82FC6548)
	// 82FC6520: 38600600  li r3, 0x600
	ctx.r[3].s64 = 1536;
	// 82FC6524: 4BF3733D  bl 0x82efd860
	ctx.lr = 0x82FC6528;
	sub_82EFD860(ctx, base);
	// 82FC6528: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC652C: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82FC6530: 7C6A592E  stwx r3, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	// 82FC6534: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6538: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FC653C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC6540: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC6544: 4BCE2F18  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FC6548 size=156
    let mut pc: u32 = 0x82FC6548;
    'dispatch: loop {
        match pc {
            0x82FC6548 => {
    //   block [0x82FC6548..0x82FC655C)
	// 82FC6548: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82FC654C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6550: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82FC6554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC6558: 40990084  ble cr6, 0x82fc65dc
	if !ctx.cr[6].gt {
	pc = 0x82FC65DC; continue 'dispatch;
	}
	pc = 0x82FC655C; continue 'dispatch;
            }
            0x82FC655C => {
    //   block [0x82FC655C..0x82FC6590)
	// 82FC655C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC6560: C1A40000  lfs f13, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC6564: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC6568: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82FC656C: 557FD1BA  rlwinm r31, r11, 0x1a, 6, 0x1d
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FC6570: 556A1D78  rlwinm r10, r11, 3, 0x15, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 82FC6574: 81680014  lwz r11, 0x14(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC6578: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FC657C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC6580: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC6584: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82FC6588: 40980008  bge cr6, 0x82fc6590
	if !ctx.cr[6].lt {
	pc = 0x82FC6590; continue 'dispatch;
	}
	// 82FC658C: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82FC6590; continue 'dispatch;
            }
            0x82FC6590 => {
    //   block [0x82FC6590..0x82FC65A4)
	// 82FC6590: C1A50000  lfs f13, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC6594: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC6598: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82FC659C: 40980008  bge cr6, 0x82fc65a4
	if !ctx.cr[6].lt {
	pc = 0x82FC65A4; continue 'dispatch;
	}
	// 82FC65A0: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82FC65A4; continue 'dispatch;
            }
            0x82FC65A4 => {
    //   block [0x82FC65A4..0x82FC65B8)
	// 82FC65A4: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC65A8: C1A60000  lfs f13, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC65AC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82FC65B0: 40990008  ble cr6, 0x82fc65b8
	if !ctx.cr[6].gt {
	pc = 0x82FC65B8; continue 'dispatch;
	}
	// 82FC65B4: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82FC65B8; continue 'dispatch;
            }
            0x82FC65B8 => {
    //   block [0x82FC65B8..0x82FC65CC)
	// 82FC65B8: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC65BC: C1A70000  lfs f13, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC65C0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82FC65C4: 40990008  ble cr6, 0x82fc65cc
	if !ctx.cr[6].gt {
	pc = 0x82FC65CC; continue 'dispatch;
	}
	// 82FC65C8: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82FC65CC; continue 'dispatch;
            }
            0x82FC65CC => {
    //   block [0x82FC65CC..0x82FC65DC)
	// 82FC65CC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC65D0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82FC65D4: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC65D8: 4198FF84  blt cr6, 0x82fc655c
	if ctx.cr[6].lt {
	pc = 0x82FC655C; continue 'dispatch;
	}
	pc = 0x82FC65DC; continue 'dispatch;
            }
            0x82FC65DC => {
    //   block [0x82FC65DC..0x82FC65E4)
	// 82FC65DC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82FC65E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC65E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FC65E8 size=380
    let mut pc: u32 = 0x82FC65E8;
    'dispatch: loop {
        match pc {
            0x82FC65E8 => {
    //   block [0x82FC65E8..0x82FC6610)
	// 82FC65E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC65EC: 4BCE2E11  bl 0x82ca93fc
	ctx.lr = 0x82FC65F0;
	sub_82CA93D0(ctx, base);
	// 82FC65F0: 8343001C  lwz r26, 0x1c(r3)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC65F4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82FC65F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82FC65FC: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82FC6600: 419A0154  beq cr6, 0x82fc6754
	if ctx.cr[6].eq {
	pc = 0x82FC6754; continue 'dispatch;
	}
	// 82FC6604: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC6608: 83630028  lwz r27, 0x28(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC660C: C16B0C18  lfs f11, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x82FC6610; continue 'dispatch;
            }
            0x82FC6610 => {
    //   block [0x82FC6610..0x82FC6654)
	// 82FC6610: 57EAE13A  rlwinm r10, r31, 0x1c, 4, 0x1d
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x0000000Fu64;
	// 82FC6614: 57EB06BE  clrlwi r11, r31, 0x1a
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x0000003Fu64;
	// 82FC6618: 1D6B0018  mulli r11, r11, 0x18
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC661C: 7D4AD82E  lwzx r10, r10, r27
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 82FC6620: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC6624: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC6628: 83CB0010  lwz r30, 0x10(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC662C: 7F03F000  cmpw cr6, r3, r30
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82FC6630: 419A0118  beq cr6, 0x82fc6748
	if ctx.cr[6].eq {
	pc = 0x82FC6748; continue 'dispatch;
	}
	// 82FC6634: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6638: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82FC663C: 4099010C  ble cr6, 0x82fc6748
	if !ctx.cr[6].gt {
	pc = 0x82FC6748; continue 'dispatch;
	}
	// 82FC6640: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC6644: 3B8AFFFF  addi r28, r10, -1
	ctx.r[28].s64 = ctx.r[10].s64 + -1;
	// 82FC6648: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC664C: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 82FC6650: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	pc = 0x82FC6654; continue 'dispatch;
            }
            0x82FC6654 => {
    //   block [0x82FC6654..0x82FC66BC)
	// 82FC6654: 3967FFFF  addi r11, r7, -1
	ctx.r[11].s64 = ctx.r[7].s64 + -1;
	// 82FC6658: 54E9D1BA  rlwinm r9, r7, 0x1a, 6, 0x1d
	ctx.r[9].u64 = ctx.r[7].u32 as u64 & 0x0000003Fu64;
	// 82FC665C: 556BD1BA  rlwinm r11, r11, 0x1a, 6, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FC6660: 3947FFFF  addi r10, r7, -1
	ctx.r[10].s64 = ctx.r[7].s64 + -1;
	// 82FC6664: 54E81D78  rlwinm r8, r7, 3, 0x15, 0x1c
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x1FFFFFFFu64;
	// 82FC6668: 554A1D78  rlwinm r10, r10, 3, 0x15, 0x1c
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 82FC666C: 7D29202E  lwzx r9, r9, r4
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82FC6670: 7D6B202E  lwzx r11, r11, r4
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32)) } as u64;
	// 82FC6674: 7CA9402A  ldx r5, r9, r8
	ctx.r[5].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) };
	// 82FC6678: 7F2B502A  ldx r25, r11, r10
	ctx.r[25].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	// 82FC667C: F8A1FFB0  std r5, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.r[5].u64 ) };
	// 82FC6680: C001FFB4  lfs f0, -0x4c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC6684: FB21FFB8  std r25, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.r[25].u64 ) };
	// 82FC6688: C181FFBC  lfs f12, -0x44(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC668C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82FC6690: 419A00AC  beq cr6, 0x82fc673c
	if ctx.cr[6].eq {
	pc = 0x82FC673C; continue 'dispatch;
	}
	// 82FC6694: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82FC6698: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82FC669C: 40990020  ble cr6, 0x82fc66bc
	if !ctx.cr[6].gt {
	pc = 0x82FC66BC; continue 'dispatch;
	}
	// 82FC66A0: 7D29402A  ldx r9, r9, r8
	ctx.r[9].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) };
	// 82FC66A4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82FC66A8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82FC66AC: F921FFB8  std r9, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.r[9].u64 ) };
	// 82FC66B0: C181FFBC  lfs f12, -0x44(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC66B4: F961FFB0  std r11, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.r[11].u64 ) };
	// 82FC66B8: C001FFB4  lfs f0, -0x4c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82FC66BC; continue 'dispatch;
            }
            0x82FC66BC => {
    //   block [0x82FC66BC..0x82FC6710)
	// 82FC66BC: FF026000  fcmpu cr6, f2, f12
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[12].f64);
	// 82FC66C0: 4198007C  blt cr6, 0x82fc673c
	if ctx.cr[6].lt {
	pc = 0x82FC673C; continue 'dispatch;
	}
	// 82FC66C4: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82FC66C8: 40980074  bge cr6, 0x82fc673c
	if !ctx.cr[6].lt {
	pc = 0x82FC673C; continue 'dispatch;
	}
	// 82FC66CC: C1A1FFB0  lfs f13, -0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC66D0: ED420028  fsubs f10, f2, f0
	ctx.f[10].f64 = (((ctx.f[2].f64 - ctx.f[0].f64) as f32) as f64);
	// 82FC66D4: C121FFB8  lfs f9, -0x48(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82FC66D8: ED016828  fsubs f8, f1, f13
	ctx.f[8].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FC66DC: EDAD4828  fsubs f13, f13, f9
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 82FC66E0: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FC66E4: EDAD02B2  fmuls f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 82FC66E8: EC086838  fmsubs f0, f8, f0, f13
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FC66EC: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82FC66F0: 4099004C  ble cr6, 0x82fc673c
	if !ctx.cr[6].gt {
	pc = 0x82FC673C; continue 'dispatch;
	}
	// 82FC66F4: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC66F8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82FC66FC: 4182002C  beq 0x82fc6728
	if ctx.cr[0].eq {
	pc = 0x82FC6728; continue 'dispatch;
	}
	// 82FC6700: 41980010  blt cr6, 0x82fc6710
	if ctx.cr[6].lt {
	pc = 0x82FC6710; continue 'dispatch;
	}
	// 82FC6704: 39630001  addi r11, r3, 1
	ctx.r[11].s64 = ctx.r[3].s64 + 1;
	// 82FC6708: 7D6B29D6  mullw r11, r11, r5
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC670C: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	pc = 0x82FC6710; continue 'dispatch;
            }
            0x82FC6710 => {
    //   block [0x82FC6710..0x82FC6728)
	// 82FC6710: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82FC6714: 41980028  blt cr6, 0x82fc673c
	if ctx.cr[6].lt {
	pc = 0x82FC673C; continue 'dispatch;
	}
	// 82FC6718: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 82FC671C: 7D6B29D6  mullw r11, r11, r5
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC6720: 7FABE850  subf r29, r11, r29
	ctx.r[29].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 82FC6724: 48000018  b 0x82fc673c
	pc = 0x82FC673C; continue 'dispatch;
            }
            0x82FC6728 => {
    //   block [0x82FC6728..0x82FC6730)
	// 82FC6728: 41980008  blt cr6, 0x82fc6730
	if ctx.cr[6].lt {
	pc = 0x82FC6730; continue 'dispatch;
	}
	// 82FC672C: 6BBD0001  xori r29, r29, 1
	ctx.r[29].u64 = ctx.r[29].u64 ^ 1;
	pc = 0x82FC6730; continue 'dispatch;
            }
            0x82FC6730 => {
    //   block [0x82FC6730..0x82FC673C)
	// 82FC6730: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82FC6734: 41980008  blt cr6, 0x82fc673c
	if ctx.cr[6].lt {
	pc = 0x82FC673C; continue 'dispatch;
	}
	// 82FC6738: 6BBD0001  xori r29, r29, 1
	ctx.r[29].u64 = ctx.r[29].u64 ^ 1;
	pc = 0x82FC673C; continue 'dispatch;
            }
            0x82FC673C => {
    //   block [0x82FC673C..0x82FC6748)
	// 82FC673C: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82FC6740: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82FC6744: 4082FF10  bne 0x82fc6654
	if !ctx.cr[0].eq {
	pc = 0x82FC6654; continue 'dispatch;
	}
	pc = 0x82FC6748; continue 'dispatch;
            }
            0x82FC6748 => {
    //   block [0x82FC6748..0x82FC6754)
	// 82FC6748: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82FC674C: 7F1FD040  cmplw cr6, r31, r26
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82FC6750: 4198FEC0  blt cr6, 0x82fc6610
	if ctx.cr[6].lt {
	pc = 0x82FC6610; continue 'dispatch;
	}
	pc = 0x82FC6754; continue 'dispatch;
            }
            0x82FC6754 => {
    //   block [0x82FC6754..0x82FC6764)
	// 82FC6754: 7FAB0034  cntlzw r11, r29
	ctx.r[11].u64 = if ctx.r[29].u32 == 0 { 32 } else { ctx.r[29].u32.leading_zeros() as u64 };
	// 82FC6758: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82FC675C: 69630001  xori r3, r11, 1
	ctx.r[3].u64 = ctx.r[11].u64 ^ 1;
	// 82FC6760: 4BCE2CEC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC6768 size=104
    let mut pc: u32 = 0x82FC6768;
    'dispatch: loop {
        match pc {
            0x82FC6768 => {
    //   block [0x82FC6768..0x82FC679C)
	// 82FC6768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC676C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC6770: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC6774: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC6778: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC677C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC6780: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC6784: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6788: 557ED1BE  srwi r30, r11, 6
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shr(6);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82FC678C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC6790: 4198000C  blt cr6, 0x82fc679c
	if ctx.cr[6].lt {
	pc = 0x82FC679C; continue 'dispatch;
	}
	// 82FC6794: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC6798: 4BFFFD19  bl 0x82fc64b0
	ctx.lr = 0x82FC679C;
	sub_82FC64B0(ctx, base);
	pc = 0x82FC679C; continue 'dispatch;
            }
            0x82FC679C => {
    //   block [0x82FC679C..0x82FC67D0)
	// 82FC679C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC67A0: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82FC67A4: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC67A8: 552906BE  clrlwi r9, r9, 0x1a
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000003Fu64;
	// 82FC67AC: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FC67B0: 1D490018  mulli r10, r9, 0x18
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * 24 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC67B4: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC67B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC67BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC67C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC67C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC67C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC67CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC67D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC67D0 size=192
    let mut pc: u32 = 0x82FC67D0;
    'dispatch: loop {
        match pc {
            0x82FC67D0 => {
    //   block [0x82FC67D0..0x82FC6850)
	// 82FC67D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC67D4: 4BCE2C39  bl 0x82ca940c
	ctx.lr = 0x82FC67D8;
	sub_82CA93D0(ctx, base);
	// 82FC67D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC67DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC67E0: 90C10064  stw r6, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[6].u32 ) };
	// 82FC67E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC67E8: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FC67EC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82FC67F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82FC67F4: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 82FC67F8: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 82FC67FC: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82FC6800: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC6804: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FC6808: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82FC680C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82FC6810: 4800C361  bl 0x82fd2b70
	ctx.lr = 0x82FC6814;
	sub_82FD2B70(ctx, base);
	// 82FC6814: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC6818: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82FC681C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FC6820: 5569E13A  rlwinm r9, r11, 0x1c, 4, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 82FC6824: 556B06BE  clrlwi r11, r11, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FC6828: 1D4B0018  mulli r10, r11, 0x18
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC682C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC6830: 7D69582E  lwzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FC6834: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC6838: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82FC683C: 41980024  blt cr6, 0x82fc6860
	if ctx.cr[6].lt {
	pc = 0x82FC6860; continue 'dispatch;
	}
	// 82FC6840: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82FC6844: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82FC6848: 40980008  bge cr6, 0x82fc6850
	if !ctx.cr[6].lt {
	pc = 0x82FC6850; continue 'dispatch;
	}
	// 82FC684C: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	pc = 0x82FC6850; continue 'dispatch;
            }
            0x82FC6850 => {
    //   block [0x82FC6850..0x82FC6860)
	// 82FC6850: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82FC6854: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82FC6858: 40990008  ble cr6, 0x82fc6860
	if !ctx.cr[6].gt {
	pc = 0x82FC6860; continue 'dispatch;
	}
	// 82FC685C: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	pc = 0x82FC6860; continue 'dispatch;
            }
            0x82FC6860 => {
    //   block [0x82FC6860..0x82FC6878)
	// 82FC6860: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82FC6864: 41980024  blt cr6, 0x82fc6888
	if ctx.cr[6].lt {
	pc = 0x82FC6888; continue 'dispatch;
	}
	// 82FC6868: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82FC686C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82FC6870: 40980008  bge cr6, 0x82fc6878
	if !ctx.cr[6].lt {
	pc = 0x82FC6878; continue 'dispatch;
	}
	// 82FC6874: 93BF0034  stw r29, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[29].u32 ) };
	pc = 0x82FC6878; continue 'dispatch;
            }
            0x82FC6878 => {
    //   block [0x82FC6878..0x82FC6888)
	// 82FC6878: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82FC687C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82FC6880: 40990008  ble cr6, 0x82fc6888
	if !ctx.cr[6].gt {
	pc = 0x82FC6888; continue 'dispatch;
	}
	// 82FC6884: 93BF0038  stw r29, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[29].u32 ) };
	pc = 0x82FC6888; continue 'dispatch;
            }
            0x82FC6888 => {
    //   block [0x82FC6888..0x82FC6890)
	// 82FC6888: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82FC688C: 4BCE2BD0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC6890 size=104
    let mut pc: u32 = 0x82FC6890;
    'dispatch: loop {
        match pc {
            0x82FC6890 => {
    //   block [0x82FC6890..0x82FC68F8)
	// 82FC6890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC6894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC6898: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC689C: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 82FC68A0: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82FC68A4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC68A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC68AC: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82FC68B0: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82FC68B4: 4BFFFF1D  bl 0x82fc67d0
	ctx.lr = 0x82FC68B8;
	sub_82FC67D0(ctx, base);
	// 82FC68B8: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FC68BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FC68C0: D3C10054  stfs f30, 0x54(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FC68C4: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82FC68C8: 4BF844B1  bl 0x82f4ad78
	ctx.lr = 0x82FC68CC;
	sub_82F4AD78(ctx, base);
	// 82FC68CC: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FC68D0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC68D4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FC68D8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC68DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC68E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC68E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC68E8: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82FC68EC: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC68F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC68F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC68F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC68F8 size=136
    let mut pc: u32 = 0x82FC68F8;
    'dispatch: loop {
        match pc {
            0x82FC68F8 => {
    //   block [0x82FC68F8..0x82FC696C)
	// 82FC68F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC68FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC6900: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC6904: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC6908: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC690C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FC6910: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC6914: 419A0058  beq cr6, 0x82fc696c
	if ctx.cr[6].eq {
	pc = 0x82FC696C; continue 'dispatch;
	}
	// 82FC6918: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC691C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82FC6920: 4099004C  ble cr6, 0x82fc696c
	if !ctx.cr[6].gt {
	pc = 0x82FC696C; continue 'dispatch;
	}
	// 82FC6924: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC6928: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FC692C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC6930: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82FC6934: 5569D1BA  rlwinm r9, r11, 0x1a, 6, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FC6938: 556B1D78  rlwinm r11, r11, 3, 0x15, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 82FC693C: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC6940: 7D49502E  lwzx r10, r9, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FC6944: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC6948: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC694C: C1AB0004  lfs f13, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC6950: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FC6954: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FC6958: 4BF84421  bl 0x82f4ad78
	ctx.lr = 0x82FC695C;
	sub_82F4AD78(ctx, base);
	// 82FC695C: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FC6960: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6964: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FC6968: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82FC696C; continue 'dispatch;
            }
            0x82FC696C => {
    //   block [0x82FC696C..0x82FC6980)
	// 82FC696C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC6970: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC6974: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC6978: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC697C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC6980 size=296
    let mut pc: u32 = 0x82FC6980;
    'dispatch: loop {
        match pc {
            0x82FC6980 => {
    //   block [0x82FC6980..0x82FC69D8)
	// 82FC6980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC6984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC6988: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC698C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC6990: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82FC6994: 4BCE7339  bl 0x82cadccc
	ctx.lr = 0x82FC6998;
	sub_82CADCA0(ctx, base);
	// 82FC6998: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC699C: FFC02890  fmr f30, f5
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[5].f64;
	// 82FC69A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC69A4: FFA03090  fmr f29, f6
	ctx.f[29].f64 = ctx.f[6].f64;
	// 82FC69A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC69AC: 3FC08204  lis r30, -0x7dfc
	ctx.r[30].s64 = -2113667072;
	// 82FC69B0: ED21182A  fadds f9, f1, f3
	ctx.f[9].f64 = ((ctx.f[1].f64 + ctx.f[3].f64) as f32) as f64;
	// 82FC69B4: ED02202A  fadds f8, f2, f4
	ctx.f[8].f64 = ((ctx.f[2].f64 + ctx.f[4].f64) as f32) as f64;
	// 82FC69B8: C3EB0BFC  lfs f31, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82FC69BC: EC1E0828  fsubs f0, f30, f1
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[1].f64) as f32) as f64);
	// 82FC69C0: ED84E828  fsubs f12, f4, f29
	ctx.f[12].f64 = (((ctx.f[4].f64 - ctx.f[29].f64) as f32) as f64);
	// 82FC69C4: EDBD1028  fsubs f13, f29, f2
	ctx.f[13].f64 = (((ctx.f[29].f64 - ctx.f[2].f64) as f32) as f64);
	// 82FC69C8: ED43F028  fsubs f10, f3, f30
	ctx.f[10].f64 = (((ctx.f[3].f64 - ctx.f[30].f64) as f32) as f64);
	// 82FC69CC: ECE3F02A  fadds f7, f3, f30
	ctx.f[7].f64 = ((ctx.f[3].f64 + ctx.f[30].f64) as f32) as f64;
	// 82FC69D0: ECC4E82A  fadds f6, f4, f29
	ctx.f[6].f64 = ((ctx.f[4].f64 + ctx.f[29].f64) as f32) as f64;
	// 82FC69D4: 48000068  b 0x82fc6a3c
	pc = 0x82FC6A3C; continue 'dispatch;
            }
            0x82FC69D8 => {
    //   block [0x82FC69D8..0x82FC6A3C)
	// 82FC69D8: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC69DC: C17F0004  lfs f11, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC69E0: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FC69E4: EC0D037A  fmadds f0, f13, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FC69E8: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82FC69EC: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82FC69F0: 40990074  ble cr6, 0x82fc6a64
	if !ctx.cr[6].gt {
	pc = 0x82FC6A64; continue 'dispatch;
	}
	// 82FC69F4: EC1C182A  fadds f0, f28, f3
	ctx.f[0].f64 = ((ctx.f[28].f64 + ctx.f[3].f64) as f32) as f64;
	// 82FC69F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC69FC: EDBB202A  fadds f13, f27, f4
	ctx.f[13].f64 = ((ctx.f[27].f64 + ctx.f[4].f64) as f32) as f64;
	// 82FC6A00: EF4007F2  fmuls f26, f0, f31
	ctx.f[26].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82FC6A04: EF2D07F2  fmuls f25, f13, f31
	ctx.f[25].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 82FC6A08: FCA0D090  fmr f5, f26
	ctx.f[5].f64 = ctx.f[26].f64;
	// 82FC6A0C: FCC0C890  fmr f6, f25
	ctx.f[6].f64 = ctx.f[25].f64;
	// 82FC6A10: 4BFFFF71  bl 0x82fc6980
	ctx.lr = 0x82FC6A14;
	sub_82FC6980(ctx, base);
	// 82FC6A14: ED9BE828  fsubs f12, f27, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[27].f64 - ctx.f[29].f64) as f32) as f64);
	// 82FC6A18: EC1ED028  fsubs f0, f30, f26
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[26].f64) as f32) as f64);
	// 82FC6A1C: ED5CF028  fsubs f10, f28, f30
	ctx.f[10].f64 = (((ctx.f[28].f64 - ctx.f[30].f64) as f32) as f64);
	// 82FC6A20: EDBDC828  fsubs f13, f29, f25
	ctx.f[13].f64 = (((ctx.f[29].f64 - ctx.f[25].f64) as f32) as f64);
	// 82FC6A24: ED3AE02A  fadds f9, f26, f28
	ctx.f[9].f64 = ((ctx.f[26].f64 + ctx.f[28].f64) as f32) as f64;
	// 82FC6A28: ED19D82A  fadds f8, f25, f27
	ctx.f[8].f64 = ((ctx.f[25].f64 + ctx.f[27].f64) as f32) as f64;
	// 82FC6A2C: ECFCF02A  fadds f7, f28, f30
	ctx.f[7].f64 = ((ctx.f[28].f64 + ctx.f[30].f64) as f32) as f64;
	// 82FC6A30: ECDBE82A  fadds f6, f27, f29
	ctx.f[6].f64 = ((ctx.f[27].f64 + ctx.f[29].f64) as f32) as f64;
	// 82FC6A34: FC40C890  fmr f2, f25
	ctx.f[2].f64 = ctx.f[25].f64;
	// 82FC6A38: FC20D090  fmr f1, f26
	ctx.f[1].f64 = ctx.f[26].f64;
	pc = 0x82FC6A3C; continue 'dispatch;
            }
            0x82FC6A3C => {
    //   block [0x82FC6A3C..0x82FC6A64)
	// 82FC6A3C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC6A40: C17E6978  lfs f11, 0x6978(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27000 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC6A44: EF6607F2  fmuls f27, f6, f31
	ctx.f[27].f64 = (((ctx.f[6].f64 * ctx.f[31].f64) as f32) as f64);
	// 82FC6A48: EF8707F2  fmuls f28, f7, f31
	ctx.f[28].f64 = (((ctx.f[7].f64 * ctx.f[31].f64) as f32) as f64);
	// 82FC6A4C: EC8807F2  fmuls f4, f8, f31
	ctx.f[4].f64 = (((ctx.f[8].f64 * ctx.f[31].f64) as f32) as f64);
	// 82FC6A50: EC6907F2  fmuls f3, f9, f31
	ctx.f[3].f64 = (((ctx.f[9].f64 * ctx.f[31].f64) as f32) as f64);
	// 82FC6A54: ED8A6378  fmsubs f12, f10, f13, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FC6A58: FD806210  fabs f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 82FC6A5C: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 82FC6A60: 4199FF78  bgt cr6, 0x82fc69d8
	if ctx.cr[6].gt {
	pc = 0x82FC69D8; continue 'dispatch;
	}
	pc = 0x82FC6A64; continue 'dispatch;
            }
            0x82FC6A64 => {
    //   block [0x82FC6A64..0x82FC6AA8)
	// 82FC6A64: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FC6A68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FC6A6C: D3A10054  stfs f29, 0x54(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FC6A70: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82FC6A74: 4BF84305  bl 0x82f4ad78
	ctx.lr = 0x82FC6A78;
	sub_82F4AD78(ctx, base);
	// 82FC6A78: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FC6A7C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6A80: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FC6A84: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC6A88: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82FC6A8C: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82FC6A90: 4BCE7289  bl 0x82cadd18
	ctx.lr = 0x82FC6A94;
	sub_82CADCEC(ctx, base);
	// 82FC6A94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC6A98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC6A9C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC6AA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC6AA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC6AA8 size=208
    let mut pc: u32 = 0x82FC6AA8;
    'dispatch: loop {
        match pc {
            0x82FC6AA8 => {
    //   block [0x82FC6AA8..0x82FC6B20)
	// 82FC6AA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC6AAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC6AB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC6AB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC6AB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC6ABC: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82FC6AC0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC6AC4: FDA01090  fmr f13, f2
	ctx.f[13].f64 = ctx.f[2].f64;
	// 82FC6AC8: FCC02090  fmr f6, f4
	ctx.f[6].f64 = ctx.f[4].f64;
	// 82FC6ACC: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82FC6AD0: FCA01890  fmr f5, f3
	ctx.f[5].f64 = ctx.f[3].f64;
	// 82FC6AD4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC6AD8: 813F0014  lwz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC6ADC: C16A0C18  lfs f11, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC6AE0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FC6AE4: 5568D1BA  rlwinm r8, r11, 0x1a, 6, 0x1d
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 82FC6AE8: 556B1D78  rlwinm r11, r11, 3, 0x15, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 82FC6AEC: ED866828  fsubs f12, f6, f13
	ctx.f[12].f64 = (((ctx.f[6].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FC6AF0: ED450028  fsubs f10, f5, f0
	ctx.f[10].f64 = (((ctx.f[5].f64 - ctx.f[0].f64) as f32) as f64);
	// 82FC6AF4: 7D48482E  lwzx r10, r8, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FC6AF8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC6AFC: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82FC6B00: ED200828  fsubs f9, f0, f1
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[1].f64) as f32) as f64);
	// 82FC6B04: C04B0004  lfs f2, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82FC6B08: ED0D1028  fsubs f8, f13, f2
	ctx.f[8].f64 = (((ctx.f[13].f64 - ctx.f[2].f64) as f32) as f64);
	// 82FC6B0C: ED890332  fmuls f12, f9, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FC6B10: ED8862B8  fmsubs f12, f8, f10, f12
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FC6B14: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 82FC6B18: 40980008  bge cr6, 0x82fc6b20
	if !ctx.cr[6].lt {
	pc = 0x82FC6B20; continue 'dispatch;
	}
	// 82FC6B1C: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x82FC6B20; continue 'dispatch;
            }
            0x82FC6B20 => {
    //   block [0x82FC6B20..0x82FC6B54)
	// 82FC6B20: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FC6B24: C16B6978  lfs f11, 0x6978(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27000 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC6B28: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 82FC6B2C: 40980028  bge cr6, 0x82fc6b54
	if !ctx.cr[6].lt {
	pc = 0x82FC6B54; continue 'dispatch;
	}
	// 82FC6B30: D0A10050  stfs f5, 0x50(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FC6B34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FC6B38: D0C10054  stfs f6, 0x54(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FC6B3C: 4BF8423D  bl 0x82f4ad78
	ctx.lr = 0x82FC6B40;
	sub_82F4AD78(ctx, base);
	// 82FC6B40: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FC6B44: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6B48: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FC6B4C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC6B50: 48000014  b 0x82fc6b64
	pc = 0x82FC6B64; continue 'dispatch;
            }
            0x82FC6B54 => {
    //   block [0x82FC6B54..0x82FC6B64)
	// 82FC6B54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC6B58: FC806890  fmr f4, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[4].f64 = ctx.f[13].f64;
	// 82FC6B5C: FC600090  fmr f3, f0
	ctx.f[3].f64 = ctx.f[0].f64;
	// 82FC6B60: 4BFFFE21  bl 0x82fc6980
	ctx.lr = 0x82FC6B64;
	sub_82FC6980(ctx, base);
	pc = 0x82FC6B64; continue 'dispatch;
            }
            0x82FC6B64 => {
    //   block [0x82FC6B64..0x82FC6B78)
	// 82FC6B64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC6B68: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC6B6C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC6B70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC6B74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6B78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FC6B78 size=20
    let mut pc: u32 = 0x82FC6B78;
    'dispatch: loop {
        match pc {
            0x82FC6B78 => {
    //   block [0x82FC6B78..0x82FC6B8C)
	// 82FC6B78: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC6B7C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC6B80: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC6B84: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC6B88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6B90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FC6B90 size=12
    let mut pc: u32 = 0x82FC6B90;
    'dispatch: loop {
        match pc {
            0x82FC6B90 => {
    //   block [0x82FC6B90..0x82FC6B9C)
	// 82FC6B90: D0240000  stfs f1, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC6B94: D0440004  stfs f2, 4(r4)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82FC6B98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FC6BA0 size=20
    let mut pc: u32 = 0x82FC6BA0;
    'dispatch: loop {
        match pc {
            0x82FC6BA0 => {
    //   block [0x82FC6BA0..0x82FC6BB4)
	// 82FC6BA0: C0040000  lfs f0, 0(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC6BA4: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC6BA8: C0040004  lfs f0, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC6BAC: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC6BB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC6BB8 size=40
    let mut pc: u32 = 0x82FC6BB8;
    'dispatch: loop {
        match pc {
            0x82FC6BB8 => {
    //   block [0x82FC6BB8..0x82FC6BE0)
	// 82FC6BB8: FC00101E  fctiwz f0, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[2].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[2].f64.trunc() as i32 as i64 };
	// 82FC6BBC: D801FFF0  stfd f0, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[0].u64 ) };
	// 82FC6BC0: A161FFF6  lhz r11, -0xa(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(-10 as u32) ) } as u64;
	// 82FC6BC4: FDA0081E  fctiwz f13, f1
	ctx.f[13].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82FC6BC8: D9A1FFF0  stfd f13, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[13].u64 ) };
	// 82FC6BCC: A141FFF6  lhz r10, -0xa(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(-10 as u32) ) } as u64;
	// 82FC6BD0: B1640002  sth r11, 2(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(2 as u32), ctx.r[11].u16 ) };
	// 82FC6BD4: B1440000  sth r10, 0(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 82FC6BD8: 90E40004  stw r7, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82FC6BDC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC6BE0 size=8
    let mut pc: u32 = 0x82FC6BE0;
    'dispatch: loop {
        match pc {
            0x82FC6BE0 => {
    //   block [0x82FC6BE0..0x82FC6BE8)
	// 82FC6BE0: 90A40004  stw r5, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82FC6BE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6BE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC6BE8 size=8
    let mut pc: u32 = 0x82FC6BE8;
    'dispatch: loop {
        match pc {
            0x82FC6BE8 => {
    //   block [0x82FC6BE8..0x82FC6BF0)
	// 82FC6BE8: 80640004  lwz r3, 4(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6BEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC6BF0 size=48
    let mut pc: u32 = 0x82FC6BF0;
    'dispatch: loop {
        match pc {
            0x82FC6BF0 => {
    //   block [0x82FC6BF0..0x82FC6C20)
	// 82FC6BF0: FC00101E  fctiwz f0, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[2].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[2].f64.trunc() as i32 as i64 };
	// 82FC6BF4: D801FFF0  stfd f0, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[0].u64 ) };
	// 82FC6BF8: A161FFF6  lhz r11, -0xa(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(-10 as u32) ) } as u64;
	// 82FC6BFC: FDA0081E  fctiwz f13, f1
	ctx.f[13].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82FC6C00: D9A1FFF0  stfd f13, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[13].u64 ) };
	// 82FC6C04: A121FFF6  lhz r9, -0xa(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(-10 as u32) ) } as u64;
	// 82FC6C08: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82FC6C0C: B1640002  sth r11, 2(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(2 as u32), ctx.r[11].u16 ) };
	// 82FC6C10: B1240000  sth r9, 0(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 82FC6C14: 90E40004  stw r7, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82FC6C18: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82FC6C1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC6C20 size=36
    let mut pc: u32 = 0x82FC6C20;
    'dispatch: loop {
        match pc {
            0x82FC6C20 => {
    //   block [0x82FC6C20..0x82FC6C44)
	// 82FC6C20: FC00101E  fctiwz f0, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[2].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[2].f64.trunc() as i32 as i64 };
	// 82FC6C24: D801FFF0  stfd f0, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[0].u64 ) };
	// 82FC6C28: A161FFF6  lhz r11, -0xa(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(-10 as u32) ) } as u64;
	// 82FC6C2C: FDA0081E  fctiwz f13, f1
	ctx.f[13].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82FC6C30: D9A1FFF0  stfd f13, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[13].u64 ) };
	// 82FC6C34: A141FFF6  lhz r10, -0xa(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(-10 as u32) ) } as u64;
	// 82FC6C38: B1640002  sth r11, 2(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(2 as u32), ctx.r[11].u16 ) };
	// 82FC6C3C: B1440000  sth r10, 0(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 82FC6C40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FC6C48 size=52
    let mut pc: u32 = 0x82FC6C48;
    'dispatch: loop {
        match pc {
            0x82FC6C48 => {
    //   block [0x82FC6C48..0x82FC6C7C)
	// 82FC6C48: A9640000  lha r11, 0(r4)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 82FC6C4C: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82FC6C50: C801FFF0  lfd f0, -0x10(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC6C54: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC6C58: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC6C5C: D0050000  stfs f0, 0(r5)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC6C60: A9640002  lha r11, 2(r4)
	ctx.r[11].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(2 as u32) ) } as i16) as i64;
	// 82FC6C64: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82FC6C68: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC6C6C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC6C70: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC6C74: D0060000  stfs f0, 0(r6)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FC6C78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC6C80 size=8
    let mut pc: u32 = 0x82FC6C80;
    'dispatch: loop {
        match pc {
            0x82FC6C80 => {
    //   block [0x82FC6C80..0x82FC6C88)
	// 82FC6C80: 90A40008  stw r5, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82FC6C84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC6C88 size=8
    let mut pc: u32 = 0x82FC6C88;
    'dispatch: loop {
        match pc {
            0x82FC6C88 => {
    //   block [0x82FC6C88..0x82FC6C90)
	// 82FC6C88: 80640008  lwz r3, 8(r4)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC6C8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6C90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC6C90 size=68
    let mut pc: u32 = 0x82FC6C90;
    'dispatch: loop {
        match pc {
            0x82FC6C90 => {
    //   block [0x82FC6C90..0x82FC6CBC)
	// 82FC6C90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC6C94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC6C98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC6C9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC6CA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC6CA4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FC6CA8: 548A07FF  clrlwi. r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC6CAC: 396B697C  addi r11, r11, 0x697c
	ctx.r[11].s64 = ctx.r[11].s64 + 27004;
	// 82FC6CB0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC6CB4: 41820008  beq 0x82fc6cbc
	if ctx.cr[0].eq {
	pc = 0x82FC6CBC; continue 'dispatch;
	}
	// 82FC6CB8: 4B87EAF9  bl 0x828457b0
	ctx.lr = 0x82FC6CBC;
	sub_828457B0(ctx, base);
	pc = 0x82FC6CBC; continue 'dispatch;
            }
            0x82FC6CBC => {
    //   block [0x82FC6CBC..0x82FC6CD4)
	// 82FC6CBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC6CC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FC6CC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC6CC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC6CCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC6CD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC6CD8 size=192
    let mut pc: u32 = 0x82FC6CD8;
    'dispatch: loop {
        match pc {
            0x82FC6CD8 => {
    //   block [0x82FC6CD8..0x82FC6D28)
	// 82FC6CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC6CDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC6CE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC6CE4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC6CE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC6CEC: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC6CF0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC6CF4: 40820090  bne 0x82fc6d84
	if !ctx.cr[0].eq {
	pc = 0x82FC6D84; continue 'dispatch;
	}
	// 82FC6CF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FC6CFC: 2F040002  cmpwi cr6, r4, 2
	ctx.cr[6].compare_i32(ctx.r[4].s32, 2, &mut ctx.xer);
	// 82FC6D00: 997F0018  stb r11, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 82FC6D04: 409A0024  bne cr6, 0x82fc6d28
	if !ctx.cr[6].eq {
	pc = 0x82FC6D28; continue 'dispatch;
	}
	// 82FC6D08: 4BF36B01  bl 0x82efd808
	ctx.lr = 0x82FC6D0C;
	sub_82EFD808(ctx, base);
	// 82FC6D0C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC6D10: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC6D14: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6D18: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6D1C: 7C8B51D6  mullw r4, r11, r10
	ctx.r[4].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82FC6D20: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6D24: 48000020  b 0x82fc6d44
	pc = 0x82FC6D44; continue 'dispatch;
            }
            0x82FC6D28 => {
    //   block [0x82FC6D28..0x82FC6D44)
	// 82FC6D28: 4BF36AE1  bl 0x82efd808
	ctx.lr = 0x82FC6D2C;
	sub_82EFD808(ctx, base);
	// 82FC6D2C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC6D30: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC6D34: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6D38: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6D3C: 7C8B51D6  mullw r4, r11, r10
	ctx.r[4].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82FC6D40: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82FC6D44; continue 'dispatch;
            }
            0x82FC6D44 => {
    //   block [0x82FC6D44..0x82FC6D84)
	// 82FC6D44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC6D48: 4E800421  bctrl
	ctx.lr = 0x82FC6D4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC6D4C: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC6D50: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82FC6D54: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FC6D58: 419A002C  beq cr6, 0x82fc6d84
	if ctx.cr[6].eq {
	pc = 0x82FC6D84; continue 'dispatch;
	}
	// 82FC6D5C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC6D60: 5463003E  slwi r3, r3, 0
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82FC6D64: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6D68: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6D6C: 7CAB51D6  mullw r5, r11, r10
	ctx.r[5].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82FC6D70: 4BCE2711  bl 0x82ca9480
	ctx.lr = 0x82FC6D74;
	sub_82CA9480(ctx, base);
	// 82FC6D74: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC6D78: 4BF36B29  bl 0x82efd8a0
	ctx.lr = 0x82FC6D7C;
	sub_82EFD8A0(ctx, base);
	// 82FC6D7C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC6D80: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
            }
            0x82FC6D84 => {
    //   block [0x82FC6D84..0x82FC6D98)
	// 82FC6D84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FC6D88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC6D8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC6D90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC6D94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC6D98 size=100
    let mut pc: u32 = 0x82FC6D98;
    'dispatch: loop {
        match pc {
            0x82FC6D98 => {
    //   block [0x82FC6D98..0x82FC6DC4)
	// 82FC6D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC6D9C: 4BCE2671  bl 0x82ca940c
	ctx.lr = 0x82FC6DA0;
	sub_82CA93D0(ctx, base);
	// 82FC6DA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC6DA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC6DA8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC6DAC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FC6DB0: 897F0018  lbz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC6DB4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC6DB8: 4082000C  bne 0x82fc6dc4
	if !ctx.cr[0].eq {
	pc = 0x82FC6DC4; continue 'dispatch;
	}
	// 82FC6DBC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82FC6DC0: 4BFFFF19  bl 0x82fc6cd8
	ctx.lr = 0x82FC6DC4;
	sub_82FC6CD8(ctx, base);
	pc = 0x82FC6DC4; continue 'dispatch;
            }
            0x82FC6DC4 => {
    //   block [0x82FC6DC4..0x82FC6DFC)
	// 82FC6DC4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC6DC8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82FC6DCC: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC6DD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC6DD4: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6DD8: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC6DDC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC6DE0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC6DE4: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC6DE8: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FC6DEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC6DF0: 4E800421  bctrl
	ctx.lr = 0x82FC6DF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC6DF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC6DF8: 4BCE2664  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC6E00 size=32
    let mut pc: u32 = 0x82FC6E00;
    'dispatch: loop {
        match pc {
            0x82FC6E00 => {
    //   block [0x82FC6E00..0x82FC6E20)
	// 82FC6E00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC6E04: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82FC6E08: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82FC6E0C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82FC6E10: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82FC6E14: 99630004  stb r11, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82FC6E18: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC6E1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC6E20 size=168
    let mut pc: u32 = 0x82FC6E20;
    'dispatch: loop {
        match pc {
            0x82FC6E20 => {
    //   block [0x82FC6E20..0x82FC6E68)
	// 82FC6E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC6E24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC6E28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC6E2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC6E30: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC6E34: 897F0004  lbz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6E38: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC6E3C: 40820078  bne 0x82fc6eb4
	if !ctx.cr[0].eq {
	pc = 0x82FC6EB4; continue 'dispatch;
	}
	// 82FC6E40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FC6E44: 2F040002  cmpwi cr6, r4, 2
	ctx.cr[6].compare_i32(ctx.r[4].s32, 2, &mut ctx.xer);
	// 82FC6E48: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82FC6E4C: 409A001C  bne cr6, 0x82fc6e68
	if !ctx.cr[6].eq {
	pc = 0x82FC6E68; continue 'dispatch;
	}
	// 82FC6E50: 4BF369B9  bl 0x82efd808
	ctx.lr = 0x82FC6E54;
	sub_82EFD808(ctx, base);
	// 82FC6E54: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC6E58: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82FC6E5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC6E60: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6E64: 48000018  b 0x82fc6e7c
	pc = 0x82FC6E7C; continue 'dispatch;
            }
            0x82FC6E68 => {
    //   block [0x82FC6E68..0x82FC6E7C)
	// 82FC6E68: 4BF369A1  bl 0x82efd808
	ctx.lr = 0x82FC6E6C;
	sub_82EFD808(ctx, base);
	// 82FC6E6C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC6E70: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 82FC6E74: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC6E78: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	pc = 0x82FC6E7C; continue 'dispatch;
            }
            0x82FC6E7C => {
    //   block [0x82FC6E7C..0x82FC6EB4)
	// 82FC6E7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC6E80: 4E800421  bctrl
	ctx.lr = 0x82FC6E84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC6E84: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC6E88: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82FC6E8C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FC6E90: 419A0024  beq cr6, 0x82fc6eb4
	if ctx.cr[6].eq {
	pc = 0x82FC6EB4; continue 'dispatch;
	}
	// 82FC6E94: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC6E98: 5463003E  slwi r3, r3, 0
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82FC6E9C: 5565083C  slwi r5, r11, 1
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82FC6EA0: 4BCE25E1  bl 0x82ca9480
	ctx.lr = 0x82FC6EA4;
	sub_82CA9480(ctx, base);
	// 82FC6EA4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC6EA8: 4BF369F9  bl 0x82efd8a0
	ctx.lr = 0x82FC6EAC;
	sub_82EFD8A0(ctx, base);
	// 82FC6EAC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC6EB0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
            }
            0x82FC6EB4 => {
    //   block [0x82FC6EB4..0x82FC6EC8)
	// 82FC6EB4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FC6EB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC6EBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC6EC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC6EC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC6EC8 size=8
    let mut pc: u32 = 0x82FC6EC8;
    'dispatch: loop {
        match pc {
            0x82FC6EC8 => {
    //   block [0x82FC6EC8..0x82FC6ED0)
	// 82FC6EC8: 80630010  lwz r3, 0x10(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC6ECC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC6ED0 size=96
    let mut pc: u32 = 0x82FC6ED0;
    'dispatch: loop {
        match pc {
            0x82FC6ED0 => {
    //   block [0x82FC6ED0..0x82FC6EFC)
	// 82FC6ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC6ED4: 4BCE2539  bl 0x82ca940c
	ctx.lr = 0x82FC6ED8;
	sub_82CA93D0(ctx, base);
	// 82FC6ED8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC6EDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC6EE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC6EE4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FC6EE8: 897F0004  lbz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6EEC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC6EF0: 4082000C  bne 0x82fc6efc
	if !ctx.cr[0].eq {
	pc = 0x82FC6EFC; continue 'dispatch;
	}
	// 82FC6EF4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82FC6EF8: 4BFFFF29  bl 0x82fc6e20
	ctx.lr = 0x82FC6EFC;
	sub_82FC6E20(ctx, base);
	pc = 0x82FC6EFC; continue 'dispatch;
            }
            0x82FC6EFC => {
    //   block [0x82FC6EFC..0x82FC6F30)
	// 82FC6EFC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC6F00: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82FC6F04: 80BF0010  lwz r5, 0x10(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC6F08: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82FC6F0C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC6F10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC6F14: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82FC6F18: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC6F1C: 816B0034  lwz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 82FC6F20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC6F24: 4E800421  bctrl
	ctx.lr = 0x82FC6F28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC6F28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC6F2C: 4BCE2530  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC6F30 size=16
    let mut pc: u32 = 0x82FC6F30;
    'dispatch: loop {
        match pc {
            0x82FC6F30 => {
    //   block [0x82FC6F30..0x82FC6F40)
	// 82FC6F30: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC6F34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC6F38: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82FC6F3C: 4BF36964  b 0x82efd8a0
	sub_82EFD8A0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC6F48 size=160
    let mut pc: u32 = 0x82FC6F48;
    'dispatch: loop {
        match pc {
            0x82FC6F48 => {
    //   block [0x82FC6F48..0x82FC6FD4)
	// 82FC6F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC6F4C: 4BCE24C1  bl 0x82ca940c
	ctx.lr = 0x82FC6F50;
	sub_82CA93D0(ctx, base);
	// 82FC6F50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC6F54: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC6F58: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC6F5C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6F60: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC6F64: 419A007C  beq cr6, 0x82fc6fe0
	if ctx.cr[6].eq {
	pc = 0x82FC6FE0; continue 'dispatch;
	}
	// 82FC6F68: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC6F6C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC6F70: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC6F74: 419A006C  beq cr6, 0x82fc6fe0
	if ctx.cr[6].eq {
	pc = 0x82FC6FE0; continue 'dispatch;
	}
	// 82FC6F78: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC6F7C: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82FC6F80: 4099005C  ble cr6, 0x82fc6fdc
	if !ctx.cr[6].gt {
	pc = 0x82FC6FDC; continue 'dispatch;
	}
	// 82FC6F84: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC6F88: 40990054  ble cr6, 0x82fc6fdc
	if !ctx.cr[6].gt {
	pc = 0x82FC6FDC; continue 'dispatch;
	}
	// 82FC6F8C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6F90: 7C6BF1D6  mullw r3, r11, r30
	ctx.r[3].s32 = ((ctx.r[11].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82FC6F94: 4BF368CD  bl 0x82efd860
	ctx.lr = 0x82FC6F98;
	sub_82EFD860(ctx, base);
	// 82FC6F98: 7C7D1B79  or. r29, r3, r3
	ctx.r[29].u64 = ctx.r[3].u64 | ctx.r[3].u64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82FC6F9C: 41820044  beq 0x82fc6fe0
	if ctx.cr[0].eq {
	pc = 0x82FC6FE0; continue 'dispatch;
	}
	// 82FC6FA0: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC6FA4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FC6FA8: 419A002C  beq cr6, 0x82fc6fd4
	if ctx.cr[6].eq {
	pc = 0x82FC6FD4; continue 'dispatch;
	}
	// 82FC6FAC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC6FB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC6FB4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6FB8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC6FBC: 7CAB51D6  mullw r5, r11, r10
	ctx.r[5].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82FC6FC0: 4BCE24C1  bl 0x82ca9480
	ctx.lr = 0x82FC6FC4;
	sub_82CA9480(ctx, base);
	// 82FC6FC4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC6FC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC6FCC: 419A0008  beq cr6, 0x82fc6fd4
	if ctx.cr[6].eq {
	pc = 0x82FC6FD4; continue 'dispatch;
	}
	// 82FC6FD0: 4BF368D1  bl 0x82efd8a0
	ctx.lr = 0x82FC6FD4;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC6FD4; continue 'dispatch;
            }
            0x82FC6FD4 => {
    //   block [0x82FC6FD4..0x82FC6FDC)
	// 82FC6FD4: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82FC6FD8: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	pc = 0x82FC6FDC; continue 'dispatch;
            }
            0x82FC6FDC => {
    //   block [0x82FC6FDC..0x82FC6FE0)
	// 82FC6FDC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	pc = 0x82FC6FE0; continue 'dispatch;
            }
            0x82FC6FE0 => {
    //   block [0x82FC6FE0..0x82FC6FE8)
	// 82FC6FE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC6FE4: 4BCE2478  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC6FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC6FE8 size=196
    let mut pc: u32 = 0x82FC6FE8;
    'dispatch: loop {
        match pc {
            0x82FC6FE8 => {
    //   block [0x82FC6FE8..0x82FC7028)
	// 82FC6FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC6FEC: 4BCE2421  bl 0x82ca940c
	ctx.lr = 0x82FC6FF0;
	sub_82CA93D0(ctx, base);
	// 82FC6FF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC6FF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC6FF8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC6FFC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC7000: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC7004: 419A00A0  beq cr6, 0x82fc70a4
	if ctx.cr[6].eq {
	pc = 0x82FC70A4; continue 'dispatch;
	}
	// 82FC7008: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC700C: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7010: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC7014: 419A0090  beq cr6, 0x82fc70a4
	if ctx.cr[6].eq {
	pc = 0x82FC70A4; continue 'dispatch;
	}
	// 82FC7018: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC701C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC7020: 40980008  bge cr6, 0x82fc7028
	if !ctx.cr[6].lt {
	pc = 0x82FC7028; continue 'dispatch;
	}
	// 82FC7024: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	pc = 0x82FC7028; continue 'dispatch;
            }
            0x82FC7028 => {
    //   block [0x82FC7028..0x82FC7040)
	// 82FC7028: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC702C: 41990014  bgt cr6, 0x82fc7040
	if ctx.cr[6].gt {
	pc = 0x82FC7040; continue 'dispatch;
	}
	// 82FC7030: 54AB063F  clrlwi. r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC7034: 41820070  beq 0x82fc70a4
	if ctx.cr[0].eq {
	pc = 0x82FC70A4; continue 'dispatch;
	}
	// 82FC7038: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82FC703C: 419A0068  beq cr6, 0x82fc70a4
	if ctx.cr[6].eq {
	pc = 0x82FC70A4; continue 'dispatch;
	}
	pc = 0x82FC7040; continue 'dispatch;
            }
            0x82FC7040 => {
    //   block [0x82FC7040..0x82FC705C)
	// 82FC7040: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82FC7044: 419A0018  beq cr6, 0x82fc705c
	if ctx.cr[6].eq {
	pc = 0x82FC705C; continue 'dispatch;
	}
	// 82FC7048: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC704C: 7C6BF1D6  mullw r3, r11, r30
	ctx.r[3].s32 = ((ctx.r[11].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82FC7050: 4BF36811  bl 0x82efd860
	ctx.lr = 0x82FC7054;
	sub_82EFD860(ctx, base);
	// 82FC7054: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82FC7058: 48000008  b 0x82fc7060
	pc = 0x82FC7060; continue 'dispatch;
            }
            0x82FC705C => {
    //   block [0x82FC705C..0x82FC7060)
	// 82FC705C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82FC7060; continue 'dispatch;
            }
            0x82FC7060 => {
    //   block [0x82FC7060..0x82FC709C)
	// 82FC7060: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82FC7064: 419A0040  beq cr6, 0x82fc70a4
	if ctx.cr[6].eq {
	pc = 0x82FC70A4; continue 'dispatch;
	}
	// 82FC7068: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC706C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FC7070: 419A002C  beq cr6, 0x82fc709c
	if ctx.cr[6].eq {
	pc = 0x82FC709C; continue 'dispatch;
	}
	// 82FC7074: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC7078: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC707C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7080: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7084: 7CAB51D6  mullw r5, r11, r10
	ctx.r[5].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82FC7088: 4BCE23F9  bl 0x82ca9480
	ctx.lr = 0x82FC708C;
	sub_82CA9480(ctx, base);
	// 82FC708C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC7090: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC7094: 419A0008  beq cr6, 0x82fc709c
	if ctx.cr[6].eq {
	pc = 0x82FC709C; continue 'dispatch;
	}
	// 82FC7098: 4BF36809  bl 0x82efd8a0
	ctx.lr = 0x82FC709C;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC709C; continue 'dispatch;
            }
            0x82FC709C => {
    //   block [0x82FC709C..0x82FC70A4)
	// 82FC709C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82FC70A0: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	pc = 0x82FC70A4; continue 'dispatch;
            }
            0x82FC70A4 => {
    //   block [0x82FC70A4..0x82FC70AC)
	// 82FC70A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC70A8: 4BCE23B4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC70B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC70B0 size=72
    let mut pc: u32 = 0x82FC70B0;
    'dispatch: loop {
        match pc {
            0x82FC70B0 => {
    //   block [0x82FC70B0..0x82FC70D4)
	// 82FC70B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC70B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC70B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC70BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC70C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC70C4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC70C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC70CC: 419A0008  beq cr6, 0x82fc70d4
	if ctx.cr[6].eq {
	pc = 0x82FC70D4; continue 'dispatch;
	}
	// 82FC70D0: 4BF367D1  bl 0x82efd8a0
	ctx.lr = 0x82FC70D4;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC70D4; continue 'dispatch;
            }
            0x82FC70D4 => {
    //   block [0x82FC70D4..0x82FC70F8)
	// 82FC70D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC70D8: 997F0018  stb r11, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 82FC70DC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC70E0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC70E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FC70E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC70EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC70F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC70F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC70F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC70F8 size=216
    let mut pc: u32 = 0x82FC70F8;
    'dispatch: loop {
        match pc {
            0x82FC70F8 => {
    //   block [0x82FC70F8..0x82FC7134)
	// 82FC70F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC70FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC7100: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC7104: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC7108: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC710C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82FC7110: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC7114: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC7118: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC711C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC7120: 41990014  bgt cr6, 0x82fc7134
	if ctx.cr[6].gt {
	pc = 0x82FC7134; continue 'dispatch;
	}
	// 82FC7124: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82FC7128: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 82FC712C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC7130: 4BFFFEB9  bl 0x82fc6fe8
	ctx.lr = 0x82FC7134;
	sub_82FC6FE8(ctx, base);
	pc = 0x82FC7134; continue 'dispatch;
            }
            0x82FC7134 => {
    //   block [0x82FC7134..0x82FC7170)
	// 82FC7134: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7138: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC713C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC7140: 40990030  ble cr6, 0x82fc7170
	if !ctx.cr[6].gt {
	pc = 0x82FC7170; continue 'dispatch;
	}
	// 82FC7144: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC7148: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FC714C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC7150: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC7154: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FC7158: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC715C: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7160: 911E0004  stw r8, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82FC7164: 7D6959D6  mullw r11, r9, r11
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC7168: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC716C: 48000044  b 0x82fc71b0
	pc = 0x82FC71B0; continue 'dispatch;
            }
            0x82FC7170 => {
    //   block [0x82FC7170..0x82FC71A8)
	// 82FC7170: 3D408336  lis r10, -0x7cca
	ctx.r[10].s64 = -2093613056;
	// 82FC7174: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82FC7178: 3BEB96C8  addi r31, r11, -0x6938
	ctx.r[31].s64 = ctx.r[11].s64 + -26936;
	// 82FC717C: 816A96CC  lwz r11, -0x6934(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-26932 as u32) ) } as u64;
	// 82FC7180: 556907FF  clrlwi. r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC7184: 40820024  bne 0x82fc71a8
	if !ctx.cr[0].eq {
	pc = 0x82FC71A8; continue 'dispatch;
	}
	// 82FC7188: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82FC718C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82FC7190: 3929697C  addi r9, r9, 0x697c
	ctx.r[9].s64 = ctx.r[9].s64 + 27004;
	// 82FC7194: 916A96CC  stw r11, -0x6934(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-26932 as u32), ctx.r[11].u32 ) };
	// 82FC7198: 3D60832C  lis r11, -0x7cd4
	ctx.r[11].s64 = -2094268416;
	// 82FC719C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82FC71A0: 386B92E0  addi r3, r11, -0x6d20
	ctx.r[3].s64 = ctx.r[11].s64 + -27936;
	// 82FC71A4: 4BCE2D7D  bl 0x82ca9f20
	ctx.lr = 0x82FC71A8;
	sub_82CA9F20(ctx, base);
	pc = 0x82FC71A8; continue 'dispatch;
            }
            0x82FC71A8 => {
    //   block [0x82FC71A8..0x82FC71B0)
	// 82FC71A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC71AC: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82FC71B0; continue 'dispatch;
            }
            0x82FC71B0 => {
    //   block [0x82FC71B0..0x82FC71D0)
	// 82FC71B0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC71B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC71B8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC71BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC71C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC71C4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC71C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC71CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC71D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC71D0 size=180
    let mut pc: u32 = 0x82FC71D0;
    'dispatch: loop {
        match pc {
            0x82FC71D0 => {
    //   block [0x82FC71D0..0x82FC726C)
	// 82FC71D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC71D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC71D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC71DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC71E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC71E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC71E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC71EC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC71F0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC71F4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC71F8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC71FC: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82FC7200: 409A006C  bne cr6, 0x82fc726c
	if !ctx.cr[6].eq {
	pc = 0x82FC726C; continue 'dispatch;
	}
	// 82FC7204: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC7208: 419A0064  beq cr6, 0x82fc726c
	if ctx.cr[6].eq {
	pc = 0x82FC726C; continue 'dispatch;
	}
	// 82FC720C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7210: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82FC7214: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7218: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC721C: 4BFFFDCD  bl 0x82fc6fe8
	ctx.lr = 0x82FC7220;
	sub_82FC6FE8(ctx, base);
	// 82FC7220: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7224: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7228: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC722C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC7230: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC7234: 41980038  blt cr6, 0x82fc726c
	if ctx.cr[6].lt {
	pc = 0x82FC726C; continue 'dispatch;
	}
	// 82FC7238: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC723C: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC7240: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FC7244: 419A0028  beq cr6, 0x82fc726c
	if ctx.cr[6].eq {
	pc = 0x82FC726C; continue 'dispatch;
	}
	// 82FC7248: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC724C: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7250: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC7254: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82FC7258: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC725C: 7D6B49D6  mullw r11, r11, r9
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC7260: 7CA849D6  mullw r5, r8, r9
	ctx.r[5].s32 = ((ctx.r[8].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82FC7264: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC7268: 4BCE2219  bl 0x82ca9480
	ctx.lr = 0x82FC726C;
	sub_82CA9480(ctx, base);
	pc = 0x82FC726C; continue 'dispatch;
            }
            0x82FC726C => {
    //   block [0x82FC726C..0x82FC7284)
	// 82FC726C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC7270: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC7274: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC7278: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC727C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC7280: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC7288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC7288 size=76
    let mut pc: u32 = 0x82FC7288;
    'dispatch: loop {
        match pc {
            0x82FC7288 => {
    //   block [0x82FC7288..0x82FC72AC)
	// 82FC7288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC728C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC7290: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC7294: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC7298: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC729C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC72A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC72A4: 419A0008  beq cr6, 0x82fc72ac
	if ctx.cr[6].eq {
	pc = 0x82FC72AC; continue 'dispatch;
	}
	// 82FC72A8: 4BF365F9  bl 0x82efd8a0
	ctx.lr = 0x82FC72AC;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC72AC; continue 'dispatch;
            }
            0x82FC72AC => {
    //   block [0x82FC72AC..0x82FC72D4)
	// 82FC72AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC72B0: 997F0004  stb r11, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82FC72B4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC72B8: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82FC72BC: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82FC72C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FC72C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC72C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC72CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC72D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC72D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC72D8 size=148
    let mut pc: u32 = 0x82FC72D8;
    'dispatch: loop {
        match pc {
            0x82FC72D8 => {
    //   block [0x82FC72D8..0x82FC730C)
	// 82FC72D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC72DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC72E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC72E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC72E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC72EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC72F0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC72F4: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC72F8: 4099005C  ble cr6, 0x82fc7354
	if !ctx.cr[6].gt {
	pc = 0x82FC7354; continue 'dispatch;
	}
	// 82FC72FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC7300: 409A000C  bne cr6, 0x82fc730c
	if !ctx.cr[6].eq {
	pc = 0x82FC730C; continue 'dispatch;
	}
	// 82FC7304: 39640010  addi r11, r4, 0x10
	ctx.r[11].s64 = ctx.r[4].s64 + 16;
	// 82FC7308: 4800000C  b 0x82fc7314
	pc = 0x82FC7314; continue 'dispatch;
            }
            0x82FC730C => {
    //   block [0x82FC730C..0x82FC7314)
	// 82FC730C: 556BF0BE  srwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shr(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC7310: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	pc = 0x82FC7314; continue 'dispatch;
            }
            0x82FC7314 => {
    //   block [0x82FC7314..0x82FC7350)
	// 82FC7314: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82FC7318: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC731C: 5563083C  slwi r3, r11, 1
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82FC7320: 4BF36541  bl 0x82efd860
	ctx.lr = 0x82FC7324;
	sub_82EFD860(ctx, base);
	// 82FC7324: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC7328: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC732C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FC7330: 419A0020  beq cr6, 0x82fc7350
	if ctx.cr[6].eq {
	pc = 0x82FC7350; continue 'dispatch;
	}
	// 82FC7334: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC7338: 5565083C  slwi r5, r11, 1
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82FC733C: 4BCE2145  bl 0x82ca9480
	ctx.lr = 0x82FC7340;
	sub_82CA9480(ctx, base);
	// 82FC7340: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC7344: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC7348: 419A0008  beq cr6, 0x82fc7350
	if ctx.cr[6].eq {
	pc = 0x82FC7350; continue 'dispatch;
	}
	// 82FC734C: 4BF36555  bl 0x82efd8a0
	ctx.lr = 0x82FC7350;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC7350; continue 'dispatch;
            }
            0x82FC7350 => {
    //   block [0x82FC7350..0x82FC7354)
	// 82FC7350: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	pc = 0x82FC7354; continue 'dispatch;
            }
            0x82FC7354 => {
    //   block [0x82FC7354..0x82FC736C)
	// 82FC7354: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC7358: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC735C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC7360: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC7364: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC7368: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC7370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC7370 size=64
    let mut pc: u32 = 0x82FC7370;
    'dispatch: loop {
        match pc {
            0x82FC7370 => {
    //   block [0x82FC7370..0x82FC73B0)
	// 82FC7370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC7374: 4BCE2099  bl 0x82ca940c
	ctx.lr = 0x82FC7378;
	sub_82CA93D0(ctx, base);
	// 82FC7378: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC737C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC7380: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82FC7384: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC7388: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 82FC738C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC7390: 4BFFFF49  bl 0x82fc72d8
	ctx.lr = 0x82FC7394;
	sub_82FC72D8(ctx, base);
	// 82FC7394: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC7398: 57EA083C  slwi r10, r31, 1
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82FC739C: 93FE0010  stw r31, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	// 82FC73A0: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC73A4: B3ABFFFE  sth r29, -2(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(-2 as u32), ctx.r[29].u16 ) };
	// 82FC73A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC73AC: 4BCE20B0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC73B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC73B0 size=380
    let mut pc: u32 = 0x82FC73B0;
    'dispatch: loop {
        match pc {
            0x82FC73B0 => {
    //   block [0x82FC73B0..0x82FC7400)
	// 82FC73B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC73B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC73B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC73BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC73C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC73C4: 3FE08336  lis r31, -0x7cca
	ctx.r[31].s64 = -2093613056;
	// 82FC73C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC73CC: 817F96E4  lwz r11, -0x691c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-26908 as u32) ) } as u64;
	// 82FC73D0: 556A07FF  clrlwi. r10, r11, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC73D4: 4082002C  bne 0x82fc7400
	if !ctx.cr[0].eq {
	pc = 0x82FC7400; continue 'dispatch;
	}
	// 82FC73D8: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 82FC73DC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82FC73E0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82FC73E4: 394A697C  addi r10, r10, 0x697c
	ctx.r[10].s64 = ctx.r[10].s64 + 27004;
	// 82FC73E8: 917F96E4  stw r11, -0x691c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-26908 as u32), ctx.r[11].u32 ) };
	// 82FC73EC: 3D00832C  lis r8, -0x7cd4
	ctx.r[8].s64 = -2094268416;
	// 82FC73F0: 914996E0  stw r10, -0x6920(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-26912 as u32), ctx.r[10].u32 ) };
	// 82FC73F4: 386892C8  addi r3, r8, -0x6d38
	ctx.r[3].s64 = ctx.r[8].s64 + -27960;
	// 82FC73F8: 4BCE2B29  bl 0x82ca9f20
	ctx.lr = 0x82FC73FC;
	sub_82CA9F20(ctx, base);
	// 82FC73FC: 817F96E4  lwz r11, -0x691c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-26908 as u32) ) } as u64;
	pc = 0x82FC7400; continue 'dispatch;
            }
            0x82FC7400 => {
    //   block [0x82FC7400..0x82FC7430)
	// 82FC7400: 556A07BD  rlwinm. r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC7404: 4082002C  bne 0x82fc7430
	if !ctx.cr[0].eq {
	pc = 0x82FC7430; continue 'dispatch;
	}
	// 82FC7408: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 82FC740C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82FC7410: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 82FC7414: 394A699C  addi r10, r10, 0x699c
	ctx.r[10].s64 = ctx.r[10].s64 + 27036;
	// 82FC7418: 917F96E4  stw r11, -0x691c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-26908 as u32), ctx.r[11].u32 ) };
	// 82FC741C: 3D00832C  lis r8, -0x7cd4
	ctx.r[8].s64 = -2094268416;
	// 82FC7420: 914996DC  stw r10, -0x6924(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-26916 as u32), ctx.r[10].u32 ) };
	// 82FC7424: 38689340  addi r3, r8, -0x6cc0
	ctx.r[3].s64 = ctx.r[8].s64 + -27840;
	// 82FC7428: 4BCE2AF9  bl 0x82ca9f20
	ctx.lr = 0x82FC742C;
	sub_82CA9F20(ctx, base);
	// 82FC742C: 817F96E4  lwz r11, -0x691c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-26908 as u32) ) } as u64;
	pc = 0x82FC7430; continue 'dispatch;
            }
            0x82FC7430 => {
    //   block [0x82FC7430..0x82FC7460)
	// 82FC7430: 556A077B  rlwinm. r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC7434: 4082002C  bne 0x82fc7460
	if !ctx.cr[0].eq {
	pc = 0x82FC7460; continue 'dispatch;
	}
	// 82FC7438: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 82FC743C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82FC7440: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82FC7444: 394A69BC  addi r10, r10, 0x69bc
	ctx.r[10].s64 = ctx.r[10].s64 + 27068;
	// 82FC7448: 917F96E4  stw r11, -0x691c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-26908 as u32), ctx.r[11].u32 ) };
	// 82FC744C: 3D00832C  lis r8, -0x7cd4
	ctx.r[8].s64 = -2094268416;
	// 82FC7450: 914996D8  stw r10, -0x6928(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-26920 as u32), ctx.r[10].u32 ) };
	// 82FC7454: 38689328  addi r3, r8, -0x6cd8
	ctx.r[3].s64 = ctx.r[8].s64 + -27864;
	// 82FC7458: 4BCE2AC9  bl 0x82ca9f20
	ctx.lr = 0x82FC745C;
	sub_82CA9F20(ctx, base);
	// 82FC745C: 817F96E4  lwz r11, -0x691c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-26908 as u32) ) } as u64;
	pc = 0x82FC7460; continue 'dispatch;
            }
            0x82FC7460 => {
    //   block [0x82FC7460..0x82FC7490)
	// 82FC7460: 556A0739  rlwinm. r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC7464: 4082002C  bne 0x82fc7490
	if !ctx.cr[0].eq {
	pc = 0x82FC7490; continue 'dispatch;
	}
	// 82FC7468: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 82FC746C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82FC7470: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 82FC7474: 394A69DC  addi r10, r10, 0x69dc
	ctx.r[10].s64 = ctx.r[10].s64 + 27100;
	// 82FC7478: 917F96E4  stw r11, -0x691c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-26908 as u32), ctx.r[11].u32 ) };
	// 82FC747C: 3D00832C  lis r8, -0x7cd4
	ctx.r[8].s64 = -2094268416;
	// 82FC7480: 914996D4  stw r10, -0x692c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-26924 as u32), ctx.r[10].u32 ) };
	// 82FC7484: 38689310  addi r3, r8, -0x6cf0
	ctx.r[3].s64 = ctx.r[8].s64 + -27888;
	// 82FC7488: 4BCE2A99  bl 0x82ca9f20
	ctx.lr = 0x82FC748C;
	sub_82CA9F20(ctx, base);
	// 82FC748C: 817F96E4  lwz r11, -0x691c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-26908 as u32) ) } as u64;
	pc = 0x82FC7490; continue 'dispatch;
            }
            0x82FC7490 => {
    //   block [0x82FC7490..0x82FC74BC)
	// 82FC7490: 556A06F7  rlwinm. r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC7494: 40820028  bne 0x82fc74bc
	if !ctx.cr[0].eq {
	pc = 0x82FC74BC; continue 'dispatch;
	}
	// 82FC7498: 3D208336  lis r9, -0x7cca
	ctx.r[9].s64 = -2093613056;
	// 82FC749C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82FC74A0: 616B0010  ori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 16;
	// 82FC74A4: 394A69FC  addi r10, r10, 0x69fc
	ctx.r[10].s64 = ctx.r[10].s64 + 27132;
	// 82FC74A8: 917F96E4  stw r11, -0x691c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-26908 as u32), ctx.r[11].u32 ) };
	// 82FC74AC: 3D00832C  lis r8, -0x7cd4
	ctx.r[8].s64 = -2094268416;
	// 82FC74B0: 914996D0  stw r10, -0x6930(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-26928 as u32), ctx.r[10].u32 ) };
	// 82FC74B4: 386892F8  addi r3, r8, -0x6d08
	ctx.r[3].s64 = ctx.r[8].s64 + -27912;
	// 82FC74B8: 4BCE2A69  bl 0x82ca9f20
	ctx.lr = 0x82FC74BC;
	sub_82CA9F20(ctx, base);
	pc = 0x82FC74BC; continue 'dispatch;
            }
            0x82FC74BC => {
    //   block [0x82FC74BC..0x82FC74EC)
	// 82FC74BC: 2B1E0001  cmplwi cr6, r30, 1
	ctx.cr[6].compare_u32(ctx.r[30].u32, 1 as u32, &mut ctx.xer);
	// 82FC74C0: 3D608330  lis r11, -0x7cd0
	ctx.r[11].s64 = -2094006272;
	// 82FC74C4: 4198004C  blt cr6, 0x82fc7510
	if ctx.cr[6].lt {
	pc = 0x82FC7510; continue 'dispatch;
	}
	// 82FC74C8: 419A003C  beq cr6, 0x82fc7504
	if ctx.cr[6].eq {
	pc = 0x82FC7504; continue 'dispatch;
	}
	// 82FC74CC: 2B1E0003  cmplwi cr6, r30, 3
	ctx.cr[6].compare_u32(ctx.r[30].u32, 3 as u32, &mut ctx.xer);
	// 82FC74D0: 41980028  blt cr6, 0x82fc74f8
	if ctx.cr[6].lt {
	pc = 0x82FC74F8; continue 'dispatch;
	}
	// 82FC74D4: 419A0018  beq cr6, 0x82fc74ec
	if ctx.cr[6].eq {
	pc = 0x82FC74EC; continue 'dispatch;
	}
	// 82FC74D8: 2B1E0005  cmplwi cr6, r30, 5
	ctx.cr[6].compare_u32(ctx.r[30].u32, 5 as u32, &mut ctx.xer);
	// 82FC74DC: 40980034  bge cr6, 0x82fc7510
	if !ctx.cr[6].lt {
	pc = 0x82FC7510; continue 'dispatch;
	}
	// 82FC74E0: 396BF39C  addi r11, r11, -0xc64
	ctx.r[11].s64 = ctx.r[11].s64 + -3172;
	// 82FC74E4: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 82FC74E8: 4800002C  b 0x82fc7514
	pc = 0x82FC7514; continue 'dispatch;
            }
            0x82FC74EC => {
    //   block [0x82FC74EC..0x82FC74F8)
	// 82FC74EC: 396BF39C  addi r11, r11, -0xc64
	ctx.r[11].s64 = ctx.r[11].s64 + -3172;
	// 82FC74F0: 386B0024  addi r3, r11, 0x24
	ctx.r[3].s64 = ctx.r[11].s64 + 36;
	// 82FC74F4: 48000020  b 0x82fc7514
	pc = 0x82FC7514; continue 'dispatch;
            }
            0x82FC74F8 => {
    //   block [0x82FC74F8..0x82FC7504)
	// 82FC74F8: 396BF39C  addi r11, r11, -0xc64
	ctx.r[11].s64 = ctx.r[11].s64 + -3172;
	// 82FC74FC: 386B0018  addi r3, r11, 0x18
	ctx.r[3].s64 = ctx.r[11].s64 + 24;
	// 82FC7500: 48000014  b 0x82fc7514
	pc = 0x82FC7514; continue 'dispatch;
            }
            0x82FC7504 => {
    //   block [0x82FC7504..0x82FC7510)
	// 82FC7504: 396BF39C  addi r11, r11, -0xc64
	ctx.r[11].s64 = ctx.r[11].s64 + -3172;
	// 82FC7508: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 82FC750C: 48000008  b 0x82fc7514
	pc = 0x82FC7514; continue 'dispatch;
            }
            0x82FC7510 => {
    //   block [0x82FC7510..0x82FC7514)
	// 82FC7510: 386BF39C  addi r3, r11, -0xc64
	ctx.r[3].s64 = ctx.r[11].s64 + -3172;
	pc = 0x82FC7514; continue 'dispatch;
            }
            0x82FC7514 => {
    //   block [0x82FC7514..0x82FC752C)
	// 82FC7514: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC7518: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC751C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC7520: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC7524: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC7528: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC7530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC7530 size=80
    let mut pc: u32 = 0x82FC7530;
    'dispatch: loop {
        match pc {
            0x82FC7530 => {
    //   block [0x82FC7530..0x82FC7580)
	// 82FC7530: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC7534: 4BCE1ED9  bl 0x82ca940c
	ctx.lr = 0x82FC7538;
	sub_82CA93D0(ctx, base);
	// 82FC7538: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC753C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC7540: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82FC7544: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FC7548: 9BFE0018  stb r31, 0x18(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[31].u8 ) };
	// 82FC754C: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82FC7550: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82FC7554: 93FE000C  stw r31, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82FC7558: 4BFFFE59  bl 0x82fc73b0
	ctx.lr = 0x82FC755C;
	sub_82FC73B0(ctx, base);
	// 82FC755C: 907E0010  stw r3, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82FC7560: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC7564: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC7568: 4BFFF9E1  bl 0x82fc6f48
	ctx.lr = 0x82FC756C;
	sub_82FC6F48(ctx, base);
	// 82FC756C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82FC7570: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82FC7574: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC7578: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC757C: 4BCE1EE0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC7580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC7580 size=120
    let mut pc: u32 = 0x82FC7580;
    'dispatch: loop {
        match pc {
            0x82FC7580 => {
    //   block [0x82FC7580..0x82FC75AC)
	// 82FC7580: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC7584: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC7588: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC758C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC7590: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC7594: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC7598: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC759C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC75A0: 419A000C  beq cr6, 0x82fc75ac
	if ctx.cr[6].eq {
	pc = 0x82FC75AC; continue 'dispatch;
	}
	// 82FC75A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82FC75A8: 48000038  b 0x82fc75e0
	pc = 0x82FC75E0; continue 'dispatch;
            }
            0x82FC75AC => {
    //   block [0x82FC75AC..0x82FC75E0)
	// 82FC75AC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC75B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC75B4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC75B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC75BC: 7FCB51D6  mullw r30, r11, r10
	ctx.r[30].s32 = ((ctx.r[11].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[30].s64 = ctx.r[30].s32 as i64;
	// 82FC75C0: 4BFFFDF1  bl 0x82fc73b0
	ctx.lr = 0x82FC75C4;
	sub_82FC73B0(ctx, base);
	// 82FC75C4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82FC75C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82FC75CC: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82FC75D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC75D4: 0CCB0000  twi 6, r11, 0
	// 82FC75D8: 7D7E5B96  divwu r11, r30, r11
	ctx.r[11].u32 = ctx.r[30].u32 / ctx.r[11].u32;
	// 82FC75DC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82FC75E0; continue 'dispatch;
            }
            0x82FC75E0 => {
    //   block [0x82FC75E0..0x82FC75F8)
	// 82FC75E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC75E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC75E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC75EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC75F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC75F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC75F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC75F8 size=20
    let mut pc: u32 = 0x82FC75F8;
    'dispatch: loop {
        match pc {
            0x82FC75F8 => {
    //   block [0x82FC75F8..0x82FC760C)
	// 82FC75F8: 80E30004  lwz r7, 4(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC75FC: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82FC7600: 409A000C  bne cr6, 0x82fc760c
	if !ctx.cr[6].eq {
		sub_82FC760C(ctx, base);
		return;
	}
	// 82FC7604: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82FC7608: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC760C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC760C size=116
    let mut pc: u32 = 0x82FC760C;
    'dispatch: loop {
        match pc {
            0x82FC760C => {
    //   block [0x82FC760C..0x82FC7618)
	// 82FC760C: 7CE90E70  srawi r9, r7, 1
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[7].s32 >> 1) as i64;
	// 82FC7610: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7614: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	pc = 0x82FC7618; continue 'dispatch;
            }
            0x82FC7618 => {
    //   block [0x82FC7618..0x82FC7628)
	// 82FC7618: 7D290E70  srawi r9, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 82FC761C: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 82FC7620: 40980008  bge cr6, 0x82fc7628
	if !ctx.cr[6].lt {
	pc = 0x82FC7628; continue 'dispatch;
	}
	// 82FC7624: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x82FC7628; continue 'dispatch;
            }
            0x82FC7628 => {
    //   block [0x82FC7628..0x82FC7654)
	// 82FC7628: 546B1838  slwi r11, r3, 3
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC762C: 7D4B4214  add r10, r11, r8
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82FC7630: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7634: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC7638: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82FC763C: 40990018  ble cr6, 0x82fc7654
	if !ctx.cr[6].gt {
	pc = 0x82FC7654; continue 'dispatch;
	}
	// 82FC7640: 3967FFFF  addi r11, r7, -1
	ctx.r[11].s64 = ctx.r[7].s64 + -1;
	// 82FC7644: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82FC7648: 419A0030  beq cr6, 0x82fc7678
	if ctx.cr[6].eq {
	pc = 0x82FC7678; continue 'dispatch;
	}
	// 82FC764C: 7C634A14  add r3, r3, r9
	ctx.r[3].u64 = ctx.r[3].u64 + ctx.r[9].u64;
	// 82FC7650: 4BFFFFC8  b 0x82fc7618
	pc = 0x82FC7618; continue 'dispatch;
            }
            0x82FC7654 => {
    //   block [0x82FC7654..0x82FC7678)
	// 82FC7654: 4098002C  bge cr6, 0x82fc7680
	if !ctx.cr[6].lt {
		sub_82FC7680(ctx, base);
		return;
	}
	// 82FC7658: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82FC765C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82FC7660: 816AFFFC  lwz r11, -4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82FC7664: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC7668: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82FC766C: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
	// 82FC7670: 7C691850  subf r3, r9, r3
	ctx.r[3].s64 = ctx.r[3].s64 - ctx.r[9].s64;
	// 82FC7674: 4BFFFFA4  b 0x82fc7618
	pc = 0x82FC7618; continue 'dispatch;
            }
            0x82FC7678 => {
    //   block [0x82FC7678..0x82FC7680)
	// 82FC7678: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 82FC767C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC7680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC7680 size=52
    let mut pc: u32 = 0x82FC7680;
    'dispatch: loop {
        match pc {
            0x82FC7680 => {
    //   block [0x82FC7680..0x82FC7694)
	// 82FC7680: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82FC7684: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82FC7688: 546B1838  slwi r11, r3, 3
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC768C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82FC7690: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	pc = 0x82FC7694; continue 'dispatch;
            }
            0x82FC7694 => {
    //   block [0x82FC7694..0x82FC76B4)
	// 82FC7694: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7698: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC769C: 7F0A2000  cmpw cr6, r10, r4
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82FC76A0: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 82FC76A4: 3463FFFF  addic. r3, r3, -1
	ctx.xer.ca = (ctx.r[3].u32 > (!(-1 as u32)));
	ctx.r[3].s64 = ctx.r[3].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82FC76A8: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 82FC76AC: 4082FFE8  bne 0x82fc7694
	if !ctx.cr[0].eq {
	pc = 0x82FC7694; continue 'dispatch;
	}
	// 82FC76B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC76B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC76B8 size=80
    let mut pc: u32 = 0x82FC76B8;
    'dispatch: loop {
        match pc {
            0x82FC76B8 => {
    //   block [0x82FC76B8..0x82FC76F4)
	// 82FC76B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC76BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC76C0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC76C4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82FC76C8: 4BFFFF31  bl 0x82fc75f8
	ctx.lr = 0x82FC76CC;
	sub_82FC75F8(ctx, base);
	// 82FC76CC: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC76D0: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82FC76D4: 40980020  bge cr6, 0x82fc76f4
	if !ctx.cr[6].lt {
	pc = 0x82FC76F4; continue 'dispatch;
	}
	// 82FC76D8: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC76DC: 546B1838  slwi r11, r3, 3
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC76E0: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC76E4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC76E8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC76EC: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82FC76F0: 419A0008  beq cr6, 0x82fc76f8
	if ctx.cr[6].eq {
	pc = 0x82FC76F8; continue 'dispatch;
	}
	pc = 0x82FC76F4; continue 'dispatch;
            }
            0x82FC76F4 => {
    //   block [0x82FC76F4..0x82FC76F8)
	// 82FC76F4: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82FC76F8; continue 'dispatch;
            }
            0x82FC76F8 => {
    //   block [0x82FC76F8..0x82FC7708)
	// 82FC76F8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FC76FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC7700: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC7704: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC7708(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC7708 size=76
    let mut pc: u32 = 0x82FC7708;
    'dispatch: loop {
        match pc {
            0x82FC7708 => {
    //   block [0x82FC7708..0x82FC7740)
	// 82FC7708: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC770C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC7710: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC7714: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82FC7718: 4BFFFFA1  bl 0x82fc76b8
	ctx.lr = 0x82FC771C;
	sub_82FC76B8(ctx, base);
	// 82FC771C: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 82FC7720: 419A0020  beq cr6, 0x82fc7740
	if ctx.cr[6].eq {
	pc = 0x82FC7740; continue 'dispatch;
	}
	// 82FC7724: 81450000  lwz r10, 0(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7728: 546B1838  slwi r11, r3, 3
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC772C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC7730: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7734: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC7738: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82FC773C: 419A0008  beq cr6, 0x82fc7744
	if ctx.cr[6].eq {
	pc = 0x82FC7744; continue 'dispatch;
	}
	pc = 0x82FC7740; continue 'dispatch;
            }
            0x82FC7740 => {
    //   block [0x82FC7740..0x82FC7744)
	// 82FC7740: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82FC7744; continue 'dispatch;
            }
            0x82FC7744 => {
    //   block [0x82FC7744..0x82FC7754)
	// 82FC7744: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FC7748: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC774C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC7750: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC7758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC7758 size=36
    let mut pc: u32 = 0x82FC7758;
    'dispatch: loop {
        match pc {
            0x82FC7758 => {
    //   block [0x82FC7758..0x82FC777C)
	// 82FC7758: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC775C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC7760: 419A001C  beq cr6, 0x82fc777c
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82FC777C);
		return;
	}
	// 82FC7764: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7768: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC776C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC7770: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82FC7774: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC7778: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC7788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC7788 size=276
    let mut pc: u32 = 0x82FC7788;
    'dispatch: loop {
        match pc {
            0x82FC7788 => {
    //   block [0x82FC7788..0x82FC77B4)
	// 82FC7788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC778C: 4BCE1C71  bl 0x82ca93fc
	ctx.lr = 0x82FC7790;
	sub_82CA93D0(ctx, base);
	// 82FC7790: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC7794: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82FC7798: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82FC779C: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC77A0: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC77A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC77A8: 409A000C  bne cr6, 0x82fc77b4
	if !ctx.cr[6].eq {
	pc = 0x82FC77B4; continue 'dispatch;
	}
	// 82FC77AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82FC77B0: 480000E4  b 0x82fc7894
	pc = 0x82FC7894; continue 'dispatch;
            }
            0x82FC77B4 => {
    //   block [0x82FC77B4..0x82FC77E0)
	// 82FC77B4: 89640004  lbz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC77B8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82FC77BC: 839B0004  lwz r28, 4(r27)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC77C0: 216B0006  subfic r11, r11, 6
	ctx.xer.ca = ctx.r[11].u32 <= 6 as u32;
	ctx.r[11].s64 = (6 as i64) - ctx.r[11].s64;
	// 82FC77C4: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82FC77C8: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC77CC: 41820058  beq 0x82fc7824
	if ctx.cr[0].eq {
	pc = 0x82FC7824; continue 'dispatch;
	}
	// 82FC77D0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82FC77D4: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82FC77D8: 409900B8  ble cr6, 0x82fc7890
	if !ctx.cr[6].gt {
	pc = 0x82FC7890; continue 'dispatch;
	}
	// 82FC77DC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82FC77E0; continue 'dispatch;
            }
            0x82FC77E0 => {
    //   block [0x82FC77E0..0x82FC7824)
	// 82FC77E0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC77E4: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82FC77E8: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC77EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC77F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC77F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC77F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC77FC: 4E800421  bctrl
	ctx.lr = 0x82FC7800;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC7800: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7804: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7808: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC780C: 419A0080  beq cr6, 0x82fc788c
	if ctx.cr[6].eq {
	pc = 0x82FC788C; continue 'dispatch;
	}
	// 82FC7810: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82FC7814: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82FC7818: 7F1DE000  cmpw cr6, r29, r28
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82FC781C: 4198FFC4  blt cr6, 0x82fc77e0
	if ctx.cr[6].lt {
	pc = 0x82FC77E0; continue 'dispatch;
	}
	// 82FC7820: 48000070  b 0x82fc7890
	pc = 0x82FC7890; continue 'dispatch;
            }
            0x82FC7824 => {
    //   block [0x82FC7824..0x82FC7834)
	// 82FC7824: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC7828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC782C: 409A0008  bne cr6, 0x82fc7834
	if !ctx.cr[6].eq {
	pc = 0x82FC7834; continue 'dispatch;
	}
	// 82FC7830: 4BFA6981  bl 0x82f6e1b0
	ctx.lr = 0x82FC7834;
	sub_82F6E1B0(ctx, base);
	pc = 0x82FC7834; continue 'dispatch;
            }
            0x82FC7834 => {
    //   block [0x82FC7834..0x82FC7844)
	// 82FC7834: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82FC7838: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82FC783C: 40990054  ble cr6, 0x82fc7890
	if !ctx.cr[6].gt {
	pc = 0x82FC7890; continue 'dispatch;
	}
	// 82FC7840: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82FC7844; continue 'dispatch;
            }
            0x82FC7844 => {
    //   block [0x82FC7844..0x82FC788C)
	// 82FC7844: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7848: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82FC784C: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC7854: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7858: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC785C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7860: 4E800421  bctrl
	ctx.lr = 0x82FC7864;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC7864: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82FC7868: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82FC786C: 4BF5060D  bl 0x82f17e78
	ctx.lr = 0x82FC7870;
	sub_82F17E78(ctx, base);
	// 82FC7870: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC7874: 40820018  bne 0x82fc788c
	if !ctx.cr[0].eq {
	pc = 0x82FC788C; continue 'dispatch;
	}
	// 82FC7878: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82FC787C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82FC7880: 7F1DE000  cmpw cr6, r29, r28
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[28].s32, &mut ctx.xer);
	// 82FC7884: 4198FFC0  blt cr6, 0x82fc7844
	if ctx.cr[6].lt {
	pc = 0x82FC7844; continue 'dispatch;
	}
	// 82FC7888: 48000008  b 0x82fc7890
	pc = 0x82FC7890; continue 'dispatch;
            }
            0x82FC788C => {
    //   block [0x82FC788C..0x82FC7890)
	// 82FC788C: 7FF9FB78  mr r25, r31
	ctx.r[25].u64 = ctx.r[31].u64;
	pc = 0x82FC7890; continue 'dispatch;
            }
            0x82FC7890 => {
    //   block [0x82FC7890..0x82FC7894)
	// 82FC7890: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x82FC7894; continue 'dispatch;
            }
            0x82FC7894 => {
    //   block [0x82FC7894..0x82FC789C)
	// 82FC7894: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82FC7898: 4BCE1BB4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC78A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC78A0 size=268
    let mut pc: u32 = 0x82FC78A0;
    'dispatch: loop {
        match pc {
            0x82FC78A0 => {
    //   block [0x82FC78A0..0x82FC7944)
	// 82FC78A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC78A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC78A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC78AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC78B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC78B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC78B8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82FC78BC: 809E0048  lwz r4, 0x48(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 82FC78C0: 4BFFFD39  bl 0x82fc75f8
	ctx.lr = 0x82FC78C4;
	sub_82FC75F8(ctx, base);
	// 82FC78C4: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC78C8: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC78CC: 409800C8  bge cr6, 0x82fc7994
	if !ctx.cr[6].lt {
	pc = 0x82FC7994; continue 'dispatch;
	}
	// 82FC78D0: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC78D4: 546B1838  slwi r11, r3, 3
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC78D8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC78DC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC78E0: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC78E4: 7F0A2000  cmpw cr6, r10, r4
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82FC78E8: 409A00AC  bne cr6, 0x82fc7994
	if !ctx.cr[6].eq {
	pc = 0x82FC7994; continue 'dispatch;
	}
	// 82FC78EC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC78F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC78F4: 554A07FA  rlwinm r10, r10, 0, 0x1f, 0x1d
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC78F8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82FC78FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7900: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC7904: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7908: 4E800421  bctrl
	ctx.lr = 0x82FC790C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC790C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC7910: 41820084  beq 0x82fc7994
	if ctx.cr[0].eq {
	pc = 0x82FC7994; continue 'dispatch;
	}
	// 82FC7914: 897E0053  lbz r11, 0x53(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(83 as u32) ) } as u64;
	// 82FC7918: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC791C: 41820028  beq 0x82fc7944
	if ctx.cr[0].eq {
	pc = 0x82FC7944; continue 'dispatch;
	}
	// 82FC7920: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82FC7924: 395F0030  addi r10, r31, 0x30
	ctx.r[10].s64 = ctx.r[31].s64 + 48;
	// 82FC7928: F97F0030  std r11, 0x30(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u64 ) };
	// 82FC792C: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82FC7930: F97F0038  std r11, 0x38(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u64 ) };
	// 82FC7934: E97E0010  ld r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	// 82FC7938: F97F0040  std r11, 0x40(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u64 ) };
	// 82FC793C: E97E0018  ld r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	// 82FC7940: F97F0048  std r11, 0x48(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u64 ) };
            }
            0x82FC7944 => {
    //   block [0x82FC7944..0x82FC795C)
	// 82FC7944: 897E0052  lbz r11, 0x52(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(82 as u32) ) } as u64;
	// 82FC7948: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC794C: 41820010  beq 0x82fc795c
	if ctx.cr[0].eq {
	pc = 0x82FC795C; continue 'dispatch;
	}
	// 82FC7950: 389E0020  addi r4, r30, 0x20
	ctx.r[4].s64 = ctx.r[30].s64 + 32;
	// 82FC7954: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82FC7958: 4BFA4EA1  bl 0x82f6c7f8
	ctx.lr = 0x82FC795C;
	sub_82F6C7F8(ctx, base);
	pc = 0x82FC795C; continue 'dispatch;
            }
            0x82FC795C => {
    //   block [0x82FC795C..0x82FC796C)
	// 82FC795C: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82FC7960: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC7964: 419A0008  beq cr6, 0x82fc796c
	if ctx.cr[6].eq {
	pc = 0x82FC796C; continue 'dispatch;
	}
	// 82FC7968: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	pc = 0x82FC796C; continue 'dispatch;
            }
            0x82FC796C => {
    //   block [0x82FC796C..0x82FC798C)
	// 82FC796C: 809E0054  lwz r4, 0x54(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC7970: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82FC7974: 419A0018  beq cr6, 0x82fc798c
	if ctx.cr[6].eq {
	pc = 0x82FC798C; continue 'dispatch;
	}
	// 82FC7978: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC797C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC7980: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC7984: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7988: 4E800421  bctrl
	ctx.lr = 0x82FC798C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC798C => {
    //   block [0x82FC798C..0x82FC7994)
	// 82FC798C: C01E0044  lfs f0, 0x44(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC7990: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	pc = 0x82FC7994; continue 'dispatch;
            }
            0x82FC7994 => {
    //   block [0x82FC7994..0x82FC79AC)
	// 82FC7994: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC7998: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC799C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC79A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC79A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC79A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC79B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC79B0 size=116
    let mut pc: u32 = 0x82FC79B0;
    'dispatch: loop {
        match pc {
            0x82FC79B0 => {
    //   block [0x82FC79B0..0x82FC79D4)
	// 82FC79B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC79B4: 4BCE1A59  bl 0x82ca940c
	ctx.lr = 0x82FC79B8;
	sub_82CA93D0(ctx, base);
	// 82FC79B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC79BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC79C0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC79C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC79C8: 419A0054  beq cr6, 0x82fc7a1c
	if ctx.cr[6].eq {
	pc = 0x82FC7A1C; continue 'dispatch;
	}
	// 82FC79CC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82FC79D0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	pc = 0x82FC79D4; continue 'dispatch;
            }
            0x82FC79D4 => {
    //   block [0x82FC79D4..0x82FC7A00)
	// 82FC79D4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC79D8: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82FC79DC: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC79E0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82FC79E4: 419A001C  beq cr6, 0x82fc7a00
	if ctx.cr[6].eq {
	pc = 0x82FC7A00; continue 'dispatch;
	}
	// 82FC79E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC79EC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC79F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC79F4: 4E800421  bctrl
	ctx.lr = 0x82FC79F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC79F8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC79FC: 41820014  beq 0x82fc7a10
	if ctx.cr[0].eq {
	pc = 0x82FC7A10; continue 'dispatch;
	}
            }
            0x82FC7A00 => {
    //   block [0x82FC7A00..0x82FC7A10)
	// 82FC7A00: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7A04: 7D5F582E  lwzx r10, r31, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FC7A08: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 82FC7A0C: 7D5F592E  stwx r10, r31, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	pc = 0x82FC7A10; continue 'dispatch;
            }
            0x82FC7A10 => {
    //   block [0x82FC7A10..0x82FC7A1C)
	// 82FC7A10: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82FC7A14: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82FC7A18: 4082FFBC  bne 0x82fc79d4
	if !ctx.cr[0].eq {
	pc = 0x82FC79D4; continue 'dispatch;
	}
	pc = 0x82FC7A1C; continue 'dispatch;
            }
            0x82FC7A1C => {
    //   block [0x82FC7A1C..0x82FC7A24)
	// 82FC7A1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC7A20: 4BCE1A3C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC7A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC7A28 size=140
    let mut pc: u32 = 0x82FC7A28;
    'dispatch: loop {
        match pc {
            0x82FC7A28 => {
    //   block [0x82FC7A28..0x82FC7A54)
	// 82FC7A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC7A2C: 4BCE19D9  bl 0x82ca9404
	ctx.lr = 0x82FC7A30;
	sub_82CA93D0(ctx, base);
	// 82FC7A30: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82FC7A34: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC7A38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC7A3C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82FC7A40: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82FC7A44: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7A48: 37DCFFFF  addic. r30, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82FC7A4C: 4180005C  blt 0x82fc7aa8
	if ctx.cr[0].lt {
	pc = 0x82FC7AA8; continue 'dispatch;
	}
	// 82FC7A50: 57DD1838  slwi r29, r30, 3
	ctx.r[29].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	pc = 0x82FC7A54; continue 'dispatch;
            }
            0x82FC7A54 => {
    //   block [0x82FC7A54..0x82FC7A94)
	// 82FC7A54: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7A58: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC7A5C: 409A004C  bne cr6, 0x82fc7aa8
	if !ctx.cr[6].eq {
	pc = 0x82FC7AA8; continue 'dispatch;
	}
	// 82FC7A60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7A64: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82FC7A68: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7A6C: 554907BF  clrlwi. r9, r10, 0x1e
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC7A70: 40820024  bne 0x82fc7a94
	if !ctx.cr[0].eq {
	pc = 0x82FC7A94; continue 'dispatch;
	}
	// 82FC7A74: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7A78: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82FC7A7C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82FC7A80: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7A84: 816B0058  lwz r11, 0x58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 82FC7A88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7A8C: 4E800421  bctrl
	ctx.lr = 0x82FC7A90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC7A90: 4800000C  b 0x82fc7a9c
	pc = 0x82FC7A9C; continue 'dispatch;
            }
            0x82FC7A94 => {
    //   block [0x82FC7A94..0x82FC7A9C)
	// 82FC7A94: 554A003C  rlwinm r10, r10, 0, 0, 0x1e
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC7A98: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82FC7A9C; continue 'dispatch;
            }
            0x82FC7A9C => {
    //   block [0x82FC7A9C..0x82FC7AA8)
	// 82FC7A9C: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82FC7AA0: 3BBDFFF8  addi r29, r29, -8
	ctx.r[29].s64 = ctx.r[29].s64 + -8;
	// 82FC7AA4: 4080FFB0  bge 0x82fc7a54
	if !ctx.cr[0].lt {
	pc = 0x82FC7A54; continue 'dispatch;
	}
	pc = 0x82FC7AA8; continue 'dispatch;
            }
            0x82FC7AA8 => {
    //   block [0x82FC7AA8..0x82FC7AB4)
	// 82FC7AA8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82FC7AAC: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82FC7AB0: 4BCE19A4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC7AB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC7AB8 size=648
    let mut pc: u32 = 0x82FC7AB8;
    'dispatch: loop {
        match pc {
            0x82FC7AB8 => {
    //   block [0x82FC7AB8..0x82FC7AF4)
	// 82FC7AB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC7ABC: 4BCE1939  bl 0x82ca93f4
	ctx.lr = 0x82FC7AC0;
	sub_82CA93D0(ctx, base);
	// 82FC7AC0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC7AC4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82FC7AC8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82FC7ACC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82FC7AD0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82FC7AD4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 82FC7AD8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7ADC: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7AE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC7AE4: 838A0014  lwz r28, 0x14(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC7AE8: 419A0250  beq cr6, 0x82fc7d38
	if ctx.cr[6].eq {
	pc = 0x82FC7D38; continue 'dispatch;
	}
	// 82FC7AEC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82FC7AF0: 7D775B78  mr r23, r11
	ctx.r[23].u64 = ctx.r[11].u64;
	pc = 0x82FC7AF4; continue 'dispatch;
            }
            0x82FC7AF4 => {
    //   block [0x82FC7AF4..0x82FC7B48)
	// 82FC7AF4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7AF8: 7D795A14  add r11, r25, r11
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[11].u64;
	// 82FC7AFC: 83AB0004  lwz r29, 4(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7B00: 897D0078  lbz r11, 0x78(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(120 as u32) ) } as u64;
	// 82FC7B04: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC7B08: 4182020C  beq 0x82fc7d14
	if ctx.cr[0].eq {
	pc = 0x82FC7D14; continue 'dispatch;
	}
	// 82FC7B0C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7B10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC7B14: 816B0088  lwz r11, 0x88(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 82FC7B18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7B1C: 4E800421  bctrl
	ctx.lr = 0x82FC7B20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC7B20: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC7B24: 408201F0  bne 0x82fc7d14
	if !ctx.cr[0].eq {
	pc = 0x82FC7D14; continue 'dispatch;
	}
	// 82FC7B28: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82FC7B2C: 419A001C  beq cr6, 0x82fc7b48
	if ctx.cr[6].eq {
	pc = 0x82FC7B48; continue 'dispatch;
	}
	// 82FC7B30: 817D0018  lwz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC7B34: 7F0BC000  cmpw cr6, r11, r24
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[24].s32, &mut ctx.xer);
	// 82FC7B38: 40990010  ble cr6, 0x82fc7b48
	if !ctx.cr[6].gt {
	pc = 0x82FC7B48; continue 'dispatch;
	}
	// 82FC7B3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC7B40: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	// 82FC7B44: 4BFF57ED  bl 0x82fbd330
	ctx.lr = 0x82FC7B48;
	sub_82FBD330(ctx, base);
            }
            0x82FC7B48 => {
    //   block [0x82FC7B48..0x82FC7B6C)
	// 82FC7B48: 817F0058  lwz r11, 0x58(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82FC7B4C: 815F0054  lwz r10, 0x54(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC7B50: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC7B54: 409900E4  ble cr6, 0x82fc7c38
	if !ctx.cr[6].gt {
	pc = 0x82FC7C38; continue 'dispatch;
	}
	// 82FC7B58: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC7B5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC7B60: 409A00D8  bne cr6, 0x82fc7c38
	if !ctx.cr[6].eq {
	pc = 0x82FC7C38; continue 'dispatch;
	}
	// 82FC7B64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FC7B68: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82FC7B6C; continue 'dispatch;
            }
            0x82FC7B6C => {
    //   block [0x82FC7B6C..0x82FC7C10)
	// 82FC7B6C: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC7B70: 2B0B0040  cmplwi cr6, r11, 0x40
	ctx.cr[6].compare_u32(ctx.r[11].u32, 64 as u32, &mut ctx.xer);
	// 82FC7B74: 4199009C  bgt cr6, 0x82fc7c10
	if ctx.cr[6].gt {
	pc = 0x82FC7C10; continue 'dispatch;
	}
	// 82FC7B78: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7B7C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82FC7B80: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC7B84: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 82FC7B88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7B8C: 4E800421  bctrl
	ctx.lr = 0x82FC7B90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC7B90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC7B94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82FC7B98: 4BFA4C61  bl 0x82f6c7f8
	ctx.lr = 0x82FC7B9C;
	sub_82F6C7F8(ctx, base);
	// 82FC7B9C: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC7BA0: E93E0020  ld r9, 0x20(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	// 82FC7BA4: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82FC7BA8: 396B0016  addi r11, r11, 0x16
	ctx.r[11].s64 = ctx.r[11].s64 + 22;
	// 82FC7BAC: E91E0028  ld r8, 0x28(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	// 82FC7BB0: E8FE0030  ld r7, 0x30(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	// 82FC7BB4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82FC7BB8: E8DE0038  ld r6, 0x38(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	// 82FC7BBC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC7BC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC7BC4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82FC7BC8: F90A0008  std r8, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 82FC7BCC: F8EA0010  std r7, 0x10(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[7].u64 ) };
	// 82FC7BD0: F8CA0018  std r6, 0x18(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[6].u64 ) };
	// 82FC7BD4: 7C6BF82E  lwzx r3, r11, r31
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82FC7BD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7BDC: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC7BE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7BE4: 4E800421  bctrl
	ctx.lr = 0x82FC7BE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC7BE8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7BEC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC7BF0: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82FC7BF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7BF8: 4E800421  bctrl
	ctx.lr = 0x82FC7BFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC7BFC: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC7C00: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82FC7C04: 396B0016  addi r11, r11, 0x16
	ctx.r[11].s64 = ctx.r[11].s64 + 22;
	// 82FC7C08: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC7C0C: 7D4BF92E  stwx r10, r11, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32), ctx.r[10].u32) };
            }
            0x82FC7C10 => {
    //   block [0x82FC7C10..0x82FC7C38)
	// 82FC7C10: 817F0054  lwz r11, 0x54(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC7C14: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FC7C18: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82FC7C1C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC7C20: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 82FC7C24: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC7C28: 4199FF44  bgt cr6, 0x82fc7b6c
	if ctx.cr[6].gt {
	pc = 0x82FC7B6C; continue 'dispatch;
	}
	// 82FC7C2C: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC7C30: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FC7C34: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	pc = 0x82FC7C38; continue 'dispatch;
            }
            0x82FC7C38 => {
    //   block [0x82FC7C38..0x82FC7C9C)
	// 82FC7C38: A17D0024  lhz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC7C3C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC7C40: 4182005C  beq 0x82fc7c9c
	if ctx.cr[0].eq {
	pc = 0x82FC7C9C; continue 'dispatch;
	}
	// 82FC7C44: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC7C48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC7C4C: 409A0050  bne cr6, 0x82fc7c9c
	if !ctx.cr[6].eq {
	pc = 0x82FC7C9C; continue 'dispatch;
	}
	// 82FC7C50: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC7C54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82FC7C58: 4BFA4BA1  bl 0x82f6c7f8
	ctx.lr = 0x82FC7C5C;
	sub_82F6C7F8(ctx, base);
	// 82FC7C5C: E95E0020  ld r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	// 82FC7C60: E93E0028  ld r9, 0x28(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	// 82FC7C64: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82FC7C68: E91E0030  ld r8, 0x30(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	// 82FC7C6C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82FC7C70: E8FE0038  ld r7, 0x38(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	// 82FC7C74: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC7C78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC7C7C: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82FC7C80: F92B0008  std r9, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 82FC7C84: F90B0010  std r8, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[8].u64 ) };
	// 82FC7C88: F8EB0018  std r7, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[7].u64 ) };
	// 82FC7C8C: 4BFF5585  bl 0x82fbd210
	ctx.lr = 0x82FC7C90;
	sub_82FBD210(ctx, base);
	// 82FC7C90: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82FC7C94: A31D0024  lhz r24, 0x24(r29)
	ctx.r[24].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC7C98: 4800007C  b 0x82fc7d14
	pc = 0x82FC7D14; continue 'dispatch;
            }
            0x82FC7C9C => {
    //   block [0x82FC7C9C..0x82FC7D14)
	// 82FC7C9C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7CA0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC7CA4: 809D0074  lwz r4, 0x74(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(116 as u32) ) } as u64;
	// 82FC7CA8: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC7CAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7CB0: 4E800421  bctrl
	ctx.lr = 0x82FC7CB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC7CB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC7CB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82FC7CBC: 4BFA4B3D  bl 0x82f6c7f8
	ctx.lr = 0x82FC7CC0;
	sub_82F6C7F8(ctx, base);
	// 82FC7CC0: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82FC7CC4: E95E0020  ld r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	// 82FC7CC8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82FC7CCC: E93E0028  ld r9, 0x28(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	// 82FC7CD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC7CD4: E91E0030  ld r8, 0x30(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	// 82FC7CD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC7CDC: E8FE0038  ld r7, 0x38(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	// 82FC7CE0: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7CE4: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82FC7CE8: F92B0008  std r9, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 82FC7CEC: F90B0010  std r8, 0x10(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[8].u64 ) };
	// 82FC7CF0: F8EB0018  std r7, 0x18(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[7].u64 ) };
	// 82FC7CF4: 81660050  lwz r11, 0x50(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC7CF8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7CFC: 4E800421  bctrl
	ctx.lr = 0x82FC7D00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC7D00: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7D04: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC7D08: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82FC7D0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7D10: 4E800421  bctrl
	ctx.lr = 0x82FC7D14;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC7D14 => {
    //   block [0x82FC7D14..0x82FC7D28)
	// 82FC7D14: 36F7FFFF  addic. r23, r23, -1
	ctx.xer.ca = (ctx.r[23].u32 > (!(-1 as u32)));
	ctx.r[23].s64 = ctx.r[23].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 82FC7D18: 3B390008  addi r25, r25, 8
	ctx.r[25].s64 = ctx.r[25].s64 + 8;
	// 82FC7D1C: 4082FDD8  bne 0x82fc7af4
	if !ctx.cr[0].eq {
	pc = 0x82FC7AF4; continue 'dispatch;
	}
	// 82FC7D20: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82FC7D24: 419A0014  beq cr6, 0x82fc7d38
	if ctx.cr[6].eq {
	pc = 0x82FC7D38; continue 'dispatch;
	}
	pc = 0x82FC7D28; continue 'dispatch;
            }
            0x82FC7D28 => {
    //   block [0x82FC7D28..0x82FC7D38)
	// 82FC7D28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC7D2C: 4BFF5605  bl 0x82fbd330
	ctx.lr = 0x82FC7D30;
	sub_82FBD330(ctx, base);
	// 82FC7D30: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82FC7D34: 4082FFF4  bne 0x82fc7d28
	if !ctx.cr[0].eq {
	pc = 0x82FC7D28; continue 'dispatch;
	}
	pc = 0x82FC7D38; continue 'dispatch;
            }
            0x82FC7D38 => {
    //   block [0x82FC7D38..0x82FC7D40)
	// 82FC7D38: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82FC7D3C: 4BCE1708  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC7D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC7D40 size=112
    let mut pc: u32 = 0x82FC7D40;
    'dispatch: loop {
        match pc {
            0x82FC7D40 => {
    //   block [0x82FC7D40..0x82FC7D64)
	// 82FC7D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC7D44: 4BCE16C5  bl 0x82ca9408
	ctx.lr = 0x82FC7D48;
	sub_82CA93D0(ctx, base);
	// 82FC7D48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC7D4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC7D50: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82FC7D54: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7D58: 37EBFFFF  addic. r31, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82FC7D5C: 4180004C  blt 0x82fc7da8
	if ctx.cr[0].lt {
	pc = 0x82FC7DA8; continue 'dispatch;
	}
	// 82FC7D60: 57FD1838  slwi r29, r31, 3
	ctx.r[29].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	pc = 0x82FC7D64; continue 'dispatch;
            }
            0x82FC7D64 => {
    //   block [0x82FC7D64..0x82FC7D9C)
	// 82FC7D64: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7D68: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82FC7D6C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7D70: 89630078  lbz r11, 0x78(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 82FC7D74: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC7D78: 41820024  beq 0x82fc7d9c
	if ctx.cr[0].eq {
	pc = 0x82FC7D9C; continue 'dispatch;
	}
	// 82FC7D7C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7D80: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82FC7D84: 816B0074  lwz r11, 0x74(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(116 as u32) ) } as u64;
	// 82FC7D88: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7D8C: 4E800421  bctrl
	ctx.lr = 0x82FC7D90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC7D90: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7D94: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82FC7D98: 40980010  bge cr6, 0x82fc7da8
	if !ctx.cr[6].lt {
	pc = 0x82FC7DA8; continue 'dispatch;
	}
            }
            0x82FC7D9C => {
    //   block [0x82FC7D9C..0x82FC7DA8)
	// 82FC7D9C: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82FC7DA0: 3BBDFFF8  addi r29, r29, -8
	ctx.r[29].s64 = ctx.r[29].s64 + -8;
	// 82FC7DA4: 4080FFC0  bge 0x82fc7d64
	if !ctx.cr[0].lt {
	pc = 0x82FC7D64; continue 'dispatch;
	}
	pc = 0x82FC7DA8; continue 'dispatch;
            }
            0x82FC7DA8 => {
    //   block [0x82FC7DA8..0x82FC7DB0)
	// 82FC7DA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC7DAC: 4BCE16AC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC7DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC7DB0 size=128
    let mut pc: u32 = 0x82FC7DB0;
    'dispatch: loop {
        match pc {
            0x82FC7DB0 => {
    //   block [0x82FC7DB0..0x82FC7DDC)
	// 82FC7DB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC7DB4: 4BCE164D  bl 0x82ca9400
	ctx.lr = 0x82FC7DB8;
	sub_82CA93D0(ctx, base);
	// 82FC7DB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC7DBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC7DC0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82FC7DC4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82FC7DC8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82FC7DCC: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7DD0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82FC7DD4: 419A0054  beq cr6, 0x82fc7e28
	if ctx.cr[6].eq {
	pc = 0x82FC7E28; continue 'dispatch;
	}
	// 82FC7DD8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82FC7DDC; continue 'dispatch;
            }
            0x82FC7DDC => {
    //   block [0x82FC7DDC..0x82FC7E18)
	// 82FC7DDC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7DE0: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82FC7DE4: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7DE8: 89630078  lbz r11, 0x78(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 82FC7DEC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC7DF0: 41820028  beq 0x82fc7e18
	if ctx.cr[0].eq {
	pc = 0x82FC7E18; continue 'dispatch;
	}
	// 82FC7DF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7DF8: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82FC7DFC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82FC7E00: 816B0078  lwz r11, 0x78(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 82FC7E04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7E08: 4E800421  bctrl
	ctx.lr = 0x82FC7E0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC7E0C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7E10: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC7E14: 40980014  bge cr6, 0x82fc7e28
	if !ctx.cr[6].lt {
	pc = 0x82FC7E28; continue 'dispatch;
	}
            }
            0x82FC7E18 => {
    //   block [0x82FC7E18..0x82FC7E28)
	// 82FC7E18: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82FC7E1C: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 82FC7E20: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82FC7E24: 4198FFB8  blt cr6, 0x82fc7ddc
	if ctx.cr[6].lt {
	pc = 0x82FC7DDC; continue 'dispatch;
	}
	pc = 0x82FC7E28; continue 'dispatch;
            }
            0x82FC7E28 => {
    //   block [0x82FC7E28..0x82FC7E30)
	// 82FC7E28: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82FC7E2C: 4BCE1624  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC7E30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC7E30 size=264
    let mut pc: u32 = 0x82FC7E30;
    'dispatch: loop {
        match pc {
            0x82FC7E30 => {
    //   block [0x82FC7E30..0x82FC7E58)
	// 82FC7E30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC7E34: 4BCE15C9  bl 0x82ca93fc
	ctx.lr = 0x82FC7E38;
	sub_82CA93D0(ctx, base);
	// 82FC7E38: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC7E3C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82FC7E40: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82FC7E44: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82FC7E48: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7E4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC7E50: 409900E0  ble cr6, 0x82fc7f30
	if !ctx.cr[6].gt {
	pc = 0x82FC7F30; continue 'dispatch;
	}
	// 82FC7E54: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82FC7E58; continue 'dispatch;
            }
            0x82FC7E58 => {
    //   block [0x82FC7E58..0x82FC7E8C)
	// 82FC7E58: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7E5C: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82FC7E60: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7E64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC7E68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7E6C: 816B0084  lwz r11, 0x84(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 82FC7E70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7E74: 4E800421  bctrl
	ctx.lr = 0x82FC7E78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC7E78: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82FC7E7C: 41980010  blt cr6, 0x82fc7e8c
	if ctx.cr[6].lt {
	pc = 0x82FC7E8C; continue 'dispatch;
	}
	// 82FC7E80: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 82FC7E84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FC7E88: 40990008  ble cr6, 0x82fc7e90
	if !ctx.cr[6].gt {
	pc = 0x82FC7E90; continue 'dispatch;
	}
            }
            0x82FC7E8C => {
    //   block [0x82FC7E8C..0x82FC7E90)
	// 82FC7E8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82FC7E90; continue 'dispatch;
            }
            0x82FC7E90 => {
    //   block [0x82FC7E90..0x82FC7F1C)
	// 82FC7E90: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC7E94: 41820088  beq 0x82fc7f1c
	if ctx.cr[0].eq {
	pc = 0x82FC7F1C; continue 'dispatch;
	}
	// 82FC7E98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7E9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC7EA0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7EA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7EA8: 4E800421  bctrl
	ctx.lr = 0x82FC7EAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC7EAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7EB0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC7EB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC7EB8: 419A0064  beq cr6, 0x82fc7f1c
	if ctx.cr[6].eq {
	pc = 0x82FC7F1C; continue 'dispatch;
	}
	// 82FC7EBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC7EC0: 83DA0000  lwz r30, 0(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7EC4: 4BF9EF85  bl 0x82f66e48
	ctx.lr = 0x82FC7EC8;
	sub_82F66E48(ctx, base);
	// 82FC7EC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82FC7ECC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82FC7ED0: 4BFA9601  bl 0x82f714d0
	ctx.lr = 0x82FC7ED4;
	sub_82F714D0(ctx, base);
	// 82FC7ED4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7ED8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82FC7EDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC7EE0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7EE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7EE8: 4E800421  bctrl
	ctx.lr = 0x82FC7EEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC7EEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82FC7EF0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7EF4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82FC7EF8: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82FC7EFC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82FC7F00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7F04: 4E800421  bctrl
	ctx.lr = 0x82FC7F08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC7F08: 89610050  lbz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC7F0C: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 82FC7F10: 4198000C  blt cr6, 0x82fc7f1c
	if ctx.cr[6].lt {
	pc = 0x82FC7F1C; continue 'dispatch;
	}
	// 82FC7F14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82FC7F18: 4BFAA409  bl 0x82f72320
	ctx.lr = 0x82FC7F1C;
	sub_82F72320(ctx, base);
            }
            0x82FC7F1C => {
    //   block [0x82FC7F1C..0x82FC7F30)
	// 82FC7F1C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7F20: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82FC7F24: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 82FC7F28: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC7F2C: 4198FF2C  blt cr6, 0x82fc7e58
	if ctx.cr[6].lt {
	pc = 0x82FC7E58; continue 'dispatch;
	}
	pc = 0x82FC7F30; continue 'dispatch;
            }
            0x82FC7F30 => {
    //   block [0x82FC7F30..0x82FC7F38)
	// 82FC7F30: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82FC7F34: 4BCE1518  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC7F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC7F38 size=128
    let mut pc: u32 = 0x82FC7F38;
    'dispatch: loop {
        match pc {
            0x82FC7F38 => {
    //   block [0x82FC7F38..0x82FC7F78)
	// 82FC7F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC7F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC7F40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC7F44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC7F48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC7F4C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC7F50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC7F54: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7F58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC7F5C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7F60: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82FC7F64: 419A0014  beq cr6, 0x82fc7f78
	if ctx.cr[6].eq {
	pc = 0x82FC7F78; continue 'dispatch;
	}
	// 82FC7F68: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC7F6C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7F70: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7F74: 4E800421  bctrl
	ctx.lr = 0x82FC7F78;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC7F78 => {
    //   block [0x82FC7F78..0x82FC7F98)
	// 82FC7F78: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7F7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC7F80: 419A0018  beq cr6, 0x82fc7f98
	if ctx.cr[6].eq {
	pc = 0x82FC7F98; continue 'dispatch;
	}
	// 82FC7F84: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC7F88: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC7F8C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7F90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC7F94: 4E800421  bctrl
	ctx.lr = 0x82FC7F98;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC7F98 => {
    //   block [0x82FC7F98..0x82FC7FB8)
	// 82FC7F98: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7F9C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC7FA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC7FA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC7FA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC7FAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC7FB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC7FB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC7FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC7FB8 size=112
    let mut pc: u32 = 0x82FC7FB8;
    'dispatch: loop {
        match pc {
            0x82FC7FB8 => {
    //   block [0x82FC7FB8..0x82FC7FE4)
	// 82FC7FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC7FBC: 4BCE1451  bl 0x82ca940c
	ctx.lr = 0x82FC7FC0;
	sub_82CA93D0(ctx, base);
	// 82FC7FC0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC7FC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC7FC8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82FC7FCC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC7FD0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7FD4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82FC7FD8: 409A000C  bne cr6, 0x82fc7fe4
	if !ctx.cr[6].eq {
	pc = 0x82FC7FE4; continue 'dispatch;
	}
	// 82FC7FDC: 4BF91685  bl 0x82f59660
	ctx.lr = 0x82FC7FE0;
	sub_82F59660(ctx, base);
	// 82FC7FE0: 48000040  b 0x82fc8020
	pc = 0x82FC8020; continue 'dispatch;
            }
            0x82FC7FE4 => {
    //   block [0x82FC7FE4..0x82FC8020)
	// 82FC7FE4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7FE8: 57BE1838  slwi r30, r29, 3
	ctx.r[30].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82FC7FEC: 7C7E5A14  add r3, r30, r11
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82FC7FF0: 4BF72961  bl 0x82f3a950
	ctx.lr = 0x82FC7FF4;
	sub_82F3A950(ctx, base);
	// 82FC7FF4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC7FF8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC7FFC: 7D7D5850  subf r11, r29, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 82FC8000: 7C7E5214  add r3, r30, r10
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82FC8004: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FC8008: 38830008  addi r4, r3, 8
	ctx.r[4].s64 = ctx.r[3].s64 + 8;
	// 82FC800C: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82FC8010: 4BCE8B21  bl 0x82cb0b30
	ctx.lr = 0x82FC8014;
	sub_82CB0B30(ctx, base);
	// 82FC8014: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC8018: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FC801C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82FC8020; continue 'dispatch;
            }
            0x82FC8020 => {
    //   block [0x82FC8020..0x82FC8028)
	// 82FC8020: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC8024: 4BCE1438  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC8028 size=124
    let mut pc: u32 = 0x82FC8028;
    'dispatch: loop {
        match pc {
            0x82FC8028 => {
    //   block [0x82FC8028..0x82FC807C)
	// 82FC8028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC802C: 4BCE13E1  bl 0x82ca940c
	ctx.lr = 0x82FC8030;
	sub_82CA93D0(ctx, base);
	// 82FC8030: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC8034: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC8038: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC803C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FC8040: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC8044: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82FC8048: 4BF91619  bl 0x82f59660
	ctx.lr = 0x82FC804C;
	sub_82F59660(ctx, base);
	// 82FC804C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC8050: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 82FC8054: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC8058: 40980024  bge cr6, 0x82fc807c
	if !ctx.cr[6].lt {
	pc = 0x82FC807C; continue 'dispatch;
	}
	// 82FC805C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8060: 57CA1838  slwi r10, r30, 3
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82FC8064: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82FC8068: 7C8A4A14  add r4, r10, r9
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82FC806C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FC8070: 38640008  addi r3, r4, 8
	ctx.r[3].s64 = ctx.r[4].s64 + 8;
	// 82FC8074: 55651838  slwi r5, r11, 3
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82FC8078: 4BCE8AB9  bl 0x82cb0b30
	ctx.lr = 0x82FC807C;
	sub_82CB0B30(ctx, base);
	pc = 0x82FC807C; continue 'dispatch;
            }
            0x82FC807C => {
    //   block [0x82FC807C..0x82FC809C)
	// 82FC807C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8080: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC8084: 7C6B5215  add. r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82FC8088: 41820014  beq 0x82fc809c
	if ctx.cr[0].eq {
	pc = 0x82FC809C; continue 'dispatch;
	}
	// 82FC808C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC8090: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC8094: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC8098: 4BFFFEA1  bl 0x82fc7f38
	ctx.lr = 0x82FC809C;
	sub_82FC7F38(ctx, base);
	pc = 0x82FC809C; continue 'dispatch;
            }
            0x82FC809C => {
    //   block [0x82FC809C..0x82FC80A4)
	// 82FC809C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC80A0: 4BCE13BC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC80A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC80A8 size=364
    let mut pc: u32 = 0x82FC80A8;
    'dispatch: loop {
        match pc {
            0x82FC80A8 => {
    //   block [0x82FC80A8..0x82FC80E0)
	// 82FC80A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC80AC: 4BCE1351  bl 0x82ca93fc
	ctx.lr = 0x82FC80B0;
	sub_82CA93D0(ctx, base);
	// 82FC80B0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC80B4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82FC80B8: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 82FC80BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC80C0: 7F1AC800  cmpw cr6, r26, r25
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[25].s32, &mut ctx.xer);
	// 82FC80C4: 419A0144  beq cr6, 0x82fc8208
	if ctx.cr[6].eq {
	pc = 0x82FC8208; continue 'dispatch;
	}
	// 82FC80C8: 4BFFF5F1  bl 0x82fc76b8
	ctx.lr = 0x82FC80CC;
	sub_82FC76B8(ctx, base);
	// 82FC80CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82FC80D0: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82FC80D4: 409A000C  bne cr6, 0x82fc80e0
	if !ctx.cr[6].eq {
	pc = 0x82FC80E0; continue 'dispatch;
	}
	// 82FC80D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82FC80DC: 48000130  b 0x82fc820c
	pc = 0x82FC820C; continue 'dispatch;
            }
            0x82FC80E0 => {
    //   block [0x82FC80E0..0x82FC816C)
	// 82FC80E0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82FC80E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC80E8: 4BFFF511  bl 0x82fc75f8
	ctx.lr = 0x82FC80EC;
	sub_82FC75F8(ctx, base);
	// 82FC80EC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC80F0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82FC80F4: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82FC80F8: 40980090  bge cr6, 0x82fc8188
	if !ctx.cr[6].lt {
	pc = 0x82FC8188; continue 'dispatch;
	}
	// 82FC80FC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8100: 576A1838  slwi r10, r27, 3
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82FC8104: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC8108: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC810C: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC8110: 7F0AC800  cmpw cr6, r10, r25
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[25].s32, &mut ctx.xer);
	// 82FC8114: 409A0074  bne cr6, 0x82fc8188
	if !ctx.cr[6].eq {
	pc = 0x82FC8188; continue 'dispatch;
	}
	// 82FC8118: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82FC811C: 57BC1838  slwi r28, r29, 3
	ctx.r[28].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82FC8120: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82FC8124: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82FC8128: 7FBC5A14  add r29, r28, r11
	ctx.r[29].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82FC812C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC8130: 4BFFFE09  bl 0x82fc7f38
	ctx.lr = 0x82FC8134;
	sub_82FC7F38(ctx, base);
	// 82FC8134: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC8138: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC813C: 4BFFFDFD  bl 0x82fc7f38
	ctx.lr = 0x82FC8140;
	sub_82FC7F38(ctx, base);
	// 82FC8140: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82FC8144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC8148: 4BFFFDF1  bl 0x82fc7f38
	ctx.lr = 0x82FC814C;
	sub_82FC7F38(ctx, base);
	// 82FC814C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC8150: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC8154: 419A0018  beq cr6, 0x82fc816c
	if ctx.cr[6].eq {
	pc = 0x82FC816C; continue 'dispatch;
	}
	// 82FC8158: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC815C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC8160: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC8164: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC8168: 4E800421  bctrl
	ctx.lr = 0x82FC816C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC816C => {
    //   block [0x82FC816C..0x82FC8188)
	// 82FC816C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8170: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82FC8174: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC8178: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC817C: 419A0070  beq cr6, 0x82fc81ec
	if ctx.cr[6].eq {
	pc = 0x82FC81EC; continue 'dispatch;
	}
	// 82FC8180: 934B0018  stw r26, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[26].u32 ) };
	// 82FC8184: 48000068  b 0x82fc81ec
	pc = 0x82FC81EC; continue 'dispatch;
            }
            0x82FC8188 => {
    //   block [0x82FC8188..0x82FC81BC)
	// 82FC8188: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82FC818C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8190: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC8194: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82FC8198: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82FC819C: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC81A0: 4BFFFD99  bl 0x82fc7f38
	ctx.lr = 0x82FC81A4;
	sub_82FC7F38(ctx, base);
	// 82FC81A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC81A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC81AC: 4BFFFE0D  bl 0x82fc7fb8
	ctx.lr = 0x82FC81B0;
	sub_82FC7FB8(ctx, base);
	// 82FC81B0: 7F1DD800  cmpw cr6, r29, r27
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82FC81B4: 40980008  bge cr6, 0x82fc81bc
	if !ctx.cr[6].lt {
	pc = 0x82FC81BC; continue 'dispatch;
	}
	// 82FC81B8: 3B7BFFFF  addi r27, r27, -1
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	pc = 0x82FC81BC; continue 'dispatch;
            }
            0x82FC81BC => {
    //   block [0x82FC81BC..0x82FC81EC)
	// 82FC81BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82FC81C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82FC81C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC81C8: 4BFFFE61  bl 0x82fc8028
	ctx.lr = 0x82FC81CC;
	sub_82FC8028(ctx, base);
	// 82FC81CC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC81D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC81D4: 419A0018  beq cr6, 0x82fc81ec
	if ctx.cr[6].eq {
	pc = 0x82FC81EC; continue 'dispatch;
	}
	// 82FC81D8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC81DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC81E0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC81E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC81E8: 4E800421  bctrl
	ctx.lr = 0x82FC81EC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC81EC => {
    //   block [0x82FC81EC..0x82FC8208)
	// 82FC81EC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC81F0: 576B1838  slwi r11, r27, 3
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC81F4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC81F8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC81FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC8200: 419A0008  beq cr6, 0x82fc8208
	if ctx.cr[6].eq {
	pc = 0x82FC8208; continue 'dispatch;
	}
	// 82FC8204: 932B0018  stw r25, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[25].u32 ) };
	pc = 0x82FC8208; continue 'dispatch;
            }
            0x82FC8208 => {
    //   block [0x82FC8208..0x82FC820C)
	// 82FC8208: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82FC820C; continue 'dispatch;
            }
            0x82FC820C => {
    //   block [0x82FC820C..0x82FC8214)
	// 82FC820C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82FC8210: 4BCE123C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8218(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC8218 size=112
    let mut pc: u32 = 0x82FC8218;
    'dispatch: loop {
        match pc {
            0x82FC8218 => {
    //   block [0x82FC8218..0x82FC8238)
	// 82FC8218: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC821C: 4BCE11ED  bl 0x82ca9408
	ctx.lr = 0x82FC8220;
	sub_82CA93D0(ctx, base);
	// 82FC8220: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC8224: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82FC8228: 83BC0004  lwz r29, 4(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC822C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82FC8230: 419A0044  beq cr6, 0x82fc8274
	if ctx.cr[6].eq {
	pc = 0x82FC8274; continue 'dispatch;
	}
	// 82FC8234: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82FC8238; continue 'dispatch;
            }
            0x82FC8238 => {
    //   block [0x82FC8238..0x82FC825C)
	// 82FC8238: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC823C: 7FDF5A14  add r30, r31, r11
	ctx.r[30].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82FC8240: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC8244: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82FC8248: 419A0014  beq cr6, 0x82fc825c
	if ctx.cr[6].eq {
	pc = 0x82FC825C; continue 'dispatch;
	}
	// 82FC824C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8250: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82FC8254: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC8258: 4E800421  bctrl
	ctx.lr = 0x82FC825C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC825C => {
    //   block [0x82FC825C..0x82FC8274)
	// 82FC825C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC8260: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82FC8264: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82FC8268: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82FC826C: 914B0028  stw r10, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 82FC8270: 4082FFC8  bne 0x82fc8238
	if !ctx.cr[0].eq {
	pc = 0x82FC8238; continue 'dispatch;
	}
	pc = 0x82FC8274; continue 'dispatch;
            }
            0x82FC8274 => {
    //   block [0x82FC8274..0x82FC8288)
	// 82FC8274: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC8278: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC827C: 4BF913E5  bl 0x82f59660
	ctx.lr = 0x82FC8280;
	sub_82F59660(ctx, base);
	// 82FC8280: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC8284: 4BCE11D4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC8288 size=104
    let mut pc: u32 = 0x82FC8288;
    'dispatch: loop {
        match pc {
            0x82FC8288 => {
    //   block [0x82FC8288..0x82FC82CC)
	// 82FC8288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC828C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC8290: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC8294: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC8298: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC829C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC82A0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC82A4: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC82A8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC82AC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC82B0: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC82B4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82FC82B8: 419A0014  beq cr6, 0x82fc82cc
	if ctx.cr[6].eq {
	pc = 0x82FC82CC; continue 'dispatch;
	}
	// 82FC82BC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC82C0: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82FC82C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC82C8: 4E800421  bctrl
	ctx.lr = 0x82FC82CC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC82CC => {
    //   block [0x82FC82CC..0x82FC82F0)
	// 82FC82CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC82D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC82D4: 4BFFFCE5  bl 0x82fc7fb8
	ctx.lr = 0x82FC82D8;
	sub_82FC7FB8(ctx, base);
	// 82FC82D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC82DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC82E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC82E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC82E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC82EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC82F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC82F0 size=324
    let mut pc: u32 = 0x82FC82F0;
    'dispatch: loop {
        match pc {
            0x82FC82F0 => {
    //   block [0x82FC82F0..0x82FC835C)
	// 82FC82F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC82F4: 4BCE110D  bl 0x82ca9400
	ctx.lr = 0x82FC82F8;
	sub_82CA93D0(ctx, base);
	// 82FC82F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC82FC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC8300: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82FC8304: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82FC8308: 83BE0048  lwz r29, 0x48(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 82FC830C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC8310: 4BFFF2E9  bl 0x82fc75f8
	ctx.lr = 0x82FC8314;
	sub_82FC75F8(ctx, base);
	// 82FC8314: 54CB063F  clrlwi. r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC8318: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82FC831C: 41820040  beq 0x82fc835c
	if ctx.cr[0].eq {
	pc = 0x82FC835C; continue 'dispatch;
	}
	// 82FC8320: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82FC8324: 41980038  blt cr6, 0x82fc835c
	if ctx.cr[6].lt {
	pc = 0x82FC835C; continue 'dispatch;
	}
	// 82FC8328: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC832C: 7F1B5800  cmpw cr6, r27, r11
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82FC8330: 4098002C  bge cr6, 0x82fc835c
	if !ctx.cr[6].lt {
	pc = 0x82FC835C; continue 'dispatch;
	}
	// 82FC8334: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8338: 576B1838  slwi r11, r27, 3
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC833C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC8340: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC8344: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC8348: 7F0BE800  cmpw cr6, r11, r29
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82FC834C: 409A0010  bne cr6, 0x82fc835c
	if !ctx.cr[6].eq {
	pc = 0x82FC835C; continue 'dispatch;
	}
	// 82FC8350: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82FC8354: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC8358: 4BFFFF31  bl 0x82fc8288
	ctx.lr = 0x82FC835C;
	sub_82FC8288(ctx, base);
	pc = 0x82FC835C; continue 'dispatch;
            }
            0x82FC835C => {
    //   block [0x82FC835C..0x82FC83E8)
	// 82FC835C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC8360: 93BA0018  stw r29, 0x18(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82FC8364: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82FC8368: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82FC836C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82FC8370: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82FC8374: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82FC8378: 4BF8BFD9  bl 0x82f54350
	ctx.lr = 0x82FC837C;
	sub_82F54350(ctx, base);
	// 82FC837C: 389E0020  addi r4, r30, 0x20
	ctx.r[4].s64 = ctx.r[30].s64 + 32;
	// 82FC8380: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC8384: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82FC8388: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82FC838C: E97E0000  ld r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 82FC8390: F97F0030  std r11, 0x30(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u64 ) };
	// 82FC8394: E97E0008  ld r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 82FC8398: F97F0038  std r11, 0x38(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u64 ) };
	// 82FC839C: E97E0010  ld r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	// 82FC83A0: F97F0040  std r11, 0x40(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u64 ) };
	// 82FC83A4: E97E0018  ld r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	// 82FC83A8: F97F0048  std r11, 0x48(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u64 ) };
	// 82FC83AC: 4BFA444D  bl 0x82f6c7f8
	ctx.lr = 0x82FC83B0;
	sub_82F6C7F8(ctx, base);
	// 82FC83B0: C01E0044  lfs f0, 0x44(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC83B4: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82FC83B8: A17E0050  lhz r11, 0x50(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC83BC: B17F0024  sth r11, 0x24(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u16 ) };
	// 82FC83C0: 817E0040  lwz r11, 0x40(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 82FC83C4: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82FC83C8: 809E0054  lwz r4, 0x54(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC83CC: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82FC83D0: 419A0018  beq cr6, 0x82fc83e8
	if ctx.cr[6].eq {
	pc = 0x82FC83E8; continue 'dispatch;
	}
	// 82FC83D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC83D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC83DC: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC83E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC83E4: 4E800421  bctrl
	ctx.lr = 0x82FC83E8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC83E8 => {
    //   block [0x82FC83E8..0x82FC842C)
	// 82FC83E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82FC83EC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82FC83F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FC83F4: 4BFFFC35  bl 0x82fc8028
	ctx.lr = 0x82FC83F8;
	sub_82FC8028(ctx, base);
	// 82FC83F8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC83FC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82FC8400: 816B0060  lwz r11, 0x60(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) } as u64;
	// 82FC8404: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC8408: 4E800421  bctrl
	ctx.lr = 0x82FC840C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC840C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC8410: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC8414: 419A0018  beq cr6, 0x82fc842c
	if ctx.cr[6].eq {
	pc = 0x82FC842C; continue 'dispatch;
	}
	// 82FC8418: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC841C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC8420: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC8424: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC8428: 4E800421  bctrl
	ctx.lr = 0x82FC842C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC842C => {
    //   block [0x82FC842C..0x82FC8434)
	// 82FC842C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82FC8430: 4BCE1020  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC8438 size=372
    let mut pc: u32 = 0x82FC8438;
    'dispatch: loop {
        match pc {
            0x82FC8438 => {
    //   block [0x82FC8438..0x82FC8468)
	// 82FC8438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC843C: 4BCE0FC9  bl 0x82ca9404
	ctx.lr = 0x82FC8440;
	sub_82CA93D0(ctx, base);
	// 82FC8440: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC8444: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82FC8448: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82FC844C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82FC8450: 837C0048  lwz r27, 0x48(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 82FC8454: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82FC8458: 4BFFF1A1  bl 0x82fc75f8
	ctx.lr = 0x82FC845C;
	sub_82FC75F8(ctx, base);
	// 82FC845C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC8460: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC8464: 4198001C  blt cr6, 0x82fc8480
	if ctx.cr[6].lt {
	pc = 0x82FC8480; continue 'dispatch;
	}
	pc = 0x82FC8468; continue 'dispatch;
            }
            0x82FC8468 => {
    //   block [0x82FC8468..0x82FC8480)
	// 82FC8468: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82FC846C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82FC8470: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82FC8474: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC8478: 4BFFFE79  bl 0x82fc82f0
	ctx.lr = 0x82FC847C;
	sub_82FC82F0(ctx, base);
	// 82FC847C: 48000128  b 0x82fc85a4
	pc = 0x82FC85A4; continue 'dispatch;
            }
            0x82FC8480 => {
    //   block [0x82FC8480..0x82FC84B8)
	// 82FC8480: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8484: 546B1838  slwi r11, r3, 3
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC8488: 7FCB5214  add r30, r11, r10
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC848C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC8490: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC8494: 7F0BD800  cmpw cr6, r11, r27
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[27].s32, &mut ctx.xer);
	// 82FC8498: 409AFFD0  bne cr6, 0x82fc8468
	if !ctx.cr[6].eq {
	pc = 0x82FC8468; continue 'dispatch;
	}
	// 82FC849C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC84A0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82FC84A4: 419A0014  beq cr6, 0x82fc84b8
	if ctx.cr[6].eq {
	pc = 0x82FC84B8; continue 'dispatch;
	}
	// 82FC84A8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC84AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC84B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC84B4: 4E800421  bctrl
	ctx.lr = 0x82FC84B8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC84B8 => {
    //   block [0x82FC84B8..0x82FC8500)
	// 82FC84B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC84BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC84C0: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC84C4: 937F0018  stw r27, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[27].u32 ) };
	// 82FC84C8: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC84CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC84D0: 4E800421  bctrl
	ctx.lr = 0x82FC84D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC84D4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC84D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC84DC: 556B07FA  rlwinm r11, r11, 0, 0x1f, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC84E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC84E4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC84E8: 4BF8BE69  bl 0x82f54350
	ctx.lr = 0x82FC84EC;
	sub_82F54350(ctx, base);
	// 82FC84EC: 897C0053  lbz r11, 0x53(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(83 as u32) ) } as u64;
	// 82FC84F0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC84F4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82FC84F8: 40820008  bne 0x82fc8500
	if !ctx.cr[0].eq {
	pc = 0x82FC8500; continue 'dispatch;
	}
	// 82FC84FC: 397D0030  addi r11, r29, 0x30
	ctx.r[11].s64 = ctx.r[29].s64 + 48;
            }
            0x82FC8500 => {
    //   block [0x82FC8500..0x82FC8538)
	// 82FC8500: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82FC8504: 393F0030  addi r9, r31, 0x30
	ctx.r[9].s64 = ctx.r[31].s64 + 48;
	// 82FC8508: 389C0020  addi r4, r28, 0x20
	ctx.r[4].s64 = ctx.r[28].s64 + 32;
	// 82FC850C: F95F0030  std r10, 0x30(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u64 ) };
	// 82FC8510: E94B0008  ld r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82FC8514: F95F0038  std r10, 0x38(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u64 ) };
	// 82FC8518: E94B0010  ld r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	// 82FC851C: F95F0040  std r10, 0x40(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[10].u64 ) };
	// 82FC8520: E96B0018  ld r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	// 82FC8524: F97F0048  std r11, 0x48(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u64 ) };
	// 82FC8528: 897C0052  lbz r11, 0x52(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(82 as u32) ) } as u64;
	// 82FC852C: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC8530: 40820008  bne 0x82fc8538
	if !ctx.cr[0].eq {
	pc = 0x82FC8538; continue 'dispatch;
	}
	// 82FC8534: 389D0050  addi r4, r29, 0x50
	ctx.r[4].s64 = ctx.r[29].s64 + 80;
	pc = 0x82FC8538; continue 'dispatch;
            }
            0x82FC8538 => {
    //   block [0x82FC8538..0x82FC8550)
	// 82FC8538: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82FC853C: 4BFA42BD  bl 0x82f6c7f8
	ctx.lr = 0x82FC8540;
	sub_82F6C7F8(ctx, base);
	// 82FC8540: 817C0040  lwz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 82FC8544: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC8548: 409A0008  bne cr6, 0x82fc8550
	if !ctx.cr[6].eq {
	pc = 0x82FC8550; continue 'dispatch;
	}
	// 82FC854C: 817D0074  lwz r11, 0x74(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(116 as u32) ) } as u64;
	pc = 0x82FC8550; continue 'dispatch;
            }
            0x82FC8550 => {
    //   block [0x82FC8550..0x82FC8584)
	// 82FC8550: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82FC8554: C01C0044  lfs f0, 0x44(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC8558: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82FC855C: A17C0050  lhz r11, 0x50(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC8560: B17F0024  sth r11, 0x24(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u16 ) };
	// 82FC8564: 809C0054  lwz r4, 0x54(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC8568: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 82FC856C: 419A0018  beq cr6, 0x82fc8584
	if ctx.cr[6].eq {
	pc = 0x82FC8584; continue 'dispatch;
	}
	// 82FC8570: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8574: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC8578: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC857C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC8580: 4E800421  bctrl
	ctx.lr = 0x82FC8584;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC8584 => {
    //   block [0x82FC8584..0x82FC85A4)
	// 82FC8584: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82FC8588: 419A001C  beq cr6, 0x82fc85a4
	if ctx.cr[6].eq {
	pc = 0x82FC85A4; continue 'dispatch;
	}
	// 82FC858C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC8590: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC8594: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC8598: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC859C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC85A0: 4E800421  bctrl
	ctx.lr = 0x82FC85A4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC85A4 => {
    //   block [0x82FC85A4..0x82FC85AC)
	// 82FC85A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC85A8: 4BCE0EAC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC85B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC85B0 size=184
    let mut pc: u32 = 0x82FC85B0;
    'dispatch: loop {
        match pc {
            0x82FC85B0 => {
    //   block [0x82FC85B0..0x82FC8610)
	// 82FC85B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC85B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC85B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC85BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC85C0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82FC85C4: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC85C8: 4BFFF031  bl 0x82fc75f8
	ctx.lr = 0x82FC85CC;
	sub_82FC75F8(ctx, base);
	// 82FC85CC: 7F03F840  cmplw cr6, r3, r31
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82FC85D0: 40980084  bge cr6, 0x82fc8654
	if !ctx.cr[6].lt {
	pc = 0x82FC8654; continue 'dispatch;
	}
	// 82FC85D4: 81260000  lwz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC85D8: 546B1838  slwi r11, r3, 3
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC85DC: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82FC85E0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC85E4: 810A0018  lwz r8, 0x18(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC85E8: 7F082000  cmpw cr6, r8, r4
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82FC85EC: 409A0068  bne cr6, 0x82fc8654
	if !ctx.cr[6].eq {
	pc = 0x82FC8654; continue 'dispatch;
	}
	// 82FC85F0: 81050000  lwz r8, 0(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC85F4: 3CE00004  lis r7, 4
	ctx.r[7].s64 = 262144;
	// 82FC85F8: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82FC85FC: 419A004C  beq cr6, 0x82fc8648
	if ctx.cr[6].eq {
	pc = 0x82FC8648; continue 'dispatch;
	}
	// 82FC8600: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC8604: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82FC8608: 419A0040  beq cr6, 0x82fc8648
	if ctx.cr[6].eq {
	pc = 0x82FC8648; continue 'dispatch;
	}
	// 82FC860C: 39430001  addi r10, r3, 1
	ctx.r[10].s64 = ctx.r[3].s64 + 1;
	pc = 0x82FC8610; continue 'dispatch;
            }
            0x82FC8610 => {
    //   block [0x82FC8610..0x82FC8648)
	// 82FC8610: 7F0AF800  cmpw cr6, r10, r31
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82FC8614: 40980040  bge cr6, 0x82fc8654
	if !ctx.cr[6].lt {
	pc = 0x82FC8654; continue 'dispatch;
	}
	// 82FC8618: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC861C: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC8620: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82FC8624: 409A0030  bne cr6, 0x82fc8654
	if !ctx.cr[6].eq {
	pc = 0x82FC8654; continue 'dispatch;
	}
	// 82FC8628: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 82FC862C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82FC8630: 546B1838  slwi r11, r3, 3
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC8634: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82FC8638: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC863C: 80E70014  lwz r7, 0x14(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC8640: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82FC8644: 409AFFCC  bne cr6, 0x82fc8610
	if !ctx.cr[6].eq {
	pc = 0x82FC8610; continue 'dispatch;
	}
	pc = 0x82FC8648; continue 'dispatch;
            }
            0x82FC8648 => {
    //   block [0x82FC8648..0x82FC8654)
	// 82FC8648: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82FC864C: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 82FC8650: 4BFFFC39  bl 0x82fc8288
	ctx.lr = 0x82FC8654;
	sub_82FC8288(ctx, base);
	pc = 0x82FC8654; continue 'dispatch;
            }
            0x82FC8654 => {
    //   block [0x82FC8654..0x82FC8668)
	// 82FC8654: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FC8658: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC865C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC8660: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC8664: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC8668 size=100
    let mut pc: u32 = 0x82FC8668;
    'dispatch: loop {
        match pc {
            0x82FC8668 => {
    //   block [0x82FC8668..0x82FC868C)
	// 82FC8668: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC866C: 4BCE0DA1  bl 0x82ca940c
	ctx.lr = 0x82FC8670;
	sub_82CA93D0(ctx, base);
	// 82FC8670: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC8674: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82FC8678: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82FC867C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC8680: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC8684: 40990040  ble cr6, 0x82fc86c4
	if !ctx.cr[6].gt {
	pc = 0x82FC86C4; continue 'dispatch;
	}
	// 82FC8688: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82FC868C; continue 'dispatch;
            }
            0x82FC868C => {
    //   block [0x82FC868C..0x82FC86B0)
	// 82FC868C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8690: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FC8694: 556BFFFF  rlwinm. r11, r11, 0x1f, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC8698: 41820018  beq 0x82fc86b0
	if ctx.cr[0].eq {
	pc = 0x82FC86B0; continue 'dispatch;
	}
	// 82FC869C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC86A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC86A4: 4BFFFBE5  bl 0x82fc8288
	ctx.lr = 0x82FC86A8;
	sub_82FC8288(ctx, base);
	// 82FC86A8: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 82FC86AC: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	pc = 0x82FC86B0; continue 'dispatch;
            }
            0x82FC86B0 => {
    //   block [0x82FC86B0..0x82FC86C4)
	// 82FC86B0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC86B4: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82FC86B8: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82FC86BC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC86C0: 4198FFCC  blt cr6, 0x82fc868c
	if ctx.cr[6].lt {
	pc = 0x82FC868C; continue 'dispatch;
	}
	pc = 0x82FC86C4; continue 'dispatch;
            }
            0x82FC86C4 => {
    //   block [0x82FC86C4..0x82FC86CC)
	// 82FC86C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC86C8: 4BCE0D94  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC86D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC86D0 size=16
    let mut pc: u32 = 0x82FC86D0;
    'dispatch: loop {
        match pc {
            0x82FC86D0 => {
    //   block [0x82FC86D0..0x82FC86E0)
	// 82FC86D0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC86D4: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82FC86D8: 99630099  stb r11, 0x99(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(153 as u32), ctx.r[11].u8 ) };
	// 82FC86DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC86E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC86E0 size=16
    let mut pc: u32 = 0x82FC86E0;
    'dispatch: loop {
        match pc {
            0x82FC86E0 => {
    //   block [0x82FC86E0..0x82FC86F0)
	// 82FC86E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC86E4: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82FC86E8: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82FC86EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC86F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC86F0 size=64
    let mut pc: u32 = 0x82FC86F0;
    'dispatch: loop {
        match pc {
            0x82FC86F0 => {
    //   block [0x82FC86F0..0x82FC8730)
	// 82FC86F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC86F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC86F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC86FC: FC00101E  fctiwz f0, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[2].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[2].f64.trunc() as i32 as i64 };
	// 82FC8700: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82FC8704: FDA0081E  fctiwz f13, f1
	ctx.f[13].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82FC8708: 38630014  addi r3, r3, 0x14
	ctx.r[3].s64 = ctx.r[3].s64 + 20;
	// 82FC870C: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FC8710: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC8714: D9A10058  stfd f13, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[13].u64 ) };
	// 82FC8718: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82FC871C: 4BF80D1D  bl 0x82f49438
	ctx.lr = 0x82FC8720;
	sub_82F49438(ctx, base);
	// 82FC8720: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC8724: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC8728: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC872C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC8730 size=80
    let mut pc: u32 = 0x82FC8730;
    'dispatch: loop {
        match pc {
            0x82FC8730 => {
    //   block [0x82FC8730..0x82FC8780)
	// 82FC8730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC8734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC8738: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC873C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC8740: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC8744: FC00101E  fctiwz f0, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[2].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[2].f64.trunc() as i32 as i64 };
	// 82FC8748: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FC874C: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC8750: FDA0081E  fctiwz f13, f1
	ctx.f[13].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82FC8754: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82FC8758: D9A10050  stfd f13, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[13].u64 ) };
	// 82FC875C: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC8760: 4BF830A1  bl 0x82f4b800
	ctx.lr = 0x82FC8764;
	sub_82F4B800(ctx, base);
	// 82FC8764: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC8768: 997F0099  stb r11, 0x99(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(153 as u32), ctx.r[11].u8 ) };
	// 82FC876C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC8770: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC8774: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC8778: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC877C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC8780 size=104
    let mut pc: u32 = 0x82FC8780;
    'dispatch: loop {
        match pc {
            0x82FC8780 => {
    //   block [0x82FC8780..0x82FC87E8)
	// 82FC8780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC8784: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC8788: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC878C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC8790: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC8794: FC00201E  fctiwz f0, f4
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[4].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[4].f64.trunc() as i32 as i64 };
	// 82FC8798: FDA0181E  fctiwz f13, f3
	ctx.f[13].s64 = if ctx.f[3].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[3].f64.trunc() as i32 as i64 };
	// 82FC879C: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FC87A0: D9A10058  stfd f13, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[13].u64 ) };
	// 82FC87A4: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC87A8: 80C1005C  lwz r6, 0x5c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82FC87AC: FD80101E  fctiwz f12, f2
	ctx.f[12].s64 = if ctx.f[2].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[2].f64.trunc() as i32 as i64 };
	// 82FC87B0: FD60081E  fctiwz f11, f1
	ctx.f[11].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82FC87B4: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82FC87B8: D9810050  stfd f12, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[12].u64 ) };
	// 82FC87BC: 80A10054  lwz r5, 0x54(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC87C0: D9610058  stfd f11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[11].u64 ) };
	// 82FC87C4: 8081005C  lwz r4, 0x5c(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82FC87C8: 4BF83051  bl 0x82f4b818
	ctx.lr = 0x82FC87CC;
	sub_82F4B818(ctx, base);
	// 82FC87CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC87D0: 997F0099  stb r11, 0x99(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(153 as u32), ctx.r[11].u8 ) };
	// 82FC87D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC87D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC87DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC87E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC87E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC87E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC87E8 size=120
    let mut pc: u32 = 0x82FC87E8;
    'dispatch: loop {
        match pc {
            0x82FC87E8 => {
    //   block [0x82FC87E8..0x82FC8828)
	// 82FC87E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC87EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC87F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC87F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC87F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC87FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC8800: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82FC8804: 4BF7FACD  bl 0x82f482d0
	ctx.lr = 0x82FC8808;
	sub_82F482D0(ctx, base);
	// 82FC8808: 38600094  li r3, 0x94
	ctx.r[3].s64 = 148;
	// 82FC880C: 4BF35055  bl 0x82efd860
	ctx.lr = 0x82FC8810;
	sub_82EFD860(ctx, base);
	// 82FC8810: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC8814: 41820014  beq 0x82fc8828
	if ctx.cr[0].eq {
	pc = 0x82FC8828; continue 'dispatch;
	}
	// 82FC8818: 38801FF2  li r4, 0x1ff2
	ctx.r[4].s64 = 8178;
	// 82FC881C: 4BF8399D  bl 0x82f4c1b8
	ctx.lr = 0x82FC8820;
	sub_82F4C1B8(ctx, base);
	// 82FC8820: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC8824: 48000008  b 0x82fc882c
	pc = 0x82FC882C; continue 'dispatch;
            }
            0x82FC8828 => {
    //   block [0x82FC8828..0x82FC882C)
	// 82FC8828: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82FC882C; continue 'dispatch;
            }
            0x82FC882C => {
    //   block [0x82FC882C..0x82FC883C)
	// 82FC882C: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8830: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC8834: 419A0008  beq cr6, 0x82fc883c
	if ctx.cr[6].eq {
	pc = 0x82FC883C; continue 'dispatch;
	}
	// 82FC8838: 4BF2FA61  bl 0x82ef8298
	ctx.lr = 0x82FC883C;
	sub_82EF8298(ctx, base);
	pc = 0x82FC883C; continue 'dispatch;
            }
            0x82FC883C => {
    //   block [0x82FC883C..0x82FC8860)
	// 82FC883C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC8840: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82FC8844: 997F0098  stb r11, 0x98(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u8 ) };
	// 82FC8848: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC884C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC8850: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC8854: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC8858: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC885C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC8860 size=40
    let mut pc: u32 = 0x82FC8860;
    'dispatch: loop {
        match pc {
            0x82FC8860 => {
    //   block [0x82FC8860..0x82FC8878)
	// 82FC8860: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8864: 548A063F  clrlwi. r10, r4, 0x18
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC8868: 41820010  beq 0x82fc8878
	if ctx.cr[0].eq {
	pc = 0x82FC8878; continue 'dispatch;
	}
	// 82FC886C: 894B0044  lbz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82FC8870: 614A0008  ori r10, r10, 8
	ctx.r[10].u64 = ctx.r[10].u64 | 8;
	// 82FC8874: 4800000C  b 0x82fc8880
	pc = 0x82FC8880; continue 'dispatch;
            }
            0x82FC8878 => {
    //   block [0x82FC8878..0x82FC8880)
	// 82FC8878: 894B0044  lbz r10, 0x44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 82FC887C: 714A00F7  andi. r10, r10, 0xf7
	ctx.r[10].u64 = ctx.r[10].u64 & 247;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	pc = 0x82FC8880; continue 'dispatch;
            }
            0x82FC8880 => {
    //   block [0x82FC8880..0x82FC8888)
	// 82FC8880: 994B0044  stb r10, 0x44(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(68 as u32), ctx.r[10].u8 ) };
	// 82FC8884: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC8888 size=80
    let mut pc: u32 = 0x82FC8888;
    'dispatch: loop {
        match pc {
            0x82FC8888 => {
    //   block [0x82FC8888..0x82FC88C4)
	// 82FC8888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC888C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC8890: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC8894: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC8898: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82FC889C: 386B0014  addi r3, r11, 0x14
	ctx.r[3].s64 = ctx.r[11].s64 + 20;
	// 82FC88A0: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 82FC88A4: 83EB0010  lwz r31, 0x10(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC88A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82FC88AC: 419A0018  beq cr6, 0x82fc88c4
	if ctx.cr[6].eq {
	pc = 0x82FC88C4; continue 'dispatch;
	}
	// 82FC88B0: 38BF0034  addi r5, r31, 0x34
	ctx.r[5].s64 = ctx.r[31].s64 + 52;
	// 82FC88B4: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82FC88B8: 4BF80469  bl 0x82f48d20
	ctx.lr = 0x82FC88BC;
	sub_82F48D20(ctx, base);
	// 82FC88BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC88C0: 997F0069  stb r11, 0x69(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(105 as u32), ctx.r[11].u8 ) };
	pc = 0x82FC88C4; continue 'dispatch;
            }
            0x82FC88C4 => {
    //   block [0x82FC88C4..0x82FC88D8)
	// 82FC88C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FC88C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC88CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC88D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC88D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC88D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC88D8 size=84
    let mut pc: u32 = 0x82FC88D8;
    'dispatch: loop {
        match pc {
            0x82FC88D8 => {
    //   block [0x82FC88D8..0x82FC892C)
	// 82FC88D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC88DC: 4BCE0B31  bl 0x82ca940c
	ctx.lr = 0x82FC88E0;
	sub_82CA93D0(ctx, base);
	// 82FC88E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC88E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC88E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC88EC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82FC88F0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82FC88F4: 997F0069  stb r11, 0x69(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(105 as u32), ctx.r[11].u8 ) };
	// 82FC88F8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC88FC: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 82FC8900: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC8904: 4BF81EFD  bl 0x82f4a800
	ctx.lr = 0x82FC8908;
	sub_82F4A800(ctx, base);
	// 82FC8908: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC890C: 1D7E0030  mulli r11, r30, 0x30
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 48 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC8910: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC8914: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC8918: 386BFFD0  addi r3, r11, -0x30
	ctx.r[3].s64 = ctx.r[11].s64 + -48;
	// 82FC891C: 4BFF73AD  bl 0x82fbfcc8
	ctx.lr = 0x82FC8920;
	sub_82FBFCC8(ctx, base);
	// 82FC8920: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC8924: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC8928: 4BCE0B34  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC8930 size=84
    let mut pc: u32 = 0x82FC8930;
    'dispatch: loop {
        match pc {
            0x82FC8930 => {
    //   block [0x82FC8930..0x82FC8984)
	// 82FC8930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC8934: 4BCE0AD9  bl 0x82ca940c
	ctx.lr = 0x82FC8938;
	sub_82CA93D0(ctx, base);
	// 82FC8938: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC893C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC8940: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC8944: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82FC8948: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82FC894C: 997F0069  stb r11, 0x69(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(105 as u32), ctx.r[11].u8 ) };
	// 82FC8950: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FC8954: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 82FC8958: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC895C: 4BF81F9D  bl 0x82f4a8f8
	ctx.lr = 0x82FC8960;
	sub_82F4A8F8(ctx, base);
	// 82FC8960: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC8964: 1D7E0018  mulli r11, r30, 0x18
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 24 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC8968: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC896C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC8970: 386BFFE8  addi r3, r11, -0x18
	ctx.r[3].s64 = ctx.r[11].s64 + -24;
	// 82FC8974: 4BFF828D  bl 0x82fc0c00
	ctx.lr = 0x82FC8978;
	sub_82FC0C00(ctx, base);
	// 82FC8978: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FC897C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC8980: 4BCE0ADC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8988(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC8988 size=172
    let mut pc: u32 = 0x82FC8988;
    'dispatch: loop {
        match pc {
            0x82FC8988 => {
    //   block [0x82FC8988..0x82FC89D8)
	// 82FC8988: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC898C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC8990: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC8994: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC8998: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC899C: FC000E5E  fctidz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[1].f64.trunc() as i64 };
	// 82FC89A0: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FC89A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC89A8: 54CA063F  clrlwi. r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC89AC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82FC89B0: 389F0080  addi r4, r31, 0x80
	ctx.r[4].s64 = ctx.r[31].s64 + 128;
	// 82FC89B4: A1610056  lhz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82FC89B8: B17F0084  sth r11, 0x84(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u16 ) };
	// 82FC89BC: 90BF0088  stw r5, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[5].u32 ) };
	// 82FC89C0: A17F0090  lhz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82FC89C4: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC89C8: B17F0090  sth r11, 0x90(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u16 ) };
	// 82FC89CC: 4182000C  beq 0x82fc89d8
	if ctx.cr[0].eq {
	pc = 0x82FC89D8; continue 'dispatch;
	}
	// 82FC89D0: 53CB07DE  rlwimi r11, r30, 0, 0x1f, 0xf
	ctx.r[11].u64 = (((ctx.r[30].u32).rotate_left(0) as u64) & 0xFFFFFFFFFFFF0001) | (ctx.r[11].u64 & 0x000000000000FFFE);
	// 82FC89D4: B1640010  sth r11, 0x10(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	pc = 0x82FC89D8; continue 'dispatch;
            }
            0x82FC89D8 => {
    //   block [0x82FC89D8..0x82FC8A34)
	// 82FC89D8: A1640010  lhz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC89DC: 550A0632  rlwinm r10, r8, 0, 0x18, 0x19
	ctx.r[10].u64 = ctx.r[8].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC89E0: 50EB077C  rlwimi r11, r7, 0, 0x1d, 0x1e
	ctx.r[11].u64 = (((ctx.r[7].u32).rotate_left(0) as u64) & 0x0000000000000006) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFFF9);
	// 82FC89E4: B1640010  sth r11, 0x10(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 82FC89E8: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82FC89EC: 556B06AE  rlwinm r11, r11, 0, 0x1a, 0x17
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC89F0: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82FC89F4: 510B15AE  rlwimi r11, r8, 2, 0x16, 0x17
	ctx.r[11].u64 = (((ctx.r[8].u32).rotate_left(2) as u64) & 0x0000000000000300) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFCFF);
	// 82FC89F8: B1640010  sth r11, 0x10(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 82FC89FC: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82FC8A00: 512B06B6  rlwimi r11, r9, 0, 0x1a, 0x1b
	ctx.r[11].u64 = (((ctx.r[9].u32).rotate_left(0) as u64) & 0x0000000000000030) | (ctx.r[11].u64 & 0xFFFFFFFFFFFFFFCF);
	// 82FC8A04: B1640010  sth r11, 0x10(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[11].u16 ) };
	// 82FC8A08: D05F0094  stfs f2, 0x94(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82FC8A0C: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8A10: 4BFFFF21  bl 0x82fc8930
	ctx.lr = 0x82FC8A14;
	sub_82FC8930(ctx, base);
	// 82FC8A14: 907F001C  stw r3, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 82FC8A18: 9BDF0099  stb r30, 0x99(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(153 as u32), ctx.r[30].u8 ) };
	// 82FC8A1C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC8A20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC8A24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC8A28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC8A2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC8A30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC8A38 size=92
    let mut pc: u32 = 0x82FC8A38;
    'dispatch: loop {
        match pc {
            0x82FC8A38 => {
    //   block [0x82FC8A38..0x82FC8A94)
	// 82FC8A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC8A3C: 4BCE09D1  bl 0x82ca940c
	ctx.lr = 0x82FC8A40;
	sub_82CA93D0(ctx, base);
	// 82FC8A40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC8A44: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC8A48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC8A4C: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 82FC8A50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC8A54: 4BFF6F5D  bl 0x82fbf9b0
	ctx.lr = 0x82FC8A58;
	sub_82FBF9B0(ctx, base);
	// 82FC8A58: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82FC8A5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC8A60: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8A64: 93BF0054  stw r29, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82FC8A68: 4BFFFE71  bl 0x82fc88d8
	ctx.lr = 0x82FC8A6C;
	sub_82FC88D8(ctx, base);
	// 82FC8A6C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8A70: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82FC8A74: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82FC8A78: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8A7C: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC8A80: 1D4A0030  mulli r10, r10, 0x30
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 48 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC8A84: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC8A88: 386BFFD0  addi r3, r11, -0x30
	ctx.r[3].s64 = ctx.r[11].s64 + -48;
	// 82FC8A8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC8A90: 4BCE09CC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC8A98 size=96
    let mut pc: u32 = 0x82FC8A98;
    'dispatch: loop {
        match pc {
            0x82FC8A98 => {
    //   block [0x82FC8A98..0x82FC8AC8)
	// 82FC8A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC8A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC8AA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC8AA4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC8AA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC8AAC: 897F0099  lbz r11, 0x99(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(153 as u32) ) } as u64;
	// 82FC8AB0: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC8AB4: 40820014  bne 0x82fc8ac8
	if !ctx.cr[0].eq {
	pc = 0x82FC8AC8; continue 'dispatch;
	}
	// 82FC8AB8: 389F0080  addi r4, r31, 0x80
	ctx.r[4].s64 = ctx.r[31].s64 + 128;
	// 82FC8ABC: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8AC0: 4BFFFE71  bl 0x82fc8930
	ctx.lr = 0x82FC8AC4;
	sub_82FC8930(ctx, base);
	// 82FC8AC4: 907F001C  stw r3, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	pc = 0x82FC8AC8; continue 'dispatch;
            }
            0x82FC8AC8 => {
    //   block [0x82FC8AC8..0x82FC8AF8)
	// 82FC8AC8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8ACC: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FC8AD0: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC8AD4: 1D4A0018  mulli r10, r10, 0x18
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 24 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC8AD8: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FC8ADC: 386BFFE8  addi r3, r11, -0x18
	ctx.r[3].s64 = ctx.r[11].s64 + -24;
	// 82FC8AE0: 4BFF73E9  bl 0x82fbfec8
	ctx.lr = 0x82FC8AE4;
	sub_82FBFEC8(ctx, base);
	// 82FC8AE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FC8AE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC8AEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC8AF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC8AF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8AF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC8AF8 size=72
    let mut pc: u32 = 0x82FC8AF8;
    'dispatch: loop {
        match pc {
            0x82FC8AF8 => {
    //   block [0x82FC8AF8..0x82FC8B40)
	// 82FC8AF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC8AFC: 4BCE0911  bl 0x82ca940c
	ctx.lr = 0x82FC8B00;
	sub_82CA93D0(ctx, base);
	// 82FC8B00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC8B04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC8B08: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82FC8B0C: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 82FC8B10: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC8B14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FC8B18: 4BFF6E99  bl 0x82fbf9b0
	ctx.lr = 0x82FC8B1C;
	sub_82FBF9B0(ctx, base);
	// 82FC8B1C: 93BF0054  stw r29, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 82FC8B20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC8B24: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8B28: 4BFFFDB1  bl 0x82fc88d8
	ctx.lr = 0x82FC8B2C;
	sub_82FC88D8(ctx, base);
	// 82FC8B2C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC8B30: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82FC8B34: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82FC8B38: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC8B3C: 4BCE0920  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC8B40 size=60
    let mut pc: u32 = 0x82FC8B40;
    'dispatch: loop {
        match pc {
            0x82FC8B40 => {
    //   block [0x82FC8B40..0x82FC8B74)
	// 82FC8B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC8B44: 4BCE08C9  bl 0x82ca940c
	ctx.lr = 0x82FC8B48;
	sub_82CA93D0(ctx, base);
	// 82FC8B48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC8B4C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82FC8B50: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82FC8B54: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82FC8B58: 4BFFFEE1  bl 0x82fc8a38
	ctx.lr = 0x82FC8B5C;
	sub_82FC8A38(ctx, base);
	// 82FC8B5C: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC8B60: 41820014  beq 0x82fc8b74
	if ctx.cr[0].eq {
	pc = 0x82FC8B74; continue 'dispatch;
	}
	// 82FC8B64: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82FC8B68: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82FC8B6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82FC8B70: 4BFF7219  bl 0x82fbfd88
	ctx.lr = 0x82FC8B74;
	sub_82FBFD88(ctx, base);
	pc = 0x82FC8B74; continue 'dispatch;
            }
            0x82FC8B74 => {
    //   block [0x82FC8B74..0x82FC8B7C)
	// 82FC8B74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC8B78: 4BCE08E4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8B80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC8B80 size=140
    let mut pc: u32 = 0x82FC8B80;
    'dispatch: loop {
        match pc {
            0x82FC8B80 => {
    //   block [0x82FC8B80..0x82FC8BC8)
	// 82FC8B80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC8B84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC8B88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC8B8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC8B90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC8B94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC8B98: 4BF34DB1  bl 0x82efd948
	ctx.lr = 0x82FC8B9C;
	sub_82EFD948(ctx, base);
	// 82FC8B9C: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FC8BA0: 38600094  li r3, 0x94
	ctx.r[3].s64 = 148;
	// 82FC8BA4: 396B2FF0  addi r11, r11, 0x2ff0
	ctx.r[11].s64 = ctx.r[11].s64 + 12272;
	// 82FC8BA8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC8BAC: 4BF34CB5  bl 0x82efd860
	ctx.lr = 0x82FC8BB0;
	sub_82EFD860(ctx, base);
	// 82FC8BB0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82FC8BB4: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC8BB8: 41820010  beq 0x82fc8bc8
	if ctx.cr[0].eq {
	pc = 0x82FC8BC8; continue 'dispatch;
	}
	// 82FC8BBC: 38801FF2  li r4, 0x1ff2
	ctx.r[4].s64 = 8178;
	// 82FC8BC0: 4BF835F9  bl 0x82f4c1b8
	ctx.lr = 0x82FC8BC4;
	sub_82F4C1B8(ctx, base);
	// 82FC8BC4: 48000008  b 0x82fc8bcc
	pc = 0x82FC8BCC; continue 'dispatch;
            }
            0x82FC8BC8 => {
    //   block [0x82FC8BC8..0x82FC8BCC)
	// 82FC8BC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x82FC8BCC; continue 'dispatch;
            }
            0x82FC8BCC => {
    //   block [0x82FC8BCC..0x82FC8C0C)
	// 82FC8BCC: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82FC8BD0: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82FC8BD4: 4BF8359D  bl 0x82f4c170
	ctx.lr = 0x82FC8BD8;
	sub_82F4C170(ctx, base);
	// 82FC8BD8: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 82FC8BDC: 4BFF7095  bl 0x82fbfc70
	ctx.lr = 0x82FC8BE0;
	sub_82FBFC70(ctx, base);
	// 82FC8BE0: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 82FC8BE4: 4BFF6E35  bl 0x82fbfa18
	ctx.lr = 0x82FC8BE8;
	sub_82FBFA18(ctx, base);
	// 82FC8BE8: 9BDF0098  stb r30, 0x98(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[30].u8 ) };
	// 82FC8BEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC8BF0: 9BDF0099  stb r30, 0x99(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(153 as u32), ctx.r[30].u8 ) };
	// 82FC8BF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC8BF8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC8BFC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC8C00: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC8C04: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC8C08: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC8C10 size=108
    let mut pc: u32 = 0x82FC8C10;
    'dispatch: loop {
        match pc {
            0x82FC8C10 => {
    //   block [0x82FC8C10..0x82FC8C68)
	// 82FC8C10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC8C14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC8C18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC8C1C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC8C20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC8C24: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82FC8C28: 4BF83549  bl 0x82f4c170
	ctx.lr = 0x82FC8C2C;
	sub_82F4C170(ctx, base);
	// 82FC8C2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FC8C30: 38BF0034  addi r5, r31, 0x34
	ctx.r[5].s64 = ctx.r[31].s64 + 52;
	// 82FC8C34: 99610085  stb r11, 0x85(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(133 as u32), ctx.r[11].u8 ) };
	// 82FC8C38: 389F0028  addi r4, r31, 0x28
	ctx.r[4].s64 = ctx.r[31].s64 + 40;
	// 82FC8C3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82FC8C40: 4BF800E1  bl 0x82f48d20
	ctx.lr = 0x82FC8C44;
	sub_82F48D20(ctx, base);
	// 82FC8C44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC8C48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC8C4C: 997F0069  stb r11, 0x69(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(105 as u32), ctx.r[11].u8 ) };
	// 82FC8C50: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82FC8C54: 4BF81E15  bl 0x82f4aa68
	ctx.lr = 0x82FC8C58;
	sub_82F4AA68(ctx, base);
	// 82FC8C58: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82FC8C5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC8C60: 419A0008  beq cr6, 0x82fc8c68
	if ctx.cr[6].eq {
	pc = 0x82FC8C68; continue 'dispatch;
	}
	// 82FC8C64: 4BF34C3D  bl 0x82efd8a0
	ctx.lr = 0x82FC8C68;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FC8C68; continue 'dispatch;
            }
            0x82FC8C68 => {
    //   block [0x82FC8C68..0x82FC8C7C)
	// 82FC8C68: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82FC8C6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC8C70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC8C74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC8C78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC8C80 size=192
    let mut pc: u32 = 0x82FC8C80;
    'dispatch: loop {
        match pc {
            0x82FC8C80 => {
    //   block [0x82FC8C80..0x82FC8CB8)
	// 82FC8C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC8C84: 4BCE0781  bl 0x82ca9404
	ctx.lr = 0x82FC8C88;
	sub_82CA93D0(ctx, base);
	// 82FC8C88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC8C8C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82FC8C90: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82FC8C94: 817D003C  lwz r11, 0x3c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(60 as u32) ) } as u64;
	// 82FC8C98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC8C9C: 419A0098  beq cr6, 0x82fc8d34
	if ctx.cr[6].eq {
	pc = 0x82FC8D34; continue 'dispatch;
	}
	// 82FC8CA0: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC8CA4: 3BFD0014  addi r31, r29, 0x14
	ctx.r[31].s64 = ctx.r[29].s64 + 20;
	// 82FC8CA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC8CAC: 419A000C  beq cr6, 0x82fc8cb8
	if ctx.cr[6].eq {
	pc = 0x82FC8CB8; continue 'dispatch;
	}
	// 82FC8CB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC8CB4: 4BF82B85  bl 0x82f4b838
	ctx.lr = 0x82FC8CB8;
	sub_82F4B838(ctx, base);
	pc = 0x82FC8CB8; continue 'dispatch;
            }
            0x82FC8CB8 => {
    //   block [0x82FC8CB8..0x82FC8CCC)
	// 82FC8CB8: 897D0098  lbz r11, 0x98(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(152 as u32) ) } as u64;
	// 82FC8CBC: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC8CC0: 4182000C  beq 0x82fc8ccc
	if ctx.cr[0].eq {
	pc = 0x82FC8CCC; continue 'dispatch;
	}
	// 82FC8CC4: 807D0010  lwz r3, 0x10(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8CC8: 4BFFFF49  bl 0x82fc8c10
	ctx.lr = 0x82FC8CCC;
	sub_82FC8C10(ctx, base);
	pc = 0x82FC8CCC; continue 'dispatch;
            }
            0x82FC8CCC => {
    //   block [0x82FC8CCC..0x82FC8CF4)
	// 82FC8CCC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC8CD0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82FC8CD4: 839D0010  lwz r28, 0x10(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8CD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC8CDC: 419A0018  beq cr6, 0x82fc8cf4
	if ctx.cr[6].eq {
	pc = 0x82FC8CF4; continue 'dispatch;
	}
	// 82FC8CE0: 38BC0034  addi r5, r28, 0x34
	ctx.r[5].s64 = ctx.r[28].s64 + 52;
	// 82FC8CE4: 389C0028  addi r4, r28, 0x28
	ctx.r[4].s64 = ctx.r[28].s64 + 40;
	// 82FC8CE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC8CEC: 4BF80035  bl 0x82f48d20
	ctx.lr = 0x82FC8CF0;
	sub_82F48D20(ctx, base);
	// 82FC8CF0: 9BDC0069  stb r30, 0x69(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(105 as u32), ctx.r[30].u8 ) };
	pc = 0x82FC8CF4; continue 'dispatch;
            }
            0x82FC8CF4 => {
    //   block [0x82FC8CF4..0x82FC8D34)
	// 82FC8CF4: 807D0010  lwz r3, 0x10(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8CF8: 4BF82B81  bl 0x82f4b878
	ctx.lr = 0x82FC8CFC;
	sub_82F4B878(ctx, base);
	// 82FC8CFC: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8D00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82FC8D04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC8D08: 9BCB0068  stb r30, 0x68(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), ctx.r[30].u8 ) };
	// 82FC8D0C: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 82FC8D10: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82FC8D14: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82FC8D18: 9BDF0035  stb r30, 0x35(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(53 as u32), ctx.r[30].u8 ) };
	// 82FC8D1C: 80BF0018  lwz r5, 0x18(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC8D20: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC8D24: 4BF80715  bl 0x82f49438
	ctx.lr = 0x82FC8D28;
	sub_82F49438(ctx, base);
	// 82FC8D28: 9B7D0098  stb r27, 0x98(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(152 as u32), ctx.r[27].u8 ) };
	// 82FC8D2C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82FC8D30: 48000008  b 0x82fc8d38
	pc = 0x82FC8D38; continue 'dispatch;
            }
            0x82FC8D34 => {
    //   block [0x82FC8D34..0x82FC8D38)
	// 82FC8D34: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82FC8D38; continue 'dispatch;
            }
            0x82FC8D38 => {
    //   block [0x82FC8D38..0x82FC8D40)
	// 82FC8D38: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC8D3C: 4BCE0718  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC8D40 size=72
    let mut pc: u32 = 0x82FC8D40;
    'dispatch: loop {
        match pc {
            0x82FC8D40 => {
    //   block [0x82FC8D40..0x82FC8D88)
	// 82FC8D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC8D44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC8D48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC8D4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC8D50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC8D54: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC8D58: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82FC8D5C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC8D60: 4BFFFF21  bl 0x82fc8c80
	ctx.lr = 0x82FC8D64;
	sub_82FC8C80(ctx, base);
	// 82FC8D64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC8D68: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8D6C: 4BF81715  bl 0x82f4a480
	ctx.lr = 0x82FC8D70;
	sub_82F4A480(ctx, base);
	// 82FC8D70: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC8D74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC8D78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC8D7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC8D80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC8D84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC8D88 size=208
    let mut pc: u32 = 0x82FC8D88;
    'dispatch: loop {
        match pc {
            0x82FC8D88 => {
    //   block [0x82FC8D88..0x82FC8DD4)
	// 82FC8D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC8D8C: 4BCE0675  bl 0x82ca9400
	ctx.lr = 0x82FC8D90;
	sub_82CA93D0(ctx, base);
	// 82FC8D90: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC8D94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC8D98: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82FC8D9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC8DA0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FC8DA4: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82FC8DA8: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82FC8DAC: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82FC8DB0: 4BFFFED1  bl 0x82fc8c80
	ctx.lr = 0x82FC8DB4;
	sub_82FC8C80(ctx, base);
	// 82FC8DB4: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8DB8: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC8DBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC8DC0: 409A0014  bne cr6, 0x82fc8dd4
	if !ctx.cr[6].eq {
	pc = 0x82FC8DD4; continue 'dispatch;
	}
	// 82FC8DC4: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FC8DC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC8DCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FC8DD0: 419A0008  beq cr6, 0x82fc8dd8
	if ctx.cr[6].eq {
	pc = 0x82FC8DD8; continue 'dispatch;
	}
	pc = 0x82FC8DD4; continue 'dispatch;
            }
            0x82FC8DD4 => {
    //   block [0x82FC8DD4..0x82FC8DD8)
	// 82FC8DD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82FC8DD8; continue 'dispatch;
            }
            0x82FC8DD8 => {
    //   block [0x82FC8DD8..0x82FC8E24)
	// 82FC8DD8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC8DDC: 40820074  bne 0x82fc8e50
	if !ctx.cr[0].eq {
	pc = 0x82FC8E50; continue 'dispatch;
	}
	// 82FC8DE0: 89630068  lbz r11, 0x68(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 82FC8DE4: 280B0000  cmplwi r11, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC8DE8: 4082003C  bne 0x82fc8e24
	if !ctx.cr[0].eq {
	pc = 0x82FC8E24; continue 'dispatch;
	}
	// 82FC8DEC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82FC8DF0: 4BF81691  bl 0x82f4a480
	ctx.lr = 0x82FC8DF4;
	sub_82F4A480(ctx, base);
	// 82FC8DF4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8DF8: C001006C  lfs f0, 0x6c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC8DFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82FC8E00: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC8E04: C1810064  lfs f12, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC8E08: C1610060  lfs f11, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC8E0C: D16B0048  stfs f11, 0x48(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82FC8E10: D18B004C  stfs f12, 0x4c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82FC8E14: D1AB0050  stfs f13, 0x50(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82FC8E18: D00B0054  stfs f0, 0x54(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82FC8E1C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8E20: 994B0068  stb r10, 0x68(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), ctx.r[10].u8 ) };
	pc = 0x82FC8E24; continue 'dispatch;
            }
            0x82FC8E24 => {
    //   block [0x82FC8E24..0x82FC8E50)
	// 82FC8E24: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8E28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC8E2C: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82FC8E30: 3943001C  addi r10, r3, 0x1c
	ctx.r[10].s64 = ctx.r[3].s64 + 28;
	// 82FC8E34: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82FC8E38: 39230010  addi r9, r3, 0x10
	ctx.r[9].s64 = ctx.r[3].s64 + 16;
	// 82FC8E3C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82FC8E40: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82FC8E44: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82FC8E48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC8E4C: 4BF82B05  bl 0x82f4b950
	ctx.lr = 0x82FC8E50;
	sub_82F4B950(ctx, base);
	pc = 0x82FC8E50; continue 'dispatch;
            }
            0x82FC8E50 => {
    //   block [0x82FC8E50..0x82FC8E58)
	// 82FC8E50: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82FC8E54: 4BCE05FC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC8E58 size=76
    let mut pc: u32 = 0x82FC8E58;
    'dispatch: loop {
        match pc {
            0x82FC8E58 => {
    //   block [0x82FC8E58..0x82FC8EA4)
	// 82FC8E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC8E5C: 4BCE05AD  bl 0x82ca9408
	ctx.lr = 0x82FC8E60;
	sub_82CA93D0(ctx, base);
	// 82FC8E60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC8E64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC8E68: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82FC8E6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC8E70: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FC8E74: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82FC8E78: 4BFFFE09  bl 0x82fc8c80
	ctx.lr = 0x82FC8E7C;
	sub_82FC8C80(ctx, base);
	// 82FC8E7C: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8E80: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82FC8E84: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82FC8E88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC8E8C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8E90: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8E94: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC8E98: 4E800421  bctrl
	ctx.lr = 0x82FC8E9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC8E9C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC8EA0: 4BCE05B8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FC8EA8 size=24
    let mut pc: u32 = 0x82FC8EA8;
    'dispatch: loop {
        match pc {
            0x82FC8EA8 => {
    //   block [0x82FC8EA8..0x82FC8EC0)
	// 82FC8EA8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC8EAC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC8EB0: 7D6A5810  subfc r11, r10, r11
	ctx.xer.ca = ctx.r[11].u32 >= ctx.r[10].u32;
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82FC8EB4: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82FC8EB8: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 82FC8EBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FC8EC0 size=152
    let mut pc: u32 = 0x82FC8EC0;
    'dispatch: loop {
        match pc {
            0x82FC8EC0 => {
    //   block [0x82FC8EC0..0x82FC8ECC)
	// 82FC8EC0: 34E4FFFF  addic. r7, r4, -1
	ctx.xer.ca = (ctx.r[4].u32 > (!(-1 as u32)));
	ctx.r[7].s64 = ctx.r[4].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82FC8EC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC8EC8: 40810050  ble 0x82fc8f18
	if !ctx.cr[0].gt {
	pc = 0x82FC8F18; continue 'dispatch;
	}
	pc = 0x82FC8ECC; continue 'dispatch;
            }
            0x82FC8ECC => {
    //   block [0x82FC8ECC..0x82FC8F0C)
	// 82FC8ECC: 2F07FFFF  cmpwi cr6, r7, -1
	ctx.cr[6].compare_i32(ctx.r[7].s32, -1, &mut ctx.xer);
	// 82FC8ED0: 419A0048  beq cr6, 0x82fc8f18
	if ctx.cr[6].eq {
	pc = 0x82FC8F18; continue 'dispatch;
	}
	// 82FC8ED4: 7D475A14  add r10, r7, r11
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82FC8ED8: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8EDC: 80C50000  lwz r6, 0(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8EE0: 7D4A0E70  srawi r10, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 82FC8EE4: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82FC8EE8: 1D2A001C  mulli r9, r10, 0x1c
	ctx.r[9].s32 = ((ctx.r[10].s32 as i64 * 28 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82FC8EEC: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82FC8EF0: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC8EF4: 7D264851  subf. r9, r6, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC8EF8: 41820060  beq 0x82fc8f58
	if ctx.cr[0].eq {
		crate::recompiler::externs::call(ctx, base, 0x82FC8F58);
		return;
	}
	// 82FC8EFC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC8F00: 4098000C  bge cr6, 0x82fc8f0c
	if !ctx.cr[6].lt {
	pc = 0x82FC8F0C; continue 'dispatch;
	}
	// 82FC8F04: 396A0001  addi r11, r10, 1
	ctx.r[11].s64 = ctx.r[10].s64 + 1;
	// 82FC8F08: 48000008  b 0x82fc8f10
	pc = 0x82FC8F10; continue 'dispatch;
            }
            0x82FC8F0C => {
    //   block [0x82FC8F0C..0x82FC8F10)
	// 82FC8F0C: 38EAFFFF  addi r7, r10, -1
	ctx.r[7].s64 = ctx.r[10].s64 + -1;
	pc = 0x82FC8F10; continue 'dispatch;
            }
            0x82FC8F10 => {
    //   block [0x82FC8F10..0x82FC8F18)
	// 82FC8F10: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82FC8F14: 4198FFB8  blt cr6, 0x82fc8ecc
	if ctx.cr[6].lt {
	pc = 0x82FC8ECC; continue 'dispatch;
	}
	pc = 0x82FC8F18; continue 'dispatch;
            }
            0x82FC8F18 => {
    //   block [0x82FC8F18..0x82FC8F34)
	// 82FC8F18: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82FC8F1C: 41990034  bgt cr6, 0x82fc8f50
	if ctx.cr[6].gt {
	pc = 0x82FC8F50; continue 'dispatch;
	}
	// 82FC8F20: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8F24: 1D4B001C  mulli r10, r11, 0x1c
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 28 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC8F28: 81050000  lwz r8, 0(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8F2C: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82FC8F30: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	pc = 0x82FC8F34; continue 'dispatch;
            }
            0x82FC8F34 => {
    //   block [0x82FC8F34..0x82FC8F50)
	// 82FC8F34: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8F38: 7D284851  subf. r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC8F3C: 40800014  bge 0x82fc8f50
	if !ctx.cr[0].lt {
	pc = 0x82FC8F50; continue 'dispatch;
	}
	// 82FC8F40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FC8F44: 394A001C  addi r10, r10, 0x1c
	ctx.r[10].s64 = ctx.r[10].s64 + 28;
	// 82FC8F48: 7F0B3800  cmpw cr6, r11, r7
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82FC8F4C: 4099FFE8  ble cr6, 0x82fc8f34
	if !ctx.cr[6].gt {
	pc = 0x82FC8F34; continue 'dispatch;
	}
	pc = 0x82FC8F50; continue 'dispatch;
            }
            0x82FC8F50 => {
    //   block [0x82FC8F50..0x82FC8F58)
	// 82FC8F50: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82FC8F54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC8F60 size=60
    let mut pc: u32 = 0x82FC8F60;
    'dispatch: loop {
        match pc {
            0x82FC8F60 => {
    //   block [0x82FC8F60..0x82FC8F78)
	// 82FC8F60: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC8F64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC8F68: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82FC8F6C: 419A0028  beq cr6, 0x82fc8f94
	if ctx.cr[6].eq {
	pc = 0x82FC8F94; continue 'dispatch;
	}
	// 82FC8F70: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8F74: 39480008  addi r10, r8, 8
	ctx.r[10].s64 = ctx.r[8].s64 + 8;
	pc = 0x82FC8F78; continue 'dispatch;
            }
            0x82FC8F78 => {
    //   block [0x82FC8F78..0x82FC8F94)
	// 82FC8F78: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8F7C: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82FC8F80: 419A001C  beq cr6, 0x82fc8f9c
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82FC8F9C);
		return;
	}
	// 82FC8F84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FC8F88: 394A001C  addi r10, r10, 0x1c
	ctx.r[10].s64 = ctx.r[10].s64 + 28;
	// 82FC8F8C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82FC8F90: 4198FFE8  blt cr6, 0x82fc8f78
	if ctx.cr[6].lt {
	pc = 0x82FC8F78; continue 'dispatch;
	}
	pc = 0x82FC8F94; continue 'dispatch;
            }
            0x82FC8F94 => {
    //   block [0x82FC8F94..0x82FC8F9C)
	// 82FC8F94: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82FC8F98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC8FA8 size=48
    let mut pc: u32 = 0x82FC8FA8;
    'dispatch: loop {
        match pc {
            0x82FC8FA8 => {
    //   block [0x82FC8FA8..0x82FC8FCC)
	// 82FC8FA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC8FAC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC8FB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC8FB4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC8FB8: 40980014  bge cr6, 0x82fc8fcc
	if !ctx.cr[6].lt {
	pc = 0x82FC8FCC; continue 'dispatch;
	}
	// 82FC8FBC: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC8FC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC8FC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC8FC8: 409A0008  bne cr6, 0x82fc8fd0
	if !ctx.cr[6].eq {
	pc = 0x82FC8FD0; continue 'dispatch;
	}
	pc = 0x82FC8FCC; continue 'dispatch;
            }
            0x82FC8FCC => {
    //   block [0x82FC8FCC..0x82FC8FD0)
	// 82FC8FCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82FC8FD0; continue 'dispatch;
            }
            0x82FC8FD0 => {
    //   block [0x82FC8FD0..0x82FC8FD8)
	// 82FC8FD0: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82FC8FD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC8FD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC8FD8 size=172
    let mut pc: u32 = 0x82FC8FD8;
    'dispatch: loop {
        match pc {
            0x82FC8FD8 => {
    //   block [0x82FC8FD8..0x82FC8FF0)
	// 82FC8FD8: 8964000C  lbz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC8FDC: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC8FE0: 41820010  beq 0x82fc8ff0
	if ctx.cr[0].eq {
	pc = 0x82FC8FF0; continue 'dispatch;
	}
	// 82FC8FE4: 8963000C  lbz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC8FE8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 82FC8FEC: 9963000C  stb r11, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	pc = 0x82FC8FF0; continue 'dispatch;
            }
            0x82FC8FF0 => {
    //   block [0x82FC8FF0..0x82FC9008)
	// 82FC8FF0: 8964000C  lbz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC8FF4: 556B07BD  rlwinm. r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC8FF8: 41820010  beq 0x82fc9008
	if ctx.cr[0].eq {
	pc = 0x82FC9008; continue 'dispatch;
	}
	// 82FC8FFC: 8963000C  lbz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC9000: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 82FC9004: 9963000C  stb r11, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	pc = 0x82FC9008; continue 'dispatch;
            }
            0x82FC9008 => {
    //   block [0x82FC9008..0x82FC9020)
	// 82FC9008: 8964000C  lbz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC900C: 556B077B  rlwinm. r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC9010: 41820010  beq 0x82fc9020
	if ctx.cr[0].eq {
	pc = 0x82FC9020; continue 'dispatch;
	}
	// 82FC9014: 8963000C  lbz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC9018: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 82FC901C: 9963000C  stb r11, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	pc = 0x82FC9020; continue 'dispatch;
            }
            0x82FC9020 => {
    //   block [0x82FC9020..0x82FC9040)
	// 82FC9020: 8964000C  lbz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC9024: 556B0739  rlwinm. r11, r11, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC9028: 41820018  beq 0x82fc9040
	if ctx.cr[0].eq {
	pc = 0x82FC9040; continue 'dispatch;
	}
	// 82FC902C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9030: 8943000C  lbz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC9034: 614A0008  ori r10, r10, 8
	ctx.r[10].u64 = ctx.r[10].u64 | 8;
	// 82FC9038: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FC903C: 9943000C  stb r10, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u8 ) };
	pc = 0x82FC9040; continue 'dispatch;
            }
            0x82FC9040 => {
    //   block [0x82FC9040..0x82FC9060)
	// 82FC9040: 8964000C  lbz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC9044: 556B06F7  rlwinm. r11, r11, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC9048: 41820018  beq 0x82fc9060
	if ctx.cr[0].eq {
	pc = 0x82FC9060; continue 'dispatch;
	}
	// 82FC904C: 8963000C  lbz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC9050: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC9054: 616B0010  ori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 16;
	// 82FC9058: 9963000C  stb r11, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82FC905C: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x82FC9060; continue 'dispatch;
            }
            0x82FC9060 => {
    //   block [0x82FC9060..0x82FC9084)
	// 82FC9060: 8964000C  lbz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC9064: 556B06B5  rlwinm. r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC9068: 4D820020  beqlr
	if ctx.cr[0].eq { return; }
	// 82FC906C: 8963000C  lbz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC9070: 81440008  lwz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC9074: 616B0020  ori r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 | 32;
	// 82FC9078: 9963000C  stb r11, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 82FC907C: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82FC9080: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC9088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC9088 size=472
    let mut pc: u32 = 0x82FC9088;
    'dispatch: loop {
        match pc {
            0x82FC9088 => {
    //   block [0x82FC9088..0x82FC90C0)
	// 82FC9088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC908C: 4BCE036D  bl 0x82ca93f8
	ctx.lr = 0x82FC9090;
	sub_82CA93D0(ctx, base);
	// 82FC9090: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC9094: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82FC9098: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC909C: 3B40FFFF  li r26, -1
	ctx.r[26].s64 = -1;
	// 82FC90A0: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82FC90A4: 3BBF000C  addi r29, r31, 0xc
	ctx.r[29].s64 = ctx.r[31].s64 + 12;
	// 82FC90A8: 9B210068  stb r25, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u8 ) };
	// 82FC90AC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82FC90B0: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 82FC90B4: 3BDD000C  addi r30, r29, 0xc
	ctx.r[30].s64 = ctx.r[29].s64 + 12;
	// 82FC90B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82FC90BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	pc = 0x82FC90C0; continue 'dispatch;
            }
            0x82FC90C0 => {
    //   block [0x82FC90C0..0x82FC90DC)
	// 82FC90C0: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC90C4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82FC90C8: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC90CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82FC90D0: 419A0144  beq cr6, 0x82fc9214
	if ctx.cr[6].eq {
	pc = 0x82FC9214; continue 'dispatch;
	}
	// 82FC90D4: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 82FC90D8: 7D3B4B78  mr r27, r9
	ctx.r[27].u64 = ctx.r[9].u64;
	pc = 0x82FC90DC; continue 'dispatch;
            }
            0x82FC90DC => {
    //   block [0x82FC90DC..0x82FC9124)
	// 82FC90DC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC90E0: 809F0028  lwz r4, 0x28(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC90E4: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC90E8: 7D29E214  add r9, r9, r28
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[28].u64;
	// 82FC90EC: 89090018  lbz r8, 0x18(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC90F0: 7D032039  and. r3, r8, r4
	ctx.r[3].u64 = ctx.r[8].u64 & ctx.r[4].u64;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82FC90F4: 41820114  beq 0x82fc9208
	if ctx.cr[0].eq {
	pc = 0x82FC9208; continue 'dispatch;
	}
	// 82FC90F8: 80A90004  lwz r5, 4(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC90FC: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC9100: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82FC9104: 419A0020  beq cr6, 0x82fc9124
	if ctx.cr[6].eq {
	pc = 0x82FC9124; continue 'dispatch;
	}
	// 82FC9108: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC910C: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82FC9110: 41980014  blt cr6, 0x82fc9124
	if ctx.cr[6].lt {
	pc = 0x82FC9124; continue 'dispatch;
	}
	// 82FC9114: 7CE72A14  add r7, r7, r5
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[5].u64;
	// 82FC9118: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82FC911C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82FC9120: 41980008  blt cr6, 0x82fc9128
	if ctx.cr[6].lt {
	pc = 0x82FC9128; continue 'dispatch;
	}
	pc = 0x82FC9124; continue 'dispatch;
            }
            0x82FC9124 => {
    //   block [0x82FC9124..0x82FC9128)
	// 82FC9124: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x82FC9128; continue 'dispatch;
            }
            0x82FC9128 => {
    //   block [0x82FC9128..0x82FC918C)
	// 82FC9128: 54E7063F  clrlwi. r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 82FC912C: 418200A4  beq 0x82fc91d0
	if ctx.cr[0].eq {
	pc = 0x82FC91D0; continue 'dispatch;
	}
	// 82FC9130: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC9134: 409A0058  bne cr6, 0x82fc918c
	if !ctx.cr[6].eq {
	pc = 0x82FC918C; continue 'dispatch;
	}
	// 82FC9138: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC913C: 7D682850  subf r11, r8, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[8].s64;
	// 82FC9140: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 82FC9144: 80A90008  lwz r5, 8(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC9148: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 82FC914C: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC9150: 80E90010  lwz r7, 0x10(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC9154: 80890014  lwz r4, 0x14(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC9158: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC915C: 8B090018  lbz r24, 0x18(r9)
	ctx.r[24].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC9160: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82FC9164: 7F033040  cmplw cr6, r3, r6
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82FC9168: 90A10058  stw r5, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u32 ) };
	// 82FC916C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82FC9170: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82FC9174: 90E10060  stw r7, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[7].u32 ) };
	// 82FC9178: 90810064  stw r4, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[4].u32 ) };
	// 82FC917C: 9B010068  stb r24, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[24].u8 ) };
	// 82FC9180: 40990050  ble cr6, 0x82fc91d0
	if !ctx.cr[6].gt {
	pc = 0x82FC91D0; continue 'dispatch;
	}
	// 82FC9184: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82FC9188: 48000040  b 0x82fc91c8
	pc = 0x82FC91C8; continue 'dispatch;
            }
            0x82FC918C => {
    //   block [0x82FC918C..0x82FC91C4)
	// 82FC918C: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82FC9190: 419A0040  beq cr6, 0x82fc91d0
	if ctx.cr[6].eq {
	pc = 0x82FC91D0; continue 'dispatch;
	}
	// 82FC9194: 3889000C  addi r4, r9, 0xc
	ctx.r[4].s64 = ctx.r[9].s64 + 12;
	// 82FC9198: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82FC919C: 4BFFFE3D  bl 0x82fc8fd8
	ctx.lr = 0x82FC91A0;
	sub_82FC8FD8(ctx, base);
	// 82FC91A0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC91A4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC91A8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC91AC: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC91B0: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC91B4: 7D083A14  add r8, r8, r7
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 82FC91B8: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC91BC: 40980008  bge cr6, 0x82fc91c4
	if !ctx.cr[6].lt {
	pc = 0x82FC91C4; continue 'dispatch;
	}
	// 82FC91C0: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	pc = 0x82FC91C4; continue 'dispatch;
            }
            0x82FC91C4 => {
    //   block [0x82FC91C4..0x82FC91C8)
	// 82FC91C4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	pc = 0x82FC91C8; continue 'dispatch;
            }
            0x82FC91C8 => {
    //   block [0x82FC91C8..0x82FC91D0)
	// 82FC91C8: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC91CC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x82FC91D0; continue 'dispatch;
            }
            0x82FC91D0 => {
    //   block [0x82FC91D0..0x82FC91EC)
	// 82FC91D0: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC91D4: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC91D8: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82FC91DC: 4099002C  ble cr6, 0x82fc9208
	if !ctx.cr[6].gt {
	pc = 0x82FC9208; continue 'dispatch;
	}
	// 82FC91E0: 7F064840  cmplw cr6, r6, r9
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82FC91E4: 41980008  blt cr6, 0x82fc91ec
	if ctx.cr[6].lt {
	pc = 0x82FC91EC; continue 'dispatch;
	}
	// 82FC91E8: 7D264B78  mr r6, r9
	ctx.r[6].u64 = ctx.r[9].u64;
	pc = 0x82FC91EC; continue 'dispatch;
            }
            0x82FC91EC => {
    //   block [0x82FC91EC..0x82FC9208)
	// 82FC91EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC91F0: 419A0018  beq cr6, 0x82fc9208
	if ctx.cr[6].eq {
	pc = 0x82FC9208; continue 'dispatch;
	}
	// 82FC91F4: 7D2B5214  add r9, r11, r10
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC91F8: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82FC91FC: 4099000C  ble cr6, 0x82fc9208
	if !ctx.cr[6].gt {
	pc = 0x82FC9208; continue 'dispatch;
	}
	// 82FC9200: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82FC9204: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x82FC9208; continue 'dispatch;
            }
            0x82FC9208 => {
    //   block [0x82FC9208..0x82FC9214)
	// 82FC9208: 377BFFFF  addic. r27, r27, -1
	ctx.xer.ca = (ctx.r[27].u32 > (!(-1 as u32)));
	ctx.r[27].s64 = ctx.r[27].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82FC920C: 3B9C001C  addi r28, r28, 0x1c
	ctx.r[28].s64 = ctx.r[28].s64 + 28;
	// 82FC9210: 4082FECC  bne 0x82fc90dc
	if !ctx.cr[0].eq {
	pc = 0x82FC90DC; continue 'dispatch;
	}
	pc = 0x82FC9214; continue 'dispatch;
            }
            0x82FC9214 => {
    //   block [0x82FC9214..0x82FC9258)
	// 82FC9214: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82FC9218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC921C: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82FC9220: 80E10060  lwz r7, 0x60(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82FC9224: 80A10064  lwz r5, 0x64(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82FC9228: 88810068  lbz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82FC922C: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82FC9230: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC9234: 913D0008  stw r9, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82FC9238: 911E0000  stw r8, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82FC923C: 90FE0004  stw r7, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82FC9240: 90BE0008  stw r5, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 82FC9244: 989E000C  stb r4, 0xc(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[4].u8 ) };
	// 82FC9248: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82FC924C: 409A000C  bne cr6, 0x82fc9258
	if !ctx.cr[6].eq {
	pc = 0x82FC9258; continue 'dispatch;
	}
	// 82FC9250: 2F06FFFF  cmpwi cr6, r6, -1
	ctx.cr[6].compare_i32(ctx.r[6].s32, -1, &mut ctx.xer);
	// 82FC9254: 409AFE6C  bne cr6, 0x82fc90c0
	if !ctx.cr[6].eq {
	pc = 0x82FC90C0; continue 'dispatch;
	}
	pc = 0x82FC9258; continue 'dispatch;
            }
            0x82FC9258 => {
    //   block [0x82FC9258..0x82FC9260)
	// 82FC9258: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82FC925C: 4BCE01EC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC9260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC9260 size=64
    let mut pc: u32 = 0x82FC9260;
    'dispatch: loop {
        match pc {
            0x82FC9260 => {
    //   block [0x82FC9260..0x82FC92A0)
	// 82FC9260: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC9264: 3964000C  addi r11, r4, 0xc
	ctx.r[11].s64 = ctx.r[4].s64 + 12;
	// 82FC9268: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82FC926C: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC9270: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC9274: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC9278: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC927C: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC9280: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82FC9284: 8164001C  lwz r11, 0x1c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC9288: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82FC928C: 81640020  lwz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FC9290: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82FC9294: 89640024  lbz r11, 0x24(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC9298: 99630018  stb r11, 0x18(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 82FC929C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC92A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC92A0 size=52
    let mut pc: u32 = 0x82FC92A0;
    'dispatch: loop {
        match pc {
            0x82FC92A0 => {
    //   block [0x82FC92A0..0x82FC92C4)
	// 82FC92A0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC92A4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC92A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC92AC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC92B0: 40980014  bge cr6, 0x82fc92c4
	if !ctx.cr[6].lt {
	pc = 0x82FC92C4; continue 'dispatch;
	}
	// 82FC92B4: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC92B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC92BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC92C0: 409A0008  bne cr6, 0x82fc92c8
	if !ctx.cr[6].eq {
	pc = 0x82FC92C8; continue 'dispatch;
	}
	pc = 0x82FC92C4; continue 'dispatch;
            }
            0x82FC92C4 => {
    //   block [0x82FC92C4..0x82FC92C8)
	// 82FC92C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82FC92C8; continue 'dispatch;
            }
            0x82FC92C8 => {
    //   block [0x82FC92C8..0x82FC92D4)
	// 82FC92C8: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC92CC: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
	// 82FC92D0: 4BFFFDB8  b 0x82fc9088
	sub_82FC9088(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC92D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC92D8 size=288
    let mut pc: u32 = 0x82FC92D8;
    'dispatch: loop {
        match pc {
            0x82FC92D8 => {
    //   block [0x82FC92D8..0x82FC932C)
	// 82FC92D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC92DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC92E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC92E4: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC92E8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82FC92EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82FC92F0: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC92F4: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC92F8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC92FC: 409800D4  bge cr6, 0x82fc93d0
	if !ctx.cr[6].lt {
	pc = 0x82FC93D0; continue 'dispatch;
	}
	// 82FC9300: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9304: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82FC9308: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82FC930C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82FC9310: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82FC9314: 9BE10068  stb r31, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u8 ) };
	// 82FC9318: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC931C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC9320: 419A0068  beq cr6, 0x82fc9388
	if ctx.cr[6].eq {
	pc = 0x82FC9388; continue 'dispatch;
	}
	// 82FC9324: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82FC9328: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	pc = 0x82FC932C; continue 'dispatch;
            }
            0x82FC932C => {
    //   block [0x82FC932C..0x82FC9364)
	// 82FC932C: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9330: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC9334: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9338: 7CEA3214  add r7, r10, r6
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[6].u64;
	// 82FC933C: 81470004  lwz r10, 4(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC9340: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82FC9344: 419A0020  beq cr6, 0x82fc9364
	if ctx.cr[6].eq {
	pc = 0x82FC9364; continue 'dispatch;
	}
	// 82FC9348: 81070000  lwz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC934C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82FC9350: 41980014  blt cr6, 0x82fc9364
	if ctx.cr[6].lt {
	pc = 0x82FC9364; continue 'dispatch;
	}
	// 82FC9354: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82FC9358: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC935C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FC9360: 41980008  blt cr6, 0x82fc9368
	if ctx.cr[6].lt {
	pc = 0x82FC9368; continue 'dispatch;
	}
	pc = 0x82FC9364; continue 'dispatch;
            }
            0x82FC9364 => {
    //   block [0x82FC9364..0x82FC9368)
	// 82FC9364: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x82FC9368; continue 'dispatch;
            }
            0x82FC9368 => {
    //   block [0x82FC9368..0x82FC937C)
	// 82FC9368: 556B063F  clrlwi. r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC936C: 41820010  beq 0x82fc937c
	if ctx.cr[0].eq {
	pc = 0x82FC937C; continue 'dispatch;
	}
	// 82FC9370: 3887000C  addi r4, r7, 0xc
	ctx.r[4].s64 = ctx.r[7].s64 + 12;
	// 82FC9374: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82FC9378: 4BFFFC61  bl 0x82fc8fd8
	ctx.lr = 0x82FC937C;
	sub_82FC8FD8(ctx, base);
	pc = 0x82FC937C; continue 'dispatch;
            }
            0x82FC937C => {
    //   block [0x82FC937C..0x82FC9388)
	// 82FC937C: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 82FC9380: 38C6001C  addi r6, r6, 0x1c
	ctx.r[6].s64 = ctx.r[6].s64 + 28;
	// 82FC9384: 4082FFA8  bne 0x82fc932c
	if !ctx.cr[0].eq {
	pc = 0x82FC932C; continue 'dispatch;
	}
	pc = 0x82FC9388; continue 'dispatch;
            }
            0x82FC9388 => {
    //   block [0x82FC9388..0x82FC93D0)
	// 82FC9388: 3969000C  addi r11, r9, 0xc
	ctx.r[11].s64 = ctx.r[9].s64 + 12;
	// 82FC938C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FC9390: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC9394: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82FC9398: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82FC939C: 80C1005C  lwz r6, 0x5c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82FC93A0: 80A10060  lwz r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82FC93A4: 80810064  lwz r4, 0x64(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82FC93A8: 88610068  lbz r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82FC93AC: 9149000C  stw r10, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82FC93B0: 90E90010  stw r7, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 82FC93B4: 91690014  stw r11, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82FC93B8: 90C90018  stw r6, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 82FC93BC: 90A9001C  stw r5, 0x1c(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[5].u32 ) };
	// 82FC93C0: 90890020  stw r4, 0x20(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 82FC93C4: 98690024  stb r3, 0x24(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), ctx.r[3].u8 ) };
	// 82FC93C8: 91090010  stw r8, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82FC93CC: 4800000C  b 0x82fc93d8
	pc = 0x82FC93D8; continue 'dispatch;
            }
            0x82FC93D0 => {
    //   block [0x82FC93D0..0x82FC93D8)
	// 82FC93D0: 9BE90024  stb r31, 0x24(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), ctx.r[31].u8 ) };
	// 82FC93D4: 93E90010  stw r31, 0x10(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[31].u32 ) };
	pc = 0x82FC93D8; continue 'dispatch;
            }
            0x82FC93D8 => {
    //   block [0x82FC93D8..0x82FC93F8)
	// 82FC93D8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC93DC: 93E90014  stw r31, 0x14(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82FC93E0: 9169000C  stw r11, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82FC93E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC93E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC93EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC93F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC93F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC93F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC93F8 size=28
    let mut pc: u32 = 0x82FC93F8;
    'dispatch: loop {
        match pc {
            0x82FC93F8 => {
    //   block [0x82FC93F8..0x82FC9414)
	// 82FC93F8: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC93FC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC9400: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC9404: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82FC9408: 7D6B2214  add r11, r11, r4
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 82FC940C: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC9410: 4BFFFEC8  b 0x82fc92d8
	sub_82FC92D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC9418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC9418 size=88
    let mut pc: u32 = 0x82FC9418;
    'dispatch: loop {
        match pc {
            0x82FC9418 => {
    //   block [0x82FC9418..0x82FC9470)
	// 82FC9418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC941C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC9420: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC9424: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC9428: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC942C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC9430: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82FC9434: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82FC9438: 90BF0004  stw r5, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82FC943C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82FC9440: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82FC9444: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82FC9448: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82FC944C: 997F0024  stb r11, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 82FC9450: 90DF0028  stw r6, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[6].u32 ) };
	// 82FC9454: 4BFFFC35  bl 0x82fc9088
	ctx.lr = 0x82FC9458;
	sub_82FC9088(ctx, base);
	// 82FC9458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC945C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FC9460: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC9464: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC9468: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC946C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC9470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC9470 size=84
    let mut pc: u32 = 0x82FC9470;
    'dispatch: loop {
        match pc {
            0x82FC9470 => {
    //   block [0x82FC9470..0x82FC94C4)
	// 82FC9470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC9474: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC9478: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC947C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC9480: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC9484: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FC9488: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82FC948C: 909F0000  stw r4, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82FC9490: 90BF0004  stw r5, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 82FC9494: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 82FC9498: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82FC949C: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82FC94A0: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82FC94A4: 997F0024  stb r11, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u8 ) };
	// 82FC94A8: 4BFFFE31  bl 0x82fc92d8
	ctx.lr = 0x82FC94AC;
	sub_82FC92D8(ctx, base);
	// 82FC94AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC94B0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FC94B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC94B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC94BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC94C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC94C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC94C8 size=48
    let mut pc: u32 = 0x82FC94C8;
    'dispatch: loop {
        match pc {
            0x82FC94C8 => {
    //   block [0x82FC94C8..0x82FC94F8)
	// 82FC94C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC94CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC94D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC94D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC94D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC94DC: 4BFFFF95  bl 0x82fc9470
	ctx.lr = 0x82FC94E0;
	sub_82FC9470(ctx, base);
	// 82FC94E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC94E4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FC94E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC94EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC94F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC94F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC94F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC94F8 size=48
    let mut pc: u32 = 0x82FC94F8;
    'dispatch: loop {
        match pc {
            0x82FC94F8 => {
    //   block [0x82FC94F8..0x82FC9528)
	// 82FC94F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC94FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC9500: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC9504: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC9508: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC950C: 4BFFFF0D  bl 0x82fc9418
	ctx.lr = 0x82FC9510;
	sub_82FC9418(ctx, base);
	// 82FC9510: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC9514: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FC9518: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC951C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC9520: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC9524: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC9528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC9528 size=164
    let mut pc: u32 = 0x82FC9528;
    'dispatch: loop {
        match pc {
            0x82FC9528 => {
    //   block [0x82FC9528..0x82FC957C)
	// 82FC9528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC952C: 4BCDFEE1  bl 0x82ca940c
	ctx.lr = 0x82FC9530;
	sub_82CA93D0(ctx, base);
	// 82FC9530: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC9534: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC9538: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC953C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FC9540: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC9544: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82FC9548: 4BFAE559  bl 0x82f77aa0
	ctx.lr = 0x82FC954C;
	sub_82F77AA0(ctx, base);
	// 82FC954C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC9550: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 82FC9554: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC9558: 40980024  bge cr6, 0x82fc957c
	if !ctx.cr[6].lt {
	pc = 0x82FC957C; continue 'dispatch;
	}
	// 82FC955C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9560: 1D5E001C  mulli r10, r30, 0x1c
	ctx.r[10].s32 = ((ctx.r[30].s32 as i64 * 28 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC9564: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 82FC9568: 7C8A4A14  add r4, r10, r9
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82FC956C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FC9570: 3864001C  addi r3, r4, 0x1c
	ctx.r[3].s64 = ctx.r[4].s64 + 28;
	// 82FC9574: 1CAB001C  mulli r5, r11, 0x1c
	ctx.r[5].s32 = ((ctx.r[11].s32 as i64 * 28 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82FC9578: 4BCE75B9  bl 0x82cb0b30
	ctx.lr = 0x82FC957C;
	sub_82CB0B30(ctx, base);
	pc = 0x82FC957C; continue 'dispatch;
            }
            0x82FC957C => {
    //   block [0x82FC957C..0x82FC95C4)
	// 82FC957C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9580: 1D7E001C  mulli r11, r30, 0x1c
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 28 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC9584: 7D6B5215  add. r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC9588: 4182003C  beq 0x82fc95c4
	if ctx.cr[0].eq {
	pc = 0x82FC95C4; continue 'dispatch;
	}
	// 82FC958C: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9590: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82FC9594: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC9598: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82FC959C: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC95A0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82FC95A4: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC95A8: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82FC95AC: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC95B0: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82FC95B4: 815D0014  lwz r10, 0x14(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC95B8: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82FC95BC: 895D0018  lbz r10, 0x18(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC95C0: 994B0018  stb r10, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	pc = 0x82FC95C4; continue 'dispatch;
            }
            0x82FC95C4 => {
    //   block [0x82FC95C4..0x82FC95CC)
	// 82FC95C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC95C8: 4BCDFE94  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC95D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC95D0 size=104
    let mut pc: u32 = 0x82FC95D0;
    'dispatch: loop {
        match pc {
            0x82FC95D0 => {
    //   block [0x82FC95D0..0x82FC962C)
	// 82FC95D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC95D4: 4BCDFE39  bl 0x82ca940c
	ctx.lr = 0x82FC95D8;
	sub_82CA93D0(ctx, base);
	// 82FC95D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC95DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC95E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC95E4: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 82FC95E8: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC95EC: 4BFFF975  bl 0x82fc8f60
	ctx.lr = 0x82FC95F0;
	sub_82FC8F60(ctx, base);
	// 82FC95F0: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC95F4: 40820038  bne 0x82fc962c
	if !ctx.cr[0].eq {
	pc = 0x82FC962C; continue 'dispatch;
	}
	// 82FC95F8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82FC95FC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC9600: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC9604: 4BFFF8BD  bl 0x82fc8ec0
	ctx.lr = 0x82FC9608;
	sub_82FC8EC0(ctx, base);
	// 82FC9608: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82FC960C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82FC9610: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82FC9614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC9618: 4BFFFF11  bl 0x82fc9528
	ctx.lr = 0x82FC961C;
	sub_82FC9528(ctx, base);
	// 82FC961C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9620: 1D7D001C  mulli r11, r29, 0x1c
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * 28 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC9624: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC9628: 48000008  b 0x82fc9630
	pc = 0x82FC9630; continue 'dispatch;
            }
            0x82FC962C => {
    //   block [0x82FC962C..0x82FC9630)
	// 82FC962C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82FC9630; continue 'dispatch;
            }
            0x82FC9630 => {
    //   block [0x82FC9630..0x82FC9638)
	// 82FC9630: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC9634: 4BCDFE28  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC9638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC9638 size=80
    let mut pc: u32 = 0x82FC9638;
    'dispatch: loop {
        match pc {
            0x82FC9638 => {
    //   block [0x82FC9638..0x82FC9688)
	// 82FC9638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC963C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC9640: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC9644: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC9648: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FC964C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC9650: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC9654: C00BBDF8  lfs f0, -0x4208(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16904 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC9658: C1AA0BFC  lfs f13, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC965C: EC21683A  fmadds f1, f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FC9660: 4B262D31  bl 0x8222c390
	ctx.lr = 0x82FC9664;
	sub_8222C390(ctx, base);
	// 82FC9664: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82FC9668: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FC966C: 89610057  lbz r11, 0x57(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 82FC9670: 997F000B  stb r11, 0xb(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(11 as u32), ctx.r[11].u8 ) };
	// 82FC9674: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC9678: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC967C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC9680: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC9684: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC9688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC9688 size=200
    let mut pc: u32 = 0x82FC9688;
    'dispatch: loop {
        match pc {
            0x82FC9688 => {
    //   block [0x82FC9688..0x82FC96D0)
	// 82FC9688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC968C: 4BCDFD81  bl 0x82ca940c
	ctx.lr = 0x82FC9690;
	sub_82CA93D0(ctx, base);
	// 82FC9690: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82FC9694: 4BCE4645  bl 0x82cadcd8
	ctx.lr = 0x82FC9698;
	sub_82CADCA0(ctx, base);
	// 82FC9698: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC969C: ED82182A  fadds f12, f2, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = ((ctx.f[2].f64 + ctx.f[3].f64) as f32) as f64;
	// 82FC96A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC96A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC96A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82FC96AC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82FC96B0: 3BFD0100  addi r31, r29, 0x100
	ctx.r[31].s64 = ctx.r[29].s64 + 256;
	// 82FC96B4: C00B0C4C  lfs f0, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC96B8: C1AA0C14  lfs f13, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FC96BC: EC0C083A  fmadds f0, f12, f0, f1
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64);
	// 82FC96C0: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 82FC96C4: EFE00072  fmuls f31, f0, f1
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82FC96C8: EFC000B2  fmuls f30, f0, f2
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[2].f64) as f32) as f64);
	// 82FC96CC: EFA000F2  fmuls f29, f0, f3
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[3].f64) as f32) as f64);
	pc = 0x82FC96D0; continue 'dispatch;
            }
            0x82FC96D0 => {
    //   block [0x82FC96D0..0x82FC9750)
	// 82FC96D0: 7BCB0020  clrldi r11, r30, 0x20
	ctx.r[11].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 82FC96D4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82FC96D8: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FC96DC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC96E0: FF800018  frsp f28, f0
	ctx.f[28].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC96E4: EC3C07F2  fmuls f1, f28, f31
	ctx.f[1].f64 = (((ctx.f[28].f64 * ctx.f[31].f64) as f32) as f64);
	// 82FC96E8: 4B262CA9  bl 0x8222c390
	ctx.lr = 0x82FC96EC;
	sub_8222C390(ctx, base);
	// 82FC96EC: FC000E5E  fctidz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[1].f64.trunc() as i64 };
	// 82FC96F0: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82FC96F4: 8961005F  lbz r11, 0x5f(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(95 as u32) ) } as u64;
	// 82FC96F8: EC3C07B2  fmuls f1, f28, f30
	ctx.f[1].f64 = (((ctx.f[28].f64 * ctx.f[30].f64) as f32) as f64);
	// 82FC96FC: 997FFF00  stb r11, -0x100(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(-256 as u32), ctx.r[11].u8 ) };
	// 82FC9700: 4B262C91  bl 0x8222c390
	ctx.lr = 0x82FC9704;
	sub_8222C390(ctx, base);
	// 82FC9704: FC000E5E  fctidz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[1].f64.trunc() as i64 };
	// 82FC9708: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82FC970C: 8961005F  lbz r11, 0x5f(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(95 as u32) ) } as u64;
	// 82FC9710: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82FC9714: EC3C0772  fmuls f1, f28, f29
	ctx.f[1].f64 = (((ctx.f[28].f64 * ctx.f[29].f64) as f32) as f64);
	// 82FC9718: 4B262C79  bl 0x8222c390
	ctx.lr = 0x82FC971C;
	sub_8222C390(ctx, base);
	// 82FC971C: FC000E5E  fctidz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[1].f64.trunc() as i64 };
	// 82FC9720: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82FC9724: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82FC9728: 8961005F  lbz r11, 0x5f(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(95 as u32) ) } as u64;
	// 82FC972C: 997F0100  stb r11, 0x100(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(256 as u32), ctx.r[11].u8 ) };
	// 82FC9730: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82FC9734: 2B1E0100  cmplwi cr6, r30, 0x100
	ctx.cr[6].compare_u32(ctx.r[30].u32, 256 as u32, &mut ctx.xer);
	// 82FC9738: 4198FF98  blt cr6, 0x82fc96d0
	if ctx.cr[6].lt {
	pc = 0x82FC96D0; continue 'dispatch;
	}
	// 82FC973C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FC9740: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82FC9744: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82FC9748: 4BCE45DD  bl 0x82cadd24
	ctx.lr = 0x82FC974C;
	sub_82CADCEC(ctx, base);
	// 82FC974C: 4BCDFD10  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC9750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC9750 size=92
    let mut pc: u32 = 0x82FC9750;
    'dispatch: loop {
        match pc {
            0x82FC9750 => {
    //   block [0x82FC9750..0x82FC97A4)
	// 82FC9750: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82FC9754: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC9758: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC975C: 7D0A2214  add r8, r10, r4
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 82FC9760: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82FC9764: 41990048  bgt cr6, 0x82fc97ac
	if ctx.cr[6].gt {
		sub_82FC97AC(ctx, base);
		return;
	}
	// 82FC9768: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC976C: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC9770: 7D292A14  add r9, r9, r5
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[5].u64;
	// 82FC9774: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82FC9778: 41990034  bgt cr6, 0x82fc97ac
	if ctx.cr[6].gt {
		sub_82FC97AC(ctx, base);
		return;
	}
	// 82FC977C: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82FC9780: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC9784: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82FC9788: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC978C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC9790: 7D445214  add r10, r4, r10
	ctx.r[10].u64 = ctx.r[4].u64 + ctx.r[10].u64;
	// 82FC9794: 7F054840  cmplw cr6, r5, r9
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82FC9798: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82FC979C: 40990008  ble cr6, 0x82fc97a4
	if !ctx.cr[6].gt {
	pc = 0x82FC97A4; continue 'dispatch;
	}
	// 82FC97A0: 90AB0010  stw r5, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	pc = 0x82FC97A4; continue 'dispatch;
            }
            0x82FC97A4 => {
    //   block [0x82FC97A4..0x82FC97AC)
	// 82FC97A4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82FC97A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC97AC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC97AC size=64
    let mut pc: u32 = 0x82FC97AC;
    'dispatch: loop {
        match pc {
            0x82FC97AC => {
    //   block [0x82FC97AC..0x82FC97EC)
	// 82FC97AC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC97B0: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC97B4: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC97B8: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82FC97BC: 7D2A2A14  add r9, r10, r5
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 82FC97C0: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82FC97C4: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82FC97C8: 41990024  bgt cr6, 0x82fc97ec
	if ctx.cr[6].gt {
		sub_82FC97EC(ctx, base);
		return;
	}
	// 82FC97CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82FC97D0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82FC97D4: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82FC97D8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC97DC: 91470000  stw r10, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82FC97E0: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82FC97E4: 90AB0010  stw r5, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	// 82FC97E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC97EC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC97EC size=8
    let mut pc: u32 = 0x82FC97EC;
    'dispatch: loop {
        match pc {
            0x82FC97EC => {
    //   block [0x82FC97EC..0x82FC97F4)
	// 82FC97EC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82FC97F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC97F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC97F8 size=112
    let mut pc: u32 = 0x82FC97F8;
    'dispatch: loop {
        match pc {
            0x82FC97F8 => {
    //   block [0x82FC97F8..0x82FC9818)
	// 82FC97F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC97FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FC9800: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FC9804: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FC9808: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC980C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC9810: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC9814: 48000028  b 0x82fc983c
	pc = 0x82FC983C; continue 'dispatch;
            }
            0x82FC9818 => {
    //   block [0x82FC9818..0x82FC983C)
	// 82FC9818: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC981C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82FC9820: 419A0040  beq cr6, 0x82fc9860
	if ctx.cr[6].eq {
	pc = 0x82FC9860; continue 'dispatch;
	}
	// 82FC9824: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FC9828: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC982C: 4BFFFFCD  bl 0x82fc97f8
	ctx.lr = 0x82FC9830;
	sub_82FC97F8(ctx, base);
	// 82FC9830: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC9834: 40820014  bne 0x82fc9848
	if !ctx.cr[0].eq {
	pc = 0x82FC9848; continue 'dispatch;
	}
	// 82FC9838: 83FF0014  lwz r31, 0x14(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	pc = 0x82FC983C; continue 'dispatch;
            }
            0x82FC983C => {
    //   block [0x82FC983C..0x82FC9848)
	// 82FC983C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82FC9840: 409AFFD8  bne cr6, 0x82fc9818
	if !ctx.cr[6].eq {
	pc = 0x82FC9818; continue 'dispatch;
	}
	// 82FC9844: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82FC9848; continue 'dispatch;
            }
            0x82FC9848 => {
    //   block [0x82FC9848..0x82FC9860)
	// 82FC9848: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC984C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FC9850: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FC9854: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FC9858: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FC985C: 4E800020  blr
	return;
            }
            0x82FC9860 => {
    //   block [0x82FC9860..0x82FC9868)
	// 82FC9860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC9864: 4BFFFFE4  b 0x82fc9848
	pc = 0x82FC9848; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC9868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC9868 size=132
    let mut pc: u32 = 0x82FC9868;
    'dispatch: loop {
        match pc {
            0x82FC9868 => {
    //   block [0x82FC9868..0x82FC9890)
	// 82FC9868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC986C: 4BCDFB9D  bl 0x82ca9408
	ctx.lr = 0x82FC9870;
	sub_82CA93D0(ctx, base);
	// 82FC9870: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC9874: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82FC9878: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82FC987C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82FC9880: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC9884: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC9888: 4099005C  ble cr6, 0x82fc98e4
	if !ctx.cr[6].gt {
	pc = 0x82FC98E4; continue 'dispatch;
	}
	// 82FC988C: 3BFD003C  addi r31, r29, 0x3c
	ctx.r[31].s64 = ctx.r[29].s64 + 60;
	pc = 0x82FC9890; continue 'dispatch;
            }
            0x82FC9890 => {
    //   block [0x82FC9890..0x82FC98CC)
	// 82FC9890: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9894: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC9898: 419A0034  beq cr6, 0x82fc98cc
	if ctx.cr[6].eq {
	pc = 0x82FC98CC; continue 'dispatch;
	}
	// 82FC989C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC98A0: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82FC98A4: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FC98A8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC98AC: 4E800421  bctrl
	ctx.lr = 0x82FC98B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC98B0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC98B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC98B8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC98BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC98C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC98C4: 4E800421  bctrl
	ctx.lr = 0x82FC98C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC98C8: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
            }
            0x82FC98CC => {
    //   block [0x82FC98CC..0x82FC98E4)
	// 82FC98CC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82FC98D0: 939F0010  stw r28, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[28].u32 ) };
	// 82FC98D4: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC98D8: 3BFF0014  addi r31, r31, 0x14
	ctx.r[31].s64 = ctx.r[31].s64 + 20;
	// 82FC98DC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FC98E0: 4198FFB0  blt cr6, 0x82fc9890
	if ctx.cr[6].lt {
	pc = 0x82FC9890; continue 'dispatch;
	}
	pc = 0x82FC98E4; continue 'dispatch;
            }
            0x82FC98E4 => {
    //   block [0x82FC98E4..0x82FC98EC)
	// 82FC98E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FC98E8: 4BCDFB70  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC98F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC98F0 size=180
    let mut pc: u32 = 0x82FC98F0;
    'dispatch: loop {
        match pc {
            0x82FC98F0 => {
    //   block [0x82FC98F0..0x82FC9998)
	// 82FC98F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC98F4: 4BCDFB19  bl 0x82ca940c
	ctx.lr = 0x82FC98F8;
	sub_82CA93D0(ctx, base);
	// 82FC98F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC98FC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FC9900: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FC9904: 397D0003  addi r11, r29, 3
	ctx.r[11].s64 = ctx.r[29].s64 + 3;
	// 82FC9908: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC990C: 7D4BF02E  lwzx r10, r11, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82FC9910: 7FEBF214  add r31, r11, r30
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82FC9914: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82FC9918: 409A0080  bne cr6, 0x82fc9998
	if !ctx.cr[6].eq {
	pc = 0x82FC9998; continue 'dispatch;
	}
	// 82FC991C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9920: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82FC9924: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC9928: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC992C: 4E800421  bctrl
	ctx.lr = 0x82FC9930;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC9930: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82FC9934: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC9938: 41820064  beq 0x82fc999c
	if ctx.cr[0].eq {
	pc = 0x82FC999C; continue 'dispatch;
	}
	// 82FC993C: 57AB045E  rlwinm r11, r29, 0, 0x11, 0xf
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 82FC9940: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82FC9944: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82FC9948: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82FC994C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9950: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9954: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FC9958: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC995C: 4E800421  bctrl
	ctx.lr = 0x82FC9960;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC9960: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9964: 80BE0004  lwz r5, 4(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC9968: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82FC996C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9970: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82FC9974: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82FC9978: 38C00009  li r6, 9
	ctx.r[6].s64 = 9;
	// 82FC997C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9980: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC9984: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC9988: 4E800421  bctrl
	ctx.lr = 0x82FC998C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82FC998C: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC9990: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82FC9994: 41820008  beq 0x82fc999c
	if ctx.cr[0].eq {
	pc = 0x82FC999C; continue 'dispatch;
	}
            }
            0x82FC9998 => {
    //   block [0x82FC9998..0x82FC999C)
	// 82FC9998: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82FC999C; continue 'dispatch;
            }
            0x82FC999C => {
    //   block [0x82FC999C..0x82FC99A4)
	// 82FC999C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FC99A0: 4BCDFABC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC99A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC99A8 size=144
    let mut pc: u32 = 0x82FC99A8;
    'dispatch: loop {
        match pc {
            0x82FC99A8 => {
    //   block [0x82FC99A8..0x82FC99C4)
	// 82FC99A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC99AC: 4BCDFA5D  bl 0x82ca9408
	ctx.lr = 0x82FC99B0;
	sub_82CA93D0(ctx, base);
	// 82FC99B0: 2B060004  cmplwi cr6, r6, 4
	ctx.cr[6].compare_u32(ctx.r[6].u32, 4 as u32, &mut ctx.xer);
	// 82FC99B4: 40990080  ble cr6, 0x82fc9a34
	if !ctx.cr[6].gt {
	pc = 0x82FC9A34; continue 'dispatch;
	}
	// 82FC99B8: 3B8303B0  addi r28, r3, 0x3b0
	ctx.r[28].s64 = ctx.r[3].s64 + 944;
	// 82FC99BC: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82FC99C0: 39240002  addi r9, r4, 2
	ctx.r[9].s64 = ctx.r[4].s64 + 2;
	pc = 0x82FC99C4; continue 'dispatch;
            }
            0x82FC99C4 => {
    //   block [0x82FC99C4..0x82FC9A34)
	// 82FC99C4: 89690000  lbz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC99C8: 39050001  addi r8, r5, 1
	ctx.r[8].s64 = ctx.r[5].s64 + 1;
	// 82FC99CC: 88850000  lbz r4, 0(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC99D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82FC99D4: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82FC99D8: 8BC50001  lbz r30, 1(r5)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(1 as u32) ) } as u64;
	// 82FC99DC: 8BE50002  lbz r31, 2(r5)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 82FC99E0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82FC99E4: 88650003  lbz r3, 3(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(3 as u32) ) } as u64;
	// 82FC99E8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82FC99EC: 88E50004  lbz r7, 4(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC99F0: 8BAB0200  lbz r29, 0x200(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(512 as u32) ) } as u64;
	// 82FC99F4: 7C84EA14  add r4, r4, r29
	ctx.r[4].u64 = ctx.r[4].u64 + ctx.r[29].u64;
	// 82FC99F8: 98850000  stb r4, 0(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[4].u8 ) };
	// 82FC99FC: 888B0100  lbz r4, 0x100(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(256 as u32) ) } as u64;
	// 82FC9A00: 7C84F214  add r4, r4, r30
	ctx.r[4].u64 = ctx.r[4].u64 + ctx.r[30].u64;
	// 82FC9A04: 98850001  stb r4, 1(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(1 as u32), ctx.r[4].u8 ) };
	// 82FC9A08: 888B0000  lbz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9A0C: 7C84FA14  add r4, r4, r31
	ctx.r[4].u64 = ctx.r[4].u64 + ctx.r[31].u64;
	// 82FC9A10: 98850002  stb r4, 2(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(2 as u32), ctx.r[4].u8 ) };
	// 82FC9A14: 888B0100  lbz r4, 0x100(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(256 as u32) ) } as u64;
	// 82FC9A18: 7C841A14  add r4, r4, r3
	ctx.r[4].u64 = ctx.r[4].u64 + ctx.r[3].u64;
	// 82FC9A1C: 98850003  stb r4, 3(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(3 as u32), ctx.r[4].u8 ) };
	// 82FC9A20: 896B0200  lbz r11, 0x200(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(512 as u32) ) } as u64;
	// 82FC9A24: 7D675A14  add r11, r7, r11
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[11].u64;
	// 82FC9A28: 99650004  stb r11, 4(r5)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82FC9A2C: 7D054378  mr r5, r8
	ctx.r[5].u64 = ctx.r[8].u64;
	// 82FC9A30: 4198FF94  blt cr6, 0x82fc99c4
	if ctx.cr[6].lt {
	pc = 0x82FC99C4; continue 'dispatch;
	}
	pc = 0x82FC9A34; continue 'dispatch;
            }
            0x82FC9A34 => {
    //   block [0x82FC9A34..0x82FC9A38)
	// 82FC9A34: 4BCDFA24  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC9A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82FC9A38 size=184
    let mut pc: u32 = 0x82FC9A38;
    'dispatch: loop {
        match pc {
            0x82FC9A38 => {
    //   block [0x82FC9A38..0x82FC9A64)
	// 82FC9A38: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 82FC9A3C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC9A40: C00B0C14  lfs f0, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC9A44: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82FC9A48: 419A00A0  beq cr6, 0x82fc9ae8
	if ctx.cr[6].eq {
	pc = 0x82FC9AE8; continue 'dispatch;
	}
	// 82FC9A4C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82FC9A50: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82FC9A54: 419A0094  beq cr6, 0x82fc9ae8
	if ctx.cr[6].eq {
	pc = 0x82FC9AE8; continue 'dispatch;
	}
	// 82FC9A58: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC9A5C: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 82FC9A60: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82FC9A64; continue 'dispatch;
            }
            0x82FC9A64 => {
    //   block [0x82FC9A64..0x82FC9A88)
	// 82FC9A64: 8164000C  lwz r11, 0xc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC9A68: 7FE33214  add r31, r3, r6
	ctx.r[31].u64 = ctx.r[3].u64 + ctx.r[6].u64;
	// 82FC9A6C: 81240010  lwz r9, 0x10(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC9A70: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82FC9A74: 7D7F59D6  mullw r11, r31, r11
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC9A78: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 82FC9A7C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82FC9A80: 419A005C  beq cr6, 0x82fc9adc
	if ctx.cr[6].eq {
	pc = 0x82FC9ADC; continue 'dispatch;
	}
	// 82FC9A84: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	pc = 0x82FC9A88; continue 'dispatch;
            }
            0x82FC9A88 => {
    //   block [0x82FC9A88..0x82FC9AC0)
	// 82FC9A88: 892B0000  lbz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9A8C: 7D2A4850  subf r9, r10, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 82FC9A90: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82FC9A94: F921FFE0  std r9, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.r[9].u64 ) };
	// 82FC9A98: C9A1FFE0  lfd f13, -0x20(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82FC9A9C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82FC9AA0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82FC9AA4: EDAD007A  fmadds f13, f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FC9AA8: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 82FC9AAC: D9A1FFE8  stfd f13, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[13].u64 ) };
	// 82FC9AB0: 8121FFEC  lwz r9, -0x14(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 82FC9AB4: 7D295215  add. r9, r9, r10
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FC9AB8: 40800008  bge 0x82fc9ac0
	if !ctx.cr[0].lt {
	pc = 0x82FC9AC0; continue 'dispatch;
	}
	// 82FC9ABC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	pc = 0x82FC9AC0; continue 'dispatch;
            }
            0x82FC9AC0 => {
    //   block [0x82FC9AC0..0x82FC9ACC)
	// 82FC9AC0: 2F0900FF  cmpwi cr6, r9, 0xff
	ctx.cr[6].compare_i32(ctx.r[9].s32, 255, &mut ctx.xer);
	// 82FC9AC4: 40990008  ble cr6, 0x82fc9acc
	if !ctx.cr[6].gt {
	pc = 0x82FC9ACC; continue 'dispatch;
	}
	// 82FC9AC8: 392000FF  li r9, 0xff
	ctx.r[9].s64 = 255;
	pc = 0x82FC9ACC; continue 'dispatch;
            }
            0x82FC9ACC => {
    //   block [0x82FC9ACC..0x82FC9ADC)
	// 82FC9ACC: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 82FC9AD0: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82FC9AD4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FC9AD8: 4082FFB0  bne 0x82fc9a88
	if !ctx.cr[0].eq {
	pc = 0x82FC9A88; continue 'dispatch;
	}
	pc = 0x82FC9ADC; continue 'dispatch;
            }
            0x82FC9ADC => {
    //   block [0x82FC9ADC..0x82FC9AE8)
	// 82FC9ADC: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 82FC9AE0: 7F034040  cmplw cr6, r3, r8
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82FC9AE4: 4198FF80  blt cr6, 0x82fc9a64
	if ctx.cr[6].lt {
	pc = 0x82FC9A64; continue 'dispatch;
	}
	pc = 0x82FC9AE8; continue 'dispatch;
            }
            0x82FC9AE8 => {
    //   block [0x82FC9AE8..0x82FC9AF0)
	// 82FC9AE8: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82FC9AEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC9AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FC9AF0 size=804
    let mut pc: u32 = 0x82FC9AF0;
    'dispatch: loop {
        match pc {
            0x82FC9AF0 => {
    //   block [0x82FC9AF0..0x82FC9B58)
	// 82FC9AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC9AF4: 4BCDF915  bl 0x82ca9408
	ctx.lr = 0x82FC9AF8;
	sub_82CA93D0(ctx, base);
	// 82FC9AF8: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82FC9AFC: 4BCE41DD  bl 0x82cadcd8
	ctx.lr = 0x82FC9B00;
	sub_82CADCA0(ctx, base);
	// 82FC9B00: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC9B04: 78AB0020  clrldi r11, r5, 0x20
	ctx.r[11].u64 = ctx.r[5].u64 & 0x00000000FFFFFFFFu64;
	// 82FC9B08: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 82FC9B0C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82FC9B10: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FC9B14: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 82FC9B18: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC9B1C: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 82FC9B20: 98BF0006  stb r5, 6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[5].u8 ) };
	// 82FC9B24: 54A92436  rlwinm r9, r5, 4, 0x10, 0x1b
	ctx.r[9].u64 = ctx.r[5].u32 as u64 & 0x0FFFFFFFu64;
	// 82FC9B28: 895E0007  lbz r10, 7(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(7 as u32) ) } as u64;
	// 82FC9B2C: 995F0007  stb r10, 7(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(7 as u32), ctx.r[10].u8 ) };
	// 82FC9B30: C38B0C14  lfs f28, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82FC9B34: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC9B38: 895E000A  lbz r10, 0xa(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(10 as u32) ) } as u64;
	// 82FC9B3C: 995F000A  stb r10, 0xa(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(10 as u32), ctx.r[10].u8 ) };
	// 82FC9B40: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC9B44: B13D0000  sth r9, 0(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[9].u16 ) };
	// 82FC9B48: EC0D0824  fdivs f0, f13, f1
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[1].f64) as f32) as f64;
	// 82FC9B4C: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 82FC9B50: 40980008  bge cr6, 0x82fc9b58
	if !ctx.cr[6].lt {
	pc = 0x82FC9B58; continue 'dispatch;
	}
	// 82FC9B54: FC00E090  fmr f0, f28
	ctx.f[0].f64 = ctx.f[28].f64;
	pc = 0x82FC9B58; continue 'dispatch;
            }
            0x82FC9B58 => {
    //   block [0x82FC9B58..0x82FC9CBC)
	// 82FC9B58: 893E0009  lbz r9, 9(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(9 as u32) ) } as u64;
	// 82FC9B5C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC9B60: 897E000B  lbz r11, 0xb(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(11 as u32) ) } as u64;
	// 82FC9B64: 3D008202  lis r8, -0x7dfe
	ctx.r[8].s64 = -2113798144;
	// 82FC9B68: 88FE0008  lbz r7, 8(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC9B6C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 82FC9B70: 80C30010  lwz r6, 0x10(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC9B74: 80A3000C  lwz r5, 0xc(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC9B78: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82FC9B7C: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FC9B80: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82FC9B84: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FC9B88: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82FC9B8C: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 82FC9B90: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82FC9B94: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82FC9B98: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82FC9B9C: C9210050  lfd f9, 0x50(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FC9BA0: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 82FC9BA4: C3AA0C98  lfs f29, 0xc98(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3224 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82FC9BA8: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82FC9BAC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC9BB0: ED0C0032  fmuls f8, f12, f0
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC9BB4: C1688470  lfs f11, -0x7b90(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-31632 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FC9BB8: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82FC9BBC: 54CB083C  slwi r11, r6, 1
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC9BC0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82FC9BC4: 83810104  lwz r28, 0x104(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82FC9BC8: 7D6B2850  subf r11, r11, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82FC9BCC: C18A7A14  lfs f12, 0x7a14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(31252 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC9BD0: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82FC9BD4: ECED0332  fmuls f7, f13, f12
	ctx.f[7].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FC9BD8: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 82FC9BDC: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82FC9BE0: C1890C4C  lfs f12, 0xc4c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FC9BE4: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FC9BE8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82FC9BEC: ED4800B2  fmuls f10, f8, f2
	ctx.f[10].f64 = (((ctx.f[8].f64 * ctx.f[2].f64) as f32) as f64);
	// 82FC9BF0: C8C10050  lfd f6, 0x50(r1)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FC9BF4: ED290032  fmuls f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC9BF8: 39600100  li r11, 0x100
	ctx.r[11].s64 = 256;
	// 82FC9BFC: FCC0369C  fcfid f6, f6
	ctx.f[6].f64 = (ctx.f[6].s64 as f64);
	// 82FC9C00: C3C80BFC  lfs f30, 0xbfc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3068 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82FC9C04: EC2D02F2  fmuls f1, f13, f11
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82FC9C08: B17C0000  sth r11, 0(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 82FC9C0C: EFEA0772  fmuls f31, f10, f29
	ctx.f[31].f64 = (((ctx.f[10].f64 * ctx.f[29].f64) as f32) as f64);
	// 82FC9C10: EDA900B2  fmuls f13, f9, f2
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[2].f64) as f32) as f64);
	// 82FC9C14: FC003018  frsp f0, f6
	ctx.f[0].f64 = (ctx.f[6].f64 as f32) as f64;
	// 82FC9C18: ED41F82A  fadds f10, f1, f31
	ctx.f[10].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 82FC9C1C: ED6D0772  fmuls f11, f13, f29
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[29].f64) as f32) as f64);
	// 82FC9C20: EDAA0332  fmuls f13, f10, f12
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FC9C24: EDA768FA  fmadds f13, f7, f3, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[3].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FC9C28: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82FC9C2C: 40990090  ble cr6, 0x82fc9cbc
	if !ctx.cr[6].gt {
	pc = 0x82FC9CBC; continue 'dispatch;
	}
	// 82FC9C30: 897F0006  lbz r11, 6(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(6 as u32) ) } as u64;
	// 82FC9C34: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82FC9C38: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FC9C3C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82FC9C40: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FC9C44: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC9C48: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC9C4C: C00A0AE0  lfs f0, 0xae0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2784 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC9C50: EC0DF03A  fmadds f0, f13, f0, f30
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64);
	// 82FC9C54: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FC9C58: EFFF0372  fmuls f31, f31, f13
	ctx.f[31].f64 = (((ctx.f[31].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FC9C5C: EC210372  fmuls f1, f1, f13
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FC9C60: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FC9C64: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82FC9C68: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FC9C6C: A1610056  lhz r11, 0x56(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82FC9C70: FC00665E  fctidz f0, f12
	ctx.f[0].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 82FC9C74: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FC9C78: 89410057  lbz r10, 0x57(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 82FC9C7C: 995F0006  stb r10, 6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[10].u8 ) };
	// 82FC9C80: A15D0000  lhz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9C84: 7D4A07B4  extsw r10, r10
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC9C88: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82FC9C8C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FC9C90: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC9C94: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC9C98: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FC9C9C: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82FC9CA0: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FC9CA4: A1410056  lhz r10, 0x56(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(86 as u32) ) } as u64;
	// 82FC9CA8: B15D0000  sth r10, 0(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 82FC9CAC: B17C0000  sth r11, 0(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 82FC9CB0: 897F0007  lbz r11, 7(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(7 as u32) ) } as u64;
	// 82FC9CB4: 716B00FD  andi. r11, r11, 0xfd
	ctx.r[11].u64 = ctx.r[11].u64 & 253;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC9CB8: 997F0007  stb r11, 7(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(7 as u32), ctx.r[11].u8 ) };
	pc = 0x82FC9CBC; continue 'dispatch;
            }
            0x82FC9CBC => {
    //   block [0x82FC9CBC..0x82FC9CD0)
	// 82FC9CBC: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FC9CC0: C00B6E28  lfs f0, 0x6e28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC9CC4: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 82FC9CC8: 40990008  ble cr6, 0x82fc9cd0
	if !ctx.cr[6].gt {
	pc = 0x82FC9CD0; continue 'dispatch;
	}
	// 82FC9CCC: FD600090  fmr f11, f0
	ctx.f[11].f64 = ctx.f[0].f64;
	pc = 0x82FC9CD0; continue 'dispatch;
            }
            0x82FC9CD0 => {
    //   block [0x82FC9CD0..0x82FC9CDC)
	// 82FC9CD0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82FC9CD4: 40990008  ble cr6, 0x82fc9cdc
	if !ctx.cr[6].gt {
	pc = 0x82FC9CDC; continue 'dispatch;
	}
	// 82FC9CD8: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	pc = 0x82FC9CDC; continue 'dispatch;
            }
            0x82FC9CDC => {
    //   block [0x82FC9CDC..0x82FC9CE8)
	// 82FC9CDC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82FC9CE0: 40990008  ble cr6, 0x82fc9ce8
	if !ctx.cr[6].gt {
	pc = 0x82FC9CE8; continue 'dispatch;
	}
	// 82FC9CE4: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	pc = 0x82FC9CE8; continue 'dispatch;
            }
            0x82FC9CE8 => {
    //   block [0x82FC9CE8..0x82FC9CFC)
	// 82FC9CE8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FC9CEC: C00B6E2C  lfs f0, 0x6e2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28204 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC9CF0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82FC9CF4: 40980008  bge cr6, 0x82fc9cfc
	if !ctx.cr[6].lt {
	pc = 0x82FC9CFC; continue 'dispatch;
	}
	// 82FC9CF8: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	pc = 0x82FC9CFC; continue 'dispatch;
            }
            0x82FC9CFC => {
    //   block [0x82FC9CFC..0x82FC9D84)
	// 82FC9CFC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FC9D00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FC9D04: C00B0B60  lfs f0, 0xb60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FC9D08: EDBFF03A  fmadds f13, f31, f0, f30
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64);
	// 82FC9D0C: EC0BF03A  fmadds f0, f11, f0, f30
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64);
	// 82FC9D10: FDA06E5E  fctidz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 82FC9D14: D9A10058  stfd f13, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[13].u64 ) };
	// 82FC9D18: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82FC9D1C: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FC9D20: 89610057  lbz r11, 0x57(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(87 as u32) ) } as u64;
	// 82FC9D24: 997F0008  stb r11, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 82FC9D28: 8961005F  lbz r11, 0x5f(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(95 as u32) ) } as u64;
	// 82FC9D2C: 997F0009  stb r11, 9(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(9 as u32), ctx.r[11].u8 ) };
	// 82FC9D30: 4BFFF909  bl 0x82fc9638
	ctx.lr = 0x82FC9D34;
	sub_82FC9638(ctx, base);
	// 82FC9D34: 897E0007  lbz r11, 7(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(7 as u32) ) } as u64;
	// 82FC9D38: 556A0031  rlwinm. r10, r11, 0, 0, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FC9D3C: 408200C8  bne 0x82fc9e04
	if !ctx.cr[0].eq {
	pc = 0x82FC9E04; continue 'dispatch;
	}
	// 82FC9D40: 556B07FF  clrlwi. r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC9D44: 408200C0  bne 0x82fc9e04
	if !ctx.cr[0].eq {
	pc = 0x82FC9E04; continue 'dispatch;
	}
	// 82FC9D48: 895F0009  lbz r10, 9(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(9 as u32) ) } as u64;
	// 82FC9D4C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82FC9D50: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82FC9D54: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82FC9D58: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC9D5C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC9D60: EC00F77A  fmadds f0, f0, f29, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[30].f64) as f32) as f64);
	// 82FC9D64: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82FC9D68: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82FC9D6C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82FC9D70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FC9D74: 409A0010  bne cr6, 0x82fc9d84
	if !ctx.cr[6].eq {
	pc = 0x82FC9D84; continue 'dispatch;
	}
	// 82FC9D78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82FC9D7C: 419A0008  beq cr6, 0x82fc9d84
	if ctx.cr[6].eq {
	pc = 0x82FC9D84; continue 'dispatch;
	}
	// 82FC9D80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82FC9D84; continue 'dispatch;
            }
            0x82FC9D84 => {
    //   block [0x82FC9D84..0x82FC9E04)
	// 82FC9D84: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82FC9D88: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82FC9D8C: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82FC9D90: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FC9D94: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FC9D98: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82FC9D9C: 40980068  bge cr6, 0x82fc9e04
	if !ctx.cr[6].lt {
	pc = 0x82FC9E04; continue 'dispatch;
	}
	// 82FC9DA0: A15D0000  lhz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9DA4: EC1CF824  fdivs f0, f28, f31
	ctx.f[0].f64 = ((ctx.f[28].f64 / ctx.f[31].f64) as f32) as f64;
	// 82FC9DA8: 7D4A59D6  mullw r10, r10, r11
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC9DAC: 794A0020  clrldi r10, r10, 0x20
	ctx.r[10].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82FC9DB0: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82FC9DB4: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82FC9DB8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82FC9DBC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82FC9DC0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC9DC4: FDA06E5E  fctidz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 82FC9DC8: D9A10058  stfd f13, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[13].u64 ) };
	// 82FC9DCC: A141005E  lhz r10, 0x5e(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(94 as u32) ) } as u64;
	// 82FC9DD0: B15D0000  sth r10, 0(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u16 ) };
	// 82FC9DD4: A15C0000  lhz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9DD8: 7D6A59D6  mullw r11, r10, r11
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC9DDC: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82FC9DE0: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82FC9DE4: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82FC9DE8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82FC9DEC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82FC9DF0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FC9DF4: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82FC9DF8: D8010058  stfd f0, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.f[0].u64 ) };
	// 82FC9DFC: A161005E  lhz r11, 0x5e(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(94 as u32) ) } as u64;
	// 82FC9E00: B17C0000  sth r11, 0(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	pc = 0x82FC9E04; continue 'dispatch;
            }
            0x82FC9E04 => {
    //   block [0x82FC9E04..0x82FC9E14)
	// 82FC9E04: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82FC9E08: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82FC9E0C: 4BCE3F19  bl 0x82cadd24
	ctx.lr = 0x82FC9E10;
	sub_82CADCEC(ctx, base);
	// 82FC9E10: 4BCDF648  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC9E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC9E18 size=100
    let mut pc: u32 = 0x82FC9E18;
    'dispatch: loop {
        match pc {
            0x82FC9E18 => {
    //   block [0x82FC9E18..0x82FC9E48)
	// 82FC9E18: A9430066  lha r10, 0x66(r3)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(102 as u32) ) } as i16) as i64;
	// 82FC9E1C: A9240002  lha r9, 2(r4)
	ctx.r[9].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(2 as u32) ) } as i16) as i64;
	// 82FC9E20: 7D6A4851  subf. r11, r10, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC9E24: 41800024  blt 0x82fc9e48
	if ctx.cr[0].lt {
	pc = 0x82FC9E48; continue 'dispatch;
	}
	// 82FC9E28: 81230058  lwz r9, 0x58(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) } as u64;
	// 82FC9E2C: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82FC9E30: 40980018  bge cr6, 0x82fc9e48
	if !ctx.cr[6].lt {
	pc = 0x82FC9E48; continue 'dispatch;
	}
	// 82FC9E34: 81230060  lwz r9, 0x60(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 82FC9E38: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC9E3C: 7D695A2E  lhzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FC9E40: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC9E44: B1640002  sth r11, 2(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(2 as u32), ctx.r[11].u16 ) };
	pc = 0x82FC9E48; continue 'dispatch;
            }
            0x82FC9E48 => {
    //   block [0x82FC9E48..0x82FC9E7C)
	// 82FC9E48: A9430064  lha r10, 0x64(r3)
	ctx.r[10].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(100 as u32) ) } as i16) as i64;
	// 82FC9E4C: A9240000  lha r9, 0(r4)
	ctx.r[9].s64 = (unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as i16) as i64;
	// 82FC9E50: 7D6A4851  subf. r11, r10, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC9E54: 4D800020  bltlr
	if ctx.cr[0].lt { return; }
	// 82FC9E58: 8123004C  lwz r9, 0x4c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 82FC9E5C: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82FC9E60: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 82FC9E64: 81230054  lwz r9, 0x54(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FC9E68: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FC9E6C: 7D695A2E  lhzx r11, r9, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FC9E70: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC9E74: B1640000  sth r11, 0(r4)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 82FC9E78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC9E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC9E80 size=60
    let mut pc: u32 = 0x82FC9E80;
    'dispatch: loop {
        match pc {
            0x82FC9E80 => {
    //   block [0x82FC9E80..0x82FC9EBC)
	// 82FC9E80: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC9E84: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82FC9E88: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC9E8C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82FC9E90: 394A0003  addi r10, r10, 3
	ctx.r[10].s64 = ctx.r[10].s64 + 3;
	// 82FC9E94: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 82FC9E98: 1D4A0014  mulli r10, r10, 0x14
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 20 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FC9E9C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC9EA0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9EA4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FC9EA8: 38C00009  li r6, 9
	ctx.r[6].s64 = 9;
	// 82FC9EAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FC9EB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC9EB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC9EB8: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC9EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC9EC0 size=40
    let mut pc: u32 = 0x82FC9EC0;
    'dispatch: loop {
        match pc {
            0x82FC9EC0 => {
    //   block [0x82FC9EC0..0x82FC9ECC)
	// 82FC9EC0: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FC9EC4: 3943002C  addi r10, r3, 0x2c
	ctx.r[10].s64 = ctx.r[3].s64 + 44;
	// 82FC9EC8: 48000014  b 0x82fc9edc
	pc = 0x82FC9EDC; continue 'dispatch;
            }
            0x82FC9ECC => {
    //   block [0x82FC9ECC..0x82FC9EDC)
	// 82FC9ECC: A12B0020  lhz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FC9ED0: 5529047E  clrlwi r9, r9, 0x11
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x00007FFFu64;
	// 82FC9ED4: B12B0020  sth r9, 0x20(r11)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u16 ) };
	// 82FC9ED8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82FC9EDC; continue 'dispatch;
            }
            0x82FC9EDC => {
    //   block [0x82FC9EDC..0x82FC9EE8)
	// 82FC9EDC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FC9EE0: 409AFFEC  bne cr6, 0x82fc9ecc
	if !ctx.cr[6].eq {
	pc = 0x82FC9ECC; continue 'dispatch;
	}
	// 82FC9EE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC9EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FC9EE8 size=264
    let mut pc: u32 = 0x82FC9EE8;
    'dispatch: loop {
        match pc {
            0x82FC9EE8 => {
    //   block [0x82FC9EE8..0x82FC9F30)
	// 82FC9EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC9EEC: 4BCDF511  bl 0x82ca93fc
	ctx.lr = 0x82FC9EF0;
	sub_82CA93D0(ctx, base);
	// 82FC9EF0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FC9EF4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82FC9EF8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FC9EFC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82FC9F00: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82FC9F04: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82FC9F08: 817C02D4  lwz r11, 0x2d4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(724 as u32) ) } as u64;
	// 82FC9F0C: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 82FC9F10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FC9F14: 419A001C  beq cr6, 0x82fc9f30
	if ctx.cr[6].eq {
	pc = 0x82FC9F30; continue 'dispatch;
	}
	// 82FC9F18: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FC9F1C: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82FC9F20: 41980010  blt cr6, 0x82fc9f30
	if ctx.cr[6].lt {
	pc = 0x82FC9F30; continue 'dispatch;
	}
	// 82FC9F24: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FC9F28: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82FC9F2C: 4098006C  bge cr6, 0x82fc9f98
	if !ctx.cr[6].lt {
	pc = 0x82FC9F98; continue 'dispatch;
	}
	pc = 0x82FC9F30; continue 'dispatch;
            }
            0x82FC9F30 => {
    //   block [0x82FC9F30..0x82FC9F70)
	// 82FC9F30: 38600038  li r3, 0x38
	ctx.r[3].s64 = 56;
	// 82FC9F34: 4BF3392D  bl 0x82efd860
	ctx.lr = 0x82FC9F38;
	sub_82EFD860(ctx, base);
	// 82FC9F38: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FC9F3C: 41820034  beq 0x82fc9f70
	if ctx.cr[0].eq {
	pc = 0x82FC9F70; continue 'dispatch;
	}
	// 82FC9F40: 3D605647  lis r11, 0x5647
	ctx.r[11].s64 = 1447493632;
	// 82FC9F44: 3D409FE1  lis r10, -0x601f
	ctx.r[10].s64 = -1612644352;
	// 82FC9F48: 616B1E89  ori r11, r11, 0x1e89
	ctx.r[11].u64 = ctx.r[11].u64 | 7817;
	// 82FC9F4C: 614A234A  ori r10, r10, 0x234a
	ctx.r[10].u64 = ctx.r[10].u64 | 9034;
	// 82FC9F50: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FC9F54: 38DD0010  addi r6, r29, 0x10
	ctx.r[6].s64 = ctx.r[29].s64 + 16;
	// 82FC9F58: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82FC9F5C: 38BB0010  addi r5, r27, 0x10
	ctx.r[5].s64 = ctx.r[27].s64 + 16;
	// 82FC9F60: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 82FC9F64: 4BF3BFE5  bl 0x82f05f48
	ctx.lr = 0x82FC9F68;
	sub_82F05F48(ctx, base);
	// 82FC9F68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FC9F6C: 48000008  b 0x82fc9f74
	pc = 0x82FC9F74; continue 'dispatch;
            }
            0x82FC9F70 => {
    //   block [0x82FC9F70..0x82FC9F74)
	// 82FC9F70: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82FC9F74; continue 'dispatch;
            }
            0x82FC9F74 => {
    //   block [0x82FC9F74..0x82FC9F94)
	// 82FC9F74: 807C02D4  lwz r3, 0x2d4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(724 as u32) ) } as u64;
	// 82FC9F78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FC9F7C: 419A0018  beq cr6, 0x82fc9f94
	if ctx.cr[6].eq {
	pc = 0x82FC9F94; continue 'dispatch;
	}
	// 82FC9F80: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FC9F84: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FC9F88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FC9F8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FC9F90: 4E800421  bctrl
	ctx.lr = 0x82FC9F94;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FC9F94 => {
    //   block [0x82FC9F94..0x82FC9F98)
	// 82FC9F94: 93FC02D4  stw r31, 0x2d4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(724 as u32), ctx.r[31].u32 ) };
	pc = 0x82FC9F98; continue 'dispatch;
            }
            0x82FC9F98 => {
    //   block [0x82FC9F98..0x82FC9FA8)
	// 82FC9F98: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82FC9F9C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82FC9FA0: 419A0048  beq cr6, 0x82fc9fe8
	if ctx.cr[6].eq {
	pc = 0x82FC9FE8; continue 'dispatch;
	}
	// 82FC9FA4: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	pc = 0x82FC9FA8; continue 'dispatch;
            }
            0x82FC9FA8 => {
    //   block [0x82FC9FA8..0x82FC9FE8)
	// 82FC9FA8: 817C02D4  lwz r11, 0x2d4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(724 as u32) ) } as u64;
	// 82FC9FAC: 7D5FCA14  add r10, r31, r25
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[25].u64;
	// 82FC9FB0: 813E000C  lwz r9, 0xc(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FC9FB4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82FC9FB8: 811E0010  lwz r8, 0x10(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FC9FBC: 7D2A49D6  mullw r9, r10, r9
	ctx.r[9].s32 = ((ctx.r[10].s32 as i64 * ctx.r[9].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82FC9FC0: 80EB001C  lwz r7, 0x1c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FC9FC4: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FC9FC8: 7D294214  add r9, r9, r8
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 82FC9FCC: 7D67F9D6  mullw r11, r7, r31
	ctx.r[11].s32 = ((ctx.r[7].s32 as i64 * ctx.r[31].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FC9FD0: 7C89D214  add r4, r9, r26
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[26].u64;
	// 82FC9FD4: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FC9FD8: 4BCDF4A9  bl 0x82ca9480
	ctx.lr = 0x82FC9FDC;
	sub_82CA9480(ctx, base);
	// 82FC9FDC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 82FC9FE0: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82FC9FE4: 4198FFC4  blt cr6, 0x82fc9fa8
	if ctx.cr[6].lt {
	pc = 0x82FC9FA8; continue 'dispatch;
	}
	pc = 0x82FC9FE8; continue 'dispatch;
            }
            0x82FC9FE8 => {
    //   block [0x82FC9FE8..0x82FC9FF0)
	// 82FC9FE8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82FC9FEC: 4BCDF460  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FC9FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FC9FF0 size=152
    let mut pc: u32 = 0x82FC9FF0;
    'dispatch: loop {
        match pc {
            0x82FC9FF0 => {
    //   block [0x82FC9FF0..0x82FCA014)
	// 82FC9FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FC9FF4: 4BCDF419  bl 0x82ca940c
	ctx.lr = 0x82FC9FF8;
	sub_82CA93D0(ctx, base);
	// 82FC9FF8: 816302D4  lwz r11, 0x2d4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(724 as u32) ) } as u64;
	// 82FC9FFC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FCA000: 419A0084  beq cr6, 0x82fca084
	if ctx.cr[6].eq {
	pc = 0x82FCA084; continue 'dispatch;
	}
	// 82FCA004: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82FCA008: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82FCA00C: 419A0078  beq cr6, 0x82fca084
	if ctx.cr[6].eq {
	pc = 0x82FCA084; continue 'dispatch;
	}
	// 82FCA010: 3BA40010  addi r29, r4, 0x10
	ctx.r[29].s64 = ctx.r[4].s64 + 16;
	pc = 0x82FCA014; continue 'dispatch;
            }
            0x82FCA014 => {
    //   block [0x82FCA014..0x82FCA04C)
	// 82FCA014: 816302D4  lwz r11, 0x2d4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(724 as u32) ) } as u64;
	// 82FCA018: 7D3E3214  add r9, r30, r6
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[6].u64;
	// 82FCA01C: 809D000C  lwz r4, 0xc(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FCA020: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82FCA024: 815D0010  lwz r10, 0x10(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FCA028: 7FE921D6  mullw r31, r9, r4
	ctx.r[31].s32 = ((ctx.r[9].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[31].s64 = ctx.r[31].s32 as i64;
	// 82FCA02C: 812B001C  lwz r9, 0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCA030: 808B0020  lwz r4, 0x20(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FCA034: 7D29F1D6  mullw r9, r9, r30
	ctx.r[9].s32 = ((ctx.r[9].s32 as i64 * ctx.r[30].s32 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82FCA038: 7D7F2A14  add r11, r31, r5
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[5].u64;
	// 82FCA03C: 7D292214  add r9, r9, r4
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[4].u64;
	// 82FCA040: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FCA044: 419A0034  beq cr6, 0x82fca078
	if ctx.cr[6].eq {
	pc = 0x82FCA078; continue 'dispatch;
	}
	// 82FCA048: 7CEA3B78  mr r10, r7
	ctx.r[10].u64 = ctx.r[7].u64;
	pc = 0x82FCA04C; continue 'dispatch;
            }
            0x82FCA04C => {
    //   block [0x82FCA04C..0x82FCA078)
	// 82FCA04C: 88890000  lbz r4, 0(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCA050: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82FCA054: 8BEB0000  lbz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCA058: 208400FF  subfic r4, r4, 0xff
	ctx.xer.ca = ctx.r[4].u32 <= 255 as u32;
	ctx.r[4].s64 = (255 as i64) - ctx.r[4].s64;
	// 82FCA05C: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FCA060: 7C9F21D6  mullw r4, r31, r4
	ctx.r[4].s32 = ((ctx.r[31].s32 as i64 * ctx.r[4].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	// 82FCA064: 388400FF  addi r4, r4, 0xff
	ctx.r[4].s64 = ctx.r[4].s64 + 255;
	// 82FCA068: 5484C63E  rlwinm r4, r4, 0x18, 0x18, 0x1f
	ctx.r[4].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82FCA06C: 988B0000  stb r4, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u8 ) };
	// 82FCA070: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FCA074: 4082FFD8  bne 0x82fca04c
	if !ctx.cr[0].eq {
	pc = 0x82FCA04C; continue 'dispatch;
	}
	pc = 0x82FCA078; continue 'dispatch;
            }
            0x82FCA078 => {
    //   block [0x82FCA078..0x82FCA084)
	// 82FCA078: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82FCA07C: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82FCA080: 4198FF94  blt cr6, 0x82fca014
	if ctx.cr[6].lt {
	pc = 0x82FCA014; continue 'dispatch;
	}
	pc = 0x82FCA084; continue 'dispatch;
            }
            0x82FCA084 => {
    //   block [0x82FCA084..0x82FCA088)
	// 82FCA084: 4BCDF3D8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCA088(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCA088 size=104
    let mut pc: u32 = 0x82FCA088;
    'dispatch: loop {
        match pc {
            0x82FCA088 => {
    //   block [0x82FCA088..0x82FCA0AC)
	// 82FCA088: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCA08C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FCA090: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FCA094: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FCA098: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCA09C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCA0A0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCA0A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FCA0A8: 419A0018  beq cr6, 0x82fca0c0
	if ctx.cr[6].eq {
	pc = 0x82FCA0C0; continue 'dispatch;
	}
	pc = 0x82FCA0AC; continue 'dispatch;
            }
            0x82FCA0AC => {
    //   block [0x82FCA0AC..0x82FCA0C0)
	// 82FCA0AC: 83C313D8  lwz r30, 0x13d8(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(5080 as u32) ) } as u64;
	// 82FCA0B0: 4BF337F1  bl 0x82efd8a0
	ctx.lr = 0x82FCA0B4;
	sub_82EFD8A0(ctx, base);
	// 82FCA0B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FCA0B8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82FCA0BC: 409AFFF0  bne cr6, 0x82fca0ac
	if !ctx.cr[6].eq {
	pc = 0x82FCA0AC; continue 'dispatch;
	}
	pc = 0x82FCA0C0; continue 'dispatch;
            }
            0x82FCA0C0 => {
    //   block [0x82FCA0C0..0x82FCA0F0)
	// 82FCA0C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FCA0C4: 3940007F  li r10, 0x7f
	ctx.r[10].s64 = 127;
	// 82FCA0C8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FCA0CC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FCA0D0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82FCA0D4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82FCA0D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FCA0DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FCA0E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FCA0E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FCA0E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FCA0EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCA0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCA0F0 size=148
    let mut pc: u32 = 0x82FCA0F0;
    'dispatch: loop {
        match pc {
            0x82FCA0F0 => {
    //   block [0x82FCA0F0..0x82FCA11C)
	// 82FCA0F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCA0F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FCA0F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FCA0FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCA100: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCA104: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FCA108: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FCA10C: 419A0010  beq cr6, 0x82fca11c
	if ctx.cr[6].eq {
	pc = 0x82FCA11C; continue 'dispatch;
	}
	// 82FCA110: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCA114: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82FCA118: 48000058  b 0x82fca170
	pc = 0x82FCA170; continue 'dispatch;
            }
            0x82FCA11C => {
    //   block [0x82FCA11C..0x82FCA13C)
	// 82FCA11C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCA120: 2B0B007F  cmplwi cr6, r11, 0x7f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 127 as u32, &mut ctx.xer);
	// 82FCA124: 40980018  bge cr6, 0x82fca13c
	if !ctx.cr[6].lt {
	pc = 0x82FCA13C; continue 'dispatch;
	}
	// 82FCA128: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCA12C: 1D4B0028  mulli r10, r11, 0x28
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 40 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FCA130: 7C6A4A14  add r3, r10, r9
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82FCA134: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FCA138: 48000034  b 0x82fca16c
	pc = 0x82FCA16C; continue 'dispatch;
            }
            0x82FCA13C => {
    //   block [0x82FCA13C..0x82FCA160)
	// 82FCA13C: 386013DC  li r3, 0x13dc
	ctx.r[3].s64 = 5084;
	// 82FCA140: 4BF33721  bl 0x82efd860
	ctx.lr = 0x82FCA144;
	sub_82EFD860(ctx, base);
	// 82FCA144: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FCA148: 916313D8  stw r11, 0x13d8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(5080 as u32), ctx.r[11].u32 ) };
	// 82FCA14C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCA150: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FCA154: 419A000C  beq cr6, 0x82fca160
	if ctx.cr[6].eq {
	pc = 0x82FCA160; continue 'dispatch;
	}
	// 82FCA158: 906B13D8  stw r3, 0x13d8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(5080 as u32), ctx.r[3].u32 ) };
	// 82FCA15C: 48000008  b 0x82fca164
	pc = 0x82FCA164; continue 'dispatch;
            }
            0x82FCA160 => {
    //   block [0x82FCA160..0x82FCA164)
	// 82FCA160: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82FCA164; continue 'dispatch;
            }
            0x82FCA164 => {
    //   block [0x82FCA164..0x82FCA16C)
	// 82FCA164: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FCA168: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	pc = 0x82FCA16C; continue 'dispatch;
            }
            0x82FCA16C => {
    //   block [0x82FCA16C..0x82FCA170)
	// 82FCA16C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82FCA170; continue 'dispatch;
            }
            0x82FCA170 => {
    //   block [0x82FCA170..0x82FCA184)
	// 82FCA170: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FCA174: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FCA178: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FCA17C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FCA180: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCA188(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCA188 size=104
    let mut pc: u32 = 0x82FCA188;
    'dispatch: loop {
        match pc {
            0x82FCA188 => {
    //   block [0x82FCA188..0x82FCA1AC)
	// 82FCA188: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCA18C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FCA190: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FCA194: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FCA198: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCA19C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCA1A0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCA1A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FCA1A8: 419A0018  beq cr6, 0x82fca1c0
	if ctx.cr[6].eq {
	pc = 0x82FCA1C0; continue 'dispatch;
	}
	pc = 0x82FCA1AC; continue 'dispatch;
            }
            0x82FCA1AC => {
    //   block [0x82FCA1AC..0x82FCA1C0)
	// 82FCA1AC: 83C311DC  lwz r30, 0x11dc(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4572 as u32) ) } as u64;
	// 82FCA1B0: 4BF336F1  bl 0x82efd8a0
	ctx.lr = 0x82FCA1B4;
	sub_82EFD8A0(ctx, base);
	// 82FCA1B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FCA1B8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82FCA1BC: 409AFFF0  bne cr6, 0x82fca1ac
	if !ctx.cr[6].eq {
	pc = 0x82FCA1AC; continue 'dispatch;
	}
	pc = 0x82FCA1C0; continue 'dispatch;
            }
            0x82FCA1C0 => {
    //   block [0x82FCA1C0..0x82FCA1F0)
	// 82FCA1C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FCA1C4: 3940007F  li r10, 0x7f
	ctx.r[10].s64 = 127;
	// 82FCA1C8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FCA1CC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FCA1D0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82FCA1D4: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82FCA1D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FCA1DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FCA1E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FCA1E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FCA1E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FCA1EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCA1F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCA1F0 size=148
    let mut pc: u32 = 0x82FCA1F0;
    'dispatch: loop {
        match pc {
            0x82FCA1F0 => {
    //   block [0x82FCA1F0..0x82FCA21C)
	// 82FCA1F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCA1F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FCA1F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FCA1FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCA200: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCA204: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FCA208: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FCA20C: 419A0010  beq cr6, 0x82fca21c
	if ctx.cr[6].eq {
	pc = 0x82FCA21C; continue 'dispatch;
	}
	// 82FCA210: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FCA214: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82FCA218: 48000058  b 0x82fca270
	pc = 0x82FCA270; continue 'dispatch;
            }
            0x82FCA21C => {
    //   block [0x82FCA21C..0x82FCA23C)
	// 82FCA21C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCA220: 2B0B007F  cmplwi cr6, r11, 0x7f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 127 as u32, &mut ctx.xer);
	// 82FCA224: 40980018  bge cr6, 0x82fca23c
	if !ctx.cr[6].lt {
	pc = 0x82FCA23C; continue 'dispatch;
	}
	// 82FCA228: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCA22C: 1D4B0024  mulli r10, r11, 0x24
	ctx.r[10].s32 = ((ctx.r[11].s32 as i64 * 36 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FCA230: 7C6A4A14  add r3, r10, r9
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 82FCA234: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FCA238: 48000034  b 0x82fca26c
	pc = 0x82FCA26C; continue 'dispatch;
            }
            0x82FCA23C => {
    //   block [0x82FCA23C..0x82FCA260)
	// 82FCA23C: 386011E0  li r3, 0x11e0
	ctx.r[3].s64 = 4576;
	// 82FCA240: 4BF33621  bl 0x82efd860
	ctx.lr = 0x82FCA244;
	sub_82EFD860(ctx, base);
	// 82FCA244: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FCA248: 916311DC  stw r11, 0x11dc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4572 as u32), ctx.r[11].u32 ) };
	// 82FCA24C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCA250: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FCA254: 419A000C  beq cr6, 0x82fca260
	if ctx.cr[6].eq {
	pc = 0x82FCA260; continue 'dispatch;
	}
	// 82FCA258: 906B11DC  stw r3, 0x11dc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4572 as u32), ctx.r[3].u32 ) };
	// 82FCA25C: 48000008  b 0x82fca264
	pc = 0x82FCA264; continue 'dispatch;
            }
            0x82FCA260 => {
    //   block [0x82FCA260..0x82FCA264)
	// 82FCA260: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82FCA264; continue 'dispatch;
            }
            0x82FCA264 => {
    //   block [0x82FCA264..0x82FCA26C)
	// 82FCA264: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FCA268: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	pc = 0x82FCA26C; continue 'dispatch;
            }
            0x82FCA26C => {
    //   block [0x82FCA26C..0x82FCA270)
	// 82FCA26C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82FCA270; continue 'dispatch;
            }
            0x82FCA270 => {
    //   block [0x82FCA270..0x82FCA284)
	// 82FCA270: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FCA274: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FCA278: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FCA27C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FCA280: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCA288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCA288 size=96
    let mut pc: u32 = 0x82FCA288;
    'dispatch: loop {
        match pc {
            0x82FCA288 => {
    //   block [0x82FCA288..0x82FCA2C4)
	// 82FCA288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCA28C: 4BCDF181  bl 0x82ca940c
	ctx.lr = 0x82FCA290;
	sub_82CA93D0(ctx, base);
	// 82FCA290: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCA294: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCA298: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FCA29C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82FCA2A0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FCA2A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCA2A8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82FCA2AC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FCA2B0: 40990030  ble cr6, 0x82fca2e0
	if !ctx.cr[6].gt {
	pc = 0x82FCA2E0; continue 'dispatch;
	}
	// 82FCA2B4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCA2B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FCA2BC: 419A0008  beq cr6, 0x82fca2c4
	if ctx.cr[6].eq {
	pc = 0x82FCA2C4; continue 'dispatch;
	}
	// 82FCA2C0: 4BF335E1  bl 0x82efd8a0
	ctx.lr = 0x82FCA2C4;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FCA2C4; continue 'dispatch;
            }
            0x82FCA2C4 => {
    //   block [0x82FCA2C4..0x82FCA2D8)
	// 82FCA2C4: 7C7EEA15  add. r3, r30, r29
	ctx.r[3].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82FCA2C8: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82FCA2CC: 4182000C  beq 0x82fca2d8
	if ctx.cr[0].eq {
	pc = 0x82FCA2D8; continue 'dispatch;
	}
	// 82FCA2D0: 4BF33591  bl 0x82efd860
	ctx.lr = 0x82FCA2D4;
	sub_82EFD860(ctx, base);
	// 82FCA2D4: 48000008  b 0x82fca2dc
	pc = 0x82FCA2DC; continue 'dispatch;
            }
            0x82FCA2D8 => {
    //   block [0x82FCA2D8..0x82FCA2DC)
	// 82FCA2D8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82FCA2DC; continue 'dispatch;
            }
            0x82FCA2DC => {
    //   block [0x82FCA2DC..0x82FCA2E0)
	// 82FCA2DC: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	pc = 0x82FCA2E0; continue 'dispatch;
            }
            0x82FCA2E0 => {
    //   block [0x82FCA2E0..0x82FCA2E8)
	// 82FCA2E0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FCA2E4: 4BCDF178  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCA2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCA2E8 size=100
    let mut pc: u32 = 0x82FCA2E8;
    'dispatch: loop {
        match pc {
            0x82FCA2E8 => {
    //   block [0x82FCA2E8..0x82FCA324)
	// 82FCA2E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCA2EC: 4BCDF121  bl 0x82ca940c
	ctx.lr = 0x82FCA2F0;
	sub_82CA93D0(ctx, base);
	// 82FCA2F0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCA2F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCA2F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FCA2FC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82FCA300: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FCA304: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCA308: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82FCA30C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FCA310: 40990034  ble cr6, 0x82fca344
	if !ctx.cr[6].gt {
	pc = 0x82FCA344; continue 'dispatch;
	}
	// 82FCA314: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCA318: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FCA31C: 419A0008  beq cr6, 0x82fca324
	if ctx.cr[6].eq {
	pc = 0x82FCA324; continue 'dispatch;
	}
	// 82FCA320: 4BF33581  bl 0x82efd8a0
	ctx.lr = 0x82FCA324;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FCA324; continue 'dispatch;
            }
            0x82FCA324 => {
    //   block [0x82FCA324..0x82FCA33C)
	// 82FCA324: 7D7EEA15  add. r11, r30, r29
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FCA328: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FCA32C: 41820010  beq 0x82fca33c
	if ctx.cr[0].eq {
	pc = 0x82FCA33C; continue 'dispatch;
	}
	// 82FCA330: 1C6B0030  mulli r3, r11, 0x30
	ctx.r[3].s32 = ((ctx.r[11].s32 as i64 * 48 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82FCA334: 4BF3352D  bl 0x82efd860
	ctx.lr = 0x82FCA338;
	sub_82EFD860(ctx, base);
	// 82FCA338: 48000008  b 0x82fca340
	pc = 0x82FCA340; continue 'dispatch;
            }
            0x82FCA33C => {
    //   block [0x82FCA33C..0x82FCA340)
	// 82FCA33C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82FCA340; continue 'dispatch;
            }
            0x82FCA340 => {
    //   block [0x82FCA340..0x82FCA344)
	// 82FCA340: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	pc = 0x82FCA344; continue 'dispatch;
            }
            0x82FCA344 => {
    //   block [0x82FCA344..0x82FCA34C)
	// 82FCA344: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FCA348: 4BCDF114  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCA350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCA350 size=120
    let mut pc: u32 = 0x82FCA350;
    'dispatch: loop {
        match pc {
            0x82FCA350 => {
    //   block [0x82FCA350..0x82FCA37C)
	// 82FCA350: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCA354: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FCA358: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FCA35C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCA360: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCA364: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCA368: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FCA36C: 419A0048  beq cr6, 0x82fca3b4
	if ctx.cr[6].eq {
	pc = 0x82FCA3B4; continue 'dispatch;
	}
	// 82FCA370: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCA374: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FCA378: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	pc = 0x82FCA37C; continue 'dispatch;
            }
            0x82FCA37C => {
    //   block [0x82FCA37C..0x82FCA398)
	// 82FCA37C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCA380: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FCA384: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCA388: 2F08FFFE  cmpwi cr6, r8, -2
	ctx.cr[6].compare_i32(ctx.r[8].s32, -2, &mut ctx.xer);
	// 82FCA38C: 419A000C  beq cr6, 0x82fca398
	if ctx.cr[6].eq {
	pc = 0x82FCA398; continue 'dispatch;
	}
	// 82FCA390: 3900FFFE  li r8, -2
	ctx.r[8].s64 = -2;
	// 82FCA394: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x82FCA398; continue 'dispatch;
            }
            0x82FCA398 => {
    //   block [0x82FCA398..0x82FCA3B4)
	// 82FCA398: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82FCA39C: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82FCA3A0: 4082FFDC  bne 0x82fca37c
	if !ctx.cr[0].eq {
	pc = 0x82FCA37C; continue 'dispatch;
	}
	// 82FCA3A4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCA3A8: 4BF334F9  bl 0x82efd8a0
	ctx.lr = 0x82FCA3AC;
	sub_82EFD8A0(ctx, base);
	// 82FCA3AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FCA3B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82FCA3B4; continue 'dispatch;
            }
            0x82FCA3B4 => {
    //   block [0x82FCA3B4..0x82FCA3C8)
	// 82FCA3B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FCA3B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FCA3BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FCA3C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FCA3C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCA3C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCA3C8 size=100
    let mut pc: u32 = 0x82FCA3C8;
    'dispatch: loop {
        match pc {
            0x82FCA3C8 => {
    //   block [0x82FCA3C8..0x82FCA404)
	// 82FCA3C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCA3CC: 4BCDF041  bl 0x82ca940c
	ctx.lr = 0x82FCA3D0;
	sub_82CA93D0(ctx, base);
	// 82FCA3D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCA3D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCA3D8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FCA3DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82FCA3E0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FCA3E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCA3E8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82FCA3EC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FCA3F0: 40990034  ble cr6, 0x82fca424
	if !ctx.cr[6].gt {
	pc = 0x82FCA424; continue 'dispatch;
	}
	// 82FCA3F4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCA3F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FCA3FC: 419A0008  beq cr6, 0x82fca404
	if ctx.cr[6].eq {
	pc = 0x82FCA404; continue 'dispatch;
	}
	// 82FCA400: 4BF334A1  bl 0x82efd8a0
	ctx.lr = 0x82FCA404;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FCA404; continue 'dispatch;
            }
            0x82FCA404 => {
    //   block [0x82FCA404..0x82FCA41C)
	// 82FCA404: 7D7EEA15  add. r11, r30, r29
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[29].u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FCA408: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FCA40C: 41820010  beq 0x82fca41c
	if ctx.cr[0].eq {
	pc = 0x82FCA41C; continue 'dispatch;
	}
	// 82FCA410: 1C6B0018  mulli r3, r11, 0x18
	ctx.r[3].s32 = ((ctx.r[11].s32 as i64 * 24 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82FCA414: 4BF3344D  bl 0x82efd860
	ctx.lr = 0x82FCA418;
	sub_82EFD860(ctx, base);
	// 82FCA418: 48000008  b 0x82fca420
	pc = 0x82FCA420; continue 'dispatch;
            }
            0x82FCA41C => {
    //   block [0x82FCA41C..0x82FCA420)
	// 82FCA41C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82FCA420; continue 'dispatch;
            }
            0x82FCA420 => {
    //   block [0x82FCA420..0x82FCA424)
	// 82FCA420: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	pc = 0x82FCA424; continue 'dispatch;
            }
            0x82FCA424 => {
    //   block [0x82FCA424..0x82FCA42C)
	// 82FCA424: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FCA428: 4BCDF034  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCA430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCA430 size=152
    let mut pc: u32 = 0x82FCA430;
    'dispatch: loop {
        match pc {
            0x82FCA430 => {
    //   block [0x82FCA430..0x82FCA48C)
	// 82FCA430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCA434: 4BCDEFD9  bl 0x82ca940c
	ctx.lr = 0x82FCA438;
	sub_82CA93D0(ctx, base);
	// 82FCA438: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCA43C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCA440: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82FCA444: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCA448: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FCA44C: 41980054  blt cr6, 0x82fca4a0
	if ctx.cr[6].lt {
	pc = 0x82FCA4A0; continue 'dispatch;
	}
	// 82FCA450: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FCA454: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FCA458: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82FCA45C: 4BF33405  bl 0x82efd860
	ctx.lr = 0x82FCA460;
	sub_82EFD860(ctx, base);
	// 82FCA460: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FCA464: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FCA468: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FCA46C: 419A0020  beq cr6, 0x82fca48c
	if ctx.cr[6].eq {
	pc = 0x82FCA48C; continue 'dispatch;
	}
	// 82FCA470: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCA474: 5565103A  slwi r5, r11, 2
	ctx.r[5].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82FCA478: 4BCDF009  bl 0x82ca9480
	ctx.lr = 0x82FCA47C;
	sub_82CA9480(ctx, base);
	// 82FCA47C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FCA480: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FCA484: 419A0008  beq cr6, 0x82fca48c
	if ctx.cr[6].eq {
	pc = 0x82FCA48C; continue 'dispatch;
	}
	// 82FCA488: 4BF33419  bl 0x82efd8a0
	ctx.lr = 0x82FCA48C;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FCA48C; continue 'dispatch;
            }
            0x82FCA48C => {
    //   block [0x82FCA48C..0x82FCA4A0)
	// 82FCA48C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCA490: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FCA494: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82FCA498: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FCA49C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82FCA4A0; continue 'dispatch;
            }
            0x82FCA4A0 => {
    //   block [0x82FCA4A0..0x82FCA4C8)
	// 82FCA4A0: 38600700  li r3, 0x700
	ctx.r[3].s64 = 1792;
	// 82FCA4A4: 4BF333BD  bl 0x82efd860
	ctx.lr = 0x82FCA4A8;
	sub_82EFD860(ctx, base);
	// 82FCA4A8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FCA4AC: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82FCA4B0: 7C6A592E  stwx r3, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[3].u32) };
	// 82FCA4B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCA4B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FCA4BC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FCA4C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FCA4C4: 4BCDEF98  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCA4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82FCA4C8 size=80
    let mut pc: u32 = 0x82FCA4C8;
    'dispatch: loop {
        match pc {
            0x82FCA4C8 => {
    //   block [0x82FCA4C8..0x82FCA518)
	// 82FCA4C8: 89440008  lbz r10, 8(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCA4CC: 8964000A  lbz r11, 0xa(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(10 as u32) ) } as u64;
	// 82FCA4D0: 89240007  lbz r9, 7(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(7 as u32) ) } as u64;
	// 82FCA4D4: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82FCA4D8: 89440006  lbz r10, 6(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(6 as u32) ) } as u64;
	// 82FCA4DC: 8904000B  lbz r8, 0xb(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(11 as u32) ) } as u64;
	// 82FCA4E0: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82FCA4E4: 89240009  lbz r9, 9(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(9 as u32) ) } as u64;
	// 82FCA4E8: 80E40000  lwz r7, 0(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCA4EC: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82FCA4F0: A1440004  lhz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCA4F4: 5529083E  rotlwi r9, r9, 1
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 82FCA4F8: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82FCA4FC: 54E6D1BE  srwi r6, r7, 6
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shr(6);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82FCA500: 7D6B4278  xor r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[8].u64;
	// 82FCA504: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82FCA508: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82FCA50C: 7D6B3278  xor r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[6].u64;
	// 82FCA510: 7D653A78  xor r5, r11, r7
	ctx.r[5].u64 = ctx.r[11].u64 ^ ctx.r[7].u64;
	// 82FCA514: 48001934  b 0x82fcbe48
	sub_82FCBE48(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCA518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCA518 size=188
    let mut pc: u32 = 0x82FCA518;
    'dispatch: loop {
        match pc {
            0x82FCA518 => {
    //   block [0x82FCA518..0x82FCA5D4)
	// 82FCA518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCA51C: 4BCDEEE9  bl 0x82ca9404
	ctx.lr = 0x82FCA520;
	sub_82CA93D0(ctx, base);
	// 82FCA520: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCA524: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCA528: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FCA52C: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82FCA530: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FCA534: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82FCA538: 4BFFFBB9  bl 0x82fca0f0
	ctx.lr = 0x82FCA53C;
	sub_82FCA0F0(ctx, base);
	// 82FCA53C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82FCA540: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82FCA544: 4BFFFCAD  bl 0x82fca1f0
	ctx.lr = 0x82FCA548;
	sub_82FCA1F0(ctx, base);
	// 82FCA548: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82FCA54C: 93DB001C  stw r30, 0x1c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82FCA550: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FCA554: 915B0008  stw r10, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82FCA558: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82FCA55C: A0FE0000  lhz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCA560: B0FB0020  sth r7, 0x20(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[7].u16 ) };
	// 82FCA564: B17B0026  sth r11, 0x26(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(38 as u32), ctx.r[11].u16 ) };
	// 82FCA568: B3BB0022  sth r29, 0x22(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(34 as u32), ctx.r[29].u16 ) };
	// 82FCA56C: B39B0024  sth r28, 0x24(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(36 as u32), ctx.r[28].u16 ) };
	// 82FCA570: 936A000C  stw r27, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 82FCA574: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FCA578: B16A0004  sth r11, 4(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u16 ) };
	// 82FCA57C: 996A0006  stb r11, 6(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(6 as u32), ctx.r[11].u8 ) };
	// 82FCA580: 996A0007  stb r11, 7(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(7 as u32), ctx.r[11].u8 ) };
	// 82FCA584: 996A0008  stb r11, 8(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 82FCA588: 996A0009  stb r11, 9(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(9 as u32), ctx.r[11].u8 ) };
	// 82FCA58C: 996A000A  stb r11, 0xa(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(10 as u32), ctx.r[11].u8 ) };
	// 82FCA590: 996A000B  stb r11, 0xb(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(11 as u32), ctx.r[11].u8 ) };
	// 82FCA594: 916A0010  stw r11, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82FCA598: 916A0014  stw r11, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82FCA59C: A0FB0022  lhz r7, 0x22(r27)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(34 as u32) ) } as u64;
	// 82FCA5A0: B0E10050  sth r7, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u16 ) };
	// 82FCA5A4: A11E0004  lhz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCA5A8: A0FE0002  lhz r7, 2(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 82FCA5AC: A13B0024  lhz r9, 0x24(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FCA5B0: B1210054  sth r9, 0x54(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u16 ) };
	// 82FCA5B4: B0E10052  sth r7, 0x52(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[7].u16 ) };
	// 82FCA5B8: B1010056  sth r8, 0x56(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(86 as u32), ctx.r[8].u16 ) };
	// 82FCA5BC: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FCA5C0: B16A0020  sth r11, 0x20(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[11].u16 ) };
	// 82FCA5C4: B16A0022  sth r11, 0x22(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(34 as u32), ctx.r[11].u16 ) };
	// 82FCA5C8: F92A0018  std r9, 0x18(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[9].u64 ) };
	// 82FCA5CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82FCA5D0: 4BCDEE84  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCA5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCA5D8 size=112
    let mut pc: u32 = 0x82FCA5D8;
    'dispatch: loop {
        match pc {
            0x82FCA5D8 => {
    //   block [0x82FCA5D8..0x82FCA5FC)
	// 82FCA5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCA5DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FCA5E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FCA5E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCA5E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCA5EC: 807F0060  lwz r3, 0x60(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82FCA5F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FCA5F4: 419A0008  beq cr6, 0x82fca5fc
	if ctx.cr[6].eq {
	pc = 0x82FCA5FC; continue 'dispatch;
	}
	// 82FCA5F8: 4BF332A9  bl 0x82efd8a0
	ctx.lr = 0x82FCA5FC;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FCA5FC; continue 'dispatch;
            }
            0x82FCA5FC => {
    //   block [0x82FCA5FC..0x82FCA60C)
	// 82FCA5FC: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FCA600: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FCA604: 419A0008  beq cr6, 0x82fca60c
	if ctx.cr[6].eq {
	pc = 0x82FCA60C; continue 'dispatch;
	}
	// 82FCA608: 4BF33299  bl 0x82efd8a0
	ctx.lr = 0x82FCA60C;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FCA60C; continue 'dispatch;
            }
            0x82FCA60C => {
    //   block [0x82FCA60C..0x82FCA624)
	// 82FCA60C: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 82FCA610: 4BFF8B19  bl 0x82fc3128
	ctx.lr = 0x82FCA614;
	sub_82FC3128(ctx, base);
	// 82FCA614: 807F0034  lwz r3, 0x34(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82FCA618: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FCA61C: 419A0008  beq cr6, 0x82fca624
	if ctx.cr[6].eq {
	pc = 0x82FCA624; continue 'dispatch;
	}
	// 82FCA620: 4BF33281  bl 0x82efd8a0
	ctx.lr = 0x82FCA624;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FCA624; continue 'dispatch;
            }
            0x82FCA624 => {
    //   block [0x82FCA624..0x82FCA648)
	// 82FCA624: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 82FCA628: 4BFF8B01  bl 0x82fc3128
	ctx.lr = 0x82FCA62C;
	sub_82FC3128(ctx, base);
	// 82FCA62C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82FCA630: 4BFF8AF9  bl 0x82fc3128
	ctx.lr = 0x82FCA634;
	sub_82FC3128(ctx, base);
	// 82FCA634: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FCA638: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FCA63C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FCA640: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FCA644: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCA648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCA648 size=104
    let mut pc: u32 = 0x82FCA648;
    'dispatch: loop {
        match pc {
            0x82FCA648 => {
    //   block [0x82FCA648..0x82FCA67C)
	// 82FCA648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCA64C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FCA650: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FCA654: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FCA658: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCA65C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCA660: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCA664: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCA668: 557ED1BE  srwi r30, r11, 6
	ctx.r[30].u32 = ctx.r[11].u32.wrapping_shr(6);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 82FCA66C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82FCA670: 4198000C  blt cr6, 0x82fca67c
	if ctx.cr[6].lt {
	pc = 0x82FCA67C; continue 'dispatch;
	}
	// 82FCA674: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FCA678: 4BFFFDB9  bl 0x82fca430
	ctx.lr = 0x82FCA67C;
	sub_82FCA430(ctx, base);
	pc = 0x82FCA67C; continue 'dispatch;
            }
            0x82FCA67C => {
    //   block [0x82FCA67C..0x82FCA6B0)
	// 82FCA67C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FCA680: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82FCA684: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCA688: 552906BE  clrlwi r9, r9, 0x1a
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000003Fu64;
	// 82FCA68C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82FCA690: 1D49001C  mulli r10, r9, 0x1c
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * 28 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FCA694: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FCA698: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FCA69C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FCA6A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FCA6A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FCA6A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FCA6AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCA6B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FCA6B0 size=308
    let mut pc: u32 = 0x82FCA6B0;
    'dispatch: loop {
        match pc {
            0x82FCA6B0 => {
    //   block [0x82FCA6B0..0x82FCA6CC)
	// 82FCA6B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCA6B4: 4BCDED4D  bl 0x82ca9400
	ctx.lr = 0x82FCA6B8;
	sub_82CA93D0(ctx, base);
	// 82FCA6B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCA6BC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82FCA6C0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82FCA6C4: 409A0008  bne cr6, 0x82fca6cc
	if !ctx.cr[6].eq {
	pc = 0x82FCA6CC; continue 'dispatch;
	}
	// 82FCA6C8: 48000110  b 0x82fca7d8
	pc = 0x82FCA7D8; continue 'dispatch;
            }
            0x82FCA6CC => {
    //   block [0x82FCA6CC..0x82FCA6DC)
	// 82FCA6CC: 2B040008  cmplwi cr6, r4, 8
	ctx.cr[6].compare_u32(ctx.r[4].u32, 8 as u32, &mut ctx.xer);
	// 82FCA6D0: 4098000C  bge cr6, 0x82fca6dc
	if !ctx.cr[6].lt {
	pc = 0x82FCA6DC; continue 'dispatch;
	}
	// 82FCA6D4: 3BE00008  li r31, 8
	ctx.r[31].s64 = 8;
	// 82FCA6D8: 4800004C  b 0x82fca724
	pc = 0x82FCA724; continue 'dispatch;
            }
            0x82FCA6DC => {
    //   block [0x82FCA6DC..0x82FCA724)
	// 82FCA6DC: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 82FCA6E0: 796B0020  clrldi r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82FCA6E4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82FCA6E8: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FCA6EC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FCA6F0: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FCA6F4: 4B2296BD  bl 0x821f3db0
	ctx.lr = 0x82FCA6F8;
	sub_821F3DB0(ctx, base);
	// 82FCA6F8: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FCA6FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82FCA700: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FCA704: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82FCA708: C00B3FA8  lfs f0, 0x3fa8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FCA70C: C1AA0C14  lfs f13, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FCA710: EC0C683A  fmadds f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FCA714: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82FCA718: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FCA71C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FCA720: 7D3F5830  slw r31, r9, r11
	if (ctx.r[11].u8 & 0x20) != 0 {
		ctx.r[31].u64 = 0;
	} else {
		ctx.r[31].u64 = ((ctx.r[9].u32) << ((ctx.r[11].u8 & 0x1F) as u32)) as u64;
	}
	pc = 0x82FCA724; continue 'dispatch;
            }
            0x82FCA724 => {
    //   block [0x82FCA724..0x82FCA75C)
	// 82FCA724: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82FCA728: 1D7F0014  mulli r11, r31, 0x14
	ctx.r[11].s32 = ((ctx.r[31].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FCA72C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82FCA730: 386B0008  addi r3, r11, 8
	ctx.r[3].s64 = ctx.r[11].s64 + 8;
	// 82FCA734: 4BF3312D  bl 0x82efd860
	ctx.lr = 0x82FCA738;
	sub_82EFD860(ctx, base);
	// 82FCA738: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82FCA73C: 397FFFFF  addi r11, r31, -1
	ctx.r[11].s64 = ctx.r[31].s64 + -1;
	// 82FCA740: 93830000  stw r28, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82FCA744: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FCA748: 3B60FFFE  li r27, -2
	ctx.r[27].s64 = -2;
	// 82FCA74C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82FCA750: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FCA754: 419A0020  beq cr6, 0x82fca774
	if ctx.cr[6].eq {
	pc = 0x82FCA774; continue 'dispatch;
	}
	// 82FCA758: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82FCA75C; continue 'dispatch;
            }
            0x82FCA75C => {
    //   block [0x82FCA75C..0x82FCA774)
	// 82FCA75C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FCA760: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82FCA764: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FCA768: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 82FCA76C: 936A0008  stw r27, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82FCA770: 4082FFEC  bne 0x82fca75c
	if !ctx.cr[0].eq {
	pc = 0x82FCA75C; continue 'dispatch;
	}
	pc = 0x82FCA774; continue 'dispatch;
            }
            0x82FCA774 => {
    //   block [0x82FCA774..0x82FCA78C)
	// 82FCA774: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCA778: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FCA77C: 419A004C  beq cr6, 0x82fca7c8
	if ctx.cr[6].eq {
	pc = 0x82FCA7C8; continue 'dispatch;
	}
	// 82FCA780: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCA784: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 82FCA788: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	pc = 0x82FCA78C; continue 'dispatch;
            }
            0x82FCA78C => {
    //   block [0x82FCA78C..0x82FCA7B4)
	// 82FCA78C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCA790: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82FCA794: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82FCA798: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCA79C: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 82FCA7A0: 419A0014  beq cr6, 0x82fca7b4
	if ctx.cr[6].eq {
	pc = 0x82FCA7B4; continue 'dispatch;
	}
	// 82FCA7A4: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82FCA7A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82FCA7AC: 4BFFFD1D  bl 0x82fca4c8
	ctx.lr = 0x82FCA7B0;
	sub_82FCA4C8(ctx, base);
	// 82FCA7B0: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x82FCA7B4; continue 'dispatch;
            }
            0x82FCA7B4 => {
    //   block [0x82FCA7B4..0x82FCA7C8)
	// 82FCA7B4: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82FCA7B8: 3BDE0014  addi r30, r30, 0x14
	ctx.r[30].s64 = ctx.r[30].s64 + 20;
	// 82FCA7BC: 4082FFD0  bne 0x82fca78c
	if !ctx.cr[0].eq {
	pc = 0x82FCA78C; continue 'dispatch;
	}
	// 82FCA7C0: 807A0000  lwz r3, 0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCA7C4: 4BF330DD  bl 0x82efd8a0
	ctx.lr = 0x82FCA7C8;
	sub_82EFD8A0(ctx, base);
	pc = 0x82FCA7C8; continue 'dispatch;
            }
            0x82FCA7C8 => {
    //   block [0x82FCA7C8..0x82FCA7D8)
	// 82FCA7C8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FCA7CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82FCA7D0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82FCA7D4: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82FCA7D8; continue 'dispatch;
            }
            0x82FCA7D8 => {
    //   block [0x82FCA7D8..0x82FCA7E4)
	// 82FCA7D8: 4BFFFB79  bl 0x82fca350
	ctx.lr = 0x82FCA7DC;
	sub_82FCA350(ctx, base);
	// 82FCA7DC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82FCA7E0: 4BCDEC70  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCA7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCA7E8 size=300
    let mut pc: u32 = 0x82FCA7E8;
    'dispatch: loop {
        match pc {
            0x82FCA7E8 => {
    //   block [0x82FCA7E8..0x82FCA878)
	// 82FCA7E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCA7EC: 4BCDEC15  bl 0x82ca9400
	ctx.lr = 0x82FCA7F0;
	sub_82CA93D0(ctx, base);
	// 82FCA7F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCA7F4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82FCA7F8: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCA7FC: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82FCA800: 1D7E0014  mulli r11, r30, 0x14
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FCA804: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82FCA808: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 82FCA80C: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82FCA810: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCA814: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 82FCA818: 419A00F0  beq cr6, 0x82fca908
	if ctx.cr[6].eq {
	pc = 0x82FCA908; continue 'dispatch;
	}
	// 82FCA81C: 895F000C  lbz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FCA820: 897F000E  lbz r11, 0xe(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(14 as u32) ) } as u64;
	// 82FCA824: 893F000B  lbz r9, 0xb(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(11 as u32) ) } as u64;
	// 82FCA828: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82FCA82C: 895F000A  lbz r10, 0xa(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	// 82FCA830: 891F000F  lbz r8, 0xf(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(15 as u32) ) } as u64;
	// 82FCA834: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82FCA838: 893F000D  lbz r9, 0xd(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(13 as u32) ) } as u64;
	// 82FCA83C: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCA840: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82FCA844: A15F0008  lhz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCA848: 5529083E  rotlwi r9, r9, 1
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 82FCA84C: 837D0004  lwz r27, 4(r29)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCA850: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82FCA854: 54E6D1BE  srwi r6, r7, 6
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shr(6);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82FCA858: 7D6B4278  xor r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[8].u64;
	// 82FCA85C: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82FCA860: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82FCA864: 7D6B3278  xor r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[6].u64;
	// 82FCA868: 7D6B3A78  xor r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[7].u64;
	// 82FCA86C: 7D6BD838  and r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[27].u64;
	// 82FCA870: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82FCA874: 409A0094  bne cr6, 0x82fca908
	if !ctx.cr[6].eq {
	pc = 0x82FCA908; continue 'dispatch;
	}
	pc = 0x82FCA878; continue 'dispatch;
            }
            0x82FCA878 => {
    //   block [0x82FCA878..0x82FCA8E4)
	// 82FCA878: 895F000C  lbz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FCA87C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82FCA880: 897F000E  lbz r11, 0xe(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(14 as u32) ) } as u64;
	// 82FCA884: 893F000B  lbz r9, 0xb(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(11 as u32) ) } as u64;
	// 82FCA888: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82FCA88C: 895F000A  lbz r10, 0xa(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	// 82FCA890: 891F000F  lbz r8, 0xf(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(15 as u32) ) } as u64;
	// 82FCA894: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82FCA898: 893F000D  lbz r9, 0xd(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(13 as u32) ) } as u64;
	// 82FCA89C: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCA8A0: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82FCA8A4: A15F0008  lhz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCA8A8: 5529083E  rotlwi r9, r9, 1
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 82FCA8AC: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82FCA8B0: 54E6D1BE  srwi r6, r7, 6
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shr(6);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82FCA8B4: 7D6B4278  xor r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[8].u64;
	// 82FCA8B8: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82FCA8BC: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82FCA8C0: 7D6B3278  xor r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[6].u64;
	// 82FCA8C4: 7D6B3A78  xor r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[7].u64;
	// 82FCA8C8: 7D6BD838  and r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[27].u64;
	// 82FCA8CC: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82FCA8D0: 409A0014  bne cr6, 0x82fca8e4
	if !ctx.cr[6].eq {
	pc = 0x82FCA8E4; continue 'dispatch;
	}
	// 82FCA8D4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82FCA8D8: 4BF974B9  bl 0x82f61d90
	ctx.lr = 0x82FCA8DC;
	sub_82F61D90(ctx, base);
	// 82FCA8DC: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FCA8E0: 40820020  bne 0x82fca900
	if !ctx.cr[0].eq {
	pc = 0x82FCA900; continue 'dispatch;
	}
	pc = 0x82FCA8E4; continue 'dispatch;
            }
            0x82FCA8E4 => {
    //   block [0x82FCA8E4..0x82FCA900)
	// 82FCA8E4: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCA8E8: 2F1CFFFF  cmpwi cr6, r28, -1
	ctx.cr[6].compare_i32(ctx.r[28].s32, -1, &mut ctx.xer);
	// 82FCA8EC: 419A001C  beq cr6, 0x82fca908
	if ctx.cr[6].eq {
	pc = 0x82FCA908; continue 'dispatch;
	}
	// 82FCA8F0: 1D7C0014  mulli r11, r28, 0x14
	ctx.r[11].s32 = ((ctx.r[28].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FCA8F4: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82FCA8F8: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82FCA8FC: 4BFFFF7C  b 0x82fca878
	pc = 0x82FCA878; continue 'dispatch;
            }
            0x82FCA900 => {
    //   block [0x82FCA900..0x82FCA908)
	// 82FCA900: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FCA904: 48000008  b 0x82fca90c
	pc = 0x82FCA90C; continue 'dispatch;
            }
            0x82FCA908 => {
    //   block [0x82FCA908..0x82FCA90C)
	// 82FCA908: 3860FFFF  li r3, -1
	ctx.r[3].s64 = -1;
	pc = 0x82FCA90C; continue 'dispatch;
            }
            0x82FCA90C => {
    //   block [0x82FCA90C..0x82FCA914)
	// 82FCA90C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82FCA910: 4BCDEB40  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCA918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCA918 size=168
    let mut pc: u32 = 0x82FCA918;
    'dispatch: loop {
        match pc {
            0x82FCA918 => {
    //   block [0x82FCA918..0x82FCA968)
	// 82FCA918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCA91C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FCA920: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82FCA924: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FCA928: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCA92C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCA930: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 82FCA934: 4BFFFA1D  bl 0x82fca350
	ctx.lr = 0x82FCA938;
	sub_82FCA350(ctx, base);
	// 82FCA938: 397F002C  addi r11, r31, 0x2c
	ctx.r[11].s64 = ctx.r[31].s64 + 44;
	// 82FCA93C: 393F0038  addi r9, r31, 0x38
	ctx.r[9].s64 = ctx.r[31].s64 + 56;
	// 82FCA940: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82FCA944: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82FCA948: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82FCA94C: 913F004C  stw r9, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[9].u32 ) };
	// 82FCA950: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82FCA954: 913F0050  stw r9, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82FCA958: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82FCA95C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FCA960: 40990030  ble cr6, 0x82fca990
	if !ctx.cr[6].gt {
	pc = 0x82FCA990; continue 'dispatch;
	}
	// 82FCA964: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	pc = 0x82FCA968; continue 'dispatch;
            }
            0x82FCA968 => {
    //   block [0x82FCA968..0x82FCA990)
	// 82FCA968: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 82FCA96C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82FCA970: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82FCA974: 39290030  addi r9, r9, 0x30
	ctx.r[9].s64 = ctx.r[9].s64 + 48;
	// 82FCA978: 390B0008  addi r8, r11, 8
	ctx.r[8].s64 = ctx.r[11].s64 + 8;
	// 82FCA97C: 910B0014  stw r8, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82FCA980: 910B0018  stw r8, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82FCA984: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82FCA988: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FCA98C: 4198FFDC  blt cr6, 0x82fca968
	if ctx.cr[6].lt {
	pc = 0x82FCA968; continue 'dispatch;
	}
	pc = 0x82FCA990; continue 'dispatch;
            }
            0x82FCA990 => {
    //   block [0x82FCA990..0x82FCA9C0)
	// 82FCA990: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82FCA994: 4BFFF6F5  bl 0x82fca088
	ctx.lr = 0x82FCA998;
	sub_82FCA088(ctx, base);
	// 82FCA998: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 82FCA99C: 4BFFF7ED  bl 0x82fca188
	ctx.lr = 0x82FCA9A0;
	sub_82FCA188(ctx, base);
	// 82FCA9A0: 93DF0034  stw r30, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[30].u32 ) };
	// 82FCA9A4: 93DF0080  stw r30, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 82FCA9A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FCA9AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FCA9B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FCA9B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82FCA9B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FCA9BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCA9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCA9C0 size=104
    let mut pc: u32 = 0x82FCA9C0;
    'dispatch: loop {
        match pc {
            0x82FCA9C0 => {
    //   block [0x82FCA9C0..0x82FCAA28)
	// 82FCA9C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCA9C4: 4BCDEA3D  bl 0x82ca9400
	ctx.lr = 0x82FCA9C8;
	sub_82CA93D0(ctx, base);
	// 82FCA9C8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCA9CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCA9D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FCA9D4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FCA9D8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82FCA9DC: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 82FCA9E0: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 82FCA9E4: 4BFFFF35  bl 0x82fca918
	ctx.lr = 0x82FCA9E8;
	sub_82FCA918(ctx, base);
	// 82FCA9E8: 7D7BD396  divwu r11, r27, r26
	ctx.r[11].u32 = ctx.r[27].u32 / ctx.r[26].u32;
	// 82FCA9EC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82FCA9F0: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82FCA9F4: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 82FCA9F8: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82FCA9FC: 7FCBE9D6  mullw r30, r11, r29
	ctx.r[30].s32 = ((ctx.r[11].s32 as i64 * ctx.r[29].s32 as i64) as i32);
	ctx.r[30].s64 = ctx.r[30].s32 as i64;
	// 82FCAA00: 937F0010  stw r27, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[27].u32 ) };
	// 82FCAA04: 935F0014  stw r26, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[26].u32 ) };
	// 82FCAA08: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82FCAA0C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82FCAA10: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FCAA14: 0CDA0000  twi 6, r26, 0
	// 82FCAA18: 4BFFF8D1  bl 0x82fca2e8
	ctx.lr = 0x82FCAA1C;
	sub_82FCA2E8(ctx, base);
	// 82FCAA1C: 93DF0070  stw r30, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82FCAA20: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82FCAA24: 4BCDEA2C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCAA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCAA28 size=160
    let mut pc: u32 = 0x82FCAA28;
    'dispatch: loop {
        match pc {
            0x82FCAA28 => {
    //   block [0x82FCAA28..0x82FCAAC8)
	// 82FCAA28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCAA2C: 4BCDE9E1  bl 0x82ca940c
	ctx.lr = 0x82FCAA30;
	sub_82CA93D0(ctx, base);
	// 82FCAA30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCAA34: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82FCAA38: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82FCAA3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCAA40: A15D0024  lhz r10, 0x24(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FCAA44: A17D0022  lhz r11, 0x22(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(34 as u32) ) } as u64;
	// 82FCAA48: 7CDE5050  subf r6, r30, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[30].s64;
	// 82FCAA4C: 809D001C  lwz r4, 0x1c(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCAA50: 7CABF214  add r5, r11, r30
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82FCAA54: 4BFFFAC5  bl 0x82fca518
	ctx.lr = 0x82FCAA58;
	sub_82FCA518(ctx, base);
	// 82FCAA58: 813D0008  lwz r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCAA5C: 57C8043E  clrlwi r8, r30, 0x10
	ctx.r[8].u64 = ctx.r[30].u32 as u64 & 0x0000FFFFu64;
	// 82FCAA60: 397F002C  addi r11, r31, 0x2c
	ctx.r[11].s64 = ctx.r[31].s64 + 44;
	// 82FCAA64: B11D0024  sth r8, 0x24(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[8].u16 ) };
	// 82FCAA68: 395F0038  addi r10, r31, 0x38
	ctx.r[10].s64 = ctx.r[31].s64 + 56;
	// 82FCAA6C: B109001C  sth r8, 0x1c(r9)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[8].u16 ) };
	// 82FCAA70: 813F0030  lwz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FCAA74: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FCAA78: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82FCAA7C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FCAA80: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82FCAA84: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 82FCAA88: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82FCAA8C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FCAA90: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82FCAA94: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FCAA98: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82FCAA9C: 93A3000C  stw r29, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82FCAAA0: 906B000C  stw r3, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82FCAAA4: 907D0010  stw r3, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82FCAAA8: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FCAAAC: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82FCAAB0: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82FCAAB4: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FCAAB8: 906B0014  stw r3, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82FCAABC: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82FCAAC0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82FCAAC4: 4BCDE998  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCAAC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCAAC8 size=228
    let mut pc: u32 = 0x82FCAAC8;
    'dispatch: loop {
        match pc {
            0x82FCAAC8 => {
    //   block [0x82FCAAC8..0x82FCAB30)
	// 82FCAAC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCAACC: 4BCDE939  bl 0x82ca9404
	ctx.lr = 0x82FCAAD0;
	sub_82CA93D0(ctx, base);
	// 82FCAAD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCAAD4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FCAAD8: 54AB063F  clrlwi. r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FCAADC: 83BE0008  lwz r29, 8(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCAAE0: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82FCAAE4: 809E001C  lwz r4, 0x1c(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCAAE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCAAEC: A17D001C  lhz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCAAF0: 7F9B5850  subf r28, r27, r11
	ctx.r[28].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 82FCAAF4: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82FCAAF8: 41820038  beq 0x82fcab30
	if ctx.cr[0].eq {
	pc = 0x82FCAB30; continue 'dispatch;
	}
	// 82FCAAFC: A0BD0018  lhz r5, 0x18(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FCAB00: 4BFFFA19  bl 0x82fca518
	ctx.lr = 0x82FCAB04;
	sub_82FCA518(ctx, base);
	// 82FCAB04: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FCAB08: 93C30010  stw r30, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82FCAB0C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82FCAB10: 906B0010  stw r3, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82FCAB14: A17E0022  lhz r11, 0x22(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(34 as u32) ) } as u64;
	// 82FCAB18: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82FCAB1C: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82FCAB20: 907E000C  stw r3, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82FCAB24: B17E0022  sth r11, 0x22(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(34 as u32), ctx.r[11].u16 ) };
	// 82FCAB28: B17D0018  sth r11, 0x18(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), ctx.r[11].u16 ) };
	// 82FCAB2C: 48000024  b 0x82fcab50
	pc = 0x82FCAB50; continue 'dispatch;
            }
            0x82FCAB30 => {
    //   block [0x82FCAB30..0x82FCAB50)
	// 82FCAB30: A17D0018  lhz r11, 0x18(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FCAB34: 7CABDA14  add r5, r11, r27
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82FCAB38: 4BFFF9E1  bl 0x82fca518
	ctx.lr = 0x82FCAB3C;
	sub_82FCA518(ctx, base);
	// 82FCAB3C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FCAB40: 93C3000C  stw r30, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82FCAB44: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82FCAB48: 906B000C  stw r3, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	// 82FCAB4C: 907E0010  stw r3, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	pc = 0x82FCAB50; continue 'dispatch;
            }
            0x82FCAB50 => {
    //   block [0x82FCAB50..0x82FCABAC)
	// 82FCAB50: B37D001C  sth r27, 0x1c(r29)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[27].u16 ) };
	// 82FCAB54: 397F002C  addi r11, r31, 0x2c
	ctx.r[11].s64 = ctx.r[31].s64 + 44;
	// 82FCAB58: A13E0024  lhz r9, 0x24(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82FCAB5C: 7D3C4850  subf r9, r28, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[28].s64;
	// 82FCAB60: B13E0024  sth r9, 0x24(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[9].u16 ) };
	// 82FCAB64: 395F0038  addi r10, r31, 0x38
	ctx.r[10].s64 = ctx.r[31].s64 + 56;
	// 82FCAB68: 813F0030  lwz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FCAB6C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FCAB70: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82FCAB74: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82FCAB78: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82FCAB7C: 907F0030  stw r3, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 82FCAB80: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82FCAB84: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82FCAB88: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82FCAB8C: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FCAB90: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82FCAB94: 91430014  stw r10, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82FCAB98: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82FCAB9C: 906B0014  stw r3, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82FCABA0: 907F0050  stw r3, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82FCABA4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82FCABA8: 4BCDE8AC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCABB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCABB0 size=76
    let mut pc: u32 = 0x82FCABB0;
    'dispatch: loop {
        match pc {
            0x82FCABB0 => {
    //   block [0x82FCABB0..0x82FCABFC)
	// 82FCABB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCABB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82FCABB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82FCABBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCABC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCABC4: 4BFFECA5  bl 0x82fc9868
	ctx.lr = 0x82FCABC8;
	sub_82FC9868(ctx, base);
	// 82FCABC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82FCABCC: 387F072C  addi r3, r31, 0x72c
	ctx.r[3].s64 = ctx.r[31].s64 + 1836;
	// 82FCABD0: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82FCABD4: 917F0030  stw r11, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 82FCABD8: 917F02C8  stw r11, 0x2c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(712 as u32), ctx.r[11].u32 ) };
	// 82FCABDC: 917F02CC  stw r11, 0x2cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(716 as u32), ctx.r[11].u32 ) };
	// 82FCABE0: 917F02D0  stw r11, 0x2d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(720 as u32), ctx.r[11].u32 ) };
	// 82FCABE4: 4BFFFD35  bl 0x82fca918
	ctx.lr = 0x82FCABE8;
	sub_82FCA918(ctx, base);
	// 82FCABE8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82FCABEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82FCABF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82FCABF4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82FCABF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCAC00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FCAC00 size=440
    let mut pc: u32 = 0x82FCAC00;
    'dispatch: loop {
        match pc {
            0x82FCAC00 => {
    //   block [0x82FCAC00..0x82FCAC40)
	// 82FCAC00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCAC04: 4BCDE7F1  bl 0x82ca93f4
	ctx.lr = 0x82FCAC08;
	sub_82CA93D0(ctx, base);
	// 82FCAC08: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCAC0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCAC10: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 82FCAC14: 7CB72B78  mr r23, r5
	ctx.r[23].u64 = ctx.r[5].u64;
	// 82FCAC18: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82FCAC1C: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 82FCAC20: 7D1E4378  mr r30, r8
	ctx.r[30].u64 = ctx.r[8].u64;
	// 82FCAC24: 7D3C4B78  mr r28, r9
	ctx.r[28].u64 = ctx.r[9].u64;
	// 82FCAC28: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 82FCAC2C: 4BFFFF85  bl 0x82fcabb0
	ctx.lr = 0x82FCAC30;
	sub_82FCABB0(ctx, base);
	// 82FCAC30: 2B180040  cmplwi cr6, r24, 0x40
	ctx.cr[6].compare_u32(ctx.r[24].u32, 64 as u32, &mut ctx.xer);
	// 82FCAC34: 3960003F  li r11, 0x3f
	ctx.r[11].s64 = 63;
	// 82FCAC38: 41980008  blt cr6, 0x82fcac40
	if ctx.cr[6].lt {
	pc = 0x82FCAC40; continue 'dispatch;
	}
	// 82FCAC3C: 3978FFFF  addi r11, r24, -1
	ctx.r[11].s64 = ctx.r[24].s64 + -1;
	pc = 0x82FCAC40; continue 'dispatch;
            }
            0x82FCAC40 => {
    //   block [0x82FCAC40..0x82FCAC50)
	// 82FCAC40: 2B170040  cmplwi cr6, r23, 0x40
	ctx.cr[6].compare_u32(ctx.r[23].u32, 64 as u32, &mut ctx.xer);
	// 82FCAC44: 3900003F  li r8, 0x3f
	ctx.r[8].s64 = 63;
	// 82FCAC48: 41980008  blt cr6, 0x82fcac50
	if ctx.cr[6].lt {
	pc = 0x82FCAC50; continue 'dispatch;
	}
	// 82FCAC4C: 3917FFFF  addi r8, r23, -1
	ctx.r[8].s64 = ctx.r[23].s64 + -1;
	pc = 0x82FCAC50; continue 'dispatch;
            }
            0x82FCAC50 => {
    //   block [0x82FCAC50..0x82FCAC64)
	// 82FCAC50: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82FCAC54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FCAC58: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82FCAC5C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82FCAC60: 419A0010  beq cr6, 0x82fcac70
	if ctx.cr[6].eq {
	pc = 0x82FCAC70; continue 'dispatch;
	}
	pc = 0x82FCAC64; continue 'dispatch;
            }
            0x82FCAC64 => {
    //   block [0x82FCAC64..0x82FCAC70)
	// 82FCAC64: 556BF87F  rlwinm. r11, r11, 0x1f, 1, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FCAC68: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82FCAC6C: 4082FFF8  bne 0x82fcac64
	if !ctx.cr[0].eq {
	pc = 0x82FCAC64; continue 'dispatch;
	}
	pc = 0x82FCAC70; continue 'dispatch;
            }
            0x82FCAC70 => {
    //   block [0x82FCAC70..0x82FCAC78)
	// 82FCAC70: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82FCAC74: 419A0010  beq cr6, 0x82fcac84
	if ctx.cr[6].eq {
	pc = 0x82FCAC84; continue 'dispatch;
	}
	pc = 0x82FCAC78; continue 'dispatch;
            }
            0x82FCAC78 => {
    //   block [0x82FCAC78..0x82FCAC84)
	// 82FCAC78: 5508F87F  rlwinm. r8, r8, 0x1f, 1, 0x1f
	ctx.r[8].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82FCAC7C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82FCAC80: 4082FFF8  bne 0x82fcac78
	if !ctx.cr[0].eq {
	pc = 0x82FCAC78; continue 'dispatch;
	}
	pc = 0x82FCAC84; continue 'dispatch;
            }
            0x82FCAC84 => {
    //   block [0x82FCAC84..0x82FCAC90)
	// 82FCAC84: 2B1A0020  cmplwi cr6, r26, 0x20
	ctx.cr[6].compare_u32(ctx.r[26].u32, 32 as u32, &mut ctx.xer);
	// 82FCAC88: 40990008  ble cr6, 0x82fcac90
	if !ctx.cr[6].gt {
	pc = 0x82FCAC90; continue 'dispatch;
	}
	// 82FCAC8C: 3B400020  li r26, 0x20
	ctx.r[26].s64 = 32;
	pc = 0x82FCAC90; continue 'dispatch;
            }
            0x82FCAC90 => {
    //   block [0x82FCAC90..0x82FCAD34)
	// 82FCAC90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82FCAC94: 935F0008  stw r26, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82FCAC98: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82FCAC9C: 933F000C  stw r25, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[25].u32 ) };
	// 82FCACA0: 7D6A5030  slw r10, r11, r10
	if (ctx.r[10].u8 & 0x20) != 0 {
		ctx.r[10].u64 = 0;
	} else {
		ctx.r[10].u64 = ((ctx.r[11].u32) << ((ctx.r[10].u8 & 0x1F) as u32)) as u64;
	}
	// 82FCACA4: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82FCACA8: 79470020  clrldi r7, r10, 0x20
	ctx.r[7].u64 = ctx.r[10].u64 & 0x00000000FFFFFFFFu64;
	// 82FCACAC: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 82FCACB0: 7D6B4830  slw r11, r11, r9
	if (ctx.r[9].u8 & 0x20) != 0 {
		ctx.r[11].u64 = 0;
	} else {
		ctx.r[11].u64 = ((ctx.r[11].u32) << ((ctx.r[9].u8 & 0x1F) as u32)) as u64;
	}
	// 82FCACB4: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82FCACB8: 796A0020  clrldi r10, r11, 0x20
	ctx.r[10].u64 = ctx.r[11].u64 & 0x00000000FFFFFFFFu64;
	// 82FCACBC: C0080C14  lfs f0, 0xc14(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FCACC0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FCACC4: 38600038  li r3, 0x38
	ctx.r[3].s64 = 56;
	// 82FCACC8: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FCACCC: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82FCACD0: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FCACD4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82FCACD8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82FCACDC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82FCACE0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82FCACE4: ED806024  fdivs f12, f0, f12
	ctx.f[12].f64 = ((ctx.f[0].f64 / ctx.f[12].f64) as f32) as f64;
	// 82FCACE8: D19F0014  stfs f12, 0x14(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82FCACEC: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82FCACF0: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82FCACF4: 4BF32B6D  bl 0x82efd860
	ctx.lr = 0x82FCACF8;
	sub_82EFD860(ctx, base);
	// 82FCACF8: 28030000  cmplwi r3, 0
	ctx.cr[0].compare_u32(ctx.r[0].u32, 0 as u32, &mut ctx.xer);
	// 82FCACFC: 41820038  beq 0x82fcad34
	if ctx.cr[0].eq {
	pc = 0x82FCAD34; continue 'dispatch;
	}
	// 82FCAD00: 3D605647  lis r11, 0x5647
	ctx.r[11].s64 = 1447493632;
	// 82FCAD04: 3D409FE1  lis r10, -0x601f
	ctx.r[10].s64 = -1612644352;
	// 82FCAD08: 616B1E89  ori r11, r11, 0x1e89
	ctx.r[11].u64 = ctx.r[11].u64 | 7817;
	// 82FCAD0C: 614A234A  ori r10, r10, 0x234a
	ctx.r[10].u64 = ctx.r[10].u64 | 9034;
	// 82FCAD10: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82FCAD14: 397C0003  addi r11, r28, 3
	ctx.r[11].s64 = ctx.r[28].s64 + 3;
	// 82FCAD18: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82FCAD1C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82FCAD20: 5565003A  rlwinm r5, r11, 0, 0, 0x1d
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82FCAD24: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 82FCAD28: 4BF3B221  bl 0x82f05f48
	ctx.lr = 0x82FCAD2C;
	sub_82F05F48(ctx, base);
	// 82FCAD2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82FCAD30: 48000008  b 0x82fcad38
	pc = 0x82FCAD38; continue 'dispatch;
            }
            0x82FCAD34 => {
    //   block [0x82FCAD34..0x82FCAD38)
	// 82FCAD34: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x82FCAD38; continue 'dispatch;
            }
            0x82FCAD38 => {
    //   block [0x82FCAD38..0x82FCAD58)
	// 82FCAD38: 807F02BC  lwz r3, 0x2bc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(700 as u32) ) } as u64;
	// 82FCAD3C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82FCAD40: 419A0018  beq cr6, 0x82fcad58
	if ctx.cr[6].eq {
	pc = 0x82FCAD58; continue 'dispatch;
	}
	// 82FCAD44: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCAD48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FCAD4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCAD50: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FCAD54: 4E800421  bctrl
	ctx.lr = 0x82FCAD58;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FCAD58 => {
    //   block [0x82FCAD58..0x82FCAD80)
	// 82FCAD58: 393F02C0  addi r9, r31, 0x2c0
	ctx.r[9].s64 = ctx.r[31].s64 + 704;
	// 82FCAD5C: 93DF02BC  stw r30, 0x2bc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(700 as u32), ctx.r[30].u32 ) };
	// 82FCAD60: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 82FCAD64: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82FCAD68: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 82FCAD6C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82FCAD70: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 82FCAD74: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 82FCAD78: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82FCAD7C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	pc = 0x82FCAD80; continue 'dispatch;
            }
            0x82FCAD80 => {
    //   block [0x82FCAD80..0x82FCADB8)
	// 82FCAD80: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCAD84: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82FCAD88: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82FCAD8C: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82FCAD90: 4200FFF0  bdnz 0x82fcad80
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x82FCAD80; continue 'dispatch;
	}
	// 82FCAD94: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 82FCAD98: 7EE7BB78  mr r7, r23
	ctx.r[7].u64 = ctx.r[23].u64;
	// 82FCAD9C: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 82FCADA0: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82FCADA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FCADA8: 387F072C  addi r3, r31, 0x72c
	ctx.r[3].s64 = ctx.r[31].s64 + 1836;
	// 82FCADAC: 4BFFFC15  bl 0x82fca9c0
	ctx.lr = 0x82FCADB0;
	sub_82FCA9C0(ctx, base);
	// 82FCADB0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82FCADB4: 4BCDE690  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCADB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCADB8 size=996
    let mut pc: u32 = 0x82FCADB8;
    'dispatch: loop {
        match pc {
            0x82FCADB8 => {
    //   block [0x82FCADB8..0x82FCAE10)
	// 82FCADB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCADBC: 4BCDE615  bl 0x82ca93d0
	ctx.lr = 0x82FCADC0;
	sub_82CA93D0(ctx, base);
	// 82FCADC0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCADC4: 7D0E4378  mr r14, r8
	ctx.r[14].u64 = ctx.r[8].u64;
	// 82FCADC8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82FCADCC: 7D3F4B78  mr r31, r9
	ctx.r[31].u64 = ctx.r[9].u64;
	// 82FCADD0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FCADD4: 93810124  stw r28, 0x124(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[28].u32 ) };
	// 82FCADD8: 3B6EFFFF  addi r27, r14, -1
	ctx.r[27].s64 = ctx.r[14].s64 + -1;
	// 82FCADDC: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82FCADE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FCADE4: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82FCADE8: 7CB22B78  mr r18, r5
	ctx.r[18].u64 = ctx.r[5].u64;
	// 82FCADEC: 7CCF3378  mr r15, r6
	ctx.r[15].u64 = ctx.r[6].u64;
	// 82FCADF0: 7D515378  mr r17, r10
	ctx.r[17].u64 = ctx.r[10].u64;
	// 82FCADF4: 3ABCFFFF  addi r21, r28, -1
	ctx.r[21].s64 = ctx.r[28].s64 + -1;
	// 82FCADF8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82FCADFC: 3AEB6C28  addi r23, r11, 0x6c28
	ctx.r[23].s64 = ctx.r[11].s64 + 27688;
	// 82FCAE00: 419A01C0  beq cr6, 0x82fcafc0
	if ctx.cr[6].eq {
	pc = 0x82FCAFC0; continue 'dispatch;
	}
	// 82FCAE04: 2B1F00FE  cmplwi cr6, r31, 0xfe
	ctx.cr[6].compare_u32(ctx.r[31].u32, 254 as u32, &mut ctx.xer);
	// 82FCAE08: 40990008  ble cr6, 0x82fcae10
	if !ctx.cr[6].gt {
	pc = 0x82FCAE10; continue 'dispatch;
	}
	// 82FCAE0C: 3BE000FE  li r31, 0xfe
	ctx.r[31].s64 = 254;
	pc = 0x82FCAE10; continue 'dispatch;
            }
            0x82FCAE10 => {
    //   block [0x82FCAE10..0x82FCAE4C)
	// 82FCAE10: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FCAE14: 7E7FB8AE  lbzx r19, r31, r23
	ctx.r[19].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 82FCAE18: 3957FE00  addi r10, r23, -0x200
	ctx.r[10].s64 = ctx.r[23].s64 + -512;
	// 82FCAE1C: 3B2B0001  addi r25, r11, 1
	ctx.r[25].s64 = ctx.r[11].s64 + 1;
	// 82FCAE20: 387802D8  addi r3, r24, 0x2d8
	ctx.r[3].s64 = ctx.r[24].s64 + 728;
	// 82FCAE24: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82FCAE28: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82FCAE2C: 7E8B522E  lhzx r20, r11, r10
	ctx.r[20].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FCAE30: 4BFFF459  bl 0x82fca288
	ctx.lr = 0x82FCAE34;
	sub_82FCA288(ctx, base);
	// 82FCAE34: 933802D8  stw r25, 0x2d8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(728 as u32), ctx.r[25].u32 ) };
	// 82FCAE38: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 82FCAE3C: 419A0184  beq cr6, 0x82fcafc0
	if ctx.cr[6].eq {
	pc = 0x82FCAFC0; continue 'dispatch;
	}
	// 82FCAE40: 3ADF0001  addi r22, r31, 1
	ctx.r[22].s64 = ctx.r[31].s64 + 1;
	// 82FCAE44: 7DFA7B78  mr r26, r15
	ctx.r[26].u64 = ctx.r[15].u64;
	// 82FCAE48: 7DD07378  mr r16, r14
	ctx.r[16].u64 = ctx.r[14].u64;
	pc = 0x82FCAE4C; continue 'dispatch;
            }
            0x82FCAE4C => {
    //   block [0x82FCAE4C..0x82FCAE7C)
	// 82FCAE4C: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCAE50: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82FCAE54: 817E0020  lwz r11, 0x20(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FCAE58: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82FCAE5C: 7D4AD1D6  mullw r10, r10, r26
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[26].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FCAE60: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FCAE64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82FCAE68: 7CEB9214  add r7, r11, r18
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[18].u64;
	// 82FCAE6C: 7D6B90AE  lbzx r11, r11, r18
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 82FCAE70: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82FCAE74: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82FCAE78: 7C9659D6  mullw r4, r22, r11
	ctx.r[4].s32 = ((ctx.r[22].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[4].s64 = ctx.r[4].s32 as i64;
	pc = 0x82FCAE7C; continue 'dispatch;
            }
            0x82FCAE7C => {
    //   block [0x82FCAE7C..0x82FCAEA4)
	// 82FCAE7C: 80B802E0  lwz r5, 0x2e0(r24)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(736 as u32) ) } as u64;
	// 82FCAE80: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82FCAE84: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82FCAE88: 7CC551AE  stbx r6, r5, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u8) };
	// 82FCAE8C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82FCAE90: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82FCAE94: 4099FFE8  ble cr6, 0x82fcae7c
	if !ctx.cr[6].gt {
	pc = 0x82FCAE7C; continue 'dispatch;
	}
	// 82FCAE98: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82FCAE9C: 2B1F0001  cmplwi cr6, r31, 1
	ctx.cr[6].compare_u32(ctx.r[31].u32, 1 as u32, &mut ctx.xer);
	// 82FCAEA0: 41980040  blt cr6, 0x82fcaee0
	if ctx.cr[6].lt {
	pc = 0x82FCAEE0; continue 'dispatch;
	}
	pc = 0x82FCAEA4; continue 'dispatch;
            }
            0x82FCAEA4 => {
    //   block [0x82FCAEA4..0x82FCAEB0)
	// 82FCAEA4: 7F0AA840  cmplw cr6, r10, r21
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82FCAEA8: 41990008  bgt cr6, 0x82fcaeb0
	if ctx.cr[6].gt {
	pc = 0x82FCAEB0; continue 'dispatch;
	}
	// 82FCAEAC: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	pc = 0x82FCAEB0; continue 'dispatch;
            }
            0x82FCAEB0 => {
    //   block [0x82FCAEB0..0x82FCAEE0)
	// 82FCAEB0: 80D802E0  lwz r6, 0x2e0(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(736 as u32) ) } as u64;
	// 82FCAEB4: 7D0AF850  subf r8, r10, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 82FCAEB8: 89670000  lbz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCAEBC: 7CC65214  add r6, r6, r10
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	// 82FCAEC0: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82FCAEC4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82FCAEC8: 7D0859D6  mullw r8, r8, r11
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82FCAECC: 7D66F9AE  stbx r11, r6, r31
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[31].u32), ctx.r[11].u8) };
	// 82FCAED0: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82FCAED4: 7FABEA14  add r29, r11, r29
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82FCAED8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82FCAEDC: 4099FFC8  ble cr6, 0x82fcaea4
	if !ctx.cr[6].gt {
	pc = 0x82FCAEA4; continue 'dispatch;
	}
	pc = 0x82FCAEE0; continue 'dispatch;
            }
            0x82FCAEE0 => {
    //   block [0x82FCAEE0..0x82FCAEF4)
	// 82FCAEE0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82FCAEE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FCAEE8: 7F1FA840  cmplw cr6, r31, r21
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82FCAEEC: 40990008  ble cr6, 0x82fcaef4
	if !ctx.cr[6].gt {
	pc = 0x82FCAEF4; continue 'dispatch;
	}
	// 82FCAEF0: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	pc = 0x82FCAEF4; continue 'dispatch;
            }
            0x82FCAEF4 => {
    //   block [0x82FCAEF4..0x82FCAF28)
	// 82FCAEF4: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCAEF8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82FCAEFC: 811E0020  lwz r8, 0x20(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FCAF00: 7D4AD1D6  mullw r10, r10, r26
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[26].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FCAF04: 80BE001C  lwz r5, 0x1c(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCAF08: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 82FCAF0C: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 82FCAF10: 7D45D1D6  mullw r10, r5, r26
	ctx.r[10].s32 = ((ctx.r[5].s32 as i64 * ctx.r[26].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FCAF14: 7D081A14  add r8, r8, r3
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[3].u64;
	// 82FCAF18: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82FCAF1C: 7F689214  add r27, r8, r18
	ctx.r[27].u64 = ctx.r[8].u64 + ctx.r[18].u64;
	// 82FCAF20: 7CEA9214  add r7, r10, r18
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[18].u64;
	// 82FCAF24: 419A008C  beq cr6, 0x82fcafb0
	if ctx.cr[6].eq {
	pc = 0x82FCAFB0; continue 'dispatch;
	}
	pc = 0x82FCAF28; continue 'dispatch;
            }
            0x82FCAF28 => {
    //   block [0x82FCAF28..0x82FCAF50)
	// 82FCAF28: 7D49A1D6  mullw r10, r9, r20
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * ctx.r[20].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FCAF2C: 7D489C30  srw r8, r10, r19
	if (ctx.r[19].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[10].u32) >> ((ctx.r[19].u8 & 0x1F) as u32)) as u64;
	}
	// 82FCAF30: 7D5F3050  subf r10, r31, r6
	ctx.r[10].s64 = ctx.r[6].s64 - ctx.r[31].s64;
	// 82FCAF34: 99070000  stb r8, 0(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 82FCAF38: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82FCAF3C: 7D4ACA14  add r10, r10, r25
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[25].u64;
	// 82FCAF40: 7CA44850  subf r5, r4, r9
	ctx.r[5].s64 = ctx.r[9].s64 - ctx.r[4].s64;
	// 82FCAF44: 7F0AC840  cmplw cr6, r10, r25
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82FCAF48: 41980008  blt cr6, 0x82fcaf50
	if ctx.cr[6].lt {
	pc = 0x82FCAF50; continue 'dispatch;
	}
	// 82FCAF4C: 7D595050  subf r10, r25, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[25].s64;
	pc = 0x82FCAF50; continue 'dispatch;
            }
            0x82FCAF50 => {
    //   block [0x82FCAF50..0x82FCAF70)
	// 82FCAF50: 813802E0  lwz r9, 0x2e0(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(736 as u32) ) } as u64;
	// 82FCAF54: 7F03A840  cmplw cr6, r3, r21
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[21].u32, &mut ctx.xer);
	// 82FCAF58: 7D0950AE  lbzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FCAF5C: 7C882050  subf r4, r8, r4
	ctx.r[4].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 82FCAF60: 40980010  bge cr6, 0x82fcaf70
	if !ctx.cr[6].lt {
	pc = 0x82FCAF70; continue 'dispatch;
	}
	// 82FCAF64: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82FCAF68: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 82FCAF6C: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82FCAF70; continue 'dispatch;
            }
            0x82FCAF70 => {
    //   block [0x82FCAF70..0x82FCAF94)
	// 82FCAF70: 7D0BEA14  add r8, r11, r29
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82FCAF74: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82FCAF78: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82FCAF7C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82FCAF80: 7FA951AE  stbx r29, r9, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[29].u8) };
	// 82FCAF84: 7D282A14  add r9, r8, r5
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[5].u64;
	// 82FCAF88: 7F06C840  cmplw cr6, r6, r25
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[25].u32, &mut ctx.xer);
	// 82FCAF8C: 41980008  blt cr6, 0x82fcaf94
	if ctx.cr[6].lt {
	pc = 0x82FCAF94; continue 'dispatch;
	}
	// 82FCAF90: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	pc = 0x82FCAF94; continue 'dispatch;
            }
            0x82FCAF94 => {
    //   block [0x82FCAF94..0x82FCAFB0)
	// 82FCAF94: 815802E0  lwz r10, 0x2e0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(736 as u32) ) } as u64;
	// 82FCAF98: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82FCAF9C: 7D4A30AE  lbzx r10, r10, r6
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 82FCAFA0: 7C8A2214  add r4, r10, r4
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 82FCAFA4: 7FAA4050  subf r29, r10, r8
	ctx.r[29].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 82FCAFA8: 4082FF80  bne 0x82fcaf28
	if !ctx.cr[0].eq {
	pc = 0x82FCAF28; continue 'dispatch;
	}
	// 82FCAFAC: 83810124  lwz r28, 0x124(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	pc = 0x82FCAFB0; continue 'dispatch;
            }
            0x82FCAFB0 => {
    //   block [0x82FCAFB0..0x82FCAFC0)
	// 82FCAFB0: 3610FFFF  addic. r16, r16, -1
	ctx.xer.ca = (ctx.r[16].u32 > (!(-1 as u32)));
	ctx.r[16].s64 = ctx.r[16].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[16].s32, 0, &mut ctx.xer);
	// 82FCAFB4: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 82FCAFB8: 4082FE94  bne 0x82fcae4c
	if !ctx.cr[0].eq {
	pc = 0x82FCAE4C; continue 'dispatch;
	}
	// 82FCAFBC: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82FCAFC0; continue 'dispatch;
            }
            0x82FCAFC0 => {
    //   block [0x82FCAFC0..0x82FCAFD4)
	// 82FCAFC0: 2B110000  cmplwi cr6, r17, 0
	ctx.cr[6].compare_u32(ctx.r[17].u32, 0 as u32, &mut ctx.xer);
	// 82FCAFC4: 419A01D0  beq cr6, 0x82fcb194
	if ctx.cr[6].eq {
	pc = 0x82FCB194; continue 'dispatch;
	}
	// 82FCAFC8: 2B1100FE  cmplwi cr6, r17, 0xfe
	ctx.cr[6].compare_u32(ctx.r[17].u32, 254 as u32, &mut ctx.xer);
	// 82FCAFCC: 40990008  ble cr6, 0x82fcafd4
	if !ctx.cr[6].gt {
	pc = 0x82FCAFD4; continue 'dispatch;
	}
	// 82FCAFD0: 3A2000FE  li r17, 0xfe
	ctx.r[17].s64 = 254;
	pc = 0x82FCAFD4; continue 'dispatch;
            }
            0x82FCAFD4 => {
    //   block [0x82FCAFD4..0x82FCB014)
	// 82FCAFD4: 562B083C  slwi r11, r17, 1
	ctx.r[11].u32 = ctx.r[17].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FCAFD8: 7EB1B8AE  lbzx r21, r17, r23
	ctx.r[21].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[17].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 82FCAFDC: 3957FE00  addi r10, r23, -0x200
	ctx.r[10].s64 = ctx.r[23].s64 + -512;
	// 82FCAFE0: 3B4B0001  addi r26, r11, 1
	ctx.r[26].s64 = ctx.r[11].s64 + 1;
	// 82FCAFE4: 387802D8  addi r3, r24, 0x2d8
	ctx.r[3].s64 = ctx.r[24].s64 + 728;
	// 82FCAFE8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82FCAFEC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82FCAFF0: 7ECB522E  lhzx r22, r11, r10
	ctx.r[22].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FCAFF4: 4BFFF295  bl 0x82fca288
	ctx.lr = 0x82FCAFF8;
	sub_82FCA288(ctx, base);
	// 82FCAFF8: 935802D8  stw r26, 0x2d8(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(728 as u32), ctx.r[26].u32 ) };
	// 82FCAFFC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82FCB000: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82FCB004: 833E001C  lwz r25, 0x1c(r30)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCB008: 419A018C  beq cr6, 0x82fcb194
	if ctx.cr[6].eq {
	pc = 0x82FCB194; continue 'dispatch;
	}
	// 82FCB00C: 3AF10001  addi r23, r17, 1
	ctx.r[23].s64 = ctx.r[17].s64 + 1;
	// 82FCB010: 48000008  b 0x82fcb018
	pc = 0x82FCB018; continue 'dispatch;
            }
            0x82FCB014 => {
    //   block [0x82FCB014..0x82FCB018)
	// 82FCB014: 83610054  lwz r27, 0x54(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82FCB018; continue 'dispatch;
            }
            0x82FCB018 => {
    //   block [0x82FCB018..0x82FCB04C)
	// 82FCB018: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCB01C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82FCB020: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FCB024: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82FCB028: 7D6B79D6  mullw r11, r11, r15
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * ctx.r[15].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FCB02C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82FCB030: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82FCB034: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82FCB038: 7CEB9214  add r7, r11, r18
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[18].u64;
	// 82FCB03C: 7D6B90AE  lbzx r11, r11, r18
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[18].u32)) } as u64;
	// 82FCB040: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 82FCB044: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82FCB048: 7C7759D6  mullw r3, r23, r11
	ctx.r[3].s32 = ((ctx.r[23].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	pc = 0x82FCB04C; continue 'dispatch;
            }
            0x82FCB04C => {
    //   block [0x82FCB04C..0x82FCB074)
	// 82FCB04C: 80B802E0  lwz r5, 0x2e0(r24)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(736 as u32) ) } as u64;
	// 82FCB050: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82FCB054: 7D085A14  add r8, r8, r11
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82FCB058: 7CC551AE  stbx r6, r5, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[5].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u8) };
	// 82FCB05C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82FCB060: 7F0A8840  cmplw cr6, r10, r17
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[17].u32, &mut ctx.xer);
	// 82FCB064: 4099FFE8  ble cr6, 0x82fcb04c
	if !ctx.cr[6].gt {
	pc = 0x82FCB04C; continue 'dispatch;
	}
	// 82FCB068: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82FCB06C: 2B110001  cmplwi cr6, r17, 1
	ctx.cr[6].compare_u32(ctx.r[17].u32, 1 as u32, &mut ctx.xer);
	// 82FCB070: 41980040  blt cr6, 0x82fcb0b0
	if ctx.cr[6].lt {
	pc = 0x82FCB0B0; continue 'dispatch;
	}
	pc = 0x82FCB074; continue 'dispatch;
            }
            0x82FCB074 => {
    //   block [0x82FCB074..0x82FCB080)
	// 82FCB074: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82FCB078: 41990008  bgt cr6, 0x82fcb080
	if ctx.cr[6].gt {
	pc = 0x82FCB080; continue 'dispatch;
	}
	// 82FCB07C: 7CF93A14  add r7, r25, r7
	ctx.r[7].u64 = ctx.r[25].u64 + ctx.r[7].u64;
	pc = 0x82FCB080; continue 'dispatch;
            }
            0x82FCB080 => {
    //   block [0x82FCB080..0x82FCB0B0)
	// 82FCB080: 80D802E0  lwz r6, 0x2e0(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(736 as u32) ) } as u64;
	// 82FCB084: 7D0A8850  subf r8, r10, r17
	ctx.r[8].s64 = ctx.r[17].s64 - ctx.r[10].s64;
	// 82FCB088: 89670000  lbz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCB08C: 7CC65214  add r6, r6, r10
	ctx.r[6].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	// 82FCB090: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82FCB094: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82FCB098: 7D0859D6  mullw r8, r8, r11
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82FCB09C: 7D6689AE  stbx r11, r6, r17
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[17].u32), ctx.r[11].u8) };
	// 82FCB0A0: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 82FCB0A4: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82FCB0A8: 7F0A8840  cmplw cr6, r10, r17
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[17].u32, &mut ctx.xer);
	// 82FCB0AC: 4099FFC8  ble cr6, 0x82fcb074
	if !ctx.cr[6].gt {
	pc = 0x82FCB074; continue 'dispatch;
	}
	pc = 0x82FCB0B0; continue 'dispatch;
            }
            0x82FCB0B0 => {
    //   block [0x82FCB0B0..0x82FCB0C4)
	// 82FCB0B0: 7E258B78  mr r5, r17
	ctx.r[5].u64 = ctx.r[17].u64;
	// 82FCB0B4: 7E248B78  mr r4, r17
	ctx.r[4].u64 = ctx.r[17].u64;
	// 82FCB0B8: 7F11D840  cmplw cr6, r17, r27
	ctx.cr[6].compare_u32(ctx.r[17].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82FCB0BC: 40990008  ble cr6, 0x82fcb0c4
	if !ctx.cr[6].gt {
	pc = 0x82FCB0C4; continue 'dispatch;
	}
	// 82FCB0C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	pc = 0x82FCB0C4; continue 'dispatch;
            }
            0x82FCB0C4 => {
    //   block [0x82FCB0C4..0x82FCB104)
	// 82FCB0C4: 815E001C  lwz r10, 0x1c(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCB0C8: 7D047A14  add r8, r4, r15
	ctx.r[8].u64 = ctx.r[4].u64 + ctx.r[15].u64;
	// 82FCB0CC: 80FE0020  lwz r7, 0x20(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FCB0D0: 2B0E0000  cmplwi cr6, r14, 0
	ctx.cr[6].compare_u32(ctx.r[14].u32, 0 as u32, &mut ctx.xer);
	// 82FCB0D4: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 82FCB0D8: 7D0851D6  mullw r8, r8, r10
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * ctx.r[10].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82FCB0DC: 7CE63B78  mr r6, r7
	ctx.r[6].u64 = ctx.r[7].u64;
	// 82FCB0E0: 7D5B79D6  mullw r10, r27, r15
	ctx.r[10].s32 = ((ctx.r[27].s32 as i64 * ctx.r[15].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FCB0E4: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82FCB0E8: 7D083214  add r8, r8, r6
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 82FCB0EC: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 82FCB0F0: 7D08EA14  add r8, r8, r29
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[29].u64;
	// 82FCB0F4: 7CEA9214  add r7, r10, r18
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[18].u64;
	// 82FCB0F8: 7F689214  add r27, r8, r18
	ctx.r[27].u64 = ctx.r[8].u64 + ctx.r[18].u64;
	// 82FCB0FC: 419A008C  beq cr6, 0x82fcb188
	if ctx.cr[6].eq {
	pc = 0x82FCB188; continue 'dispatch;
	}
	// 82FCB100: 7DDC7378  mr r28, r14
	ctx.r[28].u64 = ctx.r[14].u64;
	pc = 0x82FCB104; continue 'dispatch;
            }
            0x82FCB104 => {
    //   block [0x82FCB104..0x82FCB12C)
	// 82FCB104: 7D49B1D6  mullw r10, r9, r22
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * ctx.r[22].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FCB108: 7D48AC30  srw r8, r10, r21
	if (ctx.r[21].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[10].u32) >> ((ctx.r[21].u8 & 0x1F) as u32)) as u64;
	}
	// 82FCB10C: 7D512850  subf r10, r17, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[17].s64;
	// 82FCB110: 99070000  stb r8, 0(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 82FCB114: 7CF93A14  add r7, r25, r7
	ctx.r[7].u64 = ctx.r[25].u64 + ctx.r[7].u64;
	// 82FCB118: 7D4AD214  add r10, r10, r26
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[26].u64;
	// 82FCB11C: 7CC34850  subf r6, r3, r9
	ctx.r[6].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 82FCB120: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82FCB124: 41980008  blt cr6, 0x82fcb12c
	if ctx.cr[6].lt {
	pc = 0x82FCB12C; continue 'dispatch;
	}
	// 82FCB128: 7D5A5050  subf r10, r26, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[26].s64;
	pc = 0x82FCB12C; continue 'dispatch;
            }
            0x82FCB12C => {
    //   block [0x82FCB12C..0x82FCB150)
	// 82FCB12C: 813802E0  lwz r9, 0x2e0(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(736 as u32) ) } as u64;
	// 82FCB130: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FCB134: 7F044040  cmplw cr6, r4, r8
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82FCB138: 7D0950AE  lbzx r8, r9, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FCB13C: 7C681850  subf r3, r8, r3
	ctx.r[3].s64 = ctx.r[3].s64 - ctx.r[8].s64;
	// 82FCB140: 40980010  bge cr6, 0x82fcb150
	if !ctx.cr[6].lt {
	pc = 0x82FCB150; continue 'dispatch;
	}
	// 82FCB144: 7F79DA14  add r27, r25, r27
	ctx.r[27].u64 = ctx.r[25].u64 + ctx.r[27].u64;
	// 82FCB148: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82FCB14C: 897B0000  lbz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82FCB150; continue 'dispatch;
            }
            0x82FCB150 => {
    //   block [0x82FCB150..0x82FCB16C)
	// 82FCB150: 7D0BFA14  add r8, r11, r31
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82FCB154: 7D6951AE  stbx r11, r9, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u8) };
	// 82FCB158: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82FCB15C: 7D283214  add r9, r8, r6
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 82FCB160: 7F05D040  cmplw cr6, r5, r26
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82FCB164: 41980008  blt cr6, 0x82fcb16c
	if ctx.cr[6].lt {
	pc = 0x82FCB16C; continue 'dispatch;
	}
	// 82FCB168: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	pc = 0x82FCB16C; continue 'dispatch;
            }
            0x82FCB16C => {
    //   block [0x82FCB16C..0x82FCB188)
	// 82FCB16C: 815802E0  lwz r10, 0x2e0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(736 as u32) ) } as u64;
	// 82FCB170: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 82FCB174: 7D4A28AE  lbzx r10, r10, r5
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 82FCB178: 7C6A1A14  add r3, r10, r3
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[3].u64;
	// 82FCB17C: 7FEA4050  subf r31, r10, r8
	ctx.r[31].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 82FCB180: 4082FF84  bne 0x82fcb104
	if !ctx.cr[0].eq {
	pc = 0x82FCB104; continue 'dispatch;
	}
	// 82FCB184: 83810124  lwz r28, 0x124(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(292 as u32) ) } as u64;
	pc = 0x82FCB188; continue 'dispatch;
            }
            0x82FCB188 => {
    //   block [0x82FCB188..0x82FCB194)
	// 82FCB188: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82FCB18C: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82FCB190: 4198FE84  blt cr6, 0x82fcb014
	if ctx.cr[6].lt {
	pc = 0x82FCB014; continue 'dispatch;
	}
	pc = 0x82FCB194; continue 'dispatch;
            }
            0x82FCB194 => {
    //   block [0x82FCB194..0x82FCB19C)
	// 82FCB194: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82FCB198: 4BCDE288  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCB1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCB1A0 size=356
    let mut pc: u32 = 0x82FCB1A0;
    'dispatch: loop {
        match pc {
            0x82FCB1A0 => {
    //   block [0x82FCB1A0..0x82FCB1CC)
	// 82FCB1A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCB1A4: 4BCDE259  bl 0x82ca93fc
	ctx.lr = 0x82FCB1A8;
	sub_82CA93D0(ctx, base);
	// 82FCB1A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCB1AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCB1B0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82FCB1B4: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82FCB1B8: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 82FCB1BC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCB1C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FCB1C4: 40990128  ble cr6, 0x82fcb2ec
	if !ctx.cr[6].gt {
	pc = 0x82FCB2EC; continue 'dispatch;
	}
	// 82FCB1C8: 3BBF003C  addi r29, r31, 0x3c
	ctx.r[29].s64 = ctx.r[31].s64 + 60;
	pc = 0x82FCB1CC; continue 'dispatch;
            }
            0x82FCB1CC => {
    //   block [0x82FCB1CC..0x82FCB224)
	// 82FCB1CC: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FCB1D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FCB1D4: 419A0104  beq cr6, 0x82fcb2d8
	if ctx.cr[6].eq {
	pc = 0x82FCB2D8; continue 'dispatch;
	}
	// 82FCB1D8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82FCB1DC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82FCB1E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82FCB1E4: 4BFFE70D  bl 0x82fc98f0
	ctx.lr = 0x82FCB1E8;
	sub_82FC98F0(ctx, base);
	// 82FCB1E8: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FCB1EC: 418200E8  beq 0x82fcb2d4
	if ctx.cr[0].eq {
	pc = 0x82FCB2D4; continue 'dispatch;
	}
	// 82FCB1F0: 833D0010  lwz r25, 0x10(r29)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FCB1F4: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 82FCB1F8: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 82FCB1FC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82FCB200: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82FCB204: 4BFFF1C5  bl 0x82fca3c8
	ctx.lr = 0x82FCB208;
	sub_82FCA3C8(ctx, base);
	// 82FCB208: 933F0030  stw r25, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[25].u32 ) };
	// 82FCB20C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCB210: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82FCB214: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	// 82FCB218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FCB21C: 40990088  ble cr6, 0x82fcb2a4
	if !ctx.cr[6].gt {
	pc = 0x82FCB2A4; continue 'dispatch;
	}
	// 82FCB220: 7F68DB78  mr r8, r27
	ctx.r[8].u64 = ctx.r[27].u64;
	pc = 0x82FCB224; continue 'dispatch;
            }
            0x82FCB224 => {
    //   block [0x82FCB224..0x82FCB294)
	// 82FCB224: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82FCB228: 5527E13A  rlwinm r7, r9, 0x1c, 4, 0x1d
	ctx.r[7].u64 = ctx.r[9].u32 as u64 & 0x0000000Fu64;
	// 82FCB22C: 552B06BE  clrlwi r11, r9, 0x1a
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0x0000003Fu64;
	// 82FCB230: 1D6B001C  mulli r11, r11, 0x1c
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 28 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FCB234: 7D47502E  lwzx r10, r7, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82FCB238: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FCB23C: 816A0018  lwz r11, 0x18(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FCB240: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82FCB244: 409A0050  bne cr6, 0x82fcb294
	if !ctx.cr[6].eq {
	pc = 0x82FCB294; continue 'dispatch;
	}
	// 82FCB248: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCB24C: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FCB250: 40980044  bge cr6, 0x82fcb294
	if !ctx.cr[6].lt {
	pc = 0x82FCB294; continue 'dispatch;
	}
	// 82FCB254: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82FCB258: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 82FCB25C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCB260: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCB264: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 82FCB268: 39080018  addi r8, r8, 0x18
	ctx.r[8].s64 = ctx.r[8].s64 + 24;
	// 82FCB26C: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82FCB270: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82FCB274: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCB278: 80CA0014  lwz r6, 0x14(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FCB27C: 808A000C  lwz r4, 0xc(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FCB280: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FCB284: 90EB0008  stw r7, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82FCB288: 908B000C  stw r4, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[4].u32 ) };
	// 82FCB28C: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82FCB290: 90CB0014  stw r6, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	pc = 0x82FCB294; continue 'dispatch;
            }
            0x82FCB294 => {
    //   block [0x82FCB294..0x82FCB2A4)
	// 82FCB294: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCB298: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82FCB29C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FCB2A0: 4198FF84  blt cr6, 0x82fcb224
	if ctx.cr[6].lt {
	pc = 0x82FCB224; continue 'dispatch;
	}
	pc = 0x82FCB2A4; continue 'dispatch;
            }
            0x82FCB2A4 => {
    //   block [0x82FCB2A4..0x82FCB2B8)
	// 82FCB2A4: 817F02BC  lwz r11, 0x2bc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(700 as u32) ) } as u64;
	// 82FCB2A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82FCB2AC: 38EB0010  addi r7, r11, 0x10
	ctx.r[7].s64 = ctx.r[11].s64 + 16;
	// 82FCB2B0: 409A0008  bne cr6, 0x82fcb2b8
	if !ctx.cr[6].eq {
	pc = 0x82FCB2B8; continue 'dispatch;
	}
	// 82FCB2B4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x82FCB2B8; continue 'dispatch;
            }
            0x82FCB2B8 => {
    //   block [0x82FCB2B8..0x82FCB2D4)
	// 82FCB2B8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCB2BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82FCB2C0: 80DF0038  lwz r6, 0x38(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82FCB2C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCB2C8: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FCB2CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82FCB2D0: 4E800421  bctrl
	ctx.lr = 0x82FCB2D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82FCB2D4 => {
    //   block [0x82FCB2D4..0x82FCB2D8)
	// 82FCB2D4: 937D0010  stw r27, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[27].u32 ) };
	pc = 0x82FCB2D8; continue 'dispatch;
            }
            0x82FCB2D8 => {
    //   block [0x82FCB2D8..0x82FCB2EC)
	// 82FCB2D8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCB2DC: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82FCB2E0: 3BBD0014  addi r29, r29, 0x14
	ctx.r[29].s64 = ctx.r[29].s64 + 20;
	// 82FCB2E4: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82FCB2E8: 4198FEE4  blt cr6, 0x82fcb1cc
	if ctx.cr[6].lt {
	pc = 0x82FCB1CC; continue 'dispatch;
	}
	pc = 0x82FCB2EC; continue 'dispatch;
            }
            0x82FCB2EC => {
    //   block [0x82FCB2EC..0x82FCB304)
	// 82FCB2EC: 937F001C  stw r27, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u32 ) };
	// 82FCB2F0: 937F02C8  stw r27, 0x2c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(712 as u32), ctx.r[27].u32 ) };
	// 82FCB2F4: 937F02CC  stw r27, 0x2cc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(716 as u32), ctx.r[27].u32 ) };
	// 82FCB2F8: 937F02D0  stw r27, 0x2d0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(720 as u32), ctx.r[27].u32 ) };
	// 82FCB2FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82FCB300: 4BCDE14C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCB308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FCB308 size=1112
    let mut pc: u32 = 0x82FCB308;
    'dispatch: loop {
        match pc {
            0x82FCB308 => {
    //   block [0x82FCB308..0x82FCB340)
	// 82FCB308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCB30C: 4BCDE0D9  bl 0x82ca93e4
	ctx.lr = 0x82FCB310;
	sub_82CA93D0(ctx, base);
	// 82FCB310: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 82FCB314: 4BCE29B5  bl 0x82cadcc8
	ctx.lr = 0x82FCB318;
	sub_82CADCA0(ctx, base);
	// 82FCB318: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCB31C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82FCB320: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FCB324: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCB328: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FCB32C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82FCB330: C00B6E6C  lfs f0, 0x6e6c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FCB334: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82FCB338: 40980008  bge cr6, 0x82fcb340
	if !ctx.cr[6].lt {
	pc = 0x82FCB340; continue 'dispatch;
	}
	// 82FCB33C: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	pc = 0x82FCB340; continue 'dispatch;
            }
            0x82FCB340 => {
    //   block [0x82FCB340..0x82FCB3B8)
	// 82FCB340: 827F000C  lwz r19, 0xc(r31)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FCB344: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82FCB348: 829F0010  lwz r20, 0x10(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FCB34C: 4B2CA6BD  bl 0x82295a08
	ctx.lr = 0x82FCB350;
	sub_82295A08(ctx, base);
	// 82FCB350: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FCB354: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82FCB358: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FCB35C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FCB360: 7FCB9A14  add r30, r11, r19
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[19].u64;
	// 82FCB364: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 82FCB368: 419803E8  blt cr6, 0x82fcb750
	if ctx.cr[6].lt {
	pc = 0x82FCB750; continue 'dispatch;
	}
	// 82FCB36C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FCB370: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FCB374: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82FCB378: C30B0BFC  lfs f24, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82FCB37C: EC1F0632  fmuls f0, f31, f24
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[24].f64) as f32) as f64);
	// 82FCB380: C18A0A9C  lfs f12, 0xa9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2716 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FCB384: C1A90C14  lfs f13, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FCB388: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82FCB38C: 4098002C  bge cr6, 0x82fcb3b8
	if !ctx.cr[6].lt {
	pc = 0x82FCB3B8; continue 'dispatch;
	}
	// 82FCB390: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FCB394: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82FCB398: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82FCB39C: C18B6E68  lfs f12, 0x6e68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28264 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FCB3A0: ED606B3C  fnmsubs f11, f0, f12, f13
	ctx.f[11].f64 = -(((ctx.f[0].f64 * ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FCB3A4: C00A6E64  lfs f0, 0x6e64(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FCB3A8: C1896E60  lfs f12, 0x6e60(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28256 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FCB3AC: ED60582C  fsqrts f11, f11
	ctx.f[11].f64 = ((ctx.f[11].f64).sqrt() as f32) as f64;
	// 82FCB3B0: EC0B603C  fnmsubs f0, f11, f0, f12
	ctx.f[0].f64 = -(((ctx.f[11].f64 * ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FCB3B4: 48000018  b 0x82fcb3cc
	pc = 0x82FCB3CC; continue 'dispatch;
            }
            0x82FCB3B8 => {
    //   block [0x82FCB3B8..0x82FCB3CC)
	// 82FCB3B8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FCB3BC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82FCB3C0: C18B6E5C  lfs f12, 0x6e5c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28252 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FCB3C4: C16A6E58  lfs f11, 0x6e58(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28248 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FCB3C8: EC005B38  fmsubs f0, f0, f12, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	pc = 0x82FCB3CC; continue 'dispatch;
            }
            0x82FCB3CC => {
    //   block [0x82FCB3CC..0x82FCB4C0)
	// 82FCB3CC: ECE00032  fmuls f7, f0, f0
	ctx.f[7].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FCB3D0: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FCB3D4: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82FCB3D8: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82FCB3DC: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82FCB3E0: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82FCB3E4: C18B6E54  lfs f12, 0x6e54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28244 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FCB3E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FCB3EC: ECC00332  fmuls f6, f0, f12
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FCB3F0: C18A6E50  lfs f12, 0x6e50(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28240 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FCB3F4: C1696E4C  lfs f11, 0x6e4c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28236 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FCB3F8: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82FCB3FC: C1486E48  lfs f10, 0x6e48(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28232 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82FCB400: 57DC083C  slwi r28, r30, 1
	ctx.r[28].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82FCB404: C1276E44  lfs f9, 0x6e44(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28228 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82FCB408: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82FCB40C: ECA70032  fmuls f5, f7, f0
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FCB410: C00B6E40  lfs f0, 0x6e40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FCB414: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82FCB418: C10A6E3C  lfs f8, 0x6e3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28220 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82FCB41C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FCB420: ED87333A  fmadds f12, f7, f12, f6
	ctx.f[12].f64 = (((ctx.f[7].f64 * ctx.f[12].f64 + ctx.f[6].f64) as f32) as f64);
	// 82FCB424: ED4502B2  fmuls f10, f5, f10
	ctx.f[10].f64 = (((ctx.f[5].f64 * ctx.f[10].f64) as f32) as f64);
	// 82FCB428: ED6502F2  fmuls f11, f5, f11
	ctx.f[11].f64 = (((ctx.f[5].f64 * ctx.f[11].f64) as f32) as f64);
	// 82FCB42C: ED275278  fmsubs f9, f7, f9, f10
	ctx.f[9].f64 = (((ctx.f[7].f64 * ctx.f[9].f64 - ctx.f[10].f64) as f32) as f64);
	// 82FCB430: EC07503A  fmadds f0, f7, f0, f10
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 82FCB434: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 82FCB438: ED4B482A  fadds f10, f11, f9
	ctx.f[10].f64 = ((ctx.f[11].f64 + ctx.f[9].f64) as f32) as f64;
	// 82FCB43C: EC00302A  fadds f0, f0, f6
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64;
	// 82FCB440: ED8C402A  fadds f12, f12, f8
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[8].f64) as f32) as f64;
	// 82FCB444: ED4A002A  fadds f10, f10, f0
	ctx.f[10].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82FCB448: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 82FCB44C: EFC00332  fmuls f30, f0, f12
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FCB450: EFA90332  fmuls f29, f9, f12
	ctx.f[29].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FCB454: EFEA6B3C  fnmsubs f31, f10, f12, f13
	ctx.f[31].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FCB458: EF8B0332  fmuls f28, f11, f12
	ctx.f[28].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FCB45C: 4800313D  bl 0x82fce598
	ctx.lr = 0x82FCB460;
	sub_82FCE598(ctx, base);
	// 82FCB460: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82FCB464: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82FCB468: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FCB46C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82FCB470: 4BFFEE19  bl 0x82fca288
	ctx.lr = 0x82FCB474;
	sub_82FCA288(ctx, base);
	// 82FCB474: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82FCB478: 93DA0000  stw r30, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82FCB47C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82FCB480: 2F140000  cmpwi cr6, r20, 0
	ctx.cr[6].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 82FCB484: 83BD0008  lwz r29, 8(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCB488: 7F6BEA14  add r27, r11, r29
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 82FCB48C: 409902C4  ble cr6, 0x82fcb750
	if !ctx.cr[6].gt {
	pc = 0x82FCB750; continue 'dispatch;
	}
	// 82FCB490: EC1FE02A  fadds f0, f31, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[31].f64 + ctx.f[28].f64) as f32) as f64;
	// 82FCB494: 395EFFFE  addi r10, r30, -2
	ctx.r[10].s64 = ctx.r[30].s64 + -2;
	// 82FCB498: EF7CE82A  fadds f27, f28, f29
	ctx.f[27].f64 = ((ctx.f[28].f64 + ctx.f[29].f64) as f32) as f64;
	// 82FCB49C: 393EFFFD  addi r9, r30, -3
	ctx.r[9].s64 = ctx.r[30].s64 + -3;
	// 82FCB4A0: 5557103A  slwi r23, r10, 2
	ctx.r[23].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[23].u64 = ctx.r[23].u32 as u64;
	// 82FCB4A4: 5536103A  slwi r22, r9, 2
	ctx.r[22].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[22].u64 = ctx.r[22].u32 as u64;
	// 82FCB4A8: 7F0BDA14  add r24, r11, r27
	ctx.r[24].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82FCB4AC: 3B3D0004  addi r25, r29, 4
	ctx.r[25].s64 = ctx.r[29].s64 + 4;
	// 82FCB4B0: 3ABEFFFC  addi r21, r30, -4
	ctx.r[21].s64 = ctx.r[30].s64 + -4;
	// 82FCB4B4: EC00E82A  fadds f0, f0, f29
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64;
	// 82FCB4B8: EF5BF02A  fadds f26, f27, f30
	ctx.f[26].f64 = ((ctx.f[27].f64 + ctx.f[30].f64) as f32) as f64;
	// 82FCB4BC: EF20F02A  fadds f25, f0, f30
	ctx.f[25].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	pc = 0x82FCB4C0; continue 'dispatch;
            }
            0x82FCB4C0 => {
    //   block [0x82FCB4C0..0x82FCB598)
	// 82FCB4C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCB4C4: 39000003  li r8, 3
	ctx.r[8].s64 = 3;
	// 82FCB4C8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCB4CC: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 82FCB4D0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCB4D4: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 82FCB4D8: 80EB001C  lwz r7, 0x1c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCB4DC: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FCB4E0: 7D4A39D6  mullw r10, r10, r7
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[7].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FCB4E4: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FCB4E8: 7D6B48AE  lbzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FCB4EC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82FCB4F0: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FCB4F4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82FCB4F8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82FCB4FC: EC000672  fmuls f0, f0, f25
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[25].f64) as f32) as f64);
	// 82FCB500: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FCB504: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCB508: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCB50C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCB510: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 82FCB514: 80EB001C  lwz r7, 0x1c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCB518: 7D4A39D6  mullw r10, r10, r7
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[7].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FCB51C: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FCB520: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FCB524: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82FCB528: EDA006B2  fmuls f13, f0, f26
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 82FCB52C: EC0006F2  fmuls f0, f0, f27
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82FCB530: 896B0001  lbz r11, 1(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 82FCB534: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82FCB538: C9810058  lfd f12, 0x58(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82FCB53C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82FCB540: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82FCB544: EDAC6FFA  fmadds f13, f12, f31, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64);
	// 82FCB548: D1B90000  stfs f13, 0(r25)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FCB54C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCB550: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCB554: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCB558: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 82FCB55C: 80EB001C  lwz r7, 0x1c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCB560: 7D4A39D6  mullw r10, r10, r7
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[7].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FCB564: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FCB568: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FCB56C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82FCB570: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82FCB574: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82FCB578: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82FCB57C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82FCB580: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82FCB584: EC0C07FA  fmadds f0, f12, f31, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FCB588: EC0D07BA  fmadds f0, f13, f30, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FCB58C: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82FCB590: 40990084  ble cr6, 0x82fcb614
	if !ctx.cr[6].gt {
	pc = 0x82FCB614; continue 'dispatch;
	}
	// 82FCB594: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x82FCB598; continue 'dispatch;
            }
            0x82FCB598 => {
    //   block [0x82FCB598..0x82FCB5CC)
	// 82FCB598: 7F089800  cmpw cr6, r8, r19
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[19].s32, &mut ctx.xer);
	// 82FCB59C: 40980030  bge cr6, 0x82fcb5cc
	if !ctx.cr[6].lt {
	pc = 0x82FCB5CC; continue 'dispatch;
	}
	// 82FCB5A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCB5A4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCB5A8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCB5AC: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 82FCB5B0: 80CB001C  lwz r6, 0x1c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCB5B4: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FCB5B8: 7D4A31D6  mullw r10, r10, r6
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[6].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FCB5BC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FCB5C0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82FCB5C4: 7D6B40AE  lbzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 82FCB5C8: 48000008  b 0x82fcb5d0
	pc = 0x82FCB5D0; continue 'dispatch;
            }
            0x82FCB5CC => {
    //   block [0x82FCB5CC..0x82FCB5D0)
	// 82FCB5CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82FCB5D0; continue 'dispatch;
            }
            0x82FCB5D0 => {
    //   block [0x82FCB5D0..0x82FCB614)
	// 82FCB5D0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82FCB5D4: C007FFFC  lfs f0, -4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FCB5D8: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 82FCB5DC: C1A70004  lfs f13, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FCB5E0: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 82FCB5E4: C9610068  lfd f11, 0x68(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82FCB5E8: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82FCB5EC: C1870000  lfs f12, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FCB5F0: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82FCB5F4: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82FCB5F8: 7F08F000  cmpw cr6, r8, r30
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82FCB5FC: EC0B07FA  fmadds f0, f11, f31, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FCB600: EC0D07BA  fmadds f0, f13, f30, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FCB604: EC1D033A  fmadds f0, f29, f12, f0
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FCB608: D0070008  stfs f0, 8(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82FCB60C: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 82FCB610: 4198FF88  blt cr6, 0x82fcb598
	if ctx.cr[6].lt {
	pc = 0x82FCB598; continue 'dispatch;
	}
	pc = 0x82FCB614; continue 'dispatch;
            }
            0x82FCB614 => {
    //   block [0x82FCB614..0x82FCB6C8)
	// 82FCB614: C01BFFFC  lfs f0, -4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FCB618: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 82FCB61C: EC000672  fmuls f0, f0, f25
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[25].f64) as f32) as f64);
	// 82FCB620: D018FFFC  stfs f0, -4(r24)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82FCB624: 2C150000  cmpwi r21, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82FCB628: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 82FCB62C: FD800090  fmr f12, f0
	ctx.f[12].f64 = ctx.f[0].f64;
	// 82FCB630: EC0006B2  fmuls f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[26].f64) as f32) as f64);
	// 82FCB634: EDADC02A  fadds f13, f13, f24
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[24].f64) as f32) as f64;
	// 82FCB638: 7D77EC2E  lfsx f11, r23, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FCB63C: EC0B07FA  fmadds f0, f11, f31, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FCB640: 7C17DD2E  stfsx f0, r23, r27
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[23].u32.wrapping_add(ctx.r[27].u32), tmp.u32) };
	// 82FCB644: 7D76EC2E  lfsx f11, r22, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FCB648: FDA06E5E  fctidz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 82FCB64C: D9A10070  stfd f13, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[13].u64 ) };
	// 82FCB650: 89210077  lbz r9, 0x77(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(119 as u32) ) } as u64;
	// 82FCB654: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82FCB658: EC1B033A  fmadds f0, f27, f12, f0
	ctx.f[0].f64 = (((ctx.f[27].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FCB65C: EC1F02FA  fmadds f0, f31, f11, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FCB660: 7C16DD2E  stfsx f0, r22, r27
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[22].u32.wrapping_add(ctx.r[27].u32), tmp.u32) };
	// 82FCB664: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCB668: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82FCB66C: 992AFFFF  stb r9, -1(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-1 as u32), ctx.r[9].u8 ) };
	// 82FCB670: 7C17DC2E  lfsx f0, r23, r27
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[23].u32.wrapping_add(ctx.r[27].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FCB674: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCB678: EC00C02A  fadds f0, f0, f24
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[24].f64) as f32) as f64;
	// 82FCB67C: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82FCB680: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82FCB684: D8010070  stfd f0, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[0].u64 ) };
	// 82FCB688: 89210077  lbz r9, 0x77(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(119 as u32) ) } as u64;
	// 82FCB68C: 992AFFFE  stb r9, -2(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-2 as u32), ctx.r[9].u8 ) };
	// 82FCB690: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCB694: 7C16DC2E  lfsx f0, r22, r27
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[27].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FCB698: EC00C02A  fadds f0, f0, f24
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[24].f64) as f32) as f64;
	// 82FCB69C: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 82FCB6A0: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82FCB6A4: D8010070  stfd f0, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[0].u64 ) };
	// 82FCB6A8: 89210077  lbz r9, 0x77(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(119 as u32) ) } as u64;
	// 82FCB6AC: 992AFFFD  stb r9, -3(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-3 as u32), ctx.r[9].u8 ) };
	// 82FCB6B0: 41800064  blt 0x82fcb714
	if ctx.cr[0].lt {
	pc = 0x82FCB714; continue 'dispatch;
	}
	// 82FCB6B4: 392B0002  addi r9, r11, 2
	ctx.r[9].s64 = ctx.r[11].s64 + 2;
	// 82FCB6B8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82FCB6BC: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82FCB6C0: 7D2AEA14  add r9, r10, r29
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 82FCB6C4: 7D48DA14  add r10, r8, r27
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[27].u64;
	pc = 0x82FCB6C8; continue 'dispatch;
            }
            0x82FCB6C8 => {
    //   block [0x82FCB6C8..0x82FCB714)
	// 82FCB6C8: C00AFFFC  lfs f0, -4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FCB6CC: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82FCB6D0: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FCB6D4: C18A0000  lfs f12, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FCB6D8: C1690000  lfs f11, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FCB6DC: 3929FFFC  addi r9, r9, -4
	ctx.r[9].s64 = ctx.r[9].s64 + -4;
	// 82FCB6E0: EC0D073A  fmadds f0, f13, f28, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[28].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FCB6E4: EC0C077A  fmadds f0, f12, f29, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[29].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FCB6E8: EC1F02FA  fmadds f0, f31, f11, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 82FCB6EC: D00AFFF8  stfs f0, -8(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82FCB6F0: 394AFFFC  addi r10, r10, -4
	ctx.r[10].s64 = ctx.r[10].s64 + -4;
	// 82FCB6F4: EC00C02A  fadds f0, f0, f24
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[24].f64) as f32) as f64;
	// 82FCB6F8: FC00065E  fctidz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82FCB6FC: D8010070  stfd f0, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[0].u64 ) };
	// 82FCB700: 811A0008  lwz r8, 8(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCB704: 88E10077  lbz r7, 0x77(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(119 as u32) ) } as u64;
	// 82FCB708: 7CEB41AE  stbx r7, r11, r8
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[7].u8) };
	// 82FCB70C: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FCB710: 4080FFB8  bge 0x82fcb6c8
	if !ctx.cr[0].lt {
	pc = 0x82FCB6C8; continue 'dispatch;
	}
	pc = 0x82FCB714; continue 'dispatch;
            }
            0x82FCB714 => {
    //   block [0x82FCB714..0x82FCB750)
	// 82FCB714: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCB718: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 82FCB71C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCB720: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCB724: 7D4AE214  add r10, r10, r28
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 82FCB728: 809A0008  lwz r4, 8(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCB72C: 810B001C  lwz r8, 0x1c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCB730: 816B0020  lwz r11, 0x20(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FCB734: 7D4A41D6  mullw r10, r10, r8
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82FCB738: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FCB73C: 7C6B4A14  add r3, r11, r9
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82FCB740: 4BCDDD41  bl 0x82ca9480
	ctx.lr = 0x82FCB744;
	sub_82CA9480(ctx, base);
	// 82FCB744: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82FCB748: 7F1CA000  cmpw cr6, r28, r20
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[20].s32, &mut ctx.xer);
	// 82FCB74C: 4198FD74  blt cr6, 0x82fcb4c0
	if ctx.cr[6].lt {
	pc = 0x82FCB4C0; continue 'dispatch;
	}
	pc = 0x82FCB750; continue 'dispatch;
            }
            0x82FCB750 => {
    //   block [0x82FCB750..0x82FCB760)
	// 82FCB750: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82FCB754: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 82FCB758: 4BCE25BD  bl 0x82cadd14
	ctx.lr = 0x82FCB75C;
	sub_82CADCEC(ctx, base);
	// 82FCB75C: 4BCDDCD8  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCB760(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82FCB760 size=1140
    let mut pc: u32 = 0x82FCB760;
    'dispatch: loop {
        match pc {
            0x82FCB760 => {
    //   block [0x82FCB760..0x82FCB798)
	// 82FCB760: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCB764: 4BCDDC8D  bl 0x82ca93f0
	ctx.lr = 0x82FCB768;
	sub_82CA93D0(ctx, base);
	// 82FCB768: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82FCB76C: 4BCE2569  bl 0x82cadcd4
	ctx.lr = 0x82FCB770;
	sub_82CADCA0(ctx, base);
	// 82FCB770: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCB774: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82FCB778: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FCB77C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82FCB780: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82FCB784: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82FCB788: C00B6E6C  lfs f0, 0x6e6c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28268 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FCB78C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82FCB790: 40980008  bge cr6, 0x82fcb798
	if !ctx.cr[6].lt {
	pc = 0x82FCB798; continue 'dispatch;
	}
	// 82FCB794: FFE00090  fmr f31, f0
	ctx.f[31].f64 = ctx.f[0].f64;
	pc = 0x82FCB798; continue 'dispatch;
            }
            0x82FCB798 => {
    //   block [0x82FCB798..0x82FCB810)
	// 82FCB798: 831F0010  lwz r24, 0x10(r31)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FCB79C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82FCB7A0: 82FF000C  lwz r23, 0xc(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FCB7A4: 4B2CA265  bl 0x82295a08
	ctx.lr = 0x82FCB7A8;
	sub_82295A08(ctx, base);
	// 82FCB7A8: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82FCB7AC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82FCB7B0: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 82FCB7B4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82FCB7B8: 7FCBC214  add r30, r11, r24
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 82FCB7BC: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 82FCB7C0: 41980404  blt cr6, 0x82fcbbc4
	if ctx.cr[6].lt {
	pc = 0x82FCBBC4; continue 'dispatch;
	}
	// 82FCB7C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82FCB7C8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82FCB7CC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82FCB7D0: C36B0BFC  lfs f27, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82FCB7D4: EC1F06F2  fmuls f0, f31, f27
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[27].f64) as f32) as f64);
	// 82FCB7D8: C18A0A9C  lfs f12, 0xa9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2716 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FCB7DC: C1A90C14  lfs f13, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82FCB7E0: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82FCB7E4: 4098002C  bge cr6, 0x82fcb810
	if !ctx.cr[6].lt {
	pc = 0x82FCB810; continue 'dispatch;
	}
	// 82FCB7E8: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FCB7EC: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82FCB7F0: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82FCB7F4: C18B6E68  lfs f12, 0x6e68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28264 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FCB7F8: ED606B3C  fnmsubs f11, f0, f12, f13
	ctx.f[11].f64 = -(((ctx.f[0].f64 * ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FCB7FC: C00A6E64  lfs f0, 0x6e64(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28260 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FCB800: C1896E60  lfs f12, 0x6e60(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28256 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FCB804: ED60582C  fsqrts f11, f11
	ctx.f[11].f64 = ((ctx.f[11].f64).sqrt() as f32) as f64;
	// 82FCB808: EC0B603C  fnmsubs f0, f11, f0, f12
	ctx.f[0].f64 = -(((ctx.f[11].f64 * ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82FCB80C: 48000018  b 0x82fcb824
	pc = 0x82FCB824; continue 'dispatch;
            }
            0x82FCB810 => {
    //   block [0x82FCB810..0x82FCB824)
	// 82FCB810: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FCB814: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82FCB818: C18B6E5C  lfs f12, 0x6e5c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28252 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FCB81C: C16A6E58  lfs f11, 0x6e58(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28248 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FCB820: EC005B38  fmsubs f0, f0, f12, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	pc = 0x82FCB824; continue 'dispatch;
            }
            0x82FCB824 => {
    //   block [0x82FCB824..0x82FCB918)
	// 82FCB824: ECE00032  fmuls f7, f0, f0
	ctx.f[7].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FCB828: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FCB82C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82FCB830: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82FCB834: 3D008204  lis r8, -0x7dfc
	ctx.r[8].s64 = -2113667072;
	// 82FCB838: 3CE08204  lis r7, -0x7dfc
	ctx.r[7].s64 = -2113667072;
	// 82FCB83C: C18B6E54  lfs f12, 0x6e54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28244 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FCB840: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82FCB844: ECC00332  fmuls f6, f0, f12
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FCB848: C18A6E50  lfs f12, 0x6e50(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28240 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82FCB84C: C1696E4C  lfs f11, 0x6e4c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28236 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FCB850: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82FCB854: C1486E48  lfs f10, 0x6e48(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(28232 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82FCB858: 57DB083C  slwi r27, r30, 1
	ctx.r[27].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82FCB85C: C1276E44  lfs f9, 0x6e44(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28228 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82FCB860: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82FCB864: ECA70032  fmuls f5, f7, f0
	ctx.f[5].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FCB868: C00B6E40  lfs f0, 0x6e40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82FCB86C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82FCB870: C10A6E3C  lfs f8, 0x6e3c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28220 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82FCB874: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82FCB878: ED87333A  fmadds f12, f7, f12, f6
	ctx.f[12].f64 = (((ctx.f[7].f64 * ctx.f[12].f64 + ctx.f[6].f64) as f32) as f64);
	// 82FCB87C: ED4502B2  fmuls f10, f5, f10
	ctx.f[10].f64 = (((ctx.f[5].f64 * ctx.f[10].f64) as f32) as f64);
	// 82FCB880: ED6502F2  fmuls f11, f5, f11
	ctx.f[11].f64 = (((ctx.f[5].f64 * ctx.f[11].f64) as f32) as f64);
	// 82FCB884: ED275278  fmsubs f9, f7, f9, f10
	ctx.f[9].f64 = (((ctx.f[7].f64 * ctx.f[9].f64 - ctx.f[10].f64) as f32) as f64);
	// 82FCB888: EC07503A  fmadds f0, f7, f0, f10
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 82FCB88C: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 82FCB890: ED4B482A  fadds f10, f11, f9
	ctx.f[10].f64 = ((ctx.f[11].f64 + ctx.f[9].f64) as f32) as f64;
	// 82FCB894: EC00302A  fadds f0, f0, f6
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64;
	// 82FCB898: ED8C402A  fadds f12, f12, f8
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[8].f64) as f32) as f64;
	// 82FCB89C: ED4A002A  fadds f10, f10, f0
	ctx.f[10].f64 = ((ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64;
	// 82FCB8A0: ED8D6024  fdivs f12, f13, f12
	ctx.f[12].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 82FCB8A4: EFC00332  fmuls f30, f0, f12
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FCB8A8: EFA90332  fmuls f29, f9, f12
	ctx.f[29].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FCB8AC: EFEA6B3C  fnmsubs f31, f10, f12, f13
	ctx.f[31].f64 = -(((ctx.f[10].f64 * ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82FCB8B0: EF8B0332  fmuls f28, f11, f12
	ctx.f[28].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FCB8B4: 48002CE5  bl 0x82fce598
	ctx.lr = 0x82FCB8B8;
	sub_82FCE598(ctx, base);
	// 82FCB8B8: 937D0000  stw r27, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82FCB8BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82FCB8C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FCB8C4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82FCB8C8: 4BFFE9C1  bl 0x82fca288
	ctx.lr = 0x82FCB8CC;
	sub_82FCA288(ctx, base);
	// 82FCB8CC: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82FCB8D0: 93DC0000  stw r30, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82FCB8D4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82FCB8D8: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCB8DC: 2F170000  cmpwi cr6, r23, 0
	ctx.cr[6].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 82FCB8E0: 7C8A5A14  add r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82FCB8E4: 409902E0  ble cr6, 0x82fcbbc4
	if !ctx.cr[6].gt {
	pc = 0x82FCBBC4; continue 'dispatch;
	}
	// 82FCB8E8: EDBFE02A  fadds f13, f31, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[31].f64 + ctx.f[28].f64) as f32) as f64;
	// 82FCB8EC: 391EFFFE  addi r8, r30, -2
	ctx.r[8].s64 = ctx.r[30].s64 + -2;
	// 82FCB8F0: EC1CE82A  fadds f0, f28, f29
	ctx.f[0].f64 = ((ctx.f[28].f64 + ctx.f[29].f64) as f32) as f64;
	// 82FCB8F4: 38FEFFFD  addi r7, r30, -3
	ctx.r[7].s64 = ctx.r[30].s64 + -3;
	// 82FCB8F8: 551B103A  slwi r27, r8, 2
	ctx.r[27].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 82FCB8FC: 54FA103A  slwi r26, r7, 2
	ctx.r[26].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 82FCB900: 7FAA2214  add r29, r10, r4
	ctx.r[29].u64 = ctx.r[10].u64 + ctx.r[4].u64;
	// 82FCB904: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82FCB908: 3B3EFFFC  addi r25, r30, -4
	ctx.r[25].s64 = ctx.r[30].s64 + -4;
	// 82FCB90C: ED8DE82A  fadds f12, f13, f29
	ctx.f[12].f64 = ((ctx.f[13].f64 + ctx.f[29].f64) as f32) as f64;
	// 82FCB910: EDA0F02A  fadds f13, f0, f30
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82FCB914: ED8CF02A  fadds f12, f12, f30
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[30].f64) as f32) as f64;
	pc = 0x82FCB918; continue 'dispatch;
            }
            0x82FCB918 => {
    //   block [0x82FCB918..0x82FCB9F0)
	// 82FCB918: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCB91C: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82FCB920: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCB924: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 82FCB928: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCB92C: 80AA001C  lwz r5, 0x1c(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCB930: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FCB934: 7D0541D6  mullw r8, r5, r8
	ctx.r[8].s32 = ((ctx.r[5].s32 as i64 * ctx.r[8].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82FCB938: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82FCB93C: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82FCB940: 7D4A48AE  lbzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FCB944: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82FCB948: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82FCB94C: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82FCB950: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82FCB954: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82FCB958: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FCB95C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCB960: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCB964: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCB968: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 82FCB96C: 80AA001C  lwz r5, 0x1c(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCB970: 7D0829D6  mullw r8, r8, r5
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82FCB974: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FCB978: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82FCB97C: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82FCB980: ED4B0372  fmuls f10, f11, f13
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 82FCB984: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82FCB988: 7D4A48AE  lbzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FCB98C: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82FCB990: C9210058  lfd f9, 0x58(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82FCB994: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 82FCB998: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82FCB99C: ED4957FA  fmadds f10, f9, f31, f10
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[31].f64 + ctx.f[10].f64) as f32) as f64);
	// 82FCB9A0: D1430000  stfs f10, 0(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82FCB9A4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCB9A8: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCB9AC: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCB9B0: 39080002  addi r8, r8, 2
	ctx.r[8].s64 = ctx.r[8].s64 + 2;
	// 82FCB9B4: 80AA001C  lwz r5, 0x1c(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCB9B8: 7D0829D6  mullw r8, r8, r5
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82FCB9BC: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FCB9C0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82FCB9C4: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82FCB9C8: 7D4A48AE  lbzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FCB9CC: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 82FCB9D0: C9210060  lfd f9, 0x60(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82FCB9D4: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 82FCB9D8: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 82FCB9DC: ED695FFA  fmadds f11, f9, f31, f11
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[31].f64 + ctx.f[11].f64) as f32) as f64);
	// 82FCB9E0: ED6A5FBA  fmadds f11, f10, f30, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[30].f64 + ctx.f[11].f64) as f32) as f64);
	// 82FCB9E4: D16B0008  stfs f11, 8(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82FCB9E8: 40990084  ble cr6, 0x82fcba6c
	if !ctx.cr[6].gt {
	pc = 0x82FCBA6C; continue 'dispatch;
	}
	// 82FCB9EC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	pc = 0x82FCB9F0; continue 'dispatch;
            }
            0x82FCB9F0 => {
    //   block [0x82FCB9F0..0x82FCBA24)
	// 82FCB9F0: 7F06C000  cmpw cr6, r6, r24
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[24].s32, &mut ctx.xer);
	// 82FCB9F4: 40980030  bge cr6, 0x82fcba24
	if !ctx.cr[6].lt {
	pc = 0x82FCBA24; continue 'dispatch;
	}
	// 82FCB9F8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCB9FC: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCBA00: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCBA04: 7D083214  add r8, r8, r6
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[6].u64;
	// 82FCBA08: 82CA001C  lwz r22, 0x1c(r10)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCBA0C: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FCBA10: 7D08B1D6  mullw r8, r8, r22
	ctx.r[8].s32 = ((ctx.r[8].s32 as i64 * ctx.r[22].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 82FCBA14: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82FCBA18: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 82FCBA1C: 7D4A48AE  lbzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82FCBA20: 48000008  b 0x82fcba28
	pc = 0x82FCBA28; continue 'dispatch;
            }
            0x82FCBA24 => {
    //   block [0x82FCBA24..0x82FCBA28)
	// 82FCBA24: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82FCBA28; continue 'dispatch;
            }
            0x82FCBA28 => {
    //   block [0x82FCBA28..0x82FCBA6C)
	// 82FCBA28: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82FCBA2C: C165FFFC  lfs f11, -4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FCBA30: ED6B0732  fmuls f11, f11, f28
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[28].f64) as f32) as f64);
	// 82FCBA34: C1450004  lfs f10, 4(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82FCBA38: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 82FCBA3C: C9010068  lfd f8, 0x68(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82FCBA40: FD00469C  fcfid f8, f8
	ctx.f[8].f64 = (ctx.f[8].s64 as f64);
	// 82FCBA44: C1250000  lfs f9, 0(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82FCBA48: FD004018  frsp f8, f8
	ctx.f[8].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82FCBA4C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82FCBA50: 7F06F000  cmpw cr6, r6, r30
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82FCBA54: ED685FFA  fmadds f11, f8, f31, f11
	ctx.f[11].f64 = (((ctx.f[8].f64 * ctx.f[31].f64 + ctx.f[11].f64) as f32) as f64);
	// 82FCBA58: ED6A5FBA  fmadds f11, f10, f30, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[30].f64 + ctx.f[11].f64) as f32) as f64);
	// 82FCBA5C: ED7D5A7A  fmadds f11, f29, f9, f11
	ctx.f[11].f64 = (((ctx.f[29].f64 * ctx.f[9].f64 + ctx.f[11].f64) as f32) as f64);
	// 82FCBA60: D1650008  stfs f11, 8(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82FCBA64: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 82FCBA68: 4198FF88  blt cr6, 0x82fcb9f0
	if ctx.cr[6].lt {
	pc = 0x82FCB9F0; continue 'dispatch;
	}
	pc = 0x82FCBA6C; continue 'dispatch;
            }
            0x82FCBA6C => {
    //   block [0x82FCBA6C..0x82FCBB20)
	// 82FCBA6C: C164FFFC  lfs f11, -4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FCBA70: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 82FCBA74: ED6C02F2  fmuls f11, f12, f11
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 82FCBA78: D17DFFFC  stfs f11, -4(r29)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82FCBA7C: 7D1B5C2E  lfsx f8, r27, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82FCBA80: ED1F0232  fmuls f8, f31, f8
	ctx.f[8].f64 = (((ctx.f[31].f64 * ctx.f[8].f64) as f32) as f64);
	// 82FCBA84: FD405890  fmr f10, f11
	ctx.f[10].f64 = ctx.f[11].f64;
	// 82FCBA88: 2C190000  cmpwi r25, 0
	ctx.cr[0].compare_i32(ctx.r[0].s32, 0, &mut ctx.xer);
	// 82FCBA8C: FD205890  fmr f9, f11
	ctx.f[9].f64 = ctx.f[11].f64;
	// 82FCBA90: ED6B437A  fmadds f11, f11, f13, f8
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64 + ctx.f[8].f64) as f32) as f64);
	// 82FCBA94: 7D7B252E  stfsx f11, r27, r4
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[4].u32), tmp.u32) };
	// 82FCBA98: 7D1A5C2E  lfsx f8, r26, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82FCBA9C: ED0807F2  fmuls f8, f8, f31
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[31].f64) as f32) as f64);
	// 82FCBAA0: ED4042BA  fmadds f10, f0, f10, f8
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[10].f64 + ctx.f[8].f64) as f32) as f64);
	// 82FCBAA4: ED29D82A  fadds f9, f9, f27
	ctx.f[9].f64 = ((ctx.f[9].f64 + ctx.f[27].f64) as f32) as f64;
	// 82FCBAA8: ED6B57BA  fmadds f11, f11, f30, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[30].f64 + ctx.f[10].f64) as f32) as f64);
	// 82FCBAAC: 7D7A252E  stfsx f11, r26, r4
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[4].u32), tmp.u32) };
	// 82FCBAB0: FD604E5E  fctidz f11, f9
	ctx.f[11].s64 = if ctx.f[9].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[9].f64.trunc() as i64 };
	// 82FCBAB4: D9610070  stfd f11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[11].u64 ) };
	// 82FCBAB8: 811C0008  lwz r8, 8(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCBABC: 7D08F214  add r8, r8, r30
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[30].u64;
	// 82FCBAC0: 88E10077  lbz r7, 0x77(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(119 as u32) ) } as u64;
	// 82FCBAC4: 98E8FFFF  stb r7, -1(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(-1 as u32), ctx.r[7].u8 ) };
	// 82FCBAC8: 811C0008  lwz r8, 8(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCBACC: 7D7B242E  lfsx f11, r27, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FCBAD0: ED6BD82A  fadds f11, f11, f27
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[27].f64) as f32) as f64;
	// 82FCBAD4: FD605E5E  fctidz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[11].f64.trunc() as i64 };
	// 82FCBAD8: D9610070  stfd f11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[11].u64 ) };
	// 82FCBADC: 7D08F214  add r8, r8, r30
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[30].u64;
	// 82FCBAE0: 88E10077  lbz r7, 0x77(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(119 as u32) ) } as u64;
	// 82FCBAE4: 98E8FFFE  stb r7, -2(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(-2 as u32), ctx.r[7].u8 ) };
	// 82FCBAE8: 7D7A242E  lfsx f11, r26, r4
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[4].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FCBAEC: 811C0008  lwz r8, 8(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCBAF0: ED6BD82A  fadds f11, f11, f27
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[27].f64) as f32) as f64;
	// 82FCBAF4: 7D08F214  add r8, r8, r30
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[30].u64;
	// 82FCBAF8: FD605E5E  fctidz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[11].f64.trunc() as i64 };
	// 82FCBAFC: D9610070  stfd f11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[11].u64 ) };
	// 82FCBB00: 88E10077  lbz r7, 0x77(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(119 as u32) ) } as u64;
	// 82FCBB04: 98E8FFFD  stb r7, -3(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(-3 as u32), ctx.r[7].u8 ) };
	// 82FCBB08: 41800064  blt 0x82fcbb6c
	if ctx.cr[0].lt {
	pc = 0x82FCBB6C; continue 'dispatch;
	}
	// 82FCBB0C: 38EA0002  addi r7, r10, 2
	ctx.r[7].s64 = ctx.r[10].s64 + 2;
	// 82FCBB10: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82FCBB14: 54E6103A  slwi r6, r7, 2
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82FCBB18: 7CE85A14  add r7, r8, r11
	ctx.r[7].u64 = ctx.r[8].u64 + ctx.r[11].u64;
	// 82FCBB1C: 7D062214  add r8, r6, r4
	ctx.r[8].u64 = ctx.r[6].u64 + ctx.r[4].u64;
	pc = 0x82FCBB20; continue 'dispatch;
            }
            0x82FCBB20 => {
    //   block [0x82FCBB20..0x82FCBB6C)
	// 82FCBB20: C168FFFC  lfs f11, -4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82FCBB24: ED6B07B2  fmuls f11, f11, f30
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[30].f64) as f32) as f64);
	// 82FCBB28: C1480004  lfs f10, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82FCBB2C: C1280000  lfs f9, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82FCBB30: C1070000  lfs f8, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82FCBB34: 38E7FFFC  addi r7, r7, -4
	ctx.r[7].s64 = ctx.r[7].s64 + -4;
	// 82FCBB38: ED6A5F3A  fmadds f11, f10, f28, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[28].f64 + ctx.f[11].f64) as f32) as f64);
	// 82FCBB3C: ED695F7A  fmadds f11, f9, f29, f11
	ctx.f[11].f64 = (((ctx.f[9].f64 * ctx.f[29].f64 + ctx.f[11].f64) as f32) as f64);
	// 82FCBB40: ED7F5A3A  fmadds f11, f31, f8, f11
	ctx.f[11].f64 = (((ctx.f[31].f64 * ctx.f[8].f64 + ctx.f[11].f64) as f32) as f64);
	// 82FCBB44: D168FFF8  stfs f11, -8(r8)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82FCBB48: 80DC0008  lwz r6, 8(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCBB4C: 3908FFFC  addi r8, r8, -4
	ctx.r[8].s64 = ctx.r[8].s64 + -4;
	// 82FCBB50: ED6BD82A  fadds f11, f11, f27
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[27].f64) as f32) as f64;
	// 82FCBB54: FD605E5E  fctidz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[11].f64.trunc() as i64 };
	// 82FCBB58: D9610070  stfd f11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[11].u64 ) };
	// 82FCBB5C: 88A10077  lbz r5, 0x77(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(119 as u32) ) } as u64;
	// 82FCBB60: 7CA651AE  stbx r5, r6, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[6].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u8) };
	// 82FCBB64: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82FCBB68: 4080FFB8  bge 0x82fcbb20
	if !ctx.cr[0].lt {
	pc = 0x82FCBB20; continue 'dispatch;
	}
	pc = 0x82FCBB6C; continue 'dispatch;
            }
            0x82FCBB6C => {
    //   block [0x82FCBB6C..0x82FCBB98)
	// 82FCBB6C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCBB70: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 82FCBB74: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCBB78: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCBB7C: 80FC0008  lwz r7, 8(r28)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCBB80: 82CA001C  lwz r22, 0x1c(r10)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCBB84: 814A0020  lwz r10, 0x20(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82FCBB88: 7CD631D6  mullw r6, r22, r6
	ctx.r[6].s32 = ((ctx.r[22].s32 as i64 * ctx.r[6].s32 as i64) as i32);
	ctx.r[6].s64 = ctx.r[6].s32 as i64;
	// 82FCBB8C: 7D465214  add r10, r6, r10
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	// 82FCBB90: 7D4A2A14  add r10, r10, r5
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[5].u64;
	// 82FCBB94: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	pc = 0x82FCBB98; continue 'dispatch;
            }
            0x82FCBB98 => {
    //   block [0x82FCBB98..0x82FCBBC4)
	// 82FCBB98: 88C70000  lbz r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCBB9C: 3508FFFF  addic. r8, r8, -1
	ctx.xer.ca = (ctx.r[8].u32 > (!(-1 as u32)));
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82FCBBA0: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82FCBBA4: 98CA0000  stb r6, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u8 ) };
	// 82FCBBA8: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCBBAC: 80C6001C  lwz r6, 0x1c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 82FCBBB0: 7D465214  add r10, r6, r10
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	// 82FCBBB4: 4082FFE4  bne 0x82fcbb98
	if !ctx.cr[0].eq {
	pc = 0x82FCBB98; continue 'dispatch;
	}
	// 82FCBBB8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 82FCBBBC: 7F09B800  cmpw cr6, r9, r23
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[23].s32, &mut ctx.xer);
	// 82FCBBC0: 4198FD58  blt cr6, 0x82fcb918
	if ctx.cr[6].lt {
	pc = 0x82FCB918; continue 'dispatch;
	}
	pc = 0x82FCBBC4; continue 'dispatch;
            }
            0x82FCBBC4 => {
    //   block [0x82FCBBC4..0x82FCBBD4)
	// 82FCBBC4: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82FCBBC8: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82FCBBCC: 4BCE2155  bl 0x82cadd20
	ctx.lr = 0x82FCBBD0;
	sub_82CADCEC(ctx, base);
	// 82FCBBD0: 4BCDD870  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82FCBBD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82FCBBD8 size=508
    let mut pc: u32 = 0x82FCBBD8;
    'dispatch: loop {
        match pc {
            0x82FCBBD8 => {
    //   block [0x82FCBBD8..0x82FCBCC4)
	// 82FCBBD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82FCBBDC: 4BCDD81D  bl 0x82ca93f8
	ctx.lr = 0x82FCBBE0;
	sub_82CA93D0(ctx, base);
	// 82FCBBE0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82FCBBE4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82FCBBE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82FCBBEC: 83980000  lwz r28, 0(r24)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCBBF0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82FCBBF4: 419A01D8  beq cr6, 0x82fcbdcc
	if ctx.cr[6].eq {
	pc = 0x82FCBDCC; continue 'dispatch;
	}
	// 82FCBBF8: 895E0008  lbz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCBBFC: 897E000A  lbz r11, 0xa(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(10 as u32) ) } as u64;
	// 82FCBC00: 893E0007  lbz r9, 7(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(7 as u32) ) } as u64;
	// 82FCBC04: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82FCBC08: 895E0006  lbz r10, 6(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(6 as u32) ) } as u64;
	// 82FCBC0C: 891E000B  lbz r8, 0xb(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(11 as u32) ) } as u64;
	// 82FCBC10: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82FCBC14: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCBC18: A0FE0004  lhz r7, 4(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCBC1C: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82FCBC20: 895E0009  lbz r10, 9(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(9 as u32) ) } as u64;
	// 82FCBC24: 5526D1BE  srwi r6, r9, 6
	ctx.r[6].u32 = ctx.r[9].u32.wrapping_shr(6);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82FCBC28: 837C0004  lwz r27, 4(r28)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCBC2C: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82FCBC30: 554A083E  rotlwi r10, r10, 1
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(1)) as u64;
	// 82FCBC34: 7D6B4278  xor r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[8].u64;
	// 82FCBC38: 7D6B3A78  xor r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[7].u64;
	// 82FCBC3C: 7D6B3278  xor r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[6].u64;
	// 82FCBC40: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82FCBC44: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82FCBC48: 7D7DD838  and r29, r11, r27
	ctx.r[29].u64 = ctx.r[11].u64 & ctx.r[27].u64;
	// 82FCBC4C: 1D7D0014  mulli r11, r29, 0x14
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FCBC50: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82FCBC54: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82FCBC58: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCBC5C: 2F0BFFFE  cmpwi cr6, r11, -2
	ctx.cr[6].compare_i32(ctx.r[11].s32, -2, &mut ctx.xer);
	// 82FCBC60: 419A016C  beq cr6, 0x82fcbdcc
	if ctx.cr[6].eq {
	pc = 0x82FCBDCC; continue 'dispatch;
	}
	// 82FCBC64: 895F000C  lbz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FCBC68: 897F000E  lbz r11, 0xe(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(14 as u32) ) } as u64;
	// 82FCBC6C: 893F000B  lbz r9, 0xb(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(11 as u32) ) } as u64;
	// 82FCBC70: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82FCBC74: 895F000A  lbz r10, 0xa(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	// 82FCBC78: 891F000F  lbz r8, 0xf(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(15 as u32) ) } as u64;
	// 82FCBC7C: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82FCBC80: 893F000D  lbz r9, 0xd(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(13 as u32) ) } as u64;
	// 82FCBC84: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCBC88: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82FCBC8C: A15F0008  lhz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCBC90: 5529083E  rotlwi r9, r9, 1
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 82FCBC94: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82FCBC98: 54E6D1BE  srwi r6, r7, 6
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shr(6);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82FCBC9C: 7D6B4278  xor r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[8].u64;
	// 82FCBCA0: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82FCBCA4: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82FCBCA8: 7D6B3278  xor r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[6].u64;
	// 82FCBCAC: 7D6B3A78  xor r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[7].u64;
	// 82FCBCB0: 7D6BD838  and r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[27].u64;
	// 82FCBCB4: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82FCBCB8: 409A0114  bne cr6, 0x82fcbdcc
	if !ctx.cr[6].eq {
	pc = 0x82FCBDCC; continue 'dispatch;
	}
	// 82FCBCBC: 7FBAEB78  mr r26, r29
	ctx.r[26].u64 = ctx.r[29].u64;
	// 82FCBCC0: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	pc = 0x82FCBCC4; continue 'dispatch;
            }
            0x82FCBCC4 => {
    //   block [0x82FCBCC4..0x82FCBD30)
	// 82FCBCC4: 895F000C  lbz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FCBCC8: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82FCBCCC: 897F000E  lbz r11, 0xe(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(14 as u32) ) } as u64;
	// 82FCBCD0: 893F000B  lbz r9, 0xb(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(11 as u32) ) } as u64;
	// 82FCBCD4: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82FCBCD8: 895F000A  lbz r10, 0xa(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(10 as u32) ) } as u64;
	// 82FCBCDC: 891F000F  lbz r8, 0xf(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(15 as u32) ) } as u64;
	// 82FCBCE0: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82FCBCE4: 893F000D  lbz r9, 0xd(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(13 as u32) ) } as u64;
	// 82FCBCE8: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82FCBCEC: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82FCBCF0: A15F0008  lhz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCBCF4: 5529083E  rotlwi r9, r9, 1
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(1)) as u64;
	// 82FCBCF8: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82FCBCFC: 54E6D1BE  srwi r6, r7, 6
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shr(6);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82FCBD00: 7D6B4278  xor r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[8].u64;
	// 82FCBD04: 7D6B4A78  xor r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[9].u64;
	// 82FCBD08: 7D6B5278  xor r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[10].u64;
	// 82FCBD0C: 7D6B3278  xor r11, r11, r6
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[6].u64;
	// 82FCBD10: 7D6B3A78  xor r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 ^ ctx.r[7].u64;
	// 82FCBD14: 7D6BD838  and r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 & ctx.r[27].u64;
	// 82FCBD18: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82FCBD1C: 409A0014  bne cr6, 0x82fcbd30
	if !ctx.cr[6].eq {
	pc = 0x82FCBD30; continue 'dispatch;
	}
	// 82FCBD20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82FCBD24: 4BF9606D  bl 0x82f61d90
	ctx.lr = 0x82FCBD28;
	sub_82F61D90(ctx, base);
	// 82FCBD28: 546B063F  clrlwi. r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82FCBD2C: 40820024  bne 0x82fcbd50
	if !ctx.cr[0].eq {
	pc = 0x82FCBD50; continue 'dispatch;
	}
	pc = 0x82FCBD30; continue 'dispatch;
            }
            0x82FCBD30 => {
    //   block [0x82FCBD30..0x82FCBD50)
	// 82FCBD30: 7FB9EB78  mr r25, r29
	ctx.r[25].u64 = ctx.r[29].u64;
	// 82FCBD34: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCBD38: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 82FCBD3C: 419A0090  beq cr6, 0x82fcbdcc
	if ctx.cr[6].eq {
	pc = 0x82FCBDCC; continue 'dispatch;
	}
	// 82FCBD40: 1D7D0014  mulli r11, r29, 0x14
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FCBD44: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82FCBD48: 3BEB0008  addi r31, r11, 8
	ctx.r[31].s64 = ctx.r[11].s64 + 8;
	// 82FCBD4C: 4BFFFF78  b 0x82fcbcc4
	pc = 0x82FCBCC4; continue 'dispatch;
            }
            0x82FCBD50 => {
    //   block [0x82FCBD50..0x82FCBDA8)
	// 82FCBD50: 3920FFFE  li r9, -2
	ctx.r[9].s64 = -2;
	// 82FCBD54: 7F1AE800  cmpw cr6, r26, r29
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[29].s32, &mut ctx.xer);
	// 82FCBD58: 409A0050  bne cr6, 0x82fcbda8
	if !ctx.cr[6].eq {
	pc = 0x82FCBDA8; continue 'dispatch;
	}
	// 82FCBD5C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCBD60: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82FCBD64: 419A0054  beq cr6, 0x82fcbdb8
	if ctx.cr[6].eq {
	pc = 0x82FCBDB8; continue 'dispatch;
	}
	// 82FCBD68: 1D6B0014  mulli r11, r11, 0x14
	ctx.r[11].s32 = ((ctx.r[11].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FCBD6C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82FCBD70: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82FCBD74: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 82FCBD78: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82FCBD7C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82FCBD80: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82FCBD84: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82FCBD88: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82FCBD8C: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82FCBD90: 810B0014  lwz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82FCBD94: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 82FCBD98: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82FCBD9C: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82FCBDA0: 7D5F5378  mr r31, r10
	ctx.r[31].u64 = ctx.r[10].u64;
	// 82FCBDA4: 48000014  b 0x82fcbdb8
	pc = 0x82FCBDB8; continue 'dispatch;
            }
            0x82FCBDA8 => {
    //   block [0x82FCBDA8..0x82FCBDB8)
	// 82FCBDA8: 1D790014  mulli r11, r25, 0x14
	ctx.r[11].s32 = ((ctx.r[25].s32 as i64 * 20 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82FCBDAC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCBDB0: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82FCBDB4: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82FCBDB8; continue 'dispatch;
            }
            0x82FCBDB8 => {
    //   block [0x82FCBDB8..0x82FCBDCC)
	// 82FCBDB8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82FCBDBC: 81580000  lwz r10, 0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCBDC0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82FCBDC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82FCBDC8: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82FCBDCC; continue 'dispatch;
            }
            0x82FCBDCC => {
    //   block [0x82FCBDCC..0x82FCBDD4)
	// 82FCBDCC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82FCBDD0: 4BCDD678  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


